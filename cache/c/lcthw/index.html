<!DOCTYPE html> 
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="google-site-verification" content="fB00vw3NhrcDODZ6PcjUHM1Pz1j4T-eZ0Ja7ffDx-aU" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="alternate" href="/index.xml" type="application/rss+xml" title="Hello World">
    <link rel="icon" href="https://harryho.github.io/favicon.ico">
    <title>LCTHW - Hello World</title>
    
    <link rel="stylesheet" href="https://harryho.github.io/css/highlight/github.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/theme.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/bootie-docs.css">
</head>

<body role="document">
    
    <nav class="navbar navbar-inverse navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://harryho.github.io/">Hello World</a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li ><a href="https://harryho.github.io/">Home</a></li>
                       
                    <li ><a href="https://harryho.github.io/info/">Info</a></li>
                     
                    <li ><a href="https://harryho.github.io/code/">Code</a></li>
                     
                    <li ><a href="https://harryho.github.io/dev/">Dev</a></li>
                     
                    <li ><a href="https://harryho.github.io/os/">OS</a></li>
                     
                    <li ><a href="https://harryho.github.io/project/">Project</a></li>
                      
                </ul>
                
                <form class="navbar-form navbar-left" role="search" action="https://www.google.co.jp/search" method="get">
                    <div class="input-group doc-search-form">
                        <input type="hidden" name="as_sitesearch" value="harryho.github.io">
                        <input type="text" name="as_q" class="search-query doc-search-input-text" placeholder="Search Site">
                        <span class="input-group-addon input-group-btn doc-search-input-btn " >
							<button class="btn" type="submit"><span class="glyphicon glyphicon-search"></span></button>
                        </span>
                    </div>
                </form>
                
            </div>
            
        </div>
    </nav>
    <div class="container">


<div class="row">
	<div class="col-sm-8 doc-main">
		<main role="main">
			<article>
				<a id="title"></a>
				<h1 class="doc-entry-title">LCTHW</h1>
				<div class="doc-entry-meta">
					
				</div>
				<section>
					<p>Acknowledgment</p>

<p>I would like to thank three kinds of people who helped make this boo kwhat itis today: thehaters, thehelpers, and the painters.</p>

<p>The hatershelpedmakethis book stronger and more solid through theirinflexibility of mind, irrationalheroworship ofold C gods,and complete lack of pedagogical expertise. Without their shining example of whatnotto be,I wouldhave never worked so hard to make thisbook a completeintroduction to becoming a better programmer.</p>

<p>The helpers are Debra WilliamsCauley, Vicki Rowland, Elizabeth Ryan,the whole teamatAddison-Wesley, and everyoneonline who sent in fixes and suggestions. Their work producing,fixing, editing, and improving this bookhas formed it into a more professionaland better piece ofwriting.</p>

<p>The painters, Brian, Arthur, Vesta,and Sarah,helped me finda new way to express myself and to distract mefrom deadlines that Deb and Vicki clearly set for mebut that I keptmissing. Without painting andthe gift ofart these artists gaveme,I would havea less meaningful and rich life.
Thankyouto all ofyoufor helpingme write thisbook. It maynotbeperfect,because no bookisperfect,butit’s at least asgood asIcan possibly makeit.</p>

<p>ThisBook Is Not Really about C</p>

<p>Please don’t feel cheated, but this book is not about teaching you C programming. You’ll learnto write programs inC, but the most important lesson you’ll get fromthis bookis rigorous defensive programming. Today, too many programmerssimply assume thatwhat they write works, butone dayit will fail catastrophically. Thisis especially true ifyou’re the kind ofperson who has learned mostly modern languages that solvemany problems for you. By reading this bookand following my exercises, you’ll learn how to createsoftware that defends itself frommalicious activity and defects.
I&rsquo;m using C for a very specific reason: C is broken. Itis fullof design choices thatmade sense inthe 1970s butmakezero sense now. Everything from its unrestricted, wild use of pointersto its severely broken NUL terminatedstrings are to blame for nearly allof the security defects that hitC. It’s mybelief thatC is so broken that, while it’s in wide use, it’sthe most difficult languageto write securely. I wouldfathomthat Assembly is actually easierto write securely than C. To be honest,and you’ll find out thatI&rsquo;m very honest,I don’t think that anybody shouldbe writing newCcode.</p>

<p>Ifthat’sthe case, then why am Iteaching you C? Because I want you to become a better,stronger programmer, and there are tworeasonswhy C is an excellent language to learn if you wantto get better. First, C’s lackof nearly every modern safety feature means you have tobe more vigilant and moreaware of what’s goingon. If you can write secure, solid C code, you can write secure, solid codein any programminglanguage. The techniquesyou learn will translate toeverylanguage you use fromnowon.
Second, learning C givesyou direct accessto amountain of legacycode, and teachesyou the base syntax of alarge number ofdescendant languages. Onceyoulearn C, you can more easilylearn C++, Java, Objective-C, and JavaScript,and evenother languages becomeeasier to learn.</p>

<p>I don’t wantto scare you away by tellingyou this, because Iplan tomakethis book incredibly fun,easy, and devious. I&rsquo;ll makeit fun to learn C bygiving you projects that you mightnot havedone inother programming languages. I&rsquo;ll makethis bookeasyby using myprovenpattern of exercisesthat has you doing C programming andbuilding your skills slowly. I&rsquo;ll make it devious by teaching you how to break and thensecure your codeso you understandwhy these issues matter. You’ll learn howto cause stack overflows, illegal memory access, andother common flawsthat plagueC programs so thatyou knowwhatyou’re up against.
Gettingthrough thisbook will be challenging, likeall of mybooks,but when you’re done youwillbea far better and moreconfident programmer.</p>

<p>The Undefined Behaviorists</p>

<p>By thetimeyou’re done with this book, you’ll beable to debug, read, andfixalmost any C program youruninto, and then write new,solid C codeshould youneed to. However, I&rsquo;m notreally goingto teach you official C. You’ll learnthe language, and you’ll learn how touseit well, but official C isn’t very secure. The vast majorityof C programmers out there simplydon’t write solid code, and it’s becauseof something called Undefined Behavior (UB). UB is apartof the American NationalStandards Institute (ANSI)Cstandard thatlists all ofthe ways that a C compiler can disregard whatyou’vewritten. There’s actually a part of the standard thatsays if you write code likethis,thenallbets are off and the compiler doesn’thave to do anything consistently. UB occurs when aCprogram reads offthe end of astring, which is an incredibly common programming error in C. For a bitof background, C defines strings as blocks of memory that end inaNUL byte, or a0 byte(to simplify the definition). Since many strings come from outside the program, it’s common for a C programto receive astring without thisNULbyte. When it does, theCprogram attempts toread pastthe end ofthis string and into the memory of the computer, causing your program to crash. Every other language developed after Cattempts to preventthis, butnot C. C does so little toprevent UB thateveryCprogrammer seems to think it meansthey don’thave to deal with it. They write code full of potential NUL byte overruns, and when you pointthemout to theseprogrammers, they say, “Well that’s UB, andI don’thave to prevent it.” This reliance onC’s largenumber ofUBsiswhy most C codeis so horriblyinsecure.</p>

<p>I write C codeto try to avoid UB byeither writing code thatdoesn’t trigger it, or writing codethat attemptsto preventit. Thisturnsoutto be an impossible task because there is so much UB thatit becomes aGordian knot of interconnected pitfallsin your C code. As you go through this book, I’llpoint out ways you can trigger UB, how to avoid it if youcan,and how to trigger itin other people’s codeif possible. However, you should keepin mindthat avoiding thenearly random nature of UB is almost impossible,and you’ll just haveto do yourbest.</p>

<p>Warning!</p>

<p>You’ll find that hardcore C fans frequently will tryto beatyou up about UB. There’s aclass of C programmerswho don’twrite very much C codebut have memorizedall ofthe UB just so theycould beatup abeginner intellectually. If you run into oneof these abusive programmers, please ignore them. Often, they aren’t practicing C programmers, they are arrogant, abusive,and will only endup asking you endlessquestions in anattempt to prove their superiority rather than helpingyouwith yourcode. Should you everneed help with yourC code,simply email me at help@learncodethehardway
and I willgladly help you.</p>

<p>C Is a Pretty and Ugly Language</p>

<p>The presenceof UBthoughis one more reason why learning Cisa goodmoveif you wantto be abetter programmer. If you can write good, solid Ccode inthe way I teachyou, then youcan survive any language. Onthe positiveside, C is a really elegant languagein many ways. Its syntax is actually incrediblysmall given the power ithas. There’s a reason why so many other languages havecopieditssyntax over the last45 orsoyears. Calso givesyouquitea lot using very little technology. When you’re donelearningC, you’ll have anappreciation for asomething thatisvery elegant andbeautifulbutalso alittleugly atthe same time. C isold, so likea beautiful monument,itwilllook fantastic from about 20feet away, but when youstep up close, you’ll seeallthe cracks and flaws ithas. Because ofthis, I&rsquo;m going to teach you themostrecent versionof C thatI can make work with recent compilers. It’s apractical, straightforward, simple, yet completesubset of Cthat works well,works everywhere, andavoidsmany pitfalls. This is the C that I use to getreal workdone, and notthe encyclopedic version ofCthat hardcore fans try and fail touse. I know the Cthat I useis solid because Ispent two decades writingclean,solidC codethat powered large operations without much failureatall. My Ccode has probably processedtrillions oftransactionsbecause it poweredthe operations of companieslike Twitterand airbnb. Itrarely failed or had security attacks against it. In the many years thatmy code poweredthe Ruby onRails Web world, it’s run beautifully and even prevented security attacks, while other Webserversfell repeatedly to thesimplest of attacks.</p>

<p>My style of writingCcode is solid,but moreimportantly, mymind-setwhenwriting C is one every programmer should have. I approachC, and any programming, with the ideaof preventing errors asbest I can andassuming thatnothingwillwork right. Other programmers,even supposedly good C programmers, tend to write codeand assumeeverything will work, butrelyon UB or the operatingsystemto save them,neither of which will work as asolution. Just remember that ifpeopletryto tellyou that the code I teach in this book isn’t “realC.” If theydon’t have the same track record as me, maybe you can use whatI teach you to show them why their code isn’t very secure.
Does that meanmycode is perfect? No,not at all. This is C code. Writing perfectC codeis impossible, andin fact, writing perfectcode in any language is impossible.</p>

<p>That’s half thefunand frustration ofprogramming. I could takesomeone else’s codeand tearitapart, and someone couldtake mycode and tear it apart. All code is flawed, butthe difference is thatItryto assumemy code is always flawedand then preventthe flaws. My gift to you,should you completethis book, isto teachyou the
defensive programming mind-set thathasservedme wellfortwo decades,and has helped memake high-quality, robustsoftware.</p>

<p>What You Will Learn</p>

<p>The purposeof thisbook isto get you strongenough inC thatyou’llbeable to write your own software with it or modify someoneelse’s C code. Afterthis book, you should read Brian Kernighan and DennisRitchie’s The C Programming Language, SecondEdition (Prentice Hall, 1988),abookby the creators of the C language, also called K&amp;R C.WhatI’ll teach you is
• The basics of Csyntax and idioms</p>

<p>• Compilation, make files, linkers</p>

<p>• Findingbugs and preventingthem</p>

<p>• Defensive coding practices</p>

<p>• Breaking C code</p>

<p>• Writing basic UNIX systemssoftware</p>

<p>By the final exercise, you will havemorethanenough ammunition totackle basic systemssoftware, libraries, and othersmaller projects.</p>

<p>How to Read This Book</p>

<p>This book is intended for programmerswho have learned at least one other programming language. I refer you to my book Learn Python the Hard Way (Addison-Wesley, 2013) if you haven’tlearned a programming language yet. It’s meant for beginners and works very well as a first book onprogramming. Once you’vecompleted Learn Python the Hard Way,then you can comeback andstart this book.</p>

<p>For those who’vealready learned tocode, this book mayseem strange at first. It’s notlike otherbookswhere you read paragraph after paragraph of prose and then typein abitof codehere and there. Instead, there are videos oflecturesforeach exercise, you code right away, andthen Iexplain what you just did. This works better becauseit’s easierfor me toexplain something you’vealready done thanto speak inan abstract sense about something you aren’t familiar with at all.</p>

<p>Because ofthis structure, there are afew rules that you must followin this book:
• Watch the lecturevideo first,unless theexercise says otherwise.</p>

<p>• Type in all ofthe code. Don’tcopy-paste!</p>

<p>• Type in the code exactly asitappears, even the comments.</p>

<p>• Getit to run andmake sure itprints the same output.</p>

<p>• If there are bugs,fix them.</p>

<p>• Dothe Extra Credit,but it’sallright toskip anything you can’t figureout.</p>

<p>• Always try tofigure it outfirstbefore trying to get help.</p>

<p>If youfollowtheserules, do everythingin the book, and stillcan’tcode C,then you at least tried. It’snotfor everyone, but justtryingwill makeyoua better programmer.</p>

<p>The Videos</p>

<p>Included in this course are videos for every exercise,and in many cases,more thanone video for an exercise. These videos should beconsidered essentialto get thefull impact ofthe book’seducational method. The reason for this is that many of theproblems with writing C codeare interactive issues with failure, debugging, and commands. C requiresmuch more interaction toget thecode running and to fix problems, unlike languages likePython and Rubywherecode just runs. It’s alsomuch easier to showyoua videolectureon a topic,such aspointers or memory management, where I can demonstratehowthe machine is actuallyworking.</p>

<p>I recommend thatas you go through the course, you plan to watch thevideosfirst, and thendo theexercises unless directedto do otherwise. In someof theexercises, I use onevideoto present a problem andthenanother to demonstratethe solution. In most ofthe other exercises, I use avideo to present a lecture, and then you do the exerciseand complete it to learn the topic.</p>

<p>The Core Competencies</p>

<p>I&rsquo;m going to guessthat you haveexperience using a lesser language. One of those usable languages that lets you get away with sloppy thinking and half-baked hackery like Python or Ruby. Or, maybe you use a languagelike LISPthat pretendsthe computer is somepurely functional fantasy land with padded walls forlittlebabies. Maybe you’velearned Prolog, and you think theentireworld should just be adatabase where you walkaround in it looking for clues. Even worse,I&rsquo;m bettingyou’ve been using anintegrated development environment (IDE), so your brainis riddled with memory holes, and you can’t eventypean entire function’s name without hitting CTRL­SPACE after every three characters.
No matter whatyour background is,you could probably use some improvementin these areas:
Reading and Writing</p>

<p>This is especially true if you use an IDE, but generally I find programmers do too much skimmingand have problems reading for comprehension. They’ll just skim code that theyneed to understand indetailwithout taking thetimeto understand it. Other languagesprovide tools thatletprogrammers avoid actually writingany code, so when facedwitha languagelike C,they break down. The simplest thingto do is just understand that everyone has this problem, and you can fix itby forcing yourself to slow down and be meticulous about your readingand writing. At first, it’ll feelpainfuland annoying, buttake frequent breaks,and then eventually it’ll be easierto do.</p>

<p>Attention to Detail</p>

<p>Everyoneis bad at this, and it’sthe biggest cause of bad software. Otherlanguages let you get awaywithnotpaying attention,but C demandsyour full attention becauseit’s rightin the machine, and the machine is very picky. With C,there is no “kind of similar” or “close enough,” so you need topay attention. Doublecheck your work. Assume everythingyouwrite is wronguntil youprove it’s right.
Spotting Differences</p>

<p>A keyproblem thatpeople who are used to other languages have isthattheir brains havebeen trainedto spotdifferences in that language, not in C. Whenyou comparecode you’ve written to my exercise code, your eyes will jump rightover characters you thinkdon’t matter or thataren’t familiar. I&rsquo;ll be giving you strategies thatforceyouto seeyour mistakes,butkeep in mind thatif your code is not exactly like thecode in this book, it’swrong.</p>

<p>Planning and Debugging</p>

<p>I love other, easier languages because Icanjust hang out. I can type the ideas Ihave into their interpreter and see results immediately. They’re great for justhacking out ideas, buthave you noticed thatif you keep doing hack until it works, eventually nothing works?C is harderon you because itrequires you to first plan outwhat you want to create. Sure, you canhack for abit, but youhave toget serious much earlier in Cthan in otherlanguages. I&rsquo;ll be teaching you waysto plan out key parts of your program beforeyou start coding, and this will likelymake you a better programmer at the same time. Even justa little planning can smooth things outdown the road.</p>

<p>Learning C makes you a better programmer because you are forcedto deal with these issues earlierand more frequently. You can’t be sloppy aboutwhat you write ornothingwillwork. The advantageof C is thatit’s a simple languagethat you can figureouton your own, which makesit agreat languageforlearningabout the machineand getting stronger in thesecore programming skills.</p>

<p>Exercise0. The Setup</p>

<p>The traditionalfirstexercise, Excercise0, is where you set up your computer for therest ofthis book. In this exercise you’ll install packagesand softwaredepending onthe typeof computeryouhave.</p>

<p>If youhave problems following this exercise, then simplywatch the Exercise
0
video for yourcomputer and follow along with mysetup instructions. Thatvideo should demonstrate howto do each step and helpyousolve any problemsthat might comeup.
Linux
Linux ismostlikely the easiest system to configure for C development. For Debian systems yourunthis command from the command line:</p>

<p><code>$ sudo apt-get install build -essential</code></p>

<p>Here’s how youwould install</p>

<p>the samesetup onan RPM-based Linux like Fedora, RedHat,or CentOS7:</p>

<p><code>$ sudo yum groupinstall development-tools</code></p>

<p>If youhave adifferent variant ofLinux, simplysearch for “c development tools” and your brand of Linux to find out what’s required. Onceyou havethat installed, you should beable to type: <code>$ cc --version</code> to see whatcompiler was installed. You will most likely havethe GNU C Compiler (GCC)installed but don’tworryif it’sa different onefrom what I use inthe book. You could also try installing the Clang C compiler using the Clang’s Getting Started instructions for yourversion ofLinux, or searchingonline if those don’twork.</p>

<p>Mac OS X</p>

<p>On MacOS X, the installis even easier. First,you’llneed to either download the latest XCode from Apple,or find your installDVD andinstall it from there. The download will be massiveand could take forever, so I recommend installing from the DVD.</p>

<p>Also, search online for “installing xcode” for instructionson how to do it. You can also use theApp Storeto install it justas you wouldany other app, and if you do itthat wayyou’ll receive updates automatically.</p>

<p>To confirm that your C compiler is working, type this:
<code>$ cc --version</code></p>

<p>You should see thatyou are using aversion of the Clang C Compiler, butif your XCode is older you mayhave GCC installed. Either is fine.
Windows</p>

<p>For Microsoft Windows, I recommend you usethe Cygwin system to acquire many ofthe standard UNIX software development tools. It should be easy to install and use, but watch the videos for thisexercise tosee how I doutC support in their development tools,soyou may have problems using Microsoft’s compilers to build the codein this book.  it. An alternative to Cygwin is the MinGW system; it is more minimalist but should also work. I will warn you that Microsoft seems to be phasing.</p>

<p>A slightly more advanced optionisto use VirtualBoxto install aLinuxdistribution and run a complete Linux systemon yourWindows computer. This has the added advantagethat you can completely destroy this virtualmachine without worrying about destroying your Windows configuration. It’s also an opportunity to learn to use Linux, which is both fun andbeneficialto your development as a programmer. Linux is currently deployed as the main operating system for many distributed computer and cloudinfrastructure companies. Learning Linux will definitely improveyour knowledge of the future of computing.</p>

<p>Text Editor</p>

<p>The choice of text editor for a programmer is a tough one. For beginners, I say just use Gedit since it’s simple andit works for code. However, it doesn’t work in certain international situations,and if you’ve been programming for a while, chances are you already have a favorite text editor.</p>

<p>With this in mind, I want you to try out a few of the standard programmer text editors for your platformand then stick with the one that you like best. If you’ve been using GEdit and like it, then stick with it. If you want to try something different, then try it out real quick and pick one.</p>

<p>The mostimportantthing is do not get stuck trying to pick the perfect editor. Text editors alljust kind of suck in odd ways. Just pick one, stick with it, and if youfind something else you like, try it out. Don’t spend days onend configuringit and making it perfect.</p>

<p>Some text editors totryout:</p>

<p>• GEdit onLinux and OS X.</p>

<p>• TextWrangler on OS X.</p>

<p>• Nano, which runs in Terminaland works nearly everywhere.</p>

<p>• Emacs and Emacs for OSX; be prepared to do somelearning, though.</p>

<p>• Vim andMacVim.</p>

<p>There is probablya different editorforeveryperson out there,but theseare just a few ofthe freeones thatI know work. Try out a fewof these —and maybe some commercialones—until you find onethat you like.</p>

<p>Do Not Use an IDE</p>

<p>Warning!</p>

<p>Avoidusing an integrated development environment(IDE) while you are learning a language. They are helpful when you need to get things done,but their help tendsalso to prevent youfrom really learning the language. In my experience,the stronger programmers don’tusean IDE and also have no problem producing codeatthe same speed as IDE users. I alsofind that thecode produced with an IDEis of lower quality. Ihave noidea why thatis the case, but if you want deep, solid skillsin a programming language, Ihighly recommend thatyou avoid IDEswhile you’re learning.</p>

<p>Knowing how touse a professional programmer’s text editorisalsoauseful skill in your professionallife. When you’re dependent onan IDE, you haveto wait for a new IDE before you can learn the newer programming languages. This addsa costtoyour career: It preventsyoufrom getting ahead of shifts in language popularity. With a generic text editor, you can code in anylanguage, any time you like, without waiting for anyone to addit to an IDE. A generic text editor meansfreedom to explore on yourown andmanage your career as you see fit.</p>

<p>Exercise1. Dust Off That Compiler</p>

<p>After you haveeverything installed, you needto confirm thatyour compiler works. The easiest way todo that is to writea C program. Since you should alreadyknow at least oneprogramming language, I believeyou can startwitha small but extensive example.</p>

<p>ex1.c</p>

<pre><code class="language-c">

1 #include &lt;stdio.h&gt; 
2 
3 /* This is a comment. */ 
4 int main(int argc, char *argv[]) 
5 
6  {  int  distance  = 100;7  
8     //  this  is  also  a  comment  
9     printf(&quot;You  are  %d miles  away.\n&quot;, distance); 
11    return 0;
12 } 
</code></pre>

<p>If youhave problems getting the code up and running, watchthe video for this exercise to seeme doit first.</p>

<p>Breaking It Down</p>

<p>There area few features of the C languagein thiscode thatyou might ormightnot havefiguredoutwhile you weretyping it. I’llbreakthis down, lineby line, quickly, and then we can do exercises to understandeach partbetter. Don’tworryif you don’t understand everything in this breakdown. Iam simply givingyoua quickdive into C and promise you will learn all ofthese concepts later in the book.</p>

<p>Here’s aline-by-line description of the code:</p>

<p>ex1.c:1 An include, and itis the way to import thecontentsof one file into thissource file. C has a convention ofusing .h extensions for header files, which contain listsof functions to usein your program.</p>

<p>ex1.c:3 This is a multiline comment, and you could put as manylines oftext between the opening <code>/*</code> and closing <code>*/</code> characters asyou want.</p>

<p>ex1.c:4 A morecomplex version of the main function you’ve been using so far. How C programs workisthat the operatingsystem loadsyour program, and then itruns the function named main. For thefunction to be totally complete it needs toreturn an int and take two parameters: an int for the argumentcountand an array of char * strings for the arguments. Didthat just flyoveryour head? Don’tworry, we’ll cover this soon.</p>

<p>ex1.c:5 To startthe body of any function, you write a <code>{</code> character that indicates thebeginning ofa block. In Python, you just did a <code>:</code> and indented. In other languages, you might have a begin or do word tostart.</p>

<p>ex1.c:6 A variable declaration and assignmentatthe same time. Thisis how you create a variable, with the syntax type name = value;. InC, statements (exceptfor logic) end in a ;(semicolon) character.</p>

<p>ex1.c:8 Another kind of comment. It works like in Python or Ruby, where the comment starts atthe <code>//</code> and goes untilthe end of the line.</p>

<p>ex1.c:9 A callto your old friend printf.Likein many languages, function calls workwith the syntax name(arg1, arg2); andcanhave no argumentsor any number ofthem. The printf function is actually kind of weird in that it can take multiple arguments. You’ll seethat later.</p>

<p>ex1.c:11 Areturnfrom the main function that gives the operatingsystem (OS)your exitvalue. You maynot be familiar with how UNIX software uses returncodes, sowe’ll cover thatas well.</p>

<p>ex1.c:12 Finally, we end the main functionwith aclosing brace }character, andthat’sthe end of the program.</p>

<p>There’salot ofinformation in this breakdown, so study it lineby lineand make sure you at least havea grasp of what’s goingon. Youwon’t know everything,butyou can probably guessbefore we continue.</p>

<p>What You Should See</p>

<p>You can putthis into an ex1.c andthen run the commands shown here in this sample shelloutput. If you’re notsure how thisworks, watchthe video that goes with this exercise tosee me do it.</p>

<p>Exercise 1 Session</p>

<pre><code class="language-c">
$ make ex1 
cc -Wall ­
g ex1.c -o ex1 
$ ./ex1
 You are 100 miles away.
$ 
</code></pre>

<p>The first command make is a tool thatknowshowto build C programs (and many others). When you run it and giveit ex1 youare telling make to look forthe ex1.c file, run thecompiler to build it, and leavethe results in a filenamed ex1. This ex1 fileisanexecutable thatyou can run with ./ex1, which outputsyour results.</p>

<p>How to Break It</p>

<p>In this book, I&rsquo;mgoing to havea small section for each programteaching you howto break the program if it’s possible. I&rsquo;ll haveyou do odd things tothe programs, run them in weirdways,or change code so that you can seecrashes andcompiler errors.</p>

<p>For thisprogram, simplytry removingthings at random and still getitto compile. Just makea guessatwhatyou can remove, recompileit, and thensee what you get foran error.</p>

<p>Extra Credit</p>

<p>• Open the ex1 file in your text editorand change or delete random parts. Try running itand seewhat happens.</p>

<p>• Print outfivemore lines of textor something more complexthan “hello world.”</p>

<p>• Run man 3 printfand read about this function andmany others.</p>

<p>• Foreachline, write out the symbols youdon’t understand andsee if you can guess what theymean. Write a little chart on paper with your guesssoyou can check itlater tosee if you gotitright.</p>

<p>Exercise2. Using Makefiles to Build</p>

<p>We’re goingto use aprogram called make to simplify building your exercisecode. The make programhas been aroundfor averylongtime, and because ofthis it knows how to buildquitea few typesof software. In this exercise, I’llteach you just enough Makefile syntax to continuewith the course,and thenan exerciselater will teach you morecomplete Makefile usage.</p>

<p>Using Make</p>

<p>How make works is you declare dependencies, and thendescribe how to build them orrely on the program’s internalknowledge ofhowto build most common software. Ithas decades ofknowledge about buildinga wide variety offiles from other files. In the last exercise,you did this already using commands:</p>

<p>$ make ex1 # or this one too $ CFLAGS=&ldquo;-Wall&rdquo; make ex1</p>

<p>In the first command, you’re telling make, “I want a file named ex1to be created.” The programthen asks and does thefollowing:
1. Doesthe file ex1 exist already?</p>

<ol>
<li><p>No. Okay, is there anotherfile that starts with ex1. 3. Yes, it’scalled ex1.c. Do Iknow how to build .c files?</p></li>

<li><p>Yes, I run this command cc ex1.c -o ex1 to build them.</p></li>

<li><p>Ishall makeyouone ex1 by using cc to build itfrom ex1.c.</p></li>
</ol>

<p>The secondcommand in the listing above is a way topass modifiers tothe make command. If you’renot familiar with how the UNIX shellworks, you can create these environment variables thatwillget picked up by programs you run. Sometimes you do this with acommand like export CFLAGS=&ldquo;­Wall&rdquo; depending on the shellyou use. You can, however, alsojust put them beforethe command you wantto run,and that environment variable willbe set only while thatcommand runs.</p>

<p>In this example, I did CFLAGS=&ldquo;-Wall&rdquo; make ex1 so thatitwould addthe command line option -Wall to the cc commandthat make normallyruns. That command line optiontells the compiler cc to report all warnings (which, ina sick
twistof fate,isn’tactually all the warnings possible). You can actually getpretty farwithjust using make in thatway,butlet’s getinto makinga Makefile soyou can understand make a little better. Tostart off, createa filewithjust thefollowingin it.</p>

<p>ex2.1.mak
CFLAGS=-Wall -g
clean:
rm -f ex1</p>

<p>Save this file as Makefile in your current directory. The programautomatically assumes there’sa file called Makefile andwilljust run it.</p>

<p>Warning!
Makesure you are only entering TAB characters, not mixtures of TAB and spaces.</p>

<p>This Makefile is showing you somenew stuff with make.First,weset CFLAGS in thefile so weneverhave to set it again,as wellas adding the -g flag to getdebugging. Then, we havea section named clean that tells make how to cleanup our little project.
Make sure it’s in the same directory as your ex1.c file, and then run these commands:</p>

<p>$ make clean
$ make ex1</p>

<p>What You Should See</p>

<p>Ifthat worked, thenyou should see this:</p>

<p>Exercise 2 Session</p>

<pre><code class="language-c">
$ make clean 
rm -f ex1 
$ make ex1 
cc -Wall ­g ex1.c -o ex1 

ex1.c: In function 
'main': 

ex1.c:3: warning: 
implicit declaration 
of function 'puts' 

$ 
</code></pre>

<p>Hereyou cansee that I&rsquo;m running make clean, which tells make to run our clean target. Go lookatthe Makefile again andyou’ll seethat underthis command, I indentand then putin the shellcommandsIwant make to run for me. You couldput asmanycommands as you wanted in there, so it’sa great automationtool.</p>

<p>Warning!</p>

<p>If youfixed ex1.c to have #include <stdio.h>, then youroutput won’t have thewarning(which shouldreallybe an error) aboutputs. I havethe errorhere becauseIdidn’tfixit.
Notice thateven though we</p>

<p>don’tmention ex1 in the Makefile, make still knows how to buildit and use our specialsettings.
How to Break It
That shouldbeenough toget you started,but firstlet’s break this Makefile in a particular waysoyoucansee whathappens. Takethe line rm -f ex1 and removethe indent (move it allthe way left) so you can see what happens. Rerun make clean,and you shouldget something like this:</p>

<pre><code class="language-c">
$ make clean Makefile:4: *** missingseparator. Stop. 
</code></pre>

<p>Always rememberto indent, and if you get weird errors likethis,double check that you’re consistently using tab characters becausesome make variants areverypicky.</p>

<p>Extra Credit</p>

<p>• Create an all: ex1 target thatwillbuild ex1 with just the command make.</p>

<p>• Read man make to find out more informationon how to run it.</p>

<p>• Read man cc to find outmore information on what theflags ­</p>

<p>Wall and -g do.
• Research Makefiles online and seeif you can improve this one.</p>

<p>• Finda Makefile in anotherCproject and tryto understandwhat it’sdoing.</p>

<p>Exercise3. Formatted Printing
Keep that Makefile around since it’llhelp you spot errors, andwe’ll be adding to it when we needto automate more things.
Manyprogramming languages use theCway of formatting output, solet’s try it:</p>

<p>ex3.c</p>

<pre><code class="language-c">
1 #include &lt;stdio.h&gt; 

2 
3 int main() 
4 {
5 int age = 10;
6 int height = 72;
7 

8 printf(&quot;I am %d years old.\n&quot;, age); 
9 printf(&quot;I am %d inches tall.\n&quot;,height); 
1. 11 return 0;
12 } 
</code></pre>

<p>Once you’ve finished that, do the usual make ex3 tobuild and run it. Makesure you fix all warnings.</p>

<p>This exercisehasawholelot
goingon in a small amountof
code, so let’sbreak it down:</p>

<p>• First we’reincluding another header file called stdio.h. This tells thecompiler that you’re going tousethe standard Input/Output functions. One of those is printf.</p>

<p>• Then we’re using a variablenamed age and settingit to 10.</p>

<p>• Next we’re using a variable height and setting it to72. • Then we’readding the printf function to printthe age and height ofthe tallest10-year­oldon theplanet.</p>

<p>• In printf,you’ll notice we’re includinga format string, asseenin many other languages.</p>

<p>• After this format string, we’re putting in the variables that should be “replaced” into the format string by printf.</p>

<p>The result isgiving printfsomevariables andit’s constructing anew string and thenprinting itto the terminal.</p>

<p>What You Should See</p>

<p>When youdo thewhole build, you should see something like this:</p>

<p>Exercise 3 Session</p>

<pre><code class="language-c">
$ make ex3 
cc -Wall ­g ex3.c -o ex3 
$ ./ex3 
I  am  10  years  old.  
I  am  72  inches  tall.  
$  
</code></pre>

<p>PrettysoonI&rsquo;m going tostop tellingyou torun make and whatthe buildlookslike, so please make sureyou’re gettingthis rightand thatit’s working.
External Research</p>

<p>In the Extra Credit sectionof
each exercise,you may have</p>

<p>you go findinformation on your own andfigurethings out. This is an important part ofbeinga self-sufficient programmer. If you’re constantly running toask someone a question before trying to figure things out yourself,then you’llnever learn howto solveproblems independently. You’ll never build confidencein your skillsand will alwaysneed someone else around to do
your work. The way tobreakthis habit is to force yourselfto try to answer your own question first,and then confirmthat your answer is right. You do this by trying to break things, experimentingwithyour
answer,and doingyour own research. For thisexercise, I want you
to go online andfind out all
ofthe printf escape codes</p>

<p>and formatsequences. Escape codes are \n or \t thatlet you print a newlineor tab, respectively. Format sequencesare the %s or %d thatlet youprint a string or integer. Findthemall,learn how to modifythem, andsee whatkind of “precisions” and widths you can do.
From nowon, these kinds of tasks will be in the Extra Credit sections,and you should do them.
How to Break It
Try a fewof theseways to break this program,which mayor may not cause it to crash on your computer:
• Take the age variable outof thefirst printfcall, thenrecompile. You should geta couple ofwarnings.</p>

<p>• Run this new program</p>

<p>and itwilleithercrash orprint outareally crazyage.</p>

<p>• Put the printf back the wayit was,and then don’tset age toan initial value by changing thatline to int age;, and then rebuild it andrunit again.</p>

<p>Exercise 3.bad Session</p>

<pre><code class="language-c">
# edit ex3.c to break printf
$ make ex3 
cc -Wall ­g ex3.c -o ex3 ex3.c: In function 'main': ex3.c:8: warning: too few arguments for format ex3.c:5: warning: unused variable 'age' 
$ ./ex3 
I am -919092456 years 
old. 
I am 72 inches tall. 

# edit ex3.c again to fix printf, but don't init age $ make ex3 
cc -Wall ­g ex3.c -o ex3 ex3.c: In function 'main': ex3.c:8: warning: 'age' is used uninitialized in this function 
$ ./ex3 
I am 0 years old. 
I am 72 inches tall. 

$ 
</code></pre>

<p>Extra Credit</p>

<p>• Findas many other ways tobreak ex3.c asyou can.</p>

<p>• Run man 3 printfand read about theother % formatcharacters you can use. Theseshould</p>

<p>look familiar ifyou used them inother languages (theycome from printf).</p>

<p>• Add ex3 to the all list inyour Makefile. Use this to make clean all andbuild all ofyour exercises thusfar.</p>

<p>• Add ex3 to the clean list inyour Makefile aswell. Use make</p>

<p>clean to remove it
when youneed to.</p>

<p>Exercise4. Using a Debugger</p>

<p>This is avideo-focused exercisewhere I showyou how to use thedebuggerthat comeswithyour computer to debug yourprograms, detect errors, andeven debug processesthat arecurrently running. Pleasewatch the accompanying video tolearn more aboutthis topic.
GDB Tricks</p>

<p>Here’s alist ofsimple tricks you can do with GNU Debugger (GDB):
gdb &ndash;args Normally, gdbtakes arguments you giveit and assumes theyare for itself. Using &ndash;args passes them to the program.
thread apply allbt Dump
abacktrace for all threads. It’sveryuseful.
gdb &ndash;batch &ndash;exr &ndash;ex bt &ndash;ex q &ndash;args Run the programso that ifit bombs, you get a backtrace.
GDB Quick
Reference</p>

<p>The video is good for learning howto use a debugger, butyou’llneed to refer backto the commands asyou work. Here is aquick referenceto the GDB commands thatI used inthe video so you can use them laterin the book:
run [args] Start your</p>

<p>programwith[args].</p>

<p>break[file:]function Set abreakpoint at [file:]function. You can also use b.
backtrace Dump a backtrace of the current calling stack. Shorthand is bt.
print expr Printthe value of expr. Shorthand is p.
continue Continue running theprogram. Shorthand is c.
next Next line, but step over function calls. Shorthand is n.
step Nextline, butstep into function calls. Shorthand is s.
quit Exit GDB.
help List thetypes of commands. You can
thenget help on the classof commandas wellas thecommand.
cd, pwd, make This is justlike running these commands in your shell.
shell Quicklystart a shell so youcan do other things.
clear Clear a breakpoint.
infobreak,info watch</p>

<p>Show information about breakpointsand
watchpoints.
attach pid Attachto a running process so you can debug it.
detach Detach fromthe process.
list Listout thenextten source lines. Add a -to list thepreviousten lines.
LLDB Quick Reference</p>

<p>In OS X, you no longer have GDBand instead must use a similarprogram calledLLDB Debugger (LLDB). The commands are almostthe same, buthere’sa quick referenceforLLDB:
run [args] Start your programwith[args].
breakpoint set &ndash;name</p>

<p>[file:]function Seta break point at [file:]function. You can also use b, which is way easier.
thread backtrace Dump a backtrace of the current calling stack. Shorthand is bt.
print expr Printthe value ofexpr. Shorthand is p.
continue Continue running theprogram.
Shorthand is c. next Next line, but step over function calls.
Shorthand is n. step Nextline, butstep into function calls.
Shorthand is s. quit Exit LLDB. help List thetypes of commands.</p>

<p>You can thenget help on the classof commandas wellas thecommand itself.
cd, pwd, make justlike running these commands in your shell.
shell Quicklystart a shell so youcan do other things.
clear Clear a breakpoint.
infobreak,info watch</p>

<p>Show information about breakpointsand
watchpoints. attach -p pid Attach toa running process so you can debug it. detach Detach fromthe process. list Listout thenextten source lines. Add a -to list thepreviousten sources. You can also searchonline for quick reference cards and tutorials for both GDB and
LLDB.</p>

<p>Exercise5. Memorizing C Operators</p>

<p>When youlearned your first programming language,it most likely involved going through a book, typing in codeyou didn’t quite understand, andthen trying to figureouthow itworked.
That’s how Iwrote mostof myother books, and that works very well for beginners. In thebeginning, there are complex topics you need to understand before you can grasp whatall the symbolsand words mean, so it’saneasyway tolearn.</p>

<p>However, once you already know oneprogramming language, thismethodof fumbling aroundlearningthe syntax byosmosisisn’tthe most efficientway tolearna language. Itworks,butthere is amuchfasterway to build both yourskills ina language and your confidence in using it. This methodof learning a programming language might seem like magic,but you’ll haveto trust me that it works surprisingly well.
How I want youto learn C is to first memorizeall the basic symbolsand syntax, then apply them througha series ofexercises. This methodis very similarto howyou mightlearnhuman languages by memorizingwords and grammar, andthen applying whatyoumemorize in conversations. With justa simple amount of memorization effort inthe beginning, you can gain foundational knowledgeand haveaneasier time reading
and writingCcode.</p>

<p>Warning!
Somepeopleare dead against memorization. Usually, they claimit makesyouuncreative andboring. I&rsquo;mproof thatmemorizing things doesn’tmakeyou uncreative andboring. I paint, play and build guitars, sing,code, write books, and I memorize lots of things. This belief is entirely unfounded and detrimental to efficient learning. Please ignore anyone telling you this.
How to Memorize</p>

<p>The best wayto memorize something is a fairlysimple process:</p>

<ol>
<li><p>Create asetof flash cards that havea symbolon oneside and the descriptionon the other. Youcould also use aprogram called Anki to do this on your computer. I prefer creating my own because ithelps me memorize them asI makethem.</p></li>

<li><p>Randomize theflash</p></li>
</ol>

<p>cards and startgoing through them on one side. Try yourbest to remember theother side ofthe cardwithout looking.</p>

<ol>
<li><p>If you can’trecallthe other side of the card, thenlook atit and repeat the answer to yourself,then put that cardintoa separate pile.</p></li>

<li><p>Once yougo through all thecards you’ll have twopiles:one pileof cards you recalled quickly, and another you failed to recall.
Pick up the fail pile and drill yourself on only those cards.</p></li>

<li><p>At the very endof the session, which is usually 15–30 minutes, you’ll have a set of cards you just can’t recall. Take those cards with you whereveryou go, andwhenyou have freetime, practice memorizing them.</p></li>
</ol>

<p>There are manyother tricks to memorizing things, but I’ve foundthat this isthe best way to buildinstant recallon things you needto be ableto use immediately. The symbols, keywords, and syntax ofCarethings you need instantrecallon,sothis methodisthe best onefor this task.</p>

<p>Alsoremember thatyouneed to do both sides ofthe cards. You should be ableto read the description and know whatsymbolmatches it, as wellas knowingthe description fora symbol.</p>

<p>Finally, you don’t have to stop whileyou’rememorizing these operators. The best approachisto combine this with exercisesin thisbook so you can apply what you’ve memorized. Seethe next exercisefor more onthis.</p>

<p>The List of Operators</p>

<p>The first operators are the arithmetic operators, which are very similarto almost every other programming language. When you write the cards, thedescription side should say that it’san arithmetic operator, andwhat it does.</p>

<p>Relationaloperatorstest valuesforequality, andagain,
theyare very common in
programming languages.</p>

<p>Logicaloperators perform logic tests,and you should already knowwhat thesedo.</p>

<p>The only odd one is the logical ternary, which you’ll learn laterin this book.</p>

<p>Bitwise operators do something you likely won’t experienceoften in modern code. They alter thebits that makeup bytes and otherdata types in variousways. I won’t cover this in mybook,but theyare very handy when working with certaintypes of lower-levelsystems.</p>

<p>Assignment operators simply assignexpressions to variables, but Ccombines a large number ofother operators with assignment. So when I say and-equal,I meanthe bitwise operators, notthe logical operators.</p>

<p>I&rsquo;m callingthese data operators but theyreally deal with aspects ofpointers, member access, andvarious elements ofdata structures in C.</p>

<p>Finally,therearea few miscellaneous symbolsthat are either frequently usedfor differentroles (like ,), or don’tfit into any of the previous categories for variousreasons.</p>

<p>Study your flash cards while you continuewiththe book. If youspent 15–30 minutes a day before studying,and another15–30 minutes before bed, you could most likely memorize allof these ina fewweeks.</p>

<p>Exercise 6. Memorizing C Syntax</p>

<p>After learning theoperators, it’stimeto memorize the keywords andbasic syntax structures you’llbe using. Trustme whenI tellyou that the small amount oftime spentmemorizing these things will payhuge dividends later as you go through thebook.</p>

<p>As I mentionedin Exercise5, you don’thave to stop readingthe book while you memorize these things. You can andshould doboth. Use your flash cardsas a warm up beforecoding thatday. Take them outand drillon them for 15–30minutes, thensitdown and do somemore exercises in thebook. Asyougo through thebook,tryto use the code you’retypingas more of away to practice whatyou’rememorizing. One trick is to builda pile offlash cards containing operators and keywordsthat you don’t immediately recognizewhile you’re coding. Afteryou’re done for the day,practice thoseflash cards for another 15–30minutes.</p>

<p>Keep this up and you’ll learn C much faster and more solidlythan you wouldif you juststumbled around typing codeuntilyoumemorized it secondhand.</p>

<p>The Keywords</p>

<p>The keywords of alanguage are words that augment the symbolssothat thelanguage reads well. There are some languages like APLthat don’t really havekeywords. There are otherlanguages likeForth and LISPthat arealmost nothing but keywords. In the middleare languages like C, Python, Ruby,and many more that mix setsof keywords with symbolsto createthe basis ofthe language.</p>

<p>Warning!</p>

<p>The technical termfor processing the symbols andkeywordsof a programming language is lexical analysis.The wordforone ofthese symbolsor keywords is a lexeme.</p>

<p>Syntax Structures
I suggest you memorize those keywords,as well as memorizing thesyntax structures. A syntax structure is apattern ofsymbols that makeup a Cprogram code form, such as theformof an if-statement or a while-loop. You should find most ofthese familiar, since you already knowone language. The only trouble is thenlearninghowCdoesit.</p>

<p>Here’s how youread these:</p>

<ol>
<li><p>Anything in ALLCAPS ismeant as a replacement spotor hole.</p></li>

<li><p>Seeing [ALLCAPS]meansthat part is optional.</p></li>

<li><p>The bestway to test your memoryof syntax structuresisto open a texteditor,and where you see switch-statement, try to write the code form after saying whatit does.</p></li>
</ol>

<p>An if-statement is your
basic logic branchingcontrol:</p>

<p>if(TEST) {CODE; } else if(TEST) {CODE; } else {CODE; }</p>

<p>A switch-statement is likean if-statement but works onsimple integer constants:</p>

<p>switch (OPERAND) {
    case CONSTANT: CODE;break;
    default:
    CODE;
}</p>

<p>A while-loop is your most basic loop:
while(TEST) {
CODE;
}</p>

<p>You can also use continue</p>

<p>to cause itto loop. Call this form while-continue­loop for now:
while(TEST) {if(OTHER_TEST) {
continue; }CODE;
}</p>

<p>You can also use break to exita loop. Callthis form while-break-loop:
while(TEST) { if(OTHER_TEST) {
break;
}
CODE; }</p>

<p>The do-while-loop is an inverted version of a while-loop thatruns the code then tests to see if itshould run again:
do {CODE;
} while(TEST);</p>

<p>It canalso have continue and break inside tocontrol how it operates.</p>

<p>The for-loop doesa controlledcounted loop through a (hopefully) fixed number o fiterations using a counter:
for(INIT; TEST; POST)
{ CODE; }</p>

<p>An enum creates asetof integerconstants:</p>

<pre><code class="language-c">
enum { CONST1,CONST2, CONST3 }NAME; 

A goto will jump toa label, and is only used in a few useful situations likeerror detectionand exiting: 
if(ERROR_TEST) {goto fail; } 
fail: 
CODE; 
</code></pre>

<p>A function is defined this way:
TYPE NAME(ARG1, ARG2, ..)
{CODE;
return VALUE; }</p>

<p>That may be hard to remember, so try this example tosee what’smeant by TYPE, NAME, ARG and
VALUE:</p>

<p>int name(arg1, arg2. {
CODE;
return 0;</p>

<p>}</p>

<p>A typedef defines a new type:</p>

<pre><code class="language-c">
typedef DEFINITION IDENTIFIER; 

A more concrete form of this 
</code></pre>

<p>is:</p>

<pre><code class="language-c">
typedef unsigned char byte; 
</code></pre>

<p>Don’t let the spaces fool you; the DEFINITION is unsigned char and the IDENTIFIER is byte in thatexample.</p>

<p>A struct is apackagingof many base datatypes into a single concept,which are
used heavilyin C:</p>

<p>struct NAME {ELEMENTS;} [VARIABLE_NAME];</p>

<p>The [VARIABLE_NAME] is optional,and I prefer not to use it except in a fewsmall cases. This is commonly combined with typedef likethis:</p>

<pre><code class="language-c">
typedef struct 
[STRUCT_NAME] {
ELEMENTS; 
} IDENTIFIER; 

</code></pre>

<p>Finally, union creates something like a struct, butthe elements will overlap in memory. This is strange to understand, so simply memorize theform for now:
union NAME {ELEMENTS;} [VARIABLE_NAME];</p>

<p>A Word of Encouragement</p>

<p>Once you’ve created flash cards foreachof these, drill on themin the usual way by startingwiththe nameside, and then reading the description and formon the other side. In the video for this exercise, I show you how to use Ankito do this efficiently, but you can replicate theexperiencewith simple index cards,too. I’ve noticedsome fear or discomfort in students who are askedto memorize something like this. I&rsquo;mnot exactly surewhy, but I encourage youto doit anyway. Lookatthis asan opportunityto improve your memorization and learning skills. The moreyou do it,the better at it you getand the easier itgets.</p>

<p>It’s normalto feeldiscomfort and frustration. Don’t take it personally. Youmightspend 15 minutes andsimply hate doingitand feellike a total failure. This is normal, and it doesn’tmean you actually are afailure. Perseverance will get you pastthe initial frustration,and thislittle exercisewillteach you two things:</p>

<ol>
<li><p>You can use memorization as aself­evaluation ofyour competence. Nothing tells you how wellyou really know a subject likea memorytestof its concepts.</p></li>

<li><p>The wayto conquer difficulty isa little piece at a time. Programming is a great way tolearnthis because it’s so easy to</p></li>
</ol>

<p>break down into small partsand focus on what’s lacking. Take this as an opportunity to build yourconfidence in tackling large tasks in small pieces.</p>

<p>A Word of Warning</p>

<p>I&rsquo;ll adda finalword of warning about memorization. Memorizing alarge quantity offacts doesn’tautomatically makeyougood at applying thosefacts. You can memorize theentireANSI C standards documentand still be aterribleprogrammer. I’ve encountered many supposed C experts who know every square inchof standard C grammar but stillwrite terrible,buggy, weird code, ordon’t codeatall.</p>

<p>Never confuse an ability to regurgitatememorized facts with abilityto actually do something well. Todo that you need toapply these facts in different situationsuntil you know how to use them. That’s what therest ofthis book will help youdo.</p>

<p>Exercise7. Variablesand Types</p>

<p>You should be getting agrasp ofhow a simple C programis structured, so let’sdo thenext simplest thingand make somevariables ofdifferent types:</p>

<p>ex7.c</p>

<pre><code class="language-c">
1 #include &lt;stdio.h&gt; 

2 
3 int main(intargc, char*argv[]) 
4 {5 int distance = 100;
6 float power = 2.345f;
7 double super_power = 56789.4532;
8 char initial = 'A';
9 char first_name[] = &quot;Zed&quot;;
10 char last_name[] = &quot;Shaw&quot;;
1. 12 printf(&quot;You are %d miles away.\n&quot;, distance); 
13 printf(&quot;You have %f levels of power.\n&quot;, power); 
14 printf(&quot;You have %f awesome super powers.\n&quot;, super_power);
15 printf(&quot;I have an initial %c.\n&quot;, initial); 
16 printf(&quot;I have a first name %s.\n&quot;, first_name);
17 printf(&quot;I have a last name %s.\n&quot;, last_name); 
18 printf(&quot;My whole name is %s %c. %s.\n&quot;,
19 first 
initial, last_name); 
2. 21 int bugs = 100;
22 double 
bug_rate = 1.2;
2. 24 printf(&quot;You 
have %d bugs at the 
imaginary rate of 
%f.\n&quot;,
25 bugs,
bug_rate); 
2. 27 long
universe_of_defects = 

1L * 1024L * 1024L * 1024L;28 printf(&quot;The entire universe has %ld bugs.\n&quot;,universe_of_defects); 29 30 double expected_bugs = bugs 
* bug_rate;31 printf(&quot;You are expected to have %f bugs.\n&quot;,expected_bugs); 32 33 double part_of_universe = expected_bugs /universe_of_defects;34 printf(&quot;That is only a %e portion of the universe.\n&quot;,35 part_ 36 37 // this makes no sense, just a demo of something weird 
38 char nul_byte = '\0';39 int care_percentage = 
bugs * nul_byte;
40 printf(&quot;Which 
means you should care 
%d%%.\n&quot;,
care_percentage); 
41 
42 return 0;

43 } 
</code></pre>

<p>In this program, we’re declaring variables of differenttypes andthen printingthemusingdifferent printf format strings. I can break it down as follows:</p>

<p>ex7.c:1-4 The usualstart ofa C program.</p>

<p>ex7.c:5-6 Declare an int and double forsome fakebug data.</p>

<p>ex7.c:8-9 Print outthose two, so nothingnew here.</p>

<p>ex7.c:11 Declarea huge number using anew type, long, for storing bignumbers.</p>

<p>ex7.c:12-13 Printoutthat number using %ld that adds a modifierto the usual %d. Adding l (the letter) tells the program to printthe number as a long decimal.</p>

<p>ex7.c:15-17 This is just more math andprinting.</p>

<p>ex7.c:19-21 Craft a depiction ofyour bug rate comparedto the bugsin the universe, which is acompletely inaccuratecalculation. It’ssosmallthat we have touse %e to print it in scientific notation.</p>

<p>ex7.c:24 Make a character, with aspecial syntax &lsquo;\0&rsquo; that creates a nul byte character. This is effectively thenumber 0.</p>

<p>ex7.c:25 Multiply bugsby this character,which produces0, as in how much you should care. This demonstrates an ugly hackyou might seesometimes.</p>

<p>ex7.c:26-27 Printthat out, and noticewe’veused %% (two percent signs) so thatwecanprint a % (percent) character.</p>

<p>ex7.c:28-30 The end of the main function.</p>

<p>This source filedemonstrates how somemathworks with differenttypes ofvariables. At theend ofthe program, it also demonstratessomething you seein Cbutnot inmany other languages. To C, a character isjust an integer. It’s areallysmallinteger,but that’s all itis. This meansyou can domathon them,and a lotof software does justthat —for good orbad.</p>

<p>This last bitisyour first glanceathowCgives you direct accessto the machine. We’ll be exploring thatmore in later exercises.</p>

<p>What You Should See</p>

<p>As usual, here’s what you
should see for theoutput:</p>

<p>Exercise 7 Session</p>

<pre><code class="language-c">
$ make ex7 
cc -Wall ­g ex7.c -o ex7 
$ ./ex7
</code></pre>

<p>You have 100 bugs at the imaginary rate of 1.200000. The entire universe has 1073741824 bugs. You are expected to have 120.000000 bugs. That is only a 1.117587e-07 portion of the universe. Which means you
should care 0%.
$
How to Break It
Again, go throughthis andtry to break the printf by passing in thewrong arguments. See what happens if you try toprint outthe nul_byte variable along with %s versus %c. When you break it,runit under the debugger tosee what it says about what youdid.</p>

<p>Extra Credit</p>

<p>• Makethe number you assign to universe_of_defec</p>

<p>various sizes untilyou get a warning from the compiler.
• What dothesereally huge numbersactually printout?</p>

<p>• Change long to unsigned long and</p>

<p>tryto find thenumber
thatmakes ittoo big.</p>

<p>• Gosearch onlineto find outwhat unsigned does.</p>

<p>• Tryto explain to yourself (before I doin the next exercise) why you can multiplya char and an int.</p>

<p>Exercise8. If,
Else-If, Else</p>

<p>InC, there really isn’t a Boolean type. Instead,any integerthat’s0is false or otherwise it’s true. In the last exercise, the expression argc &gt; 1 actuallyresulted in 1 or 0, notanexplicit True or False like in Python. This isanother example of C being closerto how acomputer works, because toacomputer, truth valuesare just integers.</p>

<p>However, C doeshave a typical if-statement that uses this numeric ideaof true and false to dobranching. It’s fairlysimilar towhat you woulddo in Pythonand Ruby,as you can see in this exercise:</p>

<p>ex8.c</p>

<pre><code class="language-c">
1 #include &lt;stdio.h&gt; 

2 
3 int main(int argc, char *argv[]) 
4 {
5 int i =0;6 7 if (argc == 1) {
8 printf(&quot;Y only have one argument. You suck.\n&quot;); 
9 } else if (argc &gt; 1 &amp;&amp; argc &lt; 4) {
10 printf(&quot;H your arguments:\n&quot;); 
1. 12 for (i = 0; i &lt; argc; i++) { 
    
    13 print &quot;, argv[i]); 
1. }
15 printf(&quot;\ 
16 } else {17 printf(&quot;Y have too manyarguments. You suck.\n&quot;); 
18 }
1. 20 return 0; 
21 } 



The format for the if-statement is this: 
if(TEST) {CODE; } else if(TEST) {CODE; } else {CODE; 
} 

</code></pre>

<p>This is like most other languages except for some specific C differences:
• As mentionedbefore, the TEST parts are false if they evaluate to0, or otherwisetrue.</p>

<p>• You haveto put parentheses around the TEST elements, while someother languages let you skipthat.</p>

<p>• You don’t need the {}braces to enclosethe code, but it is very bad formto notusethem. Thebraces make it clear whereone branch ofcode begins and ends. If youdon’t include them then obnoxiouserrors come up.</p>

<p>Other than that, thecode works theway it doesin most other languages. You don’t need to have either else if or else parts.</p>

<p>What You Should See</p>

<p>This oneis pretty simple to run and try out:</p>

<p>Exercise 8 Session</p>

<pre><code class="language-c">

$ make ex8 
cc -Wall ­g ex8.c -o ex8 
$ ./ex8

You only have one argument. You suck. 
$ ./ex8 one 

Here's your arguments: ./ex8 one 
$ ./ex8 one two 

Here's your arguments: ./ex8 one two 
$ ./ex8 one two three 

You have too many arguments. You suck. 
$ 
</code></pre>

<p>How to Break It</p>

<p>This oneisn’teasyto break because it’s so simple, buttry messing upthe tests in the if-statement:
• Removethe else at the end, and the programwon’t catch the edge case.</p>

<p>• Change the &amp;&amp; to a ||
so youget an or instead</p>

<p>ofanand test andsee how thatworks.</p>

<p>Extra Credit</p>

<p>• You werebriefly introducedto &amp;&amp;,which does an and comparison, so go research online the different Boolean operators.</p>

<p>• Write a fewmore test
cases forthis program</p>

<p>to see whatyoucan
comeup with.</p>

<p>• Is thefirst test really saying the right thing? Toyou, the first argument isn’tthe same first argument a user entered. Fix it.</p>

<p>Exercise9.</p>

<p>While-Loop
and Boolean
Expressions</p>

<p>The first looping construct I&rsquo;ll show you isthe while­loop,and it’sthe simplest, useful loop you could possiblyusein C. Here’s this exercise’s codefor discussion:</p>

<p>ex9.c</p>

<pre><code class="language-c">
1 #include &lt;stdio.h&gt; 

2 
3 int main(int argc, char *argv[]) 
4 {
5 int i = 0;
6 while (i &lt; 25) {7 printf(&quot;% i);8i++;
9 }
1. 11 return 0;
12 } 
</code></pre>

<p>From this code,and from your memorization ofthe basic syntax, you can seethat a while-loop is simply this:
while(TEST) {</p>

<p>CODE;
}</p>

<p>Itsimply runs the CODE as long as TEST istrue (1). So to replicatehowthe for-loop works, we needto do our own initializingand incrementing of i. Remember that i++ increments i with the post-incrementoperator. Refer back to your listof tokens if you didn’t recognizethat.</p>

<p>What You Should See</p>

<p>The outputis basicallythe same, so I justdid ita little differently so thatyoucansee it run another way.</p>

<p>Exercise 9 Session</p>

<pre><code class="language-c">
$ make ex9 
cc -Wall ­
g ex9.c -o ex9 
$ ./ex9
arg 0: ./ex9 state 0: California state 1: Oregon state 2: Washington state 3: Texas 
$ $ ./ex9 test it 
arg 0: ./ex9 arg 1: test arg 2: it state 0: California state 1: Oregon state 2: Washington state 3: Texas 
$ 
</code></pre>

<p>How to Break It</p>

<p>There areseveralwaysto get a while-loop wrong,soI don’trecommend you use it unlessyou must. Hereare a feweasyways to break it:</p>

<p>• Forget toinitialize the first int i;. Depending onwhat i starts with, theloop mightnot run at all, or run for an extremely long time.</p>

<p>• Forget toinitialize the secondloop’s i so that it retains thevalue from the endof thefirst loop. Now your second loop mightor might notrun.</p>

<p>• Forget todo a i++ increment at theend of the loop and you’ll get a forever loop, one of the dreaded problems common in the first decadeor two of programming.</p>

<p>Extra Credit</p>

<p>• Makethe loop count backwardby using i-­to start at 25 and go to 0.</p>

<p>• Write a fewmore complex while-loops using whatyou know so far.</p>

<p>Exercise10. Switch Statements</p>

<p>Inother languages, likeRuby, you have a switch-statement that can take any expression. Some languages, likePython,don’t havea switch-statement becausean if­statement with Boolean expressionsisaboutthe same thing. For theselanguages, switch-statements are more like alternatives to if-statements and work the same internally.</p>

<p>InC, the switch-statement is actually quite differentand is really a jump table.Instead of random Boolean expressions,youcan only put expressionsthat result in integers. These integers areused to calculate jumps from the top ofthe switch to the partthat matches thatvalue. Here’s somecode to help you understand this concept of jump tables:</p>

<p>ex10.c</p>

<pre><code class="language-c">
1 
#include 
&lt;stdio.h&gt; 
2 
3 int main(int 

argc, char *argv[]) 4 {5 int i = 0;6 7 // go 
through each string in argv 8 // why am I skipping argv[0]? 
9 for (i =1;i &lt; argc; i++) { 10 printf(&quot;a %d: %s\n&quot;, i, argv[i]); 
11 }12 13 // let's make our own array of strings 
14 char *states[] = {15 &quot;Californ &quot;Oregon&quot;,
16 &quot;Texas&quot;  &quot;Washingt  
17 18  };  
19  int  
num_states  =  4;  

2. 21 for (i = 0;i &lt; num_states; i++){22 printf(&quot;s %d: %s\n&quot;, i,states[i]); 
2. }
2. 25 return 0;


2. } 

</code></pre>

<p>In this program, we take a single command line argument and print out all vowels in an incredibly
tedious wayto demonstratea switch-statement. Here’s how the switch-statement works:
• The compiler marks the place inthe program where the switch-statement starts. Let’s call this location Y.</p>

<p>• Itthen evaluates the expressionin switch(letter) to comeup with a number. In this case, thenumber willbe the raw ASCII code of the letter in argv[1].</p>

<p>• The compiler also translates each of the case blocks like case &lsquo;A&rsquo;: into alocation in the program that’s that faraway. Sothe code under case &lsquo;A&rsquo; is at Y +Ain theprogram.</p>

<p>• Itthen does the math to figureoutwhereY+ letter islocated in the switch- statement, and if it’s toofar, then it adjusts it to Y + default.</p>

<p>• Onceit knows the location, theprogram jumps to that spotin the code, andthen continuesrunning. This iswhyyouhave break on some ofthe case blocks butnoton others.</p>

<p>• If &lsquo;a&rsquo; isentered,then it jumps to case &lsquo;a&rsquo;. There’sno break, so it “fallsthrough” to the one right under it, case &lsquo;A&rsquo;, which has code and a break.</p>

<p>• Finally, it runs this code, hitsthe break,and thenexits out ofthe switch-statement entirely. This is adeep dive into how the switch-statement works, butin practice you justhave to rememberafew simple rules:
• Always includea default: branchso thatyou catch any missing inputs.</p>

<p>• Don’t allow fall through unless you really want it. It’salso a good ideato add a
//fallthrough
comment so people know it’s on purpose.
• Always writethe case and the break before you write the code that goes init.</p>

<p>• Tryto use if-statements instead if you can.</p>

<p>What You Should See</p>

<p>Here’s an exampleof me playingwiththis, and also demonstratingvarious ways to pass inthe argument:</p>

<p>Exercise 10 Session</p>

<pre><code class="language-c">
$ make ex1. cc -Wall -gex10.c ­
o ex1. $ ./ex10
ERROR: You need one argument. 
$ $ ./ex10 Zed 
0: Z is not a vowel 
1: 'E' 
2: d is not a vowel 
$ $ ./ex10 Zed Shaw 
ERROR: You need one argument. 
$ 
$ ./ex10 &quot;Zed Shaw&quot; 

0: Z is not a vowel 
1: 'E' 
2: d is not a vowel 
3: is not a vowel 
4: S is not a vowel 
5: h is not a vowel 
6: 'A' 
7: w is not a vowel 
$ 
</code></pre>

<p>Remember thatthere’s an if-statement atthe top thatexits with a return 1; when youdon’tprovide enougharguments. Areturn that’s not0 indicates to the OSthat theprogram hadan error. You can testforany valuethat’sgreater than 0 in scripts and otherprograms to figureoutwhat happened.
How to Break It</p>

<p>It’s incredibly easy tobreak a switch-statement.Here are justa few ways you can mess oneof theseup:
• Forget a break,and it’ll run two ormore blocks ofcode you don’twant itto run.</p>

<p>• Forget a default, and it’ll silentlyignore valuesyou forgot.</p>

<p>• Accidentallyput a variableinto the switch thatevaluates to something unexpected,like an int,whichbecomes weird values.</p>

<p>• Use uninitialized values in the switch.</p>

<p>You can also break this programin afew otherways. See if youcan bustit yourself.</p>

<p>Extra Credit</p>

<p>• Write another program thatuses math on the letter to convert it to lowercase, and then removeall of the extraneous uppercase letters in theswitch.</p>

<p>• Use the &lsquo;,&rsquo; (comma) to initialize letter in the for-loop.</p>

<p>• Makeit handle all of the argumentsyou pass it with yetanother for-loop.</p>

<p>• Convert this switch-statement toan if-statement. Which do you like better?</p>

<p>• In the case for &lsquo;Y&rsquo; I have the break outside</p>

<p>ofthe if-statement. What’s the impactof this, and whathappens if you move it inside of the if-statement. Proveto yourself that you’re right.</p>

<p>Exercise11. Arrays and Strings</p>

<p>This exerciseshows you that C stores itsstrings simply as an array of bytes, terminated with the &lsquo;\0&rsquo; (nul) byte. You probably clued in tothis in thelast exercisesince we didit manually. Here’show we doitin another way to makeit even clearerby comparingit to an arrayof numbers:</p>

<p>ex11.c</p>

<pre><code class="language-c">
1 #include 
&lt;stdio.h&gt; 

2 3 int main(int argc, char *argv[]) 4 { 
5 int 

numbers[4] = { 0 }; 6 char name[4]
={ 'a' }; 7 8 // first, 
print them out raw 
9 printf(&quot;numbe %d %d %d %d\n&quot;,10 numbe numbers[1], numbers[2], numbers[3]); 11 12 printf(&quot;name each: %c %c %c %c\n&quot;, 
13 name[
name[1], name[2], 
name[3]); 
1. 15 printf(&quot;name: 

%s\n&quot;,16  name);  
17  //  set  up  
the  numbers  
18 1;19 2;20 3;21 4;  numbers[0] numbers[1] numbers[2] numbers[3]  = = = =  

2. 23 // set up the name 
24 name[0] = 'Z';25 name[1] = 'e';26 name[2] = 'd';27 name[3] = '\0';28 29 // then print them out initialized 
30 printf(&quot;numbe %d %d %d %d\n&quot;, 
31 numbe 

numbers[1], 
numbers[2], 
numbers[3]); 
32 
33 printf(&quot;name 
each: %c %c %c %c\n&quot;,
34 name[
name[1], name[2], 
name[3]); 
35 
36 // print the 
name like a string 

37 printf(&quot;name: 
%s\n&quot;, name); 
38 

39 // another way to use name 
40 char 
*another = &quot;Zed&quot;;
41 
42 printf(&quot;anoth 
%s\n&quot;, another); 
43 
44 printf(&quot;anoth 
each: %c %c %c %c\n&quot;,
45 anoth 
another[1], 
another[2], 
another[3]); 
46 
47 return 0; 

48 } 

In this code, we set upsome arrays the tediousway, by assigninga value to each element. In numbers, weare setting upnumbers; butin name,we’re actually building a stringmanually. 


What You Should See 

When yourunthis code, you should firstsee thearrays printed with their contents initialized to 0 (zero), thenin its initialized form. 


Exercise 11 Session 


```c

$ make ex1. cc -Wall ­g ex11.c -o ex1. $ ./ex11
numbers: 0 0 0 0 name each: a name: a numbers: 1 2 3 4 name each: Z e d name: Zed another: Zed another each: Z e d 
$ 

You’ll notice some interesting thingsaboutthis program: 
• Ididn’t have to give all four elementsof the arrays to initialize them. This isashortcut inC. If youset just one element, it’ll fill inthe rest with 0. 

• When each elementof 
numbers is printed, 
theyall comeoutas 0. 


• When each elementof 
name isprinted, only 
the firstelement 'a' 


showsup becausethe '\0' character is specialand won’t display. 

• Thenthe first time we print name, it only prints thelettera. This isbecause thearraywill be filled with 0afterthe first 'a' in the initializer, sothe string iscorrectly terminated by a '\0' character. 

• We then set up the arrays with atedious, manual assignment to each thing and print them outagain. Look at how theychanged. Now the numbers areset, but do you see how the name string printsmy namecorrectly? 

• Thereare also two syntaxes for doinga string: char 


name[4] = {'a'}on line 6 versus char *another = &quot;name&quot; online 44. Thefirst one is less common andthe second iswhatyou should use for string literalslike this. 
Notice thatI'm using the 
same syntax andstyle of code 

to interactwithboth an array 

ofintegers andanarrayof characters, but printf thinks that the name is justa string. Again, this is because the C languagedoesn’t differentiate between a string and anarrayof characters. 


Finally,when you make string literalsyou should typically use the char *another = &quot;Literal&quot; syntax. Thisworks outto be the samething,butit’s more idiomatic andeasier to write. 

How to Break It 

The sourceof almostallbugs in C come fromforgettingto haveenough space, or forgetting to put a '\0' at the end of a string. In fact, it’s so common andhardto get rightthat themajority ofgood C code just doesn’t use C­stylestrings. In later exercises, we’llactually learn how to avoid C strings completely. 

In this program, thekey to breaking it is to forget toput the '\0' characteratthe end ofthe strings. There area few ways todo this: 
• Getrid of the initializers thatsetup name. 

• Accidentallyset name[3] = 'A'; so thatthere’s no terminator. 

• Set the initializer to 



{'a','a','a','a'}
so thatthere aretoo many 'a' characters and no space for the '\0' terminator. 
Try tocomeup with some other waysto break this, and run all ofthese underthe debugger so you can see exactly what’s goingon and whatthe errorsare called. Sometimes you’ll make these mistakes andeven adebugger can’t find them. Try moving where you declarethe variables tosee if youget an error. This is part ofthe voodoo ofC:Sometimes just where the variable islocated changesthe bug. 

Extra Credit 


• Assign thecharacters into numbers, and thenuse printf to printthemone character at atime. What kind of compiler warnings do you get? 

• Dothe inverse for name,tryingto treatit likeanarrayof int and print it out one int at atime. What does the debugger thinkof that? 


• In howmany other ways can you print this out? 

• If an array of characters is4 byteslong, and an integer is 4 bytes long, thencan youtreatthe whole name array like it’sjust an integer? How mightyou accomplish this crazy hack? 

• Take out apiece of paper and draw eachof these arrays as arowof boxes. Thendo the operations you justdid on paper tosee if you get them right. 

• Convert name to bein the style of another and see ifthe code keeps working. 



Exercise12. Sizes andArrays 

In the last exercise,you did math butwith, a '\0' (nul) character. This may seem odd if you’re coming from other languages, since they try to treat strings and byte arrays asdifferent beasts. C treats strings as just arrays of bytes, and it’s only thedifferent printingfunctionsthat 
recognizea difference. Before I canreallyexplain the significance of this, I have to introducea couplemore concepts: sizeof and arrays. Here’sthe codewe’ll be talkingabout: 

ex12.c 

```c

1 
#include 
&lt;stdio.h&gt; 
2 
3 int main(int argc, char *argv[]) 
4 {
5 int areas[] = { 10, 12, 13, 14,20 }; 
6 char name[] = &quot;Zed&quot;;
7 char full_name[] = {
8 'Z','e', 'd',
9 '','A', '.', '',10 'S', 
'h', 'a', 'w', '\0' 11 }; 12 13 // WARNING: On some systems you may have to change the 14 // %ld in this code to a %u since it will use unsigned ints 
15 printf(&quot;The size of an int: %ld\n&quot;, sizeof(int)); 16 printf(&quot;The size of areas (int[]): %ld\n&quot;,sizeof(areas)); 17 printf(&quot;The number of ints in areas: %ld\n&quot;,18 sizeo / sizeof(int)); 19 printf(&quot;The first area is %d, the 2nd %d.\n&quot;, areas[0], areas[1]); 20 21 printf(&quot;The size of a char: %ld\n&quot;,sizeof(char)); 22 printf(&quot;The size of name (char[]): %ld\n&quot;,sizeof(name)); 23 printf(&quot;The number of chars: %ld\n&quot;, sizeof(name)/ sizeof(char)); 
24 25 printf(&quot;The size of full_name (char[]): %ld\n&quot;,sizeof(full_name)); 26 printf(&quot;The number of chars: %ld\n&quot;,27 sizeo 
/ sizeof(char)); 
2. 29 printf(&quot;name= 
and 
full_name=\&quot;%s\&quot;\n&quot;, 
name, full_name); 
30 
31 return 0;

32 } 
</code></pre>

<p>In this code, we create afew arrays with differentdata types in them. Because arrays ofdata are so central tohow C works, thereare ahuge number ofways to create them. For now,just use the syntax type name[] = {initializer}; and we’ll exploremore later. Whatthis syntax means is, “I wantan array oftype that is initialized to {..}.” When C sees this,it knows to:
• Look at the type,and in
this firstcase, it’s int.</p>

<p>• Look at the [] andsee thatthere’s no length given.</p>

<p>• Look at the initializer</p>

<p>{10, 12, 13, 14,</p>

<p>20} and figure out that you wantthose five integers inyour array.
• Create apiece of memory inthe computer that can hold 5 integers one after another.</p>

<p>• Take thename you want, areas, and assign itthis location.</p>

<p>In the caseof areas, it’s creatinganarrayof five integers that contain those numbers. Whenitgets to
char name[] = &ldquo;Zed&rdquo;;</p>

<p>it’sdoing thesamething, exceptit’s creating an array ofthreecharactersand assigningthat to name. The final array we make is full_name, butwe use the annoying syntax of spellingit outone characterata time.</p>

<p>To C, name and full_name areidentical methodsof creating achar array.</p>

<p>In the rest of the file,we’re using akeyword called sizeof to ask C how big things arein bytes. Cis all about thesize and locationof pieces of memory, and what you do with them. To help you keep this straight, itgives you sizeof so thatyou can ask how bigsomething is
beforeyou workwithit. This is where stuff gets tricky, so let’s run this code first andthen explainit later.</p>

<p>What You Should See</p>

<p>Exercise 12 Session</p>

<pre><code class="language-c">

$ make ex1. cc -Wall ­g ex12.c -o ex1. $ ./ex12

The size of an int: 4 The size of areas (int[]): 20 The number of ints in areas: 5 The first area is 10, the 2nd 12. The size of a char: 1 The size of name (char[]): 4 The number of chars: 4 The size of full_name 
(char[]): 1. 
The number of chars: 
1. name=&quot;Zed&quot; and 
full_name=&quot;Zed A. 
Shaw&quot; 

$ 
</code></pre>

<p>Now yousee theoutputof these different printf calls and start to get aglimpse of whatCis doing. Your output could actually betotally differentfrom mine, since your computermight have
differentsize integers. I’llgo
through my output: 5 My computer thinksan int is4bytes insize. Your computermight use adifferent size if it’sa 32-bit versus 64­bitCPU.
6 The areas arrayhas fiveintegers init, so it makessensethat my computer requires 20 bytesto storeit.
7 If we divide the size of areas by the sizeof an int,then weget fiveelements. Looking at the code, this matches whatweputin the initializer.
8 Wethen did an array access to get areas[0] and areas[1], which meansCis zero indexed likePythonand Ruby.
9-11 We repeat this for the name array, but do you notice something odd about the size of the array? It saysit’s 4 byteslong, but we only typed “Zed” for three characters. Where’s the fourth onecoming from?
12-13 We do the same thing with full_name, and now notice it gets this correct.
13 Finally, we just print outthe name and full_name toprove thatthey actuallyare “strings” according to printf.
Make sure youcan go through and seehow these outputlines match what was created. We’llbe building on this, andexploring more
about arrays andstorage next.</p>

<p>How to Break It
Breakingthis program is fairlyeasy. Trysome of these:
• Getrid of the &lsquo;\0&rsquo; at the endof full_name and rerun it. Runit under thedebugger too. Now,movethe definitionof full_name tothe top</p>

<p>of main before areas.Try runningit under thedebugger a fewtimes and see if you get some new errors. In somecases,youmight stillget lucky andnot catch any errors.</p>

<p>• Change itsothat instead of areas[0]you tryto print areas[10]. See what the debuggerthinksof</p>

<p>that.</p>

<p>• Tryother ways tobreak it likethis, doingitto name and full_name, too.</p>

<p>Extra Credit</p>

<p>• Tryassigning to elements in the areas array with areas[0] = 100; andsimilar.</p>

<p>• Tryassigning to</p>

<p>elements of name and full_name.</p>

<p>• Trysetting one element of areas to acharacter from name.</p>

<p>• Searchonline for the differentsizes usedfor integers on different CPUs.</p>

<p>Exercise13. For-Loops and Arrays of Strings</p>

<p>You can makean array of varioustypes with theidea thata stringand an array of bytesare the samething. The nextstep is to doanarray that has strings init. We’llalso introduce yourfirst looping construct, the for-loop, to helpprint out this new data structure.</p>

<p>The fun partof this isthat there’s beenan array of strings hiding in your programs fora while now:the char *argv[] in the main function arguments. Here’s codethat will printout any commandline arguments you passit:</p>

<p>ex13.c</p>

<pre><code class="language-c">
1 #include 
&lt;stdio.h&gt; 

2 3 int main(int 
argc, char *argv[]) 4 {5 if (argc != 
2) {6 printf(&quot;E You need one argument.\n&quot;); 
7 // this is how you abort a program 
8 return 1;
9 }10 11 int i = 0;12 for (i = 0; argv[1][i] != '\0';i++) { 13 char letter = argv[1][i]; 1. 15 switch 

(letter){ 16 case 
'a': 
17 case 
'A': 
18 p'A'\n&quot;, i); 19 b 20 21 case 
'e': 
22 case 
'E': 
23 p'E'\n&quot;, i); 
24 b 

25  
26  case  
'i':  
27  case  
'I':  
28 'I'\n&quot;,29  i);  p b  
30  
31  case 'o':  
32  case 'O':  
33 'O'\n&quot;,  i);  p  

34 b 

35 36 case 
'u': 
37 case 
'U': 
38 p'U'\n&quot;, i); 39 b 40 41 case 
'y': 
42 case 
'Y': 
43 (i &gt; 2) { 
44 

it's only sometimes Y 
45 'Y'\n&quot;, i); 
46 
}47 b 48 49 defau 50 p%c is not a vowel\n&quot;,i, letter); 

51 
}

52 
}
53 
54 return 0;


55 
} 

</code></pre>

<p>The format ofa for-loop is this:</p>

<pre><code class="language-c">
for(INITIALIZER;TEST; INCREMENTER) {CODE; } 

Here’s how the for-loop works: 
• The INITIALIZER is 
code that’s run to setup 
the loop, which inthis 


caseis i=0. 

• Next,the TEST Boolean expression is checked. If it’s false (0),then CODE is skipped, doingnothing. 

• The CODE runs and does whatever it does. 

• Afterthe CODE runs, the INCREMENTER partisrun, usually incrementing something, such as in i++.

• And it continues again with step 2 untilthe TEST isfalse (0). 


This for-loop is going through thecommand line arguments using argc and argv likethis: 

• The OS passeseach command lineargument asa stringin the argv array. Theprogram’s name(./ex10)is at 0, with the restcoming after it. 

• The OS also sets argc to thenumberof arguments inthe argv array,soyoucan processthemwithout going pastthe end. Remember thatif you giveone argument, the program’s nameisthe first,so argc is2. • The for-loop sets up with i=1 in the initializer. 

• Itthen tests that i is lessthan argc with the test i &lt; argc. Since $1 &lt; 2$, it’ll pass. 

• Itthen runs thecode thatjust prints out the i and uses i to indexinto argv. 

• The incrementer isthen run using the i++ 

syntax,which isa handy wayof writing i =i+1. • This then repeats until i &lt; argc is finally false (0), theloopexits, and theprogram continueson. 




What You Should See 

To playwiththis program, then, you have to run it two ways. The first wayis topass in some command line arguments so that argc and argv get set. Thesecondis to run itwithno arguments so you can seethat thefirst for-loop doesn’t run if i &lt; argc is false. 


Exercise 13 Session 


```c

$ make ex1. cc -Wall ­g ex13.c -o ex1. $ ./ex13 i am a bunch of arguments
arg 1: i arg 2: am arg 3: a arg 4: bunch arg 5: of arg 6: arguments state 0: California state 1: Oregon state 2: Washington state 3: Texas 
$ 
$ ./ex13

state 0: California state 1: Oregon state 2: Washington state 3: Texas 
$ 
Understanding Arrays of Strings 

InCyou make an array of 

strings by combining the 
char *str = &quot;blah&quot; syntax with the char str[] = {'b','l','a','h'}
syntax to construct a two­dimensionalarray. The syntax char *states[] = {...} online 14isthis two-dimensional combination,each string being oneelement,and each character inthe stringbeing 
another. Confusing?The conceptof multiple dimensions is something most people never think about, so what you should do isbuild thisarray ofstrings on paper: 
• Makea gridwiththe index ofeach string on the left. 

• Thenput theindex of each character onthe top. 

• Thenfillin the squares in themiddle with what single character goesin each square. 

• Onceyouhave thegrid, 
trace through the code 
using this gridof paper. 




Another wayto figurethis is outisto build thesame structure in a programming languageyou aremore familiar with, likePythonor Ruby. 
How to Break It 
• Take yourfavorite other languageand use it to run this program, butinclude asmany command line arguments aspossible. See ifyoucanbustitby givingit way too many arguments. 

• Initialize i to 0 and see 
whatthat does. Do you 
have toadjust argc as 


well, or does itjust work? Why does0­based indexingwork here? 

• Set num_states wrongsothat it’s a highervalue and see whatit does. 




Extra Credit 



• Figure out whatkind of code you can put into the parts ofa for-loop. 

• Look up how tousethe comma character(,) to separatemultiple statements inthe parts ofthe for-loop, but between thesemicolon characters (;). 

• Readaboutwhata NULL isand try to use it in one ofthe elements fromthe states array to see whatit’ll print. 

• Seeif you can assignan element from the states array tothe argv array before printing both. Trythe inverse. 



Exercise14. Writing and Using Functions 
Up untilnow, we’ve just used functions that are part ofthe stdio.h header file. In this exercise, you’ll writesome functions andusesome other functions. 

ex14.c 


```c

1 #include 
&lt;stdio.h&gt; 
2 #include 
&lt;ctype.h&gt; 

3 4 // forward declarations 
5 int can_print_it(char ch);
6 void print_letters(char 
arg[]); 7 8 void 
print_arguments(int argc, char *argv[]) 
9 {10 int i = 0;11 12 for (i = 0;i &lt; argc; i++) { 13 print_let 
1. }

1. }16 17 void print_letters(char 

arg[]) 
18 {
19 int i = 0;
2. 21 for (i = 0; 
arg[i] != '\0'; i++)
{
22 char ch 
= arg[i]; 
2. 24 if 
(can_print_it(ch)) { 
25 print 
== %d &quot;, ch, ch); 


2. }

2. } 


2. 29 printf(&quot;\n&quot;);
30 
}
31 
32 int 
can_print_it(char ch)
33 {
34 return 
isalpha(ch) || 
isblank(ch); 


35 
}
36 
37 int main(int 
argc, char *argv[]) 
38 {
39 print_argumen 



argv); 40 return 0;
41 } 
</code></pre>

<p>In this examplewe’re creatingfunctionsto printout the charactersand ASCII codes forany thatare alpha or blanks. Here’s the breakdown:</p>

<p>ex14.c:2 Include a new header file, so wecan gainaccess to isalpha and
isblank.</p>

<p>ex14.c:5-6 TellC that you’ll be using some functions later in your programwithout actually havingto define them. This isa
forward declaration</p>

<p>and itsolves the chicken-and-egg problem of needing to use afunction before you’vedefined it.</p>

<p>ex14.c:8-15 Define the
print_arguments</p>

<p>function, which knows how to printthe same array ofstrings that main typically gets.</p>

<p>ex14.c:17-30 Definethe nextfunction, print_letters, which is calledby print_arguments</p>

<p>and knowshowto print
each ofthe characters</p>

<p>and theircodes.</p>

<p>ex14.c:32-35 Define</p>

<p>can_print_it, which simplyreturns the truth value(0 or1) of isalpha(ch) ||isblank(ch) back to its caller, print_letters.</p>

<p>ex14.c:38-42 Finally, main simply calls print_arguments
to make the whole chainof functionsgo. I shouldn’thave todescribe what’s in eachfunction, because they’re allthings you’verunintobefore. What you should be ableto see, though,is that I’ve simply definedfunctions the same way you’ve beendefining main.Theonlydifference is you have tohelp C out by tellingitahead of timeif you’re going tousefunctions it hasn’t encountered yet in the file. That’s what the forward declarationsdo.</p>

<p>What You Should See</p>

<p>To playwiththis program, you just feed it different command line arguments, which getpassedthrough your functions. Here’s me playingwithit to demonstrate:</p>

<p>Exercise 14 Session</p>

<pre><code class="language-c">
$ make ex1. cc -Wall ­g ex14.c -o ex1. $ ./ex14
'e' == 101 'x' == 12. $ ./ex14 hi this is cool 
'e' == 101 'x' == 120 'h' == 104 'i' == 105 't' == 116 'h' == 104 'i' == 105 's' == 115 'i' == 105 's' == 115 'c' == 99 'o' == 111 'o' == 111 'l' == 108 
$ ./ex14 &quot;I go 3 spaces&quot;
'e' == 101 'x' == 120 'I' == 73 ' ' == 32 'g' == 103 'o' == 111 ' ' == 32 ' ' == 32. 's' == 115 'p' == 112 'a' == 97 'c' == 99 'e' == 101 's' == 115 $ 
</code></pre>

<p>The isalpha and isblank doall the workof figuringoutif the given character is a letter ora blank. When I dothe last run,it prints everything but the 3 character sincethat’sa digit.</p>

<p>How to Break It</p>

<p>There aretwo different kinds
ofbreakingin this program:</p>

<p>• Removethe forward declarations to confuse</p>

<p>the compilerand cause it to complainabout can_print_it and print_letters.</p>

<p>• When you call</p>

<p>print_argumentsinside main,try adding 1 to argc so that it goes pastthe end of the argv array.</p>

<p>Extra Credit</p>

<p>• Rework these functions so thatyou have fewer functions. For example, do you really need can_print_it?</p>

<p>• Have</p>

<p>print_arguments
figureouthow long each argumentstringis by using the strlen function, and then pass thatlength to print_letters. Then, rewrite print_letters soit only processesthis fixed lengthand doesn’t relyon the &lsquo;\0&rsquo; terminator. You’llneed the #include <string.h> forthis.
• Use man tolookup informationon isalpha and isblank. Use other</p>

<p>similar functionsto printout only digits or other characters.</p>

<p>• Goread abouthow other people like to format their functions. Never use the K&amp;R syntax (it’s antiquated and confusing) but understand what it’s doing in case you run into someone who likes it.</p>

<p>Exercise15. Pointers, Dreaded Pointers
Pointers are famous mystical creatures inC. I’llattempt to demystify themby teaching you the vocabularyto deal with them. They actually aren’t that complex,but they’refrequentlyabused in weird waysthat make them hard to use. If youavoidthe stupid waysto use pointers, thenthey’refairly easy.</p>

<p>To demonstrate pointers in a way that we can talk about them,I’ve writtena frivolous programthat printsa group of people’sagesin three differentways.</p>

<p>ex15.c</p>

<pre><code class="language-c">
1 #include 
&lt;stdio.h&gt; 

2 3 int main(int 
argc, char *argv[]) 4 {5 // create 
two arrays we care about 
6 int ages[] = { 23, 43, 12, 89, 2 }; 
7 char *names[] = {8 &quot;Alan&quot;,&quot;Frank&quot;,
9 &quot;Mary&quot;,&quot;John&quot;, &quot;Lisa&quot; 10 }; 11 12 // safely get the size of ages 
13 int count = 
sizeof(ages)/
sizeof(int); 
14 int i = 0;
1. 16 // first way 
using indexing 

17 for (i = 0;i &lt; count; i++) { 18 printf(&quot;% has %d yearsalive.\n&quot;, names[i], ages[i]); 
19 20  }  
21 \n&quot;); 22  printf(&quot;--­ 
23  // set up  

the pointers to the start of the arrays 
24 int *cur_age = ages; 
25 char **cur_name = names;26 27 // second way using pointers 
28 for (i = 0;i &lt; count; i++) { 29 printf(&quot;% is %d years old.\n&quot;,30 * (cur_name + i), * (cur_age + i)); 
31 }
32 
33 printf(&quot;--­\n&quot;); 

34 

35 // third way, pointers are just arrays 
36 for (i = 0;i &lt; count; i++) { 37 printf(&quot;% is %d years old again.\n&quot;, cur_name[i], cur_age[i]); 
38 }39 40 printf(&quot;--­\n&quot;); 41 
42 // fourth way with pointers in a stupid complex way 
43 for (cur_name = names, cur_age = ages;44 (cur_ -ages)&lt; count; cur_name++, cur_age++) { 45 printf(&quot;% lived %d years so far.\n&quot;,*cur_name,*cur_age); 
46 }47 
48 return 0;
49 } 

</code></pre>

<p>Before explaining how pointers work, let’sbreakthis programdown line by lineso you get an ideaof what’s goingon. Asyougo through this detaileddescription, try to answer thequestions for yourself ona pieceof paper, thensee if whatyou guessed matches mydescription of pointerslater.</p>

<p>ex15.c:6-10 Createtwo arrays: ages storing some int data,and names storingan array ofstrings.</p>

<p>ex15.c:12-13 These are somevariables for our for-loops later.</p>

<p>ex15.c:16-19 This is just looping throughthe two arrays and printing how oldeach person is. This isusing i to index into
the array.</p>

<p>ex15.c:24 Createa pointer thatpoints at ages. Notice the use of int * to createa pointer to integer type of pointer. That’s similar to char *, whichis a pointer to char, andastring isan array ofchars. Seeing the similarityyet?</p>

<p>ex15.c:25 Createa pointer thatpoints at names.A char * is already a pointer to char,sothat’s justa string. However, you need two levels since names is two-dimensional, which thenmeans you need char ** for a pointer to (apointer tochar) type. Study thatand try to explainit to yourself, too.</p>

<p>ex15.c:28-31 Loop through ages and names butusethe pointers plus an offset of i instead. Writing * (cur_name+i) is the same aswriting name[i], and you readitas “thevalueof (pointer cur_name plusi).”</p>

<p>ex15.c:35-39 This shows how the syntax to access anelement ofan array is the samefora</p>

<p>pointer and an array.</p>

<p>ex15.c:44-50 This is anotheradmittedly insaneloopthat does the samething asthe other two,butinstead it uses various pointer arithmetic methods:</p>

<p>ex15.c:44 Initializeour for-loop by setting cur_name and cur_age tothe beginning of the names and ages arrays.</p>

<p>ex15.c:45 Thetest portion ofthe for-loop then compares the distance of the pointer cur_agefromthe startof ages. Why doesthat work?</p>

<p>ex15.c:46 The increment partof the
for-loop then increments both cur_name and cur_age so that they point at the next element ofthe name and age arrays.</p>

<p>ex15.c:48-49 The pointers cur_name and cur_age are nowpointing at one element ofthe arrays that they workon, and we can print themoutusingjust *cur_name and *cur_age,which means “thevalueof wherever cur_name is pointing.”</p>

<p>This seemingly simple programhasa large amount ofinformation, andmy goal is to getyou toattempt to figurepointersout for
yourself beforeIexplain them. Don’t continue until you’ve written down what you think a pointer does.</p>

<p>What You Should See</p>

<p>After you run thisprogram, try to traceback each line printed outto the line in the codethat produced it. If you haveto,alter the printfcalls to make sureyou’vegot the right linenumber.</p>

<p>Exercise 15 Session</p>

<pre><code class="language-c">
$ make ex1. cc -Wall ­g ex15.c -o ex1. $ ./ex15
Alan has 23 years 
alive. 
Frank has 43 years 
alive. 
Mary has 12 years 
alive. 
John has 89 years 
alive. 
Lisa has 2 years 
alive. 

Alan is 23 years old. 
Frank is 43 years 
old. 
Mary is 12 years old. 
John is 89 years old. 
Lisa is 2 years old. 

Alan is 23 years old 
again. 
Frank is 43 years old 
again. 
Mary is 12 years old 
again. 
John is 89 years old 
again. 
Lisa is 2 years old 
again. 

Alan lived 23 years 
so far. 
Frank lived 43 years 
so far. 
Mary lived 12 years 
so far. 
John lived 89 years 
so far. 
Lisa lived 2 years so 
far. 

$ 

</code></pre>

<p>Explaining Pointers</p>

<p>When youtypesomething like ages[i],you’re indexing intothe array ages, and you’re using thenumber that’s heldin i to doit. If i is set to zero thenit’s thesame astyping ages[0]. We’ve been callingthis number i an index since it’sa location inside ages thatwewant. It could also becalled an address, whichis a wayof saying “I want the integer in ages that’s at address i.”</p>

<p>If i is an index, then what’s ages? To C, ages is a locationin the computer’s memory where allof these integers start. It’s also an address, and the C compiler will replace ages anywhere you typeit with the address ofthe very first integerin ages. Anotherway tothink of ages is thatit’s the “address ofthe first integerin ages.” Buthere’s the trick: ages is an address insidethe entire computer. It’s notlike i that’s justanaddress inside ages.The ages arrayname is actually an address in the computer.
That leads toa certain realization: C thinks your whole computer is one massivearray ofbytes. Obviously, thisisn’tvery useful, butthen what C does is layeron top ofthis massive array ofbytes theconcept of types and sizes of thosetypes. You already saw how this workedin previous exercises, butnowyou start to get an idea of how Cisdoing the following with your arrays:
• Creating ablock of memory inside your computer</p>

<p>• Pointing the name ages at the beginning ofthat block</p>

<p>• Indexing into theblock by taking the base addressof ages and gettingthe element that’s i away from there</p>

<p>• Converting thataddress at ages+i into avalid int of the right size, such that the index works toreturn what you want: the int at index i</p>

<p>If youcantake abase address, like ages,and add to itwithanother address like i to produce anew address, thencan youjust make something that points rightat this location all thetime? Yes,and thatthing is calleda pointer. This is whatthe pointers cur_age and cur_name aredoing: They are variablespointing at the locationwhere ages and names livein your computer’smemory. The example program is then moving them around ordoing math on themto get values outof thememory. In one instance,they just add i to cur_age, which is the same aswhat theprogram does with array[i]. In the last for-loop, though,these twopointersarebeing moved on theirown, without i to helpout. Inthatloop, the pointersare treated likea combination ofarray and integeroffsetrolled into one.</p>

<p>A pointer is simply an addresspointing somewhere inside the computer’s memory with a typespecifier so thatyou get the rightsize ofdata with it. It’skind of likea combination of ages and i rolledintoone data type. C knows wherepointers are pointing, knowsthe data typethey point at,the sizeof thosetypes, and how toget the datafor you. Justlike with i, you can increment, decrement,subtract,or add to them. But, just like ages, you can also getvalues out, putnew values in, and use all ofthe array operations.</p>

<p>The purposeof a pointeristo
let you manually index data
into blocks ormemory when</p>

<p>an array won’t do itright. In almost all othercases, you actually want to use an array. But, there are times when you have to work with a raw block ofmemory andthat’s where apointercomes in. A pointer givesyou raw,direct access to ablockof memory so you can work with it.</p>

<p>The final thing tograspatthis stage is thatyoucanuse either syntax for most array orpointeroperations. You can takea pointer to something, butusethe array syntax to access it. You can take an arrayand dopointer arithmetic with it.
Practical Pointer Usage</p>

<p>There areprimarilyfour useful things you can do with pointersin C code:
• Askthe OSfor achunk</p>

<p>ofmemory and use a pointer to workwithit. This includes strings and somethingyou haven’tseenyet, structs.</p>

<p>• Pass large blocks of memory (like large structs) tofunctions with apointer, so you don’thave to pass the whole thing to them.</p>

<p>• Take theaddress of a</p>

<p>function, so you can use it asa dynamic callback.</p>

<p>• Scan complex chunks ofmemory,converting bytesoffof a network socketintodata structuresor parsing files.</p>

<p>For nearlyeverything else, you mightsee people use pointerswhenthey should be using arrays. In theearlydays ofCprogramming, people used pointers tospeed up their programs, becausethe compilers werereally bad at optimizing array usage. These days, the syntax to access an array versus apointerare translatedintothe same machine code and optimized in thesame way, so it’snotas necessary. Instead, you should go with arrays whenever youcan,and then only use pointers asa
performance optimization if you absolutely have to.</p>

<p>The Pointer Lexicon</p>

<p>I&rsquo;m now goingto give youa little lexicon tousefor readingand writing pointers. Whenever yourunintoa complexpointerstatement, justreferto thisand break it down bit by bit (or justdon’t use it since it’s probablynot good code.)
type *ptr Apointerof typenamed ptr
*ptr The valueof whateverptris pointed at
*(ptr + i) The value of(whateverptris pointedatplus i)
&amp;thing The address of thing
type *ptr = &amp;thing A pointer of
typenamed ptrsetto
the address ofthing
ptr++ Incrementwhere</p>

<p>ptrpoints We’ll be using thissimple lexicon tobreakdown all of the pointers we use from now on in the book.
Pointers Aren’t Arrays
No matter what, you should</p>

<p>never think that pointers and arrays are thesame thing. They aren’tthe same thing, even though C lets you work with them in manyof the same ways. Forexample,if you do sizeof(cur_age)in thecode above, youwould get thesizeof the pointer,not the size of whatitpoints at. If you wantthe size of the full array, youhave tousethe array’sname, age,as I did
on line 12. To do:Expandon thissome more with what doesn’twork the sameon pointers and arrays.
How to Break It</p>

<p>You can break this program by simply pointing the pointersatthe wrong things:
• Tryto make cur_age
point at names. You’ll
need touseaC cast</p>

<p>to force it, so go look thatup andtry tofigure it out.</p>

<p>• In the final for-loop, trygetting the math wrongin weird ways.</p>

<p>• Tryrewriting theloops so thatthey start at the end of the arrays and go to thebeginning. This is harder than itlooks.</p>

<p>Extra Credit</p>

<p>• Rewriteallof thearrays in thisprogram as pointers.</p>

<p>• Rewriteallof the
pointersas arrays.</p>

<p>• Goback tosome of the other programsthat use arrays and try touse pointersinstead.</p>

<p>• Process commandline
arguments using just</p>

<p>pointers, similar to how you did names in this one.</p>

<p>• Play with combinations ofgetting thevalue of and theaddressof things.</p>

<p>• Add another for-loop at the endthat prints out the addresses thatthese pointersare using. You’llneed the %p format for printf.</p>

<p>• Rewritethis programto use afunction for each ofthe ways you’re printing out things. Try to pass pointers to these functions so thatthey work on the data. Remember you can declare afunction to accept a pointer,but justuse itlike an array.</p>

<p>• Change the for-loops to while­</p>

<p>loops and see what
works better forwhich
kind ofpointerusage.</p>

<p>Exercise16. Structs And Pointersto Them</p>

<p>In this exercise,you’lllearn how to make a struct, point a pointer at it, and use it to make sense ofinternal memory structures. We’ll also apply theknowledge of pointersfromthe last exercise, and thenget you constructing these structures fromraw memoryusing malloc.</p>

<p>As usual, here’s theprogram we’ll talkabout,sotype itin and make itwork.</p>

<p>ex16.c</p>

<pre><code class="language-c">

1 #include &lt;stdio.h&gt; 
2 #include &lt;assert.h&gt; 
3 #include &lt;stdlib.h&gt; 
4 #include &lt;string.h&gt; 
5  
6 7 8 9 10 11 12  struct Person {char *name;int age;int height;int weight;};  
13  struct Person  

*Person_create(char 
*name, int age, int 
height,
14 int 
weight)
15 {
16 struct 
Person *who = 
malloc(sizeof(struct 
Person)); 
17 assert(who 
!= NULL); 
1. 19 who-&gt;name = 
strdup(name); 
20 who-&gt;age = 
age; 

21 who-&gt;height 
= height;
22 who-&gt;weight 
= weight;
2. 24 return who;

2. }26 27 void Person_destroy(struct Person *who)28 {29 assert(who != NULL); 30 31 free(who­&gt;name); 

32 free(who); 

33 
}
34 
35 void 
Person_print(struct 
Person *who)
36 {
37 printf(&quot;Name: 
%s\n&quot;, who-&gt;name); 
38 printf(&quot;\tAge 
%d\n&quot;, who-&gt;age); 
39 printf(&quot;\tHei 
%d\n&quot;, who-&gt;height); 
40 printf(&quot;\tWei 
%d\n&quot;, who-&gt;weight); 


41 
}
42 



43 int main(int argc, char *argv[]) 44 {45 // make two people structures 
46 struct Person *joe = Person_create(&quot;Joe Alex&quot;, 32, 64, 140); 47 48 struct Person *frank = Person_create(&quot;Frank Blank&quot;, 20, 72, 180); 49 50 // print them out and where 
they are in memory 
51 printf(&quot;Joe is at memory location %p:\n&quot;, joe); 52 Person_print(53 54 printf(&quot;Frank is at memory location %p:\n&quot;, frank); 55 Person_print(56 57 // make everyone age 20 years and print them again 
58 joe-&gt;age += 20;59 joe-&gt;height -= 2;60 joe-&gt;weight += 40;61 Person_print(62 63 frank-&gt;age += 20;64 frank­&gt;weight += 20;65 Person_print(66 67 // destroy them both so we clean up 
68 Person_destro 69 Person_destro 
70 

71 return 0;
72 } 
</code></pre>

<p>To describe thisprogram,I&rsquo;m goingto use adifferent approachthanbefore. I&rsquo;m not goingto giveyoua line-by­linebreakdown of the program, I&rsquo;mgoing to make you writeit. I&rsquo;m givingyoua guide ofthe programbased on the partsit contains, and your job is write out what each linedoes.
includes I include some new headerfiles hereto gainaccess tosome new functions. What does each give you?
struct Person This is where I&rsquo;m creating a structure thathas four elements to describea person. Thefinal result isanew compoundtype thatletsme reference these elements allas one or each pieceby name. It’s similar to a row ofa database table ora class in an object-oriented programming (OOP) language.
functionPerson_create I need a wayto create these structures,soI’ve madea functionto do that. Here are the importantthings:
• I use malloc for memory allocateto ask theOStogiveme a piece of raw memory.</p>

<p>• I pass to malloc the sizeof(structPerson), which calculates thetotal size of the structure, given allof thefields inside it.</p>

<p>• I use assert to make surethat I have a valid pieceof memoryback from malloc. There’s a special constant called NULL that you use to mean “unsetor invalid pointer.” This assert is basically checking that malloc didn’treturn a NULL invalid pointer.</p>

<p>• Iinitialize each field</p>

<p>of struct Person using the x-&gt;ysyntax, to say what part of the structure I want to set.</p>

<p>• I usethe strdupfunctionto duplicate thestring for the name, just tomake sure thatthis structure actuallyowns it. The strdup actuallyis like malloc, and it</p>

<p>alsocopies the originalstring into the memoryit creates.
function Person_destroy</p>

<p>If I have a create function, thenI always need a destroyfunction, and this is whatdestroys Person structures. Iagain use assert to make sure I&rsquo;m not gettingbad input. Then I usethe function free toreturn the memoryI gotwith malloc and strdup. If youdon’t dothis, you get a memory leak.
functionPerson_print I thenneed a way toprint outpeople,whichisall this functiondoes. It uses the same x-&gt;ysyntax to getthe field fromthe structure to printit.
functionmain In the main function, I use all ofthe previous functions andthe struct Person to do thefollowing:
• Create twopeople, joe and frank.</p>

<p>• Print them out,but notice I&rsquo;musingthe %p format so you can see where theprogram has actuallyput your structure inmemory.</p>

<p>• Age both ofthemby 20 years with changes totheir bodies,too.</p>

<p>• Print each oneafter aging them.</p>

<p>• Finally, destroythe structures so we can cleanup correctly.</p>

<p>Go through this description carefully,and dothe following:
• Look up every function and header file you don’tknow. Remember thatyou canusually do man 2 function or man 3 function, and it’lltell you about it. You can also search online for the information.</p>

<p>• Write a comment above each andeverysingle linethat says what the   linedoes in English.</p>

<p>• Trace througheach function calland variableso you know where it comes fromin the program.</p>

<p>• Look up any symbols you don’tunderstand.</p>

<p>What You Should See</p>

<p>After you augment the programwithyour description comments, make sureitreally runsand producesthis output:</p>

<p>Exercise 16 Session</p>

<pre><code class="language-c">
$ make ex1. cc -Wall ­g ex16.c -o ex1. $ ./ex16
Joe is at memory location 0xeba010: Name: Joe Alex 
Age: 32 
Height: 64 

Weight: 140 

Frank is at memory location 0xeba050: Name: Frank Blank 
Age: 2. Height: 72 

Weight: 180 

Name: Joe Alex 
Age: 52 

Height: 62 Weight: 180 Name: Frank Blank Age: 40 Height: 72 Weight: 200 
Explaining 
Structures 

</code></pre>

<p>If you’vedone thework, then structures should be making sense,but letme explain them explicitly justto make sureyou’ve understood it.</p>

<p>A structure in C is a collection ofotherdata types (variables) that are stored in oneblockof memorywhere you can access eachvariable independently byname. They are similarto a record ina databasetable, ora very simplistic classin an OOP language. We can breakone down thisway:
• In the above code, we makea struct that has fields for aperson: name, age, weight, and height.</p>

<p>• Each ofthose fields has atype, like int.</p>

<p>• C then packs those together so thatthey can all be contained in one single struct.</p>

<p>• The struct Person isnowa compound data type, which means you can refer to</p>

<p>struct Person
using the samekindsof expressionsyouwould for other datatypes.
• This lets you pass the</p>

<p>whole cohesive groupingto other functions, as you did with Person_print.</p>

<p>• You can then accessthe individualparts of a struct bytheirnames using x-&gt;y if you’re dealing with a pointer.</p>

<p>• There’s also a wayto makea structthat doesn’tneed apointer, and you use the x.y</p>

<p>(period)syntaxto work</p>

<p>with it. We’ll do this in</p>

<p>the Extra Credit section.</p>

<p>If youdidn’thave struct, you’dneed tofigure out the size,packing, and location of pieces of memory with contents like this. Infact, in most earlyAssemblercode (and even some now), thisis whatyouwould do. In C, you can let ithandlethe memory structuring ofthese compounddata typesand thenfocuson what youdo with them.</p>

<p>How to Break It</p>

<p>The ways inwhichto break this program involve howyou use the pointers andthe malloc system:
• Trypassing NULL to Person_destroy  seewhat itdoes. If it doesn’tabort, then you must nothave the -g optionin your Makefile&rsquo;s CFLAGS.
• Forget tocall Person_destroy at the end, and thenrunit under thedebugger to seeitreportthat you forgot to free the memory. Figure outthe optionsyou need to pass to thedebuggerto get itto print how you leakedthis memory.</p>

<p>• Forget tofree who­&gt;name in Person_destroy and compare theoutput. Again,usethe right optionsto seehow the debugger tellsyou exactly where you messed up.
• This time, pass NULL to Person_print and see what the debugger thinks of that. You’ll figureout that NULL isaquickway to crash your program.</p>

<p>Extra Credit</p>

<p>In this part ofthe exercise, I wantyouto attempt something difficult for the extra credit: Convert this programto not usepointers and malloc. This will be hard,soyou’llwant to research the following:
• How tocreate a struct onthe stack, justlike you’re making any othervariable.</p>

<p>• How toinitialize it using the x.y (period) character instead of the x-&gt;y syntax.</p>

<p>• How topass a structure to otherfunctions without using apointer.</p>

<p>Exercise17. Heap andStack Memory Allocation</p>

<p>In this exercise,you’regoing to make a bigleap in difficulty and create an entire smallprogram tomanage a database. This database isn’t very efficient and doesn’t storeverymuch,but itdoes demonstratemost of what you’velearned so far. It also introduces memoryallocation more formally,and gets you started working with files. We use somefileI/O functions, butI won’tbe explaining themtoo well so thatyou cantry to figure them outfirst.</p>

<p>As usual, type thiswhole programin and getit working, then we’ll discuss it.</p>

<p>ex17.c</p>

<pre><code class="language-c">
1 #include &lt;stdio.h&gt; 
2 #include &lt;assert.h&gt; 
3 #include &lt;stdlib.h&gt; 
4 #include &lt;errno.h&gt; 
5 #include &lt;string.h&gt; 
6 
7 #define MAX_DATA 512 8 #define MAX_ROWS 100 
9 
10 struct Address {
11 int id;12 int set;13 char 
name[MAX_DATA]; 14 char email[MAX_DATA]; 
15 }; 
1. 17 struct 
Database {
18 struct Address rows[MAX_ROWS]; 
19 }; 
2. 21 struct Connection {
22 FILE *file;
23 struct Database *db;
24 }; 
2. 26 void die(const char *message)
27 {
28 if (errno)
{
    
29 perror(
30 } else {
31 printf(%s\n&quot;, message); 
32 
}
33 
34 exit(1); 


35 
}
36 
37 void 



Address_print(struct 
Address *addr)
38 {
39 printf(&quot;%d %s %s\n&quot;, addr-&gt;id,addr-&gt;name, addr­&gt;email); 
40 }
41 
42 void 

Database_load(struct 
Connection *conn)
43 {
44 int rc = 
fread(conn-&gt;db,
sizeof(struct 
Database), 1, conn­&gt;file); 
45 if (rc != 1)
46 die(&quot;Fa to load database.&quot;); 
47 }
48 
49 struct 

Connection *Database_open(const char *filename, char mode)
50 {51 struct Connection *conn = 
malloc(sizeof(struct 
Connection)); 
52 if (!conn)
53 die(&quot;Me error&quot;); 
54 
55 conn-&gt;db = malloc(sizeof(struct Database)); 
56 if (!conn­&gt;db)
57 die(&quot;Me error&quot;); 
58 
59 if (mode == 'c'){ 60 conn­&gt;file = 
fopen(filename, &quot;w&quot;); 
61 } else {
62 conn­&gt;file = fopen(filename,&quot;r+&quot;); 
63 64 if (conn-&gt;file){ 65 Dat 
66 
}

67 
}68 69 if (!conn­


&gt;file)70 die(&quot;Fa 
to open the file&quot;); 71 72 return 
conn;
73 }
74 
75 void 

Database_close(struct 
Connection *conn)76 {77 if (conn)
{78 if (conn-&gt;file) 
79 fcl &gt;file); 
80 if (conn-&gt;db)
81 fre &gt;db);
82 free(co 
83 
}

84 
}
85 
86 void 



Database_write(struct 
Connection *conn)
87 {
88 rewind(conn 
&gt;file); 89 90 int rc = 
fwrite(conn-&gt;db,sizeof(struct Database), 1, conn­&gt;file); 
91 if (rc != 1)
92 die(&quot;Fa to write database.&quot;); 
93 
94 rc = fflush(conn-&gt;file); 
95 if (rc == -1)
96 die(&quot;Ca flush database.&quot;); 
97 }
98 
99 void 

Database_create(struct 
Connection *conn)
100 {
101 int i = 0;
102 
103 for (i = 
0; i &lt; MAX_ROWS; i++)
{

104 // make a prototype to initialize it 
105 struct Address addr = {.id = 
i,.set = 0 }; 106 // then just assign it 
107 conn­&gt;db-&gt;rows[i]= addr;
108 
}

109 
}110 111 void Database_set(struct Connection *conn, int id, const char *name,112 const char *email)113 {114 struct 


Address *addr = 
&amp;conn-&gt;db-&gt;rows[id]; 
115 if (addr­&gt;set)
116 die(&quot;Al 
set, delete it 
first&quot;); 
11. 118 addr-&gt;set 
= 1;

119 // WARNING: bug, read the &quot;How To Break It&quot; and fix this 
120 char *res = strncpy(addr-&gt;name, 
name, MAX_DATA); 121 // demonstrate the strncpy bug 
122 if (!res)
123 die(&quot;Na 
copy failed&quot;); 
12. 125 res = 
strncpy(addr-&gt;email,
email, MAX_DATA); 
126 if (!res)
127 die(&quot;Em 
copy failed&quot;); 

128 }12. 130 void 

Database_get(struct Connection *conn, int id)131 {132 struct Address *addr = &amp;conn-&gt;db-&gt;rows[id]; 133 134 if (addr­&gt;set){ 135 Address 
136 
} else {137 die(&quot;ID is not set&quot;); 

138 
} 

139 
}
140 
141 void 
Database_delete(struct 
Connection *conn, int 
id)
142 {
143 struct 
Address addr = {.id = 
id,.set = 0 }; 
144 conn-&gt;db­&gt;rows[id]= addr;


145 
}
146 
147 void 
Database_list(struct 



Connection *conn)
148 {
149 int i = 0;
150 struct 
Database *db = conn­&gt;db;
151 
152 for (i = 
0; i &lt; MAX_ROWS; i++)
{
153 struct 
Address *cur =&amp;db­&gt;rows[i]; 
154 
155 if 
(cur-&gt;set){ 

156 Add 

157 
}

158 
}

159 
}
160 
161 int main(int 
argc, char *argv[]) 
162 {
163 if (argc &lt; 
3)
164 die(&quot;US 

ex17 &lt;dbfile&gt; 
&lt;action&gt; [action 
params]&quot;); 
165 
166 char 



*filename = argv[1]; 167 char action = argv[2][0]; 168 struct Connection *conn = Database_open(filename action); 169 int id = 0;
170 171 if (argc &gt; 
3) id = atoi(argv[3]); 172 if (id &gt;= MAX_ROWS)die(&quot;There's not that many records.&quot;); 
173 

174 switch (action){ 175 case 
'c': 
176 Dat 177 Dat 178 bre 179 180 case 
'g': 
181 if (argc != 4)182 an id to get&quot;); 183 
184 Dat 

id);185 bre 186 187 case 
's': 
188 if (argc != 6)189 
id, name, email to set&quot;); 190 191 Dat id, argv[4], argv[5]); 192 Dat 
193 bre 

194 195 case 
'd': 
196 if (argc != 4)197 id to delete&quot;); 198 199 Dat id);200 Dat 201 bre 202 203 case 
'l': 204 Dat 205 bre 206 default 207 die 
action: c=create, g=get, s=set, d=del, l=list&quot;); 
208 
}209 210 Database_cl 211 212 return 0;

21. } 

</code></pre>

<p>In this program, we’re using a set of structures, orstructs, to createa simple database for an address book. There are somethings you’venever seen,soyoushould go through itline byline, explain what each line does, and lookup anyfunctions thatyou don’t recognize. There area few key things thatyou should pay attention to, aswell:
#define for constants We use another partof the Cpreprocessor (CPP)to create constant settings of MAX_DATA and MAX_ROWS. I&rsquo;ll cover more of wha tthe CPP does later,but this is a way to create a constant that will work reliably. There are other ways, butthey don’t apply in certain situations.</p>

<p>Fixed sized structs The Address struct then uses these constants to create a pieceof data thatis fixedin size, makingit lessefficient buteasier to store and read. The Database struct isthenalso a fixed size becauseit’s a fixed lengtharrayof Address structs. That lets you write the whole thing todisk inone move later.</p>

<p>die function to abort with an error In a smallprogram like this, you can makea single function that killsthe programwithanerror if there’s anything wrong. I call this die, and it’s used toexit theprogram with an errorafterany failed function callsor bad inputs.</p>

<p>errno and perror() for error reporting When you have an error return froma function, itwill usually set an external variablecalled errno to say exactly what happened. These are justnumbers, so you can use perror to printthe error message.</p>

<p>FILE functions I&rsquo;m using all newfunctions like fopen, fread, fclose,and rewind to workwithfiles. Each ofthesefunctions works ona FILE struct that’s justlike your other structs, butit’s definedby theC standard library.</p>

<p>nestedstruct pointers There’sa use fornested structuresand getting the address ofarray elements thatyou should study.
Specifically, code like &amp;conn-&gt;db­&gt;rows[i] that reads “get the i elementof rows,whichisin db, which is in conn, then get theaddress of (&amp;) it.”
copyingstruct prototypes Best shown in Database_delete, you can seeI&rsquo;m using a temporarylocal Address, initializing its id and set fields, and then simply copying it into the rows array by assigningitto the element I want. This trick makessure that all fields except set and id are initialized to zeros and it’sactually easier towrite. Incidentally, you shouldn’tbeusing memcpy to do these kinds ofstructcopying operations. ModernC allows youto simply assign one struct to anotherand it’ll handle the copying for you.</p>

<p>processing complex arguments I&rsquo;mdoing somemore complex argument parsing,but this isn’treallythe best way todo it. We’ll get into abetteroptionfor parsing later inthe book.
converting strings to ints I use the atoi function to takethe string forthe id onthe command line and convert it tothe int id variable. Read up on this and similar
functions.
allocating large dataon theheap The whole point of this program is thatI&rsquo;m using malloc to ask theOS fora large amountof memory when I createthe Database. We’ll cover this in more detail later.
NULL is0,soBoolean works Inmanyof the
checks, I&rsquo;mtestingthat apointeris not NULL by simply doing
if(!ptr)die(&ldquo;fail!&rdquo;), because NULLwill evaluate to false. You could be explicitand say if(ptr == NULL)die(&ldquo;fail!&rdquo;), as well. In somerare systems, NULL will be stored in the computer (represented) as something not 0, butthe Cstandard says you should still be ableto write codeas ifit has a 0 value. Fromnow on when I say “NULL is 0,” I meanits valuefor anyone who is overly pedantic.</p>

<p>What You Should See</p>

<p>You should spend asmuch time as you can testingthat it works, and running it with a debugger toconfirm that you’vegotallof thememory usage right. Here’sa session ofme testing it normally,and thenusingthe debugger to check the operations:</p>

<p>Exercise 17 Session</p>

<pre><code class="language-c">
$ make ex1. cc -Wall ­g ex17.c -o ex1. $ ./ex17 db.dat c $ ./ex17 db.dat s 1 zed zed@zedshaw.com $ ./ex17 db.dat s 2 frank frank@zedshaw.com$ ./ex17 db.dat s 3 joe joe@zedshaw.com 
$ $ ./ex17 db.dat l 
1 zed zed@zedshaw.com 

2 frank 
frank@zedshaw.com 
3 joe joe@zedshaw.com 

$ ./ex17 db.dat d 3 $ ./ex17 db.dat l 
1 zed zed@zedshaw.com 
2 frank 
frank@zedshaw.com 

$ ./ex17 db.dat g 2 
2 frank 
frank@zedshaw.com 
</code></pre>

<p>Heap versus Stack Allocation</p>

<p>You kids have it great these days. You playwithyour Ruby orPythonand just makeobjectsand variables without anycarefor where theylive. You don’tcare if it’son the stack, and what about onthe heap? Fuggedaboutit. You don’t even know, and you know what, chances are your languageof choice doesn’t even put thevariables on stack at all. It’s all heap, and you don’teven know if it is.</p>

<p>C isdifferent becauseit’s using the real CPU’s actual machinery to do its work, and thatinvolves a chunk of RAM called thestackand anothercalled theheap. What’s thedifference? It all depends onwhereyouget the storage.</p>

<p>The heap is easierto explain since it’s just allthe remainingmemory in your computer, andyou access it with the function malloc to get more. Each time you call malloc, the OS uses internalfunctions to register thatpiece ofmemory to you, and then returns apointerto it. Whenyou’redonewithit, you use free to return it to the OS so thatit can be used by otherprograms.</p>

<p>Failing to do this will cause your programto leak memory, but Valgrind will help you track these leaks down. The stack is aspecial region ofmemory thatstores temporary variables, which each function creates as locals to thatfunction. How it works is thateach argument to a function is pushed onto the stackand then used inside the function. It’s really a stack datastructure, so the last thing in isthe first thing out. This alsohappens with all local variables like char action and int id in main.Theadvantage of using astack for thisis simplythat when the function exits, theC compilerpops these variablesoff of the stack toclean up. This is simple andprevents memory leaks ifthe variableis on the stack.</p>

<p>The easiest way tokeep this straightis withthis mantra: If you didn’tget it from malloc, or a function that gotit from malloc,then it’s on the stack.</p>

<p>There arethreeprimary problems with stacks and heaps towatchout for:</p>

<p>• If you get a block of memory from malloc, and have thatpointeron the stack, then when the function exitsthe pointer willget popped off andlost.</p>

<p>• If you puttoo much data onthe stack (like large structsand arrays), then you can cause a stack overflow and theprogram will abort. In this case, use the heap with malloc.</p>

<p>• If you take a pointer to something onthe stack, and then pass orreturn it from your function,   thenthe function receiving it will  segmentation fault  (segfault), becausethe actualdata will get poppedoffand disappear. You’ll be pointing at dead space.</p>

<p>This is whyI created a Database_open that allocatesmemory ordies,and thena Database_close thatfrees everything. If you createa createfunction that makesthe whole thingor nothing, and then a destroy function that safelycleans up everything, then it’seasier to keep itall straight.</p>

<p>Finally,when a program exits, theOS will cleanup all ofthe resources for you, but sometimesnotimmediately. A common idiom (and one I use in this exercise) is to just abort andlet the OS clean up on error.</p>

<p>How to Break It</p>

<p>This programhasa lot of places where you can break it, so trysome of these but also come up with your own:
• The classic wayisto removesome of the safetychecks so that you can pass in arbitrary data. For example, removethe</p>

<p>check on line160 that prevents you from passing in anyrecord number.</p>

<p>• You can alsotry corrupting thedata file. Open it in any editor and change random bytes, andthenclose it.</p>

<p>• You could alsofind ways topassbad arguments tothe programwhen it’s run. For example, getting the file andaction backwardwillmake it create a file named after the action, andthen do an action based on the first character.</p>

<p>• There’s abugin this programbecause strncpy is poorly designed. Goread about strncpy andtryto find out whathappens when the name or address you giveis greater than 512 bytes. Fix this by simply forcing thelast character to &lsquo;\0&rsquo; so thatit’s always setno matter what (whichis what strncpy should do).</p>

<p>• In the Extra Credit section,Ihave you augmentthe programto create arbitrary size databases. Tryto see whatthe biggest databaseis before you cause the program to die dueto lackof memory from malloc.</p>

<p>Extra Credit</p>

<p>• The die function needs tobeaugmented to letyou pass the conn variable, so it can close itand clean up.</p>

<p>• Change thecode to accept parameters for MAX_DATA and MAX_ROWS, storethem in the Database struct,and write that to the file,thus creating a databasethat can be arbitrarily sized.</p>

<p>• Add more operations you can do with the database, like find.</p>

<p>• ReadabouthowCdoes it’sstructpacking, and thentryto seewhy your fileisthe sizeit is. See if you can calculate a new size after adding more fields.</p>

<p>• Add some more fields   to Address and make them searchable.</p>

<p>• Write a shellscriptthat willdo yourtesting automatically for you by running commands in theright order. Hint: Use set -e at the top ofa bash tomake it abort thewholescriptif any commandhasan error.</p>

<p>• Tryreworkingthe  programto use asingle global for the database connection. Howdoes this new version of the programcompare tothe other one?</p>

<p>• Goresearch stack data structure and writeone in yourfavorite language, then try to do it in C.</p>

<p>Exercise18. Pointersto Functions</p>

<p>Functions inCareactually justpointers toa spot in the programwheresome code exists. Just like you’vebeen creatingpointers tostructs, strings, and arrays, you can point a pointer at afunction, too. The main use for this is to pass callbacks toother functions, orto simulate classesand objects. In this exercise, we’lldo some callbacks,and in the next exercise, we’llmake a simple object system.</p>

<p>The format ofa function pointer looks likethis:</p>

<pre><code class="language-c">
int (*POINTER_NAME)(int a, int b) 
</code></pre>

<p>A wayto remember how to write oneis to do this:
• Write a normal function declaration: int callme(int a, int b)</p>

<p>• Wrap thefunction name
with the pointer syntax:</p>

<p>int (*callme)</p>

<p>(int a, int b)</p>

<p>• Change thenameto the pointer name: int (*compare_cb)
(int a, int b)</p>

<p>The key thingto rememberis thatwhen you’re done with this, the variable nameforthe pointer iscalled compare_cb and you use itjust likeit’s a function. This is similar to how pointersto arrays can be used just likethe arrays they point to. Pointers to functions can be usedlike thefunctions theypoint to but with a differentname.</p>

<pre><code class="language-c">

int (*tester)(int a, int b) = sorted_order;printf(&quot;TEST: %d is same as %d\n&quot;,tester(2, 3),sorted_order(2, 3)); 

This will work evenif the function pointer returns a pointer to something: 
• Write it: char *make_coolness(in awesome_levels) 

• Wrap it: char * (*make_coolness)(intawesome_levels) 

• Rename it: char * (*coolness_cb)(intawesome_levels) 



The nextproblem to solve with using function pointers is thatit’s hard to give them asparametersto afunction, such as when youwantto pass the functioncallbackto anotherfunction. The solution isto use typedef, which is aCkeywordfor makingnew names for other, more complex types. 


The only thing you needto do is put typedef before the same functionpointersyntax, and then after that youcan use the name likeit’s a type. I demonstratethis in the 
following exercisecode: 


ex18.c 

```c

1 #include &lt;stdio.h&gt; 2 #include &lt;stdlib.h&gt; 3 #include &lt;errno.h&gt; 4 #include &lt;string.h&gt; 
5 
6 /** Our old  friend die from ex17. */ 
7 void die(const char *message)
8 {
9 if (errno){
10 perror(m 
11 } else {
12 printf(&quot; %s\n&quot;, message); 
1. }
1. 15 exit(1); 
 1. } 


1. 18 // a typedef creates a fake type, in this 
19 // case for a function pointer 
20 typedef int (*compare_cb) (int a,int b); 
2. 22 /** 
23 * A classic bubble sort function that uses the 
24 * compare_cb to do the sorting. 
25 */ 
26 int 

*bubble_sort(int *numbers, int count,compare_cb cmp)
27 {
28 int temp = 0;
29 int i = 0;
30 int j = 0;
31 int *target = malloc(count * sizeof(int)); 
32 
33 if 

(!target)
34 die(&quot;Me error.&quot;); 
35 
36 memcpy(targnumbers, count * sizeof(int)); 
37 
38 for (i = 0; i &lt; count; i++) { 
39 for (j= 0; j &lt; count -1;j++) {
40 if (cmp(target[j], target[j + 1]) &gt; 0) { 41 
= target[j + 1]; 42 
+ 1] = target[j]; 
43 = temp;
44 
}

45 
}

46 
}
47 
48 return 



target;
49 }
50 
51 int 

sorted_order(int a, 
int b)
52 {
53 return a ­b;
54 }
55 
56 int 

reverse_order(int a,
int b)
57 {
58 return b ­
a;
59 }
60 
61 int 

strange_order(int a, 
int b)
62 {
63 if (a == 0 || b == 0) { 
64 return 0;
65 } else {
66 return a % b;
67 
}

68 
}
69 
70 /** 
71 * Used to 



test that we are sorting things correctly 
72 * by doing the sort and printing it out. 
73 */ 
74 void test_sorting(int *numbers, int count,compare_cb cmp)
75 {76 int i = 0;77 int 
*sorted = bubble_sort(numbers,count, cmp); 
78 
79 if (!sorted)
80 die(&quot;Fa to sort as requested.&quot;); 
81 
82 for (i = 0; i &lt; count; i++) { 
83 printf(&quot;, sorted[i]); 
84 
}85 printf(&quot;\n&quot; 86 87 free(sorted 

88 
}
89 
90 int main(int 



argc, char *argv[]) 91 {92 if (argc &lt; 
2) die(&quot;USAGE: ex18 4 
3 1 5 6&quot;); 93 94 int count 
= argc -1;95 int i = 0;96 char 
**inputs = argv + 1;97 98 int 
*numbers = malloc(count * sizeof(int)); 
99 if 

(!numbers)
die(&quot;Memory error.&quot;); 
100 
101 for (i = 
0; i &lt; count; i++) { 
102 numbers 
= atoi(inputs[i]); 

103 
}
104 
105 test_sortin 
count, sorted_order); 
106 test_sortin 
count,
reverse_order); 
107 test_sortin 


count,
strange_order); 
108 
109 free(number 
11. 111 return 0;


11. } 

</code></pre>

<p>In this program, you’re creatinga dynamic sorting algorithm thatcansort an array ofintegers using a comparisoncallback. Here’s the breakdown ofthis program, so you can clearly
understand it:</p>

<p>ex18.c:1-6 The usual includes that are needed for all of the functions thatwecall.</p>

<p>ex18.c:7-17 This is the die function from the previous exercisethat I&rsquo;ll use todo error checking. ex18.c:21 This is where the typedef is used, and later I use compare_cb like it’s atype similar to int or char in bubble_sort and test_sorting.</p>

<p>ex18.c:27-49 A bubble sortimplementation, which is avery inefficientway to sort someintegers. Here’sa breakdown:</p>

<p>ex18.c:27 I use the typedef for compare_cb asthe last parameter cmp. Thisisnow a function thatwill return a comparison between twointegers for sorting.</p>

<p>ex18.c:29-34 The usual creation of variables on thestack, followed bya new array of integers on the heapusing malloc.Make sure</p>

<p>you understand what</p>

<p>count * sizeof(int) is doing.</p>

<p>ex18.c:38 Theouter loop of the bubble sort.</p>

<p>ex18.c:39 Theinner loop of the bubble sort.</p>

<p>ex18.c:40 NowI call the cmp callback just like it’s anormal function,butinstead of being the nameof something thatwe defined, it’sjust a pointerto it. This lets the caller passin anything it wantsas long as itmatchesthe signatureof the
compare_cb
typedef.</p>

<p>ex18.c:41-43 The actual</p>

<p>swappingoperation whereabubble sort needs to do whatit does.</p>

<p>ex18.c:48 Finally, this returns thenewly createdand sorted resultarray target.</p>

<p>ex18.c:51-68 Three differentversions ofthe compare_cb function type, whichneeds to have the same
definitionas the</p>

<p>typedef thatwe created. The C compiler willcomplain to you if you get thiswrong and say the types don’t match.</p>

<p>ex18.c:74-87 This is a testerforthe bubble_sort function. You can see now howI&rsquo;m also using compare_cb topass to bubble_sort, demonstrating how these can be passed aroundlike any other pointers.</p>

<p>ex18.c:90-103 A simple main function that sets up anarraybased on integers topasson the command line, and then it calls the test_sorting
function.</p>

<p>ex18.c:105-107 Finally, you get tosee how the compare_cb function pointer typedef is used. I simplycall test_sorting but giveit the name of sorted_order, reverse_order, and strange_order as the functionto use. The Ccompiler thenfinds the address ofthose functions, and makes it apointerfor test_sorting to use. If you look at test_sorting, you’ll see that it then passeseach of theseto bubble_sort, but it actually has noidea whatthey do. The compiler only knows thatthey match the compare_cb prototypeand should work.</p>

<p>ex18.c:109 Last thing we do is free up the array ofnumbers that we made.</p>

<p>What You Should See Running thisprogram is simple, butyou should try differentcombinationsof numbers,or evenother characters, to see whatit does.</p>

<p>Exercise 18 Session</p>

<pre><code class="language-c">

$ make ex1. cc -Wall ­
g ex18.c -o ex1. $ ./ex18 417320 8 
0123478 
874321. 3427108 

$ 
</code></pre>

<p>How to Break It
I&rsquo;m going to haveyoudo something kind of weird to break this. These function pointersare likeeveryother pointer,sothey pointat blocks ofmemory. Chas this abilityto take onepointerand convertit to another so you can process the datain differentways. It’s usually notnecessary, but to show you howto hackyour computer, I want you to add this atthe end of test_sorting:</p>

<pre><code class="language-c">
unsigned char *data = (unsigned char *)cmp; 
for(i = 0; i &lt; 25; 
i++) {printf(&quot;%02x:&quot;,data[i]);
} 
printf(&quot;\n&quot;); 

This loop is sortof like convertingyour function toa string, andthen printing out its contents. This won’tbreak your program unless the CPU and OS you’re onhasa problem with you doingthis. Whatyou’llsee after itprints the sorted arrayis a stringof hexadecimal numbers,like this: 

```c

55:48:89:e5:89:7d:fc:8 
That shouldbethe raw assembler byte codeof the function itself, and you should see thatthey start the same but thenhave different endings. It’s also possible that this loopisn’tgetting allof the function, or it’sgetting toomuch and stompingon anotherpiece ofthe program. Without more analysis you won’tknow. 

Extra Credit 

• Geta hex editor and open up ex18, andthen find thesequence of hex digitsthat start a function tosee ifyou can find thefunction in the raw program. 

• Findother random things inyour hex editor and change them. Rerun yourprogram and see what happens. 


Strings you find are the 
easiest things tochange. 


• Pass inthe wrong function for the compare_cb and see whatthe C compiler complains about. 

• Pass inNULLand watchyour program seriouslybite it. Then, run the debuggerand seewhat that reports. 

• Write another sorting 


algorithm, then change test_sorting so thatittakes both an arbitrary sort function and thesortfunction’s callback comparison. Use it to testbothof your algorithms. 

Exercise19. Zed’s Awesome Debug Macros 


There’sareoccurring problem inCthat we’ve been dancingaround, butI'm goingto solveitin this exerciseusing aset of macros I developed. You can thank me later when you realize how insanely awesome these macros are. Right now, you don’tknow howawesome theyare,soyou’lljust haveto use them,and then you can walkup tome one day and say, “Zed, those debug macros werethe bomb. Iowe you myfirstborn child because you savedme a decadeof heartache and prevented me from killing myself morethan once. Thankyou, good sir,here’sa million dollarsand the original Snakehead Telecaster prototypesignedby Leo Fender.” 
Yes,they arethat awesome. 


The C Error-Handling Problem 
Handling errorsisa difficult activityin almost every programming language. There areentireprogramming languages that try ashardas theycan to avoid even the concept ofan error. Other languages invent complex control structureslike exceptionsto pass error conditions around. The problem existsmostly because programmers assume errors don’t happen, andthis optimisminfects the types of languages they use and create. 
C tackles theproblem by returningerror codes and setting a global errno value thatyou check. Thismakes for complex code that simply exists tocheck ifsomething you didhad an error. Asyou write more and more C code, you’ll write codewiththis pattern: 
• Calla function. 

• Check if thereturn valueisanerror (and it must look thatup each time,too). 

• Then, cleanup all the resources created so far. 

• Lastly, printoutan errormessage that hopefullyhelps. 



This meansforeveryfunction call (and yes, every function), you are potentiallywriting three or four more linesjust to make sureit worked. That doesn’tinclude the problem ofcleaning upallof thejunk you’vebuilt to that point. If you have tendifferent structures,three files,and a databaseconnection,you’d have14 more lineswhenyou get an error. 


In the past, this wasn’ta problem becauseCprograms didwhatyou’ve beendoing when therewasan error:die. No point in bothering with cleanup when the OS will do it for you. Today, though, many C programs need to run for weeks, months,or years, and handleerrors from many differentsources gracefully. You can’tjust haveyour Web server die at theslightest touch, and you definitely can’t have a library that you’vewrittennukethe programit’s usedin. That’s justrude. 

Other languagessolve this problem with exceptions,but thosehave problems inC (and in otherlanguages,too). InC, you only haveone returnvalue, but exceptions makeup an entirestack-based returnsystemwitharbitrary values. Tryingto marshal exceptionsup thestack in C is difficult, andno other librarieswillunderstand it. 


The Debug Macros 


The solutionI’ve been using for yearsis a small setof debug macros that implements a basic debuggingand error-handling systemfor C. This system is easy to understand, works with every library,and makes C code moresolid and clearer. 


Itdoes this by adopting the conventionthat whenever there’s an error,your function will jump toan error: part ofthe function that knows how to cleanup everything and return an error code. You can use amacro called check to check returncodes, printanerror message, and thenjump to the cleanup section. You cancombine thatwitha set oflogging functions for printing out useful debug messages. 


I'll now show youthe entire contents of the most awesome set of brillianceyou’ve ever seen . 

dbg.h 

```c

#ifndef __dbg_h__ 
#define __dbg_h__ 
#include &lt;stdio.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; 
#ifdef NDEBUG #define debug(M, ...) #else #define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\ 
__FILE__, __LINE__, ##__VA_ARGS__) #endif 
#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno)) #define log_err(M, ...) fprintf(stderr,\ 
&quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\ 
clean_errno(), ##__VA_ARGS__) 
#define log_warn(M, ...) fprintf(stderr,\ 
&quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\ 
__FILE__, __LINE__, clean_errno(), ##__VA_ARGS__) 
#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\ 
__FILE__, __LINE__, ##__VA_ARGS__) 
#define check(A, M, ...) if(!(A)) {\ 
log_err(M, ##__VA_ARGS__); errno=0; goto error; } 
#define sentinel(M, ...) { log_err(M, ##__VA_ARGS__);\ 
errno=0; goto error; } 
#define check_mem(A) check((A), &quot;Out of memory.&quot;) 
#define check_debug(A, M, ...) if(!(A)) { debug(M, 
##__VA_ARGS__);\ errno=0; goto 
error; } 
#endif 
Yes,that’sit,and here’s a 
breakdownof every line: 

dbg.h:1-2 Theusual defense against accidentally including the file twice, which you saw in thelast exercise. 
dbg.h:4-6 Includesfor the functions that these macros need. 
dbg.h:8 Thestart of a #ifdef thatlets you recompile yourprogram so thatallof thedebug logmessages are removed. 
dbg.h:9 If you compile with NDEBUG defined, then “no debug” messages will remain. 

You can seein this case the #define debug() is just replaced with nothing (theright sideis empty). 
dbg.h:10 The matching #else for theabove #ifdef. 
dbg.h:11 The alternative #define debug that translates anyuseof debug(&quot;format&quot;, 

arg1, arg2) into an fprintf call to stderr.ManyC programmersdon’t know this, but you can create macrosthat actually worklike printf andtake variablearguments. Some C compilers (actuallyCPP) don’t support this, but the ones that matter do. The magic hereis theuseof ##__VA_ARGS__ that says “putwhatever they had forextra arguments (...)here.” Alsonotice the use of __FILE__ and __LINE__ to get the current file:line for the debug message. Very helpful. 
dbg.h:12 The endof the #ifdef. 
dbg.h:14 The clean_errno macro that’s used inthe others to geta safe, readable version of errno. That strange syntax inthe middleis a ternary operator andyou’ll learn whatitdoes later. 

dbg.h:16-20 The log_err, log_warn, and log_info, macros for logging messages that are meant for the end user. They work like debug but can’t be compiled out. 

dbg.h:22 The best macro ever, check, will make sure thecondition A is true, and if not, it logs the error M (with variableargumentsfor log_err), and then jumps tothe function’s error: for cleanup. 
dbg.h:24 The second best macro ever, sentinel, isplaced in anypartof a function thatshouldn’t run, and if itdoes,it prints an errormessage andthen jumps tothe error: label. You put this in if-statements and switch-statements tocatch conditions that 
shouldn’thappen,like 

the default:. 
dbg.h:26 A shorthand macro called check_mem that makessure a pointeris valid,and ifit isn’t,it reportsit as anerror with “Outof memory.” 
dbg.h:28 Analternative macro, check_debug, which stillchecks and handles an error, but ifthe error iscommon,then it doesn’tbother reporting it. In this one, it will use debug instead of log_err to report the message. So when you define NDEBUG, the check still happens, and the error jump goesoff, butthe messageisn’t printed. 
Using dbg.h 

Here’s an exampleof using all of dbg.h in a small program. This doesn’t actually doanything but demonstratehow touseeach macro. However, we’llbe using these macros inall of the programswe write from now on, so be sureto understand how tousethem. 

ex19.c 


```c

1 #include 
&quot;dbg.h&quot; 
2 #include 
&lt;stdlib.h&gt; 
3 #include 
&lt;stdio.h&gt; 

4 
5 void 
test_debug() 6 {7 // notice 
you don't need the \n 
8 debug(&quot;I have Brown Hair.&quot;); 
9 
10 // passing in arguments like printf 
11 debug(&quot;I am %d years old.&quot;, 37); 
12 }
1. 14 void 

test_log_err() 
15 {
16 log_err(&quot;I 
believe everything is broken.&quot;); 17 log_err(&quot;The are %d problems in 
%s.&quot;, 0, &quot;space&quot;); 
18 }
1. 20 void 

test_log_warn() 
21 {
22 log_warn(&quot;Yo can safely ignore this.&quot;); 
23 log_warn(&quot;Ma consider looking at: %s.&quot;, &quot;/etc/passwd&quot;); 
24 }
2. 26 void 

test_log_info() 27 {
28 log_info(&quot;We I did somethingmundane.&quot;); 
29 log_info(&quot;It happened %f times today.&quot;, 1.3f); 
30 }
31 
32 int 

test_check(char 
*file_name)
33 {
34 FILE *input 
= NULL;35 char *block = NULL;
36 
37 block = 
malloc(100); 38 check_mem(bl 
should work 
39 
40 input = fopen(file_name,&quot;r&quot;);
41 check(input,&quot;Failed to open %s.&quot;,file_name); 
42 43 free(block);44 fclose(input 
45 return 0;
46 
47 error: 
48 if (block)free(block); 
49 if (input)fclose(input); 
50 return -1;
51 }
52 
53 int 

test_sentinel(int 
code)
54 {
55 char *temp 
= malloc(100); 
56 check_mem(te 57 58 switch 
(code){ 59 case 1: 60 log_ 
worked.&quot;); 61 brea 62 default: 63 sent 
shouldn't run.&quot;); 
64 
}
65 
66 free(temp); 
67 return 0;
68 


69 error: 70 if (temp)71 free(tem 72 return -1;

73 
}
74 
75 int 



test_check_mem() 76 {77 char *test 
= NULL;78 check_mem(te 79 80 free(test); 81 return 1;82 
83 error: 84 return -1;
85 }
86 
87 int 

test_check_debug() 88 {89 int i = 0;90 check_debug(
!= 0, &quot;Oops, I was 
0.&quot;);91 92 return 0;93 error: 94 return -1;
95 } 
96 
97 int main(int 

argc, char *argv[]) 98 {99 check(argc 
== 2, &quot;Need an argument.&quot;); 100 101 test_debug()102 test_log_err 103 test_log_war 104 test_log_inf 105 106 check(test_c == 0, &quot;failed with ex19.c&quot;); 
107 check(test_c == -1, &quot;failed with argv&quot;); 108 check(test_s == 0, &quot;test_sentinel failed.&quot;); 109 check(test_s == -1, &quot;test_sentinel failed.&quot;); 110 check(test_c == -1,
&quot;test_check_mem failed.&quot;); 111 check(test_c == -1,
&quot;test_check_debugfailed.&quot;); 
11. 113 return 0;
11. 115 error: 
116 return 1;

117 } 
Payattentionto how check is used, and when it’s false,it jumps tothe error: labelto doa cleanup. Theway toread thoselines is, “check that A is true,and ifnot, say M and jump out.” 


What You Should See 

When yourunthis, giveit somebogusfirst parameter to seethis: 


Exercise 19 Session 


```c

$ make ex1. cc -Wall -g ­DNDEBUG ex19.c ­o ex1. $ ./ex19 test 
[ERROR] (ex19.c:16: errno: None) I believe everything is broken. [ERROR] (ex19.c:17: errno: None) There are 0 problems in space. [WARN] (ex19.c:22: errno: None) You can safely ignore this. [WARN] (ex19.c:23: errno: None) Maybe consider looking at: /etc/passwd. [INFO] (ex19.c:28) 

Well I did something mundane. [INFO] (ex19.c:29) It happened 1.300000 times today. [ERROR] (ex19.c:38: errno: No such file or directory) Failed to open test. [INFO] (ex19.c:57) It worked. [ERROR] (ex19.c:60: errno: None) I shouldn't run. [ERROR] (ex19.c:74: errno: None) Out of memory. 

See how itreports theexact linenumberwherethe check failed? That’sgoing to save you hours of debugginglater. Also, see how it prints the error messageforyouwhen errno is set?Again,that will save youhours of debugging. 
How the CPP Expands Macros 

It’s nowtimeforyouto get a short introductionto theCPP so thatyou knowhowthese macros actually work. To do this, I'mgoing to break down the most complex macro from dbg.h,and haveyourun cpp so youcan seewhat it’s actually doing. 
Imagine thatIhave a function 

called dosomething()thatreturns thetypical 0 for successand -1 for an error. EverytimeI call dosomething, I have to check forthis errorcode, so I’d write codelike this: 

```c

int rc = 
dosomething(); 
if(rc != 0) {fprintf(stderr,&quot;There was an error: 
%s\n&quot;, strerror());goto error; } 

WhatI wantto use the CPP for is to encapsulatethis if-statement into a more readable andmemorable line ofcode. I wantwhatyou’ve been doing in dbg.h with the check macro: 

```c

int rc = 
dosomething(); 

check(rc == 0, &quot;There was an error.&quot;); 

This is much clearerand explains exactly what’s going on:Check that the function worked, and if not, reportan error. To dothis, we need somespecial CPP tricks that makethe CPP usefulas a codegeneration tool. Take a look at the check and log_err macros again: 

```c

#define log_err(M, ...) fprintf(stderr,\
&quot;[ERROR] (%s:%d:
errno: %s) &quot; M &quot;\n&quot;, 
__FILE__, __LINE__,\
clean_errno(),
##__VA_ARGS__)
#define check(A, M, 
...) if(!(A)) {\
log_err(M,
##__VA_ARGS__);
errno=0; goto error; 
} 

The first macro, log_err, is simpler. It simply replaces itself with acall to fprintf to stderr. The only tricky part of this macro is the use of ... in the definition log_err(M, ...). What this does islet you pass variableargumentsto the macro, so you can pass in the arguments that should goto fprintf. Howdo they get injected into the fprintfcall? Look at the endfor the 
##__VA_ARGS__, which is 

tellingthe CPP to takethe args enteredwhere the ... is,and inject them at thatpart ofthe fprintf call. You can then do thingslike this: 

```c

log_err(&quot;Age: %d, 
name: %s&quot;, age, 
name); 

The arguments age, name are the ... part of the definition,and thoseget injected into thefprintf output: 

```c

fprintf(stderr, &quot; [ERROR] (%s:%d:errno: %s) Age %d: name %d\n&quot;,
__FILE__,__LINE__,clean_errno(), age, name); 

See the age, name at the end?That’s how ... and ##__VA_ARGS__ work together,whichwillwork in macros thatcall other variable argument macros. Look atthe check macro now andsee thatit calls log_err, but check is also usingthe ... and ##__VA_ARGS__ todo the call. That’s howyoucan pass full printf style format strings to check, which goto log_err, and thenmakebothwork like printf. 

The nextthing to study is how check crafts the if-statement for the error checking. If we strip out the log_err usage, we see this: 

```c

if(!(A)) { errno=0; goto error; } 
Which means: If A is false, thenclear errno and goto the error label. The check macro is being replacedwith the if-statement,soif we manually expand out the macro check(rc == 0, &quot;There was an error.&quot;), we getthis: 

```c

if(!(rc == 0)) {log_err(&quot;There 
was an error.&quot;);errno=0; goto error; 
} 

Whatyoushould be getting 

fromthis trip throughthese twomacros isthat theCPP replacesmacros with the expandedversion of their definition,and it will dothis recursively, expanding allof the macros in macros. The CPP, then, is justa recursive templatingsystem, asI mentioned before. Its power comesfromits ability to generate whole blocks of parameterizedcode, thus becoming a handy code 
generation tool. That leaves one question: Why notjust use a function like die?The reason is that you want file:line numbers and the gotooperation for anerror handling exit. If you did this inside afunction,you wouldn’tget aline number where the error actually happened, and the goto would be much morecomplicated. 

Another reason isthatyou stillhave to writethe raw if-statement, which looks likeall of the other if-statements inyour code, so it’snot as clear that this oneis an error check. By wrapping the if-statement ina macro called check, you make it clearthat thisis just error checking, andnotpart of the main flow. 

Finally,CPPhasthe abilityto 

conditionally compile 
portions ofcode, so you can havecode that’s only present when youbuild a developer ordebug version of the program. You can see this already inthe dbg.h file where the debug macroonly has abody if thecompiler asks for it. Without this ability, you’d needa wasted if-statement that checks for debug mode, andthen wastes CPU capacity doing thatcheck for novalue. 

Extra Credit 

• Put #define NDEBUG at the top of the file andcheck that all ofthe debug messages go away. 

• Undothat line, and add -DNDEBUG to CFLAGS at the top ofthe 


Makefile, and then recompile to see the same thing. 

• Modify theloggingso thatitincludes the function name,as well asthe file:line. 



Exercise20. Advanced Debugging Techniques 
I’ve already taught youabout myawesomedebug macros, and you’ve beenusing them. When I debug code I use the debug() macro almost exclusively to analyze what’s goingon and track downthe problem. In this exercise,I'm goingto teach you thebasics ofusingGDB toinspecta simple programthat runs and doesn’texit. You’lllearnhow to use GDB to attach to a running process, stopit, and seewhat’shappening. After that, I’llgive you some little tips and tricks thatyoucan use with GDB. 

This is anothervideo-focused exercisewhere I showyou advanced debugging tricks with mytechnique. The discussion belowreinforces the video, so watch the video first. Debuggingwillbemuch easier tolearnby watching me do it first. 
Debug Printing versus GDB 
I approach debugging primarily with a “scientific method” style:Icomeup with possible causes andthen rule them outor provethat theycausethe defect. The problem many programmers havewith this approach is thatthey feel likeitwillslow them down. They panic and rush to solve the bug, butin their rush theyfailto notice thatthey’re reallyjust flailing aroundand gatheringno useful information. Ifind that logging (debug printing) forces me tosolve a bug scientifically, andit’s also justeasier to gather informationin most situations. 

Inaddition, Ihave these reasonsfor using debug printingas my primary debuggingtool: 
• You seean entire tracing of aprogram’s executionwithdebug 

printing of variables, which lets you track how things are going wrong. With GDB,you have toplace watch and debug statements all over theplace for everythingyouwant, and it’s difficultto get a solid trace of the execution. 

• The debug prints can 
stay inthe code, and 


when youneed them, you can recompile and theycomeback. With GDB, you haveto configurethe same informationuniquely for every defect you have tohunt down. 

• It’s easierto turn on debug logging on a server that’s not working right,and then inspect the logs while it 

runs to seewhat’s going on. System administrators know how to handle logging, butthey don’t know how to use GDB. 

• Printing things is just easier. Debuggers are alwaysobtuseand weird with their own quirky interfacesand inconsistencies. There’s nothing complicated 


about debug(&quot;Yo, dis right? %d&quot;, my_stuff);. 
• When you write debug prints tofind adefect, you’re forced to actually analyze the code and use the scientificmethod. You can think of debug usage as, “I hypothesize thatthe code is broken here.” Thenwhen you run it, youget your hypothesis tested, andif it’snot broken,then you can move to anotherpartwhereit could be. This may seem like it takes longer, but it’sactually faster because you go through a process of differential diagnosis and rule out possible causes until you find the realone. 
• Debugprinting works better with unit testing. You can actually just compilethe debugs while you work, and when aunittest explodes, justgo look at the logs at any time. With GDB, you’d have to rerunthe unit test under GDB and then trace through it to see what’s goingon. 
Despite all ofthese reasons thatIrelyon debug over GDB,Istilluse GDB ina few situations, and I think you should have any toolthat helpsyouget your work done. Sometimes,youjust haveto connect to a broken programand poke around. Or, maybe you’ve got a server that’s crashingand you can only getatcore files to seewhy. In these anda few other cases, GDB is the way to go,and it’salways goodto haveas many tools as possible tohelp solve problems. 

Here’s abreakdown of when I use GDB versusValgrind versusdebug printing: 
• I useValgrindto catch all memory errors. I use GDBif Valgrind is having problemsor if using Valgrind would 

slowthe programdown toomuch. 

• I useprint with debug to diagnoseand fix defectsrelated to logic orusage. Thisamounts to about90% of the defectsafteryoustart using Valgrind. 

• I useGDB for the remainingmysteriously weird stuff or emergency situationsto 


gather information. If Valgrind isn’t turning anything up, and I can’t even print outthe informationthat Ineed, thenI bustout GDB and start poking around. My use of GDBin this caseis entirely togather information. Once I have anidea ofwhat’s going on,I'll go back to writing a unit test to cause the defect, and 
thendo printstatements to findout why. 

A Debugging Strategy 

This processwillactually work with any debugging technique you’re using. I'm goingto describe it interms ofusing GDB sinceit seems people skipthis process the most whenusing debuggers. Use this foreverybug until you only neediton thevery difficultones. 
• Starta little text file called notes.txt and use it asa kindof lab notesforideas,bugs, problems, and so on. 

• Beforeyou use GDB, write out the bug you’re going to fixand what could be causing it. 

• Foreachcause, write outthe filesand functions where you think thecauseis 

comingfrom, or just 
write thatyoudon’t 
know. 


• Now start GDB and pick the firstpossiblecause with good file and function variablesand setbreakpoints there. 

• Use GDB tothen run the programand confirm whetherthat is the cause. Thebestway is to see if you can use the 

set command to either fixthe programeasily orcausethe error immediately. 

• If this isn’tthe cause, thenmark in the notes.txt that it wasn’t,and why. Move on tothe next possible cause that’s easiest to debug, and keep adding information. 



Incase you haven’tnoticed, 

this is basicallythe scientific method. You writedownaset ofhypotheses, thenyouuse debuggingto proveor disprove them. Thisgives you insightintomorepossible causes and eventually you find it. This process helpsyou avoid goingoverthe same possible causes repeatedly after you’vefoundthat they aren’t possible. 

You can also dothis with debug printing,the only difference is thatyouactually write out your hypotheses in the source codeinsteadof in the notes.txt. In away, debug printing forces youto tacklebugs scientifically because you haveto write out hypothesesas print statements. 

Extra Credit 

• Finda graphical debugger andcompare using it toraw GDB. Theseare useful when the program you’re looking at is local, but theyare pointless if you have todebug a programon aserver. 

• You can enable core dumps on your OS,and when aprogram 


crashes, you’ll get a corefile. This corefile islike a postmortem of the program thatyou can load up tosee what happenedright at the crash and whatcaused it. Change ex18.c so thatitcrashes after a fewiterations, then try to geta core dumpand analyzeit. 

Exercise21. Advanced Data Types and Flow Control 

This exercisewillbea completecompendium ofthe available C datatypes and flow control structures you can use. It will workas a referenceto completeyour knowledge, andwon’t have any code for you to enter. I'll haveyou memorizesome of the information bycreating flashcards so you can getthe important concepts solidin your mind. 

For thisexerciseto be useful, you should spend at least a week hammering in the contentand filling outall of the elementsthat are missing here. You’ll be writing out whateach one means,and thenwriting aprogram to confirmwhat you’ve researched. 
Available Data Types 


Type Modifiers 


Type Qualifiers 


Type Conversion 

C usesa sort ofstepped type promotion mechanism, where it looks at two operandson either side of an expression, and promotesthe smaller side to match thelarger side beforedoing the operation. If onesideof an expression is on this list, thenthe other side is converted to that type beforethe operation is done. Itgoes in thisorder: 
1. long double 

2. double 

3. 
float 

4. 
int (butonly char 
and short int); 


5. 
long 




If youfind yourself trying to figureouthow your conversions are working in an expression,then don’t leave it to thecompiler. Useexplicit casting operations to make it exactly whatyouwant. For example, ifyou have 

```c

long + char -int * double 
Rather thantryingto figure outif itwill be converted to doublecorrectly, justuse casts: 

```c

(double)long ­(double)char ­(double)int * double 
Putting thetype you want in parentheses before the variablename is how you force it into thetype you really need. The important thing, though,is always promote up, not down. Don’t cast long into char unless you know what you’re doing. 
Type Sizes 

The stdint.h defines both asetof typdefs forexact­sized integertypes, aswell as asetof macros for thesizes ofallthe types. Thisis easier to workwiththan the older limits.h sinceitis consistent. Hereare the types defined: The pattern here is in the form(u)int(BITS)_twherea u is putin frontto indicate “unsigned,” and BITS is a number for thenumberof bits. This patternisthen repeated for macrosthat returnthe maximum values of these types: 

INT(N)_MAX Maximum positivenumberof the signed integerof bits (N), such as INT16_MAX. 
INT(N)_MIN Minimum negative number of signed integerof bits (N). 
UINT(N)_MAXMaximum positive number ofunsigned integer of bits (N). Since it’sunsigned, the minimum is0 and it can’t have a negative value. 

Warning! 
Pay attention! Don’t go looking for a literal 
INT(N)_MAX 
definition in any header file. I'm using the (N) as a placeholderforany number ofbits your platform currently supports. This (N)could be any number— 8, 16, 32, 64, maybe even128. I use this notation inthis exercise so thatIdon’t haveto literally write out every possible combination. 


There arealso macros in stdint.h for sizes ofthe size_t type,integers large enoughto hold pointers,and other handysize defining macros. Compilers haveto at least havethese,and then theycan allow other, larger types. 

Hereis a full listthat should 

be in stdint.h: 


Available Operators 


This is acomprehensivelist ofallthe operators inthe C language. In this list, I'm indicating thefollowing: 

Math Operators 

Theseperformyour basic math operations, plusI include () sinceitcalls a function andisclose to a math operation. 

Data Operators 

Theseare used toaccess data 
in different ways andforms. 


Logic Operators 

Thesehandle testing equality 
and inequality of variables. 


Bit Operators 

Theseare more advancedand are for shifting and modifying the raw bits in integers. 

Boolean Operators 


Theseare used intruth testing. Studythe ternary operator carefully. It’svery handy. 

Assignment 
Operators 


Hereare compound assignment operators that assigna value,and/or performanoperation at the same time. Most of the above operations can alsobe combined into a compound assignment operator. 

Available Control Structures 


There area few control structures thatyou haven’t encountered yet. 
do-while do { ... }while(X); Firstdoes the code in theblock, thenteststhe X expressionbefore exiting. 
break Puts a break ina 

loop,ending itearly. 

continue Stops thebody ofa loop and jumps to the testso itcan continue. 
goto Jumps to aspot in the code where you’ve placeda label:, and you’vebeen using this in the dbg.h macros to go tothe error: label. 

Extra Credit 

• Read stdint.h or a description of it, and write out all the available size identifiers. 

• Gothrough each item hereand write out what it doesin code. Researchit online so you know you gotit right. 

• Getthis information memorizedby making flashcards and spending15 minutes a day practicingit. 

• Create aprogram that prints out examples of each type,and confirm thatyour research is right. 



Exercise22. The 

Stack, Scope, 
and Globals 


The concept ofscope seems to confusequitea few people when theyfirststart programming. Itoriginally came from theuseof the systemstack (whichwe lightly covered earlier),and how it was used to store temporary variables. In this exercise, we’lllearnabout scope by learninghowa stack data structure works, andthen feedingthat conceptback in to how modern C does scoping. 

The real purpose ofthis exercise, though, is to learn where the hell things live in 
C. When someone doesn’t 
grasp the conceptof scope, 

it’salmostalways a failurein understanding where variables arecreated, exist, and die. Once you know where things are, theconcept ofscope becomes easier. 

This exercisewillrequire three files: 

ex22.h A headerfile that setsup some external variables and some functions. 

ex22.c Thisisn’tyour 

main likenormal, but instead asourcefile that willbecome the object file ex22.o,which willhave some functions andvariables in itdefined from ex22.h. 

ex22_main.c The actual main thatwillinclude the othertwo, and demonstrate what they contain, aswell as other 
scope concepts. 


ex22.h and ex22.c 

Your firststepisto create your own header file named ex22.h thatdefines the functions andextern variables: 

ex22.h 

```c


#ifndef _ex22_h #define _ex22_h 
// makes THE_SIZE in ex22.c available to other .c files 

extern int THE_SIZE; 
// gets and sets an internal static variable in ex22.c 
int get_age(); void set_age(int age); 
// updates a static variable that's inside update_ratio 
double update_ratio(double ratio); 
void print_size(); 
#endif 

The importantthing to see hereis the use of extern int THE_SIZE, which I'll explain after you createthis matching ex22.c: 

ex22.c 


```c

1 #include 
&lt;stdio.h&gt; 
2 #include 
&quot;ex22.h&quot; 
3 #include 
&quot;dbg.h&quot; 

4 5 int THE_SIZE = 1000;
6 7 static int THE_AGE = 37; 
8 

9 int get_age() 
10 {
11 return THE_AGE;
12 }
1. 14 void 

set_age(int age)
15 {
16 THE_AGE = 
age;
17 }
1. 19 double 

update_ratio(double new_ratio)
20 {
21 static double ratio = 1.0;
2. 23 double old_ratio = ratio;
24 ratio = new_ratio;
2. 26 return old_ratio;
27 }
2. 29 void 

print_size() 30 {
31 log_info(&quot;I 
think size is: %d&quot;,
THE_SIZE); 
32 } 

Thesetwofiles introduce somenew kinds ofstorage for variables: 

extern This keywordis a way totell thecompiler “the variable exists, but it’sin another ‘external’ location.” Typicallythis meansthat one .c file is going to use avariable that’s been defined in another .c file. In this case, we’re saying ex22.c has avariable THE_SIZE that willbe accessed from ex22_main.c. 
static (file) This keyword iskind ofthe inverse of extern,and says that the variable isonly used in this .c file and should notbeavailable to other partsof theprogram. Keep inmind that static at the file level(aswith THE_AGE here) is differentthan inother places. 
static (function) If you declare avariable in a function static, then thatvariable acts likea static definedin the file, but it’sonly accessible from that function. It’s away of creating constantstate for afunction,butin reality it’s rarely used in modern C programming because theyare hard to use with threads. 

In these twofiles, you should 

understand thefollowing 
variables and functions: 
THE_SIZE This is the variableyou declared extern thatyou’ll playwithfrom ex22_main.c. 
get_age and set_age Theseare taking the static variable THE_AGE, but exposingit to other partsof theprogram through functions. You can’t access THE_AGE directly, but these 
functions can. 
update_ratio Thistakes a new ratio value, and returnsthe oldone. It uses afunction level static variable ratio to keeptrackof what the ratio currently is. 
print_size This prints out what ex22.c thinks THE_SIZE is currently. 

ex22_main.c 


Onceyou have thatfile written, you can then make the main function, which uses all ofthese and demonstrates some more scope conventions. 

ex22_main.c 

```c

1 #include 
&quot;ex22.h&quot; 
2 #include &quot;dbg.h&quot; 
3 
4 const char *MY_NAME = &quot;Zed A. Shaw&quot;;
5 
6 void scope_demo(int count)
7 {
8 log_info(&quot;co is: %d&quot;, count); 
9 
10 if (count &gt; 
10) {11 int 
count = 100; // 
BAD! BUGS! 
1. 13 log_info in this scope is %d&quot;,count); 
14 }15 16 log_info(&quot;co 
is at exit: %d&quot;,
count); 
1. 18 count = 
3000;
19 20 log_info(&quot;co 
after assign: %d&quot;,count); 
21 }
2. 23 int main(int 

argc, char *argv[]) 24 {25 // test out 
THE_AGE accessors 
26 log_info(&quot;Myname: %s, age: %d&quot;,MY_NAME, get_age()); 
27 28 set_age(100)29 30 log_info(&quot;My
age is now: %d&quot;, get_age()); 
31 
32 // test out THE_SIZE extern 
33 log_info(&quot;TH is: %d&quot;, THE_SIZE); 
SIZE is now: %d&quot;, 
34 35  print_size()  
36 9;37  THE_SIZE =  
38  log_info(&quot;TH  

THE_SIZE); 39 print_size()40 
41 // test the ratio function static 
42 log_info(&quot;Ra at first: %f&quot;,update_ratio(2.0)); 
43 log_info(&quot;Ra again: %f&quot;,update_ratio(10.0)); 
44 log_info(&quot;Ra once more: %f&quot;,update_ratio(300.0)); 
45  
46  //  test  the  
scope 47  demo int  count  =  
4;48  scope_demo(c  

49 scope_demo(c * 20); 
50 
51 log_info(&quot;co after callingscope_demo: %d&quot;,count); 
52 
53 return 0;

54 } 
</code></pre>

<p>I&rsquo;ll break thisfiledownline by line,butas I do,you should findeachvariable and where it lives.</p>

<p>ex22_main.c:4 A const, which standsfor constant, and is an alternative to using a define to create a constant variable.</p>

<p>ex22_main.c:6 A simple function that demonstrates more scope issues ina function.</p>

<p>ex22_main.c:8 This prints
outthe value of count</p>

<p>asitisatthe topof the</p>

<p>function.</p>

<p>ex22_main.c:10 An if-statement that starts anew scope block, and thenhasanother count variablein it. This version of count isactually awhole new variable. It’s kind of likethe if-statement started a new minifunction.</p>

<p>ex22_main.c:11 The count thatis local to this blockis actually differentfrom theone in thefunction’s parameter list.</p>

<p>ex22_main.c:13 This prints itout so you can seeit’s actually 100 here, not whatwas passed to scope_demo.</p>

<p>ex22_main.c:16 Nowfor</p>

<p>the freaky part. You have count in two places:the parameters to thisfunction,and in the if-statement. The if-statement created anew block, so the count on line1. does not impact the parameter with the same name. This line prints itout, and you’ll seethat it printsthe valueof theparameter,
not100.</p>

<p>ex22_main.c:18-20 Then, I set the parameter count to 3000and printthat out,which willdemonstrate that you can change function parameters and theydon’t impactthe caller’s versionof the variable.
Make sure thatyou trace through this function, but don’tthink thatyou understand scopequiteyet. Just startto realize thatif you makea variable inside a block (as in if-statements or while-loops), then thosevariables are new variables thatexist only in that block. This is crucial to understand,and is also a source of many bugs. We’ll address why you shouldn’tmake a variable
inside ablockshortly. The rest of the ex22_main.c then demonstrates allof these by manipulating and printing them out:</p>

<p>ex22_main.c:26 This prints out the current valuesof MY_NAME, and gets THE_AGE from ex22.c by using the accessorfunction
get_age.</p>

<p>ex22_main.c:27-30 This uses set_age in ex22.c to change THE_AGE andthen printitout.</p>

<p>ex22_main.c:33-39 Then I dothe same thingto THE_SIZE from ex22.c,butthis time I&rsquo;m accessing it directly. I&rsquo;malso demonstrating that it’s
actually changing in thatfile byprinting it hereand with print_size.</p>

<p>ex22_main.c:42-44 Here, I show how the static variable ratio inside update_ratio is maintained between function calls.</p>

<p>ex22_main.c:46-51</p>

<p>Finally,I&rsquo;m running</p>

<p>scope_demo a few</p>

<p>timessoyoucansee the scope inaction. The big thing tonoticeisthat the local count variableremains unchanged. You must understand that passing in a variablelike this won’tlet youchangeit in thefunction. Todo that, you needourold friendthe pointer. If you were topassa pointer to this count, thenthe calledfunction would have the address ofitand could change it.
That explains what’sgoing on, but youshould trace through thesefiles and make sureyou knowwhere everythingisas you study it.</p>

<p>What You Should See</p>

<p>This time,instead of using your Makefile, Iwant you to buildthese twofiles manually so you can seehow the compileractually puts them together. Here’swhat you should doand see for output:</p>

<p>Exercise 22 Session</p>

<pre><code class="language-c">
$ cc -Wall -g ­DNDEBUG -c -o ex22.o ex22.c $ cc -Wall -g ­DNDEBUG ex22_main.c ex22.o -o ex22_main $ ./ex22_main
[INFO] 
(ex22_main.c:26) My 
name: Zed A. Shaw, 
age: 37 
[INFO] 
(ex22_main.c:30) My 
age is now: 100 
[INFO] 

(ex22_main.c:33) THE_SIZE is: 1000 [INFO] (ex22.c:32) I think size is: 1000 [INFO] (ex22_main.c:38) THE SIZE is now: 9 [INFO] (ex22.c:32) I think size is: 9 [INFO] (ex22_main.c:42) Ratio at first: 1.000000 [INFO] (ex22_main.c:43) Ratio again: 2.000000 
[INFO] 
(ex22_main.c:44) 
Ratio once more: 
10.000000 
[INFO] 
(ex22_main.c:8) count 
is: 4 
[INFO] 
(ex22_main.c:16) 
count is at exit: 4 
[INFO] 
(ex22_main.c:20) 
count after assign: 
3000 
[INFO] 
(ex22_main.c:8) count 
is: 80 

[INFO] 
(ex22_main.c:13) 
count in this scope 
is 100 
[INFO] 
(ex22_main.c:16) 
count is at exit: 80 
[INFO] 
(ex22_main.c:20) 
count after assign: 
3000 
[INFO] 
(ex22_main.c:51. count after calling 
scope_demo: 4 
</code></pre>

<p>Make sure youtrace how each variableis changing and match it tothe linethat gets output. I&rsquo;m using log_info fromthe dbg.h macros so you can get theexact line number where each variable is printed, and find itinthe filesfortracing.
Scope, Stack, and Bugs</p>

<p>If you’vedone this right, you should now see many ofthe differentways you can place variables inyour C code. You can use extern or access functions like get_age to createglobals. You canmake new variables inside any blocks,and they’ll retain their own valuesuntilthatblock exits, leavingthe outer variables alone. Youalso can pass avalue toa function, and change the parameter but without changing the caller’s versionof it. The mostimportantthing to realizeisthat allof this causes bugs. C’sability to place thingsin many places in your machine,and thenlet you access itin thoseplaces, meansthat you can geteasily confusedabout where something lives. If you don’t know where itlives,then there’s a chanceyou won’t manage it properly.</p>

<p>With thatin mind, hereare somerules tofollowwhen writing C codeso you can avoid bugs related to the stack:
• Donotshadowa variablelike I’ve done herewith count in scope_demo. It leaves you open to subtle and hidden bugs where you think you’re changing avalue but</p>

<p>you’re actually not.</p>

<p>• Avoid using toomany globals, especially if across multiplefiles. If you have tousethem, thenuseaccessor functions likeI’ve done with get_age. This doesn’tapplyto constants, since those are read-only. I&rsquo;m talkingaboutvariables like THE_SIZE.If you wantpeople to modify orsetthis variable, then makeaccessor functions.</p>

<p>• When indoubt,putit on theheap. Don’trely on thesemantics ofthe stack orspecialized locations. Just create things with malloc.</p>

<p>• Don’t use function static variableslike I didin update_ratio. They’re rarelyuseful and end up beinga huge painwhenyou need to makeyour code concurrentin threads. They’re also hard as hellto find compared to awell-done global variable.</p>

<p>• Avoid re using function parameters. It’s confusing as to whether you’re just re using it or if you thinkyou’re changing the caller’s version of it.</p>

<p>As with all things, theserules can be broken when it’s practical. Infact, I guarantee you’ll run into code that breaks all ofthese rulesand is perfectly fine. Theconstraints ofdifferent platformseven makeit necessarysometimes.
How to Break It</p>

<p>For thisexercise, try to access orchangesome things you can’t to break theprogram.
• Tryto directlyaccess variables in ex22.c from ex22_main.c thatyou think youcan’t access. For example, can you get at ratio inside update_ratio? Whatif you hada</p>

<p>pointer to it?</p>

<p>• Ditch the extern declaration in ex22.h to see whaterrors or warnings youget.</p>

<p>• Add static or const specifiers to differentvariables,and thentryto change them.</p>

<p>Extra Credit</p>

<p>• Research the conceptof pass by value versus pass by reference. Write an exampleof both.</p>

<p>• Use pointers to gain access to things you shouldn’thave access to.</p>

<p>• Use yourdebugger to seewhat this kind of access looks like when you do itwrong.</p>

<p>• Write a recursive function that causesa stack overflow. Don’t know what arecursive function is? Try calling scope_demo at the bottom of scope_demo itself so thatitloops.</p>

<p>• Rewritethe Makefile
so thatitcan build this.</p>

<p>Exercise23. Meet Duff’s Device</p>

<p>This exerciseisa brainteaser where I introduceyou toone ofthe most famous hacksin C called Duff’s device, named after TomDuff, its inventor. This little slice of awesome (evil?)hasnearly everythingyou’vebeen learning wrappedin onetiny, little package. Figuringout how it works is also a good, fun puzzle.</p>

<p>Warning!</p>

<p>Part of the fun of Cis thatyoucancomeup with crazyhacks like this, but thisis also what makesC annoying to use. It’s good tolearnabout these tricks because it givesyoua deeper understandingof the languageand your computer. Butyou shouldneverusethis. Always strive for easy-to-read code.</p>

<p>Discovered by Tom Duff, Duff’s deviceisa trick with the C compiler that actually shouldn’twork. I won’ttell you whatit does yetsince this is meant to be a puzzle for you to ponder andtry to solve. You’ll getthis code running and thentryto figure outwhatitdoes,and why it does itthis way.</p>

<p>ex23.c</p>

<pre><code class="language-c">
1 #include 
&lt;stdio.h&gt; 
2 #include &lt;string.h&gt; 
3 #include &quot;dbg.h&quot; 
4 
5 int normal_copy(char *from, char *to, int count)
6 {
7 int i = 0;
8 
9 for (i = 0;

i &lt; count; i++) { 10 to[i]= from[i]; 
1. }
1. 13 return i;


1. }
1. 16 int 



duffs_device(char *from, char *to, int count)
17 {
18 {
19 int n = 
(count + 7) / 8;20 21 switch 
(count % 8) { 22 case 
0: 
2. {2. =*from++;2. 7: 2. =*from++;2. 6: 2. =*from++;2. 5: 
30 
=*from++;31 
4: 32 
=*from++;33 
3: 34 
=*from++;35 
2: 36 
=*from++;37 
1. 38 =*from++;39 while (--n &gt; 0); 
40 41 42  }  }  
43  return  
count;44 } 

45 
46 int zeds_device(char *from, char *to, int count)
47 { 48 {
49 int n =(count + 7) / 8;
50 
51 switch (count % 8) { 
52 cas 
0: 53 again:*to++ 
=*from++;
54 
55 cas 7: 
56 *to++ =*from++;
57 cas 6: 
58  *to++  
= *from++;59  cas  
5:  
60  *to++  
= *from++;61  cas  
4:  
62  *to++  
= *from++;63  cas  
3:  
64  *to++  
= *from++;65  cas  
2:  

66 *to++ =*from++;
67 cas 1. 68 *to++ =*from++;
69 if (--n &gt; 0)
70 gagain;
71 
}

72 
}
73 
74 return 



count;
75 } 76 77 int 
valid_copy(char *data, int count,char expects)
78 {
79 int i = 0;
80 for (i = 0; i &lt; count; i++) { 
81 if (data[i] != expects){
82 log[%d] %c != %c&quot;, i,data[i], expects); 
83 ret 0; 
84 
85 
86 
87 

88 }89 90 int 
argc, char 91 {92 
from[1000]93 to[1000] = 94 
0;
95 
}} 
return 1. main(int *argv[]) 
char 
={ 'a' }; 
char 
{ 'c' }; int rc = 
96 // set up the from to have some stuff 
97 memset(from 'x', 1000); 98 // set it to a failure mode 
99 memset(to,'y', 1000); 100 check(valid 1000, 'y'), &quot;Not initialized right.&quot;); 101 102 // use normal copy to 
103 rc = normal_copy(from, to,1000); 104 check(rc == 1000, &quot;Normal copy failed: %d&quot;, rc); 105 check(valid 1000, 'x'), &quot;Normal copy failed.&quot;); 106 107 // reset 108 memset(to,'y', 1000); 109 110 // duffs version 
111 rc = duffs_device(from,to, 1000); 112 check(rc == 1000, &quot;Duff's device failed: %d&quot;, rc);113 check(valid 1000, 'x'), &quot;Duff's device failed copy.&quot;); 114 115 // reset 116 memset(to,'y', 1000); 117 118 // my version 
119 rc = 
zeds_device(from, to,
1000); 
120 check(rc 
== 1000, &quot;Zed's 
device failed: %d&quot;, 
rc);
121 check(valid 
1000, 'x'), &quot;Zed's 
device failed 
copy.&quot;); 
12. 123 return 0;
124 error: 
125 return 1;

126 } 
</code></pre>

<p>In this code, Ihave three versions of acopyfunction:
normal_copy This is just aplain for-loop that copiescharacters from one arrayto another.
duffs_device Thisis calledDuff’s device, named after TomDuff, the personto blame for this delicious evil.
zeds_device A versionof
Duff’s devicethat just</p>

<p>uses a goto soyou can clue into what’s happening with the weird do-while placementin duffs_device.
Studythese three functions beforecontinuing. Try to explain what’sgoing onto yourself.</p>

<p>What You Should See</p>

<p>There’sno output from this program, itjust runs and exits. Run it under your debugger tosee ifyou can catch any more errors. Try causing someof yourown, as I showed you in Exercise
4.
Solving the Puzzle</p>

<p>The first thing tounderstand</p>

<p>is thatC is ratherloose regardingsome of its syntax. This is whyyoucanputhalf ofa do-while in one part ofa switch-statement, thenthe other half somewhere else,and the code will stillwork. If you look at myversion with the goto again,it’s actuallymore clearwhat’sgoing on, but makesure you understand how thatpart works.</p>

<p>The secondthing is howthe defaultfallthrough semantics of switch-statements let you jump to aparticular case, andthenitwilljust keep running untilthe endof the switch.</p>

<p>The final clue is the count %8 and thecalculationof n at the top.</p>

<p>Now,to solvehow these functions work, dothe following:
• Print thiscode outso thatyou canwriteon somepaper.</p>

<p>• Write eachof the variables ina table as theylook whenthey get initialized rightbefore the switch-statement.</p>

<p>• Follow thelogicto the switch,then dothe jump tothe rightcase.</p>

<p>• Update the variables,</p>

<p>including the to,
from,and thearrays
theypoint at.</p>

<p>• When you gettothe while part ormy goto alternative,check your variables, and then follow the logic either back tothe top ofthe do-while or to where the again label is located.</p>

<p>• Follow throughthis</p>

<p>manual tracing, updating thevariables, until you’re sureyou seehow this flows.
Why Bother?</p>

<p>When you’vefigured outhow it actually works, the final questionis:Whywould you everwant todo this?The purposeof thistrick isto manually doloopunrolling. Large, long loops can be slow, so oneway tospeed them up is tofind somefixed chunk of the loop, andthen justduplicate thecode in the loop thatmany times sequentially. For example, if you know a loop runs a minimum of20 times, then you can putthe contents of the loop 20 timesin the source code.
Duff’s deviceisbasically
doingthis automatically by</p>

<p>chunking upthe loop into eight iteration chunks. It’s clever and actuallyworks,but these daysa goodcompiler will do this for you. You shouldn’tneed thisexcept in the rare casewhereyouhave proven it wouldimprove your speed.</p>

<p>Extra Credit</p>

<p>• Never use thisagain.</p>

<p>• Golook at the</p>

<p>Wikipedia entry for Duff’s deviceand seeif you can spotthe error. Read thearticle, compareit to the version Ihave here,and tryto understandwhy the Wikipedia code won’twork for you but workedfor Tom Duff.</p>

<p>• Create asetof macros thatletsyoucreate any length of devicelike</p>

<p>this. For example,what if you wanted to have 32 case statements and didn’t wantto write out all ofthem?Can you do amacro thatlaysdown eight at atime?</p>

<p>• Change the main to conductsome speed tests to see which oneis really the fastest.</p>

<p>• Readabout memcpy, memmove, and</p>

<p>memset,and also comparetheirspeed.</p>

<p>• Never use thisagain!</p>

<p>Exercise24. Input, Output, Files</p>

<p>You’vebeen using printfto print things, and that’s great and all, but you need more. In this exercise,you’ll be using thefunctions fscanf and fgets to build informationabout aperson in astructure. Afterthis simple introductionaboutreading input, you’ll get a full listof the functionsthat C has for I/O. Some ofthese you’ve already seen andused, so this will be anothermemorization exercise.</p>

<p>ex24.c</p>

<pre><code class="language-c">
1 #include 
&lt;stdio.h&gt; 
2 #include &quot;dbg.h&quot; 
3 
4 #define MAX_DATA 100 
5 
6 typedef enum EyeColor {
7 BLUE_EYES,GREEN_EYES,BROWN_EYES,
8 BLACK_EYES,OTHER_EYES 
9 } EyeColor;
1. 11 const char *EYE_COLOR_NAMES[] = {
12 &quot;Blue&quot;,&quot;Green&quot;, &quot;Brown&quot;,&quot;Black&quot;, &quot;Other&quot; 
13 }; 
1. 15 typedef struct Person {
16 int age;
17 char first_name[MAX_DATA]; 
18 char last_name[MAX_DATA]; 
19 EyeColor eyes;
20 float income;
21 } Person;
2. 23 int main(int 

argc, char *argv[]) 
24 {
25 Person you = {.age = 0 }; 
26 int i = 0;
27 char *in = NULL;
2. 29 printf(&quot;What 
your First Name? &quot;); 
30 in = 

fgets(you.first_name,MAX_DATA -1, stdin); 
31 check(in != NULL, &quot;Failed to read first name.&quot;); 
32 
33 printf(&quot;What your Last Name? &quot;); 
34 in = fgets(you.last_name,MAX_DATA -1, stdin); 
35 check(in != NULL, &quot;Failed to read last name.&quot;); 
36 
37 printf(&quot;How old are you? &quot;); 
38 int rc = fscanf(stdin, &quot;%d&quot;,&amp;you.age); 
39 check(rc &gt; 0, &quot;You have to enter a number.&quot;); 
40 
41 printf(&quot;What color are your eyes:\n&quot;); 
42 for (i = 0;i &lt;= OTHER_EYES; i++){
43 printf(&quot; %s\n&quot;, i + 1,EYE_COLOR_NAMES[i]); 
44 }45 printf(&quot;&gt; 
&quot;);
46 
47 int eyes = -1;
48 rc = fscanf(stdin, &quot;%d&quot;,&amp;eyes); 
49 check(rc &gt; 0, &quot;You have to enter a number.&quot;); 
50 51 you.eyes = eyes -1;
52 check(you.ey&lt;= OTHER_EYES 
53 &amp;&amp; you.eyes &gt;= 0, &quot;Do it right, that's not an option.&quot;); 
54 
55 printf(&quot;How much do you make an hour? &quot;); 
56 rc = fscanf(stdin, &quot;%f&quot;,&amp;you.income); 
57 check(rc &gt; 0, &quot;Enter a floating point number.&quot;); 
58 

59 printf(&quot;--­--RESULTS -----\n&quot;); 
60 
61 printf(&quot;Firs Name: %s&quot;, you.first_name); 
62 printf(&quot;Last Name: %s&quot;, you.last_name); 
63 printf(&quot;Age: %d\n&quot;, you.age); 
64 printf(&quot;Eyes %s\n&quot;,EYE_COLOR_NAMES[you.ey
65 printf(&quot;Inco %f\n&quot;, you.income); 
66 
67 return 0;
68 error: 
69 
70 return -1;
71 } 
</code></pre>

<p>This programis deceptively simple, and introducesa function called fscanf, which is the file scanf. The scanf family of functions are theinverseof the printf versions. Where printf printed outdata based on aformat, scanf reads (orscans) inputbased on a format.</p>

<p>There’snothing original in the beginning ofthe file, so here’s whatthe main is doingin the program:</p>

<p>ex24.c:24-28 Sets up</p>

<p>somevariables we’ll
need.</p>

<p>ex24.c:30-32 Getsyour</p>

<p>first name using the</p>

<p>fgets function, which reads a stringfrom the input (in thiscase stdin), but makes sure itdoesn’t overflow the given buffer.</p>

<p>ex24.c:34-36 Same thing for you.last_name, againusing fgets.</p>

<p>ex24.c:38-39 Uses fscanf to read an integer from stdin and put it into you.age. You can see thatthe same format string is usedas printf to print an integer. You should also seethatyou have to give the address of you.age so that fscanf has apointer to itand can modify it. This isagoodexample ofusing a pointer toa piece of data as an out parameter.</p>

<p>ex24.c:41-45 Prints outall ofthe optionsavailable for eye color, with a matching number that works with the EyeColor enum above.</p>

<p>ex24.c:47-50 Using fscanf again,getsa number for the you.eyes, butmake sure theinput is valid.</p>

<p>This isimportant because someone can enter avalue outsidethe
EYE<em>COLOR</em> NAMES</p>

<p>array andcausea</p>

<p>segmentationfault.</p>

<p>ex24.c:52-53 Getshow much you makeas a float for the you.income.</p>

<p>ex24.c:55-61 Prints everythingoutso you can seeif you haveit right. Notice that
EYE_COLOR_NAMES</p>

<p>isused toprint outwhat the EyeColor enumis actually called.</p>

<p>What You Should See</p>

<p>When yourunthis program, you should see your inputs being properlyconverted. Make sure youtryto giveit bogus inputtoo, so you can seehow itprotects against the input.</p>

<p>Exercise 24 Session</p>

<pre><code class="language-c">
$ make ex2. cc -Wall -g ­DNDEBUG ex24.c ­o ex2. $ ./ex24
</code></pre>

<p>What&rsquo;s your First Name? Zed What&rsquo;s your Last Name? Shaw How old are you? 37 What color are your eyes:
1) Blue
2) Green
3) Brown
4) Black
5) Other
&gt;1
How much do you make an hour? 1.2345 &mdash;&ndash;RESULTS &mdash;-­First Name: Zed Last Name: Shaw Age: 37 Eyes: Blue Income: 1.234500
How to Break It</p>

<p>This is all fine and good, but
the really important part of</p>

<p>this exercise is how scanf actually sucks. It’s fine for a simple conversion of numbers,but fails for strings because it’s difficultto tell scanf how biga buffer is beforeyou read it. There’s also a problem with the function gets (not fgets, the non-f version), which we avoided. That functionhasno idea how big the inputbuffer is atall andwill just trash your program. To demonstrate theproblems with fscanf andstrings, change the linesthatuse fgets so theyare fscanf(stdin,&ldquo;%50s&rdquo;,you.first_name), and thentryto use it again. Notice it seems toread too much and theneatyour enter key?This doesn’tdo whatyouthink it does, andrather thandeal with weird scanf issues,
you should justuse fgets. Next, change the fgets to use gets,then run your debugger on ex24. Do this inside:
&ldquo;run &lt;&lt; /dev/urandom&rdquo;</p>

<p>This feeds randomgarbage into your program. Thisis calledfuzzing yourprogram, and it’s agood wayto find input bugs. In this case, you’re feedinggarbage from the /dev/urandom file (device), and thenwatchingit crash. Insome platforms,you mayhave todo thisa few times, or evenadjustthe MAX_DATA definesoit’s smallenough.</p>

<p>The gets function is so bad thatsome platforms actually warn you whenthe program runs thatyou’re using gets. You should never use this function, ever. Finally,take the inputfor you.eyes andremove the check that thenumberis withinthe rightrange. Then, feedit bad numbers like -1 or 1000. Do this under the debugger so you can seewhat happens there,too.</p>

<p>The I/O Functions</p>

<p>This is ashortlist ofvarious I/O functions thatyoushould look up. Create flashcards thathave thefunctionname and allthe variants similar to it.</p>

<p>• fscanf  • fgets  • fopen  • freopen  • fdopen  • fclose  • fcloseall   • fgetpos   • fseek  • ftell  • rewind  • fprintf   • fwrite  • fread</p>

<p>Go through these and
memorize thedifferent</p>

<p>variants and whatthey do. For example, forthe card fscanf, you’llhave scanf, sscanf, vscanf, etc., and thenwhat eachof thosedoes onthe back.</p>

<p>Finally,use man to read the helpfor each variantto get the information you need for the flash cards. Forexample, the page for fscanf comes from man fscanf.</p>

<p>Extra Credit</p>

<p>• Rewritethis to not use fscanf at all. You’ll need tousefunctions like atoi to convert the inputstrings to numbers.</p>

<p>• Change this to use plain scanf instead of fscanf to see what the differenceis.</p>

<p>• Fix itso that their input namesget strippedof the trailing newline characters andany white space.</p>

<p>• Use scanf towrite a function that reads one character at a time and fillsin thenames but doesn’tgo past theend. Make this function generic so itcantake a sizefor the string, but justmake sureyouend</p>

<p>the stringwith &lsquo;\0&rsquo; no matter what.</p>

<p>Exercise25. Variable Argument Functions</p>

<p>InC, you can createyour own versions of functions like printf and scanf by creatinga variable argument function, orvararg function.</p>

<p>Thesefunctions use the header stdarg.h, and with them,youcancreate nicer interfacesto your library. They arehandyfor certain typesof builder functions, formatting functions, and anything thattakes variable arguments.
Understanding vararg functions is not essentialto creatingC programs. Ithink I’ve used itmaybe 20 times in my codein all ofthe years I’ve beenprogramming. However, knowing howa varargfunction works will helpyoudebug the programs you use and gives you a better understandingof the computer.</p>

<p>ex25.c</p>

<pre><code class="language-c">
1 
2 

3 #include &lt;stdlib.h&gt; 
4 #include &lt;stdio.h&gt; 
5 #include &lt;stdarg.h&gt; 
6 #include &quot;dbg.h&quot; 
7 
8 #define MAX_DATA 100 
9 
10 int read_string(char **out_string, int max_buffer)
11 {
12 *out_string = calloc(1,max_buffer + 1); 
13 check_mem(*o 
1. 15 char *result = fgets(*out_string,max_buffer, stdin); 
16 check(result != NULL, &quot;Input error.&quot;); 
1. 18 return 0; 
1. 20 error: 
21 if (*out_string)free(*out_string); 
22 *out_string = NULL;
23 return -1;
24 }
2. 26 int 

read_int(int 
*out_int)
27 {
28 char *input 
= NULL; 
29 int rc = 

read_string(&amp;input,MAX_DATA); 
30 check(rc == 0, &quot;Failed to read number.&quot;); 
31 
32 *out_int = atoi(input); 
free(input); 
33  
34 35 36  free(input);return 0;  
37  error:  
38  if (input)  

39 return -1;
40 }
41 
42 int 

read_scan(const char 
*fmt, ...) 43 {44 int i = 0;45 int rc = 0;46 int 
*out_int = NULL;47 char *out_char = NULL;48 char **out_string = NULL;49 int 
max_buffer = 0;50 51 va_list 
argp;52 va_start(arg
fmt);53 54 for (i = 0;
fmt[i] != '\0'; i++){55 if 
(fmt[i] == '%'){ 56 i++;57 swit 
(fmt[i]) { 58 
'\0': 59 
format, you ended with %%.&quot;); 60 61 62 
'd': 
63 = va_arg(argp, int *);
64 = read_int(out_int); 65 == 0, &quot;Failed to read int.&quot;); 66 
67 
68 

'c': 
69 = va_arg(argp, char *);
70 
= fgetc(stdin); 71 72 73 
's': 
74 = va_arg(argp, int); 
75 = va_arg(argp, char **); 76 
= 
read_string(out_stringmax_buffer); 
77 == 0, &quot;Failed to read string.&quot;); 
78 
79 
80 
81 

format.&quot;); 
82 
}

83 
} else {

85 
}86 


84 fget 
87 check(!f &amp;&amp; !ferror(stdin), &quot;Input error.&quot;); 
88 89  }  
90 91 92  va_end(argp)return 0;  
93  error:  
94 95 96 97  }  va_end(argp)return -1;  
98  int main(int  

argc, char *argv[]) 
99 {100 char *first_name = NULL;101 char initial = '';102 char *last_name = NULL;103 int age = 0;
104 105 printf(&quot;What your first name? &quot;); 106 int rc = read_scan(&quot;%s&quot;,MAX_DATA, 
&amp;first_name); 
107 check(rc == 
0, &quot;Failed first 
name.&quot;); 
108 
109 printf(&quot;What 
your initial? &quot;); 
110 rc = 
read_scan(&quot;%c\n&quot;,
&amp;initial); 
111 check(rc == 
0, &quot;Failed 
initial.&quot;); 
11. 113 printf(&quot;What 
your last name? &quot;); 

114 rc = 
read_scan(&quot;%s&quot;,
MAX_DATA,
&amp;last_name); 
115 check(rc == 
0, &quot;Failed last 
name.&quot;); 
11. 117 printf(&quot;How 
old are you? &quot;); 
118 rc = 
read_scan(&quot;%d&quot;,
&amp;age); 
11. 120 printf(&quot;--­-RESULTS ----\n&quot;); 

121 printf(&quot;Firs Name: %s&quot;,first_name); 122 printf(&quot;Init '%c'\n&quot;, initial); 123 printf(&quot;Last Name: %s&quot;,last_name); 124 printf(&quot;Age: %d\n&quot;, age); 125 126 free(first_n 127 free(last_na 128 return 0;129 error: 130 return -1. 131 } 
</code></pre>

<p>This programis similar to the previous exercise, except I havewritten my own scanf function tohandle strings the way Iwant. The main function shouldbe clear to you,as wellas thetwo functions read_string and read_int, sincethey do nothingnew.</p>

<p>The varargs functionis called
read_scan, anditdoes the</p>

<p>same thingthat scanf is doingusingthe va_list data structure andsupporting macros andfunctions. Here’s how:
• Iset as the last parameter ofthe function thekeyword &hellip; to indicateto C thatthis function will take any number of arguments after the fmt argument. I could put</p>

<p>many other arguments
beforethis,butIcan’t
putany more after this.</p>

<p>• Aftersetting up some variables, I createa va_list variableand initializeit with va_start. This configures thegear in stdarg.h that handles variable arguments.</p>

<p>• Ithen use a for-loop to loop through the format string fmt and processthe same kind offormats that scanf has,onlymuch simpler. I justhave integers, characters, and strings.</p>

<p>• When I hit aformat, I use the switch-statement tofigure outwhattodo.</p>

<p>• Now, to get a variable fromthe va_list argp,I use the macro va_arg(argp,TYPE) where TYPE is the exacttype of what I willassign this function parameter to. The downsideto thisdesign isthatyou’re flying blind, so ifyou don’t have enough parameters,then oh well, you’ll most likely crash.</p>

<p>• The interesting difference from scanf isI&rsquo;m assumingthat people want read_scan tocreate the stringsit reads when it hitsan &rsquo;s&rsquo; format sequence. When you givethis sequence,the function takestwo parameters off the va_list argp stack:the maxfunction sizeto read, and the outputcharacter string pointer. Usingthat information, itjust runs read_string todo the realwork.</p>

<p>• This makes read_scan more consistentthan scanf, since you always give an address-of &amp; on variables tohave them setappropriately.</p>

<p>• Finally, if thefunction encounters acharacter that’s notin the correct format,it just reads one charto skipit. It doesn’tcarewhatthat charis, justthat it should skip it.</p>

<p>What You Should See</p>

<p>When yourunthis one, it’s similarto the last one.</p>

<p>Exercise 25 Session</p>

<pre><code class="language-c">
$ make ex2. cc -Wall -g ­DNDEBUG ex25.c ­o ex2. $ ./ex25
</code></pre>

<p>What&rsquo;s your first name? Zed What&rsquo;s your initial? A What&rsquo;s your last name? Shaw How old are you? 37 &mdash;-RESULTS &mdash;­First Name: Zed Initial: &lsquo;A&rsquo; Last Name: Shaw Age: 37
How to Break It</p>

<p>This programshould be more robustagainstbuffer overflows, but it doesn’t handle theformatted inputas wellas scanf. To tryto break this, change thecode so thatyou forget topass in the initial size for ‘%s’ formats. Try giving it moredata than MAX_DATA, and then see how omitting calloc in read_string changes how it works. Finally,there’s a problem where fgets eats the newlines, so try tofix that using fgetc,butleave out the \0 that ends thestring.</p>

<p>Extra Credit</p>

<p>• Makedouble andtriple sure that you know whateach of the out_ variables is doing. Most importantly, you should know what out_string is and how it’s a pointer to a pointer,sothat you understand when you’re setting thepointer versusthe contents is important.</p>

<p>• Write a similarfunction to printf that uses the varargssystem, and rewrite main to use it.
• As usual,read theman page on all ofthis so thatyou knowwhatit does on your platform. Some platforms willuse macros,others will use functions, and some willhave thesedo nothing. It alldepends on thecompiler and the platformyouuse.</p>

<p>Exercise26. Project
logfind</p>

<p>This is asmall project for you to attempt on yourown. To be effectiveatC, you’ll need to learn toapplywhatyou know toproblems. In this exercise, Idescribe atoolI wantyouto implement, andI describe it ina vague way on purpose. This is done so that you willtryto implement whateveryoucan, however you can. Whenyou’redone, you can thenwatcha video for the exercise that shows you how I didit,and then you can getthe code and compare it toyours.</p>

<p>Think ofthis projectas a real­worldpuzzle that you might haveto solve.</p>

<p>The logfind
Specification</p>

<p>I want atoolcalled logfind that lets me search through log filesfor text. This tool is aspecializedversion ofanother tool called grep, butdesigned only for log files on a system. Theidea isthatI can type:
logfind zedshaw</p>

<p>And,itwillsearch allthe common places that log files are stored, andprint out every filethat has theword “zedshaw” in it.</p>

<p>The logfind tool should
havethesebasic features:</p>

<ol>
<li><p>This tool takesany sequenceof wordsand assumes Imean “and” for them. So logfind zedshaw smart guy willfind all files thathave zedshaw and smart and guy in them.</p></li>

<li><p>Ittakes an optional argument of -o if the parameters are meant to be or logic.</p></li>

<li><p>Itloads thelist of allowed log filesfrom ~/.logfind.</p></li>

<li><p>The listof file names can be anything that the glob function allows. Refer to man 3 globto see howthis works. I suggest startingwith justa flat list of exact files, andthenadd glob functionality.</p></li>

<li><p>You shouldoutputthe matching linesas you scan,and try to match them asfast aspossible.</p></li>
</ol>

<p>That’s the entire description.</p>

<p>Remember thatthis may be
very hard, so takeit atinybit</p>

<p>at atime. Write some code, test it, write more, test that, and so on in little chunks until you haveit working. Start with thesimplest thing thatgets it working, andthen slowly addto it and refine it until every featureisdone.</p>

<p>Exercise27. Creative and Defensive Programming</p>

<p>You have now learnedmost ofthe basics ofC programming andare ready to start becoming a serious programmer. This is where you go from beginner to expert, both with C and hopefullywithcore computer science concepts. I will be teaching you a fewof the coredata structures and algorithmsthat every programmershould know, and then a fewvery interesting onesI’ve used in realsoftware for years.
Before I cando that, Ihave to teach you some basic skills and ideasthat will help you makebetter software. Exercises
2. through 31
will teach you advancedconcepts, featuring moretalking than coding. Afterthat, you’ll apply what you’velearned to makea core library ofuseful data structures.</p>

<p>The first step ingetting better at writing C code(and really any language)is tolearna new mind-setcalled defensive programming.Defensive programming assumesthat you are goingto makemany mistakes,and then attempts to preventthematevery possible step. In this exercise, I&rsquo;m going to teachyouhow to thinkabout programming defensively.</p>

<p>The Creative Programmer Mind-Set</p>

<p>It’s notpossibleto show you how to be creativein ashort exerciselike this,but Iwill tellyou that creativity involvestaking risksand being open-minded. Fear will quicklykillcreativity, so the mind-set I adopt, andmany programmerscopy, is that accidents are designedto makeyouunafraid of taking chances and looking likean idiot. Here’s mymind-set:
• Ican’t make a mistake.</p>

<p>• Itdoesn’t matterwhat people think.</p>

<p>• Whatever mybrain comesup with is going to be a great idea.</p>

<p>I only adoptthis mind-set temporarily, andeven have little tricks to turnit on. By doingthis,I can come up with ideas, find creative solutions,open my thoughts to odd connections, andjust generally invent weirdness without fear. In thismind-set, I&rsquo;ll typically write a horrible first versionof somethingjust to getthe idea out.</p>

<p>However, when I’vefinished mycreative prototype, Iwill throwit outand getserious about making it solid. Where other people make a mistake is carrying the creativemind­set into their implementation phase. This then leads to a very different, destructive mind-set: thedarkside ofthe creative mind-set:
• It’s possible towrite perfect software.</p>

<p>• Mybrain tells methe truth, andit can’tfind any errors: I have therefore written perfect software.</p>

<p>• Mycode is who I am and peoplewho criticize its perfection are criticizing me.</p>

<p>Theseare lies. Youwill frequently run into programmerswho feel intense pride about what they’vecreated, which is natural, but this pridegets in the way of theirability to objectively improvetheir craft. Because of this pride and attachmenttowhat they’vewritten, they can continueto believe that what theywrite isperfect. As long asthey ignore other people’s criticismof theircode,they can protecttheirfragile egos and neverimprove.</p>

<p>The trick to being creative and makingsolidsoftware is the ability to adopt a defensiveprogramming mind-set.</p>

<p>The Defensive Programmer Mind-Set</p>

<p>After you haveaworking, creative prototype and you’re feelinggoodabout the idea, it’stimeto switchto being a defensiveprogrammer. The defensiveprogrammer basically hates your code and believes these things:
• Softwarehaserrors.</p>

<p>• You aren’tyour software, yetyou’re responsible for the errors.</p>

<p>• You can never remove the errors,onlyreduce their probability.</p>

<p>This mind-set lets you be honest about yourwork and critically analyzeit for improvements. Notice that it doesn’tsay you are full of errors?It says your code is full oferrors. This isa significant thingto understand becauseit gives you the powerof objectivity for the next implementation.</p>

<p>Just likethe creative mind-set,the defensive programming mind-set has a dark side, aswell. Defensive programmersare paranoid, and this fearprevents them fromever possibly being wrongor making mistakes.</p>

<p>That’s greatwhen you’re trying to be ruthlessly consistentand correct, butit’s murder oncreative energy and concentration.</p>

<p>The Eight Defensive Programmer Strategies</p>

<p>Once you’ve adopted this mind-set,youcanthen rewriteyour prototypeand follow asetof eight strategies to make yourcode assolidas possible. While I workon the realversion,I ruthlessly follow these strategies and try to remove asmanyerrors as I can,thinking like someone who wantsto break the software.</p>

<p>Never Trust Input</p>

<p>Never trust the datayou’re given andalways validate it.
Prevent Errors If an erroris possible, no matter how probable, tryto prevent it.</p>

<p>FailEarly and Openly
Failearly, cleanly, and openly, stating what happened, where, and how to fix it.</p>

<p>Document Assumptions
Clearly state thepre­conditions, post­conditions, and invariants.</p>

<p>Prevention over Documentation. Don’t do with documentation that whichcan be done with code or avoided completely.
AutomateEverything
Automate everything,</p>

<p>especially testing.
Simplifyand Clarify
Always simplify the</p>

<p>code tothe smallest,</p>

<p>cleanestform that works without sacrificing safety.</p>

<p>Question Authority</p>

<p>Don’t blindly follow or reject rules.</p>

<p>Thesearen’t theonly strategies, butthey’re thecore things Ifeel programmers haveto focuson when trying to make good, solid code. Notice thatI don’treallysay exactly how to dothese. I&rsquo;ll
go into eachof thesein more detail,and someof the exerciseswillactually cover them extensively.
Applying the Eight Strategies</p>

<p>Theseideas are allas great pop-psychology platitudes, buthowdo you actually apply them to working code? I&rsquo;m now goingto give youa set of thingsto alwaysdo in this book’s codethat demonstrates each one with a concrete example. The ideas aren’t limited tojust these examples, so you should use these as aguideto making your own codemore solid.</p>

<p>Never Trust Input</p>

<p>Let’s look at an exampleof bad designand better design. I won’t say good design because this could be done even better. Take a look at these two functions that both copy astring and a simple main to testout thebetter one.</p>

<p>ex27_1.c</p>

<pre><code class="language-c">
12
#undef NDEBUG #include 
&quot;dbg.h&quot; 

3

#include 

&lt;stdio.h&gt; 

4

#include 

&lt;assert.h&gt; 

/* 756
* 
Naive copy 

that assumes all inputs are always valid 
8

* taken from 

K&amp;R C and cleaned up 


A bit. 

9 */ 
10 void copy(char to[], char from[]) 
11 {
12 int i = 0;
1. 14 // while loop will not end if from isn't '\0' terminated 
15 while ((to[i]= from[i]) != '\0'){ 
16 ++i;
1. } 

1. }
1. 20 /* 
21 * A safer version that checks for many common errors using the
22 * length of each string to control the loops and termination. 
23 */ 
24 int safercopy(int from_len, char *from,int to_len, char *to) 25 {
26 assert(from != NULL &amp;&amp; to != NULL &amp;&amp; &quot;from and to can't be NULL&quot;); 
27 int i = 0;
28 int max = from_len &gt; to_len -1 ? to_len -1: from_len;
2. 30 // to_len must have at least 1 byte 
31 if (from_len &lt; 0 || to_len &lt;= 0)
32 return -1;
33 
34 for (i = 0;i &lt; max; i++) { 
35 to[i]= from[i]; 
36 }37 38 to[to_len ­
1] = '\0';39 40 return i;
41 }
42 

43 int main(int argc, char *argv[]) 
44 {
45 // careful to understand why we can get these sizes 
46 char from[] = &quot;0123456789&quot;;
47 int from_len = sizeof(from); 
48 
49 // notice that it's 7 chars + \0 
50 char to[] = &quot;0123456&quot;; 
51 int to_len = sizeof(to); 
52 
53 debug(&quot;Copyi '%s':%d to '%s':%d&quot;,from, from_len, to,to_len); 
54 
55 int rc = safercopy(from_len,from, to_len, to); 
56 check(rc &gt; 0, &quot;Failed to safercopy.&quot;); 
57 check(to[to_ -1] == '\0', &quot;String not terminated.&quot;); 
58 

59 debug(&quot;Resul is: '%s':%d&quot;, to,to_len); 
60 
61 // now try to break it 
62 rc = safercopy(from_len * -1, from, to_len,to);
63 check(rc == -1, &quot;safercopy should fail #1&quot;); 
64 check(to[to_ -1] == '\0', &quot;String not terminated.&quot;); 
65 66 rc = 
safercopy(from_len,from, 0, to); 
67 check(rc == -1, &quot;safercopy should fail #2&quot;); 
68 check(to[to_ -1] == '\0', &quot;String not terminated.&quot;); 
69  
70 71  return 0;  
72  error:  
73 74  }  return 1;  
</code></pre>

<p>The copy function is typical C code and it’s the sourceof ahugenumberof buffer overflows. It’s flawed because itassumes thatit will alwaysreceivea valid, terminated C string(with &lsquo;\0&rsquo;), andjust uses a while-loop toprocessit. Problemis, to ensure that is incrediblydifficult, and ifit’s nothandled right, itcauses the while-loop to loop
infinitely. A cornerstone of writing solid code is never writing loops that can possibly loop forever.</p>

<p>The safercopy function triesto solvethis byrequiring the caller to give thelengths ofthe twostrings it must deal with. By doing this,it can makecertain checks about these stringsthat the copy function can’t. It can check thatthe lengths areright,and thatthe to string has enough space,and itwill always terminate. It’simpossiblefor this functionto run onforever likethe copy function.</p>

<p>This is the ideabehind never trusting the inputsyou receive. If you assumethat your functionisgoing to geta string that’s not terminated (whichis common), thenyou can design yourfunction so thatit doesn’t rely onit to work properly. If you need the argumentsto never be NULL,then you shouldcheck for that, too. Ifthe sizes should bewithin sane levels, thencheck that. You simply assumethat whoever is calling you got it wrong,and thentryto makeit difficult for them to give you another bad state.</p>

<p>This extends to software you
write thatgets input from the</p>

<p>externaluniverse. The famouslastwords ofthe programmerare, “Nobody’s goingto do that.” I’ve seen them say thatand then the next day someone does exactly that, crashing or hackingtheirapplication. If you say nobody isgoing todo that, justthrow inthe codeto makesure they simplycan’t hack your application. You’ll be glad youdid.</p>

<p>There is a diminishing return on this,buthere’s a listof things Itry todo inallof the functions I writein C:
• Foreachparameter, identify what its preconditions are, and whetherthe precondition should cause afailure or return an error. If you are writing a library,favor errors over failures.</p>

<p>• Add assert calls at the beginning that check foreachfailure precondition using</p>

<p>assert(test &amp;&amp;</p>

<p>&ldquo;message&rdquo;);. This</p>

<p>little hack does the test,</p>

<p>and when itfails, the</p>

<p>OSwilltypically print</p>

<p>the assert line for</p>

<p>you thatincludesthat</p>

<p>message. This is very</p>

<p>helpful whenyou’re
trying to figure outwhy
that assert isthere.</p>

<p>• Forthe other preconditions, return the error code or use my check macro togive an errormessage. I didn’t use check in this example since it would confusethe comparison.</p>

<p>• Document why these preconditions existso</p>

<p>thatwhen a programmerhits the error, he or she can figureoutif they’re really necessary ornot.</p>

<p>• If you’re modifying the inputs, makesure that theyare correctly formed when the function exits, or abort if they aren’t.</p>

<p>• Always check the error
codes of functions you</p>

<p>use. For example, people frequently forget to check the return codes from fopen or fread,which causes them to use the resources thereturn codes give despite the error. This causes your programto crash or open an avenue for an attack.</p>

<p>• You also need to be</p>

<p>returningconsistent errorcodes so thatyou can dothis for all of your functions. Once you get inthis habit, you’ll thenunderstand why my check macros work theway they do.</p>

<p>Just doingthese simple things will improve yourresource handling andprevent quite a fewerrors.
Prevent Errors</p>

<p>Inresponseto theprevious example, you mighthear people say, “Well, it’snot very likely someonewilluse copy wrong.” Despite the mountain of attacksmade against this very kindof function, somepeople still believe thatthe probability of this error is very low. Probability is a funnything because peopleare incredibly bad atguessingthe probability of any event. People are, however, much better at determining if something is possible. They mightsaythe errorin copy is not probable,but they can’t denythat it’s possible.</p>

<p>The key reason is thatfor something tobeprobable,it first has to bepossible. Determining thepossibility is easy,since we can all imaginesomething happening. What’s not so easy is determining its probability after that. Isthe chancethat someonemight use copy wrong20%, 10%, or1%?Who knows?You’d need to gather evidence, look at rates of failurein many softwarepackages, and probably surveyreal programmersabouthowthey use the function.</p>

<p>This means, if you’regoing to prevent errors, you still need to tryto preventwhat’s possible but first focus your energies onwhat’s most probable. It may notbe feasible to handleallof the possible waysyour software can be broken,butyou have to attempt it. But at thesame time,if you don’tconstrain your efforts tothe most probable events, then you’ll
be wasting time onirrelevant</p>

<p>attacks. Here’s aprocessfor determining what to prevent in yoursoftware:
• List all thepossible errors that can happen, no matter howprobable (within reason,of course). Nopoint listing “aliens sucking your memories outto steal your passwords.”</p>

<p>• Give each possible errora probabilitythat’s apercentage of the operations thatcan be vulnerable. If youare handling requests from the Internet, thenit’s the percentage of requests thatcancause the error. If they are function calls, then it’s whatpercentage of function calls can cause the error.</p>

<p>• Calculate theeffortin number ofhours or amountof code to preventit. You could also justgive aneasyor hard metric, orany metric that preventsyou fromworking onthe impossible when there are easierthings to fix stillon the list.</p>

<p>• Rank them by effort (lowest tohighest), and</p>

<p>probability (highest to lowest). This is now your tasklist.</p>

<p>• Prevent allof the errors you can in thislist, aimingforremoving the possibility, then reducing the probability if you can’t make it impossible.</p>

<p>• If there are errorsyou can’t fix, then document them so</p>

<p>someone else can fix
them. This little processwillgive you anice list of things todo, butmore importantly, keep you fromworking onuseless things when there are other more important things to work on. You canalso be more or lessformalwiththis process. If you’re doinga full security audit, thiswillbe better done with awhole team and a nicespreadsheet. If you’re just writinga function, thensimply reviewthe code and scratch theseout into somecomments. What’s important isthat you stop assumingthat errorsdon’t happen, and you workon removingthemwhenyou can without wasting effort.
Fail Early and Openly</p>

<p>If youencounteranerror inC you have two choices:
• Returnanerror code.</p>

<p>• Abort the process. This is just how itis, so what you need todo is make sure the failures happen quickly, are clearly documented,give
an errormessage, and are
easy for theprogrammer to</p>

<p>avoid. This iswhythe check macros I’ve given you work theway they do. For every error youfind,it prints a message, thefile and linenumberwhereit happened, and forces areturn code. If youjust use my macros, you’llend updoing the right thing anyway.
I tend to prefer returningan errorcode to abortingthe program. If it’scatastrophic, thenI will,but very few errors aretruly catastrophic. A good exampleof when I&rsquo;ll abort a programis if I&rsquo;m given an invalid pointer,as I didin safercopy. Instead ofhaving theprogrammer experiencea segmentation fault explosion somewhere, I catch itright awayand abort. However, if it’scommonto pass in a NULL,then I&rsquo;ll probably change that to a
check instead so thatthe callercan adaptand keep running.</p>

<p>Inlibraries, however,I trymy hardest to never abort. The software usingmy library can decideif itshould abort, and I&rsquo;ll typically abortonlyif the library is very badly used.</p>

<p>Finally,a big part ofbeing open about errorsis not using the samemessage orerror codeformore thanone possible error. You typically seethis with errorsin external resources. A library will receive an erroron a socket, and then simplyreport “bad socket.” What they should do is returnthe erroron the socketsothat itcanbe properlydebuggedand fixed. When designing your error reporting, make sureyougive adifferent error message for the different possible errors.
Document Assumptions</p>

<p>If you’refollowingalongand using this advice, thenwhat you’re doing is buildinga contractof how your functions expect the world to be. You’vecreated preconditions for each argument, you’vehandled possible errors, and you’re failingelegantly. The next step is to complete the contractand addinvariants
and postconditions. An invariantis a condition thatmustbeheld true insome state while thefunction runs. This isn’t very common in simple functions, butwhen you’re dealing with complex structures,itbecomesmore necessary. Agood example of an invariant is a condition where astructureis always initialized properlywhileit’s being used. Another example wouldbethat a sorted data structure isalways sorted during processing.</p>

<p>A postcondition is a guaranteeon theexit value or result ofa functionrunning. This can blend together with invariants,butthis is something as simple as “function always returns0or -1on error.” Usuallythese are documented,but ifyour function returns an allocated resource, you can adda postcondition that checks to makesure it’s returning something, andnot NULL. Or, you can use NULL to indicate an error,sothat your postcondition checksthatthe resource is deallocated on any errors.</p>

<p>In Cprogramming, invariants and postconditionsare usually usedmore in documentationthan actual codeor assertions. The best way to handle them is to add assert calls for theones you can,then documentthe rest. If youdo that, when people hitan errorthey can seewhat assumptions you madewhenwriting the function.
Prevention over
Documentation</p>

<p>A common problemwhen programmerswritecode is thatthey will documenta common bug rather than simplyfix it. Myfavoriteis when the Ruby onRails systemsimply assumed that all months had 30 days. Calendars arehard, so rather thanfixit,programmers threw a tiny little comment somewhere thatsaid this was on purpose, and then they refused tofixit for years.
Everytimesomeone would complain,theywould bluster and yell, “But it’s documented!”
Documentationdoesn’t matter if youcan actually fix the problem, and if the function has a fatalflaw, then justdon’t includeituntil you can fix it. In the caseof Ruby on Rails, not havingdate functions wouldhave been better than including
purposefully broken onesthat</p>

<p>nobody could use. As you go throughyour defensiveprogramming cleanups,tryto fix everything you can. If you findyourself documenting moreand more problems you can’t fix,then considerredesigning the feature or simplyremoving it. If you really haveto keepthis horriblybrokenfeature,then I suggest youwrite it, document it, andthen finda new job beforeyouare blamed forit.
Automate Everything</p>

<p>You are a programmer, and thatmeans yourjob is putting other people out ofjobs with automation. The pinnacleof this is putting yourself out of ajob with your own automation. Obviously,you won’tcompletely eliminate whatyoudo, butif you’re spending your whole day rerunning manual tests in your terminal, then your job isn’t programming. You are doingQA,and you should automateyourselfoutof this QA job that youprobably don’treallywantanyway.</p>

<p>The easiest way todo thisis to writeautomatedtests, or unit tests. In thisbook I&rsquo;m goingto get into how to do this easily,butI’llavoid most ofthe dogmaaboutwhenyou should writetests. I’llfocus on how towrite them,what to test,and how tobeefficientat the testing.</p>

<p>Hereare common things programmersfail toautomate when theyshould:
• Testing and validation</p>

<p>• Build processes</p>

<p>• Deployment of
software</p>

<p>• System administration</p>

<p>• Errorreporting Try todevote someof your time to automating this and you’ll have moretimeto work on the fun stuff. Or, if this is fun toyou, then maybe you should workon software
thatmakes automating these things easier.
Simplify and Clarify</p>

<p>The concept ofsimplicity is a slipperyone tomanypeople, especially smart people. They generally confuse comprehension with simplicity. Ifthey understand it, clearly it’ssimple. The actualtestof simplicityis comparingsomething with something else that could be simpler. But you’llsee people who write codego running to the most complex,obtuse structures possible because theythink thesimpler version ofthe same thingis dirty. A loveaffair with complexity is aprogramming sickness.</p>

<p>You can fightthis disease by first tellingyourself, “Simple and clear is notdirty,no matter what everyone else is doing.” If everyoneelseis writing insane visitorpatterns involving 19 classes over 12 interfaces, andyoucando it with twostring operations, thenyouwin. They are wrong, no matter how elegant theythink their complex monstrosity is.</p>

<p>Here’s the simplesttest of which function is better:</p>

<p>• Makesure both functions haveno errors. Itdoesn’t matter how fast orsimple a function is ifithas errors.</p>

<p>• If you can’tfixone, thenpick the other.</p>

<p>• Dotheyproduce the same result? If not, then pickthe onethat has the result you need.</p>

<p>• If theyproducethe same result, thenpick the onethateitherhas fewer features, fewer branches, oryou just think is simpler.</p>

<p>• Makesure you’re not justpicking theone that ismostimpressive.</p>

<p>Simple and dirty beats
complexand cleanany
day.</p>

<p>You’ll notice thatImostly giveup at theend andtell you to use yourjudgment. Simplicity is ironically a very complexthing, so using your taste asa guideis thebest way to go. Just make sure that you adjustyour view of what’s “good” as you grow and gain moreexperience.
Question Authority</p>

<p>The final strategy is themost important because itbreaks you outof thedefensive programming mind-set and lets you transition into the creative mind-set. Defensive programming is authoritarian and canbecruel. The job of this mind-setis tomakeyou follow rules, becausewithout them you’ll miss something orget distracted.</p>

<p>This authoritarian attitude has the disadvantageof disabling independentcreativethought. Rules arenecessary for gettingthings done,but being aslave to them will kill your creativity.</p>

<p>This final strategymeans you should periodically question the rules you follow and assumethat they could be wrong, just likethe software you are reviewing. What I will typicallydo is gotake a nonprogramming break and let therules go after asession ofdefensive programming. Then I’llbereadyto do some creative workor more defensivecoding ifIneed to.
Order Is Not Important</p>

<p>The final thing I’llsayon this philosophy isthat I&rsquo;mnot tellingyou todo thisin a strict order of “CREATE! DEFEND!CREATE! DEFEND!” At first you mightwanttodo that,but I’d actually doeither in varying amountsdepending onwhat I wanted to do,and I might even meldthemtogether with no defined boundary.
I also don’t think one mind­set isbetter thananother, or thatthere’s astrictseparation between them. Youneed both creativity andstrictnessto do programming well,sowork on bothif you wantto improve.</p>

<p>Extra Credit</p>

<p>• The codein the bookup to thispoint (and for the rest of it)potentially violates these rules. Go back and apply what you’velearned to one exerciseto seeif you can improve itor find bugs.</p>

<p>• Findanopensource projectand givesome ofthe filesa similar code review. Submita patchthat fixes abug.</p>

<p>Exercise28. Intermediate Makefiles</p>

<p>In the nextthreeexercises you’ll create a skeleton projectdirectory to use in building your Cprograms later. This skeletondirectory will be used for the rest ofthe book. In this exercise,I&rsquo;ll
cover justthe Makefile so</p>

<p>you can understand it. The purposeof thisstructure is to make it easy tobuild medium-sized programs without havingto resort to configuretools. If doneright, you can get very far with just GNU makeand somesmall shellscripts.</p>

<p>The Basic Project Structure</p>

<p>The first thing todo is make a c-skeleton directory,and thenputa set ofbasic files and directoriesin it that many projects have. Here’smy starter:</p>

<p>Exercise 28 Session</p>

<pre><code class="language-c">

$ mkdir c-skeleton $ cd c-skeleton/ $ touch LICENSE README.md Makefile $ mkdir bin src tests $ cp dbg.h src/ # this is from Ex1. $ ls -l 
total 8 -rw-r--r--1 zedshaw staff 31 16:38 LICENSE -rw-r--r--1 zedshaw staff 1168 
17:00 Makefile -rw-r--r--1 
zedshaw staff 
31 16:38 README.md drwxr-xr-x 2 zedshaw staff 68 31 16:38 bin drwxr-xr-x 2 zedshaw staff 68 
10:07 build drwxr-xr-x 3 zedshaw staff 102 
16:28 src drwxr-xr-x 2 zedshaw staff 68 31 16:38 tests 
$ ls -l src 
total 8 -rw-r--r--1 zedshaw staff 982 
16:28 dbg.h 
$ 
At theend you seeme doa ls -l so thatyoucansee the finalresults. 

Here’s abreakdown: LICENSE If you release the source of your projects, you’ll wantto include a license. If you don’t, though, the code iscopyrightby you and nobody else has rights 
to itby default. 
README.md Basic instructionsforusing your project go here. It ends in .md sothat it willbe interpretedas markdown. 

Makefile The main build 
fileforthe project. 

bin/ Whereprograms that users can run go. Thisis usually empty, and the Makefile will create it ifit’s not there. 
build/ Wherelibraries and other buildartifacts go. Alsoempty,and the Makefile will create it ifit’s not there. 
src/ Where the source code goes,usually .c and .h files. 
tests/ Where automated tests go. 
src/dbg.h I copied the 
dbg.h 
from 


Exercise 
1. into 
src/ 
forlater. 

I'll 
now 
break 
down 
eachof 
the 
components 
of 
this 
skeleton 
project 
so 
thatyou 
can 
understand 
how 
itworks. 

Makefile 

The first thing I’llcoveris the Makefile, because from thatyou canunderstand how everythingelseworks. The Makefile inthis exercise is much more detailedthan ones you’veused so far,soI’ll break it down afteryou type it in: 

Makefile 

```c

1 CFLAGS=-g -O2 ­Wall -Wextra -Isrc ­rdynamic -DNDEBUG $(OPTFLAGS)
2 LIBS=-ldl 
$(OPTLIBS)
3 PREFIX? 

=/usr/local4 5 SOURCES=$(wildca 
src/**/*.c src/*.c)6 OBJECTS=$(patsub 
%.c,%.o,$(SOURCES)) 7 8 TEST_SRC=$(wildc 
tests/*_tests.c)9 TESTS=$(patsubst 
%.c,%,$(TEST_SRC)) 10 11 TARGET=build/lib 12 SO_TARGET=$(pats 
%.a,%.so,$(TARGET)) 13 14 # The Target 
Build 
15 all: $(TARGET)
$(SO_TARGET) tests 16 17 dev: CFLAGS=-g 
-Wall -Isrc -Wall -Wextra $(OPTFLAGS) 
18  dev:  all  
19  
20  $(TARGET):  

CFLAGS += -fPIC 21 $(TARGET): build $(OBJECTS)
22 ar rcs $@ $(OBJECTS)
23 ranlib $@ 24 $(SO_TARGET): $(TARGET) $(OBJECTS)
25 $(CC) ­shared -o $@ $(OBJECTS)
2. 27 build: 
28 build  @mkdir -p  
29 bin  @mkdir -p  
30  

31 # The Unit Tests 
32 .PHONY: tests 33 tests: CFLAGS 
+= $(TARGET)34 tests: $(TESTS)35 sh 
./tests/runtests.sh36 37 # The Cleaner 38 clean: 
39 rm -rf build $(OBJECTS)$(TESTS)
40 rm -f tests/tests.log
41 find .­name &quot;*.gc*&quot; -exec rm {} \;
42 rm -rf `find . -name &quot;*.dSYM&quot; -print` 
43  
44  #  The  Install  
45  install:  all  
46  install  -d  

$(DESTDIR)/$(PREFIX)/l 

47 install 

$(TARGET)$(DESTDIR)/$(PREFIX)/l 
with potentially
48  
49  #  The Checker  
50  check:  
51  @echo  Files  

dangerous functions. 
52 @egrep'[^_.&gt;a-zA-Z0-9](str(n?cpy|n?cat|xfrm|n?dup|str|pbrk|tok|_)\
53 
cpy|a?sn? 
printf|byte_)'
$(SOURCES) || true 
</code></pre>

<p>Remember thatyouneed to consistently indentthe Makefile with tab characters. Your text editor should knowthat and do the rightthing. If itdoesn’t,get a differenttext editor. No programmershould use an editorthat failsatsomething so simple.</p>

<p>The Header</p>

<p>This Makefile is designed to builda library reliably on almost anyplatform using specialfeatures of GNU make.We’ll be working on this librarylater, so I&rsquo;ll break down each part insections, startingwiththe header.</p>

<p>Makefile:1 These are the usual CFLAGS that you setin all of your projects, along with a fewothersthat may be needed to build libraries. You may need to adjust these for different platforms. Notice the OPTFLAGS variableatthe end that lets people augment the build options asneeded.</p>

<p>Makefile:2 These options are usedwhen linkinga library. Someone else can then augmentthe
linking optionsusing</p>

<p>the OPTLIBS variable.</p>

<p>Makefile:3 This codesets an optional variable called PREFIX that willonly havethis valueif theperson running theMakefile didn’t already give a PREFIX setting. That’s whatthe ?= does.</p>

<p>Makefile:5 This fancy lineof awesomeness
dynamically creates the SOURCES variableby doing a wildcard search forall *.c files in the src/ directory. You have togive both src/*<em>/</em>.c and src/*.c so thatGNU make willinclude the filesin src and the filesbelowit.</p>

<p>Makefile:6 Onceyou have the list ofsource files, you can then use the patsubst to take the SOURCES list of *.c files and makea new listof all theobject files. You dothis by telling patsubst to change all %.c extensionsto %.o, and thenthose extensions are assigned to OBJECTS.</p>

<p>Makefile:8 We’re using</p>

<p>the wildcard again to find allof the test source files forthe unit tests. These areseparate fromthe library’s source files.</p>

<p>Makefile:9 Then, we’re using the same patsubst trick to dynamicallyget all the TEST targets. In this case, I&rsquo;mstripping away the .c extension so thata full program willbe madewiththe same name. Previously, I hadreplaced the .c with {.o}soan object fileiscreated.</p>

<p>Makefile:11 Finally, we say the ultimate target is build/libYOUR_LIB which you will change to be whatever library you’re actually trying to
build. This completesthe topof the Makefile, but I should explain what I mean by “lets people augment the build.” When yourun Make, you can dothis:</p>

<pre><code class="language-c">
# WARNING! Just a demonstration, won't really work right now. # this installs the library into /tmp $ make PREFIX=/tmpinstall # this tells it to add pthreads $ make OPTFLAGS=­pthread 
</code></pre>

<p>If youpass in options that match the samekindof variables you have in your Makefile, thenthose will showup inyour build. You can then use this tochange how the Makefile runs.</p>

<p>The first variablealters the PREFIX so thatit installs into /tmp instead. The secondone sets OPTFLAGS so thatthe -pthread option is present.</p>

<p>The Target Build
Continuing with the breakdownof the Makefile, I&rsquo;mactually building theobject files and targets:</p>

<p>Makefile:14 Remember thatthe first target is what make runsby defaultwhen no target isgiven. In this, it’s called all: and it gives $(TARGET)tests asthe targets to build. Lookup at the TARGET variableand you see that’s the library,so all: will first build the library.</p>

<p>The tests target is further downin the Makefile andbuilds the unit tests.</p>

<p>Makefile:16 Here’s anothertargetfor making “developer builds” that introduces a techniquefor changing optionsforjust one target. IfIdo a “dev build,” I want the CFLAGS to include optionslike -Wextra thatareuseful for finding bugs. If you place them on the target lineas options likethis, thengive another line thatsays the original target (in this case all), then it will change the options you set. I usethis for setting differentflags on differentplatforms that need it.</p>

<p>Makefile:19 Thisbuilds the TARGET library, whateverthat is. It also uses the same trick fromline 15,giving a target with justoptions and ways to alter them for thisrun. In this case, I&rsquo;m adding -fPIC just for the library build, using the += syntax to add iton.</p>

<p>Makefile:20 Nowwesee the realtarget,whereI say first make the build directory, and thencompile allof the OBJECTS.</p>

<p>Makefile:21 Thisrunsthe ar command that actually makes the TARGET.Thesyntax $@ $(OBJECTS) is a way of saying, “putthe target for this Makefile source here and allthe OBJECTS after that.” In this case, the $@ mapsback tothe $(TARGET) online 19, which maps to
build/libYOUR_LIB</p>

<p>Itseemslike a lotto keep track of in this indirection, and it can be,butonce you get it working, you just change TARGET at the
topand builda whole</p>

<p>new library.</p>

<p>Makefile:22 Finally, to makethe library,you run ranlib onthe TARGET andit’s built.</p>

<p>Makefile:23-24 This just makesthe build/ or bin/ directories ifthey don’texist. This isthen referenced fromline 19 when it givesthe build target to make
sure the build/</p>

<p>directory is made. You nowhave allof thestuff you need tobuild the software, so we’llcreate a way to build andrununit tests to do automated testing.</p>

<p>The Unit Tests
C isdifferent from other languages because it’s easier to create one tiny little programforeachthing you’re testing. Some testing frameworks try to emulatethe moduleconcept other languages have and do dynamicloading, but this doesn’twork wellin C. It’s also unnecessary,because you can justmake a single programthat’srunforeach test instead.</p>

<p>I&rsquo;ll cover thispartof the Makefile, and thenlater you’ll seethe contents ofthe
tests/ directorythat make
it actually work. Makefile:29 If you havea target that’s not real, butthereis a directory orfile with that name, thenyouneed to tagthe target with .PHONY: so make willignore the fileand always run. Makefile:30 I use the same trick for modifying the CFLAGS
variableto add the TARGET to thebuild so thateachof thetest programs will be linked with the TARGET library. In thiscase, it willadd
build/libYOUR_LIB
to thelinking.</p>

<p>Makefile:31 Then I have the actual tests: target,which depends on allof theprograms
listedin the TESTS variablethat we created in theheader. This one lineactually says, “Make, use what you know about building programs and the currentCFLAGS settings to buildeach programin TESTS.”</p>

<p>Makefile:32 Finally, when all ofthe TESTS are built, there’s a simple shellscriptI’ll create later that knows how to run them alland reporttheir output. This lineactually runsit so you can seethe test results.</p>

<p>For theunittestingto work, you’ll need tocreate a little shellscriptthat knows how to run the programs. Go ahead and create this
tests/runtests.sh
script:
runtests.sh</p>

<pre><code class="language-c">
1 echo &quot;Running unit tests:&quot; 
2 3 for i in tests/*_tests
4  do  
5  if test -f  
$i  
6  then  

7 if 

$VALGRIND ./$i 2&gt;&gt; tests/tests.log
8  then  
9  echo  
$i  PASS  
10  else  
11  ech  
&quot;ERROR  in  test  $i:  
here's  

tests/tests.log&quot;
12 ech 
&quot;------&quot; 
13 tai tests/tests.log
14 exi 
1. 15  fi  
16  fi  
17  done  
18  
19  echo  &quot;&quot;  

</code></pre>

<p>I&rsquo;ll be using this laterwhen I cover how unit tests work.</p>

<p>The Cleaner</p>

<p>I now havefully workingunit tests,sonextup ismaking things cleanwhenIneed to reset everything.</p>

<p>Makefile:38 The clean: target startsthings off when we need to clean up theproject.</p>

<p>Makefile:39-42 This cleans out most of the junk thatvarious compilers andtools leave behind. It also gets rid ofthe build/directory and usesa trick at the end to cleanly erase theweird *.dSYM directories thatApple’s XCode leaves behindfor debuggingpurposes.</p>

<p>If yourunintojunkthat you need to clean out,simply augmentthe listof things being deleted inthis target.</p>

<p>The Install</p>

<p>After that,I&rsquo;ll need a wayto install the project,and for a Makefile that’s buildinga library,I justneed to put something inthe common PREFIX directory, usually /usr/local/lib.</p>

<p>Makefile:45 Thismakes install: dependon the all: target, so that when yourun make install, itwill be sure tobuild everything.</p>

<p>Makefile:46 I thenusethe program install to create the target lib directory if it doesn’t exist. In this case,I&rsquo;m trying to make the install asflexible as possible byusingtwo variables that are conventions for installers. DESTDIR is handed tomake by installers, which do their builds insecure or odd locations, to build packages. PREFIX is used when people want the project to be installed insomeplace other than /usr/local.</p>

<p>Makefile:47 After that, I&rsquo;m justusing install to actually
install the library where
it needsto go.</p>

<p>The purposeof the install programis tomakesure things havethe right permissions set. Whenyou run make install, you usually haveto doit as the root user, so thetypical build processis make &amp;&amp; sudo make install.</p>

<p>The Checker</p>

<p>The very last part of this Makefile is a bonus thatI include inmy C projectsto helpme dig outany attempts to use thebad functions inC. Theseare namely thestring functions andother unprotectedbufferfunctions.</p>

<p>Makefile:50 Thissets a variablethat’s a big regex looking for bad functions like strcpy.</p>

<p>Makefile:51 The check: target allows you to run acheck whenever you need to.</p>

<p>Makefile:52 Thisis just a way toprint a message, butdoing @echo tells make to not printthe command, just its output.</p>

<p>Makefile:53 Run the egrep command on the source files to look for anybad patterns. The || true at the end is a way to prevent make fromthinking that egrep failedif it doesn’tfinderrors.</p>

<p>When yourunthis, it will havethe oddeffectof returningan errorwhen there’s nothing bad going on.</p>

<p>What You Should See
I havetwo moreexercises to go before I&rsquo;m done building the project skeleton directory, buthere’sme testing out the features of the Makefile.</p>

<p>Exercise 28 Session</p>

<pre><code class="language-c">
$ make clean 
rm -rf build rm -f tests/tests.log find . -name &quot;*.gc*&quot; -exec rm {} \; rm -rf `find . -name &quot;*.dSYM&quot; -print` 
$ make check 
$ make 
</code></pre>

<p>When I run the clean: target, it works, butbecause I don’thave anysourcefiles in the src/ directory, none of the othercommandsreally work. I&rsquo;ll finishthat up in the nextexercises.</p>

<p>Extra Credit</p>

<p>• Tryto get the Makefile toactually work by putting a source and header file in src/ andmaking the library. You shouldn’tneed a main function inthe source file.</p>

<p>• Research what</p>

<p>functions the check: target is looking for in the BADFUNCS regular expressionthatit’s using.</p>

<p>• If you don’tdo automated unit testing, thengo read about it so you’re preparedlater.</p>

<p>Exercise29. Libraries and Linking</p>

<p>A central part ofany C programis theability tolink it tolibraries that your OS provides. Linking is how you get additionalfeatures for your program thatsomeone else createdand packagedon the system. You’vebeen using somestandard libraries thatare automatically included, but I&rsquo;mgoing to explain thedifferent types of librariesand what they do.</p>

<p>First off, libraries are poorly designed inevery programming language. I haveno idea why, butit seems languagedesigners think of linking assomething theyjust slap on later.</p>

<p>Libraries areusually confusing, hard to dealwith, can’t do versioning right, and end up being linked differently everywhere.
C isno different, but theway linking andlibraries aredone in C is an artifactof how the UNIX operatingsystemand executable formats were designed years ago. Learning how Clinksthings helpsyou understand how yourOS works andhowit runsyour programs.</p>

<p>To startoff, there are two basic types oflibraries: static You made oneof these when you used ar and ranlib to create the lib YOUR_LIBRARY.a in the lastexercise. This kind oflibraryis nothing more than a container for a setof .o
object files and their functions, and you can treatit likeone big .o filewhenbuilding your programs.
dynamic These typically end in .so, .dll or about onemillionother endings on OSX, depending onthe version and who happenedto be working thatday. Seriously though,OS X adds .dylib, .bundle, and .framework with notmuch distinction among the three. These filesarebuilt and then placed in acommon location. When you run your program,the OS dynamicallyloads these filesand links them to your program on the fly.</p>

<p>I tend to like static libraries for small-tomedium-sized projects, becausethey are easier todeal with andwork on moreoperating systems. I also like to put all ofthe code I can into a static library so thatIcan thenlinkit to unit tests and to the file programs asneeded.
Dynamiclibrariesare good for largersystems, when space is tight, or if youhave a large number ofprograms thatusecommon functionality. In this case, you don’twant tostatically link all of the codeforthe common features to every program, so you put it in a dynamiclibrary so thatitis loaded only oncefor all of them.</p>

<p>In the previous exercise, I laidout how tomake a static library (a .a file), andthat’s whatI’ll use in therest ofthe book. In this exercise,I&rsquo;m goingto showyouhow to makea simple .so library, and how to dynamically loadit with the UNIX dlopen system. I’llhave you dothis manually so thatyou understand everything that’s actually happening, then for extra credit you’ll use the c-skeleton skeletonto create it.</p>

<p>Dynamically Loading a Shared Library</p>

<p>To do this,Iwillcreate two source files:One will be used to make a libex29.so library,the other will be a programcalled ex29 that can loadthis library andrun functions from it.</p>

<p>libex29.c</p>

<pre><code class="language-c">
1 #include 
&lt;stdio.h&gt; 
2 #include 
&lt;ctype.h&gt; 
3 #include 
&quot;dbg.h&quot; 

4 
5 
6 int 
print_a_message(const 
char *msg)
7 {
8 printf(&quot;A 
STRING: %s\n&quot;, msg); 
9 
10 return 0;
11 }
1. 1. 14 int 

uppercase(const char 
*msg)15 {16 int i = 0;17 18 // BUG: \0 
termination problems 
19 for(i = 0; msg[i] != '\0'; i++){
20 printf(&quot; toupper(msg[i])); 
2. }
2. 23 printf(&quot;\n&quot;)
2. 25 return 0;


2. }
2. 28 int 



lowercase(const char 
*msg)29 {30 int i = 0;31 32 // BUG: \0 
termination problems 
33 for(i = 0; msg[i] != '\0'; i++){
34 printf(&quot; tolower(msg[i])); 
35 
}
36 
37 printf(&quot;\n&quot;)
38 
39 return 0;


40 
}
41 
42 int 



fail_on_purpose(const char *msg)43 { 
44 return 1;
45 } 
</code></pre>

<p>There’snothing fancy in there,althoughthereare some bugsI&rsquo;m leavingin on purposeto seeif you’ve been payingattention. You’ll fix thoselater.</p>

<p>Whatwe wantto do is use the functions dlopen, dlsym, and dlclose to work with the above functions.</p>

<p>ex29.c</p>

<pre><code class="language-c">
1 #include &lt;stdio.h&gt; 2 #include &quot;dbg.h&quot; 3 #include &lt;dlfcn.h&gt; 
4 
5 typedef int (*lib_function)(const char *data); 
6 
7 int main(int 
argc, char *argv[]) 
8 {
9 int rc = 0;
10 check(argc == 4, &quot;USAGE: ex29 libex29.so function data&quot;); 
1. 12 char *lib_file = argv[1]; 
13 char *func_to_run = argv[2]; 
14 char *data = argv[3]; 
1. 16 void *lib = dlopen(lib_file,RTLD_NOW); 
17 check(lib != NULL, &quot;Failed to open the library %s: %s&quot;, lib_file, 
func_to_run); 
18  dler  
19  
20 func  =  lib_function dlsym(lib,  

21 check(func != NULL,
22 &quot;Did not find %s function 
in the library %s: 

26 check(rc 
%s&quot;, func_to_run, 23 dlerror()); 24  lib_  
25  rc  =  
func(data);  ==  

0, &quot;Function %s return %d for data: %s&quot;, func_to_run,
27 rc,data); 
2. 29 rc = dlclose(lib); 
30 check(rc == 0, &quot;Failed to close %s&quot;, lib_file); 
31. 32 33  return 0;  
34  error:  
35 36  }  return 1;  
</code></pre>

<p>I&rsquo;ll now break thisdown so you can seewhat’sgoing on in this smallbit of useful code:</p>

<p>ex29.c:5 I&rsquo;ll use this</p>

<p>function pointer definitionlaterto call functions in the library. This isnothing new, but makesure you understand what it’s doing.</p>

<p>ex29.c:17 After theusual setupfora small program, I use the dlopen function to loadup thelibrary that’s indicatedby lib_file. This function returns a handle thatwe use later, which works a lotlike opening afile.</p>

<p>ex29.c:18 Ifthere’s an error, I do the usual check and exit, but notice at thenend that I&rsquo;m using dlerror to find out whatthe library-related error was.</p>

<p>ex29.c:20 I use dlsym to get a function out ofthe lib by its string name in func_to_run. This isthe powerful part, sinceI&rsquo;m dynamicallygetting a pointer to a function based on astring I got fromthe command line argv.</p>

<p>ex29.c:23 I then call the func function that was returned, and check its returnvalue.</p>

<p>ex29.c:26 Finally,I close the library up just like I would a file. Usually, you keep theseopen the whole time the program isrunning, so closing it at the endisn’tas useful,butI&rsquo;m demonstrating ithere.</p>

<p>What You Should See</p>

<p>Now thatyou knowwhatthis filedoes,here’s ashell session of me building the libex29.so, ex29 and thenworking with it. Follow along so you learn howthese things aremanuallybuilt.</p>

<p>Exercise 29 Session</p>

<pre><code class="language-c">
# compile the lib file and make the .so # you may need -fPIC here on some platforms. add that if you get an error $ cc -c libex29.c -o libex29.o $ cc -shared -o libex29.so libex29.o 
# make the loader program$ cc -Wall -g ­DNDEBUG ex29.c -ldl ­o ex2. # try it out with some things that work $ ex29 ./libex29.soprint_a_message
&quot;hello there&quot; 
-bash: ex29: command not found 
$ ./ex29 ./libex29.soprint_a_message
&quot;hello there&quot; 

A STRING: hello there 
$ ./ex29 ./libex29.souppercase &quot;hello there&quot; 
HELLO THERE 
$ ./ex29 ./libex29.solowercase &quot;HELLO tHeRe&quot; 
hello there 
$ ./ex29 ./libex29.sofail_on_purpose &quot;i fail&quot; 
[ERROR] (ex29.c:23: errno: None) Function fail_on_purpose return 1 for\ 
data: i fail 
# try to give it bad args $ ./ex29 ./libex29.sofail_on_purpose
[ERROR] (ex29.c:11: errno: None) USAGE: ex29 libex29.so function data 
# try calling a function that is not there $ ./ex29 ./libex29.soadfasfasdf asdfadff 
[ERROR] (ex29.c:20: errno: None) Did not find adfasfasdf 
function in the library libex29.so: dlsym(0x1076009b0, adfasfasdf):\ 
symbol not found 
# try loading a .so that is not there $ ./ex29 ./libex.soadfasfasdf asdfadfas 
[ERROR] (ex29.c:17: errno: No such file or directory) Failed to open 
the library libex.so: 
dlopen(libex.so, 2): image not found 
$ 
</code></pre>

<p>Onething thatyou may run into is thatevery OS, every versionof every OS,and every compiler onevery versionof every OS,seemsto wantto change the way you build a shared library every time somenew programmer thinks it’s wrong. If the line I use to make the libex29.so file is wrong, thenlet me knowand I&rsquo;ll add somecommentsforother platforms.</p>

<p>Warning!
Sometimesyou’lldo what youthink is normal,and run this command cc -Wall -g -DNDEBUG ­ldl ex29.c -o ex29 thinking everything willwork, but nope. You see,on someplatforms the orderof where libraries gomakes them work ornot, andforno real reason. In Debianor Ubuntu,youhave todo
cc -Wall -g ­DNDEBUG ex29.c -ldl -o ex29 for noreasonatall. It’s justthe wayitis. So since this works onOS X I&rsquo;mdoing it here, but in thefuture, ifyou link against adynamic library andit can’tfind a function, try shuffling things around.</p>

<p>Theirritationhere is there’s anactual platform difference on nothing morethan the orderof command line arguments. Onno rational planet should putting an -ldl at one position be different from another. It’s an option,and havingto know thesethings is incrediblyannoying.
How to Break It
Open libex29.so and edit it with an editor thatcan handle binary files. Change a couple ofbytes, then close itlibex29.so. Tryto see if you can get the dlopenfunction toload iteven though you’vecorrupted it.</p>

<p>Extra Credit</p>

<p>• Were youpaying attention to thebad code Ihave inthe</p>

<p>libex29.c
functions? Doyousee how,even though I use a for-loop theystill check for &lsquo;\0&rsquo; endings? Fix this so that the functions always take a length forthe string towork with inside the function.
• Take the c ­skeleton skeleton, and create anew project for thisexercise. Put the libex29.c file in the src/ directory. Change the Makefile so thatitbuilds thisas build/libex29.so.</p>

<p>• Take the ex29.c file and put it in   tests/ex29_tests. so thatitrunsas a unit
test. Make thisall work,</p>

<p>which meansthat you’ll have tochangeit so that it loadsthe build/libex29.so file and runs tests similar to whatI didmanually above.
• Readthe man dlopen documentation and read about all of the related functions. Try some of the otheroptions to
dlopen beside RTLD_NOW.</p>

<p>Exercise30. Automated Testing
Automated testingis used frequently in other languages likePythonand Ruby, but rarely usedin C. Partof the reason comesfrom the difficulty ofautomatically loadingand testing piecesof C code. In this chapter, we’ll createa very small testing framework andget your skeleton directoryto build an example testcase.</p>

<p>The framework I&rsquo;m going to use,and you’ll includein your c-skeleton skeleton, is called minunit which started with atinysnippet of codeby Jera Design. I evolveditfurther,to be this:
minunit.h</p>

<pre><code class="language-c">
1 #undef NDEBUG 
2 #ifndef _minunit_h
3 #define _minunit_h
4 
5 #include &lt;stdio.h&gt;
6 #include &lt;dbg.h&gt;
7 #include &lt;stdlib.h&gt;
8 
9 #define mu_suite_start() char *message = NULL 
1. 11 #define mu_assert(test, message) if (!(test)) {\ 
12 log_err(mess return message; } 
13 #define mu_run_test(test) debug(&quot;\n-----%s&quot;, &quot; &quot; #test); \ 
14 message = test(); tests_run++; if (message) return message; 
16 #define RUN_TESTS(name) int main(int argc, char *argv[]) {\ 
17 argc = 1; \ 
18 debug(&quot;---­-RUNNING: %s&quot;, argv[0]);\ 
19 printf(&quot;--­-\nRUNNING: %s\n&quot;, argv[0]);\ 
20 char *result = name();\ 
21 if (result != 0) {\ 
22 printf(&quot; %s\n&quot;, result);\ 
23 }\ 
24 else {\ 
25 printf(&quot; TESTS PASSED\n&quot;);\ 
26 }\ 
27 printf(&quot;Test run: %d\n&quot;, tests_run);\ 
28 exit(result != 0);\ 
29 } 
30 

31 int tests_run;32 33 #endif 
</code></pre>

<p>There’spractically nothing leftof theoriginal,since now I&rsquo;m using the dbg.h macros and a large macro that I created at the endfor the boilerplate testrunner. Even with this tiny amount of code, we’ll createa fully functioning unit testsystem thatyou canusein your C
codeonce it’scombined with ashell script torunthe tests.</p>

<p>Wiring Up the Test Framework</p>

<p>To continuethis exercise,you should have your src/libex29.c working. You should have also completed the Exercise
2. Extra Credit
to getthe ex29.c loader program to properlyrun. In Exercise
29,I ask you to make it worklike a unit test,butI&rsquo;m going to startoverand show youhow to do thatwith minunit.h.</p>

<p>The first thing todo is create asimple empty unit test name,
tests/libex29_tests.c</p>

<p>with this in it:</p>

<p>ex30.c</p>

<pre><code class="language-c">

1 #include &quot;minunit.h&quot; 
2 
3 char *test_dlopen() 
4 {
5 
6 return NULL;
7 }
8 
9 char *test_functions()
10 {
1. 12 return NULL; 13 }14 15 char
*test_failures() 16 {17 18 return NULL;
19 }
2. 21 char
*test_dlclose() 22 {23 24 return NULL;
25 } 
2. 27 char
*all_tests() 

38 
2. 29  {  mu_suite_sta  
30  
31 
32 
33 
34 
35  mu_run_test(mu_run_test(mu_run_test(mu_run_test(  
36  return  NULL;
37  }  

39 RUN_TESTS(all_te 
</code></pre>

<p>This codeis demonstrating the RUN_TESTS macro in tests/minunit.h and how to use theother test runner macros. I havethe actualtestfunctions stubbed outsothat you can see how to structure aunittest. I’llbreak this file down first:
libex29_tests.c:1 This includes the minunit.h framework.
libex29_tests.c:3-7 A first test. Tests arestructured so thatthey takeno arguments andreturn a char * that’s NULL on success. This is importantbecause the other macros will be used toreturn anerror messageto the test runner.
libex29_tests.c:9-2. Theseare more tests
thatarethe same as the first.
libex29_tests.c:27 The runner function thatwill control all ofthe other tests. It has thesame formas anyother test case, but it gets configured with some additional gear.
libex29_tests.c:28 This setsup some common stuff for a test with mu_suite_start.</p>

<p>libex29_tests.c:30 This is how yousaywhattests to run, using the mu_run_test macro.
libex29_tests.c:35 After you say whatteststo run,youthen return NULL justlike anormal test function.
libex29_tests.c:38 Finally,you just use the big RUN_TESTS macro</p>

<p>to wire upthe main methodwithall ofthe goodies, andtell it to run the all_tests starter.
That’s allthereis to running a test,and now you should try gettingjust thisto run within the project skeleton. Here’s whatit looks likewhenIdo it:</p>

<p>Exercise 30 Session</p>

<p>not printable
I first did a make clean and then I ran the build, which remade thetemplate libYOUR_LIBRARY. a
and
libYOUR_LIBRARY.so
files. Remember that you did this in the Extra Credit for Exercise29,butjust in case you didn’tget it, here’s the diff for the Makefile I&rsquo;m using now:</p>

<p>ex30.Makefile.diff</p>

<pre><code class="language-c">
diff --git a/code/c-skeleton/Makefileb/code/c-skeleton/Makefileindex 135d538..21b92bf 100644 
---a/code/c-
skeleton/Makefile +++ b/code/c-skeleton/Makefile
@@ -9,9 +9,10 @@TEST_SRC=$(wildcardtests/*_tests.c)
TESTS=$(patsubst%.c,%,$(TEST_SRC)) 
TARGET=build/libYOUR_+SO_TARGET=$(patsubst%.a,%.so,$(TARGET)) 
# The Target Build 
-all: $(TARGET) tests +all: $(TARGET)$(SO_TARGET) tests

dev: CFLAGS=-g -Wall -Isrc -Wall -Wextra $(OPTFLAGS)
dev: all @@ -21,6 +22,9 @@$(TARGET): build $(OBJECTS)
ar rcs $@ $(OBJECTS)
ranlib $@ 
+$(SO_TARGET):$(TARGET) $(OBJECTS) 
+ $(CC) -shared -o $@ 
$(OBJECTS)
+ 

build: 
@mkdir -p build 
@mkdir -p bin 
</code></pre>

<p>With thosechanges you should now be building everythingand finally be able to fill inthe remainingunit test functions:
libex29_tests.c</p>

<pre><code class="language-c">
1 #include 
&quot;minunit.h&quot; 
2 #include &lt;dlfcn.h&gt; 
3 
4 typedef int (*lib_function)(const char *data); 
5 char *lib_file = &quot;build/libYOUR_LIBRARY 
6 void *lib = NULL;
7 
8 int check_function(const char *func_to_run,const char *data, 
9 int 


expected)
10 {
11 lib_function func = dlsym(lib,func_to_run); 
12 check(func != NULL,
13 &quot;Did not find %s function in the library %s: %s&quot;, func_to_run, 
14 lib_ dlerror()); 
1. 16 int rc = func(data); 
17 check(rc == expected, &quot;Function dlopen(lib_file,RTLD_NOW); 
%s  return  %d  for  
data: 18  %s&quot;,  func  
rc, 19  data);  
20 21  return error:  1;  
22 23 24  }  return  0;  
25  char  
*test_dlopen() 26 {27 lib =  

28 mu_assert(li != NULL, &quot;Failed to open the library to test.&quot;); 
2. 30 return NULL;
31 }
32 
33 char 

*test_functions() 
34 {
35 mu_assert(ch 
&quot;Hello&quot;, 0), 
36 &quot;pri failed.&quot;); 
37 mu_assert(ch &quot;Hello&quot;, 0), 
38 &quot;uppfailed.&quot;); 
39 mu_assert(ch &quot;Hello&quot;, 0), 
40 &quot;low failed.&quot;); 
41 
42 return NULL;
43 }
44 
45 char 

*test_failures() 46 {
47 mu_assert(ch &quot;Hello&quot;, 1), 
48 &quot;fai should fail.&quot;); 
49 
50 return NULL;
51 }
52 
53 char 

*test_dlclose() 
54 {
55 int rc = 
dlclose(lib); 56 mu_assert(rc == 0, &quot;Failed to 
close lib.&quot;); 
57 
58 return NULL;
59 }60 61 char 
*all_tests() 
62 63  {  mu_suite_sta  
64  
65 66 67 68 69  mu_run_test(mu_run_test(mu_run_test(mu_run_test(  

70 return 

NULL;
71 }
72 
73 RUN_TESTS(all_te 


</code></pre>

<p>Hopefullyby now you can figure out what’sgoing on, since there’s nothing new in this except for the
check_function function. This is acommon patternwhereI useachunk ofcode repeatedly,and then simplyautomate itby either creatinga functionor a macro for it. In this case, I&rsquo;mgoing to run functionsin the .so thatIload, so I just madea little function todo it.</p>

<p>Extra Credit</p>

<p>• This worksbut it’s probably a bitmessy. Clean the c-skeleton directory up so that it has allof these files,but remove</p>

<p>any of the code related to Exercise
29. You should beable to copy this directory over and kick-start newprojects without much editing.</p>

<p>• Study the runtests.sh, and thengo read about bash syntax so you know what it does. Do you think you could write a C version of this script?</p>

<p>Exercise31. Common Undefined Behavior
At this point inthe book, it’s time to introduceyou tothe most common kinds of UB that you will encounter. C has 191 behaviors that the standards committee has decided aren’t defined by the standard, and therefore anything goes. Some of these behaviors are legitimately not the compiler’s job, but the vast majority are simply lazy capitulations by the standards committee that cause annoyances, or worse, defects. An example of laziness:</p>

<p>An unmatched “or” character is encountered on a logical source line during tokenization.</p>

<p>In this instance,the C99 standardactually allowsa compiler writer to fail at a parsingtaskthata junior in college could getright. Why is this? Who knows, but most likely someoneon the standards committeewas working on aCcompilerwith this defect and managed to get this in thestandard rather thanfixtheircompiler. Or, as I said, simple laziness.</p>

<p>The crux of the issue with UB is the differencebetweenthe C abstract machine, defined in thestandard andreal computers. TheCstandard describes the C language according to a strictlydefined abstract machine. This is a perfectly valid wayto design alanguage, exceptwherethe C standard goeswrong: It doesn’trequire compilers to implementthis abstract machine and enforceits specification. Instead, a compiler writer can completely ignore the abstract machine in191instances of the standard. It should really be calledan “abstract machine, but”,as in, “It’s a strictlydefined abstract machine, but&hellip;” This allows the standards committee andcompiler implementers to have their cake andeatit, too. They can havea standardthat is full of omissions, laxspecification, and errors,butwhen you encounter oneof these, they can pointatthe abstract machine and simply say in their best robot voice, “THE ABSTRACT MACHINEIS ALLTHATMATTERS. YOU DO NOT CONFORM!” Yet,in 191 instancesthatcompiler writersdon’t haveto conform, you do. You are a secondclasscitizen, even though the language isreally writtenfor youto use.</p>

<p>This meansthat you, not the compiler writer,areleftto enforcethe rulesof an abstract computational machine, andwhenyou inevitably fail,it’s yourfault. The compiler doesn’thave to flag the UB, doanything reasonable, andit’s yourfault for not memorizing all 191 rulesthat shouldbe avoided. You are juststupid for not memorizing 191 complex potholeson the road to C. This is a wonderful situation for the classic know-it-all type who can memorize these 191 finer points of annoyance with which to beat beginners to intellectualdeath. There’s an additional hypocrisy with UB that is doubly infuriating. If you show a C fanatic code that properlyu ses C strings but can overwrite the string terminator,they will say, “That’s UB. It’s not the C language’s fault!” However, if you show them UB that has while(x) x &lt;&lt;= 1 in it, they will say, “That’s UB idiot!Fix your damn code!” This lets the C fanatic simultaneously use UB to defend thepurityof C’s design,and also beat youup for being an idiotwho writes bad code. Some UB is meant as, “you can ignore the security of this since it’s not C’s fault”, andother UB is meant as, “you are an idiot for writing this code,” and the distinction betweenthe twois notspecified inthe standard. As you can see, Iam not a fan ofthe huge list ofUB. I had to memorizeallof these beforethe C99standard,and justdidn’t bother to memorize thechanges. I’d simplymoved onto away and found a way to avoid as much UB as I possiblycould, trying to stay within the abstract machinespecification while also workingwithreal machines. This turns out to be almost impossible, so I just don’twritenew codein C anymore becauseof its glaringlyobvious problems.</p>

<p>Warning!</p>

<p>The technical explanationas towhy C UB is wrong comes from AlanTuring:
1. C UB contains behaviors thatare</p>

<p>lexical,semantic, and executionbased.</p>

<ol>
<li><p>The lexical and semantic behaviors can be detected bythe compiler.</p></li>

<li></li>
</ol>

<p>The execution-based behaviors fallinto Turing’sdefinitionof the halting problem, and aretherefore NP-complete.</p>

<ol>
<li></li>
</ol>

<p>This means thatto</p>

<p>avoid C UB, it requires solvingone ofthe oldest proven unsolvable problems in computer science, makingUB effectively impossible for a computer toavoid.</p>

<p>To putitmore succinctly: “If the only way to knowthat you’veviolated the abstract machine with UBisto run your C program, then you will never be able to completely avoid UB.”
UB 2. Because ofthis, I&rsquo;m going to list thetop 20 undefined behaviors in C, and tell you how to avoid them as best I can. In general, theway to avoid UB is towriteclean code, but someof these behaviors are impossible to avoid. For example, writing past theend ofa C stringis an undefinedbehavior, yet it’seasily done by accident and externallyaccessible to an attacker. This list will also include relatedUB thatall fallintothe same category butwithdifferingcontexts.
Common UBs</p>

<ol>
<li>Anobject isreferred to outside of its lifetime (6.2.4).</li>
</ol>

<p>•Thevalue of a pointerto an object whoselifetime has endedis used (6.2.4).
•Thevalue of an objectwithautomatic storage duration is used while it is indeterminate (6.2.4, 6.7.8,6.8).</p>

<ol>
<li>Conversionto orfrom an integertype producesa value outside therangethat can be represented (6.3.1.4).</li>
</ol>

<p>•Demotion of one real floating typeto another produces a valueoutsidethe rangethat can be represented (6.3.1.5).</p>

<ol>
<li><p>Twodeclarationsof the same object or function specify typesthat are notcompatible (6.2.7).</p></li>

<li><p>Anlvalue having array typeisconvertedto a pointer to theinitial element of the array, and thearray object has registerstorageclass (6.3.2.1).</p></li>
</ol>

<p>•An attemptismade to use the value of a void expression, or an implicit orexplicit conversion (except to void) is appliedto a void expression (6.3.2.2).</p>

<p>•Conversion of a pointerto an integer typeproduces a value outside the range that can be represented (6.3.2.3).</p>

<p>•Conversion between two pointer types produces a result that isincorrectly aligned (6.3.2.3).</p>

<p>•A pointerisused to call afunction whose typeis not compatible with the pointed-totype (6.3.2.3).</p>

<p>•Theoperand
of the unary * operator has an invalid value (6.5.3.2).</p>

<p>•A pointeris converted to other than aninteger or pointertype (6.5.4).</p>

<p>•Addition
or subtraction of a pointerinto, or just beyond, an array objectand an integer typeproduces a result that doesnotpoint into, or justbeyond,</p>

<p>the same array object (6.5.6).</p>

<p>•Addition
or subtraction of a pointerinto, or just beyond, an array objectand an integer typeproduces a result that pointsjust beyond thearray objectand is used as the operand ofa unary * operator that isevaluated (6.5.6).</p>

<p>•Pointers thatdo not point into, or just beyond, thesame array object are subtracted(6.5.6).</p>

<p>•An array subscript is outof range,even if an object is apparently accessible withthe given subscript(asin the lvalue expression a[1][7] given the declaration int a[4][5]) (6.5.6).</p>

<p>•Theresultof subtracting two pointersis not representable in an objectof type ptrdiff_t(6.5.6).
•Pointers thatdo not point to the same aggregate or union (nor justbeyond the same array object) are compared using relationaloperators (6.5.8).</p>

<p>•An attemptismade to access, or generate a pointer tojust past, a flexible array memberof a structurewhenthe referencedobject providesno elements for thatarray (6.7.2.1).</p>

<p>•Two pointer types that arerequiredto be compatible are not identically qualified, or arenot pointers to compatible types (6.7.5.1).</p>

<p>•Thesizeexpression in an array declaration isnota constant expression and evaluates at program execution timeto anonpositive value(6.7.5.2).</p>

<p>•Thepointerpassed to a library function array parameter does nothave avaluesuch that alladdress computationsand objectaccesses are valid(7.1.4).</p>

<ol>
<li><p>The programattempts to modifya stringliteral (6.4.5).</p></li>

<li><p>Anobject has its stored valueaccessedother thanby an lvalue of an allowabletype (6.5).</p></li>

<li><p>Anattempt is made to modify theresultof a function call, a conditionaloperator,an assignmentoperator,or acomma operator, orto access itafterthe next sequencepoint (6.5.2.2, 6.5.15, 6.5.16,6.5.17).</p></li>

<li><p>The value ofthe second operandof the/or % operator is zero(6.5.5).</p></li>

<li><p>Anobject isassignedto an inexactly overlapping object orto an exactly overlapping object with incompatible type (6.5.16.1).</p></li>

<li><p>A constant expression in an initializeris not, ordoes notevaluateto, one of the following:an arithmetic constant expression, a null pointer constant, an addressconstant,or an addressconstant for an object typeplus or minus an integer constant expression (6.6).</p></li>
</ol>

<p>•An arithmetic constant expression does not have arithmetic type; has operands that are not integer constants, floating constants, enumeration constants,character constants,or sizeof expressions;or contains casts (outsideoperands to sizeofoperators) other than conversions of arithmetic typesto arithmetic types (6.6).
11. An attempt is madeto modify an object definedwitha const­qualified type through use ofanlvaluewith non-const-qualified type(6.7.3).</p>

<ol>
<li>A function with externallinkage is declared with an inline</li>
</ol>

<p>function specifier,but is notalso definedin the same translationunit (6.7.4).</p>

<ol>
<li></li>
</ol>

<p>The valueof an unnamed member of a structure orunion is used (6.7.8).</p>

<ol>
<li></li>
</ol>

<p>The }that terminates a function is reached, and the value ofthe function callis usedby the caller (6.9.1).</p>

<ol>
<li></li>
</ol>

<p>A filewith the same nameas one of the standard headers, not provided as part of the implementation,is placedin anyof the standard placesthatare searched for included source files (7.1.2).</p>

<ol>
<li></li>
</ol>

<p>The valueof an argument toa character handling function is neither equal tothe</p>

<p>valueof EOF nor representable as an unsignedchar (7.4).</p>

<ol>
<li></li>
</ol>

<p>The valueof theresult ofaninteger arithmetic orconversion function cannot be represented (7.8.2.1,7.8.2.2, 7.8.2.3, 7.8.2.4, 7.20.6.1, 7.20.6.2, 7.20.1).</p>

<ol>
<li></li>
</ol>

<p>The valueof a pointer to a FILEobjectis used</p>

<p>after the associated file isclosed (7.19.3).
•Thestreamforthe fflush function points to an input streamor toan update stream in which the most recentoperation was input (7.19.5.2).
•Thestring
pointed to by the mode argument in a call to</p>

<p>the fopen function does not exactly matchone of the specified character sequences (7.19.5.3).</p>

<p>•An
output operation on an updatestream isfollowed by an input operation withoutan interveningcall to the fflush function or</p>

<p>A file positioning</p>

<p>function,or an input operation onan update stream is followed byan outputoperation with an intervening call to a file positioning function (7.19.5.3).
19. A conversion specification for a formattedoutput function uses a # or0 flagwith aconversion specifierotherthan thosedescribed (7.19.6.1, 7.24.2.1). * An s conversion specifieris encountered by one ofthe formatted outputfunctions,and the argumentis missing the null terminator (unless aprecisionis specified that does not requirenull termination)(7.19.6.1, 7.24.2.1). * The contents of the array suppliedin acall to the fgets, gets, or fgetws function are used after a readerror occurred (7.19.7.2, 7.19.7.7, 7.24.3.2).
20. A non-nullpointer returned bya callto the calloc, malloc,or realloc function with azero requested sizeisused to access an object (7.20.3). * The valueof a pointer that refers to space deallocatedby a call to the free or realloc function is used (7.20.3). * The pointer argument tothe free or realloc function does not match a pointer earlier returned by calloc, malloc, or realloc, or the space has been
deallocatedby a call to
free or realloc</p>

<p>(7.20.3.2, 7.20.3.4).</p>

<p>There are manymore,but these seemto be the onesthat I run into themostoftenor thatcome up the most often in C code. Theyare also the most difficulttoavoid,soif you at least remember these, you’ll be able toavoid the majorones.</p>

<p>Exercise32. Double Linked Lists</p>

<p>The purposeof thisbook isto teach you how yourcomputer really works, andincluded in thatis how various data structures and algorithms function. Computers by themselves don’t doa lot of useful processing. Tomake them do usefulthings,you need to structurethe dataand thenorganize theprocessing ofthese structures. Other programming languages either includelibraries that implementallof these structures,or they have direct syntax for them. Cmakes you implementallof thedata structures thatyou need yourself,which makesitthe perfect language to learn how
theyactually work. My goal is to help you do three things:
• Understandwhat’s really goingon in Python, Ruby,or JavaScript codelike this: data = {&ldquo;name&rdquo;: &ldquo;Zed&rdquo;}</p>

<p>• Geteven better at C code by using data structuresto apply what you know to a set of</p>

<p>solved problems.</p>

<p>• Learna core set ofdata structuresand algorithmssothat you are better informed about what works best in certain situations.</p>

<p>What Are Data Structures</p>

<p>The name data structure is self-explanatory. It’s an organization ofdata thatfits a certain model. Maybe the model is designedto allow processing the datain anew way. Maybe it’sjust organized to store it on disk efficiently. In this book, I&rsquo;ll follow asimplepattern for makingdata structures that work reliably:
• Definea structure for the main outer structure.</p>

<p>• Definea structure for</p>

<p>the contents, usually nodeswithlinks between them.</p>

<p>• Create functions that operate onthese two structures.</p>

<p>There areother styles of data structures in C,butthis patternworks welland is consistentformaking most data structures.
Making the Library</p>

<p>For therest ofthis book, you’ll be creatinga library thatyou canusewhen you’re done. Thislibrarywillhave the following elements:
• Header (.h) filesfor
each data structure.</p>

<p>• Implementation (.c) filesforthe algorithms.</p>

<p>• Unit tests that test all of
them to make surethey</p>

<p>keep working.</p>

<p>• Documentation that we’ll auto-generate fromthe header files.</p>

<p>You already havethe c-skeleton, so use it to createa liblcthw project:</p>

<p>Exercise 32 Session</p>

<pre><code class="language-c">
$ cp -r c-skeleton 
liblcthw 
$ cd liblcthw/ $ ls 
LICENSE Makefile 
$ vim Makefile $ ls src/
dbg.h libe 
$ mkdir src/lcthw $ mv src/dbg.hsrc/lcthw$ vim tests/minunit.h $ rm src/libex29.*tests/libex29*$ make clean 
rm -rf build tests/libex29_tests rm -f tests/tests.log find . -name &quot;*.gc*&quot; 
-exec rm {} \; rm -rf `find . -name &quot;*.dSYM&quot; -print` 
$ ls tests/
minunit.h runtests.sh 
$ 

In this sessionIdo the following: 
• Copy the c-skeleton over. 

• Editthe Makefile to change 


libYOUR_LIBRARY.a 
to liblcthw.a as the new TARGET. 
• Makethe src/lcthwdirectory, where we’ll putourcode. 

• Move the src/dbg.h
into this new directory. 


• Edit 


tests/minunit.h

so thatituses 
#include &lt;lcthw/dbg.h&gt; as the include. 
• Getrid of thesource and testfiles thatwe don’tneed for libex29.*. 

• Cleanup everything 



that’s leftover. Now thatyou’re ready tostart building thelibrary,the first data structure that I'll buildis the doubly linkedlist. 
Doubly Linked Lists 


The first data structure that we’ll addto liblcthw is a doubly linked list. This is the simplest datastructureyou can make,and it has useful properties for certain operations. A linked list works bynodeshaving pointersto their next or previous element. A doubly linked listcontains pointers to both, while asingly linked list only pointsatthe next element. 

Because each node has pointersto thenext and previous elements, and because you keeptrackof the first andlastelements ofthe list, you can dosome operations very quickly with doubly linked lists. Anything thatinvolves inserting or deletinganelement will be very fast. They’re alsoeasyto implementby most programmers. 

The main disadvantage ofa linked lististhat traversingit involvesprocessingevery single pointer along the way. This meansthat searching, most sorting, and iterating over the elementswillbe slow. Italso meansthat you can’t really jump torandom partsof thelist. If you had an array ofelements,you could justindexright into the middleof thelist,buta linked list uses a stream ofpointers. 
That meansif you want the tenth element, you have togo through thefirst nine elements. 
Definition 

As I said inthe introduction to this exercise, firstwritea header filewiththe rightC structure statements init. 
list.h 

```c

#ifndef lcthw_List_h #define lcthw_List_h 
#include &lt;stdlib.h&gt; 
struct ListNode;typedef struct 
ListNode {struct ListNode *next;struct ListNode *prev;void *value;} ListNode; 
typedef struct List {int count;ListNode *first;ListNode *last;
} List; 
List *List_create(); 
void 
List_destroy(List * list);void List_clear(List 
* list); 
void 
List_clear_destroy(Lis 
* list); 
#define List_count(A) ((A)-&gt;count) #define List_first(A) ((A)-&gt;first != NULL ? (A)-&gt;first-&gt;value : NULL) #define List_last(A) ((A)-&gt;last != NULL ? (A)-&gt;last-&gt;value : NULL) 
void List_push(List * list, void *value); void *List_pop(List * list); 
void 
List_unshift(List * list, void *value); void *List_shift(List 
* list); 
void 
*List_remove(List * list, ListNode * node); 
#define LIST_FOREACH(L, S, M, 
V) ListNode *_node = NULL;\ 
*V = NULL;\ for(V = _node = L-&gt;S; _node != NULL; V = _node = _node-&gt;M) 
#endif 

The first thing Ido is create twostructuresforthe ListNode andthe List thatwillcontain thosenodes. This creates thedata structure,whichI’ll use in the functions andmacros thatI define after that. If you read these functions, you’ll see thatthey’re rathersimple. I'll be explainingthemwhen I cover the implementation, but hopefullyyoucanguess what theydo. 
Each ListNode has three components within thedata structure: 
• A value, which is a pointer to anything, and storesthe thing wewant to put in thelist. 

•A 
ListNode *next 


pointer,whichpoints at anotherListNodethat holds the next element in thelist. 
•A ListNode *prevthatholdsthe previous element. Complex, right? Calling the previous thing “previous.” I could have used “anterior” and “posterior,” but only ajerkwould do 
that. The List struct isthen nothing more than a container for these ListNode structs thathave beenlinked together in a chain. It keeps track of 
the count, first, and last elements ofthe list. Finally,take alook at 
src/lcthw/list.h:37

where I definethe LIST_FOREACH macro. This is acommon programming idiom where you makea macrothat generates iteration codeso people can’t mess it up. Gettingthis kind of processing right can be difficultwithdata structures, so writing macros helps people out. You’llsee how I use this when Italk about the implementation. 
Implementation 

You should mostly understand how a doubly linked listworks. It’snothing more than nodeswithtwo pointersto thenext and previous elements ofthe list. You can thenwrite the 
src/lcthw /list.c
codeto see how each operation is implemented. 
list.c 


```c


1 #include &lt;lcthw/list.h&gt; 
2 #include &lt;lcthw/dbg.h&gt; 
3 
4 List *List_create() 
5 {
6 return calloc(1,sizeof(List)); 
7 }
8 
9 void 

List_destroy(List * 
list)
10 {
11 LIST_FOREACH first, next, cur){ 
12 if (cur-&gt;prev){ 
13 free &gt;prev); 
1. }

1. }16 17 free(list­


&gt;last); 18 free(list); 
19 } 
2. 21 void 

List_clear(List * 
list)
22 {
23 LIST_FOREACH first, next, cur){ 
24 free(cur &gt;value); 
2. }

2. }
2. 28 void 



List_clear_destroy(Lis 
* list)29 { 30 List_clear(l 31 List_destroy
32 }
33 
34 void 

List_push(List * 
list, void *value)35 {36 ListNode 
*node = calloc(1,
sizeof(ListNode)); 37 check_mem(no 38 39 node-&gt;value 
= value;40 
41 if (list­&gt;last == NULL){ 
42 list­&gt;first = node;
43 list­&gt;last = node;
44 } else {45 list­&gt;last-&gt;next = node;46 node­&gt;prev = list-&gt;last;
47 list­&gt;last = node;
48 }
49 
50 list­
&gt;count++;

51. 52  error:  
53 54 55  }  return;  
56  void  

*List_pop(List * 
list)
57 {
58 ListNode *node = list-&gt;last;
59 return node != NULL ? List_remove(list,node): NULL; 
60 }
61 
62 void 

List_unshift(List * 
list, void *value)63 {64 ListNode 
*node = calloc(1,
sizeof(ListNode)); 65 check_mem(no 66 67 node-&gt;value 
= value;68 69 if (list­
&gt;first == NULL){ 
70 list­&gt;first = node;
71 list­&gt;last = node;
72 } else {
73 node­&gt;next = list-&gt;first;
74 list­&gt;first-&gt;prev = node;

75 list­&gt;first = node;
76 }
77 
78 list­
&gt;count++;79 *List_shift(List * 
80  error:  
81 82 83  }  return;  
84  void  

list)
85 {
86 ListNode *node = list-&gt;first;
87 return node != NULL ? List_remove(list,node): NULL;
88 }89 
90 void *List_remove(List * list, ListNode * node)
91 {
92 void *result = NULL;
93 
94 check(list­&gt;first &amp;&amp; list-&gt;last,&quot;List is empty.&quot;); 
95 check(node,&quot;node can't be NULL&quot;); 
96 
97 if (node == list-&gt;first &amp;&amp; node == list-&gt;last){ 
98 list­&gt;first = NULL;
99 list­&gt;last = NULL;
100 } else if (node == list-&gt;first){101 list­&gt;first = node-&gt;next;102 check(li &gt;first != NULL,103 
list, somehow got a first that is NULL.&quot;); 
104 list­&gt;first-&gt;prev = NULL;
105 
} else if (node == list-&gt;last){106 list­&gt;last = node-&gt;prev;107 check(li &gt;last != NULL,108 

list, somehow got a next that is NULL.&quot;); 109 list­&gt;last-&gt;next = NULL;

11. } else {111 ListNode 

*after = node-&gt;next;112 ListNode *before = node-&gt;prev;113 after­&gt;prev = before;114 before­&gt;next = after;

11. }
11. 117 list­&gt;count--;
118 result = 
node-&gt;value;
119 free(node); 
12. 121 error: 


122 return result;

12. } 

</code></pre>

<p>I then implementallof the operations ona doubly linked list that can’t be done with simple macros. Rather than cover every tiny,littleline of this file, I&rsquo;m going to give a high-leveloverviewof every operation inboththe list.h and list.c files, and then leaveyouto read the
code. list.h:List_count Returns the number of elements in thelist,which is maintained as elements are added andremoved. list.h:List_first Returns the firstelementof the list, butdoesn’t remove it. list.h:List_last Returns the lastelementof the list, butdoesn’t remove
it.
list.h:LIST_FOREACH</p>

<p>Iterates over the
elements in the list.</p>

<p>list.c:List_create Simply creates themain List struct.
list.c:List_destroy Destroys a List and any elementsit might have.
list.c:List_clear A convenient function for freeingthe values in each node,notthe nodes.
list.c:List_clear_destroy
Clears and destroys a list. It’s notvery efficient since it loops through them twice.
list.c:List_push The first operation that demonstrates the advantageof a linked list. Itadds anew element tothe end of the list, and because that’s justa couple of pointer assignments, it does itveryfast.
list.c:List_pop The inverse of List_push, this takes the lastelementoff and returnsit.
list.c:List_unshift The other thingyou can easily do to a linked list isadd elements to the front of the list very quickly. In thiscase, I call that List_unshift for lack of abetterterm.
list.c:List_shift Just like List_pop, this removes the first element andreturns it.
list.c:List_remove This is actually doingall ofthe removal whenyoudo List<em>pop or List</em> shift.Something that seems to always be difficultin data structuresisremoving things, and this function isno different. It has to handle quite a few conditions depending on if the elementbeing removed is at the front, the end, boththe front and theend, orthe
middle. Mostof these functionsare nothing special, and you should beable to easilydigest this and understand itfrom justthe code. You should definitely focus on howthe LIST_FOREACH macro is used in List_destroy so thatyou canunderstand how much it simplifies this common operation.
Tests</p>

<p>After you havethose compiling, it’s time to create the testthat makessure they operate correctly.
list_tests.c</p>

<pre><code class="language-c">
1 #include &quot;minunit.h&quot; 2 #include &lt;lcthw/list.h&gt; 
3 #include &lt;assert.h&gt; 
4 5 static List *list = NULL;6 char *test1 = &quot;test1 data&quot;;7 char *test2 = &quot;test2 data&quot;;8 char *test3 = &quot;test3 data&quot;;9 10 char 
*test_create() 
11 {
12 list = List_create(); 
13 mu_assert(li != NULL, &quot;Failed to create list.&quot;); 
1. 15 return NULL;
16 }17 18 char 
*test_destroy() 
19 20  {  List_clear_d  
21. 22  return  

NULL;
2. 24 }
2. 26 char 

*test_push_pop() 
27 {
28 List_push(li test1); 
29 mu_assert(Li == test1, &quot;Wrong last value.&quot;); 
30 
31 List_push(li test2); 
32 mu_assert(Li == test2, &quot;Wrong last value&quot;); 
33 
34 List_push(li test3); 
35 mu_assert(Li == test3, &quot;Wrong last value.&quot;); 
36 mu_assert(Li == 3, &quot;Wrong count on push.&quot;); 
37 
38 char *val = List_pop(list); 
39 mu_assert(va == test3, &quot;Wrong value on pop.&quot;); 
40 
41 val = List_pop(list); 
42 mu_assert(va == test2, &quot;Wrong value on pop.&quot;); 
43 
44 val = List_pop(list); 
45 mu_assert(va == test1, &quot;Wrong value on pop.&quot;); 
46 mu_assert(Li == 0, &quot;Wrong count 50 51 char 
after 47  pop.&quot;);  
48  return  
NULL;49  }  

*test_unshift() 
52 {
53 List_unshift test1); 
54 mu_assert(Li == test1, &quot;Wrong first value.&quot;); 
55 
56 List_unshift test2); 
57 mu_assert(Li == test2, &quot;Wrong first value&quot;); 
58 
59 List_unshift test3); 
60 mu_assert(Li == test3, &quot;Wrong last value.&quot;); 
61 mu_assert(Li == 3, &quot;Wrong count on unshift.&quot;); 
62 
63 return NULL;
64 }
65 
66 char 

*test_remove() 67 {68 // we only 
need to test the middle remove case since push/shift 
69 // already tests the other cases 
70 
71 char *val = List_remove(list,list-&gt;first-&gt;next); 
72 mu_assert(va == test2, &quot;Wrong removed element.&quot;); 
73 mu_assert(Li == 2, &quot;Wrong count after remove.&quot;); 
74 mu_assert(Li == test3, &quot;Wrong first after remove.&quot;); 
75 mu_assert(Li == test1, &quot;Wrong last after remove.&quot;); 
76 
77 return NULL;
78 }
79 
80 char 

*test_shift() 
81 {
82 mu_assert(Li 
!= 0, &quot;Wrong count before shift.&quot;); 
83 
84 char *val = List_shift(list); 
85 mu_assert(va == test3, &quot;Wrong value on shift.&quot;); 
86 
87 val = List_shift(list); 
88 mu_assert(va == test1, &quot;Wrong value on shift.&quot;); 
89 mu_assert(Li == 0, &quot;Wrong count after shift.&quot;); 
90 
91 return NULL;
92 }
93 
94 char 

*all_tests() 95 {96 mu_suite_sta 97 98 mu_run_test(99 mu_run_test(
100 mu_run_test(
101 mu_run_test(
102 mu_run_test(
103 mu_run_test(
104 
105 return 

NULL;
106 }107 
108 


RUN_TESTS(all_te 
</code></pre>

<p>This test simplygoes through every operation and makes sureitworks. I use a simplification in the test where I createjust one List *list for thewhole program, andthen have the tests work on it. Thissaves the trouble of building a List for every test, butit could mean thatsome tests only pass because of how the previous test ran. In this case, I try to make each testkeep the listclear or actually use the results from the previous test.</p>

<p>What You Should See</p>

<p>If you did everything right, thenwhenyoudo abuild and run the unit tests, it should look likethis:</p>

<p>Exercise 32.build Session</p>

<pre><code class="language-c">
$ make 
cc -g -O2 -Wall -Wextra -Isrc ­rdynamic -DNDEBUG ­fPIC -c -o\ 
src/lcthw/list. src/lcthw/list.c ar rcs build/liblcthw.a src/lcthw/list.o ranlib build/liblcthw.a cc -shared -o build/liblcthw.so src/lcthw/list.o cc -g -O2 -Wall -Wextra -Isrc ­rdynamic ­
DNDEBUG build/liblcth tests/list_tests.c 
o tests/list_tests sh ./tests/runtests.sh Running unit tests: 
RUNNING: ./tests/list_tests ALL TESTS PASSED Tests run: 6 tests/list_tests PASS 
$ 
RUN_TESTS(all_te 
</code></pre>

<p>Make sure six tests ran, it
builds without warnings or</p>

<p>errors, andit’s making the</p>

<p>build /liblcthw.a and build/liblcthw.so
files.
How to Improve It</p>

<p>Instead ofbreaking this, I&rsquo;m goingto tell you how to improve thecode:
• You can make
List_clear_destro
more efficient byusing</p>

<p>LIST_FOREACH and</p>

<p>doing both free calls inside one loop.
• You can addasserts for preconditions so that the program isn’t given a NULL value forthe List *list parameters.</p>

<p>• You can addinvariants thatcheck thatthe list’s contents arealways correct, such as count isnever <0, and if count > 0, then first isn’t NULL.</p>

<p>• You can add documentation to the header filein the form ofcomments before each struct,function, and macrothat describes whatit does.</p>

<p>Theseimprovements speakto the defensive programming practices I talked about earlier, hardening this code against flawsand improving usability. Go aheadand do these things, andthen findas many other waysto improve the code as you can.</p>

<p>Extra Credit</p>

<p>• Research doubly versus singly linkedlists and when one is preferred over the other.</p>

<p>• Research the limitations
ofa doubly linkedlist.</p>

<p>For example, while they are efficient for inserting anddeleting elements, theyare very slowforiteratingover them all.</p>

<p>• What operations are missing that you can imagineneeding? Some examples arecopying, joining,and splitting. Implementthese operations andwritethe</p>

<p>unit tests for them.</p>

<p>Exercise33.
LinkedList
Algorithms</p>

<p>Im going tocovertwo algorithmsfor alinked list thatinvolve sorting. I&rsquo;m goingto warn youfirst thatif you need tosortthe data, then don’tusea linkedlist. These are horribleforsortingthings, and there aremuchbetter data structures youcan use if that’s arequirement. I&rsquo;m covering these two algorithms because they are slightly difficultto pull off with a linked list, and to getyou thinking abouthow to efficientlymanipulate them.</p>

<p>In the interest of writing this book, I&rsquo;m going to put the algorithmsin twodifferent files list_algos.h and list_algos.c then write atestin list_algos_test.c.For now,just follow mystructure, since itkeeps things clean, butif you everwork onother libraries, remember thatthis isn’t acommon structure.</p>

<p>In this exercise,I&rsquo;m also goingto giveyouanextra challenge and I want youto try notto cheat. I&rsquo;m going to giveyouthe unit test first, and Iwantyou totype itin. Then, I want youto try and implementthe twoalgorithms based on their descriptions in Wikipedia beforeseeing if your code looks likemy code.
Bubble and Merge Sorts</p>

<p>You know what’s awesome about theInternet?Ican just refer you to the “bubble sort” and “mergesort” pages on Wikipedia andtell you to readthose. Man, thatsaves me a boatload oftyping. Now I can tellyouhowto actually implementeachof these using the pseudo-code they havethere. Here’s how you can tacklean algorithmlike this:
• Readthe description and lookatany visualizations ithas.</p>

<p>• Either draw the</p>

<p>algorithmon paper using boxesand lines, oractually take a deck ofplaying cards (or cards with numbers) and try todo the algorithmmanually. This givesyou a concrete demonstration ofhow thealgorithm works.</p>

<p>• Create the skeleton functions in your list_algos.c file and make a working list_algos.h file, thensetup your test harness.</p>

<p>• Write your first failing test andget everything to compile.</p>

<p>• Goback tothe Wikipedia pageand copy-paste the pseudo-code (notthe C code!) into the guts ofthe first function that you’re making.</p>

<p>• Translate thispseudo­code into goodCcode the wayI’ve taught you, using your unit testto makesure it’s working.</p>

<p>• Fill out somemore tests for edgecases like empty lists, already sorted lists, andthe like.</p>

<p>• Repeat this for thenext
algorithmand test it.</p>

<p>I justgave you the secret to figuringoutmostof the algorithmsoutthere—until you get tosome of the more insaneones,that is. In this case, you’re justdoing the bubbleand merge sorts from Wikipedia,butthose will be good starters.</p>

<p>The Unit Test</p>

<p>Hereis the unit test you should use forthe pseudo-code:
list_algos_tests.c</p>

<pre><code class="language-c">
1 #include &quot;minunit.h&quot; 2 #include &lt;lcthw/list_algos.h&gt; 3 #include 
&lt;assert.h&gt; 
4 #include &lt;string.h&gt; 
5 
6 char *values[] ={ &quot;XXXX&quot;, &quot;1234&quot;,&quot;abcd&quot;, &quot;xjvef&quot;,&quot;NDSS&quot; }; 
7 
8 #define NUM_VALUES 5 
9 
10 List *create_words() 
11 {
12 int i = 0;
13 List *words = List_create(); 
1. 15 for (i = 0;i &lt; NUM_VALUES; i++){
16 List_pus values[i]); 
17 }
1. 19 return 

words;
20 }
2. 22 int 

is_sorted(List * words) 23 {
24 LIST_FOREACH first, next, cur){ 
25 if (cur-&gt;next &amp;&amp; strcmp(cur-&gt;value, cur-&gt;next-&gt;value)&gt; 
0) {
26 debu %s&quot;, (char *)cur­&gt;value,
27 *)cur-&gt;next-&gt;value); 
28 retu 0;
2. }

30 
} 


31 

32 return 1;
33 }
34 
35 char 

*test_bubble_sort() 36 {37 List *words 
= create_words(); 38 39 // should 
work on a list that needs sorting 
40 int rc = List_bubble_sort(words (List_compare) strcmp); 
41 mu_assert(rc == 0, &quot;Bubble sort failed.&quot;); 
42 mu_assert(is 
43 &quot;Wor are not sorted after bubble sort.&quot;); 
44 
45 // should work on an already sorted list 
46 rc = List_bubble_sort(words (List_compare)strcmp); 
47 mu_assert(rc == 0, &quot;Bubble sort of 
already sorted 
failed.&quot;); 
48 mu_assert(is 
49 &quot;Wor should be sort if already bubble sorted.&quot;); 
50  
51 52  List_destroy  
53  //  should  
work  on  an  empty  list  
54  words  =  

List_create(words); 55 rc = 
List_bubble_sort(words (List_compare)strcmp); 
56 mu_assert(rc == 0, &quot;Bubble sort failed on empty list.&quot;); 
57 mu_assert(is &quot;Words should be sorted if empty.&quot;); 
58 
59 List_destroy
60 
61 return NULL;
62 }
63 

64 char 

*test_merge_sort() 
65 {
66 List *words = create_words(); 
67 
68 // should work on a list that needs sorting 
69 List *res = List_merge_sort(words,(List_compare)strcmp); 
70 mu_assert(is 
&quot;Words are not sorted after merge sort.&quot;); 
71 
72 List *res2 = List_merge_sort(res,(List_compare)strcmp); 
73 mu_assert(is 
74 &quot;Sho still be sorted after merge sort.&quot;); 
75 List_destroy
76 List_destroy
77 
78 List_destroy
79 return 
NULL;
80 } 
81 82 char 
*all_tests() 

83 84  {  mu_suite_sta  
85  
86 87 88  mu_run_test(mu_run_test(  
89  return  
NULL;90  } 

91 
92 RUN_TESTS(all_te 
</code></pre>

<p>I suggest thatyoustart with</p>

<p>the bubble sortand getthat working, andthen moveon to the mergesort. What I would do is layoutthefunction prototypesand skeletons that get allthree files compiling, butnotpassing thetest. Then, I’d justfillin the implementation until it starts working.</p>

<p>The Implementation</p>

<p>Areyou cheating? Infuture exercises, I’lljust give youa unit test andtell you to implementit, so it’s good practice for you to not look at this code until you getyour own working. Here’s the code for the list_algos.c and list_algos.h:
list_algos.h</p>

<pre><code class="language-c">
#ifndef lcthw_List_algos_h #define lcthw_List_algos_h 
#include 
&lt;lcthw/list.h&gt; 
typedef int (*List_compare)(const void *a, const void *b); 
int 
List_bubble_sort(List 
* 
list, List_compare cmp); 

List *List_merge_sort(List 

* 
list, List_compare cmp); 


#endif 
list_algos.c 

```c

1 #include &lt;lcthw/list_algos.h&gt; 
2 #include &lt;lcthw/dbg.h&gt; 
3 
4 inline void ListNode_swap(ListNode 
* a, ListNode * b)5 {6 void *temp 
= a-&gt;value;7a-&gt;value = b-&gt;value;8b-&gt;value = temp;
9 }
1. 11 int 

List_bubble_sort(List 
* list, List_compare cmp)
12 13  {  int  sorted  
= 1;14  
15  if  

(List_count(list) &lt;= 
1) {
16 return 0; // already sorted 
17 }
1. 19 do { 

20 sorted 
= 1;
21 LIST_FOR first, next, cur){ 22 if (cur-&gt;next){ 
23 (cmp(cur-&gt;value, cur­&gt;next-&gt;value) &gt; 0) { 
24 cur-&gt;next); 2. = 0;
2. 2. }

2. } 

2. } while 


(!sorted); 30 31 return 0;
32 }
33 
34 inline List 

*List_merge(List * left, List * right,List_compare cmp)
35 {
36 List *result = List_create(); 
37 void *val = NULL; 
38 39 while 
(List_count(left)&gt;0 || List_count(right)&gt; 0) {
40 if (List_count(left)&gt;0 &amp;&amp; List_count(right)&gt; 0) {
41 if (cmp(List_first(left),List_first(right)) &lt;= 
0) {
42 = List_shift(left); 
43 } 
else {
44 = List_shift(right); 
45 }46 47 List 
val);
48 
} else if (List_count(left)&gt; 0) {

49 val = List_shift(left); 50 List val);

51 
} else if (List_count(right) 


&gt; 0) {
52 val = List_shift(right); 53 List val);
54 
}

55 
}
56 
57 return 



result;
58 }
59 
60 List 

*List_merge_sort(List 
* list, List_compare cmp) 61 {
62 if (List_count(list) &lt;= 
1) {
63  return  
list;64 65  }  
66  List *left  

= List_create(); 
67 List *right = List_create(); 
68 int middle = List_count(list)/2;
69 
70 LIST_FOREACH first, next, cur){ 
71 if (middle &gt; 0) { 
72 List cur-&gt;value); 
73 } else {
74 List cur-&gt;value); 
75 76  }  
77  middle­ 
-;78 79  }  

80 List 

*sort_left = List_merge_sort(left, cmp);
81 List *sort_right = List_merge_sort(right, cmp);
82 
83 if 

(sort_left != left)84 List_des 85 if 
(sort_right != right)86 List_des 87 
88 return 

List_merge(sort_left,sort_right, cmp); 
89 } 

The bubble sort isn’t too hard to figure out,althoughit’s really slow. The mergesort is much more complicated, and honestly, Icouldprobably spendabit more time optimizing this code if I wanted to sacrificeclarity. 


There is another way to implementa mergesort using abottom-up method,but it’s alittleharder tounderstand, so I didn’t doit. As I’ve already said, sorting algorithmson linkedlists are entirelypointless. You could spendall day trying tomake this faster and it will stillbe slower than almost anyother sortable datastructure. Simply don’t use linked lists if you need to sort things. 


What You Should See 

Ifeverything works, then you should getsomething like this: 


Exercise 33 Session 


```c

$ make clean all 
rm -rf build src/lcthw/list.o src/lcthw/list_algos.o 
tests/list_algo tests/list_tests rm -f tests/tests.log find . -name &quot;*.gc*&quot; -exec rm {} \; rm -rf `find . -name &quot;*.dSYM&quot; -print` cc -g -O2 -Wall -Wextra -Isrc ­rdynamic -DNDEBUG ­fPIC -c -o\ 
src/lcthw/list. src/lcthw/list.c cc -g -O2 -Wall -Wextra -Isrc ­rdynamic -DNDEBUG ­fPIC -c -o\ 
src/lcthw/list_ src/lcthw/list_algos.c ar rcs build/liblcthw.a src/lcthw/list.o src/lcthw/list_algos.o ranlib build/liblcthw.a cc -shared -o build/liblcthw.so src/lcthw/list.o src/lcthw/list_algos.o cc -g -O2 -Wall -Wextra -Isrc ­rdynamic ­DNDEBUG build/liblcth 
tests/list_algo o tests/list_algos_tests cc -g -O2 -Wall -Wextra -Isrc ­rdynamic ­DNDEBUG build/liblcth 
tests/list_test 
o tests/list_tests sh ./tests/runtests.sh Running unit tests: 
RUNNING: ./tests/list_algos_tes ALL TESTS PASSED 
Tests run: 2 

tests/list_algos_tests PASS 
RUNNING: ./tests/list_tests ALL TESTS PASSED Tests run: 6 tests/list_tests PASS 
$ 

After this exercise, I'mnot goingto showyouthis output unlessit’s necessary to show you howit works. From now on, you should knowthat I ranthe tests and that they all passed andeverything compiled. 
How to Improve It 
Goingback to thedescription ofthe algorithms, there are severalways toimprove these implementations. Here are a fewobvious ones: 
• The merge sort doesa crazyamount of copying and creating lists, so find waysto 

reduce this. 

• The bubblesort description in Wikipedia mentions a fewoptimizations. Try to implement them. 

• Canyou use the List_split and List_join (if you implemented them) to improve mergesort? 

• Gothrough allof the defensiveprogramming 


checks and improve the robustnessof this implementation, protectingagainstbad NULL pointers, and thencreate an optional debug level invariant thatworks like is_sorted doesafter asort. 

Extra Credit 

• Create aunittestthat comparesthe performance ofthe two algorithms. You’ll want to look at man 3 time for abasic timer function, and run enoughiterationsto at least havea few secondsof samples. 

• Play with theamountof data inthe lists that 

need tobe sorted and seeif thatchanges your timing. 

• Finda way to simulate filling differentsized random lists, measuring how long theytake. Then, graph theresult to see howit compares to thedescription ofthe algorithm. 

• Tryto explain why sortinglinked lists is a 

really badidea. 

• Implement a 


List_insert_sorte 

that will take a given value, and using the List_compare, insert the elementatthe rightposition so that the list is always sorted. How does using this methodcompare to sortinga list after you’vebuilt it? 
• Tryimplementing the bottom-up mergesort describedon the Wikipedia page. The code there is already C, so it shouldbeeasyto recreate,buttry to understand how it’s working compared to the slower one I have here. 

Exercise34. Dynamic Array 

This is an array thatgrows on its own and has most of the same featuresas a linked list. Itwill usuallytake up less space,runfaster, andhas other beneficial properties. This exercisewillcovera few ofthe disadvantages,like very slowremovalfrom the front, with a solution to just 
do itatthe end. A dynamic array is simply an array of void ** pointers that’s pre-allocatedin one shotand thatpoint at thedata. In the linked list, you hada full structure thatstored the void *value pointer, but in a dynamic array,there’s justa single array with allof them. Thismeans you don’t need any other pointers for nextand previous records since you can justindex into the dynamic array directly. 

To start, I’llgive you the header fileyoushould type in for the implementation: 
darray.h 

```c

#ifndef _DArray_h #define _DArray_h #include &lt;stdlib.h&gt; 
#include &lt;assert.h&gt; #include &lt;lcthw/dbg.h&gt; 
typedef struct DArray 
{ int end;
int max;
size_t element_size;
size_t expand_rate;
void **contents;} DArray; 
DArray*DArray_create(size_t element_size, size_t initial_max); 
void 
DArray_destroy(DArray 
* array); 
void 
DArray_clear(DArray * array); 
int 
DArray_expand(DArray 
* array); 
int 
DArray_contract(DArray
* array); 
int 
DArray_push(DArray * array, void *el); 
void 
*DArray_pop(DArray * array); 
void 
DArray_clear_destroy(D 
* array); 
#define DArray_last(A) ((A)­
&gt;contents[(A)-&gt;end ­1]) 
#define 
DArray_first(A) ((A)­&gt;contents[0]) 
#define DArray_end(A) 
((A)-&gt;end) 
#define 
DArray_count(A) 
DArray_end(A) 
#define DArray_max(A) 
((A)-&gt;max) 

#define 
DEFAULT_EXPAND_RATE 

300 

static inline void 
DArray_set(DArray * 
array, int i, void 
*el)
{ 

check(i &lt; array­&gt;max, &quot;darray attempt to set past max&quot;); 
if (i &gt; array­&gt;end) array-&gt;end = i; 
array­&gt;contents[i]= el; error: 
return;} 
static inline void 
*DArray_get(DArray * 
array, int i)
{ 

check(i &lt; array­&gt;max, &quot;darray attempt to get past max&quot;); 
return array­&gt;contents[i]; error: 
return NULL;} static inline void 
*DArray_remove(DArray 
* array, int i){ 
void *el = array­&gt;contents[i]; 
array­&gt;contents[i]= NULL; 
return el;} 
static inline void 
*DArray_new(DArray * 
array)
{ 

check(array­&gt;element_size &gt; 0,
&quot;Can't use DArray_new on 0 size darrays.&quot;); 
return calloc(1, array-&gt;element_size); 
error: 
return NULL;} 
#define DArray_free(E) free((E)) 
#endif 


This header fileisshowing you anew technique where I put static inline functions rightin the header. Thesefunction definitions will work similarly tothe #define macros that you’vebeen making,but they’recleanerand easierto write. If you need to createa block ofcode for a macro and you don’tneed code generation, thenusea static inline function. 

Compare this technique to the LIST_FOREACH that generates aproper for-loop for alist. This would be impossible todo with a static inline function because itactually has to generate theinner block of codeforthe loop. Theonly way to do that iswitha callback function, butthat’s notas fastand it’s harder to use. 

I'll then change things upand haveyou create the unit test for DArray: 
darray_tests.c 

```c

1 #include &quot;minunit.h&quot; 2 #include 
&lt;lcthw/darray.h&gt; 
3 
4 static DArray *array = NULL;
5 static int *val1 = NULL;
6 static int *val2 = NULL;
7 
8 char *test_create() 
9 {
10 array = DArray_create(sizeof(i 100);
11 mu_assert(ar != NULL, &quot;DArray_createfailed.&quot;); 
12 mu_assert(ar &gt;contents != NULL,&quot;contents are wrong in darray&quot;); 
13 mu_assert(ar &gt;end == 0, &quot;end isn't at the right spot&quot;); 
14 mu_assert(ar &gt;element_size == sizeof(int),
15 &quot;ele size is wrong.&quot;); 
16 mu_assert(ar &gt;max == 100, &quot;wrong max length on initial 
size&quot;); 
1. 18 return NULL;
19 }20 21 char 
*test_destroy() *test_new() 
22 23 24  {  DArray_destr  
25  return  
NULL;26 27  }  
28  char  

29 {
30 val1 = DArray_new(array); 
31 mu_assert(va != NULL, &quot;failed to make a new element&quot;); 
32 
33 val2 = DArray_new(array); 
34 mu_assert(va != NULL, &quot;failed to make a new element&quot;); 
35 
36 return NULL; 
37 }
38 
39 char 

*test_set() 
40 {
41 DArray_set(a 0, val1); 
42 DArray_set(a 1, val2); 
43 
44 return 
NULL;
45 }
46 
47 char 

*test_get() 48 { 49 mu_assert(DA 
0) == val1, &quot;Wrong 
first value.&quot;); 50 mu_assert(DA 
1) == val2, &quot;Wrong 
second value.&quot;); 51 52 return 
NULL;
53 }
54 
55 char 

*test_remove() 56 {57 int 
*val_check = DArray_remove(array,0);
58 mu_assert(va != NULL, &quot;Should not get NULL.&quot;); 
59 mu_assert(*v == *val1, &quot;Should get the first value.&quot;); 
60 mu_assert(DA 
0) == NULL, &quot;Should 
be gone.&quot;); 
61 DArray_free(
62 
63 val_check = 
DArray_remove(array,1);64 mu_assert(va 
!= NULL, &quot;Should not get NULL.&quot;); 
65 mu_assert(*v == *val2, &quot;Should get the first value.&quot;); 
66 mu_assert(DA 
1) == NULL, &quot;Should be gone.&quot;); 
67 68  DArray_free(  
69  return  
NULL;70 71  }  
72  char  

*test_expand_contract( 

73 {
74 int old_max = array-&gt;max;
75 DArray_expan 
76 mu_assert((u int)array-&gt;max == old_max + array­&gt;expand_rate,
77 &quot;Wro size after expand.&quot;); 
78 
79 DArray_contr 
80 mu_assert((u int)array-&gt;max == array-&gt;expand_rate + 1,
81 &quot;Sho stay at the expand_rate at least.&quot;); 
82 
83 DArray_contr 
84 mu_assert((u int)array-&gt;max == array-&gt;expand_rate + 1,
85 &quot;Sho stay at the expand_rate at least.&quot;); 
86 
87 return NULL; 
88 }
89 
90 char 

*test_push_pop() 91 {92 int i = 0;93 for (i = 0;
i &lt; 1000; i++) { 
94 int *val = DArray_new(array); 
95 *val = i * 333;96 DArray_pval);
97 }
98 

99 mu_assert(ar &gt;max == 1201, &quot;Wrong max size.&quot;); 100 101 for (i = 999; i &gt;= 0; i--) { 102 int *val = DArray_pop(array); 103 mu_asser != NULL, &quot;Shouldn't get a NULL.&quot;); 104 mu_asser == i * 333, &quot;Wrong value.&quot;); 105 DArray_f 
106 
}
107 
108 return 
NULL;


109 
}
11. 111 char 
*all_tests() 
112 {
113 mu_suite_sta 
11. 115 mu_run_test(
116 mu_run_test(
117 mu_run_test(
118 mu_run_test(
119 mu_run_test(
120 mu_run_test( 


121 mu_run_test(
122 mu_run_test(
12. 124 return 
NULL;


12. }126 127 RUN_TESTS(all_te 
</code></pre>

<p>This showsyouhow allof the operations are used,which thenmakes implementing the DArray much easier:
darray.c</p>

<pre><code class="language-c">
1 #include &lt;lcthw/darray.h&gt; 2 #include 
&lt;assert.h&gt; 
3 
4 DArray *DArray_create(size_t element_size, size_t initial_max)
5 {
6 DArray *array = malloc(sizeof(DArray))
7 check_mem(ar 
8 array-&gt;max = initial_max;
9 check(array­&gt;max &gt; 0, &quot;You must set an initial_max &gt; 0.&quot;);
1. 11 array­&gt;contents = calloc(initial_max,sizeof(void *)); 
12 check_mem(ar &gt;contents); 
1. 14 array-&gt;end = 0;
15 array­&gt;element_size = element_size;
16 array­&gt;expand_rate = DEFAULT_EXPAND_RATE;
1. 18 return 

array;19 20 error: 21 if (array)22 free(arr 23 return 
NULL;
24 }
2. 26 void 

DArray_clear(DArray * 
array)
27 {
28 int i = 0;29 if (array­&gt;element_size &gt; 0) { 
30 for (i = 0; i &lt; array-&gt;max;i++) {
31 if (array-&gt;contents[i]!= NULL){ 
32 &gt;contents[i]); 
33 
}

34 
}

35 
} 


36 37  }  
38  static inline  
int  

DArray_resize(DArray 
* array, size_t 
newsize)
39 {
40 array-&gt;max 
= newsize;41 check(array­&gt;max &gt; 0, &quot;The 
newsize must be &gt; 
0.&quot;);
42 
43 void *contents = realloc( 
44 arra &gt;contents, array-&gt;max 
* sizeof(void *)); 
45 // check contents and assume realloc doesn't harm the original on error 
46 47 check_mem(co 48 49 array­
&gt;contents = contents;50 51 return 0;52 error: 53 return -1;
54 } 
55 
56 int DArray_expand(DArray 
* array)57 {58 size_t 
old_max = array-&gt;max;
59 check(DArrayarray-&gt;max + array­&gt;expand_rate) == 0,
60 &quot;Fai to expand array to new size: %d&quot;,
61 arra &gt;max + (int)array­&gt;expand_rate); 
62 
63 memset(array&gt;contents + old_max,0, array-&gt;expand_rate + 1);
64 65  return  0;  
66  error:  
67 68 69  }  return  -1;  
70  int  

DArray_contract(DArray
* array)71 {72 int 
new_size = array-&gt;end &lt; (int)array­&gt;expand_rate ? 
73 (int &gt;expand_rate : array­&gt;end;
74 
75 return DArray_resize(array,new_size + 1); 
76 }
77 
78 void 

DArray_destroy(DArray 
* array)79 {80 if (array)
{81 if 
(array-&gt;contents)
82 free &gt;contents); 
83 free(arr 
84 
}

85 
}
86 
87 void 



DArray_clear_destroy(D 
* array)88 {89 DArray_clear 90 DArray_destr 
91 }
92 
93 int 

DArray_push(DArray * array, void *el)
94 {
95 array­&gt;contents[array-&gt;end]= el;
96 array­&gt;end++;
97 
98 if (DArray_end(array) &gt;= DArray_max(array)) { 
99 return DArray_expand(array); 
100 
} else {101 return 0;

102 
} 

103 
}
104 
105 void 
*DArray_pop(DArray * 
array)
106 {
107 check(array­&gt;end -1 &gt;= 0,



&quot;Attempt to pop from 
empty array.&quot;); 
108 
109 void *el = 
DArray_remove(array, 
array-&gt;end -1); 
110 array-&gt;end­-;

11. 112 if 

(DArray_end(array)&gt; (int)array­&gt;expand_rate113 &amp;&amp; DArray_end(array)% array-&gt;expand_rate){ 114 DArray_c 
11. }
11. 117 return el;
118 error: 
119 return 
NULL;


12. } 




This showsyouanother way 

to tackle complexcode. Instead ofdivingright into the .c implementation,look at the header file,and then readthe unit test. Thisgives you an abstract-to-concrete understanding of how the pieces worktogether, making it easierto remember. 
Advantages and 
Disadvantages 


A DArray is better when you need tooptimizethese operations: 
• Iteration: You can just use abasic for-loop and DArray_countwith DArray_get, and you’re done. No specialmacrosneeded, and it’s faster because 

you aren’t walking 
through pointers. 


• Indexing: You can use DArray_get and DArray_set to access any element at random,butwith a List you have togo through N elementsto get toN+1. • Destroying: You can justfree thestructand the contents in two 

operations. A List requiresa seriesof free calls andwalking every element. 

• Cloning:You can also cloneit in justtwo operations (plus whateverit’s storing) by copying thestruct and contents. Again, alist requireswalking through thewhole thing and copying every 

ListNode plus its 
value. 


• Sorting: As you saw, List ishorrible ifyou need tokeep thedata sorted. A DArrayopensup a whole class ofgreatsorting algorithms, because now youcan access elements randomly. 

• LargeData: If you need 
to keeparounda lot of 



data, thena DArraywinssince its base, contents, takes up lessmemory thanthe same number of ListNode structs. 

However, the List wins on 

these operations: 
• Insertand removeon the front (what Icalled shift):A DArray needs specialtreatmentto be able todo this 

efficiently, andusually it has to do some copying. 

• Splitting orjoining: A List can justcopy somepointers and it’s done,but with a DArray,youhave copy all ofthe arrays involved. 

• SmallData:If you only need tostorea few elements, thentypically 


the storagewill be smaller ina List than ageneric DArray.This isbecause the DArrayneeds toexpand the backing store to accommodate future inserts,whilea List only makeswhatit needs. 

With this, I prefer to use a 
DArray for most ofthe 
things you seeother people use a List for. Ireserve using List for anydata structure thatrequires a small number ofnodes tobe added and removedfrom either end. I'll show you twosimilar data structures called a Stack and Queue wherethis is important. 
How to Improve It 

As usual, gothrough each function andoperation and add the defensive programming checks, pre­conditions, invariants, and anything else you can find to makethe implementation more bulletproof. 

Extra Credit 


• Improve the unit tests to cover moreof the operations, and test them using a for-loop to ensure that theywork. 

• Research whatit would take toimplement bubblesort andmerge sortforDArray, but don’tdo it yet. I’llbe implementingDArray algorithmsnext, so
you’ll do this then. 


• Write some performance tests for common operations and comparethemto the same operations in List.Youdid some of this already, but this time,writea unit test thatrepeatedlydoes the operation inquestion and then, in themain 

runner,do the timing. 


• Look at howthe DArray_expand is implemented using a constant increase (size +300). Typically, dynamicarraysare implemented with a multiplicative increase (size × 2), but I’ve foundthis tocost needless memory for no realperformancegain. 


Testmy assertionand seewhen you’d want a multiplicative increase instead of a constant increase. 

Exercise35. Sorting and Searching 

In this exercise,I'm going to cover foursorting algorithms and one searchalgorithm. The sortingalgorithms are goingto be quick sort,heap sort, mergesort, andradix sort. I'mthengoing to show 
you howdo a to binary search 

after you’vedonea radixsort. However, I'm alazy guy,and in most standardClibraries you have existing implementationsof the heapsort, quicksort, and merge sort algorithms. Here’s how youusethem: 
darray_algos.c 

```c


1 #include &lt;lcthw/darray_algos.h&gt; 
2 #include &lt;stdlib.h&gt; 
3 
4 int DArray_qsort(DArray * array, DArray_compare cmp)
5 {
6 qsort(array­&gt;contents,DArray_count(array), sizeof(void *), cmp); 
7 return 0;
8 }
9 

10 int 

DArray_heapsort(DArray
* array,
DArray_compare cmp)
11 {
12 return heapsort(array­&gt;contents,DArray_count(array), 
13 size *), cmp); 
14 }
1. 16 int 

DArray_mergesort(DArra 
* array,DArray_compare cmp) 
17 {18 return 
mergesort(array­&gt;contents,DArray_count(array), 
19 size *), cmp); 
20 } 
That’s the whole implementation ofthe darray_algos.c file, and it shouldwork onmost modern UNIX systems. What each ofthese does is sort the contents store ofvoid pointersusing the 
DArray_compare that you giveit. I'll showyouthe header filefor this, too: 
darray_algos.h 

```c

#ifndef darray_algos_h #define darray_algos_h #include &lt;lcthw/darray.h&gt; 
typedef int (*DArray_compare)(const void *a, const void *b); 
int 
DArray_qsort(DArray * array, DArray_compare cmp); 
int 
DArray_heapsort(DArray
* array, 
DArray_compare cmp); 
int 
DArray_mergesort(DArra 
* array,DArray_compare cmp); 
#endif 

It’s about the samesizeand should bewhat you expect. Next, you can see how these functions are used in theunit test for thesethree: 
darray_algos_tests.c 


```c

1 #include &quot;minunit.h&quot; 2 #include &lt;lcthw/darray_algos.h&gt; 
3 
4 int testcmp(char **a,char **b)
5 {6 return strcmp(*a,*b); 
7 } 
8 

9 DArray *create_words() 
10 {
11 DArray *result = DArray_create(0, 5); 
12 char *words[] = {&quot;asdfasfd&quot;,
13 &quot;werwar&quot; &quot;13234&quot;, &quot;asdfasfd&quot;,&quot;oioj&quot; }; 
14 int i = 0;
1. 16 for (i = 0; 

i &lt; 5; i++) { 
17 DArray_pwords[i]); 
18 }
1. 20 return 

result;
21 }
2. 23 int 

is_sorted(DArray * 
array)24 {25 int i = 0;26 27 for (i = 0; 
i &lt; 

DArray_count(array)­1; i++) { 
28 if (strcmp(DArray_get(arr i), DArray_get(array,*run_sort_test(int (*func)(DArray *,DArray_compare), 
i + 1)) 29  &gt;  0) {  retu  
0;30 31 32  }  }  
33 34 35  }  return  1;  
36  char  

37 const char *name)
38 {
39 DArray *words = create_words(); 
40 mu_assert(!i &quot;Words should start not sorted.&quot;); 
41 
42 debug(&quot;--­Testing %s sorting algorithm&quot;, name); 
43 int rc = 

func(words,(DArray_compare)testcmp); 
44 mu_assert(rc == 0, &quot;sort failed&quot;); 45 mu_assert(is 
&quot;didn't sort it&quot;); 46 47 DArray_destr 48 49 return 
NULL;
50 }
51 
52 char 

*test_qsort() 
53 {
54 return run_sort_test(DArray_q&quot;qsort&quot;); 
55 }
56 
57 char 

*test_heapsort() 
58 {
59 return 
run_sort_test(DArray_h &quot;heapsort&quot;); 
60 }
61 
62 char 

*test_mergesort() 63 {64 return 
run_sort_test(DArray_m &quot;mergesort&quot;); 
65 }66 67 char 
*all_tests() 
68 69  {  mu_suite_sta  
70  
71 72 73 74  mu_run_test(mu_run_test(mu_run_test(  

75 return 

NULL;
76 }77 78 RUN_TESTS(all_te 
</code></pre>

<p>The thing tonotice, and actually what tripped me up for awhole day, is the definition of testcmp on line4. You haveto use a char ** and not a char * because qsort gives you a pointer to the pointers in the contents array. The function qsort and friends are scanningthe array, and handing pointers to each element inthe array to your comparisonfunction. Since whatI havein the contents array are pointers, that meansyouget a pointer to a pointer.</p>

<p>With thatout of the way,you havejust implemented three difficultsorting algorithms in about 20lines ofcode. You could stopthere, but part of this bookislearninghow these algorithms work, so the Extra Credit section isgoing to involve implementingeach ofthese.
Radix Sort and
Binary Search</p>

<p>Since you’re going to implementquicksort, heapsort, andmerge sorton your own, I&rsquo;m going to show you afunky algorithm called radix sort. It has a slightly narrow usefulness insorting arrays ofintegers,butseems to worklike magic. In this case, I&rsquo;mgoing tocreate a specialdata structure called a RadixMap that’s usedto mapone integerto another.</p>

<p>Here’s the header file for the new algorithm, which is both algorithm and datastructure in one:
radixmap.h</p>

<pre><code class="language-c">
#ifndef _radixmap_h #include &lt;stdint.h&gt; 
typedef union 
RMElement {uint64_t raw;struct {
uint32_t key;uint32_t 
value;
} data;
} RMElement; 

typedef struct 
RadixMap {
size_t max;
size_t end;
uint32_t counter;
RMElement *contents;
RMElement *temp;} RadixMap; 
RadixMap*RadixMap_create(size_ max); 
void 
RadixMap_destroy(Radix 
* map); 
void 
RadixMap_sort(RadixMap
* map); 
RMElement *RadixMap_find(RadixMa 
* map, uint32_t key); 
int 
RadixMap_add(RadixMap 
* map, uint32_t key,uint32_t value); 
int 

RadixMap_delete(RadixM * map, RMElement * el); 
#endif 

You seethat I have alot of the sameoperations as ina Dynamic Array or a List data structure, butthe difference is I'mworking only with fixed size 32-bit uin32_t integers. I'malso introducing you toa newC 
concept calledthe union here. 
C Unions 

A unionis a wayto refer to the samepiece ofmemory in anumberof different ways. You define it like a struct, excepteveryelement is sharingthe same space with all ofthe others. You can think of aunion as apicture ofthe memory, and the elements inthe union as differentcolored lenses to viewthe picture. 

Whattheyareused for is to either save memory or convertchunks of memory between formats. Thefirst usage is typically done with varianttypes, where you createa structure thathastag for the type, and then a union inside it for each type. When used forconverting between formats ofmemory,you can simplydefine the two structures,and thenaccess the rightone. 

First, let meshow you how to makea variant typewithC unions: 

ex35.c 

```c

1 #include 
&lt;stdio.h&gt; 

2 
3 typedef enum {
4 TYPE_INT,
5 TYPE_FLOAT,
6 TYPE_STRING, 

7 8  } VariantType;  
9  struct Variant  
{10  VariantType  

type;
11 union {
12 int as_integer;
13 float as_float;
14 char *as_string;
15 } data;
16 }; 
1. 18 typedef struct Variant Variant;
1. 20 void Variant_print(Variant 
* var)21 {22 switch 
(var-&gt;type){ 
23 case TYPE_INT: 
24 prin %d\n&quot;, var­&gt;data.as_integer); 
25 brea 26 case TYPE_FLOAT: 
27 prin %f\n&quot;, var­&gt;data.as_float); 
28 brea 29 case TYPE_STRING: 
30 prin %s\n&quot;, var­&gt;data.as_string); 
31 brea 32 default: 33 prin 
TYPE: %d&quot;, var­&gt;type); 
34 
}

35 
} 


36 

37 int main(int argc, char *argv[]) 
38 {
39 Variant a_int = {.type = TYPE_INT, .data.as_integer = 100 }; 
40 Variant a_float = {.type = TYPE_FLOAT, .data.as_float = 
100.34 }; 
41 Variant a_string = {.type = 
TYPE_STRING,42 .data.as 
= &quot;YO DUDE!&quot; }; 43 44 Variant_prin 45 Variant_prin 46 Variant_prin 47 48 // here's 
how you access them 
49 a_int.data.a = 200;50 a_float.data = 2.345;51 a_string.dat = &quot;Hi there.&quot;; 
52 

53 Variant_prin 54 Variant_prin 55 Variant_prin 56 57 return 0;
58 } 

You find thisin many implementationsof dynamic languages. The languagewill define some base varianttype with tags for allthe base typesof thelanguage, and thenusually there’s a generic object tag forthe types you can create. The advantageof doingthis is thatthe Variant only takesup as much space asthe VariantType type tag and the largest member of the union. This is becauseC is layering each element of the Variant.data union together,sothey overlap. To do that,Csizes theunion big enoughto hold thelargest 
element. In the radixmap.h file, I havethe RMElement union, which demonstratesusing a unionto convertblocksof memory between types. In this case,I wantto store a uint64_t-sized integer for sortingpurposes, butI want two uint32_t integers for the datato representa key and value pair. By using a union, I'mable to cleanly 
access the same block of memory inthe twodifferent ways Ineed. 

The Implementation 

I next have the actual RadixMap implementation for each of these operations: 
radixmap.c 

```c


1 2  /* * Based  on  code  
by AheavZed  ndre Reinald ily modified A. Shaw.  then by  
3 4  */  
5  #include  

&lt;stdio.h&gt; 
6 #include &lt;stdlib.h&gt; 
7 #include &lt;assert.h&gt; 
8 #include &lt;lcthw/radixmap.h&gt; 
9 #include &lt;lcthw/dbg.h&gt; 
1. 11 RadixMap *RadixMap_create(size_ max)
12 {
13 RadixMap *map = calloc(sizeof(RadixMap1);
14 check_mem(ma 
1. 16 map­&gt;contents = calloc(sizeof(RMElemen max + 1); 
17 check_mem(ma &gt;contents); 
1. 19 map-&gt;temp = 
calloc(sizeof(RMElemen 

26 error: 
max + 1); 20 &gt;temp); 21  check_mem(ma  
22 max;23 0;24  map-&gt;max map-&gt;end  = =  
25  return  map;  

27 return NULL; 
28 }
2. 30 void 

RadixMap_destroy(Radix 
* map)31 {32 if (map){ 33 free(map
&gt;contents); 34 free(map&gt;temp); 35 free(map
36 
}

37 
}
38 
39 #define 



ByteOf(x,y) (((uint8_t *)x)[(y)]) 
40 
41 static inline void radix_sort(short offset, uint64_t max,
42 uint64_t * source, uint64_t * dest)
43 {
44 uint64_t count[256] = { 0 }; 
45 uint64_t *cp = NULL;
46 uint64_t *sp = NULL;
47 uint64_t *end = NULL; 
48 uint64_t s = 0;
49 uint64_t c = 0;
50 
51 // count occurences of every byte value 
52 for (sp = source, end = source 
+ max; sp &lt; end; sp++) { 
53 count[Byoffset)]++;
54 }
55 

56 // transform count into index by summing 
57 // elements and storing into same array 
58 for (s = 0, cp = count, end = count + 256; cp &lt; end; cp++) { 
59 c = *cp;
60 *cp = s;
61 s += c;
62 }
63 

64 // fill dest with the right values in the right place 
65 for (sp = source, end = source 
+ max; sp &lt; end; sp++) { 
66 cp = count + ByteOf(sp,offset); 
67 dest[*cp=*sp;68 ++ (*cp); 
69 
} 

70 
}
71 
72 void 



RadixMap_sort(RadixMap
* map)73 {74 uint64_t 
*source =&amp;map­&gt;contents[0].raw;
75 uint64_t *temp =&amp;map­&gt;temp[0].raw;
76 
77 radix_sort(0 map-&gt;end, source, temp); 
78 radix_sort(1 map-&gt;end, temp, source); 
79 radix_sort(2 map-&gt;end, source,temp); 
80 radix_sort(3 map-&gt;end, temp, source); 
81 }
82 
83 RMElement 

*RadixMap_find(RadixMa * map, uint32_t to_find)
84 {
85 int low = 

0;
86 int high = map-&gt;end -1;
87 RMElement *data = map­&gt;contents;
88 
89 while (low &lt;= high){ 
90 int middle = low +(high -low) / 2;
91 uint32_t key = data[middle].data.key;
92 
93 if (to_find &lt; key){ 
94 high = middle -1;
95 } else if (to_find &gt; key){ 
96 low = middle + 1;
97 } else {
98 retu 
&amp;data[middle]; 

99 
}


100 
}
101 
102 return 
NULL; 


103 
}104 105 int RadixMap_add(RadixMap 


* map, uint32_t key,uint32_t value)106 {107 check(key &lt; UINT32_MAX, &quot;Key can't be equal to UINT32_MAX.&quot;); 108 109 RMElement element = {.data = {.key = key,.value = value} }; 110 check(map­
&gt;end +1&lt; map-&gt;max,
&quot;RadixMap is full.&quot;); 
11. 112 map­&gt;contents[map-&gt;end++]
= element;
11. 114 RadixMap_sor 
11. 116 return 0;
11. 118 error: 
119 return -1;

120 }121 122 int 
RadixMap_delete(RadixM 
* map, RMElement * 
el)
123 {
124 check(map­&gt;end &gt; 0, &quot;There is 
nothing to delete.&quot;); 
125 check(el != 
NULL, &quot;Can't delete a 
NULL element.&quot;); 
12. 127 el­&gt;data.key = 
UINT32_MAX;
12. 129 if (map­&gt;end &gt; 1) { 

130 // don't bother resorting a map of 1 length 
131 RadixMap
132 
}
133 
134 map-&gt;end--;
135 
136 return 0;
137 error: 
138 return -1;


139 
} 




As usual, enter thisin andget it working, along with the unit test,and then I'll explain what’s happening. Take special care with the radix_sort functionsince it’sveryparticular in how it’s implemented. 
radixmap_tests.c 

```c

1 #include &quot;minunit.h&quot; 2 #include 
&lt;lcthw/radixmap.h&gt; 
3 #include &lt;time.h&gt; 
4 
5 static int make_random(RadixMap 
* map)6 {7 size_t i = 
0;
8 
9 for (i = 0;i &lt; map-&gt;max -1;i++) {
10 uint32_t key = (uint32_t) (rand() | (rand() &lt;&lt; 16));
11 check(Ra key, i) == 0, &quot;Failed to add key %u.&quot;,
12 key); 
1. }
1. 15 return i;
1. 17 error: 
18 return 0;


1. }
2. 21 static int 



check_order(RadixMap 
* map)22 {23  RMElement  
d1,24 int 25  d2; i =  unsigned 0;  
26  // only  

signal errors if any (should not be) 
27 for (i = 0; map-&gt;end &gt; 0 &amp;&amp; i &lt; map-&gt;end -1; i++) { 
28 d1 = map-&gt;contents[i]; 
29 d2 = 
map-&gt;contents[i + 1]; 30 31 if 
(d1.data.key &gt; d2.data.key){ 32 debu 
key: %u, value: %u, equals max? %d\n&quot;, i,33 d1.data.value,34 == UINT32_MAX); 35 retu 0;
36 
}

37 
} 


38 

39 return 1;
40 }
41 
42 static int 

test_search(RadixMap 
* map)43 {44 unsigned i 
= 0;
45 RMElement *d = NULL;
46 RMElement *found = NULL;
47 
48 for (i = 
map-&gt;end / 2; i &lt; map-&gt;end; i++) { 49 d = &amp;map-&gt;contents[i]; 
50 found = RadixMap_find(map, d­&gt;data.key); 
51 check(fo != NULL, &quot;Didn't find %u at %u.&quot;, d­&gt;data.key, i); 
52 check(fo &gt;data.key == d­&gt;data.key,
53 
the wrong result: %p:%u looking for %u at %u&quot;, found,
54 &gt;data.key, d­&gt;data.key, i); 
55 56  }  
57 58  return 1; error:  
59 60 61  }  return 0;  
62  // test for big  

number of elements 
63 static char *test_operations() 
64 {
65 size_t N = 200;
66 
67 RadixMap *map = RadixMap_create(N); 
68 mu_assert(ma != NULL, &quot;Failed to make the map.&quot;); 
69 mu_assert(ma 
&quot;Didn't make a random 
fake radix map.&quot;); 
70 
71 RadixMap_sor 
72 mu_assert(ch 
73 &quot;Fai 

to properly sort the 
RadixMap.&quot;); 
74 
75 mu_assert(te &quot;Failed the search test.&quot;); 
76 mu_assert(ch 
77 &quot;Rad didn't stay sorted after search.&quot;); 
78 
79 while (map­&gt;end &gt; 0) { 
80 RMElemen *el = RadixMap_find(map,
81 &gt;contents[map-&gt;end /2].data.key); 
82 mu_asser != NULL, &quot;Should get a result.&quot;); 
83 
84 size_t old_end = map-&gt;end;
85 
86 mu_asser el) == 0, &quot;Didn't delete it.&quot;); 
87 mu_asser -1 == map-&gt;end, &quot;Wrong size after 
delete.&quot;); 
88 
89 // test that the end is now the old value, 
90 // but uint32 max so it trails off 
91 mu_asser 
92 didn't stay sorted after delete.&quot;); 
93 }94 95 RadixMap_des 
96 

97 return NULL;
98 }
99 100 char *all_tests() 101 {102 mu_suite_sta 103 srand(time(N 104 105 mu_run_test(106 107 return NULL;
108 } 109 110 RUN_TESTS(all_te 
</code></pre>

<p>I shouldn’thave toexplain toomuch about the test. It’s simplysimulating placing random integers into the RadixMap, and then making sureitcan get them out reliably. Not too interesting.</p>

<p>In the radixmap.c file, most ofthe operations are easy to understandif you read the code. Here’sa description
ofwhat thebasic functions are doingand how they work:
RadixMap_create As usual, I&rsquo;mallocatingall ofthe memory needed for the structures definedin radixmap.h. I&rsquo;ll be using the temp and contents later when I talkabout radix_sort.
RadixMap_destroy
Again,I&rsquo;m just destroyingwhat was created.
radix_sort Here’sthe meatof thedata structure,but I&rsquo;ll explain what it’sdoing in thenextsection.
RadixMap_sort Thisuses the radix_sort function toactually sort the contents. Itdoes this by sortingbetween the contents and temp until finally contents is sorted. You’ll seehow this works when I describe radix_sort later.
RadixMap_find This is using abinary search algorithmto find a key you giveit. I’llexplain how this worksshortly.
RadixMap_add Using the RadixMap_sort
function, this will add the keyand value you request at the end,then simply sort itagain so thateverything is in the rightplace. Once everythingis sorted, the RadixMap_find will work properly because it’sa binary search.
RadixMap_delete This
works thesame as
RadixMap_add,</p>

<p>exceptit deletes elements ofthe structure by settingtheir valuesto the max for a unsigned32-bitinteger, UINT32_MAX. This meansthat you can’t use thatvalue as an key value, but it makes deletingelements easy. Simply set it tothat and thensort, andit’ll get moved to the end. Now it’sdeleted.
Studythe codeforthe functions I described. That justleaves RadixMap_sort, radix_sort, and RadixMap_find to understand.
RadixMap_find
and Binary Search</p>

<p>I&rsquo;ll start with howthe binary searchis implemented. Binary search isasimple algorithm thatmost people can understand intuitively. In fact, you could takea deckof playingcards anddo this manually. Here’showthis function works, andhowa binarysearch is done,step by step:
• Set ahighand low mark basedon the size ofthe array.</p>

<p>• Getthe middleelement between thelow and high marks.</p>

<p>• If the key isless-than, thenthe keymustbe below the middle. Set high to one lessthan middle.</p>

<p>• If the key isgreater­than, then thekey must</p>

<p>be above the middle. Setthe lowmark one greater than themiddle.</p>

<p>• If it’sequal, you found it. Stop.</p>

<p>• Keeplooping until low and highpass each other. Youwon’tfindit if you exit the loop.</p>

<p>Whatyou’reeffectively doing is guessing where thekey mightbeby picking the middleand comparing it to the high and lowmarks. Since the dataissorted, you know that the thekey has to be above orbelowyour guess. Ifit’s below, then you justdivided thesearch space in half. Youkeep going until you either find itor you overlapthe boundaries and exhaust the search space.
RadixMap_sort
and radix_sort</p>

<p>A radix sort is easy to understand ifyoutryto do it manually first. Whatthis algorithm does is exploitthe factthat numbers are stored with asequenceof digits that go from least significantto most significant. It then takes the numbers andbuckets them by the digit,and when it has processed allof the digits, the numbers come out sorted. At firstitseems like magic, and honestly, looking at the
codesure seems likeit is,so</p>

<p>try doing itmanuallyonce. To do this algorithm, write outa bunchof three-digit numbers in a random order. Let’s say we do223, 912, 275,100, 633,120, and380.
• Place the number in buckets by the ones digit: [380, 100, 120], [912], [633, 223], [275].</p>

<p>• Inow have to go through eachof these buckets in order,and thensortitby thetens digit: [100],[912], [120, 223], [633],[275], [380].</p>

<p>• Now each bucket contains numbers that are sorted by the ones digit andthen the tens digit. I needto thengo</p>

<p>through thesein order and fillinthe final hundreds digit: [100, 120], [223, 275], [380],[633], [912].</p>

<p>• Atthis pointeach bucket is sorted by hundreds,tens and ones, andif I takeeach bucket in order,I get the finalsortedlist:</p>

<p>100, 120, 223,</p>

<p>275, 380, 633,
912. Make sure youdo thisafew timessoyou understand how it works. Itreallyisa slick little algorithm. Most importantly, it will workon numbers ofarbitrary size,so you can sortreally huge numbers because you’re just doingthem1byte at a time.</p>

<p>Inmy situation, the digits (alsocalled placevalues) are individual8-bit bytes,soI need 256 buckets tostorethe distribution of the numbers by theirdigits. Ialso need a way to storethemsuch thatI don’tusetoo muchspace. If you look at radix_sort, you’ll seethat thefirstthing I do is builda count histogramso Iknow how many occurrences ofeach digit there are for the given offset.</p>

<p>OnceIknow the counts for each digit (all 256 ofthem), I can then use them as distribution pointsintoa target array. For example, if I have10 bytesthat are0x00, thenI know I canplace them in thefirst ten slotsof the target array. This givesme an index for where they goin the target array, which is the second for-loop in radix_sort.</p>

<p>Finally,once I knowwhere theycan go inthe target array I simplygo throughall ofthe digits in the source array for this offset, and place the numbers intheirslots in order. Using the ByteOfmacro helps keep thecode clean, since there’sa bit of pointer hackery tomake it work. However,the end result is thatallof the integers will be placed inthe bucket for their digitwhen
the final for-loop isdone. Whatbecomes interesting is how I use thisin RadixMap_sort to sort these 64-bit integersby just the first32 bits. Remember how I havethe key and value in a unionforthe RMElement type? That meansthat tosort this array by the key, I only need to sort the first4bytes (32 bits/8 bits per byte) of every
integer. If youlookatthe RadixMap_sort, you see thatIgrab aquickpointerto the contents and temp for source and targetarrays, and thenI call radix_sort fourtimes. Each timeI call it, I alternatesourceand target, and do the next byte. When I&rsquo;m done, the radix_sort has done its joband thefinal
copy has been sortedintothe contents.
How to Improve It</p>

<p>There is a bigdisadvantage to this implementation because it has toprocess theentire array fourtimes on every insertion. It doesdo it fast, butit’d be better ifyou could limit theamountof sorting by the size of whatneeds to be sorted.</p>

<p>There aretwo waysyoucan
improve thisimplementation:</p>

<p>• Use a binarysearch to find theminimum position for the new element, thenonly sort fromthereto the end. You find the minimum, putthe newelement on the end, and thenjust sortfromthe minimum on. This will cut your sortspacedown</p>

<p>considerablymostof
the time.</p>

<p>• Keeptrackof the biggest keycurrently being used, andthen only sort enoughdigits to handle that key. You can also keep trackof the smallest number, and then only sort the digits necessary for the range. Todo this, you’ll have tostartcaring</p>

<p>about CPU integer</p>

<p>ordering (endianness). Try theseoptimizations, but only after you augment the unit test with sometiming informationsoyoucansee if you’re actually improvingthe speed of the implementation.</p>

<p>Extra Credit</p>

<p>• Implement quicksort, heapsort, andmerge sortand then provide a</p>

<p>#define thatlets you pickamong thethree, or create a second set of functions you can call. Use the technique I taught you toread the Wikipedia pageforthe algorithm, and then implementitwiththe pseudo-code.</p>

<p>• Compare the performance ofyour optimizations to the</p>

<p>original
implementations.</p>

<p>• Use thesesorting functions to create a</p>

<p>DArray_sort_add</p>

<p>thatadds elements to the DArray but sorts the array afterward.
• Write a DArray_find that uses the binary search algorithmfrom RadixMap_find and the DArray_compare to find elements ina sorted DArray.</p>

<p>Exercise36.
Safer Strings</p>

<p>This exerciseisdesigned to get you using bstring from now on, explain why C’s strings areanincredibly bad idea, andthen have you change the liblcthw code to use bstring.
Why C Strings Were a Horrible Idea</p>

<p>When people talkabout problems with C,they say its concept ofastring isone of the top flaws. You’ve been using these extensively, and I’ve talked about thekindsof flawstheyhave,butthere isn’t much thatexplains exactly why Cstrings are flawed andalways will be. I&rsquo;ll try to explain thatright now,and after decades of using C’s strings, there’s enoughevidence for me to say thatthey arejust abad idea.</p>

<p>It’s impossible to confirm thatany given C stringis valid:
• A C stringis invalid if it doesn’tend in &lsquo;\0&rsquo;.</p>

<p>• Any loop that processes
an invalidCstring will
loop infinitely(or just</p>

<p>create a buffer overflow).</p>

<p>• C strings don’t havea knownlength,sothe only wayto check if they’reterminated correctly is to loop through them.</p>

<p>• Therefore,it isn’t possible to validateaC string withoutpossibly looping infinitely.</p>

<p>This is simple logic. You can’t write aloop thatchecks if a C string is valid because invalidCstringscause loops to never terminate. That’sit, and the only solution isto include the size. Onceyou know thesize, you can avoid the infinite loopproblem. If you look at the two functions I
showed
you
from</p>

<p>Exercise
27,
you
seethis:</p>

<p>ex36.c</p>

<pre><code class="language-c">

1 void copy(char to[], char from[]) 
2 {
3 int i = 0;
4 
5 // while loop will not end if from isn't '\0' terminated 
6 while ((to[i]= from[i]) != '\0'){ 
7 ++i;
8 
}

9 
} 


10 11 int 
safercopy(int from_len, char *from,int to_len, char *to)
12 {
13 int i = 0;
14 int max = from_len &gt; to_len -1 ? to_len -1: from_len;
1. 16 // to_len must have at least 1 byte 
17 if (from_len &lt; 0 || to_len &lt;= 0)
18 return -1;
1. 20 for (i = 0;i &lt; max; i++) { 
21 to[i]= from[i]; 
22 }23 24 to[to_len ­
1] = '\0';25 26 return i;
27 } 
Imagine thatyou want toadd acheck tothe copy function to confirmthat the from string is valid. How would you do that? You’dwrite a loop thatcheckedthat the string ended in '\0'. Oh wait. If the stringdoesn’t end in '\0', thenhowdoes the checkingloopend? Itdoesn’t. Checkmate. 
No matter whatyoudo,you 
can’t check that aCstring is 

valid without knowing the length of the underlying storage, and inthis case,the safercopy includesthose lengths. This function doesn’t havethe same problemsince its loops will always terminate,and evenif you lie to itaboutthe size,youstill haveto giveit afinite size. 

Whatthe Better String Librarydoes iscreate a structure thatalways includes the lengthof thestring’s storage. Because the length is alwaysavailable to a bstring, thenall ofits operations can be safer. The loops will terminate,the contents can bevalidated, and it won’t have this major flaw. The library also comes with a tonof operationsyou need with strings, likesplitting, formatting, andsearching, and they’re most likely done rightand are safer. 


There couldbeflaws in bstring, but it’s been around a long time,sothose are probably minimal. Theystill find flaws in glibc, so what’s a programmerto do, right? 
Using bstrlib 


There arequitea few improvedstring libraries,but I like bstrlib because it fitsin one file for thebasics, and has most of the stuffyou need to deal with strings. In this exercise you’ll needto get two files, bstrlib.c and bstrlib.h,from the Better String Library. 

Here’s me doing this inthe 

liblcthw project directory: 


Exercise 36 Session 


```c

$ mkdir bstrlib $ cd bstrlib/ $ unzip~/Downloads/bstrlib­05122010.zip
Archive: /Users/zeds 05122010.zip ... 
$ ls 
bsafe.c bstr bstrwrap.h lice bsafe.h bstr cpptest.cpp port bstest.c bstrlib.c gpl.txt secu 
$ mv bstrlib.h bstrlib.c ../src/lcthw/$ cd ../ $ rm -rf bstrlib # make the edits $ vim src/lcthw/bstrlib.c$ make clean all 
... 
$ 


On line 14, you seeme edit the bstrlib.c file tomove it toa newlocation and fixa bug on OS X. Here’s the diff file: 

ex36.diff 

```c

25c2. &lt; #include 
&quot;bstrlib.h&quot; 

&gt; #include &lt;lcthw/bstrlib.h&gt;2759c2759 &lt; #ifdef __GNUC__ 
&gt; #if defined(__GNUC__) &amp;&amp; !defined(__APPLE__) 

HereI changethe include to be &lt;lcthw/bstrlib.h&gt;, and then fix oneof the ifdef at line2759. 

Learning the Library 


This exerciseisshort, and it’s meant to simply get you ready for theremaining exercisesthat use theBetter String Library. In the next twoexercises, I'll use bstrlib.c tocreate a hashmap datastructure. 

You should now getfamiliar with this libraryby reading the header file andthe implementations, and then write a 
tests/bstr_tests.c

thattestsout thefollowing functions: 
bfromcstr 

Createa bstring froma C style constant. 
blk2bstr Do the samething, butgive the length of the buffer. 
bstrcpy Copy a 

bstring. bassign Setone bstringto another. 
bassigncstr

Seta bstring to a Cstring’s contents. 
bassignblk
Seta bstring to a Cstring but give the length. 
bdestroy 
Destroy a bstring. 

bconcat 
Concatenateone bstringonto another. 
bstricmp
Comparetwo bstringsreturning the sameresultas strcmp. 
biseq Testif twobstrings are equal. 
binstr Tell if one bstring is in another. 
bfindreplace

Find one bstring in another,then replace it with a third. 
bsplit Splita bstringintoa bstrList. 
bformat Doa format string, 
which is super handy. 
blength Getthe length of a bstring. 
bdata Get the data from a bstring. 
bchar Get a char 

froma bstring. 

Your testshould tryoutallof 

these operations, anda few more that youfind interesting fromthe header file. 

Exercise37. 
Hashmaps 

Hash maps (hashmaps, hashes, orsometimes dictionaries) are used frequently in dynamic programming for storing key/value data. A hashmap works byperforming a hashing calculation on the keys toproduceaninteger, thenusesthat integerto find a bucket to get or set thevalue. It’s averyfast,practical data structure because itworks on nearly anydata andis easy to implement. 

Here’s an exampleof using a hashmap (aka,dictionary) in Python: 

ex37.py 

```c


fruit_weights = 
{'Apples': 10,
'Oranges': 100,
'Grapes': 1.0} 

for key, value in fruit_weights.items(): print key, &quot;=&quot;,value 
Almosteverymodern languagehassomething like this, so many peopleend up writing codeand never understand how thisactually works. By creatingthe Hashmap datastructurein C, I'll show you howthis works. I'll start with the header file so I can talk about the data structure. 
hashmap.h 

```c

#ifndef _lcthw_Hashmap_h #define _lcthw_Hashmap_h #include &lt;stdint.h&gt; #include &lt;lcthw/darray.h&gt; 
#define DEFAULT_NUMBER_OF_BUCK 100 
typedef int (*Hashmap_compare)(void *a, void *b); typedef
uint32_t(*Hashmap_hash (void *key); 
typedef struct 
Hashmap {DArray *buckets;Hashmap_compare
compare;
Hashmap_hashhash;} Hashmap; 
typedef struct 
HashmapNode {void *key;void *data;uint32_t hash;
} HashmapNode; 
typedef int 
(*Hashmap_traverse_cb)(HashmapNode * node); 
Hashmap*Hashmap_create(Hashma compare,Hashmap_hash); 
void 
Hashmap_destroy(Hashma 
* map); 
int 
Hashmap_set(Hashmap * map, void *key, void *data); 
void 
*Hashmap_get(Hashmap 
* map, void *key); 
int 
Hashmap_traverse(Hashm 
* map,Hashmap_traverse_cbtraverse_cb); 
void 
*Hashmap_delete(Hashma 
* map, void *key); 
#endif 

The structureconsists of a Hashmap that contains any number of HashmapNode structs. Looking at Hashmap, youcan seethat it’sstructured likethis: 
DArray *buckets A dynamicarray thatwill be set to a fixed size of 100 buckets. Each bucket will in turn contain a DArray that willhold HashmapNode pairs. 
Hashmap_compare compare This is a comparisonfunction thatthe Hashmap uses to findelementsby their key. Itshould work like all ofthe other compare functions, and it defaults tousing bstrcmp so thatkeys are justbstrings. 
Hashmap_hash hash 

This isthe hashing function, and it’s responsible for takinga key, processing its contents, and producing asingle uint32_t index number. You’ll seethe defaultone soon. 

This almost tellsyou how the 

data is stored, butthe 
buckets DArray hasn’t 

been created yet. Just remember that it’skind of a two-level mapping: 
• Thereare 100buckets thatmake up the first level, andthings are in these buckets basedon their hash. 

• Each bucket is a DArray thatcontains HashmapNode structs thataresimply appendedto the end as they’readded. 



The HashmapNode is then composed of thesethree elements: 
void *key Thekey for this key=value pair. 
void *value The value. 
uint32_thash The calculated hash, which makesfinding this node quicker. We canjust check the hash andskip any that don’tmatch, only checkingthe keyif 
it’sequal. The rest of the header file is nothing new, so now I can showyouthe implementation hashmap.c file: 
hashmap.c 

```c

1 #undef NDEBUG 2 #include &lt;stdint.h&gt; 3 #include 
&lt;lcthw/hashmap.h&gt; 
4 #include &lt;lcthw/dbg.h&gt; 
5 #include &lt;lcthw/bstrlib.h&gt; 
6 
7 static int default_compare(void *a, void *b)
8 {
9 return bstrcmp((bstring) a,(bstring) b); 
10 }
1. 12 /** 
13 * Simple Bob 

Jenkins's hash algorithm taken from the 
14 * wikipedia description. 
15 */ 
16 static uint32_t default_hash(void *a)
17 {
18 size_t len = blength((bstring)a);
19 char *key = bdata((bstring) a); 
20 uint32_t hash = 0; 
21 = 0;22  uint32_t  i  
23 i = {24  0;  i  for (hash = &lt; len; ++i) hash +=  
key[i]; 25  hash  +=  
(hash 26  &lt;&lt;  10);  hash  ^=  
(hash 27 28  &gt;&gt;  6); }  
29  hash  +=  
(hash 30  &lt;&lt;  3); hash  ^=  

(hash 31  &gt;&gt;  11); hash  +=  
(hash 32  &lt;&lt;  15);  
33  return  
hash;34 35  }  
36  Hashmap  

*Hashmap_create(Hashma compare, Hashmap_hash hash)
37 {
38 Hashmap *map = calloc(1,sizeof(Hashmap)); 
39 check_mem(ma 
40 
41 map­&gt;compare = compare == NULL ? default_compare : compare;
42 map-&gt;hash = hash == NULL ? default_hash : hash;
43 map­&gt;buckets = DArray_create(
44 size *),
DEFAULT_NUMBER_OF_BUCK 45 map­&gt;buckets-&gt;end = map­&gt;buckets-&gt;max; // fake out expanding it 
46 check_mem(ma &gt;buckets); 
47 
48 return map;
49 
50 error: 
51 if (map){ 57 58 void 
52 53 54  }  Hashmap_  
55  return  
NULL;56  }  

Hashmap_destroy(Hashma 
* map)59 {60 int i = 0;61 int j = 0;62 63 if (map){ 64 if 
(map-&gt;buckets){ 
65 for (i = 0; i &lt; DArray_count(map­&gt;buckets); i++) { 
66 *bucket = 
DArray_get(map­&gt;buckets, i); 67 (bucket){ 
68 (j = 0; j &lt; DArray_count(bucket); j++) {
69  
j));70  
71. 72. 73 74  }DArr  
&gt;buckets);  

75 
}76 77 free(map

78 
}

79 
}
80 
81 static inline 



HashmapNode*Hashmap_node_create(i hash, void *key,
82 void *data)
83 {
84 HashmapNode 
*node = calloc(1,sizeof(HashmapNode)); 85 check_mem(no 
86 

87 key;88  node-&gt;key = node-&gt;data  
= data;89  node-&gt;hash  
= hash;90  
91  return  
node; 

92 
93 error: 
94 return 
NULL;
95 }96 
97 static inline 

DArray*Hashmap_find_bucket(H 
* map, void *key,98 int 
create,99 uint32_t 
* hash_out)100 {101 uint32_t hash = map­&gt;hash(key); 102 int bucket_n = hash % DEFAULT_NUMBER_OF_BUCK 103 check(bucket &gt;= 0, &quot;Invalid bucket 
found: %d&quot;,bucket_n); 104 // store it for the return so the caller can use it 
105 *hash_out = hash;106 107 DArray *bucket = DArray_get(map­&gt;buckets, bucket_n); 108 109 if (!bucket &amp;&amp; create){ 110 // new 
bucket, set it up 
111 bucket = DArray_create(11. *),
DEFAULT_NUMBER_OF_BUCK 113 check_me 114 DArray_s &gt;buckets, bucket_n,bucket); 
11. }116 117 return bucket;118 119 error: 120 return 

NULL;

12. }
12. 123 int 
Hashmap_set(Hashmap * 
map, void *key, void 
*data)
124 {
125 uint32_t 
hash = 0;
126 DArray 
*bucket = 
Hashmap_find_bucket(ma 
key, 1, &amp;hash); 
127 check(bucket 



&quot;Error can't create bucket.&quot;); 
12. 129 HashmapNode 
*node = 
Hashmap_node_create(ha 
key, data); 
130 check_mem(no 
131 
132 DArray_push(
node); 
133 
134 return 0;
135 
136 error: 
137 return -1;

138 }139 
140 static inline int 
Hashmap_get_node(Hashm 
* 
map, uint32_t hash,141 DArray 

* 
bucket, void *key)142 {143 int i = 0;144 145 for (i = 0;i &lt; DArray_end(bucket); i++) {146 debug(&quot;T %d&quot;, i); 147 HashmapN *node = 


DArray_get(bucket,
i);
148 if 
(node-&gt;hash == hash 
&amp;&amp; map-&gt;compare(node­&gt;key, key) == 0) { 
149 retu 
i;

150 
}

151 
}
152 
153 return -1;


154 
}155 156 void *Hashmap_get(Hashmap 


* map, void *key)
157 {
158 uint32_t 
hash = 0;
159 DArray 
*bucket = 
Hashmap_find_bucket(ma 
key, 0, &amp;hash); 
160 if 
(!bucket) return 
NULL;
161 
162 int i = 
Hashmap_get_node(map,
hash, bucket, key); 
163 if (i == 
-1) return NULL; 

164 

165 HashmapNode *node = DArray_get(bucket,i);166 check(node != NULL,167 &quot;Fai to get node from bucket when it should exist.&quot;); 168 169 return node-&gt;data;170 171 error: 
fallthrough 
172 return NULL;
173 }
174 
175 int 
Hashmap_traverse(Hashm 

* map,
Hashmap_traverse_cb
traverse_cb)
176 {
177 int i = 0;
178 int j = 0;
179 int rc = 0;
180 
181 for (i = 0;
i &lt; DArray_count(map­
&gt;buckets); i++) { 
182 DArray 
*bucket = 
DArray_get(map­&gt;buckets, i); 
183 if 
(bucket){ 
184 for 
(j = 0; j &lt; 
DArray_count(bucket); 
j++) {
185 
*node = 
DArray_get(bucket,
j);
186 

= traverse_cb(node); 
187 
(rc != 0)
188 
rc;

189 
}


190 
}


191 
}
192 
193 return 0;


194 
}
195 
196 void 
*Hashmap_delete(Hashma 



* map, void *key)197 {198 uint32_t 
hash = 0;
199 DArray 
*bucket = 
Hashmap_find_bucket(ma 
key, 0, &amp;hash); 
200 if 
(!bucket)
201 return 
NULL;
202 
203 int i = 
Hashmap_get_node(map,
hash, bucket, key); 
204 if (i == 
-1)
205 return 

NULL;
206 
207 HashmapNode 
*node = 
DArray_get(bucket,
i);
208 void *data 
= node-&gt;data;
209 free(node); 
21. 211 HashmapNode 
*ending = 
DArray_pop(bucket); 
21. 213 if (ending 
!= node){ 
214 // 

alright looks like it's not the last one, swap it 
215 DArray_s i, ending); 
21. }
21. 218 return 
data;


21. } 





There’snothing very complicated inthe implementation,but the default_hash and Hashmap_find_bucket functions will needsome explanation. When you use Hashmap_create, you can pass in anycompare and hash functions you want,but ifyou don’t, ituses the default_compare and default_hash functions. 

The first thing tolook at is how default_hash does its thing. This is asimple hash functioncalled a Jenkins hash after Bob Jenkins. I got the algorithm from the “Jenkins hash” page on Wikipedia. It simplygoes through eachbyte of the key to hash(a bstring), and then it works thebits so thatthe end result is asingle uint32_t. Itdoes this with some adding and exclusive or (XOR) operations. 


There are manydifferent hash functions, all with different properties, butonce you have 
one, you needa wayto use it 
to findthe rightbuckets. The 

Hashmap_find_bucket

does itlike this: 
• First, itcalls map­&gt;hash(key) toget the hashforthe key. 

• Itthen findsthe bucket using hash % DEFAULT_NUMBER_OF 


so every hash will alwaysfind some bucket nomatter how bigit is. 
• Itthen getsthe bucket, which is also a DArray,and ifit’s not there,itwillcreate the bucket. However, that depends onif the create variablesays to doso. 

• Onceit has foundthe DArray bucket for the righthash,itreturns it, and the hash_out 


variableis usedto give the caller the hash that was found. 
Allof theother functions then use 
Hashmap_find_bucket

to do their work: 
• Setting a key/value involvesfinding the bucket,makinga HashmapNode, and thenadding itto the bucket. 

• Getting akey involves finding thebucket, and thenfinding the HashmapNodethat matches the hash and key thatyou want. 

• Deleting an item finds the bucket, finds where the requested nodeis, and then removesit by swappingthe last node into its place. 



The only other functionthat 

you should study is the Hashmap_traverse.This simplywalks throughevery bucket, and for any bucket thathaspossiblevalues, it calls the traverse_cb on each value. Thisis how you scan awhole Hashmap for its values. 

The Unit Test 

Finally,you have the unit test 
to testallof theseoperations: 

hashmap_tests.c 


```c

1 #include 
&quot;minunit.h&quot; 
2 #include 
&lt;lcthw/hashmap.h&gt; 
3 #include 
&lt;assert.h&gt; 
4 #include 
&lt;lcthw/bstrlib.h&gt; 
5 6 Hashmap *map = NULL;7 static int 
traverse_called = 0;
8 struct tagbstring test1 = bsStatic(&quot;test data 1&quot;);
9 struct tagbstring test2 = bsStatic(&quot;test data 2&quot;);
10 struct tagbstring test3 = bsStatic(&quot;xest data 3&quot;);
11 struct tagbstring expect1 = bsStatic(&quot;THE VALUE 1&quot;); 
12 struct tagbstring expect2 = bsStatic(&quot;THE VALUE 2&quot;);
13 struct tagbstring expect3 = bsStatic(&quot;THE VALUE 3&quot;);
1. 15 static int traverse_good_cb(Hashm 
* node)16 {17 debug(&quot;KEY: 
%s&quot;, bdata((bstring)node-&gt;key)); 18 traverse_cal 19 return 0;
20 }
2. 22 static int 

traverse_fail_cb(Hashm 
* node)23 {24 debug(&quot;KEY: 
%s&quot;, bdata((bstring)
node-&gt;key)); 25 traverse_cal 26 27 if 
(traverse_called == 
2) { 
28 return 1;
29 } else {
30 return 0;
31 
}

32 
}
33 
34 char 



*test_create() 
35 {
36 map = Hashmap_create(NULL,NULL); 
37 mu_assert(ma != NULL, &quot;Failed to create map.&quot;); 
38 

39 return NULL;
40 }
41 
42 char 

*test_destroy() 43 {44 Hashmap_dest 45 46 return 
NULL;
47 }
48 
49 char 

*test_get_set() 50 {51 int rc = 
Hashmap_set(map,&amp;test1,&amp;expect1); 
52 mu_assert(rc == 0, &quot;Failed to set &amp;test1&quot;); 
53 bstring result = Hashmap_get(map,&amp;test1); 
54 mu_assert(re == &amp;expect1, &quot;Wrong value for test1.&quot;); 
55 
56 rc = Hashmap_set(map,&amp;test2,&amp;expect2); 
57 mu_assert(rc == 0, &quot;Failed to set test2&quot;); 
58 result = Hashmap_get(map,&amp;test2); 
59 mu_assert(re == &amp;expect2, &quot;Wrong value for test2.&quot;); 
60 
61 rc = Hashmap_set(map,&amp;test3,&amp;expect3); 
62 mu_assert(rc == 0, &quot;Failed to set test3&quot;); 
63 result = Hashmap_get(map,&amp;test3); 
64 mu_assert(re == &amp;expect3, &quot;Wrong 
value 65  for  test3.&quot;);  
66  return  
NULL;67 68  }  
69  char  

*test_traverse() 70 { 
71 int rc = 

Hashmap_traverse(map,traverse_good_cb); 
72 mu_assert(rc == 0, &quot;Failed to traverse.&quot;); 
73 mu_assert(tr == 3, &quot;Wrong count traverse.&quot;); 
74 
75 traverse_cal = 0;
76 rc = Hashmap_traverse(map,traverse_fail_cb); 
77 mu_assert(rc == 1, &quot;Failed to traverse.&quot;); 
78 mu_assert(tr == 2, &quot;Wrong count traverse for fail.&quot;); 
79 
80 return NULL;
81 }
82 
83 char 

*test_delete() 
84 {
85 bstring 
deleted =(bstring)Hashmap_delete(map, &amp;test1); 
86 mu_assert(de != NULL, &quot;Got NULL on delete.&quot;); 
87 mu_assert(de == &amp;expect1, &quot;Should get test1&quot;); 
88 bstring result = Hashmap_get(map,&amp;test1); 
89 mu_assert(re == NULL, &quot;Should delete.&quot;); 
90 
91 deleted = (bstring)Hashmap_delete(map,&amp;test2); 
92 mu_assert(de != NULL, &quot;Got NULL on delete.&quot;); 
93 mu_assert(de == &amp;expect2, &quot;Should get test2&quot;); 
94 result = Hashmap_get(map,&amp;test2); 
95 mu_assert(re == NULL, &quot;Should delete.&quot;); 
96 
97 deleted = 

(bstring)Hashmap_delete(map,&amp;test3); 
98 mu_assert(de != NULL, &quot;Got NULL on delete.&quot;); 
99 mu_assert(de == &amp;expect3, &quot;Should get test3&quot;); 100 result = Hashmap_get(map,&amp;test3); 101 mu_assert(re == NULL, &quot;Should delete.&quot;); 
102 

103 return NULL;
104 
}
105 
106 char 
*all_tests() 
107 {
108 mu_suite_sta 
109 
110 mu_run_test(
111 mu_run_test(
112 mu_run_test(
113 mu_run_test(
114 mu_run_test(
11. 
116 return NULL;

11. }118 119 RUN_TESTS(all_te 
</code></pre>

<p>The only thing tolearnabout this unittestis that at the top I use a feature of bstringto create static stringsto work withinthe tests. I use the tagbstring and bsStatic tocreate them on lines 7–13.
How to Improve It</p>

<p>This is averysimple implementation of Hashmap, asare mostof theother data structures in thisbook. My goalisn’tto give youinsanely great,hyper-speed, well-tuned datastructures. Usually thoseare much too complicated todiscuss and only distractyou from the real, basic data structureat work. My goal is to give you an understandable starting point tothen improveupon or better understand the implementation.</p>

<p>In this case, there aresome things you can dowiththis implementation:
• You can use a sort on each bucket so that they’realways sorted. This increasesyour insert time but decreases yourfind</p>

<p>time,because you can thenusea binary search to findeachnode. Right now,it’s looping through allof thenodes in a bucket justto find one.</p>

<p>• You can dynamically sizethe number of buckets,or letthe caller specify thenumberfor each Hashmap created.</p>

<p>• You can use a better</p>

<p>default_hash. There aretons ofthem.</p>

<p>• This (and nearlyevery Hashmap)is vulnerable tosomeone pickingkeys thatwill fill only onebucket, and thentricking your programintoprocessing them. Thisthen makes your program run slower becauseit changesfrom</p>

<p>processinga Hashmapto effectively processingasingle DArray.If you sort the nodesin the bucket, this helps, but you can also use better hashing functions, and for the really paranoid programmer, add a random salt so thatkeys can’t be predicted.</p>

<p>• You could have it</p>

<p>deletebucketsthat are empty of nodesto save space,or put empty buckets into acache so you can save on time lostcreating and destroyingthem.</p>

<p>• Rightnow, it justadds elements evenif they already exist. Writean alternative set method thatonlyadds an element ifit isn’t set</p>

<p>already. As usual, you shouldgo through eachfunction and makeit bulletproof. The Hashmap could alsousea debug setting fordoing an invariant check.</p>

<p>Extra Credit</p>

<p>• Research the Hashmapimplementation in your favorite programming languageto seewhat features ithas.</p>

<p>• Findoutwhat themajor disadvantages ofa Hashmap are and how to avoid them. For example, it doesn’t preserve order without specialchanges, nor</p>

<p>does itwork when you need tofind things based on partsof keys.</p>

<p>• Write a unit test that demonstrates thedefect offillinga Hashmapwith keys that landin the samebucket, then test how this impacts performance. A good way todo thisisto just reduce the number of buckets to something</p>

<p>stupid, likefive.</p>

<p>Exercise38. Hashmap Algorithms</p>

<p>There arethreehash functions that you’ll implementin this exercise:
FNV-1a Named after the creators Glenn Fowler, Phong Vo, andLandon Curt Noll,this hash
producesgood numbers
and is reasonably fast.</p>

<p>Adler-32 Namedafter Mark Adler, this is a horrible hashalgorithm, butit’s been arounda long time and it’s good for studying.
DJBHash This hash algorithmisattributed to DanJ. Bernstein (DJB),butit’s difficult to findhisdiscussion of
the algorithm. It’s</p>

<p>shown to befast,but
possiblynot great</p>

<p>numbers.</p>

<p>You’vealready seen the Jenkins hash as the default hash forthe Hashmap data structure,sothis exercise will be looking at thesethree new hash functions. The codefor them is usually small,and it’s notoptimized at all. As usual, I&rsquo;m going for understanding
and not blindingspeed. The header fileis very simple, so I&rsquo;ll startwiththat:
hashmap_algos.h</p>

<pre><code class="language-c">
#ifndef hashmap_algos_h #define hashmap_algos_h 
#include &lt;stdint.h&gt; 
uint32_t Hashmap_fnv1a_hash(voi *data); 
uint32_t Hashmap_adler32_hash(v *data); 
uint32_t Hashmap_djb_hash(void *data); 
#endif 
I'm just declaringthe three 
functions I’llimplement in 

the hashmap_algos.cfile: 
hashmap_algos.c 


```c

1 #include 
&lt;lcthw/hashmap_algos.h 
2 #include 
&lt;lcthw/bstrlib.h&gt; 
3 
4 // settings 
taken from 
5 // 
http://www.isthe.com/c 

param 
6 const uint32_t FNV_PRIME = 16777619;
7 const uint32_t FNV_OFFSET_BASIS = 2166136261;
8 
9 uint32_t Hashmap_fnv1a_hash(voi *data)
10 {
11 bstring s = (bstring) data;
12 uint32_t hash = 
FNV_OFFSET_BASIS;
13 int i = 0;
1. 15 for (i = 0;i &lt; blength(s); i++){
16 hash ^= bchare(s, i, 0); 
17 hash *= FNV_PRIME;
18 }
1. 20 return 

hash;
21 }
2. 23 const int 
MOD_ADLER = 65521;24 25 uint32_t 
Hashmap_adler32_hash(v 
*data)26 {27 bstring s = 
(bstring) data;28 uint32_t a 
= 1, b = 0;29 int i = 0;30 31 for (i = 0;
i &lt; blength(s); i++){ 32 a =(a 
+ bchare(s, i, 0)) % 
MOD_ADLER;33 b =(b 
+ a)% MOD_ADLER;
34 }35 36 return (b 
&lt;&lt; 16) | a;
37 }
38 
39 uint32_t 

Hashmap_djb_hash(void 
*data)40 {41 bstring s = 
(bstring) data;42 uint32_t 
hash = 5381;43 int i = 0;44 45 for (i = 0;
i &lt; blength(s); i++){46 hash = ((hash &lt;&lt; 5) + hash)
+ bchare(s, i, 0); /* 
hash * 33 + c */ 
47 }
48 
49 return 

hash; 50 } 

This file, then, has the three hash algorithms. Youshould notice thatI'm justusing a bstring for thekey, but I'm using the bchare function toget acharacter fromthe bstring,but returning0 if that character is outside thestring’s length. 
Each of thesealgorithms are foundonline, so go search for them and read about them. 
Again, I primarily used Wikipedia andthen followed it toother sources. 
I then have a unit test that tests outeach algorithm, but it also tests whether it will distribute well across a number ofbuckets: 
hashmap_algos_tests.c 


```c

1 #include 
&lt;lcthw/bstrlib.h&gt; 
2 #include &lt;lcthw/hashmap.h&gt; 
3 #include &lt;lcthw/hashmap_algos.h 
4 #include &lt;lcthw/darray.h&gt; 
5 #include &quot;minunit.h&quot; 
6 
7 struct tagbstring test1 = bsStatic(&quot;test data 1&quot;);
8 struct tagbstring test2 = bsStatic(&quot;test data 2&quot;);
9 struct tagbstring test3 = bsStatic(&quot;xest data 3&quot;);
1. 11 char *test_fnv1a() 
12 {
13 uint32_t hash = Hashmap_fnv1a_hash(&amp;te 
14 mu_assert(ha != 0, &quot;Bad hash.&quot;); 
1. 16 hash = Hashmap_fnv1a_hash(&amp;te 17 mu_assert(ha 
!= 0, &quot;Bad hash.&quot;); 18 19 hash = 
Hashmap_fnv1a_hash(&amp;te 20 mu_assert(ha 
!= 0, &quot;Bad hash.&quot;); 21 22 return 
NULL;
23 }
2. 25 char 

*test_adler32() 26 {27 uint32_t 
hash = Hashmap_adler32_hash(&amp; 28 mu_assert(ha 
!= 0, &quot;Bad hash.&quot;); 29 30 hash = 
Hashmap_adler32_hash(&amp; 31 mu_assert(ha 
!= 0, &quot;Bad hash.&quot;); 32 33 hash = 
Hashmap_adler32_hash(&amp; 34 mu_assert(ha 
!= 0, &quot;Bad hash.&quot;); 35 36 return 
NULL; 
37 }
38 
39 char 

*test_djb() 40 {41 uint32_t 
hash = Hashmap_djb_hash(&amp;test 42 mu_assert(ha 
!= 0, &quot;Bad hash.&quot;); 43 44 hash = 
Hashmap_djb_hash(&amp;test 45 mu_assert(ha != 0, &quot;Bad hash.&quot;); 46 
47 hash = 

Hashmap_djb_hash(&amp;test 

48 != 0,49  mu_assert(ha &quot;Bad hash.&quot;);  
50  return  
NULL;51 52  }  
53  #define  BUCKETS  
100  
54  #define  

BUFFER_LEN 2. 55 #define NUM_KEYS BUCKETS * 1000 
56 enum { 
ALGO_FNV1A,ALGO_ADLER32,ALGO_DJB }; 
57 
58 int gen_keys(DArray * keys, int num_keys)
59 {
60 int i = 0;
61 FILE *urand = fopen(&quot;/dev/urandom&quot;,&quot;r&quot;);
62 check(urand != NULL, &quot;Failed to open /dev/urandom&quot;); 63 
64 struct bStream *stream = bsopen((bNread)fread, urand); 
65 check(stream != NULL, &quot;Failed to open /dev/urandom&quot;); 
66 
67 bstring key 
i &lt; num_keys; i++) { 

= bfromcstr(&quot;&quot;); 68 int rc 69  =  0;  
70  //  FNV1a  
histogram 71  for (i  =  0;  

72 rc = 

bsread(key, stream,BUFFER_LEN); 
73 check(rc &gt;= 0, &quot;Failed to read from /dev/urandom.&quot;); 
74 
75 DArray_pbstrcpy(key)); 
76 77  }  
78 79 80 81  bsclose(stre fclose(urand return 0;  
82  error:  

83 return -1;
84 }
85 
86 void 

destroy_keys(DArray * 
keys)87 {88 int i = 0;89 for (i = 0;
i &lt; NUM_KEYS; i++) { 90 bdestroyi));
91 
}92 93 DArray_destr 

94 
}
95 



96 void 

fill_distribution(int *stats, DArray * keys,
97 Hashmap_ 
hash_func)98 {99 int i = 0;
100 uint32_t 
hash = 0;
101 
102 for (i = 0;
i &lt; 
DArray_count(keys); 
i++) {
103 hash = 

hash_func(DArray_get(k i));104 stats[ha % BUCKETS] += 1;
105 
}
106 


107 
}
108 
109 char 
*test_distribution() 
110 {
111 int i = 0;
112 int 
stats[3][BUCKETS]={



{0} };
113 DArray *keys = 
DArray_create(0,
NUM_KEYS); 
11. 115 mu_assert(ge 
NUM_KEYS) == 0,
116 &quot;Fai 
to generate random 
keys.&quot;); 
11. 118 fill_distrib 
keys,
Hashmap_fnv1a_hash); 
119 fill_distrib 
keys,
Hashmap_adler32_hash);
120 fill_distrib 

keys,
Hashmap_djb_hash); 
12. 122 fprintf(stde 
&quot;FNV\tA32\tDJB\n&quot;); 
12. 124 for (i = 0;
i &lt; BUCKETS; i++) { 
125 fprintf(
&quot;%d\t%d\t%d\n&quot;,
12. [i],
12. [i], stats[ALGO_DJB]
[i]);

12. }12. 130 destroy_keys 131 132 return NULL;

133 
}
134 
135 char 
*all_tests() 
136 {
137 mu_suite_sta 
138 
139 mu_run_test(
140 mu_run_test(
141 mu_run_test(
142 mu_run_test(
143 


144 return NULL;

145 
}146 147 RUN_TESTS(all_te 
</code></pre>

<p>I havethe number of BUCKETS inthis codeset fairlyhigh, sinceI have a fast enoughcomputer,butif it runs slow, justlower it and NUM_KEYS. Whatthis test lets me do isrunthe test and thenlook at the distribution ofkeys for each hashfunction
using abit of analysiswitha</p>

<p>languagecalled R. I dothis bycraftinga big list ofkeys using the gen_keys function. Thesekeys are takenoutof the /dev/urandom device and are random byte keys. I then use these keysto havethe
fill_distribution function fill upthe stats array with where those keys wouldhash in a theoretical set of buckets. All this function doesisgo through all ofthe keys, dothe hash, thendo what the Hashmapwoulddo to finditsbucket.</p>

<p>Finally,I&rsquo;m simplyprinting outa three-column tablewith the finalcountforeach bucket, showinghowmany keys managed to getintoeach bucket randomly. Ican then look at these numbers tosee if thehash functions are distributing keysevenly.</p>

<p>What You Should See
Teaching you Ris outside the scope of this book, but ifyou wantto getitand try this, it can
be
found
at
www.r­
project.org.</p>

<p>Hereis anabbreviated shell session that showsme running
tests/hashmap_algos_t</p>

<p>to getthe tableproduced by test_distribution (not shown here), and then using R to seewhatthe summary statisticsare.</p>

<p>Exercise 38 Session</p>

<pre><code class="language-c">
$ 
tests/hashmap_algos_te # copy-paste the table it prints out $ vim hash.txt 
$R 
&gt; hash &lt;­read.table(&quot;hash.txt&quot;,
header=T)
&gt; summary(hash)

FNV A Min. : 945 Min. : 
908.0 Min. : 92. 1st Qu.: 980 1st Qu.: 980.8 1st Qu.: 979 
Median : 998 Median :1000.0 Median : 
998 

Mean :1000 Mean 
3rd Qu.:1016 3rd 
Qu.:1019.2 3rd 
Qu.:102. Max. :1072 Max. 
&gt; 

First, I justrunthe test, which on your screen will printthe table. Then, Ijust copy-paste it out ofmy terminal and use vim hash.txt to save the data. If youlookatthe data, it has the header FNV A32 DJB for each ofthe three 
algorithms. Secondly, I run R and load the datausingthe read.table command. This is asmartfunction that works with thiskind oftab­delimited data, andI only haveto tell it header=T for 
it toknow thatthe data has a header. Finally,Ihave thedata 
loaded andcanuse summaryto print outitssummary 
statisticsforeach column. Hereyou cansee that each function actuallydoes alright with this randomdata. Here’s whateach oftheserows means: 
Min. This isthe minimum valuefound forthe data in that column. FNV-la seems to win onthis run since ithas the largest number, meaningit has atighter 
range at the low end. 

1stQu. This is thepoint where the firstquarter ofthe data ends. 
Median This is the number that’s in the middleif you sorted them. Medianismost useful when compared to mean. 
Mean Meanisthe average most people think of, and it’s the sum divided 
by thecount ofthe data. If youlook, allof them are 1,000, which is great. If you compare this tothe median, you seethat allthree have really close mediansto the mean. Whatthis meansis the data isn’t skewedin one direction, so youcan trust the mean. 
3rd Qu. Thisis the point 

where the lastquarter of the datastarts and representsthe tail end ofthe numbers. 
Max. Thisisthe maximumnumberof the data, and presents the upperbound on all ofthem. 
Lookingatthis data, you see thatall of thesehashes seem to do wellon random keys, and the means matchthe NUM_KEYS setting that I made. What I'mlookingfor is this:If Imake 1,000 keys perbucket(BUCKETS × 1000), then onaverageeach bucket shouldhave 1,000 keys init. If thehash function isn’t working, then you’llsee these summary statistics show amean that’s not 1,000, and really high ranges at thefirst and third quarters. A good hash functionshould havea dead-on1,000mean, andas 
tight a range aspossible. You should alsoknow that you’ll get different numbers frommine, and even between differentruns of thisunittest. 
How to Break It 
I'm finally goingto haveyou do some breaking inthis exercise. Iwantyou towrite the worsthash function you can,and then use the datato prove that it’sreallybad. You can use R to dothe statistics, justlike I did,butmaybeyou haveanother tool thatyoucan use to give you the same summary statistics. 

The goalis to makea hash function that seems normal to an untrained eye, but when actually run, it has a bad meanand is all over the place. That means youcan’t justhave it return 1. You haveto givea stream of numbers thatseem alrightbut aren’t, andthey’re loading up somebucketstoo much. 
Extrapoints if you can make aminimal changeto oneof the four hash algorithms thatI 
gaveyou todo this. The purposeof thisexercise is to imagine thatsome friendly coder comes to you and offers to improveyour hash function, but actually justmakes a nice little back 
door that really screwsup your Hashmap. As the Royal Society says, 
“Nullius in verba.” 

Extra Credit 

• Take the default_hash out ofthe hashmap.c, makeit one of the algorithmsin hashmap_algos.c, and then make all ofthe tests work again. 

• Add the default_hash to the hashmap_algos_tes


test andcompare its 

statisticsto the other 
hash functions. 

• Finda few more hash functions andadd them, too. You can never have toomany hash functions! 

Exercise39. String Algorithms 

In this exercise,I'm going to showyoua supposedly faster string search algorithm, called binstr, and compare it tothe one that exists in bstrlib.c. The documentationfor binstr says thatitusesa simple “brute force” string search to find thefirstinstance. The onethat I'll implement will use the Boyer-Moore-Horspool (BMH) algorithm, which is supposed tobe faster if you analyze thetheoretical time. Assumingmy implementation isn’t flawed, you’ll seethat thepractical time for BMHis muchworse thanthe simple bruteforceof binstr. 

The point of this exercise isn’t really to explain the algorithm,because it’ssimple enoughforyouto readthe “Boyer-Moore-Horspool algorithm” page on Wikipedia. Thegist ofthis algorithm isthat itcalculates a skip characters list asafirst operation, thenit uses this list to quickly scan throughthe string. It’s supposed tobe faster thanbrute force,so 
let’sget the code into the rightfiles andsee. First, I havethe header: 
string_algos.h 

```c

#ifndef string_algos_h #define string_algos_h 
#include 
&lt;lcthw/bstrlib.h&gt; 
#include &lt;lcthw/darray.h&gt; 
typedef struct 

StringScanner {bstring in;const unsigned 
char *haystack;ssize_t hlen;const unsigned 
char *needle;ssize_t nlen;size_t 
skip_chars[UCHAR_MAX + 1]; } StringScanner; 
int 

String_find(bstring in, bstring what); 

StringScanner*StringScanner_create(in); 
int 

StringScanner_scan(Str 
* scan, bstring tofind); 
void 

StringScanner_destroy(
* scan); 
#endif 


Inorder to see the effects of this skip characters list,I'm goingto maketwo versions ofthe BMH algorithm: 

String_find Thissimply finds the firstinstance ofone string inanother, doing the entire algorithmin oneshot. 

StringScanner_scan This uses a 

StringScanner
state structure to separatethe skiplist build from theactual find. This willlet me seewhat impactthat has on performance. This model alsogives me theadvantage of incrementally scanning for onestring in another and quickly findingall instances. 


Onceyou have that, here’s the implementation: 
string_algos.c 


```c

1 #include &lt;lcthw/string_algos.h&gt; 2 #include &lt;limits.h&gt; 
3 4 static inline void 

String_setup_skip_char 
* skip_chars,5 const 
unsigned char *needle,
6 ssize_t nlen)
7 {
8 size_t i = 0;
9 size_t last = nlen -1;
1. 11 for (i = 0;i &lt; UCHAR_MAX + 1;i++) {
12 skip_cha = nlen;
13 }
1. 15 for (i = 0;

i &lt; last; i++) { 16 skip_cha = last -i;
1. }

1. }
1. 20 static inline 



const unsigned char *String_base_search(co unsigned
21 char *haystack, 
22 ssize_t hlen,
23 const unsigned
24 char *needle,
25 ssize_t nlen,
26 size_t * 
27 skip_cha 28 {29 size_t i = 
0;
30 size_t last = nlen -1. 31 

32 assert(hayst != NULL &amp;&amp; &quot;Given bad haystack to search.&quot;); 
33 assert(needl != NULL &amp;&amp; &quot;Given bad needle to search for.&quot;); 
34 
35 check(nlen &gt; 0, &quot;nlen can't be &lt;= 0&quot;); 
36 check(hlen &gt; 0, &quot;hlen can't be &lt;= 0&quot;); 
37 

38 while (hlen &gt;= nlen){ 
39 for (i = last; haystack[i]
== needle[i]; 40  i--) { if  
(i == 41  0) {  
haystack;42 43 44  }  }  
45  hlen  -=  

skip_chars[haystack[la 
46 haystack 

+= 
skip_chars[haystack[la 
47 }
48 
49 error: 

fallthrough 
50 return NULL;
51 }
52 
53 int 


String_find(bstring 
in, bstring what)54 {55 const 
unsigned char *found 
= NULL;
56 
57 const unsigned char *haystack = (const unsigned char *)bdata(in); 
58 ssize_t hlen = blength(in); 
59 const unsigned char *needle = (const unsigned char *)bdata(what); 
60 ssize_t nlen = blength(what); 
61 size_t 
skip_chars[UCHAR_MAX 
+ 1] = { 0 }; 
62 
63 String_setupneedle, nlen); 
64 
65 found = String_base_search(hayhlen,
66 nlen, skip_chars); 
67 
68 return found != NULL ? found -haystack : -1;
69 } 
70 

71 StringScanner *StringScanner_create(in)

72 {
73 StringScanne *scan = calloc(1,sizeof(StringScanner)) 
unsigned char 
74 75  check_mem(sc  
76  scan-&gt;in  =  
in;77  scan­ 
&gt;haystack  =  (const  

*)bdata(in); 

78 scan-&gt;hlen 
= blength(in); 79 80 assert(scan 
!= NULL &amp;&amp; &quot;fuck&quot;); 81 return 
scan;82 83 error: 84 free(scan); 85 return 
NULL;
86 }87 88 static inline 
void 

StringScanner_set_need 
* scan,89 bstring 
tofind)
90 {
91 scan­
&gt;needle = (const unsigned char 
*)bdata(tofind); 
92 scan-&gt;nlen = blength(tofind); 
93 
94 String_setup&gt;skip_chars, scan­&gt;needle, scan-&gt;nlen); 
95 } 
96 
97 static inline void StringScanner_reset(St 
* scan)98 {99 scan­
&gt;haystack = (const unsigned char 
*)bdata(scan-&gt;in); 100 scan-&gt;hlen = blength(scan-&gt;in); 
101 }102 103 int StringScanner_scan(Str * scan, bstring tofind)104 {105 const unsigned char *found = NULL;106 ssize_t found_at = 0;107 108 if (scan­&gt;hlen &lt;= 0) { 109 StringSc 110 return -1;
111 }11. 113 if ((const unsigned char 
*)bdata(tofind) != scan-&gt;needle){ 114 StringSc tofind); 
115 }
11. 117 found = 

String_base_search(sca 
&gt;haystack, scan­&gt;hlen,
118 scan 
&gt;needle, scan-&gt;nlen,
119 scan 
&gt;skip_chars); 

12. 121 if (found){
122 found_at = found -(const unsigned char 
*)bdata(scan-&gt;in); 123 scan­&gt;haystack = found + scan-&gt;nlen;124 scan­&gt;hlen -= found_at ­scan-&gt;nlen;
125 } else {126 // done, reset the setup 
127 StringSc 128 found_at 
= -1;
12. }
130 
131 return 
found_at;


132 
}
133 
134 void 

StringScanner_destroy(



* scan)
135 {
136 if (scan){ 
137 free(sca 

138 
} 


139 
} 



The entire algorithm isin two static inline functions called 

String_setup_skip_cha 

and String_base_search. Theseare thenused in the other functions toactually implementthe searching styles Iwant. Study these first twofunctions and compare them to theWikipedia 
description so that you know 

what’s goingon. The String_find then just uses these two functions to do afind and return theposition found. It’s very simple, and I'll use ittosee how this build skip_chars phase impacts real, practical performance. Keep inmind thatyou couldmaybemake this faster, but I'm teaching you howto confirm 
theoretical speed after you implementanalgorithm. The 

StringScanner_scan
function then follows the common patternI use of create, scan, and destroy,and is used toincrementallyscan astring for another string. You’ll seehow this isused when I show youthe unit test thatwilltestthis out. 

Finally,Ihave theunittest thatfirstconfirms thatthis is all working, then it runs simple performance tests for all three,finding algorithms in a commented out section. 
string_algos_tests.c 


```c

1 #include &quot;minunit.h&quot; 2 #include &lt;lcthw/string_algos.h&gt; 3 #include 
&lt;lcthw/bstrlib.h&gt; 
4 #include &lt;time.h&gt; 
5 
6 struct tagbstring IN_STR = bsStatic(
7 &quot;I have ALPHA beta ALPHA and oranges ALPHA&quot;); 
8 struct tagbstring ALPHA = bsStatic(&quot;ALPHA&quot;); 
9 const int TEST_TIME = 1;1. 11 char 

*test_find_and_scan() 
12 {
13 StringScanne *scan = StringScanner_create(&amp; 
14 mu_assert(sc != NULL, &quot;Failed to make the scanner.&quot;); 
1. 16 int find_i = String_find(&amp;IN_STR,&amp;ALPHA); 
17 mu_assert(fi &gt; 0, &quot;Failed to find 'ALPHA' in test 
string.&quot;); 
1. 19 int scan_i = StringScanner_scan(sca &amp;ALPHA); 
20 mu_assert(sc &gt; 0, &quot;Failed to find 'ALPHA' with scan.&quot;); 
21 mu_assert(sc == find_i, &quot;find and scan don't match&quot;); 
2. 23 scan_i = StringScanner_scan(sca &amp;ALPHA); 
24 mu_assert(sc &gt; find_i,
25 &quot;sho find another ALPHA after the first&quot;); 
2. 27 scan_i = StringScanner_scan(sca &amp;ALPHA); 
28 mu_assert(sc &gt; find_i,
29 &quot;sho find another ALPHA after the first&quot;); 
30 
31 mu_assert(St &amp;ALPHA) == -1, 32 &quot;sho 
find it&quot;); 33 34 StringScanne 35 36 return 
NULL;
37 }
38 
39 char 

*test_binstr_performan 40 {41 int i = 0;42 int found_at = 0;
43 unsigned long find_count = 0;
44 time_t elapsed = 0;
45 time_t start = time(NULL); 
46 
47 do {
48 for (i = 0; i &lt; 1000; i++) { 
49 foun = binstr(&amp;IN_STR, 0,&amp;ALPHA); 
50 mu_a != BSTR_ERR, &quot;Failed to find!&quot;); 
51 find 
52 }53 54 elapsed 
= time(NULL)-start;
55 } while (elapsed &lt;= TEST_TIME); 
56 
57 debug(&quot;BINST COUNT: %lu, END TIME: %d, OPS: %f&quot;,
58 find (int)elapsed,(double)find_count /elapsed); 
59 return NULL;
60 }
61 
62 char 

*test_find_performance 63 {64 int i = 0;65 int 
found_at = 0;66 unsigned long find_count = 0;67 time_t elapsed = 0;68 time_t start = time(NULL); 
69 

70 do {
71 for (i = 0; i &lt; 1000; i++) { 
72 foun = String_find(&amp;IN_STR,&amp;ALPHA); 
73 find 
74 }75 76 elapsed 
= time(NULL)-start;
77 } while (elapsed &lt;= TEST_TIME); 
78 

79 debug(&quot;FIND COUNT: %lu, END TIME: %d, OPS: %f&quot;,
80 find (int)elapsed,(double)find_count /elapsed); 
81. 82  return  
NULL;83 84  }  
85  char  

*test_scan_performance 86 { 
87 int i = 0;88 int found_at = 0;89 unsigned long find_count = 0;90 time_t elapsed = 0;
91 StringScanne *scan = StringScanner_create(&amp; 
92 
93 time_t 

start = time(NULL); 94 95 do {96 for (i 
= 0; i &lt; 1000; i++) { 
97 foun = 0;
98 
99 do {
100 
= 

StringScanner_scan(sca &amp;ALPHA); 101 
102 
}while (found_at != -1);

103 
}104 

105 elapsed = time(NULL)-start;

106 
} while 
(elapsed &lt;= 
TEST_TIME); 
107 
108 debug(&quot;SCAN 
COUNT: %lu, END TIME: 
%d, OPS: %f&quot;,
109 find 
(int)elapsed,
(double)find_count /
elapsed); 
11. 111 StringScanne 
11. 
113 return NULL;

11. }115 116 char *all_tests() 117 {118 mu_suite_sta 119 120 mu_run_test(121 122 // this is an idiom for commenting out sections of code 123 #if 0 


124 mu_run_test( 
125 mu_run_test( 
126 mu_run_test( 
127 #endif 
12. 129 return 
NULL;

130 }131 132 RUN_TESTS(all_te 
</code></pre>

<p>I haveit writtenhere with #if 0,which isa way to use the CPPto comment outa section ofcode. Type it in likethis,and then removeit and the #endif so thatyou can seethese performance tests run. Asyoucontinue with the book, simply comment these out so thatthe test doesn’twaste development time.</p>

<p>There’snothing amazing in this unittest; it justruns each ofthe differentfunctionsin loops thatlastlong enoughto get a fewseconds of sampling. Thefirsttest (test_find_and_scan) justconfirmsthatwhat I’ve writtenworks,because there’s nopoint in testingthe speed of something that doesn’twork. Then,the next three functions run alarge number ofsearches,using each ofthe three functions.</p>

<p>The trick to notice is that I grab the starting time in start,and then I loop until at least TEST_TIME seconds havepassed. This makes sure thatIget enough samplesto work with while comparing the three. I&rsquo;ll then run this test with different TEST_TIME settings andanalyze the results.</p>

<p>What You Should See</p>

<p>When I run thisteston my laptop, I getnumbersthat look likethis:</p>

<p>Exercise 39.1 Session</p>

<pre><code class="language-c">
$ 
./tests/string_algos_t 
DEBUG tests/string_algos_tes -----RUNNING: 
./tests/string_alg 
RUNNING: ./tests/string_algos_t DEBUG tests/string_algos_tes test_find_and_scan DEBUG tests/string_algos_tes 
test_scan_performance DEBUG tests/string_algos_tes SCAN COUNT:\ 
110272000, END TIME: 2, OPS: 55136000.000000 DEBUG tests/string_algos_tes 
test_find_performance DEBUG tests/string_algos_tes FIND COUNT:\ 
12710000, END TIME: 2, OPS: 6355000.000000 DEBUG tests/string_algos_tes 
test_binstr_performanc DEBUG tests/string_algos_tes BINSTR COUNT:\ 
72736000, END TIME: 2, OPS: 36368000.000000 ALL TESTS PASSED 
Tests run: 4 

$ 

I look at thisand Iwant todo more than 2 secondsfor each run. I wantto run this many times, and thenuseRto check itoutlike I did before. Here’s whatI get for ten samplesfor about 10seconds each: 
scan find binstr 71195200 6353700 37110200 75098000 37420800 74910000 37263600 74859600 37133200 73345600 37549700 74754400 37162400 75343600 37075000 73804800 36858700 74995200 36811700 74781200 
6358400 6351300 6586100 6365200 6358000 6630400 6439900 6384300 6449500 
37383000 


The way Igot this isusing a little bitof shellhelp, and thenediting theoutput: 


Exercise 39.2 Session 

```c

$ for i in 12345 6789 1. &gt; do echo &quot;RUN --­
$i&quot; &gt;&gt; times.log 
&gt; 

./tests/string_algos_t 2&gt;&amp;1 | grep COUNT &gt;&gt; times.log
&gt; done $ less times.log $ vim times.log 
Right away, you can see that the scanningsystembeats the pantsoffboth ofthe others, butI’ll open this inRand confirmtheresults: 


Exercise 39.3 Session 

```c

&gt; times &lt;­read.table(&quot;times.log&quot; header=T)&gt; summary(times)
scan Min. :71195200 Mi 1st 
Qu.:74042200 1st Qu.:6358100 1st Qu.:37083800 
Median 
:74820400  Median  
:6374750  Median  
:37147800  
Mean  :74308760  Me  
3rd  
Qu.:74973900  3rd  
Qu.:6447100  3rd  
Qu.:37353150  
Max.  :75343600  Ma  
&gt;  

To understand why I'm getting the summary statistics, I have to explain somestatistics for you. What I'm lookingforin these numbers issimply this: “Are these three functions (scan, find, bsinter) actually different?” Iknow thateach time I run my tester function, I getslightly different numbers,and thosenumbers can cover a certain range. You seehere thatthe first and third quarters dothat for each sample.

What I look at first is the mean, and I want to see if each sample’s mean is differentfrom theothers. I can seethat, andclearlythe scan beats binstr, which also beats find. However,I havea problem. If I use just the mean, there’s a chance thatthe ranges ofeach sample mightoverlap.

What if I have meansthat are different, but the firstand third quarters overlap? In that case, Icouldsaythat ifI ran the samples again there’s a chancethat themeans might notbe different. The more overlapI have inthe ranges, the higher probability that my twosamples(andmy two functions)are not actually different. Any difference that I'm seeing in thetwo (in this casethree) is just random chance. 


There are manytoolsthat you 
can use to solve thisproblem, 

butin our case, Icanjust look at the firstand third quarters and the meanforall three samples. If themeans are different, andthe quartersare way offwithno possibility of overlapping,thenit’s alright to say that theyare different. 

Inmy three samples,I can say that scan, find, and binstr are different,don’t overlapin range,and I can trust the sample (for the most 
part). 

Analyzing the Results 

Lookingatthe results,I can seethat String_find is much slower than the other two. In fact, it’s so slow that I’d think there’ssomething wrongwithhowI implemented it. However, when I compareit to StringScanner_scan,I can seethat it’s most likely the part that builds theskip list that’s costingthe time. Notonly is find slower,it’s also doing less than scan because it’s justfinding the first stringwhile scan finds all ofthem. 
I can alsosee that scan beats binstr, as well,and by quite alargemargin. Again, notonly does scan domore thanboth ofthese, but it’s also much faster. 


There area few caveats with this analysis: 
• Imay havemessed up this implementation or the test. Atthis point I would go research all of the possibleways to do aBMH algorithm and tryto improveit. I would alsoconfirm that I'm doing the test right. 

• If you alterthe time the test runs,you’llget 

differentresults. There isawarm-up period thatI'm not investigating. 

• The test_scan_perform unit test isn’t quite the same asthe others, but it’sdoing more than the other tests, so it’s probably alright.
• I'monlydoing thetest by searching for one string inanother. I could randomize the strings tofind their position and lengthas a confoundingfactor.

• Maybe binstr is implemented better than simple brute force. 

• Icouldberunning these in an unfortunateorder. Mayberandomizing which test runs first will givebetter results. 



Onething to gatherfrom this is thatyou need to confirm realperformanceeven ifyou implementanalgorithm correctly. In this case, the claim isthat theBMH algorithm should havebeaten the binstr algorithm, buta simple test proved it didn’t. Had Inotdone this,Iwould havebeen using an inferior algorithm implementation without knowing it. With these metrics, I canstart to tunemy implementation, or simplyscrap it andfind anotherone. 

Extra Credit 

• Seeif you can make the Scan_find faster. Why ismy implementation here slow? 

• Trysome different scan timesand see if you get differentnumbers. 


Whatimpact does the length of time thatyou run the testhave on the scan times?Whatcan you say about that result? 

• Alter theunittest so thatitrunseach function for a short burst in thebeginning to clearoutany warm-up period,and then start the timing portion. 

Does that change the dependenceon the length of time the test runs? Does itchange how many operations persecond arepossible? 

• Makethe unit test randomize thestrings to find andthen measure the performance you get. Oneway to do this isto use the bsplitfunction from bstrlib.h tosplit the IN_STR on spaces. Then, youcan use the bstrList struct that you get toaccess each string itreturns. This willalso teach you how to use bstrList operations for string processing.

• Trysome runs with the tests in different orders to see if you get 

differentresults. 

Exercise40. Binary Search Trees 

The binarytree is the simplest tree-baseddata structure,and even though it’s been replaced byhash maps in many languages, it’s still useful for many applications. Variants on the binary tree existforveryusefulthings likedatabase indexes, search algorithm structures, and even graphics. 
I'm callingmy binary treea BSTree for binary search tree, andthe best wayto describe it is that it’s another way to do a Hashmap style key/value store. The difference is thatinsteadof hashing thekey tofind a location, the BSTree comparesthe key tonodesin atree, and then walksthrough the tree to find thebest place to store it, based on howit comparesto other nodes. 
Before I reallyexplain how this works, letme show you the bstree.h headerfile so thatyou cansee thedata structures,and thenI can use thatto explain how it’s built. 
bstree.h 


```c

#ifndef _lcthw_BSTree_h #define _lcthw_BSTree_h 
typedef int (*BSTree_compare)(void *a, void *b); 
typedef struct 
BSTreeNode {void *key;void *data; 
struct BSTreeNode *left;
struct BSTreeNode *right;
struct BSTreeNode *parent;} BSTreeNode; 
typedef struct BSTree 
{ 
int count;
BSTree_comparecompare;
BSTreeNode *root;} BSTree; 
typedef int 
(*BSTree_traverse_cb)(BSTreeNode * node); 
BSTree *BSTree_create(BSTree_ compare); 
void 
BSTree_destroy(BSTree 
* map); 
int BSTree_set(BSTree 
* map, void *key,
void *data); 
void 

*BSTree_get(BSTree * map, void *key); 
int 

BSTree_traverse(BSTree 
* map,BSTree_traverse_cb traverse_cb); 
void 
*BSTree_delete(BSTree 
* map, void *key); 
#endif 

This followsthe same pattern thatI’vebeen using this whole time where I havea base container named BSTree, which has nodes named BSTreeNode that makeup theactual contents. Bored yet?Good, there’sno reason to be clever with this kind ofstructure. 

The importantthing is how the BSTreeNode is configured,and how it gets used todo each operation: set, get, and delete.I'll cover get first since it’s the easiest operation, andI’ll pretendI'm doingitmanually against the datastructure: 
• Itake the keyyou’re looking for andI startat the root. Firstthing I do iscompareyour key with thatnode’s key. 

• If your key isless than the node.key, then I traverse downthe tree using the left pointer. 

• If your key isgreater 


thanthe node.key, thenI go downwith right. 

• Irepeat steps2and 3 until I eitherfinda matching node.key or get toa node that has no leftand right. In the first case, Ireturn the node.data. In the second, Ireturn NULL. 


That’s allthereis to get, so 
now on to set. It’s nearly the 

same thing, except you’re looking for where toputa new node: 
• If there isno BSTree.root, then I justmake itand we’re done. That’s the first node. 

• Afterthat, I compare your key to node.key, startingat the root. 

• If your key isless than 

orequal tothe node.key, thenI wantto goleft. If your key is greaterthan and notequaltothe node.key, thenI wantto goright. 

• Ikeep repeating step 3 until I reach anode where leftor right doesn’texist,butthat’s the direction Ineed to go. 

• Oncethere, Isetthat direction (left or right) to a newnode forthe key and data Iwant, and then set thisnew node’s parentto the previous nodeI came from. I’llusethe parent node whenI do delete. 



This also makes sense given 
how get works. Iffindinga 
node involvesgoing left or 

rightdepending on how the key compares,thensettinga node involvesthe same thing until I cansettheleftor right for anew node. 
Take sometime todrawouta fewtrees on paperand go through settingand getting nodessoyou understand how this works. After that, you’re ready to look atthe implementation,and I can explain delete. Deleting in 
trees is a major pain, and so 
it’sbest explainedby doinga 
line-by-line code breakdown. 

bstree.c 

```c

1 #include &lt;lcthw/dbg.h&gt; 
2 #include &lt;lcthw/bstree.h&gt; 3 #include 
&lt;stdlib.h&gt; 4 #include &lt;lcthw/bstrlib.h&gt; 
5 
6 static int default_compare(void *a, void *b)
7 {
8 return bstrcmp((bstring) a,(bstring) b); 
9 }
1. 11 BSTree 

*BSTree_create(BSTree_ 
compare)12 {13 BSTree *map = calloc(1,
sizeof(BSTree)); 14 check_mem(ma 15 16 map­
&gt;compare = compare == NULL ? 
default_compare : 
compare;17 18 return map;19 20 error: 21 if (map){ 22 BSTree_d 
23 } 
24 return NULL;
25 }
2. 27 static int 

BSTree_destroy_cb(BSTr 
* node)28 {29 free(node); 30 return 0;
31 }
32 
33 void 

BSTree_destroy(BSTree 
* map)34 { 
35 if (map){ 36 BSTree_t BSTree_destroy_cb); 37 free(map
38 
}

39 
}
40 
41 static inline 



BSTreeNode *BSTreeNode_create(BST 
* parent,42 void 
*key, void *data)43 {44 BSTreeNode 
*node = calloc(1. sizeof(BSTreeNode)); 

51 
45 46  check_mem(no  
47 key;48  node-&gt;key = node-&gt;data  
= data;49  node­ 
&gt;parent 50  =  parent;return  
node;  

52 error: 
53 return NULL;
54 } 55 
56 static inline void BSTree_setnode(BSTree * map, BSTreeNode * node,
57 void *key, void *data)
58 {
59 int cmp = map-&gt;compare(node­&gt;key, key); 
60 
61 if (cmp &lt;= 
0) {62 if 
(node-&gt;left){ 
63 BSTr node-&gt;left, key,data); 
64 } else {
65 node &gt;left = BSTreeNode_create(node key, data); 
66 
}

67 
} else {68 if (node-&gt;right){ 


69 BSTr node-&gt;right, key, data); 
70 } else {
71 node &gt;right = BSTreeNode_create(node key, data); 
72 
}

73 
}

74 
}
75 
76 int 



BSTree_set(BSTree * map, void *key, void *data)
77 { 
78 if (map­&gt;root == NULL){ 
79 // first so just make it and get out 
80 map­&gt;root = BSTreeNode_create(NULL key, data); 
81 check_mem &gt;root); 
82 } else {
83 BSTree_se map-&gt;root, key,data); 
84 } 
85 
86 return 0;
87 error: 
88 return -1;

89 }
90 
91 static inline 

BSTreeNode *BSTree_getnode(BSTree 
* 
map,92 BSTreeNod 

* 
node, void *key)93 {94 int cmp = 


map-&gt;compare(node­&gt;key, key); 
95 
96 if (cmp == 

0) {
97 return node;
98 } else if (cmp &lt; 0) { 
99 if (node-&gt;left){ 100 retur BSTree_getnode(map,node-&gt;left, key); 
101 
} else {102 retur NULL;

103 
} 

104 
} else {105 if (node-&gt;right){ 106 retur BSTree_getnode(map,node-&gt;right, key); 

107 
} else {108 retur NULL;

109 
}


11. }


11. }
11. 113 void 
*BSTree_get(BSTree * 
map, void *key) 


114 {115 if (map­&gt;root == NULL){ 116 return NULL;

11. } else {118 BSTreeNod *node = BSTree_getnode(map, map-&gt;root, key); 119 return node == NULL ? NULL : node-&gt;data;

12. }

12. }12. 
123 static inline int 
BSTree_traverse_nodes(
* node,124 BSTree_tr traverse_cb)125 {126 int rc = 0;127 128 if (node­&gt;left){ 129 rc = BSTree_traverse_nodes(&gt;left, traverse_cb); 130 if (rc != 0) 
131 retur 

rc;
132 
}133 134 if (node­&gt;right){ 135 rc = BSTree_traverse_nodes(&gt;right, traverse_cb); 136 if (rc != 0)137 retur rc;

138 
}139 140 return 

traverse_cb(node); 

141 
}
142 
143 int 
BSTree_traverse(BSTree 



* map,
BSTree_traverse_cb 
traverse_cb)
144 {
145 if (map­&gt;root){ 
146 return 
BSTree_traverse_nodes(
&gt;root, traverse_cb); 

147 }
148 

149 return 0;
150 }
151 
152 static inline 
BSTreeNode 
*BSTree_find_min(BSTre 

* node)
153 {
154 while (node­&gt;left){ 
155 node = 
node-&gt;left;

156 
}
157 
158 return node;


159 
} 



160 

161 static inline void 
BSTree_replace_node_in 
* 
map,
162 BSTreeNod 


* 
node,
163 BSTreeNod 


* 
new_value)
164 {
165 if (node­&gt;parent){ 
166 if (node 
== node-&gt;parent­&gt;left){ 
167 node­


&gt;parent-&gt;left = new_value;
168 
} else {169 node­&gt;parent-&gt;right = new_value;

170 
}

171 
} else {172 // this is the root so gotta change it 


173 map­&gt;root = new_value;
174 
}175 176 if 

(new_value){ 177 new_value &gt;parent = node­&gt;parent;

178 
}

179 
}180 181 static inline void 


BSTree_swap(BSTreeNode 
* a, BSTreeNode * b)
182 {
183 void *temp = 
NULL;
184 temp = b­&gt;key; 

185 b-&gt;key = a­&gt;key;
186 a-&gt;key = 
temp;
187 temp = b­&gt;data;
188 b-&gt;data = a­&gt;data;
189 a-&gt;data = 
temp;

190 }191 192 static inline BSTreeNode *BSTree_node_delete(BS 
* 
map, 

193 BSTreeNod 

* 
node,
194 void 
*key)
195 {
196 int cmp = 
map-&gt;compare(node­&gt;key, key); 
197 
198 if (cmp &lt; 0)
{
199 if 
(node-&gt;left){ 
200 retur 
BSTree_node_delete(map
node-&gt;left, key); 



201 } else {202 // not found 
203 retur NULL;
204 
}

205 
} else if (cmp &gt; 0) { 206 if (node-&gt;right){ 207 retur BSTree_node_delete(mapnode-&gt;right, key); 

208 
} else {209 // not found 


210 retur 

NULL;
21. }

21. } else {213 if (node-&gt;left &amp;&amp; node­&gt;right){ 214 // swap this node for the smallest node that is bigger than us 


215 BSTre *successor = BSTree_find_min(node­&gt;right); 
216 BSTre 

node); 217 218 // this leaves the old successor with possibly a right child 219 // so replace it with that right child 
220 BSTre successor,221 &gt;right); 22. 223 // 

finally it's swapped, so return successor instead of node 
224 retur successor;
22. } else if (node-&gt;left){ 226 BSTre node, node-&gt;left); 

22. } else if (node-&gt;right){ 228 BSTre node, node-&gt;right); 

22. } else {230 BSTre 

node, NULL); 

231 
}
232 
233 return 
node;


234 
}


235 
}
236 
237 void 
*BSTree_delete(BSTree 



* map, void *key)
238 {
239 void *data = 
NULL;
240 
241 if (map­
&gt;root){ 
242 BSTreeNod 
*node = 
BSTree_node_delete(map
map-&gt;root, key); 
243 
244 if 
(node){ 
245 data 
= node-&gt;data;
246 free(

247 
}


248 
}
249 
250 return data;


251 
} 



Before getting into how BSTree_delete works,I wantto explaina patternfor doingrecursive functioncalls in a sane way. You’ll find thatmanytree-based data structures are easy to writeif you use recursion,but formulatea single recursive function. Part ofthe problem is thatyou need to set up someinitial data forthe first operation, then recurseinto the datastructure, whichis 
hard to do with one function. The solutionisto use two functions:One function sets up the data structure and initial recursion conditionsso thata second function cando the real work. Take alookat BSTree_get firstto see whatI mean. 
• Ihave an initial condition:If map­&gt;root is NULL,then return NULL and don’t 

recurse. 

• Ithen set upa callto the realrecursion, which is in BSTree_getnode.I create the initial condition of the root node to start with the key and thenthe map. 

• In the BSTree_getnode,I thendo theactual recursivelogic. I 


comparethe keys with 

map­
&gt;compare(node­
&gt;key, key) and go 

left, right,or equal to 

depending onthe 
results. 
• Since thisfunction is self-similarand doesn’t have tohandle any initial conditions (because BSTree_getdid), thenI can 

structure it very simply. When it’s done, it returnsto the caller,and thatreturn then comes back to BSTree_getfor the result. 

• At the end, the BSTree_get handles gettingthe node.data element butonly if theresult isn’t NULL. 



This way of structuring a recursivealgorithmmatches the way I structure my recursivedata structures. I haveaninitial base function thathandlesinitial conditions and some edgecases, and thenit calls aclean recursive function that does thework. Comparethatwith how I havea base structure in BStree combined with recursive BSTreeNode structures,whichall reference each other ina tree. Using this pattern makesit easy to deal with recursion and keep it straight. 
Next, go look at BSTree_set and BSTree_setnode to see the exactsame pattern. I use BSTree_set toconfigure the initialconditions andedge cases. A common edge case is thatthere’sno rootnode, so I haveto make one toget 
things started. This patternwillworkwith nearly anyrecursive algorithm youhave tofigure out. The wayI do itisby following this pattern: 
• Figure out the initial variables, how they change,and what the stopping conditions are for each recursive step. 

• Write a recursive function that calls itself, 

and has argumentsfor each stopping condition and initial variable. 

• Write a setupfunction to set initialstarting conditions for the algorithmand handle edge cases,then have it call therecursive function. 

• Finally, the setup function returns the final result,and 


possiblyalters it if the 

recursivefunction can’t 

handle final edgecases. 

This finallyleads me to BSTree_delete and BSTree_node_delete. First, you can justlookat BSTree_delete and see thatit’s thesetup function. Whatit’s doing isgrabbing the resulting node dataand freeingthe node that’s found. Thingsget more complex in BSTree_node_delete, because todelete a node at any point in thetree,I haveto rotate thatnode’schildrenup to theparent. Here’sa breakdownof thisfunction and the functions it uses: 
bstree.c:190 Irunthe comparefunction to figureoutwhich direction I'mgoing. 
bstree.c:192-198 This is 
the usual less-than 

branch tousewhenI wantto goleft. I'm handling thecase that leftdoesn’t existhere, and returning NULL to say “notfound.” This covers deleting something that isn’t in the BSTree. 
bstree.c:199-205 This is the samething,butfor the right branch of the tree. Just keeprecursing down into thetree just likein the other functions, and return NULL if itdoesn’t exist. 
bstree.c:206 This is where I havefound the node,sincethe keyis equal(compare return 0). 
bstree.c:207 This node has both a left and right branch, so it’s deeply embedded in the tree. 
bstree.c:209 To remove this node, I first need to find thesmallestnode that’s greater than this node,whichmeans I call 
BSTree_find_min 

on theright child. 
bstree.c:210 Once I have this node, I'll swapits key and data with the currentnode’s values. 

This will effectively take this nodethat was down at thebottomof the treeand put its contents here,sothat I don’thave to try and shufflethe node outby its pointers. 
bstree.c:214 The successor is now this dead branch that has the current node’s values. Itcould justbe removed,butthere’sa chancethat it has a right node value. This means I needto do a single rotate so thatthe successor’s rightnode gets movedup to completely detach it. 
bstree.c:217 Atthis point, the successor is removed fromthe tree, its valuesare replaced the current node’s values, andany children it hadare moved up into the parent. Icanreturn the successor as ifit werethe node. 
bstree.c:218 Atthis branch, I knowthat the node has aleft but no right, so I want to replace this node with its leftchild. 
bstree.c:219 Iagain use 
BSTree_replace_no 
to dothe replace, rotating theleft child up. 
bstree.c:220 This branch ofthe if-statement meansIhave a right child butno left child, so I want to rotate the rightchild up. 
bstree.c:221 Again, I use the functionto do the rotate,butthis time, rotate the right node. 
bstree.c:222 Finally, the only thing that’s left is the conditionwhere I’ve found the node, and ithasno children (no leftor right). In this case, I simply replace this node with NULL by using the same function I did with all ofthe others. 
bstree.c:210 Afterall that, 
I havethe current node 

rotated out of the tree and replacedwithsome child element that will fitin the tree. Ijust returnthis tothe caller so it can be freed and managed. 

This operation is very complex, and to be honest, I justdon’t botherdoing deletesin sometree data structures,and I treat them likeconstant data inmy software. If I needto do heavy inserting and deleting, I use a Hashmap instead. 

Finally,you canlookatthe unit test to see how I'm testing it: 
bstree_tests.c 

```c

1 #include &quot;minunit.h&quot; 2 #include 
&lt;lcthw/bstree.h&gt; 
3 #include &lt;assert.h&gt; 
4 #include &lt;lcthw/bstrlib.h&gt; 
5 #include &lt;stdlib.h&gt; 
6 #include &lt;time.h&gt; 
7 
8 BSTree *map = NULL;
9 static int traverse_called = 0;
10 struct tagbstring test1 = bsStatic(&quot;test data 
1&quot;);11 struct 
tagbstring test2 = bsStatic(&quot;test data 2&quot;);
12 struct tagbstring test3 = bsStatic(&quot;xest data 3&quot;);
13 struct tagbstring expect1 = bsStatic(&quot;THE VALUE 1&quot;);
14 struct tagbstring expect2 = bsStatic(&quot;THE VALUE 2&quot;); 
15 struct tagbstring expect3 = bsStatic(&quot;THE VALUE 3&quot;);
1. 17 static int traverse_good_cb(BSTre 
* node)18 {19 debug(&quot;KEY: 
%s&quot;, bdata((bstring)
node-&gt;key)); 20 traverse_cal 21 return 0;
22 }
2. 24 static int 

traverse_fail_cb(BSTre 
* node)25 {26 debug(&quot;KEY: 
%s&quot;, bdata((bstring)
node-&gt;key)); 27 traverse_cal 28 29 if 
(traverse_called == 
2) {
30 return 1;
31 } else {
32 return 0; 
33 
}

34 
}
35 
36 char 



*test_create() 
37 {
38 map = BSTree_create(NULL); 
39 mu_assert(ma != NULL, &quot;Failed to create map.&quot;); 
40 41 return NULL;
42 }
43 

44 char 

*test_destroy() 45 {46 BSTree_destr 47 48 return 
NULL;
49 }
50 
51 char 

*test_get_set() 52 {53 int rc = 
BSTree_set(map,&amp;test1,&amp;expect1); 54 mu_assert(rc == 0, &quot;Failed to set 
&amp;test1&quot;); 
55 bstring result = BSTree_get(map,&amp;test1); 
56 mu_assert(re == &amp;expect1, &quot;Wrong value for test1.&quot;); 
57 
58 rc = BSTree_set(map,&amp;test2,&amp;expect2); 
59 mu_assert(rc == 0, &quot;Failed to set test2&quot;); 
60 result = BSTree_get(map, &amp;test2); 
61 mu_assert(re == &amp;expect2, &quot;Wrong value for test2.&quot;); 
62 
63 rc = BSTree_set(map,&amp;test3,&amp;expect3); 
64 mu_assert(rc == 0, &quot;Failed to set test3&quot;); 
65 result = BSTree_get(map,&amp;test3); 
66 mu_assert(re == &amp;expect3, &quot;Wrong 
value for test3.&quot;); 67 68 return 
NULL;
69 }
70 
71 char 

*test_traverse() 72 {73 int rc = 
BSTree_traverse(map,traverse_good_cb); 
74 mu_assert(rc == 0, &quot;Failed to traverse.&quot;); 
75 mu_assert(tr == 3, &quot;Wrong count traverse.&quot;); 
76 
77 traverse_cal = 0;
78 rc = BSTree_traverse(map,traverse_fail_cb); 
79 mu_assert(rc == 1, &quot;Failed to traverse.&quot;); 
80 mu_assert(tr == 2, &quot;Wrong count traverse for fail.&quot;); 
81 
82 return NULL;
83 } 84 85 char 
*test_delete() 
86 {
87 bstring deleted =(bstring)BSTree_delete(map,&amp;test1); 
88 mu_assert(de != NULL, &quot;Got NULL on delete.&quot;); 
89 mu_assert(de == &amp;expect1, &quot;Should get test1&quot;); 
90 bstring result = BSTree_get(map,&amp;test1); 
91 mu_assert(re == NULL, &quot;Should delete.&quot;); 
92 
93 deleted = (bstring)BSTree_delete(map,&amp;test1); 
94 mu_assert(de == NULL, &quot;Should get NULL on delete&quot;); 
95 
96 deleted = (bstring)BSTree_delete(map, &amp;test2); 
97 mu_assert(de != NULL, &quot;Got NULL on delete.&quot;); 
98 mu_assert(de == &amp;expect2, &quot;Should get test2&quot;); 
99 result = BSTree_get(map,&amp;test2); 100 mu_assert(re == NULL, &quot;Should delete.&quot;); 101 102 deleted = (bstring) BSTree_delete(map,&amp;test3); 103 mu_assert(de != NULL, &quot;Got NULL on delete.&quot;); 104 mu_assert(de == &amp;expect3, &quot;Should get test3&quot;); 105 result = BSTree_get(map,&amp;test3); 106 mu_assert(re == NULL, &quot;Should delete.&quot;); 107 108 // test deleting non-existent 
stuff 
109 deleted = 
(bstring)
BSTree_delete(map,
&amp;test3); 
110 mu_assert(de 
== NULL, &quot;Should get 
NULL&quot;); 
11. 112 return 
NULL;

113 }
11. 115 char 
*test_fuzzing() 
116 {
117 BSTree 

*store = 
BSTree_create(NULL); 
118 int i = 0;
119 int j = 0;
120 bstring 
numbers[100] = { NULL 
};

121 bstring 
data[100] = { NULL }; 
122 srand((unsig
int)time(NULL)); 
12. 124 for (i = 0;
i &lt; 100; i++) { 
125 int num 
= rand(); 

126 numbers[= bformat(&quot;%d&quot;, num); 127 data[i]= bformat(&quot;data %d&quot;, num);128 BSTree_s numbers[i], data[i]); 
129 }
130 
131 for (i = 0;
i &lt; 100; i++) { 
132 bstring 
value = 
BSTree_delete(store,
numbers[i]); 
133 mu_asser 
== data[i], 

134 

to delete the right 
number.&quot;); 
135 
136 mu_asser 
numbers[i]) == NULL,
137 
get nothing.&quot;); 
138 
139 for (j
= i + 1; j &lt; 99 -i;
j++) {
140 bstr 
value = 
BSTree_get(store,
numbers[j]); 

141 mu_a == data[j], 142 
to get the right number.&quot;); 
143 
}144 145 bdestroy146 bdestroy

147 
}148 149 BSTree_destr 150 151 return NULL;

152 
}153 

154 char 
*all_tests() 
155 {
156 mu_suite_sta 
157 
158 mu_run_test(
159 mu_run_test(
160 mu_run_test(
161 mu_run_test(
162 mu_run_test(
163 mu_run_test(
164 
165 return 
NULL;


166 
}167 


168 RUN_TESTS(all_te 
</code></pre>

<p>I&rsquo;ll pointyou to the test_fuzzing function, which is an interesting technique for testing complex data structures. It is difficult to create asetof keys that cover all of the branchesin BSTree<em>node</em> delete, and chances are, I wouldmiss someedge case. Abetterway is to createa fuzz function thatdoes all of the operations, butdoes them in a horrible and randomway. In this case, I&rsquo;m inserting a set ofrandom string keys, and thenI&rsquo;m deletingthemand trying to get therest after each delete.
Doingthis preventsyou from testing only what you know to work, and thenmiss things you don’tknow. Bythrowing random junk at yourdata structures,you’llhit things you didn’texpectand be able to workoutany bugsyou have.
How to Improve It
Do not doany ofthese yet. In the next exercise I&rsquo;ll be using this unittestto teach you somemore performance­tuningtricks, and you’ll come back and do theseafteryou complete Exercise
41. • As usual,you should go through allof the</p>

<p>defensiveprogramming checks and add assert<code>s for conditions that shouldn’thappen. For example, you shouldn’t be getting</code>NULL valuesforthe recursion functions, so assert that.</p>

<p>• The traverse function walks through the treein orderby traversing left,then</p>

<p>right, andthen the currentnode. You can create traverse functions for thereverse order, aswell.</p>

<p>• Itdoes a full string compare onevery node,but Icoulduse the Hashmap hashing functions to speed this up. I could hash the keys, andthen keepthe hash inthe</p>

<p>BSTreeNode. Then, in each of the setup functions, I can hashthe key ahead oftime and pass it down tothe recursivefunction. Using this hash,Ican thencompare eachnode much quickerin a way that’s similarto whatI do in Hashmap.</p>

<p>Extra Credit</p>

<p>• There’s an alternative way todo thisdata structure without using recursion. The Wikipedia pageshows alternatives thatdon’t use recursion butdo the same thing. Why would this bebetteror worse?</p>

<p>• Readup onallof the
differentbut similar
trees you can find.</p>

<p>There areAVL trees
(namedafterGeorgy
Adelson-Velsky and</p>

<p>E.M. Landis),red-black trees, andsome non-tree structures like skip lists.</p>

<p>Exercise41. Project devpkg</p>

<p>You are now ready to tackle a new project called devpkg. In this projectyou’regoing to recreate apiece ofsoftware thatIwrote specifically for this bookcalled devpkg. You’ll thenextend it in a few key ways and improvethe code, most importantlyby writing someunittests for it. This exercisehasa companionvideoto it, and also a projecton GitHub (<a href="https://github.com)that">https://github.com)that</a> you can referenceif you getstuck. You should attempt to dothis exerciseusing the description below, since that’s how you’ll need to learnto codefrom books in the future. Most computer sciencetextbooks don’tinclude videos for their exercises, so this projectis more abouttrying tofigure it outfromthis description.</p>

<p>If youget stuck, andyou can’t figureit out, then go watchthe video andlook at the GitHub projectto seehow your code differsfrommine.</p>

<p>What Is devpkg?
Devpkg is asimple C programthat installs other software. Imade it specifically for thisbook as a way to teach you how areal softwareproject is structured, and alsohowto reuseother people’slibraries. Ituses a portability library calledthe Apache Portable Runtime (APR),whichhasmany handy C functions that work on tons ofplatforms, including Windows. Other thanthat, it justgrabscode fromthe Internet (or local files) anddoes the usual
./configure, make, and make install that every programdoes.</p>

<p>Your goal in this exerciseis to build devpkg fromthe source,finish each challenge I give,and use thesource to understand what devpkg does and why.</p>

<p>What We Want to Make</p>

<p>We want atoolthat has these commands:
devpkg -S Sets up a new installation ona computer.
devpkg -I Installs apiece ofsoftware from a URL.
devpkg -L Listsall ofthe
softwarethat’sbeen</p>

<p>installed. devpkg -F Fetches some source code formanual building. devpkg -B Builds the source code and installs it, even if it’s already installed. We want devpkg to be able to takealmost any URL, figureoutwhat kind of projectitis, downloadit, install it, and register thatit
downloadedthat software. We’d also like it to process a simple dependency listsothat it can install allof the softwarethat a projectmight need, aswell.</p>

<p>The Design</p>

<p>To accomplish this goal, devpkg will havea very simple design:
Use External Commands</p>

<p>You’ll do most of the
work throughexternal commands like curl, git,and tar.This reduces the amount of code devpkg needs to get thingsdone.
SimpleFileDatabase You could easilymake it more complex, but you’ll startby making justmake a single simple file databaseat /usr/local/.devpk
to keeptrackof what’s</p>

<p>installed.
/usr/local Always Again, you could makethis more advanced, but for now just assume it’s always /usr/local, which is astandard install pathfor most softwareon UNIX.
configure, make,make install It’sassumedthat most softwarecanbe installed with just a configure, make, and make install —and maybe configure is optional. If thesoftware at aminimumcan’tdo that, there are some optionsto modify the commands,but otherwise, devpkgwon’tbother.</p>

<p>TheUserCan BeRoot</p>

<p>We’ll assumethat the user canbecomeroot using sudo,but doesn’twant tobecome root untilthe end.</p>

<p>This will keep our program smallatfirst and workwell enoughforusto getitgoing, at which pointyou’llbeable to modifyit further for this exercise.</p>

<p>The Apache Portable</p>

<p>Runtime</p>

<p>Onemorething you’ll dois leverage theAPRLibraries to get a good set ofportable routinesfor doing this kind of work. APR isn’t necessary, and you couldprobably write this program without it, but it’d takemorecode than necessary. I&rsquo;m also forcing you to use APR now so you get usedto linking andusing other libraries. Finally, APR also workson Windows,so your skills with it are transferable tomany other platforms.</p>

<p>You should goget both the apr-1.5.2 and the apr­util-1.5.4 libraries, as wellas browsethrough the documentationavailable at the main APR site at <a href="http://apr.apache.org">http://apr.apache.org</a>.</p>

<p>Here’s ashell script that will
install all thestuff youneed.</p>

<p>You should write this into a fileby hand,and then run it until itcaninstallAPR without anyerrors.</p>

<p>Exercise 41.1 Session</p>

<pre><code class="language-c">
set -e 
# go somewhere safe 
cd /tmp 
# get the source to base APR 1.5.2 
curl -L -O http://archive.apache. 1.5.2.tar.gz 
# extract it and go into the source 
tar -xzvf apr­1.5.2.tar.gzcd apr-1.5.2 
# configure, make, make install 
./configuremake sudo make install 
# reset and cleanup 
cd /tmp rm -rf apr-1.5.2 apr­1.5.2.tar.gz 
# do the same with apr-util 
curl -L -O http://archive.apache. util-1.5.4.tar.gz 
# extract 
tar -xzvf apr-util­1.5.4.tar.gz 
cd apr-util-1.5.4 
# configure, make, make install 
./configure --with­apr=/usr/local/apr 
# you need that extra parameter to configure because # apr-util can't really find it because...who knows. 
make sudo make install 
#cleanup 
cd /tmp rm -rf apr-util­1.5.4* apr-1.5.2. I'm having youwrite this script outbecause it’s basically what we want devpkg to do,butwith extra optionsand checks. In fact, you could justdo it allin shellwith less code, but then thatwouldn’t be a very good programfora C book would it? 
Simply run thisscriptand fix it untilitworks,then you’ll havethe librariesyouneed to completethe restof this project. 
Project Layout 

You need tosetup some simple projectfiles toget started. Here’showI usually craft anew project: 


Exercise 41.2 Session 
mkdir devpkg cd devpkgtouch README Makefile 
Other Dependencies 


You should have already installed apr-1.5.2 andapr­util-1.5.4,sonowyou need a fewmore files to use as basic dependencies: 
• dbg.h 
from 


Exercise 
20. 


• bstrlib.h and bstrlib.c from 


http://bstring.sourceforge 


Download the .zipfile, 


extract it, andcopy just 

thosetwo files. 
• Type make bstrlib.o, and if it doesn’twork,read the instructionsforfixing bstring below. 

Warning! 

Insome platforms,the 
bstring.c file will 
haveanerror like this: 


```c

bstrlib.c:2762: error: expecteddeclaration\ specifiers or '...' before numeric constant 

This is fromabad define that the authorsadded, which doesn’talways work. You justneed to change line2759 that reads #ifdef __GNUC__ toread: 

```c

#if defined(__GNUC__) &amp;&amp; !defined(__APPLE__) 
andthen itshould 
workon OSX. 


When that’s all done,you should have a Makefile, README, dbg.h, bstrlib.h, and bstrlib.c ready togo. 

The Makefile 

A good placeto startisthe Makefile sincethis lays outhowthings are builtand whatsourcefiles you’ll be creating. 

Makefile 


```c

PREFIX?=/usr/local CFLAGS=-g -Wall ­I${PREFIX}/apr/include 1 CFLAGS+=­I${PREFIX}/apr/include util-1 LDFLAGS=­L${PREFIX}/apr/lib ­lapr-1 -pthread ­laprutil-1 all: devpkg 
devpkg: bstrlib.o db.o shell.o commands.o 
install: all 
install -d $(DESTDIR)/$(PREFIX)/b 
install devpkg $(DESTDIR)/$(PREFIX)/b 
clean: 
rm -f *.o 
rm -f devpkg 
rm -rf *.dSYM 


There’snothing in this that you haven’tseenbefore, exceptmaybe the strange ?= syntax,which says “set PREFIXequalto this unless PREFIXisalready set.” 

Warning! 


If you’reon more recent versions of Ubuntu,and you get errorsabout apr_off_t or off64_t, then add ­D_LARGEFILE64_SOUR to CFLAGS. Another thingis that you need to add 
/usr/local/apr/lib

to a file in 
/etc/ld.conf.so.d/

andthen run ldconfig so that it correctly picks up the libraries. 

The Source Files 
From the Makefile, we seethat there are five dependencies for devpkg: 
bstrlib.o This comes from bstrlib.c andthe header file bstlib.h, which you already have. 
db.o This comes from db.c and header file db.h,and it will 
contain code for our 

little databaseroutines. 

shell.o This is from shell.c andheader shell.h, as well asa couple offunctions that makerunning other commands like curl easier. 
commands.o Thisisfrom command.c and header command.h, and containsall ofthe commands that devpkg needs to be useful. 
devpkg It’s not explicitly mentioned, but it’s the target (on the left)in this part of the Makefile. It comes from devpkg.c, which contains the main function for the whole program. 

Your job is to now create each ofthese files, type in their code, and get them correct. 

Warning! 

You mayread this descriptionand think, “Man! How isit that Zed is so smart thathe justsatdownand typed thesefiles out likethis!?I could never dothat.” I didn’t magically craft devpkg inthis form with my awesome codingpowers. Instead, whatI didis this: 
• Iwroteaquicklittle README to getan idea ofhow Iwanted it to work. 

• Icreated a simple bash script (like the one you didearlier) to figureout 

all ofthe pieces that 
wereneeded. 


• Imade one .c file and hacked on itfora few days workingthrough the ideaand figuring it out. 

• Igot itmostly working and debugged, then I started breaking upthe one big file into these four files. 

• Aftergetting thesefiles 


laiddown,Irenamed and refined the functions anddata structuressothat they’d be more logicaland pretty. 

• Finally, after I hadit working the exact same butwiththe new structure,Iaddeda few features like the -F and -B options. 



You’re readingthis in theorder I want to teachitto you,but don’tthink thisishow I always build software. Sometimes I already knowthe subject andI usemore planning. SometimesI justhack upanidea andsee how wellit’d work. SometimesI write one, then throw it awayand plan outa better one. It all depends on whatmy experience tells meis bestor where my inspiration takes me. 


If yourunintoa supposedexpert who triesto tellyou that there’s onlyone wayto solveaprogramming problem, they’re lying to you. Either they actually use multiple tactics, or they’renot 
very good. 


The DB Functions 


There must be a wayto recordURLs that havebeen installed, listtheseURLs, and check whether somethinghas already beeninstalled so we can skipit. I'll use asimple flatfile database andthe bstrlib.h library todo it. 

First, create the db.h header 

filesoyouknow whatyou’ll be implementing. 
db.h 

```c

#ifndef _db_h 
#define _db_h 
#define DB_FILE &quot;/usr/local/.devpkg/db #define DB_DIR &quot;/usr/local/.devpkg&quot; 
int DB_init(); int DB_list(); int DB_update(const char *url); int DB_find(const char *url); 
#endif 

Then, implementthose functions in db.c, andas you build this, use make to get itto compilecleanly. 
db.c 


```c


1

#include 

&lt;unistd.h&gt; 

2

#include 

&lt;apr_errno.h&gt; 

3

#include 

&lt;apr_file_io.h&gt; 

456

#include &quot;db.h&quot; #include 
&quot;bstrlib.h&quot; 

7

#include 

&quot;dbg.h&quot; 

89

static FILE 

*DB_open(const char *path, const char *mode)
10 {
11 return fopen(path, mode); 
12 }
1. 14 static void 

DB_close(FILE * db)15 {16 fclose(db); 
17 }18 19 static bstring 
DB_load() 20 {
21 FILE *db = NULL;
22 bstring data = NULL;
2. 24 db = DB_open(DB_FILE,&quot;r&quot;);
25 check(db,&quot;Failed to open database: %s&quot;,DB_FILE); 
2. 27 data = bread((bNread) fread, 
db);28 check(data,
&quot;Failed to read from db file: %s&quot;,DB_FILE); 
29 30 DB_close(db)31 return 
data;32 33 error: 34 if (db)35 DB_close 36 if (data)37 bdestroy38 return 
NULL; 
39 }
40 
41 int 

DB_update(const char 
*url)
42 {
43 if 
(DB_find(url)) { 44 log_info 
recorded as installed: %s&quot;, url); 
45 }
46 
47 FILE *db = 

DB_open(DB_FILE,
&quot;a+&quot;); 

48 check(db,
&quot;Failed to open DB 
file: %s&quot;, DB_FILE); 
49 
50 bstring line = bfromcstr(url); 
51 bconchar(lin '\n'); 
52 int rc = fwrite(line-&gt;data,blength(line), 1,db);
53 check(rc == 1, &quot;Failed to append to the db.&quot;); 
54  
55 56  return error:  0;  
57 58 59 60 61  }  if (db)DB_close return -1;  
62  int  

DB_find(const char 
*url)
63 {
64 bstring data = NULL;
65 bstring line = 
bfromcstr(url); 
66 int res = -1;
67 
68 data = DB_load(); 
69 check(data,&quot;Failed to load: %s&quot;,DB_FILE); 
70 
71 if (binstr(data, 0,line) == BSTR_ERR){ 
72 res = 0;
73 } else { 
74 res = 1;
75 }
76 
77 error: 

fallthrough 
78 if (data)
79 bdestroy
80 if (line)
81 bdestroy
82 
83 return res;

84 }
85 
86 int DB_init() 
87 { 

88 apr_pool_t 
*p = NULL;89 apr_pool_ini 90 apr_pool_cre 
NULL); 91 92 if 
(access(DB_DIR, W_OK | X_OK) == -1) { 
93 apr_stat rc = apr_dir_make_recursive 
94 | APR_UWRITE 95 APR_UEXECUTE | 
96 | APR_GWRITE 97 APR_GEXECUTE, p); 98 check(rc == APR_SUCCESS,
&quot;Failed to make database dir: %s&quot;,99 
100 }
101 
102 if 
(access(DB_FILE,
W_OK) == -1) { 
103 FILE *db 

= DB_open(DB_FILE,&quot;w&quot;); 
104 check(db,
&quot;Cannot opendatabase: %s&quot;,DB_FILE); 105 DB_close(
106 
}
107 
108 apr_pool_dest 
109 return 0;
11. 111 error: 
112 apr_pool_dest 
113 return -1;


11. }
11. 116 int DB_list() 



117 {
118 bstring data 
= DB_load(); 
119 check(data,

&quot;Failed to read load: 
%s&quot;, DB_FILE); 
12. 121 printf(&quot;%s&quot;,
bdata(data)); 
122 bdestroy(data 
123 return 0;
12. 125 error: 
126 return -1;

127 } 
Challenge1: Code Review 

Before continuing, read every lineof thesefiles carefully and confirm thatyou have them entered in exactly as theyappearhere. Read them backward line by lineto practice that. Also, trace each function calland make sure you’re using check to validate thereturn codes. Finally,lookup every function that youdon’t recognize—either in theAPR Web sitedocumentation orin the bstrlib.h and bstrlib.c source. 

The Shell Functions 

A keydesigndecision for devpkg is to have external tools like curl, tar,and git do most of the work. We could find libraries todo all ofthis internally, but it’s pointless if we justneed the base features of these programs. Thereis no shame in runninganother command in UNIX. 

To do this,I'm going touse 

the apr_thread_proc.hfunctions torunprograms, butI also want to make a simple kind of template system. I’llusea struct Shell thatholdsall ofthe informationneededto run a program, but has holesin the arguments listthat I can replace with values. 
Lookatthe shell.h file to seethe structure and the commands thatI’ll use. You can seethat I'musing extern to indicatehow other .c filescan access variables that I'mdefiningin shell.c. 
shell.h 

```c

#ifndef _shell_h 
#define _shell_h 
#define 

MAX_COMMAND_ARGS 100 
#include &lt;apr_thread_proc.h&gt; 
typedef struct Shell 
{ const char *dir;const char *exe; 
apr_procattr_t 
*attr;apr_proc_t proc;apr_exit_why_e

exit_why;int exit_code; 
const char 

*args[MAX_COMMAND_ARGS } Shell; 
int Shell_run(apr_pool_t 
* p, Shell * cmd); int Shell_exec(Shell cmd, ...); 

extern Shell CLEANUP_SH;extern Shell GIT_SH;extern Shell TAR_SH;extern Shell CURL_SH; 

extern Shell 

CONFIGURE_SH;extern Shell MAKE_SH;extern Shell INSTALL_SH; 
#endif 
Make sure you’vecreated shell.h exactly as it appears here, andthat you’ve gotthe same names and number of extern Shell variables. Those areused by the Shell_run and Shell_exec functionsto run commands. I define these twofunctions,and createthe realvariables in shell.c. 
shell.c 

```c

1 #include &quot;shell.h&quot; 2 #include &quot;dbg.h&quot; 3 #include &lt;stdarg.h&gt; 
4 5 int 
Shell_exec(Shell 
template, ...) 
6 {
7 apr_pool_t 
*p = NULL;8 int rc = -1;9 apr_status_t rv = APR_SUCCESS;10 va_list argp;11 const char *key = NULL;12 const char 
*arg = NULL;
13 int i = 0;
1. 15 rv = apr_pool_create(&amp;p,NULL); 
16 check(rv == APR_SUCCESS, &quot;Failed to create pool.&quot;); 
1. 18 va_start(argtemplate); 
1. 20 for (key = va_arg(argp, const char *); 
21 key != NULL; key = va_arg(argp, const char *)) { 
22 arg = va_arg(argp, const char *); 
2. 24 for (i = 0; template.args[i]!= NULL; i++) { 
25 if (strcmp(template.args[key) == 0) { 
26 = arg; Shell_run(p,
27  
found  it  
28 29 30 31  }  }  }  
32  rc  =  

&amp;template); 33 apr_pool_des 34 va_end(argp)35 return rc;36 37 error: 38 if (p){ 39 apr_pool 
40 
}41 return rc;

42 
}
43 
44 int 



Shell_run(apr_pool_t 
* p, Shell * cmd)45 {46 apr_procattr 
*attr;
47 apr_status_t rv;
48 apr_proc_t 
newproc;49 50 rv = apr_procattr_create(&amp;a p);
51 check(rv == APR_SUCCESS, &quot;Failed to create proc attr.&quot;); 
52 
53 rv = apr_procattr_io_set(at APR_NO_PIPE,APR_NO_PIPE,
54 APR_ 
55 check(rv == APR_SUCCESS, &quot;Failed to set IO of command.&quot;); 
56 57 rv = 
apr_procattr_dir_set(a cmd-&gt;dir); 
58 check(rv == APR_SUCCESS, &quot;Failed to set root to %s&quot;,cmd-&gt;dir); 
59 
60 rv = apr_procattr_cmdtype_s APR_PROGRAM_PATH); 
61 check(rv == APR_SUCCESS, &quot;Failed to set cmd type.&quot;); 
62 
63 rv = 

apr_proc_create(&amp;newpr cmd-&gt;exe, cmd-&gt;args,NULL, attr, p); 
64 check(rv == APR_SUCCESS, &quot;Failed to run command.&quot;); 
65 
66 rv = apr_proc_wait(&amp;newproc &amp;cmd-&gt;exit_code,&amp;cmd-&gt;exit_why,
67 APR_ 
68 check(rv == APR_CHILD_DONE,&quot;Failed to wait.&quot;); 
69 
70 check(cmd­&gt;exit_code == 0, &quot;%s exited badly.&quot;, cmd­&gt;exe); 
71 check(cmd­&gt;exit_why == APR_PROC_EXIT, &quot;%s was killed or crashed&quot;,
72 cmd­&gt;exe); 
73 
74 return 0;
75 
76 error: 
77 return -1;
78 }
79 
80 Shell 

CLEANUP_SH ={
81 .exe = &quot;rm&quot;,
82 .dir = &quot;/tmp&quot;,
83 .args = {&quot;rm&quot;, &quot;-rf&quot;,&quot;/tmp/pkg-build&quot;,&quot;/tmp/pkg­src.tar.gz&quot;,
84 &quot;/tmp/pk src.tar.bz2&quot;, 
&quot;/tmp/DEPENDS&quot;, NULL}
85 }; 
86 
87 Shell GIT_SH = {
88 .dir = &quot;/tmp&quot;,
89 .exe = &quot;git&quot;,
90 .args = {&quot;git&quot;, &quot;clone&quot;,&quot;URL&quot;, &quot;pkg-build&quot;,NULL}
91 }; 
92 
93 Shell TAR_SH = { 
94 .dir = &quot;/tmp/pkg-build&quot;,
95 .exe = &quot;tar&quot;,
96 .args = {&quot;tar&quot;, &quot;-xzf&quot;,&quot;FILE&quot;, &quot;--strip­components&quot;, &quot;1&quot;,NULL}
97 }; 
98 
99 Shell CURL_SH = {100 .dir = &quot;/tmp&quot;,101 .exe = &quot;curl&quot;, 
102 .args = 
{&quot;curl&quot;, &quot;-L&quot;, &quot;-o&quot;,
&quot;TARGET&quot;, &quot;URL&quot;,
NULL}
103 }; 
104 
105 Shell 
CONFIGURE_SH ={
106 .exe = 
&quot;./configure&quot;,
107 .dir = 
&quot;/tmp/pkg-build&quot;,
108 .args = 
{&quot;configure&quot;, &quot;OPTS&quot;,
NULL}
109 , 

110 }; 
11. 112 Shell MAKE_SH = 
{
113 .exe = 
&quot;make&quot;,
114 .dir = 
&quot;/tmp/pkg-build&quot;,
115 .args = 
{&quot;make&quot;, &quot;OPTS&quot;,
NULL}
116 }; 
11. 118 Shell 
INSTALL_SH ={
119 .exe = 
&quot;sudo&quot;, 

120 .dir = &quot;/tmp/pkg-build&quot;,121 .args = {&quot;sudo&quot;, &quot;make&quot;,&quot;TARGET&quot;, NULL}122 }; 
Read the shell.c fromthe bottom to thetop (which is a common C source layout) and you seehow I’vecreated the actual Shell variables that you indicatedwere extern in shell.h. Theylive here, butare available tothe rest of the program. Thisis how you makeglobal variablesthat livein one .o file butare used everywhere. You shouldn’tmake many of these, butthey arehandy for things like this. 
Continuing up the fileweget to the Shell_run function, which is abasefunction that justruns a command according to what’sin a Shell struct. It uses many 
ofthe functions defined in 

apr_thread_proc.h,so go lookup each oneto see how the base functionworks. This seems likealot ofwork compared to just using the system function call, but it also gives youmore control over the otherprogram’s execution. Forexample, in our Shell struct,we have a .dir attribute thatforcesthe programto be in a specific directory before running. Finally,Ihave the Shell_exec function, which is avariable argument function. You’veseen this before, but makesure you grasp the stdarg.hfunctions. In the challenge for this section, you’re goingto analyzethis function. 
Challenge2: Analyze
Shell_exec 

The challenge for thesefiles (in addition to a full code review like youdidin Challenge1) is to fully analyze Shell_exec and break down exactly how it works. You should be ableto understand each line,howthe two for-loops work, and how arguments are being replaced. 


Onceyou have it analyzed, add a field to struct Shell thatgives you the number ofvariable args that must be replaced. Update all ofthe commands to have the rightcountof args, and have an errorcheck toconfirm that these argshave been replaced, and then error exit. 

The Command Functions 

Now youget to make the actualcommandsthat do the work. These commands will use functions from APR, db.h,and shell.h todo the real work of downloading and building the software that you wantit to build. This is the most complex set offiles, so do themcarefully. As before, you startby making the commands.h file, then implementingitsfunctions in 
the commands.c file. commands.h 

```c

#ifndef _commands_h #define _commands_h 
#include 
&lt;apr_pools.h&gt; 
#define DEPENDS_PATH &quot;/tmp/DEPENDS&quot; #define TAR_GZ_SRC &quot;/tmp/pkg-src.tar.gz&quot; #define TAR_BZ2_SRC &quot;/tmp/pkg­src.tar.bz2&quot; #define BUILD_DIR &quot;/tmp/pkg-build&quot; #define GIT_PAT &quot;*.git&quot; #define DEPEND_PAT &quot;*DEPENDS&quot; #define TAR_GZ_PAT &quot;*.tar.gz&quot; #define TAR_BZ2_PAT &quot;*.tar.bz2&quot; #define CONFIG_SCRIPT &quot;/tmp/pkg­build/configure&quot; 
enum CommandType {
COMMAND_NONE,COMMAND_INSTALL,COMMAND_LIST,COMMAND_FETCH,
COMMAND_INIT,COMMAND_BUILD}; 
int Command_fetch(apr_pool 
* p, const char *url,int fetch_only); 
int 
Command_install(apr_po 
* p, const char *url,const char 
*configure_opts,
const char *make_opts, const char *install_opts); 
int Command_depends(apr_po 
* p, const char *path); 
int Command_build(apr_pool 
* p, const char *url, const char 
*configure_opts,
const char 
*make_opts,
const char 
*install_opts); 
#endif 


There’snotmuchin commands.h that you haven’tseenalready. You should see thattherearesome defines for strings that are used everywhere. The really interesting code isin commands.c. 
commands.c 

```c

1 #include &lt;apr_uri.h&gt; 
2 #include &lt;apr_fnmatch.h&gt; 3 #include 
&lt;unistd.h&gt; 
4 5 #include &quot;commands.h&quot; 
6 #include &quot;dbg.h&quot; 
7 #include &quot;bstrlib.h&quot; 
8 #include &quot;db.h&quot; 
9 #include &quot;shell.h&quot; 
1. 11 int Command_depends(apr_po 
* p, const char 
*path)
12 {
13 FILE *in = 
NULL; 
14 bstring line = NULL;
1. 16 in = fopen(path, &quot;r&quot;); 
17 check(in != NULL, &quot;Failed to open downloaded depends: %s&quot;, path); 
1. 19 for (line = bgets((bNgetc) fgetc,in, '\n'); 
20 line != NULL;
21 line = bgets((bNgetc)
fgetc, in, '\n')) 
22 {
23 btrimws(
24 log_info depends: %s&quot;,bdata(line)); 
25 int rc = Command_install(p,bdata(line), NULL,NULL, NULL); 
26 check(rc == 0, &quot;Failed to install: %s&quot;,bdata(line)); 
27 bdestroy 
28 }
2. 30 fclose(in); 
31 return 0;
32 
33 error: 
34 if (line)

bdestroy(line); 35 if (in)fclose(in); 36 return -1;
37 }
38 
39 int 

Command_fetch(apr_pool 
* p, const char *url, 
int fetch_only)
40 {
41 apr_uri_t info = {.port = 0 }; 
42 int rc = 0;43 const char *depends_file = NULL;
44 apr_status_t rv = apr_uri_parse(p,url,&amp;info); 
45 
46 check(rv == APR_SUCCESS, &quot;Failed to parse URL: %s&quot;,url); 47 48 if 
(apr_fnmatch(GIT_PAT,info.path, 0) == APR_SUCCESS){ 
49 rc = Shell_exec(GIT_SH,&quot;URL&quot;, url, NULL); 
50 check(rc == 0, &quot;git failed.&quot;); 
51 } else if (apr_fnmatch(DEPEND_PA info.path, 0) == APR_SUCCESS){ 
52 check(!f 
&quot;No point in fetching a DEPENDS file.&quot;); 
53 54 if 
(info.scheme){ 
55 depe = DEPENDS_PATH;
56 rc = Shell_exec(CURL_SH,&quot;URL&quot;, url, &quot;TARGET&quot;,depends_file,
57 
58 chec == 0, &quot;Curl failed.&quot;); 
59 } else {
60 depe = info.path;
61 }
62 
63 // 

recursively process the devpkg list 
64 log_info according to DEPENDS: %s&quot;, url); 
65 rv = Command_depends(p,depends_file); 
66 check(rv == 0, &quot;Failed to 
process the DEPENDS: %s&quot;, url); 
67 
68 // this indicates that 
(apr_fnmatch(TAR_GZ_PA 

nothing  needs  to  be  
done  
69  return  
0;70  
71  } else if  

info.path, 0) == APR_SUCCESS){ 
72 if (info.scheme){ 
73 rc = Shell_exec(CURL_SH, 
74 

url, &quot;TARGET&quot;,TAR_GZ_SRC, NULL); 
75 chec == 0, &quot;Failed to curl source: %s&quot;, url); 
76 }
77 
78 rv = 

apr_dir_make_recursive 79 | APR_UWRITE |80 p);81 check(rv == APR_SUCCESS, 
&quot;Failed to make 
directory %s&quot;,
82 
83 
84 rc = Shell_exec(TAR_SH,&quot;FILE&quot;, TAR_GZ_SRC,NULL); 
85 check(rc == 0, &quot;Failed to untar %s&quot;,TAR_GZ_SRC); 
86 } else if (apr_fnmatch(TAR_BZ2_P info.path, 0) == APR_SUCCESS){ 
87 if (info.scheme){ 
88 rc = Shell_exec(CURL_SH,&quot;URL&quot;, url, &quot;TARGET&quot;,TAR_BZ2_SRC,

89 
90 chec == 0, &quot;Curl failed.&quot;); 
91 }92 93 apr_stat 
rc = apr_dir_make_recursive 94 
| APR_UWRITE 
95 APR_UEXECUTE, p); 
96 
97 check(rc == 0, &quot;Failed to make directory %s&quot;,BUILD_DIR); 
98 rc = Shell_exec(TAR_SH,&quot;FILE&quot;, TAR_BZ2_SRC,NULL); 
99 check(rc == 0, &quot;Failed to untar %s&quot;,TAR_BZ2_SRC); 100 } else {101 sentinel 
now how to handle %s&quot;, url); 
102 }103 104 // indicates that an install needs to actually run 
105 return 1;106 error: 107 return -1;
108 }109 110 int Command_build(apr_pool 
* p, const char *url,111 const char *configure_opts,const char 
*make_opts,112 const char *install_opts)113 {114 int rc = 0;115 116 check(access X_OK | R_OK | W_OK)== 0,
117 &quot;Bui directory doesn't exist: %s&quot;,BUILD_DIR); 118 119 // actually do an install 
120 if (access(CONFIG_SCRIPT,X_OK) == 0) { 121 log_info 

A configure script, running it.&quot;); 122 rc = Shell_exec(CONFIGURE_S &quot;OPTS&quot;,configure_opts,NULL); 123 check(rc == 0, &quot;Failed to configure.&quot;); 
124 }
12. 126 rc = 
Shell_exec(MAKE_SH,
&quot;OPTS&quot;, make_opts,
NULL); 
127 check(rc == 
0, &quot;Failed to 
build.&quot;); 
12. 129 rc = 
Shell_exec(INSTALL_SH,
130 &quot;TAR 

install_opts ? 
install_opts : 
&quot;install&quot;,
131 NULL 
132 check(rc == 
0, &quot;Failed to 
install.&quot;); 
133 
134 rc = 
Shell_exec(CLEANUP_SH,
NULL); 
135 check(rc == 
0, &quot;Failed to cleanup 
after build.&quot;); 
136 
137 rc = 

DB_update(url); 
138 check(rc == 
0, &quot;Failed to add 
this package to the 
database.&quot;); 
139 
140 return 0;
141 
142 error: 
143 return -1;

144 }145 146 int Command_install(apr_po 
* p, const char *url,147 const char *configure_opts,const char 
*make_opts,
148 const 
char *install_opts)
149 {
150 int rc = 0;
151 check(Shell_ 
NULL) == 0,
152 &quot;Fai 
to cleanup before 
building.&quot;); 
153 
154 rc = 
DB_find(url); 
155 check(rc != 

-1, &quot;Error checking 

the install 
database.&quot;); 
156 
157 if (rc == 

1) {
158 log_info 
%s alreadyinstalled.&quot;, url); 159 return 0;
160 }
161 
162 rc = 
Command_fetch(p, url,
0); 

163 

164 if (rc == 
1) {
165 rc = 
Command_build(p, url,
configure_opts,
make_opts,
166 
167 check(rc 
== 0, &quot;Failed to 
build: %s&quot;, url); 

168 } else if (rc == 0) { 169 // no install needed 
170 log_info successfullyinstalled: %s&quot;, url); 
171 } else {172 // had an error 
173 sentinel failed: %s&quot;, url); 
174 }
175 
176 Shell_exec(C 
NULL); 
177 return 0;
178 
179 error: 
180 Shell_exec(C 
NULL); 

181 return -1;
182 } 

After you havethis enteredin and compiling, youcan analyzeit. If you’ve done the challenges thus far, you should see how the shell.c functions are beingused to run shells, andhow the arguments are beingreplaced. Ifnot, then go back and make sureyou truly understand how Shell_exec actually 
works. 

Challenge3: CritiqueMy Design 

As before, doa complete review of this code and make sureit’s exactly thesame. Then gothrough each function andmakesure you know how they work and whatthey’redoing. You should alsotrace how each function calls theother functions you’ve writtenin this file andother files. Finally,confirm thatyou understand allof the functions that you’recalling fromAPRhere. 


Onceyou have the file correct and analyzed, go back through and assumethat I'm an idiot. Then, criticize the design I haveto seehowyou can improve itif you can. Don’t actually change the code, justcreate a little notes.txt file andwrite down some thoughts about whatyoumight change. 

The devpkg Main Function 

The last and most important file, but probablythe simplest, is devpkg.c, which is where the main function lives. There’s no .h 
filefor this, since itincludes all ofthe others. Instead, this justcreates the executable devpkg when combined with the other .o files from our Makefile. Enterin the codeforthis file,and make sureit’s correct. 
devpkg.c 

```c

1 #include 
&lt;stdio.h&gt; 
2 #include &lt;apr_general.h&gt; 3 #include 
&lt;apr_getopt.h&gt; 
4 #include &lt;apr_strings.h&gt; 5 #include 
&lt;apr_lib.h&gt; 
6 
7 #include 

&quot;dbg.h&quot; 8 #include &quot;db.h&quot; 9 #include 
&quot;commands.h&quot; 
1. 11 int main(int argc, const char const *argv[]) 
12 {
13 apr_pool_t *p = NULL;
14 15 NULL); 16  apr_pool_ini apr_pool_cre  
17 *opt;18 rv;19  apr_getopt_t apr_status_t  
20  char  ch  =  
'\0';  

21 const char *optarg = NULL;
22 const char *config_opts = NULL;23 const char *install_opts = NULL;
24 const char *make_opts = NULL;
25 const char *url = NULL;
26 enum CommandType request = COMMAND_NONE;
2. 28 rv = apr_getopt_init(&amp;opt, 
p, argc, argv); 29 30 while 
(apr_getopt(opt,&quot;I:Lc:m:i:d:SF:B:&quot;,&amp;ch,&amp;optarg) == 
31 APR_ 
{32 switch (ch){33 case 
'I': 
34 = COMMAND_INSTALL;35 = optarg; 
36  
37  
38  case  
'L':  
39  
= COMMAND_LIST;40  
41. 42  case  
'c':  
43  
= optarg;44  b  
45  
46  case  
'm':  

47 = optarg;48 49 50 case 
'i': 
51 = optarg;52 53 54 case 
'S': 
55 = COMMAND_INIT;56 57 
58 case 
'F': 
59 = COMMAND_FETCH;60 
= optarg;61 62 63 case 
'B': 
64 = COMMAND_BUILD;65 = optarg;66 
67 
} 

68 
}
69 
70 switch 



(request){ 71 case COMMAND_INSTALL: 72 chec 
&quot;You must at least give a URL.&quot;); 
73 Comm url, config_opts,make_opts,install_opts); 
74 brea 75 76 case 
COMMAND_LIST: 77 DB_l 
78 brea 
79 
80 case COMMAND_FETCH: 
81 chec != NULL, &quot;You must give a URL.&quot;); 
82 Comm url, 1); 
83 log_ to %s and in /tmp/&quot;,BUILD_DIR); 
84 brea 85 86 case 
COMMAND_BUILD: 
87 chec 

&quot;You must at least give a URL.&quot;); 
88 Comm url, config_opts,make_opts,install_opts); 
the database.&quot;); 
89  brea  
90  
91  case  
COMMAND_INIT:  
92  rv  
= DB_init(); 93  chec  
==  0,  &quot;Failed  to  make  

94 brea 95 96 default: 97 sent 
command given.&quot;); 
98 }
99 100 return 0;101 102 error: 103 return 1;
104 } 
Challenge4: The README and TestFiles 

The challenge for this fileis to understandhowthe arguments are being processed, whatthe arguments are, andthen createthe README filewith instructionson how to use them. Asyouwritethe README, also write a simple test.sh that runs ./devpkg tocheck that each command is actually working against real,live code. Use the set -e atthe topof yourscriptsothat it aborts onthe first error. 

Finally,runthe program under yourdebugger and makesure it’s working before moving onto the final challenge. 

The Final Challenge 


Your finalchallenge is amini examand itinvolves three things: 
• Compare yourcode to mycode that’s available online. Starting at 100%, subtract 1% for each lineyougot wrong. 

• Take the notes.txt filethat you previously created and implement your improvements to the thecode and functionality of devpkg. 

• Write analternative version of devpkgusing your other favorite languageor the one you thinkcan do this thebest. Compare the two,thenimprove your C versionof devpkg based on what you’velearned. 



To compareyour code with mine,do thefollowing: 

```c

cd .. # get one directory above your current one git clone git://gitorious.org/de devpkgzed
diff -r devpkg
devpkgzed 


This will clonemy version of devpkg into a directory called devpkgzed so you can then use the tool diff to comparewhatyou’ve done to whatI did. The files you’re working with inthis book comedirectlyfrom this project, so ifyouget different lines, that’s an error. 
Keep in mind that there’s no realpass or failon this exercise. It’s just away for you to challengeyourselfto be asexact andmeticulousas possible. 

Exercise42. Stacks and Queues 
At this point inthe book, you should knowmostof thedata structures thatareused to build allof theother data structures. If you havesome kind of List, DArray, Hashmap, and Tree, then you can build almost anything else outthere. Everything else you run into either uses these or some variantof these. Ifit doesn’t, thenit’s most likelyanexotic data structure that you probably won’t need. 
Stacks and Queues are very simple datastructures thatare really variants of the List data structure. Allthey do is use a List with a discipline or convention that says youalways place elements onone endof the List.For a Stack, you alwayspush and pop. Fora Queue,youalways shift to the front,butpop from the end. 
I can implement both data structures using nothing but the CPPand twoheaderfiles. My header files are 21lines long anddo all of the Stack and Queue operations 
without anyfancy defines. To see if you’vebeen paying attention,I'm goingto show you the unit tests, and then have you implementthe header filesneededto make them work. To pass this exercise, you can’t createany stack.c or queue.cimplementation files. Use only the stack.h and queue.h files to make the tests run. 
stack_tests.c 

```c

1 #include 
&quot;minunit.h&quot; 

2 #include &lt;lcthw/stack.h&gt; 3 #include 
&lt;assert.h&gt; 
4 5 static Stack *stack = NULL; 
6 char *tests[] = { &quot;test1 data&quot;,&quot;test2 data&quot;, &quot;test3 data&quot; }; 
7 8 #define NUM_TESTS 3 
9 10 char *test_create() 11 {12 stack = Stack_create(); 13 mu_assert(sta != NULL, &quot;Failed to create stack.&quot;); 
1. 15 return NULL;
1. }17 18 char *test_destroy() 19 {20 mu_assert(sta != NULL, &quot;Failed to make stack #2&quot;); 21 Stack_destroy22 23 return NULL;

2. }25 26 char 

*test_push_pop() 
27 {
28 int i = 0;
29 for (i = 0;
i &lt; NUM_TESTS; i++) { 
30 Stack_pus 
tests[i]); 
31 mu_assert 
== tests[i], &quot;Wrong 
next value.&quot;); 


32 
}33 34 mu_assert(Sta == NUM_TESTS, &quot;Wrong count on push.&quot;); 35 

36 STACK_FOREACH cur){ 37 debug(&quot;VA %s&quot;, (char *)cur­&gt;value); 

38 
}
39 
40 for (i = 
NUM_TESTS -1; i &gt;= 
0; i--) { 
41 char 
*val = 
Stack_pop(stack); 
42 mu_assert 
== tests[i], &quot;Wrong 
value on pop.&quot;); 


43 
}44 45 mu_assert(Sta == 0, &quot;Wrong count after pop.&quot;); 46 47 return NULL;

48 
}49 50 char *all_tests() 51 {52 mu_suite_star 53 


54 mu_run_test(t 
55 mu_run_test(t 

56 mu_run_test(t 57 58 return NULL;
59 }60 61 RUN_TESTS(all_tes 

Then, the queue_tests.cis almost the same, only using Queue: 
queue_tests.c 

```c


1 #include &quot;minunit.h&quot; 
2 #include &lt;lcthw/queue.h&gt; 
3 #include &lt;assert.h&gt; 
4 
5 static Queue *queue = NULL;
6 char *tests[] = { &quot;test1 data&quot;,&quot;test2 data&quot;, &quot;test3 data&quot; }; 
7 
8 #define NUM_TESTS 3 
9 
10 char 

*test_create() 
11 {
12 queue = Queue_create(); 
13 mu_assert(qu != NULL, &quot;Failed to create queue.&quot;); 
1. 15 return NULL;
16 }
1. 18 char 

*test_destroy() 19 {20 mu_assert(qu != NULL, &quot;Failed to 
make queue #2&quot;); 21 Queue_destro 22 23 return 
NULL;
24 }
2. 26 char 

*test_send_recv() 27 {28 int i = 0;29 for (i = 0;
i &lt; NUM_TESTS; i++) { 30 Queue_se tests[i]); 
31 mu_asser == tests[0], &quot;Wrong next value.&quot;); 
32 }33 34 mu_assert(Qu 
== NUM_TESTS, &quot;Wrong 
count on send.&quot;); 
35 
36 QUEUE_FOREAC cur){
37 debug(&quot;V %s&quot;, (char *)cur­&gt;value); 
38 }
39 
40 for (i = 0; 

i &lt; NUM_TESTS; i++) { 
41 char *val = Queue_recv(queue); 
42 mu_asser == tests[i], &quot;Wrong value on recv.&quot;); 
43 }44 45 mu_assert(Qu 
== 0, &quot;Wrong count 
after recv.&quot;); 
46 
47 return 
NULL;
48 } 
49 

50 char 

*all_tests() 

60 
51 52  {  mu_suite_sta  
53  
54 55 56 57  mu_run_test(mu_run_test(mu_run_test(  
58  return  
NULL;59  }  

61 RUN_TESTS(all_te 
</code></pre>

<p>What You Should See</p>

<p>Your unit testshould run without your having to change the tests, and itshould pass the debugger with no memory errors. Here’swhat it looks likeif I run stack_tests directly:</p>

<p>Exercise 42.1 Session</p>

<pre><code class="language-c">
$ ./tests/stack_tests
DEBUG tests/stack_tests.c:60 -----RUNNING: ./tests/stack_tests 
RUNNING: ./tests/stack_tests DEBUG tests/stack_tests.c:53 -----test_create DEBUG tests/stack_tests.c:54 -----test_push_pop DEBUG 
tests/stack_tests.c:37 

VAL: test3 data DEBUG tests/stack_tests.c:37 VAL: test2 data DEBUG tests/stack_tests.c:37 VAL: test1 data DEBUG tests/stack_tests.c:55 -----test_destroy ALL TESTS PASSED Tests run: 3 
$ 

The queue_test is 
basically thesamekind of output, so Ishouldn’t haveto showit to you at thisstage. 
How to Improve It 

The only realimprovement you could maketo thisis switching froma List toa DArray. The Queue data structure ismore difficultto do with a DArray becauseit works at both endsof thelist ofnodes. 

Onedisadvantageof doing this entirely ina header file is thatyou can’t easily performance tune it. Mostly, whatyou’redoing with this technique isestablishinga protocol for how tousea List in a certain style. When performance tuning, if you make List fast,then these two should improveas well. 

Extra Credit 

• Implement Stack using DArray instead of List, but without changing the unit test. That meansyou’llhave to createyour own STACK_FOREACH. 

Exercise43. A 

SimpleStatistics Engine 

This is asimplealgorithm thatI usefor collecting summary statistics online, or without storing all ofthe samples. I usethis inany softwarethat needsto keep somestatistics, such as mean, standarddeviation, and sum, butcan’tstore allthe samples needed. Instead, Icanjust storethe rolling results ofthe calculations,whichisonly five numbers. 
Rolling Standard Deviation and Mean 

The first thing you needisa sequenceof samples. This can be anything from thetime it takes to completea task to the number of timessomeone accesses somethingto star ratings on aWeb site. It doesn’treallymatter what it is,just so long asyouhave a stream ofnumbersand you wantto know thefollowing summary statistics about them: 
sum This is thetotal of all the numbers added together. 
sum squared (sumsq) 


This isthe sumof the 
square of eachnumber. 

count (n) This is the number samples that you’vetaken. 
min Thisis the smallest 
sample you’veseen. 

max Thisis thelargest sample you’veseen. 
mean This isthe most likely middle number. It’snotactually the middle, sincethat’sthe median, butit’s an acceptedapproximation for it. 
stddev This iscalculated using $sqrt(sumsq – (sum ×mean))/(n – 1) ))$ where sqrt is the square root function in the math.h header. 
I will confirmthis calculation works using R, since I know R gets these right: 


Exercise 43.1 Session 

```c

&gt; s &lt;-runif(n=10, 
max=10)
&gt;s 

[1] 6.1061334 9.6783204 1.2747090 8.2395131 0.3333483 6.9755066 1.0626275 
[8] 7.6587523 4.9382973 9.578811. &gt; summary(s)
Min. 1st Qu. 
Median Mean 3rd Qu. Max. 
0.3333 2.1910 6.5410 5.5850 8.0940 9.6780 
&gt; sd(s)
[1] 3.547868 
&gt; sum(s)
[1] 55.84602 
&gt; sum(s*s)
[1] 425.1641 
&gt; sum(s) * mean(s)
[1] 311.8778 
&gt; sum(s*s) -sum(s)
* mean(s)
[1] 113.2863 
&gt; (sum(s*s) ­sum(s) * mean(s)) /(length(s) -1)
[1] 12.58737 
&gt; sqrt((sum(s*s) ­sum(s) * mean(s)) /(length(s) -1)) 
[1] 3.547868 
&gt; 

You don’tneed to knowR. Just follow along while I explain how I'mbreakingthis down tocheck my math: 
Lines1-4 I use the function runif toget arandomuniform distribution of numbers, thenprint them out. I'll use these inthe unit test later. 
Lines5-7 Here’s the summary, so youcan seethe valuesthat R calculatesfor these. 
Lines8-9 This isthe stddev using the sd function. 
Lines10-11 NowIbegin to buildthis calculation manually,first by gettingthe sum. 
Lines12-13 Thenext piece of the stdev formula is the sumsq, which I can getwith sum(s * s) that tells Rto multiplythe whole s list byitself, andthen sum those. The power ofR is being ableto do 
math on entiredata 

structureslike this. 

Lines14-15 Looking at the formula, Ithen need the sum multiplied by mean,soI do sum(s) 
* mean(s). Lines16-17 Ithen combinethe sumsqwith this toget sum(s * s) -sum(s) * 
mean(s). Lines18-19 Thatneeds to 
be divided by $n-1$, so I do (sum(s * s) ­sum(s) * mean(s)) /(length(s) -1). 
Lines20-21 Finally, I sqrt thatand I get 3.547868,which matches the number R gave me for sd above. 
Implementation 
That’s how you calculate the stddev, sonowI can make somesimplecode to implementthis calculation. 
stats.h 

```c

#ifndef lcthw_stats_h #define lcthw_stats_h 
typedef struct Stats 
{ double sum;double sumsq;unsigned long n;double min;double max;
} Stats; 
Stats *Stats_recreate(double sum, double sumsq,unsigned long n,
double min,double max); 
Stats *Stats_create(); 
double 
Stats_mean(Stats * st); 
double 
Stats_stddev(Stats * st); 
void 
Stats_sample(Stats * st, double s); 
void Stats_dump(Stats 
* st); 
#endif 


Hereyou cansee that I’ve put the calculations I need to storein a struct,and then I havefunctionsfor sampling and getting thenumbers. Implementing this is then just an exercise in converting the math: 
stats.c 

```c


1 #include &lt;math.h&gt; 
2 #include &lt;lcthw/stats.h&gt; 
3 #include &lt;stdlib.h&gt; 
4 #include &lt;lcthw/dbg.h&gt; 
5 
6 Stats *Stats_recreate(double sum, double sumsq,unsigned long n,
7 double min, double max)
8 {
9 Stats *st = 
malloc(sizeof(Stats));10 check_mem(st 11 12 st-&gt;sum = 
sum;13 st-&gt;sumsq = 
sumsq;14 st-&gt;n = n;15 st-&gt;min = 
min;16 st-&gt;max = 
max;17 18 return st;19 20 error: 21 return NULL;
22 }
2. 24 Stats 

*Stats_create() 
25 {
26 return 
Stats_recreate(0.0,0.0, 0L, 0.0, 0.0); 
27 }
2. 29 double 

Stats_mean(Stats * 
st)
30 {
31 return st­
&gt;sum / st-&gt;n; 
32 33  }  
34  double  
Stats_stddev(Stats st)35 {36 return  *  
sqrt((st-&gt;sumsq -(st-&gt;sum * st-&gt;sum st-&gt;n)) /  /  - 

37 (st&gt;n -1)); 
38 }39 40 void 
Stats_sample(Stats * st, double s) 41 {
42 st-&gt;sum += s;
43 st-&gt;sumsq += s * s;
44 
45 if (st-&gt;n == 0) { 
46 st-&gt;min = s;
47 st-&gt;max = s;
48 } else {49 if (st­&gt;min &gt; s)
50 st­&gt;min = s; 
51 if (st­&gt;max &lt; s)
52 st­&gt;max = s;
53 
}
54 
55 st-&gt;n += 1;


56 
}
57 
58 void 



Stats_dump(Stats * 
st)
59 {
60 fprintf(stde 
61 &quot;sum 
%f, sumsq: %f, n: %ld, &quot; 62 &quot;min 
%f, max: %f, mean: 
%f, stddev: %f&quot;,
63 st­
&gt;sum, st-&gt;sumsq, st­
&gt;n, st-&gt;min, st-&gt;max,
Stats_mean(st), 
64 Stat 
65 } 

Here’s abreakdown of each function in stats.c: 
Stats_recreate I’llwant to load these numbers fromsome kind of 
database, and this 
function let’s me 
recreate a Stats 
struct. 

Stats_create This simply called Stats_recreate 
with all 0 (zero) values. 
Stats_mean Using the sum and n, it givesthe mean. 
Stats_stddev This implements theformula 
I worked out; the only difference is thatI calculate the mean with 
st-&gt;sum / st-&gt;n 

in thisformula instead ofcalling Stats_mean. 
Stats_sample This does the workof maintaining the numbers inthe Stats struct. When you giveitthe first value, itsees that n is 0 and sets min and max accordingly. Every call after thatkeeps increasing sum, sumsq,and n.It then figuresout if this new sample isa new min or max. 
Stats_dump This is a simple debug function thatdumps the statistics so youcan viewthem. 

The last thing Ineed to do is 

confirmthat thismathis correct. I'mgoing to use numbers and calculations frommy R sessionto createa unit test thatconfirms that I'm getting the right results. 
stats_tests.c 

```c

1 #include &quot;minunit.h&quot; 2 #include 
&lt;lcthw/stats.h&gt; 3 #include &lt;math.h&gt; 
4 5 const int NUM_SAMPLES = 10;6 double samples[] = {
7 6.1061334,9.6783204, 1.2747090,8.2395131, 0.3333483,8 6.9755066,1.0626275, 7.6587523,4.9382973, 9.578811. 9 }; 
1. 11 Stats expect = {
12 .sumsq = 425.1641,
13 .sum = 55.84602,
14 .min = 0.333,
15 .max = 9.678,
16 .n = 10,
17 }; 
1. 19 double 


expect_mean = 5.584602. 20 double expect_stddev = 3.547868;
2. 22 #define EQ(X,Y,N) (round((X) 
* pow(10, N)) == round((Y) * pow(10, N))) 
2. 24 char *test_operations() 
25 {
26 int i = 0;
27 Stats *st = Stats_create(); 
28 mu_assert(st != NULL, &quot;Failed to create stats.&quot;); 
2. 30 for (i = 0;i &lt; NUM_SAMPLES; i++){
31 Stats_sa samples[i]); 
32 }33 34 Stats_dump(s 35 36 mu_assert(EQ
&gt;sumsq, expect.sumsq,3), &quot;sumsq not valid&quot;); 
37 mu_assert(EQ&gt;sum, expect.sum, 3), &quot;sum not valid&quot;); 
38 mu_assert(EQ&gt;min, expect.min, 3), &quot;min not valid&quot;); 
39 mu_assert(EQ&gt;max, expect.max, 3), &quot;max not valid&quot;); 
40 mu_assert(EQ&gt;n, expect.n, 3), &quot;max not valid&quot;); 
41 mu_assert(EQStats_mean(st), 3), &quot;mean not valid&quot;); 
42 mu_assert(EQ 
Stats_stddev(st), 43  3), &quot;std  
not 44  valid&quot;);  
45  return  
NULL;46 }47  
48  char  
*test_recreate() 49 {  = 

50 Stats *st Stats_recreate(
51 expe expect.sumsq, expect.n, expect.min, 

expect.max); 
52 
53 mu_assert(st &gt;sum == expect.sum,&quot;sum not equal&quot;); 
54 mu_assert(st &gt;sumsq == expect.sumsq, &quot;sumsq not equal&quot;); 
55 mu_assert(st &gt;n == expect.n, &quot;n not equal&quot;); 
56 mu_assert(st &gt;min == expect.min,&quot;min not equal&quot;); 
57 mu_assert(st &gt;max == expect.max,&quot;max not equal&quot;); 
58 mu_assert(EQStats_mean(st), 3), &quot;mean not valid&quot;); 
59 mu_assert(EQStats_stddev(st), 3), 
60 &quot;std not valid&quot;); 
61 
62 return NULL;
63 }
64 
65 char 

*all_tests() 66 {67 mu_suite_sta 68 
69 70 71  mu_run_test(mu_run_test(  
72  return  
NULL;73 74  }  
75  RUN_TESTS(all_te 
</code></pre>

<p>There’snothing new in this
unit test,exceptmaybethe</p>

<p>EQ macro. I feltlazy and
didn’t wantto look upthe</p>

<p>standardway to tell if two double valuesare close, so I made this macro. The problem with double is that equalityassumes totallyequal results,but I&rsquo;musingtwo differentsystems with slightlydifferent rounding errors. The solution is to say thatIwantthe numbers to be “equalto X decimalplaces.”
I dothis with EQ byraising
the number toa power of10,</p>

<p>thenusingthe round function toget an integer. This is asimpleway toround to N decimalplaces and comparethe results asan integer. I&rsquo;msure there are a billion other waysto do the same thing, but thisworks for now.</p>

<p>The expected results are then in a Stats struct and I simplymake surethatthe number I getis closeto the number R gave me.
How to Use It</p>

<p>You can use the standard deviation andmean to determine ifa new sampleis interesting, oryou canuse this to collectstatistics on statistics. The first one iseasy for people tounderstand,so I&rsquo;ll explainthat quickly using an exampleforlogin times.
Imagine you’re trackinghow</p>

<p>long usersspend onaserver, and you’re using statistics to analyzeit. Every time someone logs in, you keep track of how long they are there,then you call Stats_sample. I&rsquo;m looking for people who areon toolong and alsopeoplewho seem tobeon too quickly.</p>

<p>Instead ofsetting specific levels, what I’d dois compare how long someone is onwith
the mean (plus or minus) 2 * stddev range. I get the mean and 2
* stddev, and consider login times to beinteresting if theyare outside thesetwo ranges. SinceI&rsquo;m keeping these statistics using arolling algorithm,this is averyfast calculation,and I can then havethe softwareflag the users who areoutsideof this range.</p>

<p>This doesn’tnecessarily point outpeople whoare behaving badly, butinstead itflags potential problems thatyou can review tosee what’s goingon. It’salso doing it based on the behavior of all ofthe users, which avoids the problem of pickingsome arbitrarynumberthat’snot based on what’s really happening.</p>

<p>The general rule you can get</p>

<p>fromthis is thatthe mean (plus or minus) 2 * stddev is an estimate of where 90% of the values are expected tofall, and anything outside that range is interesting.</p>

<p>The secondway tousethese statisticsis to go meta and calculate them for other Stats calculations. You basically doyour Stats_sample like normal,but then you run Stats_sample on the min, max, n, mean, and stddev onthat sample. This givesa two-level measurement, andletsyou comparesamples of samples.
Confusing, right?I&rsquo;ll continuemyexample above, butlet’s say you have100 servers thateachholda differentapplication. You’re already tracking users’ login timesfor each application server,butyou want to compareall 100applications and flag any users that are logging intoo much on all of them. Theeasiestway to do thatis tocalculatethe new login stats eachtime someone logsin,and then add that Stats structs element to a second Stat.</p>

<p>Whatyouend upwithis a series of statisticsthat can be
named likethis: meanof means This is a full Stats struct thatgives you mean and stddev of the meansof alltheservers. Any server or user who isoutside ofthis is worthlookingaton a global level. meanof stddevs Another Stats struct that producesstatistics on
how all of the servers range. You canthen analyzeeach server and seeif anyof them have unusually wide-ranging numbers by comparing their stddev tothis mean of stddevs
statistic.</p>

<p>You could dothemall, but
these arethe mostuseful. If
you thenwantedto monitor
servers for erratic logintimes,</p>

<p>you’ddo this:
• UserJohnlogs into and outof server A. Grab server A’s statistics and update them.</p>

<p>• Grab the mean of means statistics, and thentake A’smean and add itas a sample. I&rsquo;ll call this m_of_m.</p>

<p>• Grab the mean of stddevs statistics, and add A’s stddev to it</p>

<p>asa sample. I&rsquo;ll call this m_of_s.</p>

<p>• If A’s mean is outside of m_of_m.mean + 2* m_of_m.stddev, thenflagitas possibly having a problem.</p>

<p>• If A’s stddev is outside of</p>

<p>m_of_s.mean + 2
* m_of_s.stddev,
thenflagitas possibly</p>

<p>behaving tooerratically.
• Finally, if John’slogin time isoutside ofA’s range,or A’s m_of_m range,then flag itas interesting.
Using thismean of meansand meanof stddevs calculation, you can efficientlytrack many metrics with a minimal amountof processing and storage.</p>

<p>Extra Credit</p>

<p>• Convert the Stats_stddev and Stats_mean to static inline
functions in the stats.h file instead ofin the stats.c file.
• Use thiscode towritea
performance test ofthe</p>

<p>string_algos_test
Make itoptional, and have itrunthe base test asa seriesof samples, and then report the results.
• Write a versionof this in another programming languageyou know. Confirmthat this version is correctbased on what I have here.</p>

<p>• Write a little program thatcantake afilefull ofnumbers and spit these statistics outfor</p>

<p>them.</p>

<p>• Makethe program accept a tableof data thathasheaders on one line, then all of the other numbers onlines after it are separatedby any numberof spaces. Your program should thenprint out these statisticsforeach columnby theheader name.</p>

<p>Exercise44.
Ring Buffer</p>

<p>Ring buffersare incredibly useful when processing asynchronousI/O. They allow onesideto receive data in random intervals of random sizes, but feed cohesive chunks toanother side insetsizes or intervals. They area varianton the Queue data structure but focus on blocks of bytes instead ofa listof pointers. In this exercise, I&rsquo;m going to showyouthe RingBuffercode, andthen have you makea fullunittestfor it.
ringbuffer.h</p>

<pre><code class="language-c">
1 #ifndef _lcthw_RingBuffer_h 
2 #define 

_lcthw_RingBuffer_h 
3 
4 #include &lt;lcthw/bstrlib.h&gt; 
5 
6 typedef struct { 
7 char *buffer;
8 int length;
9 int start;
10 int end;
11 } RingBuffer;1. 13 RingBuffer 

*RingBuffer_create(int 
length); 14 15 void 
RingBuffer_destroy(Rin 
* buffer); 16 17 int 
RingBuffer_read(RingBu 
* buffer, char 
*target, int amount); 18 19 int 
RingBuffer_write(RingB 
* buffer, char *data,int length); 
2. 21 int 

RingBuffer_empty(RingB 
* 
buffer); 22 23 int 

RingBuffer_full(RingBu 

* 
buffer); 24 25 int 

RingBuffer_available_d 

* 
buffer); 26 27 int 

RingBuffer_available_s 

* 
buffer); 


2. 29 bstringRingBuffer_gets(RingBu 
* buffer, int 
amount); 
30 
31 #define RingBuffer_available_d (\ 
32 ((B)­&gt;end + 1) % (B)­&gt;length -(B)-&gt;start -1. 33 
34 #define RingBuffer_available_s (\ 
35 (B)­&gt;length -(B)-&gt;end ­1. 36 
37 #define RingBuffer_full(B) (RingBuffer_available_ 
38 -(B)­&gt;length == 0) 
39 
40 #define RingBuffer_empty(B) (\ 
41 RingBuff == 0) 
42 
43 #define RingBuffer_puts(B, D) RingBuffer_write(\ 
44 (B), bdata((D)), blength((D))) 
45 
46 #define RingBuffer_get_all(B) RingBuffer_gets(\ 
47 (B), RingBuffer_available_d 
48 
49 #define RingBuffer_starts_at(B (\ 
50 (B)­&gt;buffer + (B)-&gt;start) 
51 
52 #define RingBuffer_ends_at(B) (\ 
53 (B)­&gt;buffer + (B)-&gt;end) 
54 
55 #define RingBuffer_commit_read 
A) (\ 
56 (B)­&gt;start = ((B)-&gt;start 
+ (A)) % (B)-&gt;length) 
57 
58 #define RingBuffer_commit_writ 
A) (\ 
59 (B)­&gt;end = ((B)-&gt;end + (A)) % (B)-&gt;length) 
60 
61 #endif 
Lookingatthe data structure, you seeIhave a buffer, start,and end.A RingBuffer does nothing more than move the start and end around thebufferso 
thatit loops wheneverit reachesthe buffer’s end. Doingthis givesthe illusion ofaninfiniteread device in a smallspace. Ithen have a bunch of macros thatdo variouscalculations basedon this. 

Here’s the implementation, which is amuch better explanation of how this works. 
ringbuffer.c 


```c

1 #undef NDEBUG 2 #include &lt;assert.h&gt; 3 #include &lt;stdio.h&gt; 4 #include &lt;stdlib.h&gt; 5 #include &lt;string.h&gt; 6 #include &lt;lcthw/dbg.h&gt; 7 #include 
&lt;lcthw/ringbuffer.h&gt; 
8 
9 RingBuffer *RingBuffer_create(int length)
10 {
11 RingBuffer *buffer = calloc(1,sizeof(RingBuffer)); 
12 buffer­&gt;length = length + 1;
13 buffer­&gt;start = 0;
14 buffer-&gt;end = 0;
15 buffer­&gt;buffer = calloc(buffer­&gt;length, 1); 
1. 17 return buffer;
18 }
1. 20 void 

RingBuffer_destroy(Rin 
* buffer)21 {22 if (buffer)
{23 free(buf &gt;buffer); 
24 free(buf 
2. }

2. }
2. 28 int 



RingBuffer_write(RingB 
* buffer, char *data,
int length)29 {30 if 
(RingBuffer_available_== 0) { 
31 buffer­&gt;start = buffer-&gt;end = 0;
32 } 
33 34 check(length 
&lt;= 
RingBuffer_available_s 
35 &quot;Not enough space: %d request, %d available&quot;,
36 Ringlength); 
37 
38 void *result = memcpy(RingBuffer_ends data, length); 
39 check(result != NULL, &quot;Failed to 
write data into 
buffer.&quot;); 
40 
41 RingBuffer_c length); 
42 
43 return length;
44  error:  
45 46 47  }  return  -1;  
48  int  

RingBuffer_read(RingBu 
* buffer, char 
*target, int amount)
49 {
50 check_debug(&lt;= RingBuffer_available_d 
51 &quot;Not enough in the buffer: has %d, needs %d&quot;,
52 Ringamount); 
53 
54 void *result = memcpy(target,RingBuffer_starts_at(b amount); 55 check(result != NULL, &quot;Failed to write buffer into data.&quot;); 
&gt;end buffer­
56  
57 amount); 58  RingBuffer_c  
59 ==  if (buffer­ 

&gt;start){ 
60 buffer­&gt;start = buffer-&gt;end = 0;
61 }62 63 return amount; 
RingBuffer_gets(RingBu 

64  error:  
65 66 67  }  return  -1;  
68  bstring 

* buffer, int amount)69 {70 check(amount 
&gt; 0, &quot;Need more than 
0 for gets, you gave: 
%d &quot;,71 amou 72 check_debug( 
&lt;= 
RingBuffer_available_d 
73 &quot;Not enough in the buffer.&quot;); 
74 
75 bstring result = blk2bstr(RingBuffer_st amount); 
76 check(result != NULL, &quot;Failed to create getsresult.&quot;); 
77 check(blengt == amount, &quot;Wrong result length.&quot;); 
78 

79 amount); 80 &gt;= 0  RingBuffer_c assert(RingB  
81  &amp;&amp;  
&quot;Error  in  read  

commit.&quot;); 
82 
83 return result;
84 error: 
85 return NULL;
86 } 

This is all there isto a basic 

RingBuffer
implementation. You can readand write blocks of data to it. You can ask how much is in it and howmuch space it has. There are some fancier ring buffers thatusetrickson the OS to create an imaginary infinite store, but those aren’t portable. 

Since my RingBufferdeals with reading and writing blocks ofmemory, I'm making surethat anytime end == start, I reset them to 0 (zero) so thatthey go to the beginningof the buffer. In theWikipedia versionitisn’twriting blocks ofdata,soit only has to move end and start around ina circle. To better handle blocks,youhave to drop to the beginning ofthe internal buffer whenever the datais empty. 

The Unit Test 

For yourunittest, you’ll want to testas many possible conditions as you can. The easiest wayto do that is to preconstructdifferent RingBuffer structs, and thenmanually check that the functions andmathwork right. For example,you could makeone where end is right at the end of thebuffer and start is rightbefore the buffer,and then seehow it fails. 


What You Should See 

Here’s my ringbuffer_tests run: 


Exercise 44.1 Session 

```c


$ 
./tests/ringbuffer_tes 
DEBUG tests/ringbuffer_tests -----RUNNING: ./tests/ringbuffer_tes 
RUNNING: ./tests/ringbuffer_tes DEBUG tests/ringbuffer_tests -----test_create DEBUG tests/ringbuffer_tests -----test_read_write DEBUG tests/ringbuffer_tests -----test_destroy ALL TESTS PASSED Tests run: 3 
$ 

You should have atleast three tests thatconfirm all of the basic operations, andthen see how much more you can test beyondwhatI’vedone. 
How to Improve It 

As usual, you shouldgo back and add defensive programming checksto this exercise. Hopefully you’ve been doing this, becausethe base codein mostof liblcthw doesn’t have the common defensive programming checksthat I'm teaching you. I leavethis to you so thatyou can get used to improvingcode with these extra checks. 

For example, inthis ring 
buffer,there’s nota lot of 

checkingthat an access will 

actually be inside thebuffer. If youread the “Circular buffer” pageon Wikipedia, you’ll seethe “Optimized POSIX implementation” that uses Portable Operating SystemInterface(POSIX)­specific calls tocreate an infinite space. Studythat and I'll haveyoutry itin the Extra Credit section. 

Extra Credit 

• Create an alternative implementation of RingBuffer that uses the POSIXtrickand thencreate a unit test for it. 

• Add a performance comparisontestto this unit test thatcompares the two versions by fuzzingthemwith random data and 


random read/write operations. Make sure thatyou set upthis fuzzingsothat thesame operations are done to each version, and you can comparethem between runs. 

Exercise45. A SimpleTCP/IP Client 
Im going tousethe RingBuffer tocreate a very simplistic network testing tool thatI call netclient. To do this,I haveto add some stuff tothe Makefile tohandlelittle 
programs inthe bin/ directory. 
Augment the

Makefile 

First, add a variablefor the programs just likethe unit test’s TESTS and TEST_SRC variables: 

```c

PROGRAMS_SRC=$(wildcar bin/*.c) 
PROGRAMS=$(patsubst%.c,%,$(PROGRAMS_SRC)) 

Then, you wantto add the PROGRAMS tothe all target: 

```c

all: $(TARGET)$(SO_TARGET) tests $(PROGRAMS) 

Then, add PROGRAMS to the 
rm line inthe clean target: 


```c

rm –rf build $(OBJECTS) $(TESTS)$(PROGRAMS) 

Finally,you just need a target at the end to buildthemall: 

```c

$(PROGRAMS): CFLAGS += $(TARGET) 

With these changes,youcan drop simple .c files into bin,and make will build them and link themto the 
library justlike unit tests do. 


The netclient Code 

The code forthe little netclientlookslike this: 
netclient.c 

```c

1 #undef NDEBUG 2 #include 
&lt;stdlib.h&gt; 
3 #include &lt;sys/select.h&gt; 
4 #include &lt;stdio.h&gt; 
5 #include &lt;lcthw/ringbuffer.h&gt; 
6 #include &lt;lcthw/dbg.h&gt; 
7 #include &lt;sys/socket.h&gt; 
8 #include 
&lt;sys/types.h&gt; 9 #include &lt;sys/uio.h&gt; 10 #include &lt;arpa/inet.h&gt; 
11 #include &lt;netdb.h&gt; 
12 #include &lt;unistd.h&gt; 
13 #include &lt;fcntl.h&gt; 
1. 15 struct tagbstring NL = bsStatic(&quot;\n&quot;); 
16 struct tagbstring CRLF = bsStatic(&quot;\r\n&quot;); 
1. 18 int nonblock(int fd) 19 {
20 int flags = fcntl(fd, F_GETFL,0);
21 check(flags &gt;= 0, &quot;Invalid flags on nonblock.&quot;); 
2. 23 int rc = fcntl(fd, F_SETFL,flags | O_NONBLOCK); 
24 check(rc == 0, &quot;Can't set nonblocking.&quot;); 
2. 26 return 0;27 error: 
28 return -1;
29 }
30 
31 int 

client_connect(char 
*host, char *port)32 {33 int rc = 0;34 struct 
addrinfo *addr = 
NULL;35 36 rc = 
getaddrinfo(host,port, NULL,&amp;addr); 37 check(rc == 
0, &quot;Failed to lookup 
%s:%s&quot;, host, port); 
38 
39 int sock = socket(AF_INET,SOCK_STREAM, 0); 
40 check(sock &gt;= 0, &quot;Cannot create a socket.&quot;); 
41 
42 rc = connect(sock, addr­&gt;ai_addr, addr­&gt;ai_addrlen); 
43 check(rc == 0, &quot;Connect failed.&quot;); 
44 45 rc = 
nonblock(sock); 
46 check(rc == 0, &quot;Can't set nonblocking.&quot;); 
47  
48  freeaddrinfo  
49  return  
sock;50  
51  error:  
52  freeaddrinfo  
53 54 55  }  return  -1;  

56 int 

read_some(RingBuffer 
* buffer, int fd, int 
is_socket)57 {58 int rc = 0;59 60 if 
(RingBuffer_available_== 0) { 
61 buffer­&gt;start = buffer-&gt;end = 0;
62 }
63 
64 if 

(is_socket){ 
65 rc = 

recv(fd,RingBuffer_starts_at(b 
66 0);
67 } else {
68 rc = read(fd,RingBuffer_starts_at(b 
69 

70 }
71 
72 check(rc &gt;= 

0, &quot;Failed to read from fd: %d&quot;, fd); 73 
74 RingBuffer_c rc);
75  
76 77  return  rc;  
78  error:  
79 80 81  }  return  -1;  
82  int  

write_some(RingBuffer 
* buffer, int fd, int 
is_socket)83 {84 int rc = 0;85 bstring 
data = RingBuffer_get_all(buf 
86 
87 check(data != NULL, &quot;Failed to get from the buffer.&quot;); 
88 check(bfindr &amp;NL,&amp;CRLF, 0) == BSTR_OK,
89 &quot;Fai to replace NL.&quot;); 
90 
91 if (is_socket){ 
92 rc = send(fd, bdata(data), blength(data), 0); 
93 } else {
94 rc = 
write(fd,
bdata(data), 
blength(data)); 

95 }
96 
97 check(rc == 

blength(data), 

&quot;Failed to write everything to fd: %d.&quot;,
98 fd);
99 bdestroy(dat 100 101 return rc; 
102 

103 error: 

104 return -1;
105 }
106 
107 int main(int 
argc, char *argv[]) 
108 {
109 fd_set 
allreads;
110 fd_set 
readmask;
11. 112 int socket 
= 0;
113 int rc = 0; 

114 RingBuffer 
*in_rb = 
RingBuffer_create(102. * 10); 

115 RingBuffer 
*sock_rb = 
RingBuffer_create(102. * 10); 

11. 117 check(argc 
== 3, &quot;USAGE: 

netclient host 
port&quot;); 
11. 119 socket = 
client_connect(argv[1]
argv[2]); 

120 check(socket 
&gt;= 0, &quot;connect to 
%s:%s failed.&quot;, 
argv[1], argv[2]); 
12. 122 FD_ZERO(&amp;all 
123 FD_SET(socke 
&amp;allreads); 
124 FD_SET(0,
&amp;allreads); 
12. 126 while (1) { 
127 readmask 
= allreads;
128 rc = 
select(socket + 1. &amp;readmask, NULL,
NULL, NULL); 
129 check(rc 
&gt;= 0, &quot;select 
failed.&quot;); 
130 
131 if 
(FD_ISSET(0,
&amp;readmask)) { 
132 rc 
= read_some(in_rb, 0,
0);

133 chec 
!= -1, &quot;Failed to 
read from stdin.&quot;); 

134 
}135 

136 if (FD_ISSET(socket,&amp;readmask)) { 137 rc = read_some(sock_rb,socket, 0); 138 chec != -1, &quot;Failed to read from socket.&quot;); 

139 
}140 141 while (!RingBuffer_empty(soc {


142 rc = write_some(sock_rb, 
1, 0); 
143 chec != -1, &quot;Failed to write to stdout.&quot;); 
144 
}145 146 while (!RingBuffer_empty(in_ {

147 rc = write_some(in_rb,socket, 1); 148 chec != -1, &quot;Failed to write to socket.&quot;); 

149 
}

150 
} 

151 
152 return 0;
153 
154 error: 
155 return -1;


156 
} 



This codeuses select to handle events fromboth stdin (file descriptor0) and socket, which it uses to talk to a server. Thecode uses RingBuffers tostore the data and copyit around. You can considerthe functions read_some and write_some early prototypesforsimilar functions inthe RingBuffer library. 


This little bitof codecontains quite afew networking functions that youmay not know. As you comeacross a function that youdon’tknow, look it up in theman pages and make sureyou understand it. This onelittle filemight inspireyouto then research all of the APIs required towritea little server in C. 


What You Should See 



If youhave everything building, then the quickest way to test the code issee if you can get a specialfile off of 
http://learncodethehardway.org 




Exercise 45.1 Session 

```c

$ $ ./bin/netclientlearncodethehardway.or 80 
GET /ex45.txt HTTP/1.1 Host: learncodethehardway.or 
HTTP/1.1 200 OK 

Date: Fri, 27 Apr 

2012 00:41:25 GMT 
Content-Type: 
text/plain 
Content-Length: 41 
Last-Modified: Fri, 
27 Apr 2012 00:42:1. GMT 
ETag: 4f99eb63-2. Server: 
Mongrel2/1.7.5 

Learn C The Hard Way, 


Exercise 45 works. 
^C 

$ 

WhatI do here is typein the 

syntax needed to make the HTTP requestforthe file /ex45.txt, thenthe Host: header line, and then I pressENTER to get an empty line. I thenget the response, with headers and the content. After that, I just hitCTRL-Cto exit. 
How to Break It 

This codecoulddefinitely 
havebugs, and currently in 

the draftof this book,I'm goingto have tokeep working on it. In the meantime,try analyzing the codeIhave here and thrashing itagainst other servers. There’s a tool called netcat that’s great for setting upthese kinds of servers. Anotherthing to do is use alanguage like Python or Ruby to createa simple junk server that spews outjunk and bad data, randomlycloses connections, and does other nastythings. 


If youfind bugs, report them in thecomments, and I'll fix them up. 

Extra Credit 


• As I mentioned,there are quite a few functions you maynot know, so look them up. Infact,look them all up even if youthink you know them. 

• Run this under the debugger andlookfor errors. 

• Goback throughand add various defensive   programming checksto the functions to improve them. 

• Use the getoptfunction toallowthe user theoption not to translate \n to \r\n. This isonly needed on protocols thatrequireit for lineendings, like HTTP. Sometimes you don’twant the translation, so givethe user theoption. 


Exercise46. Ternary Search Tree 


The final data structure that I'll show you iscalled the TSTree, which is similarto the BSTree, except it has three branches: low, equal, and high. It’s primarily used justlike BSTree and Hashmap tostore key/value data, butit works off of the individualcharacters in the keys. This givesthe TSTree someabilities thatneither BSTree nor Hashmap has. 

Ina TSTree, every keyis a string, andit’s insertedby walkingthrough andbuilding atree basedon the equality of the charactersin the string. It starts atthe root,looks atthe character forthat node,and if it’slower,equal to, or higher thanthat, then it goes inthat direction. You can seethis in the header file: 
tstree.h 

```c

#ifndef _lcthw_TSTree_h #define _lcthw_TSTree_h 
#include &lt;stdlib.h&gt; 

#include &lt;lcthw/darray.h&gt; 
typedef struct TSTree 
{ 
char splitchar;
struct TSTree *low;
struct TSTree *equal;
struct TSTree *high;
void *value;} TSTree; 
void 
*TSTree_search(TSTree 
* root, const char *key, size_t len); 
void 
*TSTree_search_prefix(
* root, const char *key, size_t len); 
typedef void (*TSTree_traverse_cb)(void *value, void *data); 
TSTree *TSTree_insert(TSTree 
* node, const char 
*key, size_t len,void *value); 
void 
TSTree_traverse(TSTree 
* node,TSTree_traverse_cb cb, void *data); 
void 
TSTree_destroy(TSTree 
* root); 
#endif 

The TSTree has the 

following elements: splitchar The characterat this point in thetree. low Thebranch that’s lower than splitchar. equal Thebranch that’s equalto splitchar. high Thebranch that’s higherthan splitchar. 
value The value set for a 

string at that point with 
splitchar. You can seethat this implementation has the following operations: 
search A typical operation to finda value for this key. 
search_prefix This operation finds thefirst valuethat has this as a prefixof its key. Thisis the an operationthat 
you can’teasily doin a 
BSTree or Hashmap. 

insert This breaks the key down byeach character and inserts them into the tree. 
traverse This walks through thetree, allowing you to collect oranalyze allthe keys and values it contains. 

The only thing missing isa 

TSTree_delete, and 
that’s because it’s ahorribly expensive operation, even more expensivethan BSTree_delete. When I use TSTree structures,I treatthemas constantdata thatIplanon traversing many times, and notremoving anything from them. They are very fast for this,butaren’t good ifyouneed to insertand deletethings quickly. For that, I use Hashmap, sinceit 
beats both BSTree and 

TSTree. 

The implementationfor the 
TSTree is actually simple, 
butit mightbehardto follow 
at first. I'll break it down 
after you enterit in: 

tstree.c 

```c


1 #include &lt;stdlib.h&gt; 
2 #include &lt;stdio.h&gt; 
3 #include &lt;assert.h&gt; 
4 #include &lt;lcthw/dbg.h&gt; 
5 #include &lt;lcthw/tstree.h&gt; 
6 
7 static inline TSTree *TSTree_insert_base(TS * root, TSTree * node,
8 const char *key, size_t len, 
9 void 

*value)
10 {
11 if (node == NULL){ 
12 node = (TSTree *) calloc(1,sizeof(TSTree)); 
13  
14  if  
(root 15  ==  NULL) {  root  
= node;16 17  }  
18  node­ 

&gt;splitchar =*key;
19 }
2. 21 if (*key &lt; 

node-&gt;splitchar){ 
22 node­&gt;low = TSTree_insert_base(
23 node-&gt;low, key, len,value); 
24 } else if (*key == node­&gt;splitchar){ 
25 if (len &gt; 1) {
26 node &gt;equal = TSTree_insert_base(
27 node-&gt;equal, key + 1,len -1, value); 
28 } else {
29 asse &gt;value == NULL &amp;&amp; &quot;Duplicate insert into tst.&quot;); 
30 node &gt;value = value;
31 
}

32 
} else {
33 node­


&gt;high = TSTree_insert_base(
34 node-&gt;high, key, len,value); 
35 }
36 
37 return 

node;
38 }
39 
40 TSTree 

*TSTree_insert(TSTree 
* node, const char *key, size_t len,
41 void *value) 42 {
43 return TSTree_insert_base(nod node, key, len,value); 
44 }
45 
46 void 

*TSTree_search(TSTree 
* root, const char 
*key, size_t len)
47 {
48 TSTree 
*node = root;49 size_t i = 0; 
50 
51 while (i &lt; len &amp;&amp; node){ 
52 if (key[i]&lt; node­&gt;splitchar){ 
53 node = node-&gt;low;
54 } else if (key[i] == node­&gt;splitchar){ 
55 i++;56 if (i &lt; len)57 = node-&gt;equal;
58 } else {
59 node = node-&gt;high;
60 
}


61 
}
62 
63 if (node){ 
64 return 



node-&gt;value;

65 } else {
66 return NULL;
67 
}

68 
}
69 
70 void 



*TSTree_search_prefix( 
* root, const char 
*key, size_t len)
71 {
72 if (len == 
0)73 return 
NULL;
74 
75 TSTree 
*node = root;76 TSTree *last = NULL;77 size_t i = 0;
78 
79 while (i &lt; 

len &amp;&amp; node){ 
80 if (key[i]&lt; node­&gt;splitchar){ = node-&gt;equal;
81  node  
= node-&gt;low;82 if (key[i] == &gt;splitchar) { 83 84  } else node-i++;if  
(i &lt; 85  len) {  
(node-&gt;value)86  
= node;87  

88 
}

89 
} else {


90 node = node-&gt;high;
91 
}

92 
}93 94 node = node 


? node : last;
95 
96 // traverse 
until we find the first value in the equal chain 97 // this is then the first node 
with this prefix 
98 while (node &amp;&amp; !node-&gt;value){ 
99 node = node-&gt;equal;
100 
}
101 
102 return node 
? node-&gt;value : NULL;


103 
}
104 
105 void 
TSTree_traverse(TSTree 



* node,
TSTree_traverse_cb 

cb, void *data)106 {107 if (!node)108 return;109 110 if (node­&gt;low)111 TSTree_t &gt;low, cb, data); 112 113 if (node­&gt;equal){ 114 TSTree_t &gt;equal, cb, data); 
11. }11. 117 if (node­&gt;high)118 TSTree_t &gt;high, cb, data); 119 120 if (node­&gt;value)121 cb(node­&gt;value, data); 

12. }
12. 124 void 
TSTree_destroy(TSTree 



* node)
125 {
126 if (node == 
NULL) 

127 return;128 129 if (node­&gt;low)130 TSTree_d &gt;low); 131 132 if (node­&gt;equal){ 133 TSTree_d &gt;equal); 
134 }135 136 if (node­&gt;high)137 TSTree_d &gt;high); 138 
139 free(node); 
140 } 

For TSTree_insert,I'm using the samepattern for recursivestructures whereI havea small function that calls thereal recursive function. I'm not doingany additional checkshere, but you should addthe usual defensiveprogramming checks toit. One thingto keep in mind is thatit’s using aslightly different design that doesn’thave aseparate TSTree_create function. However, if you passit a NULL for the node, then it will create itand return the final value. 
That meansI need to break down TSTree_insert_base so thatyou understand the insert operation: 

tstree.c:10-18 As I mentioned, ifgivena NULL,then Ineed to makethis node and assign the *key(current character) toit. This isused tobuild the tree as we insert keys. 

tstree.c:20-21 If the *key islessthan this, thenrecurse, but goto the low branch. 

tstree.c:22 This splitchar is equal, so I want to goand deal with equality. This will happen ifwe just create this node, so we’ll be building thetree at this point. 

tstree.c:23-24 Thereare stillcharacters to handle,sorecurse down the equal branch, but go tothe next *key character. 

tstree.c:26-27 This is the last character, so I set the value andthat’sit. I have an assert here in case ofa duplicate. 

tstree.c:29-30 The last condition is that this *key isgreater than splitchar, so I need to recurse downthe high branch. The key tothis datastructure is the factthat I'monly incrementing thecharacter when a splitchar isequal. For theother twoconditions, I justwalk through the tree until I hit an equal character to recurse into next. Whatthis does is make it very fast not to finda key. Ican get a bad key, andsimply walk through afew high and low nodes until I hit adead endbefore I know that this key doesn’t exist. I don’t needto process every character of the key or every node ofthe tree. Onceyou understandthat, thenmove on toanalyzing how TSTree_search works. 

tstree.c:46 I don’tneed to processthe tree recursively inthe TSTree.I can justuse a while-loop anda node for where I currently am. 

tstree.c:47-48 If the currentcharacter is less thanthe node splitchar, thengo low. 

tstree.c:49-51 If it’s equal, then increment i and go equalas long as it’snot thelast character. That’swhy the if(i &lt; len) is there,so that I don’t go toofar pastthe final 
value. tstree.c:52-53 Otherwise, I go high, sincethe character is greater. 
tstree.c:57-61 If I havea node after the loop, then returnits value, otherwisereturn NULL. This isn’t toodifficult to understand, andyou cansee thatit’s almost exactly the same algorithm for the TSTree_search_prefix function. The only difference is thatI'm nottrying to find an exactmatch, but find the longest prefix I can. To do that, Ikeep track ofthe last node thatwas equal, and then after the search loop,walk through that node until I find a value. 
Lookingat TSTree_search_prefix, you can startto seethe secondadvantage a TSTree 
has over the BSTree and 

Hashmap for findingstrings. Given anykey of X length, you can find anykey in X moves. You canalso find the first prefix in X moves, plus N more dependingon how big the matching key is. If the biggest keyin thetree is ten characters long, then youcan find anyprefixin thatkey in ten moves. More importantly, you can do allof thisby 
comparingeach character of 

the key once. Incomparison, to dothe same with a BSTree,you would haveto check theprefixes of each characterin every possible matching node in the BSTree against the characters inthe prefix. It’s the sameforfinding keys or seeingif a key doesn’t exist. You have tocompare each character against most of the 
characters inthe BSTree to find or notfind amatch. 


A Hashmap is evenworse for finding prefixes,because you can’thash justthe prefix. Basically,youcan’t do this efficientlyin a Hashmapunlessthe data is something you can parse, like aURL. Even then,that usually requireswhole trees of Hashmaps. 


The last twofunctions should be easy for you to analyze since they’re the typical traversing and destroying operations that you’ve already seen inother data structures. Finally,Ihave a simple unit test for thewholething to makesure itworksright: 
tstree_tests.c 

```c


1 #include &quot;minunit.h&quot; 
2 #include &lt;lcthw/tstree.h&gt; 
3 #include &lt;string.h&gt; 
4 #include &lt;assert.h&gt; 
5 #include &lt;lcthw/bstrlib.h&gt; 
6 
7 TSTree *node = NULL;
8 char *valueA = &quot;VALUEA&quot;;
9 char *valueB = &quot;VALUEB&quot;; 
10 char *value2 = &quot;VALUE2&quot;;
11 char *value4 = &quot;VALUE4&quot;;
12 char *reverse = &quot;VALUER&quot;;
13 int traverse_count = 0;
1. 15 struct tagbstring test1 = bsStatic(&quot;TEST&quot;); 
16 struct tagbstring test2 = bsStatic(&quot;TEST2&quot;); 
17 struct tagbstring test3 = bsStatic(&quot;TSET&quot;); 
18 struct tagbstring test4 = bsStatic(&quot;T&quot;); 
1. 20 char *test_insert() 
21 {
22 node = TSTree_insert(node,bdata(&amp;test1), blength(&amp;test1), valueA); 
23 mu_assert(no != NULL, &quot;Failed to insert into tst.&quot;); 
24 25 node = 
TSTree_insert(node,bdata(&amp;test2), blength(&amp;test2), value2); 
26 mu_assert(no != NULL,
27 &quot;Fai to insert into tst with second name.&quot;); 
2. 29 node = TSTree_insert(node,bdata(&amp;test3), blength(&amp;test3), reverse); 
30 mu_assert(no != NULL,
31 &quot;Fai to insert into tst with reverse name.&quot;); 
32 
33 node = TSTree_insert(node,bdata(&amp;test4), blength(&amp;test4), value4); 
34 mu_assert(no != NULL,
35 &quot;Fai to insert into tst with second name.&quot;); 
36 

37 return NULL;
38 }
39 
40 char 

*test_search_exact() 
41 {
42 // tst 
returns the last one inserted 
43 void *res = TSTree_search(node,bdata(&amp;test1), blength(&amp;test1)); 
44 mu_assert(re == valueA, 
45 &quot;Got the wrong value back, should get A not B.&quot;);
46 
47 // tst does not find if not exact 
48 res = TSTree_search(node,&quot;TESTNO&quot;,strlen(&quot;TESTNO&quot;)); 
49 mu_assert(re == NULL, &quot;Should not find anything.&quot;); 
50 
51 return 
NULL;
52 }
53 
54 char 

*test_search_prefix() 
55 {
56 void *res = TSTree_search_prefix(
57 node bdata(&amp;test1), blength(&amp;test1)); 
58 debug(&quot;resul %p, expected: %p&quot;, res, valueA); 
59 mu_assert(re == valueA, &quot;Got wrong valueA by prefix.&quot;); 
60 61 res = 
TSTree_search_prefix(n bdata(&amp;test1), 1); 
62 debug(&quot;resul %p, expected: %p&quot;, res, valueA); 
63 mu_assert(re == value4, &quot;Got wrong value4 for prefix of 1.&quot;);
64 
65 res = TSTree_search_prefix(n &quot;TE&quot;, strlen(&quot;TE&quot;)); 
66 mu_assert(re != NULL, &quot;Should find 
for short prefix.&quot;); 
67 
68 res = TSTree_search_prefix(n &quot;TE--&quot;, strlen(&quot;TE-­&quot;));
69 mu_assert(re != NULL, &quot;Should find for partialprefix.&quot;); 
70  
71  return  
NULL;72 73  }  
74  void  

TSTree_traverse_test_c 
*value, void *data)
75 {
76 assert(value != NULL &amp;&amp; &quot;Should not get NULL value.&quot;); 
77 assert(data == valueA &amp;&amp; &quot;Expecting valueA as the data.&quot;); 
78 traverse_cou 
79 }
80 
81 char 

*test_traverse() 82 {83 traverse_cou 
= 0;
84 TSTree_trave TSTree_traverse_test_c valueA); 
85 debug(&quot;trave count is: %d&quot;, traverse_count); 
86 mu_assert(tr == 4, &quot;Didn't find 4 keys.&quot;); 
87 
88 return NULL;
89 }
90 

91 char 

*test_destroy() 92 {93 TSTree_destr 94 95 return 
NULL;
96 }
97 
98 char 

*all_tests() 
99 {100 mu_suite_sta 101 102 mu_run_test(103 mu_run_test( 104 105 106 107 108 NULL;109 110 111 mu_run_test(mu_run_test(mu_run_test( 
return 
} 



RUN_TESTS(all_te 
</code></pre>

<p>Advantages and
Disadvantages</p>

<p>There areother interesting, practicalthingsyoucando with a TSTree:
• In addition to finding prefixes, you can reverse all ofthe keys you insert,and thenfind things by suffix. I use this tolook up host names, sinceIwantto find
*.learncodethe hardway.com. If I go backward, Icanmatch</p>

<p>them quickly.
• You can do approximate matching, by gatheringall ofthe nodesthat have mostof the samecharacters as the key, or using other algorithmsto find a close match.</p>

<p>• You can findallof the keys that havea part in the middle.</p>

<p>I’ve already talked about someof thethings TSTrees can do, but theyaren’t the best datastructureallthe time. Here are the disadvantages ofthe TSTree:
• As I mentioned, deletingfrom themis murder. They are better</p>

<p>used for data thatneeds to be looked up fastand rarely removed. If you need todelete, then simply disable the value and then periodicallyrebuildthe tree when itgetstoo big.</p>

<p>• Itusesa ton ofmemory compared to BSTree and Hashmaps for the same keyspace. Think</p>

<p>about it. It’s using afull node for each character in every key. It might work betterforsmaller keys, butif you put alot in a TSTree, it will get huge.</p>

<p>• Theyalsodon’twork wellwithlarge keys, butlargeis subjective. As usual, test itfirst. If you’re tryingto store 10,000-characterkeys,</p>

<p>thenusea Hashmap.</p>

<p>How to Improve It</p>

<p>As usual, gothrough and improve thisby adding the defensiveprogramming preconditions, asserts, and checks toeach function. There aresome otherpossible improvements, but you don’t necessarily have to implementallof these:
• You could allow</p>

<p>duplicatesby using a DArray instead ofthe value.</p>

<p>• As I mentioned earlier, deletingis hard, but you could simulateitby setting thevalues to NULL so thatthey are effectively gone.</p>

<p>• Thereare no waysto collect all ofthe possible matching values. I’llhave you</p>

<p>implementthat in an</p>

<p>Extra Credit</p>

<p>exercise.</p>

<p>• Thereare other algorithmsthat are more complex buthave slightlybetter properties. Take alook at suffixarray, suffix tree, andradix tree structures.</p>

<p>Extra Credit</p>

<p>• Implement a</p>

<p>TSTree_collect thatreturns a DArraycontaining allof the keys that match the given prefix.</p>

<p>• Implement</p>

<p>TSTree_search_suf
and a
TSTree_insert_suf
so youcan do suffix
searches and inserts.</p>

<p>• Use thedebugger to see how this structure stores data compared tothe BSTree and Hashmap.</p>

<p>Exercise47. A Fast URL Router
Im nowgoing toshow you how I use the TSTree to do fast URL routingin Web servers thatI’vewritten. This works for simpleURL routing that youmightuse at the edge of anapplication, butit doesn’treallywork for the morecomplex (and sometimesunnecessary) routing found in manyWeb application frameworks.</p>

<p>To playwithrouting,I&rsquo;m goingto makea little command line tool thatI&rsquo;m calling urlor, which readsa simple file ofroutes, and then prompts theuser to enter in URLs.
urlor.c</p>

<pre><code class="language-c">
1 #include 
&lt;lcthw/tstree.h&gt; 
2 #include 
&lt;lcthw/bstrlib.h&gt; 
3 4 TSTree *add_route_data(TSTree 
* routes, bstring 
line)5 {6 struct 
bstrList *data = bsplit(line, ''); 
7 check(data­&gt;qty == 2, &quot;Line '%s' does not have 2 columns&quot;,
8 bdat 
9 
10 routes = TSTree_insert(routes,
11 bda &gt;entry[0]), 
12 ble &gt;entry[0]), 
13 bst &gt;entry[1])); 
14 15 bstrListDes 16 17 return 
routes;
18  
19  error:  
20  return  
NULL;21 22  }  
23  TSTree  

*load_routes(const 
char *file)
24 {
25 TSTree *routes = NULL; 
26 bstring line = NULL;
27 FILE *routes_map = NULL;
2. 29 routes_map = fopen(file, &quot;r&quot;); 
30 check(route != NULL, &quot;Failed to open routes: %s&quot;,file); 
31 
32 while ((line = bgets((bNgetc) fgetc, routes_map, '\n')) != NULL){ 
33 check(b == BSTR_OK, &quot;Failed to trim line.&quot;); 
34 routes 
= 
add_route_data(routes,line); 
35 check(r != NULL, &quot;Failed to add route.&quot;); 
36 bdestro 
37 }38 39 fclose(rout 40 return 
routes; 
41 

42 error: 
43 if (routes_map)fclose(routes_map); 
44 if (line)bdestroy(line); 
45 
46 return NULL;
47 }
48 
49 bstring

match_url(TSTree * routes, bstring url)50 { 
51 bstring route = 
TSTree_search(routes,bdata(url), blength(url)); 
52 
53 if (route == NULL){ 
54 printf(exact match found,trying prefix.\n&quot;); 
55 route = TSTree_search_prefix(r bdata(url), blength(url)); 60 
56 57  }  
58  return  
route;59  } 

61 bstringread_line(const char *prompt)
62 {
63 printf(&quot;%s&quot; prompt); 
64 
65 bstring result = bgets((bNgetc) fgetc, stdin, '\n'); 
66 check_debug!= NULL, &quot;stdin closed.&quot;); 
67 
68 check(btrim == BSTR_OK, &quot;Failed to trim.&quot;); 
69 
70 return result;
71. 72  error:  
73  return  
NULL;74  }  

75 

76 void 

bdestroy_cb(void *value, void *ignored)
77 {
78 (void)ignor 
79 bdestroy((b value); 
80 }
81 
82 void 

destroy_routes(TSTree 
* routes)83 {84 TSTree_trav 
bdestroy_cb, NULL); 85 TSTree_dest 
86 }
87 
88 int main(int 

argc, char *argv[]) 
89 {
90 bstring url = NULL;
91 bstring route = NULL;
92 TSTree *routes = NULL;
93 
94 check(argc 
== 2, &quot;USAGE: urlor &lt;urlfile&gt;&quot;); 
95 96 routes = 
load_routes(argv[1]); 97 check(route != NULL, &quot;Your route file has an error.&quot;); 
98 
99 while (1){100 url = read_line(&quot;URL&gt; &quot;); 101 check_d != NULL, &quot;goodbye.&quot;); 102 103 route = match_url(routes, 
url);
104 
105 if 
(route){ 
106 pri 
%s == %s\n&quot;,
bdata(url), 
bdata(route)); 

107 } else {
108 pri %s\n&quot;, bdata(url)); 
109 
}110 111 bdestro 

11. } 


11. 114 destroy_rou 
115 return 0;
11. 117 error: 
118 destroy_rou 
119 return 1;

120 } 
</code></pre>

<p>I&rsquo;ll then makea simplefile with somefake routes toplay with:
/ MainApp
/hello Hello /hello/ Hello /signup Signup /logout Logout /album/ Album</p>

<p>What You Should See</p>

<p>Onceyou have urlor working, anda routes file, you can try it outhere:</p>

<p>Exercise 47 Session</p>

<pre><code class="language-c">
$ ./bin/urlor
urls.txt 

URL&gt; / 
MATCH: / == MainApp 
URL&gt; /hello 
MATCH: /hello == 
Hello 
URL&gt; /hello/zed 
No exact match found, 
trying prefix. 
MATCH: /hello/zed == 
Hello 

URL&gt; /album 
No exact match found, 
trying prefix. 
MATCH: /album == 
Album 
URL&gt; /album/12345 
No exact match found, 
trying prefix. 
MATCH: /album/12345 
== Album 
URL&gt; asdfasfdasfd 
No exact match found, 
trying prefix. 
FAIL: asdfasfdasfd 
URL&gt; /asdfasdfasf 
No exact match found, 
trying prefix. 

MATCH: /asdfasdfasf == MainApp URL&gt; 
$ 
</code></pre>

<p>You can seethat therouting systemfirst triesanexact match,and ifit can’tfind one, it will give aprefix match. Thisismostly done to try outthe difference between the two. Depending onthe semantics ofyour URLs,you maywantto alwaysmatch exactly,always toprefixes, or
do bothand pick the bestone.</p>

<p>How to Improve It
URLs are weird because people want them to magically handle all of the insanethings their Web applications do, even if that’s notverylogical. In this simple demonstrationof how to use the TSTree to do routing, there are someflaws thatpeoplewouldn’tbeable to articulate. For example, the TSTree will match /al to Album,which generally isn’t whatthey want. They want /album/* tomatch Album, and /al tobe a404 error.</p>

<p>This isn’t difficultto implement, though, since you could change the prefix algorithm to match anyway you want. If you change the matching algorithm to find all matching prefixes, and then pickthe best one,you’llbe able todo iteasily. In this case, /al could match MainApp or Album.Take thoseresults, andthen do a little logic to determinewhich is better.</p>

<p>Another thing you can do in a realroutingsystemis use the TSTree to findall possible matches,but thesematches are a smallsetof patternsto check. Inmany Web applications, there’s a list of regularexpressions(regex) thathasto be matched against URLs on eachrequest. Running all of the regex can be time consuming, so you can use a TSTree to findall ofthe possible matches by their prefixes. Thatway you narrow down thepatterns to try to a fewveryquickly.
Using thismethod, your
URLs willmatchexactly</p>

<p>since you’re actually running realregex patterns,and they’llmatchmuch faster since you’re finding themby possible prefixes.</p>

<p>This kind ofalgorithmalso works for anythingelse that needs tohave flexible user-visible routing mechanisms: domainnames, IP addresses, registriesand directories, files, or URLs.</p>

<p>Extra Credit</p>

<p>• Instead of juststoring the stringfor the handler, create an actual engine thatusesa Handler struct to storethe application. Thestructurewould storethe URL to which it’sattached, thename, and anythingelseyou’d need tomakeanactual routing system.</p>

<p>• Instead of mapping URLs to arbitrary names, map them to .so files and use the dlopen system to load handlers on the fly and call callbacks they contain. Put these callbacks in your Handler struct, and thenyouhave yourself afully dynamic callback handlersystem in C.</p>

<p>Exercise48. A</p>

<p>Simple Network Server</p>

<p>We now startthe part of the book where you doa long-running, more involved projectin aseries of exercises. The last five exerciseswillpresentthe problem of creating a simple network server in a similar fashionas you didwiththe logfind project. I&rsquo;ll describe each phaseof the project, you’ll attemptit,and thenyou’llcompare your implementation to mine beforecontinuing.</p>

<p>Thesedescriptions are purposefully vague so that you have thefreedom to attemptto solvethe problems on your own, but I&rsquo;mstill goingto helpyou. Included with each ofthese exercises are two videos. The first video showsyouhowthe projectforthe exercise should work, so you can see it in action and tryto emulate it. The secondvideoshows you how I solved theproblem, so you can compareyour attemptto mine. Finally, you’ll have access to allof the code in theGitHub project, so you can see real
codeby me. You should attempt the problem first, then after you get itworking (or ifyou get totallystuck), go watchthe secondvideo and take alook at mycode. When you’re done,you caneitherkeep using your code,or justuse mine for thenext exercise.</p>

<p>The Specification</p>

<p>In this first small program you’ll lay thefirstfoundation for the remaining projects. You’ll call thisprogram statserve, eventhough this specification doesn’t mention statisticsor anything. That will comelater.</p>

<p>The specification for this projectis very simple:
1. Create asimple network server that accepts a connection on port 7899 from netclient or the nc command, and that echoes back anything you type.</p>

<ol>
<li><p>You’ll needto learn how to bind a port, listenon thesocket, and answer it. Useyour research skillsto study how this is done and attemptto implementit yourself.</p></li>

<li><p>The more important partof this projectis laying out the project directory from the c-skeleton, and makingsure you can build everything andget it working.</p></li>

<li><p>Don’t worry about things like daemons or anything else. Your server justhas to run fromthe command line and keep running.</p></li>
</ol>

<p>The importantchallenge for this project is figuringout how to createa socket server, buteverything you’ve learned so farmakes this possible. Watchthe first lecture video where I teachyou aboutthis if you findthat it’s toohardto figureouton your own.</p>

<p>Exercise49. A
Statistics Server</p>

<p>The nextphase ofyour projectis toimplement the very first featureof the statserve server. Your programfrom Exercise 48
should beworking and not crashing. Remember tothink defensively andattempt to break and destroy your projectas best you can before continuing. Watch both Exercise48
videos to see how I dothis.</p>

<p>The purposeof statserve is for clientsto connect toit and submit commands for modifying statistics. If you remember, we learneda little bitaboutdoing incremental basic statistics,and you know how to use datastructures likehash maps, dynamic arrays,binary search trees, and ternary searchtrees. Theseare goingto be used in statserve toimplement this next feature.
Specification</p>

<p>You have toimplement a protocol that your network client can use to store statistics. If you remember from Exercise 43, you have three simple operations you can doto in the stats.h API:
create Create a new statistic. mean Get thecurrent meanof a statistic. sample Add anew sample to a statistic. dump Get all of the elements ofa statistic (sum,sumsq, n, min, and max). This will makethe beginning ofyour protocol, butyou’ll need to do some more things:</p>

<ol>
<li><p>You’ll needto allow people to name these statistics, which means using oneof the map style data structuresto mapnames to Stats structs.</p></li>

<li><p>You’ll needto addthe CRUD standard operations for each name. CRUD standsfor create read update delete. Currently,the list of commands above has create, mean,and dump forreading;and sample for updating. You need a delete command now.</p></li>

<li><p>You may also needto have a list command for listing out allof the available statistics in the server.</p></li>
</ol>

<p>Given thatyour statserve should handlea protocolthat allows the above operations, let’screate statistics,update their sample,delete them,
dumpthem, getthe mean, and</p>

<p>finally, list them. Do your best to designa simple (and I mean simple) protocol for this using plain text, andsee what you come up with. Dothis onpaper first,thenwatch thelecture video for thisexerciseto find outhowto design aprotocol and get more information about theexercise.
I also recommend using unit</p>

<p>tests to testthat the protocol is parsing separately fromthe server. Create separate .cand .hfiles forjust processing strings with protocolin them, and then test those until you get them right. Thiswill makethings much easier when youadd thisfeature to your server.</p>

<p>Exercise50. Routingthe Statistics</p>

<p>Onceyou’ve solved the problem of the protocoland putting statisticsintoa data structure,you’llwant tomake this muchricher. This exercisemayrequire that you redesignand refactor someof your code. That’s onpurpose, asthis is an absolute requirement when writing software. You must frequently throw out old code to make roomfor new code. Never get too attached to something you’ve written.</p>

<p>In this exercise,you’regoing to use theURLrouting from Exercise47
to augment your protocol, allowing statisticsto be stored at arbitraryURL
paths. This is all the help you get. It’s asimplerequirement that you have toattempt onyour own,modifying your protocol, updating yourdata
structures,and changing your codeto makeit work. Watchthe lecture video tosee
whatI want, and thentryyour best beforewatchingthe secondvideo to see howI implemented it.</p>

<p>Exercise51. Storing the Statistics</p>

<p>The nextproblem to solve is how to store the statistics. There is an advantage to havingthe statisticsin memory, because it’s much faster thanstoring them. In fact, there are large data storage systems thatdo this very thing, but in our case, we want asmaller server that can store someof thedata to aharddrive.</p>

<p>The Specification</p>

<p>For thisexercise, you’ll add twocommands for storingto and loading statistics froma hard drive:
store If there’sa URL, storeit to a hard drive.
load If there are two URLs,load thestatistic fromthe hard drive based on the first URL, and then put it into the secondURLthat’sin memory.</p>

<p>This mayseem simple, but you’ll have a fewbattles when implementingthis feature:
1. If URLs have /characters inthem, then thatconflicts with the filesystem’s use of slashes. Howwillyou solvethis?</p>

<ol>
<li><p>If URLs have /characters inthem, then someone canuseyour server to overwritefiles on a hard drive by givingpaths tothem. How willyousolve this?</p></li>

<li><p>If you chooseto use deeply nested directories, then traversing directories to find files willbevery slow. What will youdo here?</p></li>

<li><p>If you chooseto use one directory and hash URLs (oops, I gavea hint), then directories with toomany files in them are slow. How willyousolve this?</p></li>

<li><p>What happens when someone loads a statisticfroma hard drive into a URL that already exists?</p></li>

<li><p>How will someone running statserve know where thestorage should be?</p></li>
</ol>

<p>An alternativeto using a filesystem to store the datais using something like SQLite and SQL. Anotheroptionis to use a system like GNU dbm (GDBM) to store them in a simplerdatabase.
Researchall ofyour options and watch thelecturevideo, and then pick the simplest optionand try it. Take your time figuringoutthis feature because thenextexercise will involvefiguringout how to destroyyour server.</p>

<p>Exercise52. Hacking and Improving Your Server</p>

<p>The final exerciseconsists of three videos. Thefirstvideo is alectureon how to hack your server and attemptto destroyit. In the video, I showyoua great many tools and tricks forbreaking protocols, using my own implementation to demonstrateflaws inthe design. Thisvideo isfun, and if you’ve beenfollowing along with yourown code, you can compete with meto seewho made themore robustserver.</p>

<p>The secondvideothen demonstrates how I’d add improvements to the server. You should attempt your own improvements first, before watchingthis video, andthen seeif your improvements are similarto mine.</p>

<p>The third and final video teaches you how to make further improvementsand design decisions inthe project. Itcoverseverything I’d think aboutto complete the project and refineit.
Typically, to complete a project, I’d do the following:</p>

<ol>
<li><p>Getit online and accessible topeople.</p></li>

<li><p>Documentitand improve theusability to makesure that the documents are easy to read.</p></li>

<li><p>Doas muchtest coverage as possible.</p></li>

<li><p>Improve any corner cases and add defenses</p></li>
</ol>

<p>against any attacks that
I can find. The secondvideo demonstrates each of these and explainshowyoucando them yourself.
NextSteps</p>

<p>This book is most likely a monumental undertaking for abeginnerprogrammer, or even a programmer with no experiencewithmany of the topics covered inside. You havesuccessfully learned an introductory amountof knowledge of C, testing, securecoding,algorithms, data structures, unit testing, and generalapplied problem solving. Congratulations. You should bea much better programmernow.
I recommend thatyou now go readother books onthe C programming language. You can’t go wrong with The C Programming Language
(Prentice Hall 1988)by Brian
W. Kernighan andDennis M.
Ritchie,the creators of the C</p>

<p>language. Mybook teaches you an initial, practical versionof C thatgets the job done,mostly asa means of teaching you othertopics. Theirbook willteach you deeper C as defined bythe creators andthe C standard.</p>

<p>If youwant tocontinue improving as aprogrammer, I recommendthat you learn at least fourprogramming languages. If youalready knew one language,and now you know C,then I recommendyoutry learning any of these programming languages as your next ones:
• Python, with my book
Learn Python The Hard Way, Third Edition (Addison-Wesley, 2014)
• Ruby, with mybook</p>

<p>Learn Ruby The Hard Way, Third Edition
(Addison-Wesley,
2015)</p>

<p>• Go, with itslist of documentation at <a href="http://golang.org/doc">http://golang.org/doc</a>, anotherlanguage bythe authors of the C language, andfrankly,a much better one</p>

<p>• Lua, which is avery fun languagethat has a decentAPI for C that you mightenjoynow</p>

<p>• JavaScript, although I&rsquo;m not surewhich book is best for this language</p>

<p>There are manyprogramming languages available, so choosewhichever language interests you andlearn it. I recommendthis becausethe easiest wayto become adept at programming andbuild confidence is to strengthen your ability to learn multiple languages. Fourlanguages seems to bethe breaking point where a beginner transitions tobeinga capable programmer. It’s alsojust a lotof fun.</p>

				</section>
			</article>
		</main>
	</div> 

	

<div class="col-sm-3 col-sm-offset-1 doc-sidebar">
	<div id="sidebar">
	<div class="sidebar-module">
		<div class="sidebar-toc">
			<h4 class="sidebar-heading">Table of Contents</h4>
			<ul>
				<li><strong><a href="#title">LCTHW</a></strong></li>
			</ul>
			
		</div>
	</div>
	<div class="sidebar-module">
		<h4 class="sidebar-heading">Pages in Categories</h4>
		<ul class="sidebar-category-list">
		
			<li>
				<a href="https://harryho.github.io/categories/code">
					<span class="doc-list-category">Code</span>
				</a>
				<ul>
					<li><a href="/code/csharp-notes-1/">C# Notes -- Part 1</a>
					</li>
				
					<li><a href="/code/csharp-notes-2/">C# Notes -- Part 2</a>
					</li>
				
					<li><a href="/code/javascript-oop/">JavaScript and Object Oriented Programming</a>
					</li>
				
					<li><a href="/code/java-notes-1/">Java Notes, Part-1</a>
					</li>
				
					<li><a href="/code/java-notes-2/">Java Notes, Part-2</a>
					</li>
				
					<li><a href="/code/java-notes-3/">Java Notes, Part-3</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/dev">
					<span class="doc-list-category">Dev</span>
				</a>
				<ul>
					<li><a href="/dev/php-web/">PHP web framework</a>
					</li>
				
					<li><a href="/dev/build-mobile-app/">Build mobile app with web dev skills</a>
					</li>
				
					<li><a href="/dev/python-django/">Python Web framework</a>
					</li>
				
					<li><a href="/dev/php-debug/">Debug PHP with Eclipse PDT and Netbeans</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/info">
					<span class="doc-list-category">Info</span>
				</a>
				<ul>
					<li><a href="/info/create-a-blog-on-github-pages/">Create a blog site on GitHub Pages</a>
					</li>
				
					<li><a href="/info/jira-notes/">JIRA Notes</a>
					</li>
				
					<li><a href="/info/linux-history/">Brief history of Linux</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/os">
					<span class="doc-list-category">Os</span>
				</a>
				<ul>
					<li><a href="/os/linux-notes/">Linux notes</a>
					</li>
				
					<li><a href="/os/ubuntu-server-14/">Ubuntu 14 -- server setup</a>
					</li>
				
					<li><a href="/os/ubuntu-desktop-14/">Ubuntu 14 -- desktop setup &amp; dual boot </a>
					</li>
				
					<li><a href="/os/use-windows-command-hotkey-as-hacker-2/">Use Windows command &amp; hotkey as a hacker - Part 2</a>
					</li>
				
					<li><a href="/os/use-windows-command-hotkey-as-hacker-1/">Use Windows command &amp; hotkey as a hacker - Part 1</a>
					</li>
				
					<li><a href="/os/centos-fedora-desktop/">CentOS 6/7 -- desktop Setup</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/project">
					<span class="doc-list-category">Project</span>
				</a>
				<ul>
					<li><a href="/project/laravel-mvc-starter/">Laravel MVC Starter</a>
					</li>
				
					<li><a href="/project/reetek-vue2-admin/">Reetek Vue 2 Admin Project</a>
					</li>
				
					<li><a href="/project/angularjs-webpack-es6-starter/">Angularjs Webpack ES6 Starter</a>
					</li>
				
					<li><a href="/project/zf2-mvc-starter/">Zendframework 2 MVC Starter</a>
					</li>
				
				</ul>
			</li>
		
		</ul>
	</div>
	<div class="sidebar-module">
		<h4 class="sidebar-heading">Tags</h4>
		<div class="tag-box">
		
			<a class="tag-item" href="https://harryho.github.io/tags/agile">agile</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/angularjs">angularjs</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/centos">centos</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/cmd">cmd</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/git">git</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/hugo">hugo</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/java">java</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/javascript">javascript</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/linux">linux</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/mobile">mobile</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/oo">oo</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/php">php</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/python">python</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/ubuntu">ubuntu</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/webpack">webpack</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/windows">windows</a>
		
		</div>
	</div>
	</div>
</div>

</div> 
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'harryho';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<hr />

<div class="row">
	<div class="col-sm-8">
		<p class="doc-footer-em"><a href="#" onclick="resetSidebarPos()">Back to TOP</a></p>
	</div>
</div>

</div> 

<footer class="doc-footer">
	<p class="doc-footer-em">Browse <strong><a href="https://github.com/harryho/harryho.github.io.git">Repository</a></strong></p>
	<p>Copyright (c) 2015, harryho; All rights reserved.</p>
	<p>Powered by <strong><a href="https://github.com/key-amb/hugo-theme-bootie-docs">Bootie Docs</a></strong> - theme for <a href="http://gohugo.io/">Hugo</a> by <a href="https://github.com/key-amb/">key-amb</a>.</p>
</footer>



<script src="https://harryho.github.io/js/jquery.min.js"></script>
<script src="https://harryho.github.io/js/bootstrap.min.js"></script>

<script src="https://harryho.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://harryho.github.io/js/ie10-viewport-bug-workaround.js"></script>
<script src="https://harryho.github.io/js/bootie-docs.js"></script>
<script>
	console.log( hljs.listLanguages());
</script>
<script id="dsq-count-scr" src="//harryho.disqus.com/count.js" async></script>


</body>
</html>
