<!DOCTYPE html> 
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="google-site-verification" content="fB00vw3NhrcDODZ6PcjUHM1Pz1j4T-eZ0Ja7ffDx-aU" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="alternate" href="/index.xml" type="application/rss+xml" title="Hello World">
    <link rel="icon" href="https://harryho.github.io/favicon.ico">
    <title>DIP3 Notes - Hello World</title>
    
    <link rel="stylesheet" href="https://harryho.github.io/css/highlight/github.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/theme.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/bootie-docs.css">
</head>

<body role="document">
    
    <nav class="navbar navbar-inverse navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://harryho.github.io/">Hello World</a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li ><a href="https://harryho.github.io/">Home</a></li>
                       
                    <li ><a href="https://harryho.github.io/info/">Info</a></li>
                     
                    <li ><a href="https://harryho.github.io/code/">Code</a></li>
                     
                    <li ><a href="https://harryho.github.io/dev/">Dev</a></li>
                     
                    <li ><a href="https://harryho.github.io/os/">OS</a></li>
                     
                    <li ><a href="https://harryho.github.io/project/">Project</a></li>
                      
                </ul>
                
                <form class="navbar-form navbar-left" role="search" action="https://www.google.co.jp/search" method="get">
                    <div class="input-group doc-search-form">
                        <input type="hidden" name="as_sitesearch" value="harryho.github.io">
                        <input type="text" name="as_q" class="search-query doc-search-input-text" placeholder="Search Site">
                        <span class="input-group-addon input-group-btn doc-search-input-btn " >
							<button class="btn" type="submit"><span class="glyphicon glyphicon-search"></span></button>
                        </span>
                    </div>
                </form>
                
            </div>
            
        </div>
    </nav>
    <div class="container">


<div class="row">
	<div class="col-sm-8 doc-main">
		<main role="main">
			<article>
				<a id="title"></a>
				<h1 class="doc-entry-title">DIP3 Notes</h1>
				<div class="doc-entry-meta">
					
				</div>
				<section>
					

<p>This document was created with Prince, a great way of getting web content onto paper.</p>

<p>CHAPTER -1. WHAT’S NEW IN “DIVE INTO PYTHON 3”</p>

<p>. Isn’t this where we came in? .
— Pink Floyd, The Wall
-1.1. A.K.A. “THE MINUS LEVEL”</p>

<p>Are you already a Python programmer? Did you read the original “Dive Into Python”? Did you buy it on paper? (If so, thanks!) Are you ready to take the plunge into Python 3? … If so, read on. (If none of that is true, you’d be better off starting at the beginning.) Python 3 comes with a script called 2to3. Learn it. Love it. Use it. Porting Code to Python 3 with 2to3 is a reference of all the things that the 2to3 tool can fix automatically. Since a lot of those things are syntax changes, it’s a good starting point to learn about a lot of the syntax changes in Python 3. (print is now a function, <code>x</code> doesn’t work, &amp;c.)</p>

<p>Case Study:
Porting chardet to Python 3 documents my (ultimately successful) effort to port a non-trivial library from Python 2 to Python 3. It may help you; it may not. There’s a fairly steep learning curve, since you need to kind of understand the library first, so you can understand why it broke and how I fixed it. A lot of the breakage centers around strings. Speaking of which… Strings. Whew. Where to start. Python 2 had “strings” and “Unicode strings.” Python 3 has “bytes” and “strings.” That is, all strings are now Unicode strings, and if you want to deal with a bag of bytes, you use the new bytes type. Python 3 will never implicitly convert between strings and bytes, so if you’re not sure which one you have at any given moment, your code will almost certainly break. Read the Strings chapter for more details.</p>

<p>Bytes vs. strings comes up again and again throughout the book.</p>

<p>• In Files, you’ll learn the difference between reading files in “binary” and “text” mode. Reading (and writing!) files in text mode requires an encoding parameter. Some text file methods count characters, but other methods count bytes. If your code assumes that one character == one byte, it will break on multi-byte characters.</p>

<p>• In HTTP Web Services, the httplib2 module fetches headers and data over HTTP. HTTP headers are returned as strings, but the HTTP body is returned as bytes.</p>

<p>• In Serializing Python Objects, you’ll learn why the pickle module in Python 3 defines a new data format that is backwardly incompatible with Python 2. (Hint: it’s because of bytes and strings.) Also, Python 3 supports serializing objects to and from JSON, which doesn’t even have a bytes type. I’ll show you how to hack around that.</p>

<p>• In Case study: porting chardet to Python 3, it’s just a bloody mess of bytes and strings everywhere.</p>

<p>Even if you don’t care about Unicode (oh but you will), you’ll want to read about string formatting in Python 3, which is completely different from Python 2. Iterators are everywhere in Python 3, and I understand them a lot better than I did five years ago when I wrote “Dive Into Python”. You need to understand them too, because lots of functions that used to return lists in Python 2 will now return iterators in Python 3. At a minimum, you should read the second half of the Iterators chapter and the second half of the Advanced Iterators chapter. By popular request, I’ve added an appendix on Special Method Names, which is kind of like the Python docs “Data Model” chapter but with more snark. When I was writing “Dive Into Python”, all of the available XML libraries sucked. Then Fredrik Lundh wrote ElementTree, which doesn’t suck at all. The Python gods wisely incorporated ElementTree into the standard library, and now it forms the basis for my new XML chapter. The old ways of parsing XML are still around, but you should avoid them, because they suck! Also new in Python — not in the language but in the community — is the emergence of code repositories like The Python Package Index (PyPI). Python comes with utilities to package your code in standard formats and distribute those packages on PyPI. Read Packaging Python Libraries for details.</p>

<p>CHAPTER 0. INSTALLING PYTHON</p>

<p>. Tempora mutantur nos et mutamur in illis. (Times change, and we change with them.) .
— ancient Roman proverb</p>

<p>0.1. DIVING IN
Before you can start programming in Python 3, you need to install it. Or do you?</p>

<p>0.2. WHICH PYTHON IS RIGHT FOR YOU?</p>

<p>If you&rsquo;re using an account on a hosted server, your ISP may have already installed Python 3. If you’re running Linux at home, you may already have Python 3, too. Most popular GNU/Linux distributions come with Python 2 in the default installation; a small but growing number of distributions also include Python 3. Mac OS X includes a command-line version of Python 2, but as of this writing it does not include Python 3. Microsoft Windows does not come with any version of Python. But don’t despair! You can point-and-click your way through installing Python, regardless of what operating system you have.</p>

<p>The easiest way to check for Python 3 on your Linux or Mac OS X system is from the command line. Once you’re at a command line prompt, just type python3 (all lowercase, no spaces), press ENTER, and see what happens. On my home Linux system, Python 3.1 is already installed, and this command gets me into the Python interactive shell.
mark@atlantis:~$ python3
Python 3.1 (r31:73572, Jul 28 2009, 06:52:23)
[GCC 4.2.4 (Ubuntu 4.2.4-1ubuntu4)] on linux2
Type &ldquo;help&rdquo;, &ldquo;copyright&rdquo;, &ldquo;credits&rdquo; or &ldquo;license&rdquo; for more information.
&gt;&gt;&gt;</p>

<p>(Type exit() and press ENTER to exit the Python interactive shell.)
My web
hosting
provider
also runs Linux and provides command-line access, but my server does not have Python 3 installed. (Boo!)
mark@manganese:~$ python3
bash: python3: command not found</p>

<p>So back to the question that started this section, “Which Python is right for you?” Whichever one runs on the computer you already have.
[Read on for Windows instructions, or skip to Installing on Mac OS X, Installing on Ubuntu Linux, or Installing on Other Platforms.]</p>

<p>.</p>

<p>0.3. INSTALLING ON MICROSOFT WINDOWS
Windows comes in two architectures these days: 32-bit and 64-bit. Of course, there are lots of different versions of Windows — XP, Vista, Windows 7 — but Python runs on all of them. The more important distinction is 32-bit v. 64-bit. If you have no idea what architecture you’re running, it’s probably 32-bit.
Visit python.org/download/ and download the appropriate Python 3 Windows installer for your
architecture. Your choices will look something like this:</p>

<p>• Python 3.1 Windows installer (Windows binary — does not include source)</p>

<p>• Python 3.1 Windows AMD64 installer (Windows AMD64 binary — does not include source)</p>

<p>I don’t want to include direct download links here, because minor updates of Python happen all the time and I don’t want to be responsible for you missing important updates. You should always install the most recent version of Python 3.x unless you have some esoteric reason not to.</p>

<p>Once your download is complete, double-click the .msi file. Windows will pop up a security alert, since you’re about to be running executable code. The official Python installer is digitally signed by the Python Software Foundation, the non-profit corporation that oversees Python development. Don’t accept imitations! Click the Run button to launch the Python 3 installer.</p>

<p>The first question the installer will ask you is whether you want to install Python 3 for all users or just for you. The default choice is “install for all users,” which is the best choice unless you have a good reason to choose otherwise. (One possible reason why you would want to “install just for me” is that you are installing Python on your company’s computer and you don’t have administrative rights on your Windows account. But then,   why are you installing Python without permission from your company’s Windows administrator? Don’t get me in trouble here!)</p>

<p>Click the Next button to accept your choice of installation type.
Next, the installer will prompt you to choose a destination directory. The default for all versions of Python 3.1.x is C:\Python31\, which should work well for most users unless you have a specific reason to change it. If you maintain a separate drive letter for installing applications, you can browse to it using the embedded controls, or simply type the pathname in the box below. You are not limited to installing Python on the C: drive; you can install it on any drive, in any folder.</p>

<p>Click the Next button to accept your choice of destination directory.</p>

<p>The next page looks complicated, but it’s not really. Like many installers, you have the option not to install every single component of Python 3. If disk space is especially tight, you can exclude certain components.</p>

<p>. Register Extensions allows you to double-click Python scripts (.py files) and run them. Recommended but not required. (This option doesn’t require any disk space, so there is little point in excluding it.)</p>

<p>. Tcl/Tk is the graphics library used by the Python Shell, which you will use throughout this book. I strongly recommend keeping this option.</p>

<p>. Documentation installs a help file that contains much of the information on docs.python.org. Recommended if you are on dialup or have limited Internet access.</p>

<p>. Utility Scripts includes the 2to3.py script which you’ll learn about later in this book. Required if you want to learn about migrating existing Python 2 code to Python 3. If you have no existing Python 2 code, you can skip this option.</p>

<p>. Test Suite is a collection of scripts used to test the Python interpreter itself. We will not use it in this book, nor have I ever used it in the course of programming in Python. Completely optional.</p>

<p>If you’re unsure how much disk space you have, click the Disk Usage button. The installer will list your drive letters, compute how much space is available on each drive, and calculate how much would be left after installation.
Click the OK button to return to the “Customizing Python” page.</p>

<p>If you decide to exclude an option, select the drop-down button before the option and select “Entire feature will be unavailable.” For example, excluding the test suite will save you a whopping 7908KB of disk space.
Click the Next button to accept your choice of options.</p>

<p>The installer will copy all the necessary files to your chosen destination directory. (This happens so quickly, I had to try it three times to even get a screenshot of it!)</p>

<p>Click the Finish button to exit the installer.</p>

<p>Start menu, there should be a new item called Python 3.1. Within that, there is a program called IDLE. Select this item to run the interactive Python Shell.
[Skip to using the Python Shell]</p>

<p>.</p>

<p>0.4. INSTALLING ON MAC OS X
All modern Macintosh computers use the Intel chip (like most Windows PCs). Older Macs used PowerPC chips. You don’t need to understand the difference, because there’s just one Mac Python installer for all Macs.
Visit python.org/download/ and download the Mac installer. It will be called something like Python 3.1 Mac Installer Disk Image, although the version number may vary. Be sure to download version 3.x, not 2.x.</p>

<p>Your browser should automatically mount the disk image and open a Finder window to show you the contents. (If this doesn’t happen, you’ll need to find the disk image in your downloads folder and double-click to mount it. It will be named something like python-3.1.dmg.) The disk image contains a number of text files (Build.txt, License.txt, ReadMe.txt), and the actual installer package, Python.mpkg.
Double-click the Python.mpkg installer package to launch the Mac Python installer.</p>

<p>Click the
Continue</p>

<p>button to move along.</p>

<p>upgrade.
Apple no
longer provides security updates for your operating system, and your computer is probably at risk if you
ever go online. Also, you can’t run Python 3.</p>

<p>Click the Continue button to advance.</p>

<p>Python has had a number of owners and sponsors throughout its history, each of which has left its mark on the software license. But the end result is this: Python is open source, and you may use it on any platform, for any purpose, without fee or obligation of reciprocity.
Click the Continue button once again.</p>

<p>source, you are really “agreeing” that the license is granting you additional rights, rather than taking them away.
Click the Agree button to continue.</p>

<p>In truth, I have never had the need to change the install location.
From this screen, you can also customize the installation to exclude certain features. If you want to do this, click the Customize button; otherwise click the Install button.</p>

<p>Framework. This is the guts of Python, and is both selected and disabled because it must be installed.</p>

<p>. GUI Applications includes IDLE, the graphical Python Shell which you will use throughout this book. I strongly recommend keeping this option selected.</p>

<p>. UNIX command-line tools includes the command-line python3 application. I strongly recommend keeping this option, too.</p>

<p>. Python Documentation contains much of the information on docs.python.org. Recommended if you are on dialup or have limited Internet access.</p>

<p>. Shell profile updater controls whether to update your shell profile (used in Terminal.app) to ensure that this version of Python is on the search path of your shell. You probably don’t need to change this.</p>

<p>. Fix system Python should not be changed. (It tells your Mac to use Python 3 as the default Python for all scripts, including built-in system scripts from Apple. This would be very bad, since most of those scripts are written for Python 2, and they would fail to run properly under Python 3.)</p>

<p>Click the Install button to continue.</p>

<p>administrative password. There is no way to install Mac Python without administrator privileges. Click the OK button to begin the installation.</p>

<p>Click the Close button to exit the installer.
Assuming you didn’t change the install location, you can find the newly installed files in the Python 3.1 folder within your /Applications folder. The most important piece is IDLE, the graphical Python Shell.
Double-click IDLE to launch the Python Shell.</p>

<p>The Python Shell is where you will spend most of your time exploring Python. Examples throughout this book will assume that you can find your way into the Python Shell.
[Skip to using the Python Shell]</p>

<p>.</p>

<p>0.5. INSTALLING ON UBUNTU LINUX
Modern Linux distributions are backed by vast repositories of precompiled applications, ready to install. The exact details vary by distribution. In Ubuntu Linux, the easiest way to install Python 3 is through the Add/ Remove application in your Applications menu.</p>

<p>When you first launch the Add/Remove application, it will show you a list of preselected applications in different categories. Some are already installed; most are not. Because the repository contains over 10,000 applications, there are different filters you can apply to see small parts of the repository. The default filter is “Canonical-maintained applications,” which is a small subset of the total number of applications that are officially supported by Canonical, the company that creates and maintains Ubuntu Linux.</p>

<p>Python 3 is not maintained by Canonical, so the first step is to drop down this filter menu and select “All
Open Source applications.”</p>

<p>Once you’ve widened the filter to include all open source applications, use the Search box immediately after the filter menu to search for Python 3.</p>

<p>Now the list of applications narrows to just those matching Python 3. You’re going to check two packages. The first is Python (v3.0). This contains the Python interpreter itself.</p>

<p>The second package you want is immediately above: IDLE (using Python-3.0). This is a graphical Python Shell that you will use throughout this book.
After you’ve checked those two packages, click the Apply Changes button to continue.</p>

<p>Python-3.0) and Python (v3.0).
Click the Apply button to continue.
The package manager will show you a progress meter while it downloads the necessary packages from Canonical’s Internet repository.</p>

<p>Once the packages are downloaded, the package manager will automatically begin installing them.</p>

<p>Python Shell, or
click the Close button to exit the package manager.</p>

<p>You can always relaunch the Python Shell by going to your Applications menu, then the Programming
submenu, and selecting IDLE.</p>

<p>Python Shell is where you will spend most of your time exploring Python. Examples throughout this book will assume that you can find your way into the Python Shell.
[Skip to using the Python Shell]</p>

<p>.</p>

<p>0.6. INSTALLING ON OTHER PLATFORMS</p>

<p>Python 3 is available on a number of different platforms. In particular, it is available in virtually every Linux, BSD, and Solaris-based distribution. For example, RedHat Linux uses the yum package manager. FreeBSD has its ports
and
packages
collection, SUSE has zypper, and Solaris has pkgadd. A quick web search for Python 3 + your operating system should tell you whether a Python 3 package is available, and if so, how to install it.</p>

<p>.</p>

<p>0.7. USING THE PYTHON SHELL
The Python Shell is where you can explore Python syntax, get interactive help on commands, and debug short programs. The graphical Python Shell (named IDLE) also contains a decent text editor that supports Python syntax coloring and integrates with the Python Shell. If you don’t already have a favorite text editor, you should give IDLE a try.
First things first. The Python Shell itself is an amazing interactive playground. Throughout this book, you’ll see examples like this:
&gt;&gt;&gt; 1 + 1
2</p>

<p>The three angle brackets, &gt;&gt;&gt;, denote the Python Shell prompt. Don’t type that part. That’s just to let you know that this example is meant to be followed in the Python Shell.
1+1 is the part you type. You can type any valid Python expression or command in the Python Shell. Don’t be shy; it won’t bite! The worst that will happen is you’ll get an error message. Commands get executed immediately (once you press ENTER); expressions get evaluated immediately, and the Python Shell prints out the result.
2 is the result of evaluating this expression. As it happens, 1+1 is a valid Python expression. The result, of course, is 2.
Let’s try another one.
&gt;&gt;&gt; print(&lsquo;Hello world!&rsquo;)
Hello world!</p>

<p>Pretty simple, no? But there’s lots more you can do in the Python shell. If you ever get stuck — you can’t remember a command, or you can’t remember the proper arguments to pass a certain function — you can get interactive help in the Python Shell. Just type help and press ENTER.
&gt;&gt;&gt; help
Type help() for interactive help, or help(object) for help about object.</p>

<p>There are two modes of help. You can get help about a single object, which just prints out the documentation and returns you to the Python Shell prompt. You can also enter help mode, where instead of evaluating Python expressions, you just type keywords or command names and it will print out whatever it knows about that command.
To enter the interactive help mode, type help() and press ENTER.
&gt;&gt;&gt; help()
Welcome to Python 3.0! This is the online help utility.</p>

<p>If this is your first time using Python, you should definitely check out
the tutorial on the Internet at <a href="http://docs.python.org/tutorial/">http://docs.python.org/tutorial/</a>.</p>

<p>Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules. To quit this help utility and
return to the interpreter, just type &ldquo;quit&rdquo;.</p>

<p>To get a list of available modules, keywords, or topics, type &ldquo;modules&rdquo;,
&ldquo;keywords&rdquo;, or &ldquo;topics&rdquo;. Each module also comes with a one-line summary
of what it does; to list the modules whose summaries contain a given word
such as &ldquo;spam&rdquo;, type &ldquo;modules spam&rdquo;.</p>

<p>help&gt;</p>

<p>Note how the prompt changes from &gt;&gt;&gt; to help&gt;. This reminds you that you’re in the interactive help mode. Now you can enter any keyword, command, module name, function name — pretty much anything Python understands — and read documentation on it.
help&gt; print . Help on built-in function print in module builtins:
print(&hellip;)
print(value, &hellip;, sep=&rsquo; &lsquo;, end=&rsquo;\n&rsquo;, file=sys.stdout)</p>

<p>Prints the values to a stream, or to sys.stdout by default.
Optional keyword arguments:
file: a file-like object (stream); defaults to the current sys.stdout.
sep: string inserted between values, default a space.
end: string appended after the last value, default a newline.</p>

<p>help&gt; PapayaWhip . no Python documentation found for &lsquo;PapayaWhip&rsquo;
help&gt; quit  .
You are now leaving help and returning to the Python interpreter.
If you want to ask for help on a particular object directly from the
interpreter, you can type &ldquo;help(object)&rdquo;. Executing &ldquo;help(&lsquo;string&rsquo;)&rdquo;
has the same effect as typing a particular string at the help&gt; prompt.</p>

<blockquote>
<blockquote>
<blockquote>
<pre><code>. 
</code></pre>

<ol>
<li>To get documentation on the print() function, just type print and press ENTER. The interactive help mode will display something akin to a man page: the function name, a brief synopsis, the function’s arguments and their default values, and so on. If the documentation seems opaque to you, don’t panic. You’ll learn more about all these concepts in the next few chapters.</li>
</ol>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>Of course, the interactive help mode doesn’t know everything. If you type something that isn’t a Python command, module, function, or other built-in keyword, the interactive help mode will just shrug its virtual shoulders.</p></li>

<li><p>To quit the interactive help mode, type quit and press ENTER.</p></li>

<li><p>The prompt changes back to &gt;&gt;&gt; to signal that you’ve left the interactive help mode and returned to the Python Shell.</p></li>
</ol>

<p>IDLE, the graphical Python Shell, also includes a Python-aware text editor.</p>

<p>.</p>

<p>0.8. PYTHON EDITORS AND IDES
IDLE is not the only game in town when it comes to writing programs in Python. While it’s useful to get started with learning the language itself, many developers prefer other text editors or Integrated Development Environments (IDEs). I won’t cover them here, but the Python community maintains a
list
of
Python-aware
editors
that covers a wide range of supported platforms and software licenses.
You might also want to check out the list
of
Python-aware
IDEs, although few of them support Python 3 yet. One that does is PyDev, a plugin for Eclipse
that turns Eclipse into a full-fledged Python IDE. Both Eclipse and PyDev are cross-platform and open source.
On the commercial front, there is ActiveState’s Komodo
IDE. It has per-user licensing, but students can get a discount, and a free time-limited trial version is available.
I’ve been programming in Python for nine years, and I edit my Python programs in GNU
Emacs
and debug them in the command-line Python Shell. There’s no right or wrong way to develop in Python. Find a way that works for you!
CHAPTER 1. YOUR FIRST PYTHON PROGRAM</p>

<p>. Don’t bury your burden in saintly silence. You have a problem? Great. Rejoice, dive in, and investigate. .
— Ven. Henepola Gunaratana</p>

<p>1.1. DIVING IN
Convention dictates that I should bore you with the fundamental building blocks of programming, so we can slowly work up to building something useful. Let’s skip all that. Here is a complete, working Python program. It probably makes absolutely no sense to you. Don’t worry about that, because you’re going to dissect it line by line. But read through it first and see what, if anything, you can make of it.
SUFFIXES = {1000: [&lsquo;KB&rsquo;, &lsquo;MB&rsquo;, &lsquo;GB&rsquo;, &lsquo;TB&rsquo;, &lsquo;PB&rsquo;, &lsquo;EB&rsquo;, &lsquo;ZB&rsquo;, &lsquo;YB&rsquo;],</p>

<p>1024: [&lsquo;KiB&rsquo;, &lsquo;MiB&rsquo;, &lsquo;GiB&rsquo;, &lsquo;TiB&rsquo;, &lsquo;PiB&rsquo;, &lsquo;EiB&rsquo;, &lsquo;ZiB&rsquo;, &lsquo;YiB&rsquo;]}</p>

<p>def approximate_size(size, a_kilobyte_is_1024_bytes=True):
&ldquo;&lsquo;Convert a file size to human-readable form.</p>

<p>Keyword arguments:
size &ndash; file size in bytes
a_kilobyte_is_1024_bytes &ndash; if True (default), use multiples of 1024</p>

<p>if False, use multiples of 1000</p>

<p>Returns: string</p>

<p>&rdquo;&rsquo;
if size &lt; 0:
raise ValueError(&lsquo;number must be non-negative&rsquo;)</p>

<p>multiple = 1024 if a_kilobyte_is_1024_bytes else 1000</p>

<p>for suffix in SUFFIXES[multiple]:
size /= multiple
if size &lt; multiple:</p>

<p>return &lsquo;{0:.1f} {1}&lsquo;.format(size, suffix)</p>

<p>raise ValueError(&lsquo;number too large&rsquo;)</p>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&lsquo;:
print(approximate_size(1000000000000, False))
print(approximate_size(1000000000000))</p>

<p>Now let’s run this program on the command line. On Windows, it will look something like this:
c:\home\diveintopython3\examples&gt; c:\python31\python.exe humansize.py</p>

<p>1.0 TB</p>

<p>931.3 GiB</p>

<p>On Mac OS X or Linux, it would look something like this:
you@localhost:~/diveintopython3/examples$ python3 humansize.py</p>

<p>1.0 TB</p>

<p>931.3 GiB</p>

<p>What just happened? You executed your first Python program. You called the Python interpreter on the command line, and you passed the name of the script you wanted Python to execute. The script defines a single function, the approximate_size() function, which takes an exact file size in bytes and calculates a “pretty” (but approximate) size. (You’ve probably seen this in Windows Explorer, or the Mac OS X Finder, or Nautilus or Dolphin or Thunar on Linux. If you display a folder of documents as a multi-column list, it will display a table with the document icon, the document name, the size, type, last-modified date, and so on. If the folder contains a 1093-byte file named TODO, your file manager won’t display TODO 1093 bytes; it’ll say something like TODO 1 KB instead. That’s what the approximate_size() function does.)
Look at the bottom of the script, and you’ll see two calls to print(approximate_size(arguments)). These are function calls — first calling the approximate_size() function and passing a number of arguments, then taking the return value and passing it straight on to the print() function. The print() function is built-in; you’ll never see an explicit declaration of it. You can just use it, anytime, anywhere. (There are lots of built-in functions, and lots more functions that are separated into modules. Patience, grasshopper.)
So why does running the script on the command line give you the same output every time? We’ll get to that. First, let’s look at that approximate_size() function.</p>

<p>.</p>

<p>1.2. DECLARING FUNCTIONS</p>

<p>Python has functions like most other languages, but it does not have separate header files like C++ or interface/implementation sections like Pascal. When you need a function, just declare it, like this:
def approximate_size(size, a_kilobyte_is_1024_bytes=True):</p>

<p>The keyword def starts the function declaration, followed by the function name, followed by the
arguments in parentheses. Multiple arguments are separated with commas.
Also note that the function doesn’t define a return datatype. Python functions do not specify the datatype of their return value; they don’t even specify whether or not they return a value. (In fact, every Python function returns a value; if the function ever executes a return statement, it will return that value, otherwise it will return None, the Python null value.)
. In some languages, functions (that return a value) start with function, and subroutines</p>

<p>(that do not return a value) start with sub.
There are no subroutines in Python. Everything is a function, all functions return a
value (even if it’s None), and all functions start with def.</p>

<p>The approximate_size() function takes the two arguments — size and a_kilobyte_is_1024_bytes — but neither argument specifies a datatype. In Python, variables are never explicitly typed. Python figures out what type a variable is and keeps track of it internally.
. In Java and other statically-typed languages, you must specify the datatype of the function return value and each function argument. In Python, you never explicitly specify the datatype of anything. Based on what value you assign, Python keeps track of the datatype internally.
1.2.1. OPTIONAL AND NAMED ARGUMENTS</p>

<p>Python allows function arguments to have default values; if the function is called without the argument, the argument gets its default value. Furthermore, arguments can be specified in any order by using named arguments.
Let’s take another look at that approximate_size() function declaration:
def approximate_size(size, a_kilobyte_is_1024_bytes=True):</p>

<p>The second argument, a_kilobyte_is_1024_bytes, specifies a default value of True. This means the argument is optional; you can call the function without it, and Python will act as if you had called it with True as a second parameter.
Now look at the bottom of the script:
if <strong>name</strong> == &lsquo;<strong>main</strong>&lsquo;:
print(approximate_size(1000000000000, False)) .
print(approximate_size(1000000000000)) .</p>

<ol>
<li><p>This calls the approximate_size() function with two arguments. Within the approximate_size() function, a_kilobyte_is_1024_bytes will be False, since you explicitly passed False as the second argument.</p></li>

<li><p>This calls the approximate_size() function with only one argument. But that’s OK, because the second argument is optional! Since the caller doesn’t specify, the second argument defaults to True, as defined by the function declaration.</p></li>
</ol>

<p>You can also pass values into a function by name.
&gt;&gt;&gt; from humansize import approximate_size
&gt;&gt;&gt; approximate_size(4000, a_kilobyte_is_1024_bytes=False) .
&lsquo;4.0 KB&rsquo;
&gt;&gt;&gt; approximate_size(size=4000, a_kilobyte_is_1024_bytes=False) .
&lsquo;4.0 KB&rsquo;
&gt;&gt;&gt; approximate_size(a_kilobyte_is_1024_bytes=False, size=4000) .
&lsquo;4.0 KB&rsquo;
&gt;&gt;&gt; approximate_size(a_kilobyte_is_1024_bytes=False, 4000) .</p>

<p>File &ldquo;<stdin>&rdquo;, line 1
SyntaxError: non-keyword arg after keyword arg</p>

<blockquote>
<blockquote>
<blockquote>
<p>approximate_size(size=4000, False)  .
File &ldquo;<stdin>&rdquo;, line 1
SyntaxError: non-keyword arg after keyword arg</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>This calls the approximate_size() function with 4000 for the first argument (size) and False for the argument named a_kilobyte_is_1024_bytes. (That happens to be the second argument, but doesn’t matter, as you’ll see in a minute.)</p></li>

<li><p>This calls the approximate_size() function with 4000 for the argument named size and False for the argument named a_kilobyte_is_1024_bytes. (These named arguments happen to be in the same order as the arguments are listed in the function declaration, but that doesn’t matter either.)</p></li>

<li><p>This calls the approximate_size() function with False for the argument named a_kilobyte_is_1024_bytes and 4000 for the argument named size. (See? I told you the order didn’t matter.)</p></li>

<li><p>This call fails, because you have a named argument followed by an unnamed (positional) argument, and that never works. Reading the argument list from left to right, once you have a single named argument, the rest of the arguments must also be named.</p></li>

<li><p>This call fails too, for the same reason as the previous call. Is that surprising? After all, you passed 4000 for the argument named size, then “obviously” that False value was meant for the a_kilobyte_is_1024_bytes argument. But Python doesn’t work that way. As soon as you have a named argument, all arguments to the right of that need to be named arguments, too.
.</p></li>
</ol>

<p>1.3. WRITING READABLE CODE</p>

<p>I won’t bore you with a long finger-wagging speech about the importance of documenting your code. Just know that code is written once but read many times, and the most important audience for your code is yourself, six months after writing it (i.e. after you’ve forgotten everything but need to fix something). Python makes it easy to write readable code, so take advantage of it. You’ll thank me in six months.
1.3.1. DOCUMENTATION STRINGS</p>

<p>You can document a Python function by giving it a documentation string (docstring for short). In this program, the approximate_size() function has a docstring:
def approximate_size(size, a_kilobyte_is_1024_bytes=True):
&ldquo;&lsquo;Convert a file size to human-readable form.</p>

<p>Keyword arguments:</p>

<p>size &ndash; file size in bytes</p>

<p>a_kilobyte_is_1024_bytes &ndash; if True (default), use multiples of 1024</p>

<p>if False, use multiples of 1000</p>

<p>Returns: string</p>

<p>&rdquo;&rsquo;</p>

<p>Triple quotes signify a multi-line string. Everything between the start and end quotes is part of a single string, including carriage returns, leading white space, and other quote characters. You can use them anywhere, but you’ll see them most often used when defining a docstring.
.</p>

<p>Triple quotes are also an easy way to define a string with both single and double quotes, like qq/&hellip;/ in Perl 5.</p>

<p>Everything between the triple quotes is the function’s docstring, which documents what the function does. A docstring, if it exists, must be the first thing defined in a function (that is, on the next line after the function declaration). You don’t technically need to give your function a docstring, but you always should. I know you’ve heard this in every programming class you’ve ever taken, but Python gives you an added incentive: the docstring is available at runtime as an attribute of the function.</p>

<p>. Many Python IDEs use the docstring to provide context-sensitive documentation, so that when you type a function name, its docstring appears as a tooltip. This can be incredibly helpful, but it’s only as good as the docstrings you write.</p>

<p>1.4. THE import SEARCH PATH
Before this goes any further, I want to briefly mention the library search path. Python looks in several places when you try to import a module. Specifically, it looks in all the directories defined in sys.path. This is just a list, and you can easily view it or modify it with standard list methods. (You’ll learn more about lists in Native
Datatypes.)
&gt;&gt;&gt; import sys .
&gt;&gt;&gt; sys.path .
[&ldquo;,</p>

<p>&rsquo;/usr/lib/python31.zip&rsquo;,
&lsquo;/usr/lib/python3.1&rsquo;,
&lsquo;/usr/lib/python3.1/plat-linux2@EXTRAMACHDEPPATH@&rsquo;,
&lsquo;/usr/lib/python3.1/lib-dynload&rsquo;,
&lsquo;/usr/lib/python3.1/dist-packages&rsquo;,
&lsquo;/usr/local/lib/python3.1/dist-packages&rsquo;]</p>

<blockquote>
<blockquote>
<blockquote>
<p>sys .
<module 'sys' (built-in)>
sys.path.insert(0, &lsquo;/home/mark/diveintopython3/examples&rsquo;) .
sys.path .
[&lsquo;/home/mark/diveintopython3/examples&rsquo;,</p>
</blockquote>
</blockquote>
</blockquote>

<p>&rdquo;,
&lsquo;/usr/lib/python31.zip&rsquo;,
&lsquo;/usr/lib/python3.1&rsquo;,
&lsquo;/usr/lib/python3.1/plat-linux2@EXTRAMACHDEPPATH@&rsquo;,
&lsquo;/usr/lib/python3.1/lib-dynload&rsquo;,
&lsquo;/usr/lib/python3.1/dist-packages&rsquo;,
&lsquo;/usr/local/lib/python3.1/dist-packages&rsquo;]</p>

<ol>
<li><p>Importing the sys module makes all of its functions and attributes available.</p></li>

<li><p>sys.path is a list of directory names that constitute the current search path. (Yours will look different, depending on your operating system, what version of Python you’re running, and where it was originally installed.) Python will look through these directories (in this order) for a .py file whose name matches what you’re trying to import.</p></li>

<li><p>Actually, I lied; the truth is more complicated than that, because not all modules are stored as .py files. Some are built-in modules; they are actually baked right into Python itself. Built-in modules behave just like regular modules, but their Python source code is not available, because they are not written in Python! (Like Python itself, these built-in modules are written in C.)</p></li>

<li><p>You can add a new directory to Python’s search path at runtime by adding the directory name to sys.path, and then Python will look in that directory as well, whenever you try to import a module. The effect lasts as long as Python is running.</p></li>

<li><p>By using sys.path.insert(0, new_path), you inserted a new directory as the first item of the sys.path list, and therefore at the beginning of Python’s search path. This is almost always what you want. In case of naming conflicts (for example, if Python ships with version 2 of a particular library but you want to use version 3), this ensures that your modules will be found and used instead of the modules that came with Python.</p></li>
</ol>

<p>.
1.5. EVERYTHING IS AN OBJECT
In case you missed it, I just said that Python functions have attributes, and that those attributes are available at runtime. A function, like everything else in Python, is an object.
Run the interactive Python shell and follow along:
&gt;&gt;&gt; import humansize .
&gt;&gt;&gt; print(humansize.approximate_size(4096, True)) .</p>

<p>4.0 KiB
&gt;&gt;&gt; print(humansize.approximate_size.<strong>doc</strong>) .
Convert a file size to human-readable form.</p>

<p>Keyword arguments:
size &ndash; file size in bytes
a_kilobyte_is_1024_bytes &ndash; if True (default), use multiples of 1024</p>

<p>if False, use multiples of 1000</p>

<p>Returns: string</p>

<ol>
<li>The first line imports the humansize program as a module — a chunk of code that you can use interactively, or from a larger Python program. Once you import a module, you can reference any of its public functions, classes, or attributes. Modules can do this to access functionality in other modules, and you can do it in the</li>
</ol>

<p>Python interactive shell too. This is an important concept, and you’ll see a lot more of it throughout this book.</p>

<ol>
<li><p>When you want to use functions defined in imported modules, you need to include the module name. So you can’t just say approximate_size; it must be humansize.approximate_size. If you’ve used classes in Java, this should feel vaguely familiar.</p></li>

<li><p>Instead of calling the function as you would expect to, you asked for one of the function’s attributes, <strong>doc</strong>.</p></li>
</ol>

<p>. import in Python is like require in Perl. Once you import a Python module, you access its functions with module.function; once you require a Perl module, you access its functions with module::function.
1.5.1. WHAT’S AN OBJECT?</p>

<p>Everything in Python is an object, and everything can have attributes and methods. All functions have a built-in attribute <strong>doc</strong>, which returns the docstring defined in the function’s source code. The sys module is an object which has (among other things) an attribute called path. And so forth.
Still, this doesn’t answer the more fundamental question: what is an object? Different programming languages define “object” in different ways. In some, it means that all objects must have attributes and methods; in others, it means that all objects are subclassable. In Python, the definition is looser. Some objects have neither attributes nor methods, but they could. Not all objects are subclassable. But everything is an object in the sense that it can be assigned to a variable or passed as an argument to a function.</p>

<p>You may have heard the term “first-class object” in other programming contexts. In Python, functions are first-class objects. You can pass a function as an argument to another function. Modules are first-class objects. You can pass an entire module as an argument to a function. Classes are first-class objects, and individual instances of a class are also first-class objects.</p>

<p>This is important, so I’m going to repeat it in case you missed it the first few times: everything in Python is an object. Strings are objects. Lists are objects. Functions are objects. Classes are objects. Class instances are objects. Even modules are objects.</p>

<p>.
1.6. INDENTING CODE
Python functions have no explicit begin or end, and no curly braces to mark where the function code starts and stops. The only delimiter is a colon (:) and the indentation of the code itself.
def approximate_size(size, a_kilobyte_is_1024_bytes=True): .
if size &lt; 0: .
raise ValueError(&lsquo;number must be non-negative&rsquo;) .
.</p>

<p>multiple = 1024 if a_kilobyte_is_1024_bytes else 1000</p>

<p>for suffix in SUFFIXES[multiple]: .
size /= multiple
if size &lt; multiple:</p>

<p>return &lsquo;{0:.1f} {1}&lsquo;.format(size, suffix)</p>

<p>raise ValueError(&lsquo;number too large&rsquo;)</p>

<ol>
<li><p>Code blocks are defined by their indentation. By “code block,” I mean functions, if statements, for loops, while loops, and so forth. Indenting starts a block and unindenting ends it. There are no explicit braces, brackets, or keywords. This means that whitespace is significant, and must be consistent. In this example, the function code is indented four spaces. It doesn’t need to be four spaces, it just needs to be consistent. The first line that is not indented marks the end of the function.</p></li>

<li><p>In Python, an if statement is followed by a code block. If the if expression evaluates to true, the indented block is executed, otherwise it falls to the else block (if any). Note the lack of parentheses around the expression.</p></li>

<li><p>This line is inside the if code block. This raise statement will raise an exception (of type ValueError), but only if size &lt; 0.</p></li>

<li><p>This is not the end of the function. Completely blank lines don’t count. They can make the code more readable, but they don’t count as code block delimiters. The function continues on the next line.</p></li>

<li><p>The for loop also marks the start of a code block. Code blocks can contain multiple lines, as long as they are all indented the same amount. This for loop has three lines of code in it. There is no other special syntax for multi-line code blocks. Just indent and get on with your life.</p></li>
</ol>

<p>After some initial protests and several snide analogies to Fortran, you will make peace with this and start seeing its benefits. One major benefit is that all Python programs look similar, since indentation is a language requirement and not a matter of style. This makes it easier to read and understand other people’s Python code.
. Python uses carriage returns to separate statements and a colon and indentation to separate code blocks. C++ and Java use semicolons to separate statements and curly braces to separate code blocks.</p>

<p>.</p>

<p>1.7. EXCEPTIONS
Exceptions are everywhere in Python. Virtually every module in the standard Python library uses them, and Python itself will raise them in a lot of different circumstances. You’ll see them repeatedly throughout this book.
What is an exception? Usually it’s an error, an indication that something went wrong. (Not all exceptions are errors, but never mind that for now.) Some programming languages encourage the use of error return codes, which you check. Python encourages the use of exceptions, which you handle.
When an error occurs in the Python Shell, it prints out some details about the exception and how it happened, and that’s that. This is called an unhandled exception. When the exception was raised, there was no code to explicitly notice it and deal with it, so it bubbled its way back up to the top level of the Python Shell, which spits out some debugging information and calls it a day. In the shell, that&rsquo;s no big deal, but if that happened while your actual Python program was running, the entire program would come to a screeching halt if nothing handles the exception. Maybe that’s what you want, maybe it isn’t.
. Unlike Java, Python functions don’t declare which exceptions they might raise. It’s up to you to determine what possible exceptions you need to catch.
An exception doesn’t need to result in a complete program crash, though. Exceptions can be handled. Sometimes an exception is really because you have a bug in your code (like accessing a variable that doesn’t exist), but sometimes an exception is something you can anticipate. If you’re opening a file, it might not exist. If you’re importing a module, it might not be installed. If you’re connecting to a database, it might be unavailable, or you might not have the correct security credentials to access it. If you know a line of code may raise an exception, you should handle the exception using a try&hellip;except block.
. Python uses try&hellip;except blocks to handle exceptions, and the raise statement to
generate them. Java and C++ use try&hellip;catch blocks to handle exceptions, and the
throw statement to generate them.</p>

<p>The approximate_size() function raises exceptions in two different cases: if the given size is larger than the function is designed to handle, or if it’s less than zero.
if size &lt; 0:
raise ValueError(&lsquo;number must be non-negative&rsquo;)</p>

<p>The syntax for raising an exception is simple enough. Use the raise statement, followed by the exception name, and an optional human-readable string for debugging purposes. The syntax is reminiscent of calling a function. (In reality, exceptions are implemented as classes, and this raise statement is actually creating an instance of the ValueError class and passing the string &lsquo;number must be non-negative&rsquo; to its initialization method. But we’re
getting
ahead
of
ourselves!)
. You don’t need to handle an exception in the function that raises it. If one function
doesn’t handle it, the exception is passed to the calling function, then that function’s
calling function, and so on “up the stack.” If the exception is never handled, your
program will crash, Python will print a “traceback” to standard error, and that’s the</p>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>try</dt>
<dd></dd>
</dl>

<dl>
<dt>ry</dt>
<dd></dd>
</dl>

<p>import chardet</p>

<p>except
ImportError:</p>

<p>chardet = None</p>

<p>Later, you can check for the presence of the chardet module with a simple if statement:
if chardet:</p>

<h1 id="do-something">do something</h1>

<p>else:</p>

<h1 id="continue-anyway">continue anyway</h1>

<p>Another common use of the ImportError exception is when two modules implement a common API, but one is more desirable than the other. (Maybe it’s faster, or it uses less memory.) You can try to import one module but fall back to a different module if the first import fails. For example, the
XML
chapter
talks about two modules that implement a common API, called the ElementTree API. The first, lxml, is a third-party module that you need to download and install yourself. The second, xml.etree.ElementTree, is slower but is part of the Python 3 standard library.
try:</p>

<p>from lxml import etree
except ImportError:
import xml.etree.ElementTree as etree</p>

<p>By the end of this try..except block, you have imported some module and named it etree. Since both modules implement a common API, the rest of your code doesn’t need to keep checking which module got imported. And since the module that did get imported is always called etree, the rest of your code doesn’t need to be littered with if statements to call differently-named modules.</p>

<p>.</p>

<p>1.8. UNBOUND VARIABLES
Take another look at this line of code from the approximate_size() function:
multiple = 1024 if a_kilobyte_is_1024_bytes else 1000</p>

<p>You never declare the variable multiple, you just assign a value to it. That’s OK, because Python lets you do that. What Python will not let you do is reference a variable that has never been assigned a value. Trying to do so will raise a NameError exception.
&gt;&gt;&gt; x</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
NameError: name &lsquo;x&rsquo; is not defined</p>

<blockquote>
<blockquote>
<blockquote>
<p>x = 1
x</p>
</blockquote>
</blockquote>
</blockquote>

<p>You will thank Python for this one day.</p>

<p>.</p>

<p>1.9. EVERYTHING IS CASE-SENSITIVE</p>

<p>All names in Python are case-sensitive: variable names, function names, class names, module names, exception names. If you can get it, set it, call it, construct it, import it, or raise it, it’s case-sensitive.
&gt;&gt;&gt; an_integer = 1
&gt;&gt;&gt; an_integer</p>

<blockquote>
<blockquote>
<blockquote>
<p>AN_INTEGER</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;<stdin>&rdquo;, line 1, in <module></p>

<p>NameError: name &lsquo;AN_INTEGER&rsquo; is not defined</p>

<blockquote>
<blockquote>
<blockquote>
<p>An_Integer</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;<stdin>&rdquo;, line 1, in <module></p>

<p>NameError: name &lsquo;An_Integer&rsquo; is not defined</p>

<blockquote>
<blockquote>
<blockquote>
<p>an_inteGer</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;<stdin>&rdquo;, line 1, in <module></p>

<p>NameError: name &lsquo;an_inteGer&rsquo; is not defined</p>

<p>And so on.
.</p>

<p>1.10. RUNNING SCRIPTS
Python modules are objects and have several useful attributes. You can use this to easily test your modules
as you write them, by including a special block of code that executes when you run the Python file on the command line. Take the last few lines of humansize.py:
if <strong>name</strong> == &lsquo;<strong>main</strong>&lsquo;:</p>

<p>print(approximate_size(1000000000000, False))
print(approximate_size(1000000000000))</p>

<p>. Like C, Python uses == for comparison and = for assignment. Unlike C, Python does not support in-line assignment, so there’s no chance of accidentally assigning the value you thought you were comparing.
So what makes this if statement special? Well, modules are objects, and all modules have a built-in attribute <strong>name</strong>. A module’s <strong>name</strong> depends on how you’re using the module. If you import the module, then <strong>name</strong> is the module’s filename, without a directory path or file extension.
&gt;&gt;&gt; import humansize
&gt;&gt;&gt; humansize.<strong>name</strong>
&lsquo;humansize&rsquo;</p>

<p>But you can also run the module directly as a standalone program, in which case <strong>name</strong> will be a special default value, <strong>main</strong>. Python will evaluate this if statement, find a true expression, and execute the if code block. In this case, to print two values.<br />
c:\home\diveintopython3&gt; c:\python31\python.exe humansize.py 1.0 TB 931.3 GiB<br />
And that’s your first Python program!<br />
.<br />
1.11. FURTHER READING<br />
• • • •  PEP
257: Docstring Conventions explains what distinguishes a good docstring from a great docstring. Python Tutorial: Documentation Strings also touches on the subject. PEP 8: Style Guide for Python Code discusses good indentation style. Python Reference Manual explains what it means to say that everything in Python is an object, because some people are pedants and like to discuss that sort of thing at great length.</p>

<p>CHAPTER 2. NATIVE DATATYPES</p>

<p>.   Wonder is the foundation of all philosophy, inquiry its progress, ignorance its end. .
— Michel de Montaigne</p>

<p>2.1. DIVING IN</p>

<p>Datatypes. Set aside your first Python program for just a minute, and let’s talk about datatypes. In Python, every value has a
datatype, but you don’t need to declare the datatype of variables. How does that work? Based on each variable’s original assignment, Python figures out what type it is and keeps tracks of that internally.
Python has many native datatypes. Here are the important ones:</p>

<ol>
<li><p>Booleans are either True or False.</p></li>

<li><p>Numbers can be integers (1 and 2), floats (1.1 and 1.2), fractions (<sup>1</sup>&frasl;<sub>2</sub> and <sup>2</sup>&frasl;<sub>3</sub>), or even complex
numbers.</p></li>

<li><p>Strings are sequences of Unicode characters, e.g. an HTML document.</p></li>

<li><p>Bytes and byte arrays, e.g. a JPEG image file.</p></li>

<li><p>Lists are ordered sequences of values.</p></li>

<li><p>Tuples are ordered, immutable sequences of values.</p></li>

<li><p>Sets are unordered bags of values.</p></li>

<li><p>Dictionaries are unordered bags of key-value pairs.</p></li>
</ol>

<p>Of course, there are more types than these. Everything is an object in Python, so there are types like module, function, class, method, file, and even compiled code. You’ve already seen some of these: modules have names, functions have docstrings, &amp;c. You’ll learn about classes in Classes &amp;Iterators, and about files in Files.
Strings and bytes are important enough — and complicated enough — that they get their own chapter. Let’s look at the others first.</p>

<p>.</p>

<p>2.2. BOOLEANS
Booleans are either true or false. Python has two constants, cleverly named True and False, which can be used to assign boolean values directly. Expressions can also evaluate to a boolean value. In certain places (like if statements), Python expects an expression to evaluate to a boolean value. These places are called boolean contexts. You can use virtually any expression in a boolean context, and Python will try to determine its truth value. Different datatypes have different rules about which values are true or false in a boolean context. (This will make more sense once you see some concrete examples later in this chapter.)
For example, take this snippet from humansize.py:
if size &lt; 0:</p>

<p>raise ValueError(&lsquo;number must be non-negative&rsquo;)</p>

<p>size is an integer, 0 is an integer, and &lt; is a numerical operator. The result of the expression size &lt; 0 is always a boolean. You can test this yourself in the Python interactive shell:
&gt;&gt;&gt; size = 1</p>

<blockquote>
<blockquote>
<blockquote>
<p>size &lt; 0
False
size = 0
size &lt; 0
False
size = -1
size &lt; 0
True</p>
</blockquote>
</blockquote>
</blockquote>

<p>Due to some legacy issues left over from Python 2, booleans can be treated as numbers. True is 1; False is 0.
&gt;&gt;&gt; True + True
2
&gt;&gt;&gt; True - False
1
&gt;&gt;&gt; True * False
0
&gt;&gt;&gt; True / False</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
ZeroDivisionError: int division or modulo by zero</p>

<p>Ew, ew, ew! Don’t do that. Forget I even mentioned it.
.</p>

<p>2.3. NUMBERS
Numbers are awesome. There are so many to choose from. Python supports both integers and floating point numbers. There’s no type declaration to distinguish them; Python tells them apart by the presence or absence of a decimal point.
&gt;&gt;&gt; type(1) .
<class 'int'>
&gt;&gt;&gt; isinstance(1, int) .
True
&gt;&gt;&gt; 1 + 1 .
2
&gt;&gt;&gt; 1 + 1.0 .
2.0
&gt;&gt;&gt; type(2.0)
<class 'float'></p>

<ol>
<li><p>You can use the type() function to check the type of any value or variable. As you might expect, 1 is an int.</p></li>

<li><p>Similarly, you can use the isinstance() function to check whether a value or variable is of a given type.</p></li>

<li><p>Adding an int to an int yields an int.</p></li>

<li><p>Adding an int to a float yields a float. Python coerces the int into a float to perform the addition, then returns a float as the result.</p></li>
</ol>

<p>2.3.1. COERCING INTEGERS TO FLOATS AND VICE-VERSA
As you just saw, some operators (like addition) will coerce integers to floating point numbers as needed. You can also coerce them by yourself.
&gt;&gt;&gt; float(2) .
2.0
&gt;&gt;&gt; int(2.0) .
2
&gt;&gt;&gt; int(2.5) .
2
&gt;&gt;&gt; int(-2.5) .
-2
&gt;&gt;&gt; 1.12345678901234567890 .
1.1234567890123457
&gt;&gt;&gt; type(1000000000000000) .
<class 'int'></p>

<ol>
<li><p>You can explicitly coerce an int to a float by calling the float() function.</p></li>

<li><p>Unsurprisingly, you can also coerce a float to an int by calling int().</p></li>

<li><p>The int() function will truncate, not round.</p></li>

<li><p>The int() function truncates negative numbers towards 0. It’s a true truncate function, not a floor function.</p></li>

<li><p>Floating point numbers are accurate to 15 decimal places.</p></li>

<li><p>Integers can be arbitrarily large.</p></li>
</ol>

<p>. Python 2 had separate types for int and long. The int datatype was limited by sys.maxint, which varied by platform but was usually 232-1. Python 3 has just one integer type, which behaves mostly like the old long type from Python 2. See PEP
237
for details.</p>

<p>2.3.2. COMMON NUMERICAL OPERATIONS
You can do all kinds of things with numbers.
&gt;&gt;&gt; 11 / 2 .
5.5
&gt;&gt;&gt; 11 // 2 .
5
&gt;&gt;&gt; -11 // 2 .
-6
&gt;&gt;&gt; 11.0 // 2 .
5.0
&gt;&gt;&gt; 11 ** 2 .
121
&gt;&gt;&gt; 11 % 2 .
1</p>

<ol>
<li><p>The / operator performs floating point division. It returns a float even if both the numerator and denominator are ints.</p></li>

<li><p>The // operator performs a quirky kind of integer division. When the result is positive, you can think of it as truncating (not rounding) to 0 decimal places, but be careful with that.</p></li>

<li><p>When integer-dividing negative numbers, the // operator rounds “up” to the nearest integer. Mathematically speaking, it’s rounding “down” since -6 is less than -5, but it could trip you up if you were expecting it to truncate to -5.</p></li>

<li><p>The // operator doesn’t always return an integer. If either the numerator or denominator is a float, it will still round to the nearest integer, but the actual return value will be a float.</p></li>

<li><p>The ** operator means “raised to the power of.” 112 is 121.</p></li>

<li><p>The % operator gives the remainder after performing integer division. 11 divided by 2 is 5 with a remainder of 1, so the result here is 1.</p></li>
</ol>

<p>. In Python 2, the / operator usually meant integer division, but you could make it behave like floating point division by including a special directive in your code. In Python 3, the / operator always means floating point division. See PEP
238
for details.</p>

<p>2.3.3. FRACTIONS</p>

<p>Python isn’t limited to integers and floating point numbers. It can also do all the fancy math you learned in high school and promptly forgot about.
&gt;&gt;&gt; import fractions .
&gt;&gt;&gt; x = fractions.Fraction(1, 3) .
&gt;&gt;&gt; x
Fraction(1, 3)
&gt;&gt;&gt; x * 2 .
Fraction(2, 3)
&gt;&gt;&gt; fractions.Fraction(6, 4) .
Fraction(3, 2)
&gt;&gt;&gt; fractions.Fraction(0, 0) .</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
File &ldquo;fractions.py&rdquo;, line 96, in <strong>new</strong></p>

<p>raise ZeroDivisionError(&lsquo;Fraction(%s, 0)&rsquo; % numerator)
ZeroDivisionError: Fraction(0, 0)</p>

<ol>
<li><p>To start using fractions, import the fractions module.</p></li>

<li><p>To define a fraction, create a Fraction object and pass in the numerator and denominator.</p></li>

<li><p>You can perform all the usual mathematical operations with fractions. Operations return a new Fraction object. 2 * (<sup>1</sup>&frasl;<sub>3</sub>) = (<sup>2</sup>&frasl;<sub>3</sub>)</p></li>

<li><p>The Fraction object will automatically reduce fractions. (<sup>6</sup>&frasl;<sub>4</sub>) = (<sup>3</sup>&frasl;<sub>2</sub>)</p></li>

<li><p>Python has the good sense not to create a fraction with a zero denominator.</p></li>
</ol>

<p>2.3.4. TRIGONOMETRY
You can also do basic trigonometry in Python.
&gt;&gt;&gt; import math
&gt;&gt;&gt; math.pi .
3.1415926535897931
&gt;&gt;&gt; math.sin(math.pi / 2) .
1.0
&gt;&gt;&gt; math.tan(math.pi / 4) .
0.99999999999999989</p>

<ol>
<li><p>The math module has a constant for p, the ratio of a circle’s circumference to its diameter.</p></li>

<li><p>The math module has all the basic trigonometric functions, including sin(), cos(), tan(), and variants like asin().</p></li>

<li><p>Note, however, that Python does not have infinite precision. tan(p / 4) should return 1.0, not 0.99999999999999989.</p></li>
</ol>

<p>2.3.5. NUMBERS IN A BOOLEAN CONTEXT
You can use numbers in
a
boolean
context, such as an
if statement. Zero values are false, and non-zero values</p>

<p>are true.</p>

<blockquote>
<blockquote>
<blockquote>
<p>def is_it_true(anything): .
&hellip; if anything:
&hellip; print(&ldquo;yes, it&rsquo;s true&rdquo;)
&hellip; else:
&hellip; print(&ldquo;no, it&rsquo;s false&rdquo;)
&hellip;
is_it_true(1) .
yes, it&rsquo;s true
is_it_true(-1)
yes, it&rsquo;s true
is_it_true(0)
no, it&rsquo;s false
is_it_true(0.1) .
yes, it&rsquo;s true
is_it_true(0.0)
no, it&rsquo;s false
import fractions
is_it_true(fractions.Fraction(1, 2)) .
yes, it&rsquo;s true
is_it_true(fractions.Fraction(0, 1))
no, it&rsquo;s false</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>Did you know you can define your own functions in the Python interactive shell? Just press ENTER at the end of each line, and ENTER on a blank line to finish.</p></li>

<li><p>In a boolean context, non-zero integers are true; 0 is false.</p></li>

<li><p>Non-zero floating point numbers are true; 0.0 is false. Be careful with this one! If there’s the slightest rounding error (not impossible, as you saw in the previous section) then Python will be testing 0.0000000000001 instead of 0 and will return True.</p></li>

<li><p>Fractions can also be used in a boolean context. Fraction(0, n) is false for all values of n. All other fractions are true.</p></li>
</ol>

<p>.</p>

<p>2.4. LISTS
Lists are Python’s workhorse datatype. When I say “list,” you might be thinking “array whose size I have to declare in advance, that can only contain items of the same type, &amp;c.” Don’t think that. Lists are much cooler than that.
.
A list in Python is like an array in Perl 5. In Perl 5, variables that store arrays always start with the @ character; in Python, variables can be named anything, and Python keeps track of the datatype internally.</p>

<p>.
A list in Python is much more than an array in Java (although it can be used as one if that’s really all you want out of life). A better analogy would be to the ArrayList class, which can hold arbitrary objects and can expand dynamically as new items are added.</p>

<p>2.4.1. CREATING A LIST
Creating a list is easy: use square brackets to wrap a comma-separated list of values.
&gt;&gt;&gt; a_list = [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;, &lsquo;z&rsquo;, &lsquo;example&rsquo;]  .<br />
&gt;&gt;&gt; a_list<br />
[&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;, &lsquo;z&rsquo;, &lsquo;example&rsquo;]<br />
&gt;&gt;&gt; a_list[0]  .<br />
&lsquo;a&rsquo;<br />
&gt;&gt;&gt; a_list[4]  .<br />
&lsquo;example&rsquo;<br />
&gt;&gt;&gt; a_list[-1]  .<br />
&lsquo;example&rsquo;<br />
&gt;&gt;&gt; a_list[-3]  .<br />
&lsquo;mpilgrim&rsquo;</p>

<ol>
<li><p>First, you define a list of five items. Note that they retain their original order. This is not an accident. A list is an ordered set of items.</p></li>

<li><p>A list can be used like a zero-based array. The first item of any non-empty list is always a_list[0].</p></li>

<li><p>The last item of this five-item list is a_list[4], because lists are always zero-based.</p></li>

<li><p>A negative index accesses items from the end of the list counting backwards. The last item of any non-empty list is always a_list[-1].</p></li>

<li><p>If the negative index is confusing to you, think of it this way: a_list[-n] == a_list[len(a_list) -n]. So in this list, a_list[-3] == a_list[5 -3] == a_list[2].</p></li>
</ol>

<p>2.4.2. SLICING A LIST
Once you’ve defined a list, you can get any part of it as
a new list. This is called slicing the list.</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_list
[&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;, &lsquo;z&rsquo;, &lsquo;example&rsquo;]
a_list[1:3] .
[&lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;]
a_list[1:-1] .
[&lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;, &lsquo;z&rsquo;]
a_list[0:3] .
[&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;]
a_list[:3] .
[&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;]
a_list[3:] .
[&lsquo;z&rsquo;, &lsquo;example&rsquo;]
a_list[:] .
[&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;, &lsquo;z&rsquo;, &lsquo;example&rsquo;]</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>You can get a part of a list, called a “slice”, by specifying two indices. The return value is a new list containing all the items of the list, in order, starting with the first slice index (in this case a_list[1]), up to but not including the second slice index (in this case a_list[3]).</p></li>

<li><p>Slicing works if one or both of the slice indices is negative. If it helps, you can think of it this way: reading the list from left to right, the first slice index specifies the first item you want, and the second slice index specifies the first item you don’t want. The return value is everything in between.</p></li>

<li><p>Lists are zero-based, so a_list[0:3] returns the first three items of the list, starting at a_list[0], up to but not including a_list[3].</p></li>

<li><p>If the left slice index is 0, you can leave it out, and 0 is implied. So a_list[:3] is the same as a_list[0:3], because the starting 0 is implied.</p></li>

<li><p>Similarly, if the right slice index is the length of the list, you can leave it out. So a_list[3:] is the same as a_list[3:5], because this list has five items. There is a pleasing symmetry here. In this five-item list, a_list[:3] returns the first 3 items, and a_list[3:] returns the last two items. In fact, a_list[:n] will always return the first n items, and a_list[n:] will return the rest, regardless of the length of the list.</p></li>

<li><p>If both slice indices are left out, all items of the list are included. But this is not the same as the original a_list variable. It is a new list that happens to have all the same items. a_list[:] is shorthand for making a complete copy of a list.</p></li>
</ol>

<p>2.4.3. ADDING ITEMS TO A LIST
There are four ways to add items to a list.
&gt;&gt;&gt; a_list = [&lsquo;a&rsquo;]
&gt;&gt;&gt; a_list = a_list + [2.0, 3] .
&gt;&gt;&gt; a_list .
[&lsquo;a&rsquo;, 2.0, 3]
&gt;&gt;&gt; a_list.append(True) .
&gt;&gt;&gt; a_list
[&lsquo;a&rsquo;, 2.0, 3, True]
&gt;&gt;&gt; a_list.extend([&lsquo;four&rsquo;, &lsquo;O&rsquo;]) .
&gt;&gt;&gt; a_list
[&lsquo;a&rsquo;, 2.0, 3, True, &lsquo;four&rsquo;, &lsquo;O&rsquo;]
&gt;&gt;&gt; a_list.insert(0, &lsquo;O&rsquo;) .
&gt;&gt;&gt; a_list
[&lsquo;O&rsquo;, &lsquo;a&rsquo;, 2.0, 3, True, &lsquo;four&rsquo;, &lsquo;O&rsquo;]</p>

<ol>
<li><p>The + operator concatenates lists to create a new list. A list can contain any number of items; there is no size limit (other than available memory). However, if memory is a concern, you should be aware that list concatenation creates a second list in memory. In this case, that new list is immediately assigned to the existing variable a_list. So this line of code is really a two-step process — concatenation then assignment — which can (temporarily) consume a lot of memory when you’re dealing with large lists.</p></li>

<li><p>A list can contain items of any datatype, and the items in a single list don’t all need to be the same type. Here we have a list containing a string, a floating point number, and an integer.</p></li>

<li><p>The append() method adds a single item to the end of the list. (Now we have four different datatypes in the list!)</p></li>

<li><p>Lists are implemented as classes. “Creating” a list is really instantiating a class. As such, a list has methods that operate on it. The extend() method takes one argument, a list, and appends each of the items of the argument to the original list.</p></li>

<li><p>The insert() method inserts a single item into a list. The first argument is the index of the first item in the list that will get bumped out of position. List items do not need to be unique; for example, there are now two separate items with the value &lsquo;O&rsquo;: the first item, a_list[0], and the last item, a_list[6].</p></li>
</ol>

<p>. a_list.insert(0, value) is like the unshift() function in Perl. It adds an item to the beginning of the list, and all the other items have their positional index bumped up to make room.
Let’s look closer at the difference between append() and extend().
&gt;&gt;&gt; a_list = [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;]
&gt;&gt;&gt; a_list.extend([&rsquo;d&rsquo;, &lsquo;e&rsquo;, &lsquo;f&rsquo;]) .
&gt;&gt;&gt; a_list
[&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;, &rsquo;d&rsquo;, &lsquo;e&rsquo;, &lsquo;f&rsquo;]
&gt;&gt;&gt; len(a_list) .
6
&gt;&gt;&gt; a_list[-1]
&lsquo;f&rsquo;
&gt;&gt;&gt; a_list.append([&lsquo;g&rsquo;, &lsquo;h&rsquo;, &lsquo;i&rsquo;]) .
&gt;&gt;&gt; a_list
[&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;, &rsquo;d&rsquo;, &lsquo;e&rsquo;, &lsquo;f&rsquo;, [&lsquo;g&rsquo;, &lsquo;h&rsquo;, &lsquo;i&rsquo;]]
&gt;&gt;&gt; len(a_list) .
7
&gt;&gt;&gt; a_list[-1]
[&lsquo;g&rsquo;, &lsquo;h&rsquo;, &lsquo;i&rsquo;]</p>

<ol>
<li><p>The extend() method takes a single argument, which is always a list, and adds each of the items of that list to a_list.</p></li>

<li><p>If you start with a list of three items and extend it with a list of another three items, you end up with a list of six items.</p></li>

<li><p>On the other hand, the append() method takes a single argument, which can be any datatype. Here, you’re calling the append() method with a list of three items.</p></li>

<li><p>If you start with a list of six items and append a list onto it, you end up with&hellip; a list of seven items. Why seven? Because the last item (which you just appended) is itself a list. Lists can contain any type of data, including other lists. That may be what you want, or it may not. But it’s what you asked for, and it’s what you got.</p></li>
</ol>

<p>2.4.4. SEARCHING FOR VALUES IN A LIST</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_list = [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;new&rsquo;, &lsquo;mpilgrim&rsquo;, &lsquo;new&rsquo;]</p>

<p>a_list.count(&lsquo;new&rsquo;) .
2</p>

<p>&lsquo;new&rsquo; in a_list .
True</p>

<p>&lsquo;c&rsquo; in a_list</p>
</blockquote>
</blockquote>
</blockquote>

<p>False</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_list.index(&lsquo;mpilgrim&rsquo;) .
3</p>

<p>a_list.index(&lsquo;new&rsquo;) .
2</p>

<p>a_list.index(&lsquo;c&rsquo;) .
Traceback (innermost last):</p>
</blockquote>
</blockquote>
</blockquote>

<p>File &ldquo;<interactive input>&rdquo;, line 1, in ?</p>

<p>ValueError: list.index(x): x not in list</p>

<ol>
<li><p>As you might expect, the count() method returns the number of occurrences of a specific value in a list.</p></li>

<li><p>If all you want to know is whether a value is in the list or not, the in operator is slightly faster than using the count() method. The in operator always returns True or False; it will not tell you how many times the value appears in the list.</p></li>

<li><p>Neither the in operator nor the count() method will tell you where in the list a value appears. If you need to know where in the list a value is, call the index() method. By default it will search the entire list, although you can specify an optional second argument of the (0-based) index to start from, and even an optional third argument of the (0-based) index to stop searching.</p></li>

<li><p>The index() method finds the first occurrence of a value in the list. In this case, &lsquo;new&rsquo; occurs twice in the list, in a_list[2] and a_list[4], but the index() method will return only the index of the first occurrence.</p></li>

<li><p>As you might not expect, if the value is not found in the list, the index() method will raise an exception.</p></li>
</ol>

<p>Wait, what? That’s right: the index() method raises an exception if it doesn’t find the value in the list. This is notably different from most languages, which will return some invalid index (like -1). While this may seem annoying at first, I think you will come to appreciate it. It means your program will crash at the source of the problem instead of failing strangely and silently later. Remember, -1 is
a
valid
list
index. If the index() method returned -1, that could lead to some not-so-fun debugging sessions!</p>

<p>2.4.5. REMOVING ITEMS FROM A LIST
Lists can expand and contract automatically. You’ve seen the expansion part. There are several different ways to
remove items from a list as well.</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_list = [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;new&rsquo;, &lsquo;mpilgrim&rsquo;, &lsquo;new&rsquo;]
a_list[1]
&lsquo;b&rsquo;
del a_list[1] .
a_list
[&lsquo;a&rsquo;, &lsquo;new&rsquo;, &lsquo;mpilgrim&rsquo;, &lsquo;new&rsquo;]
a_list[1] .
&lsquo;new&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>You can use the del statement to delete a specific item from a list.</p></li>

<li><p>Accessing index 1 after deleting index 1 does not result in an error. All items after the deleted item shift their positional index to “fill the gap” created by deleting the item.</p></li>
</ol>

<p>Don’t know the positional index? Not a problem; you can remove items by value instead.
&gt;&gt;&gt; a_list.remove(&lsquo;new&rsquo;) .
&gt;&gt;&gt; a_list
[&lsquo;a&rsquo;, &lsquo;mpilgrim&rsquo;, &lsquo;new&rsquo;]
&gt;&gt;&gt; a_list.remove(&lsquo;new&rsquo;) .
&gt;&gt;&gt; a_list
[&lsquo;a&rsquo;, &lsquo;mpilgrim&rsquo;]
&gt;&gt;&gt; a_list.remove(&lsquo;new&rsquo;)</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
ValueError: list.remove(x): x not in list</p>

<ol>
<li><p>You can also remove an item from a list with the remove() method. The remove() method takes a value and removes the first occurrence of that value from the list. Again, all items after the deleted item will have their positional indices bumped down to “fill the gap.” Lists never have gaps.</p></li>

<li><p>You can call the remove() method as often as you like, but it will raise an exception if you try to remove a value that isn’t in the list.</p></li>
</ol>

<p>2.4.6. REMOVING ITEMS FROM A LIST: BONUS ROUND
Another interesting list method is pop(). The pop() method is yet another way to remove
items
from
a
list, but with a twist.
&gt;&gt;&gt; a_list = [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;new&rsquo;, &lsquo;mpilgrim&rsquo;]</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_list.pop() .
&lsquo;mpilgrim&rsquo;
a_list
[&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;new&rsquo;]
a_list.pop(1) .
&lsquo;b&rsquo;
a_list
[&lsquo;a&rsquo;, &lsquo;new&rsquo;]
a_list.pop()
&lsquo;new&rsquo;
a_list.pop()
&lsquo;a&rsquo;
a_list.pop() .</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
IndexError: pop from empty list</p>

<ol>
<li><p>When called without arguments, the pop() list method removes the last item in the list and returns the value it removed.</p></li>

<li><p>You can pop arbitrary items from a list. Just pass a positional index to the pop() method. It will remove that item, shift all the items after it to “fill the gap,” and return the value it removed.</p></li>

<li><p>Calling pop() on an empty list raises an exception.</p></li>
</ol>

<p>. Calling the pop() list method without an argument is like the pop() function in Perl. It removes the last item from the list and returns the value of the removed item. Perl has another function, shift(), which removes the first item and returns its value; in Python, this is equivalent to a_list.pop(0).</p>

<p>2.4.7. LISTS IN A BOOLEAN CONTEXT</p>

<p>You can also use a list in a
boolean
context, such as an if statement.
&gt;&gt;&gt;  def is_it_true(anything):<br />
&hellip;  if anything:<br />
&hellip;  print(&ldquo;yes, it&rsquo;s true&rdquo;)<br />
&hellip;  else:<br />
&hellip;  print(&ldquo;no, it&rsquo;s false&rdquo;)<br />
&hellip;<br />
&gt;&gt;&gt;  is_it_true([])  .</p>

<p>no, it&rsquo;s false &gt;&gt;&gt; is_it_true([&lsquo;a&rsquo;]) . yes, it&rsquo;s true &gt;&gt;&gt; is_it_true([False]) .</p>

<p>yes, it&rsquo;s true</p>

<ol>
<li><p>In a boolean context, an empty list is false.</p></li>

<li><p>Any list with at least one item is true.</p></li>

<li><p>Any list with at least one item is true. The value of the items is irrelevant.</p></li>
</ol>

<p>.
2.5. TUPLES
A tuple is an immutable list. A tuple can not be changed in any way once it is created.
&gt;&gt;&gt; a_tuple = (&ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;mpilgrim&rdquo;, &ldquo;z&rdquo;, &ldquo;example&rdquo;) .
&gt;&gt;&gt; a_tuple
(&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;, &lsquo;z&rsquo;, &lsquo;example&rsquo;)
&gt;&gt;&gt; a_tuple[0] .
&lsquo;a&rsquo;
&gt;&gt;&gt; a_tuple[-1] .
&lsquo;example&rsquo;
&gt;&gt;&gt; a_tuple[1:3] .
(&lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;)</p>

<ol>
<li><p>A tuple is defined in the same way as a list, except that the whole set of elements is enclosed in parentheses instead of square brackets.</p></li>

<li><p>The elements of a tuple have a defined order, just like a list. Tuple indices are zero-based, just like a list, so the first element of a non-empty tuple is always a_tuple[0].</p></li>

<li><p>Negative indices count from the end of the tuple, just like a list.</p></li>

<li><p>Slicing works too, just like a list. When you slice a list, you get a new list; when you slice a tuple, you get a new tuple.</p></li>
</ol>

<p>The major difference between tuples and lists is that tuples can not be changed. In technical terms, tuples are immutable. In practical terms, they have no methods that would allow you to change them. Lists have methods like append(), extend(), insert(), remove(), and pop(). Tuples have none of these methods. You can slice a tuple (because that creates a new tuple), and you can check whether a tuple contains a particular value (because that doesn’t change the tuple), and… that’s about it.</p>

<h1 id="continued-from-the-previous-example">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>a_tuple</p>
</blockquote>
</blockquote>
</blockquote>

<p>(&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;, &lsquo;z&rsquo;, &lsquo;example&rsquo;)</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_tuple.append(&ldquo;new&rdquo;)   .
Traceback (innermost last):</p>
</blockquote>
</blockquote>
</blockquote>

<p>File &ldquo;<interactive input>&rdquo;, line 1, in ?</p>

<p>AttributeError: &lsquo;tuple&rsquo; object has no attribute &lsquo;append&rsquo;</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_tuple.remove(&ldquo;z&rdquo;)     .
Traceback (innermost last):</p>
</blockquote>
</blockquote>
</blockquote>

<p>File &ldquo;<interactive input>&rdquo;, line 1, in ?</p>

<p>AttributeError: &lsquo;tuple&rsquo; object has no attribute &lsquo;remove&rsquo;</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_tuple.index(&ldquo;example&rdquo;) .
4</p>

<p>&ldquo;z&rdquo; in a_tuple  .
True</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>You can’t add elements to a tuple. Tuples have no append() or extend() method.</p></li>

<li><p>You can’t remove elements from a tuple. Tuples have no remove() or pop() method.</p></li>

<li><p>You can find elements in a tuple, since this doesn’t change the tuple.</p></li>

<li><p>You can also use the in operator to check if an element exists in the tuple.</p></li>
</ol>

<p>So what are tuples good for?
•   Tuples are faster than lists. If you’re defining a constant set of values and all you’re ever going to do with it is iterate through it, use a tuple instead of a list.</p>

<p>•   It makes your code safer if you “write-protect” data that doesn’t need to be changed. Using a tuple instead of a list is like having an implied assert statement that shows this data is constant, and that special thought (and a specific function) is required to override that.</p>

<p>•   Some tuples can be used as dictionary keys (specifically, tuples that contain immutable values like strings,
numbers, and other tuples). Lists can never be used as dictionary keys, because lists are not immutable.</p>

<p>.</p>

<p>Tuples can be converted into lists, and vice-versa. The built-in tuple() function takes a list and returns a tuple with the same elements, and the list() function takes a tuple and returns a list. In effect, tuple() freezes a list, and list() thaws a tuple.
2.5.1. TUPLES IN A BOOLEAN CONTEXT
You can use tuples in a
boolean
context, such as an if statement.
&gt;&gt;&gt; def is_it_true(anything):
&hellip; if anything:
&hellip; print(&ldquo;yes, it&rsquo;s true&rdquo;)
&hellip; else:
&hellip; print(&ldquo;no, it&rsquo;s false&rdquo;)
&hellip;
&gt;&gt;&gt; is_it_true(()) .
no, it&rsquo;s false
&gt;&gt;&gt; is_it_true((&lsquo;a&rsquo;, &lsquo;b&rsquo;)) .
yes, it&rsquo;s true
&gt;&gt;&gt; is_it_true((False,)) .
yes, it&rsquo;s true
&gt;&gt;&gt; type((False)) .
<class 'bool'>
&gt;&gt;&gt; type((False,))
<class 'tuple'></p>

<ol>
<li><p>In a boolean context, an empty tuple is false.</p></li>

<li><p>Any tuple with at least one item is true.</p></li>

<li><p>Any tuple with at least one item is true. The value of the items is irrelevant. But what’s that comma doing there?</p></li>

<li><p>To create a tuple of one item, you need a comma after the value. Without the comma, Python just assumes you have an extra pair of parentheses, which is harmless, but it doesn’t create a tuple.</p></li>
</ol>

<p>2.5.2. ASSIGNING MULTIPLE VALUES AT ONCE</p>

<p>Here’s a cool programming shortcut: in Python, you can use a tuple to assign multiple values at once.
&gt;&gt;&gt; v = (&lsquo;a&rsquo;, 2, True)
&gt;&gt;&gt; (x, y, z) = v .
&gt;&gt;&gt; x
&lsquo;a&rsquo;
&gt;&gt;&gt; y
2
&gt;&gt;&gt; z
True</p>

<ol>
<li>v is a tuple of three elements, and (x, y, z) is a tuple of three variables. Assigning one to the other assigns each of the values of v to each of the variables, in order.
This has all kinds of uses. Suppose you want to assign names to a range of values. You can use the built-in range() function with multi-variable assignment to quickly assign consecutive values.
&gt;&gt;&gt; (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7) . &gt;&gt;&gt; MONDAY . 0 &gt;&gt;&gt; TUESDAY 1 &gt;&gt;&gt; SUNDAY 6</li>

<li><p>The built-in range() function constructs a sequence of integers. (Technically, the range() function returns an iterator, not a list or a tuple, but you’ll learn about that distinction later.) MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY are the variables you’re defining. (This example came from the calendar module, a fun little module that prints calendars, like the UNIX program cal. The calendar module defines integer constants for days of the week.)</p></li>

<li><p>Now each variable has its value: MONDAY is 0, TUESDAY is 1, and so forth.</p></li>
</ol>

<p>You can also use multi-variable assignment to build functions that return multiple values, simply by returning a tuple of all the values. The caller can treat it as a single tuple, or it can assign the values to individual variables. Many standard Python libraries do this, including the os module, which you&rsquo;ll learn about in the
next
chapter.</p>

<p>.
2.6. SETS
A set is an unordered “bag” of unique values. A single set can contain values of any immutable datatype. Once you have two sets, you can do standard set operations like union, intersection, and set difference.
2.6.1. CREATING A SET
First things first. Creating a set is easy.
&gt;&gt;&gt; a_set = {1} .
&gt;&gt;&gt; a_set
{1}
&gt;&gt;&gt; type(a_set) .
<class 'set'>
&gt;&gt;&gt; a_set = {1, 2} .
&gt;&gt;&gt; a_set
{1, 2}</p>

<ol>
<li><p>To create a set with one value, put the value in curly brackets ({}).</p></li>

<li><p>Sets are actually implemented as classes, but don’t worry about that for now.</p></li>

<li><p>To create a set with multiple values, separate the values with commas and wrap it all up with curly brackets.</p></li>
</ol>

<p>You can also create a set out of a list.
&gt;&gt;&gt; a_list = [&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;, True, False, 42]
&gt;&gt;&gt; a_set = set(a_list) .
&gt;&gt;&gt; a_set .
{&lsquo;a&rsquo;, False, &lsquo;b&rsquo;, True, &lsquo;mpilgrim&rsquo;, 42}
&gt;&gt;&gt; a_list .
[&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;mpilgrim&rsquo;, True, False, 42]</p>

<ol>
<li><p>To create a set from a list, use the set() function. (Pedants who know about how sets are implemented will point out that this is not really calling a function, but instantiating a class. I promise you will learn the difference later in this book. For now, just know that set() acts like a function, and it returns a set.)</p></li>

<li><p>As I mentioned earlier, a single set can contain values of any datatype. And, as I mentioned earlier, sets are unordered. This set does not remember the original order of the list that was used to create it. If you were to add items to this set, it would not remember the order in which you added them.</p></li>

<li><p>The original list is unchanged.</p></li>
</ol>

<p>Don’t have any values yet? Not a problem. You can create an empty set.
&gt;&gt;&gt; a_set = set() .
&gt;&gt;&gt; a_set .
set()
&gt;&gt;&gt; type(a_set) .
<class 'set'>
&gt;&gt;&gt; len(a_set) .
0
&gt;&gt;&gt; not_sure = {} .
&gt;&gt;&gt; type(not_sure)
<class 'dict'></p>

<ol>
<li><p>To create an empty set, call set() with no arguments.</p></li>

<li><p>The printed representation of an empty set looks a bit strange. Were you expecting {}, perhaps? That would denote an empty dictionary, not an empty set. You’ll learn about dictionaries later in this chapter.</p></li>

<li><p>Despite the strange printed representation, this is a set…</p></li>

<li><p>…and this set has no members.</p></li>

<li><p>Due to historical quirks carried over from Python 2, you can not create an empty set with two curly</p></li>
</ol>

<p>brackets. This actually creates an empty dictionary, not an empty set.</p>

<p>2.6.2. MODIFYING A SET
There are two different ways to add values to an existing set: the add() method, and the update() method.
&gt;&gt;&gt; a_set = {1, 2}
&gt;&gt;&gt; a_set.add(4) .
&gt;&gt;&gt; a_set
{1, 2, 4}
&gt;&gt;&gt; len(a_set) .
3
&gt;&gt;&gt; a_set.add(1) .
&gt;&gt;&gt; a_set
{1, 2, 4}
&gt;&gt;&gt; len(a_set) .
3</p>

<ol>
<li><p>The add() method takes a single argument, which can be any datatype, and adds the given value to the set.</p></li>

<li><p>This set now has 3 members.</p></li>

<li><p>Sets are bags of unique values. If you try to add a value that already exists in the set, it will do nothing. It won’t raise an error; it’s just a no-op.</p></li>

<li><p>This set still has 3 members.</p></li>
</ol>

<blockquote>
<blockquote>
<blockquote>
<p>a_set = {1, 2, 3}</p>

<p>a_set
{1, 2, 3}
a_set.update({2, 4, 6}) .
a_set .
{1, 2, 3, 4, 6}
a_set.update({3, 6, 9}, {1, 2, 3, 5, 8, 13}) .
a_set
{1, 2, 3, 4, 5, 6, 8, 9, 13}
a_set.update([10, 20, 30]) .
a_set
{1, 2, 3, 4, 5, 6, 8, 9, 10, 13, 20, 30}</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>The update() method takes one argument, a set, and adds all its members to the original set. It’s as if you called the add() method with each member of the set.</p></li>

<li><p>Duplicate values are ignored, since sets can not contain duplicates.</p></li>

<li><p>You can actually call the update() method with any number of arguments. When called with two sets, the update() method adds all the members of each set to the original set (dropping duplicates).</p></li>

<li><p>The update() method can take objects of a number of different datatypes, including lists. When called with a list, the update() method adds all the items of the list to the original set.</p></li>
</ol>

<p>2.6.3. REMOVING ITEMS FROM A SET
There are three ways to remove individual values from a set. The first two, discard() and remove(), have one subtle difference.
&gt;&gt;&gt; a_set = {1, 3, 6, 10, 15, 21, 28, 36, 45}</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_set
{1, 3, 36, 6, 10, 45, 15, 21, 28}
a_set.discard(10) .
a_set
{1, 3, 36, 6, 45, 15, 21, 28}
a_set.discard(10) .
a_set
{1, 3, 36, 6, 45, 15, 21, 28}
a_set.remove(21) .
a_set
{1, 3, 36, 6, 45, 15, 28}
a_set.remove(21) .</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
KeyError: 21</p>

<ol>
<li><p>The discard() method takes a single value as an argument and removes that value from the set.</p></li>

<li><p>If you call the discard() method with a value that doesn’t exist in the set, it does nothing. No error; it’s just a no-op.</p></li>

<li><p>The remove() method also takes a single value as an argument, and it also removes that value from the set.</p></li>

<li><p>Here’s the difference: if the value doesn’t exist in the set, the remove() method raises a KeyError exception.</p></li>
</ol>

<p>Like lists, sets have a pop() method.
&gt;&gt;&gt; a_set = {1, 3, 6, 10, 15, 21, 28, 36, 45}</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_set.pop()     .
1</p>

<p>a_set.pop()</p>
</blockquote>
</blockquote>
</blockquote>

<p>3</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_set.pop()</p>
</blockquote>
</blockquote>
</blockquote>

<p>36</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_set</p>
</blockquote>
</blockquote>
</blockquote>

<p>{6, 10, 45, 15, 21, 28}</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_set.clear()   .
a_set</p>
</blockquote>
</blockquote>
</blockquote>

<p>set()</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_set.pop()     .
Traceback (most recent call last):</p>
</blockquote>
</blockquote>
</blockquote>

<p>File &ldquo;<stdin>&rdquo;, line 1, in <module></p>

<p>KeyError: &lsquo;pop from an empty set&rsquo;</p>

<ol>
<li><p>The pop() method removes a single value from a set and returns the value. However, since sets are unordered, there is no “last” value in a set, so there is no way to control which value gets removed. It is completely arbitrary.</p></li>

<li><p>The clear() method removes all values from a set, leaving you with an empty set. This is equivalent to a_set = set(), which would create a new empty set and overwrite the previous value of the a_set variable.</p></li>

<li><p>Attempting to pop a value from an empty set will raise a KeyError exception.</p></li>
</ol>

<p>2.6.4. COMMON SET OPERATIONS
Python’s set type supports several common set operations.
&gt;&gt;&gt; a_set = {2, 4, 5, 9, 12, 21, 30, 51, 76, 127, 195}
&gt;&gt;&gt; 30 in a_set .
True
&gt;&gt;&gt; 31 in a_set
False
&gt;&gt;&gt; b_set = {1, 2, 3, 5, 6, 8, 9, 12, 15, 17, 18, 21}
&gt;&gt;&gt; a_set.union(b_set) .
{1, 2, 195, 4, 5, 6, 8, 12, 76, 15, 17, 18, 3, 21, 30, 51, 9, 127}
&gt;&gt;&gt; a_set.intersection(b_set) .
{9, 2, 12, 5, 21}
&gt;&gt;&gt; a_set.difference(b_set) .
{195, 4, 76, 51, 30, 127}
&gt;&gt;&gt; a_set.symmetric_difference(b_set) .
{1, 3, 4, 6, 8, 76, 15, 17, 18, 195, 127, 30, 51}</p>

<ol>
<li><p>To test whether a value is a member of a set, use the in operator. This works the same as lists.</p></li>

<li><p>The union() method returns a new set containing all the elements that are in either set.</p></li>

<li><p>The intersection() method returns a new set containing all the elements that are in both sets.</p></li>

<li><p>The difference() method returns a new set containing all the elements that are in a_set but not b_set.</p></li>

<li><p>The symmetric_difference() method returns a new set containing all the elements that are in exactly one of the sets.</p></li>
</ol>

<p>Three of these methods are symmetric.</p>

<h1 id="continued-from-the-previous-example-1">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>b_set.symmetric_difference(a_set) .
{3, 1, 195, 4, 6, 8, 76, 15, 17, 18, 51, 30, 127}
b_set.symmetric_difference(a_set) == a_set.symmetric_difference(b_set) .
True
b_set.union(a_set) == a_set.union(b_set) .
True
b_set.intersection(a_set) == a_set.intersection(b_set) .
True
b_set.difference(a_set) == a_set.difference(b_set) .
False</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>The symmetric difference of a_set from b_set looks different than the symmetric difference of b_set from a_set, but remember, sets are unordered. Any two sets that contain all the same values (with none left over) are considered equal.</p></li>

<li><p>And that’s exactly what happens here. Don’t be fooled by the Python Shell’s printed representation of these sets. They contain the same values, so they are equal.</p></li>

<li><p>The union of two sets is also symmetric.</p></li>

<li><p>The intersection of two sets is also symmetric.</p></li>

<li><p>The difference of two sets is not symmetric. That makes sense; it’s analogous to subtracting one number from another. The order of the operands matters.</p></li>
</ol>

<p>Finally, there are a few questions you can ask of sets.
&gt;&gt;&gt; a_set = {1, 2, 3}
&gt;&gt;&gt; b_set = {1, 2, 3, 4}
&gt;&gt;&gt; a_set.issubset(b_set) .
True
&gt;&gt;&gt; b_set.issuperset(a_set) .
True
&gt;&gt;&gt; a_set.add(5) .
&gt;&gt;&gt; a_set.issubset(b_set)
False
&gt;&gt;&gt; b_set.issuperset(a_set)
False</p>

<ol>
<li><p>a_set is a subset of b_set — all the members of a_set are also members of b_set.</p></li>

<li><p>Asking the same question in reverse, b_set is a superset of a_set, because all the members of a_set are also members of b_set.</p></li>

<li><p>As soon as you add a value to a_set that is not in b_set, both tests return False.</p></li>
</ol>

<p>2.6.5. SETS IN A BOOLEAN CONTEXT
You can use sets in a
boolean
context, such as an if statement.
&gt;&gt;&gt; def is_it_true(anything):
&hellip; if anything:
&hellip; print(&ldquo;yes, it&rsquo;s true&rdquo;)
&hellip; else:
&hellip; print(&ldquo;no, it&rsquo;s false&rdquo;)
&hellip;
&gt;&gt;&gt; is_it_true(set()) .
no, it&rsquo;s false
&gt;&gt;&gt; is_it_true({&lsquo;a&rsquo;}) .
yes, it&rsquo;s true
&gt;&gt;&gt; is_it_true({False}) .
yes, it&rsquo;s true</p>

<ol>
<li><p>In a boolean context, an empty set is false.</p></li>

<li><p>Any set with at least one item is true.</p></li>

<li><p>Any set with at least one item is true. The value of the items is irrelevant.</p></li>
</ol>

<p>.
2.7. DICTIONARIES
A dictionary is an unordered set of key-value pairs. When you add a key to a dictionary, you must also add a value for that key. (You can always change the value later.) Python dictionaries are optimized for retrieving the value when you know the key, but not the other way around.
. A dictionary in Python is like a hash in Perl 5. In Perl 5, variables that store hashes always start with a % character. In Python, variables can be named anything, and Python keeps track of the datatype internally.
2.7.1. CREATING A DICTIONARY
Creating a dictionary is easy. The syntax is similar to sets, but instead of values, you have key-value pairs. Once you have a dictionary, you can look up values by their key.
&gt;&gt;&gt; a_dict = {&lsquo;server&rsquo;: &lsquo;db.diveintopython3.org&rsquo;, &lsquo;database&rsquo;: &lsquo;mysql&rsquo;} .
&gt;&gt;&gt; a_dict
{&lsquo;server&rsquo;: &lsquo;db.diveintopython3.org&rsquo;, &lsquo;database&rsquo;: &lsquo;mysql&rsquo;}
&gt;&gt;&gt; a_dict[&lsquo;server&rsquo;] .
&lsquo;db.diveintopython3.org&rsquo;
&gt;&gt;&gt; a_dict[&lsquo;database&rsquo;] .
&lsquo;mysql&rsquo;
&gt;&gt;&gt; a_dict[&lsquo;db.diveintopython3.org&rsquo;] .</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
KeyError: &lsquo;db.diveintopython3.org&rsquo;</p>

<ol>
<li><p>First, you create a new dictionary with two items and assign it to the variable a_dict. Each item is a key-value pair, and the whole set of items is enclosed in curly braces.</p></li>

<li><p>&lsquo;server&rsquo; is a key, and its associated value, referenced by a_dict[&lsquo;server&rsquo;], is &lsquo;db.diveintopython3.org&rsquo;.</p></li>

<li><p>&lsquo;database&rsquo; is a key, and its associated value, referenced by a_dict[&lsquo;database&rsquo;], is &lsquo;mysql&rsquo;.</p></li>

<li><p>You can get values by key, but you can’t get keys by value. So a_dict[&lsquo;server&rsquo;] is &lsquo;db.diveintopython3.org&rsquo;, but a_dict[&lsquo;db.diveintopython3.org&rsquo;] raises an exception, because &lsquo;db.diveintopython3.org&rsquo; is not a key.</p></li>
</ol>

<p>2.7.2. MODIFYING A DICTIONARY
Dictionaries do not have any predefined size limit. You can add new key-value pairs to a dictionary at any time, or you can modify the value of an existing key. Continuing from the previous example:
&gt;&gt;&gt; a_dict</p>

<p>{&lsquo;server&rsquo;: &lsquo;db.diveintopython3.org&rsquo;, &lsquo;database&rsquo;: &lsquo;mysql&rsquo;}
&gt;&gt;&gt; a_dict[&lsquo;database&rsquo;] = &lsquo;blog&rsquo; .
&gt;&gt;&gt; a_dict
{&lsquo;server&rsquo;: &lsquo;db.diveintopython3.org&rsquo;, &lsquo;database&rsquo;: &lsquo;blog&rsquo;}
&gt;&gt;&gt; a_dict[&lsquo;user&rsquo;] = &lsquo;mark&rsquo; .
&gt;&gt;&gt; a_dict .
{&lsquo;server&rsquo;: &lsquo;db.diveintopython3.org&rsquo;, &lsquo;user&rsquo;: &lsquo;mark&rsquo;, &lsquo;database&rsquo;: &lsquo;blog&rsquo;}
&gt;&gt;&gt; a_dict[&lsquo;user&rsquo;] = &lsquo;dora&rsquo; .
&gt;&gt;&gt; a_dict
{&lsquo;server&rsquo;: &lsquo;db.diveintopython3.org&rsquo;, &lsquo;user&rsquo;: &lsquo;dora&rsquo;, &lsquo;database&rsquo;: &lsquo;blog&rsquo;}
&gt;&gt;&gt; a_dict[&lsquo;User&rsquo;] = &lsquo;mark&rsquo; .
&gt;&gt;&gt; a_dict
{&lsquo;User&rsquo;: &lsquo;mark&rsquo;, &lsquo;server&rsquo;: &lsquo;db.diveintopython3.org&rsquo;, &lsquo;user&rsquo;: &lsquo;dora&rsquo;, &lsquo;database&rsquo;: &lsquo;blog&rsquo;}</p>

<ol>
<li><p>You can not have duplicate keys in a dictionary. Assigning a value to an existing key will wipe out the old value.</p></li>

<li><p>You can add new key-value pairs at any time. This syntax is identical to modifying existing values.</p></li>

<li><p>The new dictionary item (key &lsquo;user&rsquo;, value &lsquo;mark&rsquo;) appears to be in the middle. In fact, it was just a coincidence that the items appeared to be in order in the first example; it is just as much a coincidence that they appear to be out of order now.</p></li>

<li><p>Assigning a value to an existing dictionary key simply replaces the old value with the new one.</p></li>

<li><p>Will this change the value of the user key back to &ldquo;mark&rdquo;? No! Look at the key closely — that’s a capital U in &ldquo;User&rdquo;. Dictionary keys are case-sensitive, so this statement is creating a new key-value pair, not overwriting an existing one. It may look similar to you, but as far as Python is concerned, it’s completely different.</p></li>
</ol>

<p>2.7.3. MIXED-VALUE DICTIONARIES
Dictionaries aren’t just for strings. Dictionary values can be any datatype, including integers, booleans, arbitrary objects, or even other dictionaries. And within a single dictionary, the values don’t all need to be the same type; you can mix and match as needed. Dictionary keys are more restricted, but they can be strings, integers, and a few other types. You can also mix and match key datatypes within a dictionary.
In fact, you’ve already seen a dictionary with non-string keys and values, in your
first
Python
program.
SUFFIXES = {1000: [&lsquo;KB&rsquo;, &lsquo;MB&rsquo;, &lsquo;GB&rsquo;, &lsquo;TB&rsquo;, &lsquo;PB&rsquo;, &lsquo;EB&rsquo;, &lsquo;ZB&rsquo;, &lsquo;YB&rsquo;],
1024: [&lsquo;KiB&rsquo;, &lsquo;MiB&rsquo;, &lsquo;GiB&rsquo;, &lsquo;TiB&rsquo;, &lsquo;PiB&rsquo;, &lsquo;EiB&rsquo;, &lsquo;ZiB&rsquo;, &lsquo;YiB&rsquo;]}</p>

<p>Let&rsquo;s tear that apart in the interactive shell.
&gt;&gt;&gt; SUFFIXES = {1000: [&lsquo;KB&rsquo;, &lsquo;MB&rsquo;, &lsquo;GB&rsquo;, &lsquo;TB&rsquo;, &lsquo;PB&rsquo;, &lsquo;EB&rsquo;, &lsquo;ZB&rsquo;, &lsquo;YB&rsquo;],
&hellip; 1024: [&lsquo;KiB&rsquo;, &lsquo;MiB&rsquo;, &lsquo;GiB&rsquo;, &lsquo;TiB&rsquo;, &lsquo;PiB&rsquo;, &lsquo;EiB&rsquo;, &lsquo;ZiB&rsquo;, &lsquo;YiB&rsquo;]}
&gt;&gt;&gt; len(SUFFIXES) .
2
&gt;&gt;&gt; 1000 in SUFFIXES .
True
&gt;&gt;&gt; SUFFIXES[1000] .
[&lsquo;KB&rsquo;, &lsquo;MB&rsquo;, &lsquo;GB&rsquo;, &lsquo;TB&rsquo;, &lsquo;PB&rsquo;, &lsquo;EB&rsquo;, &lsquo;ZB&rsquo;, &lsquo;YB&rsquo;]
&gt;&gt;&gt; SUFFIXES[1024] .
[&lsquo;KiB&rsquo;, &lsquo;MiB&rsquo;, &lsquo;GiB&rsquo;, &lsquo;TiB&rsquo;, &lsquo;PiB&rsquo;, &lsquo;EiB&rsquo;, &lsquo;ZiB&rsquo;, &lsquo;YiB&rsquo;]
&gt;&gt;&gt; SUFFIXES[1000][3] .
&lsquo;TB&rsquo;</p>

<ol>
<li><p>Like lists
and sets, the len() function gives you the number of keys in a dictionary.</p></li>

<li><p>And like lists and sets, you can use the in operator to test whether a specific key is defined in a dictionary.</p></li>

<li><p>1000 is a key in the SUFFIXES dictionary; its value is a list of eight items (eight strings, to be precise).</p></li>

<li><p>Similarly, 1024 is a key in the SUFFIXES dictionary; its value is also a list of eight items.</p></li>

<li><p>Since SUFFIXES[1000] is a list, you can address individual items in the list by their 0-based index.</p></li>
</ol>

<p>2.7.4. DICTIONARIES IN A BOOLEAN CONTEXT</p>

<p>You can also use a dictionary in a
boolean
context, such as an if statement.
&gt;&gt;&gt; def is_it_true(anything):
&hellip; if anything:
&hellip; print(&ldquo;yes, it&rsquo;s true&rdquo;)
&hellip; else:
&hellip; print(&ldquo;no, it&rsquo;s false&rdquo;)
&hellip;
&gt;&gt;&gt; is_it_true({}) .
no, it&rsquo;s false
&gt;&gt;&gt; is_it_true({&lsquo;a&rsquo;: 1}) .
yes, it&rsquo;s true</p>

<ol>
<li><p>In a boolean context, an empty dictionary is false.</p></li>

<li><p>Any dictionary with at least one key-value pair is true.</p></li>
</ol>

<p>.</p>

<p>2.8. None
None is a special constant in Python. It is a null value. None is not the same as False. None is not 0. None is not an empty string. Comparing None to anything other than None will always return False.
None is the only null value. It has its own datatype (NoneType). You can assign None to any variable, but you can not create other NoneType objects. All variables whose value is None are equal to each other.
&gt;&gt;&gt; type(None)</p>

<p><class 'NoneType'>
&gt;&gt;&gt; None == False
False
&gt;&gt;&gt; None == 0
False
&gt;&gt;&gt; None == &ldquo;
False
&gt;&gt;&gt; None == None
True
&gt;&gt;&gt; x = None
&gt;&gt;&gt; x == None
True
&gt;&gt;&gt; y = None
&gt;&gt;&gt; x == y
True</p>

<p>2.8.1. None IN A BOOLEAN CONTEXT
In a
boolean
context, None is false and not None is true.
&gt;&gt;&gt; def is_it_true(anything):</p>

<p>&hellip;  if anything:<br />
&hellip;  print(&ldquo;yes, it&rsquo;s true&rdquo;)<br />
&hellip;  else:<br />
&hellip;  print(&ldquo;no, it&rsquo;s false&rdquo;)<br />
&hellip;</p>

<blockquote>
<blockquote>
<blockquote>
<p>is_it_true(None)
no, it&rsquo;s false
is_it_true(not None)
yes, it&rsquo;s true</p>
</blockquote>
</blockquote>
</blockquote>

<p>.</p>

<p>2.9. FURTHER READING
• Boolean
operations</p>

<p>• Numeric
types</p>

<p>• Sequence
types</p>

<p>• Set
types</p>

<p>• Mapping
types</p>

<p>• fractions module</p>

<p>• math module</p>

<p>• PEP
237:
Unifying
Long
Integers
and
Integers</p>

<p>• PEP
238:
Changing
the
Division
Operator</p>

<p>CHAPTER 3. COMPREHENSIONS</p>

<p>. Our imagination is stretched to the utmost, not, as in fiction, to imagine things which are not really there, but just to comprehend those things which are. .
— Richard Feynman</p>

<p>3.1. DIVING IN
Every programming language has that one feature, a complicated thing intentionally made simple. If you’re coming from another language, you could easily miss it, because your old language didn’t make that thing simple (because it was busy making something else simple instead). This chapter will teach you about list comprehensions, dictionary comprehensions, and set comprehensions: three related concepts centered around one very powerful technique. But first, I want to take a little detour into two modules that will help you navigate your local file system.</p>

<p>.</p>

<p>3.2. WORKING WITH FILES AND DIRECTORIES
Python 3 comes with a module called os, which stands for “operating system.” The os module
contains a plethora of functions to get information on — and in some cases, to manipulate — local directories, files, processes, and environment variables. Python does its best to offer a unified API across all
supported
operating
systems
so your programs can run on any computer with as little platform-specific code as possible.
3.2.1. THE CURRENT WORKING DIRECTORY</p>

<p>When you’re just getting started with Python, you’re going to spend a lot of time in the
Python
Shell. Throughout this book, you will see examples that go like this:
1. Import one of the modules in the examples folder</p>

<ol>
<li><p>Call a function in that module</p></li>

<li><p>Explain the result</p></li>
</ol>

<p>If you don’t know about the current working directory,
step 1 will probably fail with an ImportError. Why?
Because Python will look for the example module in the</p>

<p>import
search
path, but it won’t find it because the
examples folder isn’t one of the directories in the
search path. To get past this, you can do one of two
things:</p>

<ol>
<li><p>Add the examples folder to the import search path</p></li>

<li><p>Change the current working directory to the examples folder</p></li>
</ol>

<p>The current working directory is an invisible property that Python holds in memory at all times. There is always a current working directory, whether you’re in the Python Shell, running your own Python script from the command line, or running a Python CGI script on a web server somewhere.</p>

<p>The os module contains two functions to deal with the current working directory.
&gt;&gt;&gt; import os .
&gt;&gt;&gt; print(os.getcwd()) .
C:\Python31
&gt;&gt;&gt; os.chdir(&lsquo;/Users/pilgrim/diveintopython3/examples&rsquo;) .
&gt;&gt;&gt; print(os.getcwd()) .
C:\Users\pilgrim\diveintopython3\examples</p>

<ol>
<li><p>The os module comes with Python; you can import it anytime, anywhere.</p></li>

<li><p>Use the os.getcwd() function to get the current working directory. When you run the graphical Python Shell, the current working directory starts as the directory where the Python Shell executable is. On Windows, this depends on where you installed Python; the default directory is c:\Python31. If you run the Python Shell from the command line, the current working directory starts as the directory you were in when you ran python3.</p></li>

<li><p>Use the os.chdir() function to change the current working directory.</p></li>

<li><p>When I called the os.chdir() function, I used a Linux-style pathname (forward slashes, no drive letter) even though I’m on Windows. This is one of the places where Python tries to paper over the differences between operating systems.</p></li>
</ol>

<p>3.2.2. WORKING WITH FILENAMES AND DIRECTORY NAMES
While we’re on the subject of directories, I want to point out the os.path module. os.path contains
functions for manipulating filenames and directory names.</p>

<blockquote>
<blockquote>
<blockquote>
<p>import os</p>

<p>print(os.path.join(&lsquo;/Users/pilgrim/diveintopython3/examples/&rsquo;, &lsquo;humansize.py&rsquo;))
/Users/pilgrim/diveintopython3/examples/humansize.py</p>

<p>print(os.path.join(&lsquo;/Users/pilgrim/diveintopython3/examples&rsquo;, &lsquo;humansize.py&rsquo;))
/Users/pilgrim/diveintopython3/examples\humansize.py</p>

<p>print(os.path.expanduser(&rsquo;~&lsquo;))
c:\Users\pilgrim</p>

<p>print(os.path.join(os.path.expanduser(&rsquo;~&lsquo;), &lsquo;diveintopython3&rsquo;, &lsquo;examples&rsquo;, &lsquo;humansize.py&rsquo;))
c:\Users\pilgrim\diveintopython3\examples\humansize.py</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>The os.path.join() function constructs a pathname out of one or more partial pathnames. In this case, it simply concatenates strings.</p></li>

<li><p>In this slightly less trivial case, calling the os.path.join() function will add an extra slash to the pathname before joining it to the filename. It’s a backslash instead of a forward slash, because I constructed this example on Windows. If you replicate this example on Linux or Mac OS X, you’ll see a forward slash instead. Don’t fuss with slashes; always use os.path.join() and let Python do the right thing.</p></li>

<li><p>The os.path.expanduser() function will expand a pathname that uses ~ to represent the current user’s home directory. This works on any platform where users have a home directory, including Linux, Mac OS X, and Windows. The returned path does not have a trailing slash, but the os.path.join() function doesn’t mind.</p></li>

<li><p>Combining these techniques, you can easily construct pathnames for directories and files in the user’s home directory. The os.path.join() function can take any number of arguments. I was overjoyed when I discovered this, since addSlashIfNecessary() is one of the stupid little functions I always need to write when building up my toolbox in a new language. Do not write this stupid little function in Python; smart people have already taken care of it for you.</p></li>
</ol>

<p>os.path also contains functions to split full pathnames, directory names, and filenames into their constituent parts.
&gt;&gt;&gt; pathname = &lsquo;/Users/pilgrim/diveintopython3/examples/humansize.py&rsquo;
&gt;&gt;&gt; os.path.split(pathname) .
(&lsquo;/Users/pilgrim/diveintopython3/examples&rsquo;, &lsquo;humansize.py&rsquo;)
&gt;&gt;&gt; (dirname, filename) = os.path.split(pathname) .
&gt;&gt;&gt; dirname .
&lsquo;/Users/pilgrim/diveintopython3/examples&rsquo;
&gt;&gt;&gt; filename .
&lsquo;humansize.py&rsquo;
&gt;&gt;&gt; (shortname, extension) = os.path.splitext(filename) .
&gt;&gt;&gt; shortname
&lsquo;humansize&rsquo;
&gt;&gt;&gt; extension
&lsquo;.py&rsquo;</p>

<ol>
<li>The split function splits a full pathname and returns a tuple containing the path and filename.</li>

<li><p>Remember when I said you could use multi-variable
assignment
to return multiple values from a function? The os.path.split() function does exactly that. You assign the return value of the split function into a tuple of two variables. Each variable receives the value of the corresponding element of the returned tuple.</p></li>

<li><p>The first variable, dirname, receives the value of the first element of the tuple returned from the os.path.split() function, the file path.</p></li>

<li><p>The second variable, filename, receives the value of the second element of the tuple returned from the os.path.split() function, the filename.</p></li>

<li><p>os.path also contains the os.path.splitext() function, which splits a filename and returns a tuple containing the filename and the file extension. You use the same technique to assign each of them to separate variables.</p></li>
</ol>

<p>3.2.3. LISTING DIRECTORIES
The glob module is another tool in the Python standard library. It’s an easy way to get the contents of a directory programmatically, and it uses the sort of wildcards that you may already be familiar with from working on the command line.</p>

<blockquote>
<blockquote>
<blockquote>
<p>os.chdir(&lsquo;/Users/pilgrim/diveintopython3/&rsquo;)</p>

<p>import glob
glob.glob(&lsquo;examples/*.xml&rsquo;) .
[&lsquo;examples\feed-broken.xml&rsquo;,</p>
</blockquote>
</blockquote>
</blockquote>

<p>&lsquo;examples\feed-ns0.xml&rsquo;,</p>

<p>&lsquo;examples\feed.xml&rsquo;]</p>

<blockquote>
<blockquote>
<blockquote>
<p>os.chdir(&lsquo;examples/&rsquo;)   .
glob.glob(&rsquo;<em>test</em>.py&rsquo;)  .
[&lsquo;alphameticstest.py&rsquo;,</p>
</blockquote>
</blockquote>
</blockquote>

<p>&lsquo;pluraltest1.py&rsquo;,
&lsquo;pluraltest2.py&rsquo;,
&lsquo;pluraltest3.py&rsquo;,
&lsquo;pluraltest4.py&rsquo;,
&lsquo;pluraltest5.py&rsquo;,
&lsquo;pluraltest6.py&rsquo;,
&lsquo;romantest1.py&rsquo;,
&lsquo;romantest10.py&rsquo;,
&lsquo;romantest2.py&rsquo;,
&lsquo;romantest3.py&rsquo;,
&lsquo;romantest4.py&rsquo;,
&lsquo;romantest5.py&rsquo;,
&lsquo;romantest6.py&rsquo;,
&lsquo;romantest7.py&rsquo;,
&lsquo;romantest8.py&rsquo;,
&lsquo;romantest9.py&rsquo;]</p>

<ol>
<li><p>The glob module takes a wildcard and returns the path of all files and directories matching the wildcard. In this example, the wildcard is a directory path plus “*.xml”, which will match all .xml files in the examples subdirectory.</p></li>

<li><p>Now change the current working directory to the examples subdirectory. The os.chdir() function can take relative pathnames.</p></li>

<li><p>You can include multiple wildcards in your glob pattern. This example finds all the files in the current working directory that end in a .py extension and contain the word test anywhere in their filename.</p></li>
</ol>

<p>3.2.4. GETTING FILE METADATA</p>

<p>Every modern file system stores metadata about each file: creation date, last-modified date, file size, and so on. Python provides a single API to access this metadata. You don’t need to open the file; all you need is the filename.
&gt;&gt;&gt; import os
&gt;&gt;&gt; print(os.getcwd()) .
c:\Users\pilgrim\diveintopython3\examples
&gt;&gt;&gt; metadata = os.stat(&lsquo;feed.xml&rsquo;) .
&gt;&gt;&gt; metadata.st_mtime .
1247520344.9537716
&gt;&gt;&gt; import time .
&gt;&gt;&gt; time.localtime(metadata.st_mtime) .
time.struct_time(tm_year=2009, tm_mon=7, tm_mday=13, tm_hour=17,</p>

<p>tm_min=25, tm_sec=44, tm_wday=0, tm_yday=194, tm_isdst=1)</p>

<ol>
<li><p>The current working directory is the examples folder.</p></li>

<li><p>feed.xml is a file in the examples folder. Calling the os.stat() function returns an object that contains several different types of metadata about the file.</p></li>

<li><p>st_mtime is the modification time, but it’s in a format that isn’t terribly useful. (Technically, it’s the number of seconds since the Epoch, which is defined as the first second of January 1st, 1970. Seriously.)</p></li>

<li><p>The time module is part of the Python standard library. It contains functions to convert between different time representations, format time values into strings, and fiddle with timezones.</p></li>

<li><p>The time.localtime() function converts a time value from seconds-since-the-Epoch (from the st_mtime property returned from the os.stat() function) into a more useful structure of year, month, day, hour, minute, second, and so on. This file was last modified on July 13, 2009, at around 5:25 PM.</p></li>
</ol>

<h1 id="continued-from-the-previous-example-2">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>metadata.st_size .
3070
import humansize
humansize.approximate_size(metadata.st_size) .
&lsquo;3.0 KiB&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>The os.stat() function also returns the size of a file, in the st_size property. The file feed.xml is 3070 bytes.</p></li>

<li><p>You can pass the st_size property to the approximate_size() function.</p></li>
</ol>

<p>3.2.5. CONSTRUCTING ABSOLUTE PATHNAMES
In the
previous
section, the glob.glob() function returned a list of relative pathnames. The first example had pathnames like &lsquo;examples\feed.xml&rsquo;, and the second example had even shorter relative pathnames like &lsquo;romantest1.py&rsquo;. As long as you stay in the same current working directory, these relative pathnames will work for opening files or getting file metadata. But if you want to construct an absolute pathname — i.e. one that includes all the directory names back to the root directory or drive letter — then you’ll need the os.path.realpath() function.
&gt;&gt;&gt; import os
&gt;&gt;&gt; print(os.getcwd())
c:\Users\pilgrim\diveintopython3\examples
&gt;&gt;&gt; print(os.path.realpath(&lsquo;feed.xml&rsquo;))
c:\Users\pilgrim\diveintopython3\examples\feed.xml</p>

<p>.</p>

<p>3.3. LIST COMPREHENSIONS</p>

<p>A list comprehension provides a compact way of mapping a list into another list by applying a function to
each of the elements of the list.
&gt;&gt;&gt; a_list = [1, 9, 8, 4]</p>

<blockquote>
<blockquote>
<blockquote>
<p>[elem * 2 for elem in a_list] .
[2, 18, 16, 8]
a_list .
[1, 9, 8, 4]
a_list = [elem * 2 for elem in a_list] .
a_list
[2, 18, 16, 8]</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>To make sense of this, look at it from right to left. a_list is the list you’re mapping. The Python interpreter loops through a_list one element at a time, temporarily assigning the value of each element to the variable elem. Python then applies the function elem * 2 and appends that result to the returned list.</p></li>

<li><p>A list comprehension creates a new list; it does not change the original list.</p></li>

<li><p>It is safe to assign the result of a list comprehension to the variable that you’re mapping. Python constructs the new list in memory, and when the list comprehension is complete, it assigns the result to the original variable.</p></li>
</ol>

<p>You can use any Python expression in a list comprehension, including the functions in the os module for manipulating files and directories.
&gt;&gt;&gt; import os, glob
&gt;&gt;&gt; glob.glob(&rsquo;<em>.xml&rsquo;) .
[&lsquo;feed-broken.xml&rsquo;, &lsquo;feed-ns0.xml&rsquo;, &lsquo;feed.xml&rsquo;]
&gt;&gt;&gt; [os.path.realpath(f) for f in glob.glob(&rsquo;</em>.xml&rsquo;)] .
[&lsquo;c:\Users\pilgrim\diveintopython3\examples\feed-broken.xml&rsquo;,</p>

<p>&lsquo;c:\Users\pilgrim\diveintopython3\examples\feed-ns0.xml&rsquo;,</p>

<p>&lsquo;c:\Users\pilgrim\diveintopython3\examples\feed.xml&rsquo;]</p>

<ol>
<li><p>This returns a list of all the .xml files in the current working directory.</p></li>

<li><p>This list comprehension takes that list of .xml files and transforms it into a list of full pathnames.</p></li>
</ol>

<p>List comprehensions can also filter items, producing a result that can be smaller than the original list.
&gt;&gt;&gt; import os, glob
&gt;&gt;&gt; [f for f in glob.glob(&rsquo;*.py&rsquo;) if os.stat(f).st_size &gt; 6000] .
[&lsquo;pluraltest6.py&rsquo;,</p>

<p>&lsquo;romantest10.py&rsquo;,
&lsquo;romantest6.py&rsquo;,
&lsquo;romantest7.py&rsquo;,
&lsquo;romantest8.py&rsquo;,
&lsquo;romantest9.py&rsquo;]</p>

<ol>
<li>To filter a list, you can include an if clause at the end of the list comprehension. The expression after the if keyword will be evaluated for each item in the list. If the expression evaluates to True, the item will be included in the output. This list comprehension looks at the list of all .py files in the current directory, and the if expression filters that list by testing whether the size of each file is greater than 6000 bytes. There are six such files, so the list comprehension returns a list of six filenames.
All the examples of list comprehensions so far have featured simple expressions — multiply a number by a constant, call a single function, or simply return the original list item (after filtering). But there’s no limit to how complex a list comprehension can be.
&gt;&gt;&gt; import os, glob
&gt;&gt;&gt; [(os.stat(f).st_size, os.path.realpath(f)) for f in glob.glob(&rsquo;*.xml&rsquo;)] .
[(3074, &lsquo;c:\Users\pilgrim\diveintopython3\examples\feed-broken.xml&rsquo;),</li>
</ol>

<p>(3386, &lsquo;c:\Users\pilgrim\diveintopython3\examples\feed-ns0.xml&rsquo;),</p>

<p>(3070, &lsquo;c:\Users\pilgrim\diveintopython3\examples\feed.xml&rsquo;)] &gt;&gt;&gt; import humansize &gt;&gt;&gt; [(humansize.approximate_size(os.stat(f).st_size), f) for f in glob.glob(&rsquo;*.xml&rsquo;)] . [(&lsquo;3.0 KiB&rsquo;, &lsquo;feed-broken.xml&rsquo;),
(&lsquo;3.3 KiB&rsquo;, &lsquo;feed-ns0.xml&rsquo;),
(&lsquo;3.0 KiB&rsquo;, &lsquo;feed.xml&rsquo;)]</p>

<ol>
<li><p>This list comprehension finds all the .xml files in the current working directory, gets the size of each file (by calling the os.stat() function), and constructs a tuple of the file size and the absolute path of each file (by calling the os.path.realpath() function).</p></li>

<li><p>This comprehension builds on the previous one to call the approximate_size() function
with the file size of each .xml file.</p></li>
</ol>

<p>.</p>

<p>3.4. DICTIONARY COMPREHENSIONS
A dictionary comprehension is like a list comprehension, but it constructs a dictionary instead of a list.
&gt;&gt;&gt; import os, glob
&gt;&gt;&gt; metadata = [(f, os.stat(f)) for f in glob.glob(&rsquo;<em>test</em>.py&rsquo;)] .
&gt;&gt;&gt; metadata[0] .
(&lsquo;alphameticstest.py&rsquo;, nt.stat_result(st_mode=33206, st_ino=0, st_dev=0,</p>

<p>st_nlink=0, st_uid=0, st_gid=0, st_size=2509, st_atime=1247520344,</p>

<p>st_mtime=1247520344, st_ctime=1247520344))
&gt;&gt;&gt; metadata_dict = {f:os.stat(f) for f in glob.glob(&rsquo;<em>test</em>.py&rsquo;)} .
&gt;&gt;&gt; type(metadata_dict) .
<class 'dict'>
&gt;&gt;&gt; list(metadata_dict.keys()) .
[&lsquo;romantest8.py&rsquo;, &lsquo;pluraltest1.py&rsquo;, &lsquo;pluraltest2.py&rsquo;, &lsquo;pluraltest5.py&rsquo;,</p>

<p>&lsquo;pluraltest6.py&rsquo;, &lsquo;romantest7.py&rsquo;, &lsquo;romantest10.py&rsquo;, &lsquo;romantest4.py&rsquo;,
&lsquo;romantest9.py&rsquo;, &lsquo;pluraltest3.py&rsquo;, &lsquo;romantest1.py&rsquo;, &lsquo;romantest2.py&rsquo;,
&lsquo;romantest3.py&rsquo;, &lsquo;romantest5.py&rsquo;, &lsquo;romantest6.py&rsquo;, &lsquo;alphameticstest.py&rsquo;,
&lsquo;pluraltest4.py&rsquo;]</p>

<blockquote>
<blockquote>
<blockquote>
<p>metadata_dict[&lsquo;alphameticstest.py&rsquo;].st_size .
2509</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>This is not a dictionary comprehension; it’s a list
comprehension. It finds all .py files with test in their name, then constructs a tuple of the filename and the file metadata (from calling the os.stat() function).</p></li>

<li><p>Each item of the resulting list is a tuple.</p></li>

<li><p>This is a dictionary comprehension. The syntax is similar to a list comprehension, with two differences. First, it is enclosed in curly braces instead of square brackets. Second, instead of a single expression for each item, it contains two expressions separated by a colon. The expression before the colon (f in this example) is the dictionary key; the expression after the colon (os.stat(f) in this example) is the value.</p></li>

<li><p>A dictionary comprehension returns a dictionary.</p></li>

<li><p>The keys of this particular dictionary are simply the filenames returned from the call to glob.glob(&rsquo;<em>test</em>.py&rsquo;).</p></li>

<li><p>The value associated with each key is the return value from the os.stat() function. That means we can “look up” a file by name in this dictionary to get its file metadata. One of the pieces of metadata is st_size, the file size. The file alphameticstest.py is 2509 bytes long.</p></li>
</ol>

<p>Like list comprehensions, you can include an if clause in a dictionary comprehension to filter the input sequence based on an expression which is evaluated with each item.
&gt;&gt;&gt; import os, glob, humansize
&gt;&gt;&gt; metadata_dict = {f:os.stat(f) for f in glob.glob(&rsquo;*&lsquo;)} .
&gt;&gt;&gt; humansize_dict = {os.path.splitext(f)[0]:humansize.approximate_size(meta.st_size) \
&hellip; for f, meta in metadata_dict.items() if meta.st_size &gt; 6000} .
&gt;&gt;&gt; list(humansize_dict.keys()) .
[&lsquo;romantest9&rsquo;, &lsquo;romantest8&rsquo;, &lsquo;romantest7&rsquo;, &lsquo;romantest6&rsquo;, &lsquo;romantest10&rsquo;, &lsquo;pluraltest6&rsquo;]
&gt;&gt;&gt; humansize_dict[&lsquo;romantest9&rsquo;] .
&lsquo;6.5 KiB&rsquo;</p>

<ol>
<li><p>This dictionary comprehension constructs a list of all the files in the current working directory (glob.glob(&rsquo;*&lsquo;)), gets the file metadata for each file (os.stat(f)), and constructs a dictionary whose keys are filenames and whose values are the metadata for each file.</p></li>

<li><p>This dictionary comprehension builds on the previous comprehension, filters out files smaller than 6000 bytes (if meta.st_size &gt; 6000), and uses that filtered list to construct a dictionary whose keys are the filename minus the extension (os.path.splitext(f)[0]) and whose values are the approximate size of each file (humansize.approximate_size(meta.st_size)).</p></li>

<li><p>As you saw in a previous example, there are six such files, thus there are six items in this dictionary.</p></li>

<li><p>The value of each key is the string returned from the approximate_size() function.</p></li>
</ol>

<p>3.4.1. OTHER FUN STUFF TO DO WITH DICTIONARY COMPREHENSIONS
Here’s a trick with dictionary comprehensions that might be useful someday: swapping the keys and values of a dictionary.
&gt;&gt;&gt; a_dict = {&lsquo;a&rsquo;: 1, &lsquo;b&rsquo;: 2, &lsquo;c&rsquo;: 3}
&gt;&gt;&gt; {value:key for key, value in a_dict.items()}</p>

<p>{1: &lsquo;a&rsquo;, 2: &lsquo;b&rsquo;, 3: &lsquo;c&rsquo;}</p>

<p>Of course, this only works if the values of the dictionary are immutable, like strings or tuples. If you try this with a dictionary that contains lists, it will fail most spectacularly.
&gt;&gt;&gt; a_dict = {&lsquo;a&rsquo;: [1, 2, 3], &lsquo;b&rsquo;: 4, &lsquo;c&rsquo;: 5}</p>

<blockquote>
<blockquote>
<blockquote>
<p>{value:key for key, value in a_dict.items()}</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
File &ldquo;<stdin>&rdquo;, line 1, in <dictcomp></p>

<p>TypeError: unhashable type: &lsquo;list&rsquo;</p>

<p>.
3.5. SET COMPREHENSIONS
Not to be left out, sets have their own comprehension syntax as well. It is remarkably similar to the syntax for dictionary comprehensions. The only difference is that sets just have values instead of key:value pairs.
&gt;&gt;&gt; a_set = set(range(10))
&gt;&gt;&gt; a_set
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
&gt;&gt;&gt; {x ** 2 for x in a_set} .
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}
&gt;&gt;&gt; {x for x in a_set if x % 2 == 0} .
{0, 8, 2, 4, 6}
&gt;&gt;&gt; {2**x for x in range(10)} .
{32, 1, 2, 4, 8, 64, 128, 256, 16, 512}</p>

<ol>
<li><p>Set comprehensions can take a set as input. This set comprehension calculates the squares of the set of numbers from 0 to 9.</p></li>

<li><p>Like list comprehensions and dictionary comprehensions, set comprehensions can contain an if clause to filter each item before returning it in the result set.</p></li>

<li><p>Set comprehensions do not need to take a set as input; they can take any sequence.</p></li>
</ol>

<p>.</p>

<p>3.6. FURTHER READING
• os module
• os —
Portable
access
to
operating
system
specific
features
• os.path module
• os.path —
Platform-independent
manipulation
of
file
names</p>

<p>• glob module</p>

<p>• glob —
Filename
pattern
matching</p>

<p>• time module</p>

<p>• time —
Functions
for
manipulating
clock
time</p>

<p>• List
comprehensions</p>

<p>• Nested
list
comprehensions</p>

<p>• Looping
techniques</p>

<p>CHAPTER 4. STRINGS</p>

<p>. I’m telling you this ’cause you’re one of my friends.
My alphabet starts where your alphabet ends! .
— Dr. Seuss, On Beyond Zebra!</p>

<p>4.1. SOME BORING STUFF YOU NEED TO UNDERSTAND BEFORE YOU CAN DIVE IN
Few people think about it, but text is incredibly complicated. Start with the alphabet. The people of Bougainville
have the smallest alphabet in the world; their Rotokas
alphabet
is composed of only 12 letters: A, E, G, I, K, O, P, R, S, T, U, and V. On the other end of the spectrum, languages like Chinese, Japanese, and Korean have thousands of characters. English, of course, has 26 letters — 52 if you count uppercase and lowercase separately — plus a handful of !@#$%&amp; punctuation marks.</p>

<p>When you talk about “text,” you’re probably thinking of “characters and symbols on my computer screen.” But computers don’t deal in characters and symbols; they deal in bits and bytes. Every piece of text you’ve ever seen on a computer screen is actually stored in a particular character encoding. Very roughly speaking, the character encoding provides a mapping between the stuff you see on your screen and the stuff your computer actually stores in memory and on disk. There are many different character encodings, some optimized for particular languages like Russian or Chinese or English, and others that can be used for multiple languages.</p>

<p>In reality, it’s more complicated than that. Many characters are common to multiple encodings, but each encoding may use a different sequence of bytes to actually store those characters in memory or on disk. So you can think of the character encoding as a kind of decryption key. Whenever someone gives you a sequence of bytes — a file, a web page, whatever — and claims it’s “text,” you need to know what character encoding they used so you can decode the bytes into characters. If they give you the wrong key or no key at all, you’re left with the unenviable task of cracking the code yourself. Chances are you’ll get it wrong, and the result will be gibberish.</p>

<p>Surely you’ve seen web pages like this, with strange question-mark-like characters where apostrophes should be. That usually means the page author didn’t declare their character encoding correctly, your browser was left guessing, and the result was a mix of expected and unexpected characters. In English it’s merely annoying; in other languages, the result can be completely unreadable.
There are character encodings for each major language in the world. Since each language is different, and memory and disk space have historically been expensive, each character encoding is optimized for a particular language. By that, I mean each encoding using the same numbers (0–255) to represent that language’s characters. For instance, you’re probably familiar with the ASCII encoding, which stores English characters as numbers ranging from 0 to 127. (65 is capital “A”, 97 is lowercase “a”, &amp;c.) English has a very simple alphabet, so it can be completely expressed in less than 128 numbers. For those of you who can count in base 2, that’s 7 out of the 8 bits in a byte.</p>

<p>Western European languages like French, Spanish, and German have more letters than English. Or, more precisely, they have letters combined with various diacritical marks, like the ñ character in Spanish. The most common encoding for these languages is CP-1252, also called “windows-1252” because it is widely used on Microsoft Windows. The CP-1252 encoding shares characters with ASCII in the 0–127 range, but then extends into the 128–255 range for characters like n-with-a-tilde-over-it (241), u-with-two-dots-over-it (252), &amp;c. It’s still a single-byte encoding, though; the highest possible number, 255, still fits in one byte.
Then there are languages like Chinese, Japanese, and Korean, which have so many characters that they require multiple-byte character sets. That is, each “character” is represented by a two-byte number from 0–65535. But different multi-byte encodings still share the same problem as different single-byte encodings, namely that they each use the same numbers to mean different things. It’s just that the range of numbers is broader, because there are many more characters to represent.
That was mostly OK in a non-networked world, where “text” was something you typed yourself and occasionally printed. There wasn’t much “plain text”. Source code was ASCII, and everyone else used word processors, which defined their own (non-text) formats that tracked character encoding information along with rich styling, &amp;c. People read these documents with the same word processing program as the original author, so everything worked, more or less.
Now think about the rise of global networks like email and the web. Lots of “plain text” flying around the globe, being authored on one computer, transmitted through a second computer, and received and displayed by a third computer. Computers can only see numbers, but the numbers could mean different things. Oh no! What to do? Well, systems had to be designed to carry encoding information along with every piece of “plain text.” Remember, it’s the decryption key that maps computer-readable numbers to human-readable characters. A missing decryption key means garbled text, gibberish, or worse.
Now think about trying to store multiple pieces of text in the same place, like in the same database table that holds all the email you’ve ever received. You still need to store the character encoding alongside each piece of text so you can display it properly. Think that’s hard? Try searching your email database, which means converting between multiple encodings on the fly. Doesn’t that sound fun?
Now think about the possibility of multilingual documents, where characters from several languages are next to each other in the same document. (Hint: programs that tried to do this typically used escape codes to switch “modes.” Poof, you’re in Russian koi8-r mode, so 241 means .; poof, now you’re in Mac Greek mode, so 241 means ..) And of course you’ll want to search those documents, too.
Now cry a lot, because everything you thought you knew about strings is wrong, and there ain’t no such thing as “plain text.”
.</p>

<p>4.2. UNICODE
Enter Unicode.
Unicode is a system designed to represent every character from every language. Unicode represents each letter, character, or ideograph as a 4-byte number. Each number represents a unique character used in at least one of the world’s languages. (Not all the numbers are used, but more than 65535 of them are, so 2 bytes wouldn’t be sufficient.) Characters that are used in multiple languages generally have the same number, unless there is a good etymological reason not to. Regardless, there is exactly 1 number per character, and exactly 1 character per number. Every number always means just one thing; there are no “modes” to keep track of. U+0041 is always &lsquo;A&rsquo;, even if your language doesn’t have an &lsquo;A&rsquo; in it.
On the face of it, this seems like a great idea. One encoding to rule them all. Multiple languages per document. No more “mode switching” to switch between encodings mid-stream. But right away, the obvious question should leap out at you. Four bytes? For every single character. That seems awfully wasteful, especially for languages like English and Spanish, which need less than one byte (256 numbers) to express every possible character. In fact, it’s wasteful even for ideograph-based languages (like Chinese), which never need more than two bytes per character.
There is a Unicode encoding that uses four bytes per character. It’s called UTF-32, because 32 bits = 4 bytes. UTF-32 is a straightforward encoding; it takes each Unicode character (a 4-byte number) and represents the character with that same number. This has some advantages, the most important being that you can find the Nth character of a string in constant time, because the Nth character starts at the 4×Nth byte. It also has several disadvantages, the most obvious being that it takes four freaking bytes to store every freaking character.
Even though there are a lot of Unicode characters, it turns out that most people will never use anything beyond the first 65535. Thus, there is another Unicode encoding, called UTF-16 (because 16 bits = 2 bytes). UTF-16 encodes every character from 0–65535 as two bytes, then uses some dirty hacks if you actually need to represent the rarely-used “astral plane” Unicode characters beyond 65535. Most obvious advantage: UTF-16 is twice as space-efficient as UTF-32, because every character requires only two bytes to store instead of four bytes (except for the ones that don’t). And you can still easily find the Nth character of a string in constant time, if you assume that the string doesn’t include any astral plane characters, which is a good assumption right up until the moment that it’s not.
But there are also non-obvious disadvantages to both UTF-32 and UTF-16. Different computer systems store individual bytes in different ways. That means that the character U+4E2D could be stored in UTF-16 as either 4E 2D or 2D 4E, depending on whether the system is big-endian or little-endian. (For UTF-32, there are even more possible byte orderings.) As long as your documents never leave your computer, you’re safe — different applications on the same computer will all use the same byte order. But the minute you want to transfer documents between systems, perhaps on a world wide web of some sort, you’re going to need a way to indicate which order your bytes are stored. Otherwise, the receiving system has no way of knowing whether the two-byte sequence 4E 2D means U+4E2D or U+2D4E.
To solve this problem, the multi-byte Unicode encodings define a “Byte Order Mark,” which is a special non-printable character that you can include at the beginning of your document to indicate what order your bytes are in. For UTF-16, the Byte Order Mark is U+FEFF. If you receive a UTF-16 document that starts with the bytes FF FE, you know the byte ordering is one way; if it starts with FE FF, you know the byte ordering is reversed.
Still, UTF-16 isn’t exactly ideal, especially if you’re dealing with a lot of ASCII characters. If you think about it, even a Chinese web page is going to contain a lot of ASCII characters — all the elements and attributes surrounding the printable Chinese characters. Being able to find the Nth character in constant time is nice, but there’s still the nagging problem of those astral plane characters, which mean that you can’t guarantee that every character is exactly two bytes, so you can’t really find the Nth character in constant time unless you maintain a separate index. And boy, there sure is a lot of ASCII text in the world…
Other people pondered these questions, and they came up with a solution:
UTF-8</p>

<p>UTF-8 is a variable-length encoding system for Unicode. That is, different characters take up a different number of bytes. For ASCII characters (A-Z, &amp;c.) UTF-8 uses just one byte per character. In fact, it uses the exact same bytes; the first 128 characters (0–127) in UTF-8 are indistinguishable from ASCII. “Extended Latin” characters like ñ and ö end up taking two bytes. (The bytes are not simply the Unicode code point like they would be in UTF-16; there is some serious bit-twiddling involved.) Chinese characters like. end up taking three bytes. The rarely-used “astral plane” characters take four bytes.
Disadvantages: because each character can take a different number of bytes, finding the Nth character is an O(N) operation — that is, the longer the string, the longer it takes to find a specific character. Also, there is bit-twiddling involved to encode characters into bytes and decode bytes into characters.
Advantages: super-efficient encoding of common ASCII characters. No worse than UTF-16 for extended Latin characters. Better than UTF-32 for Chinese characters. Also (and you’ll have to trust me on this, because I’m not going to show you the math), due to the exact nature of the bit twiddling, there are no byte-ordering issues. A document encoded in UTF-8 uses the exact same stream of bytes on any computer.</p>

<p>.</p>

<p>4.3. DIVING IN
In Python 3, all strings are sequences of Unicode characters. There is no such thing as a Python string encoded in UTF-8, or a Python string encoded as CP-1252. “Is this string UTF-8?” is an invalid question. UTF-8 is a way of encoding characters as a sequence of bytes. If you want to take a string and turn it into a sequence of bytes in a particular character encoding, Python 3 can help you with that. If you want to take a sequence of bytes and turn it into a string, Python 3 can help you with that too. Bytes are not characters; bytes are bytes. Characters are an abstraction. A string is a sequence of those abstractions.
&gt;&gt;&gt; s = &lsquo;.. Python&rsquo; .
&gt;&gt;&gt; len(s) .
9
&gt;&gt;&gt; s[0] .
&lsquo;.&rsquo;
&gt;&gt;&gt; s + &lsquo; 3&rsquo; .
&lsquo;.. Python 3&rsquo;</p>

<ol>
<li>To create a string, enclose it in quotes. Python strings can be defined with either single quotes (&lsquo;) or double quotes (&ldquo;).</li>
<li>The built-in len() function returns the length of the string, i.e. the number of characters. This is the same function you use to find
the
length
of
a
list,
tuple,
set,
or
dictionary. A string is like a tuple of characters.</li>
<li>Just like getting individual items out of a list, you can get individual characters out of a string using index notation.</li>
<li>Just like lists, you can concatenate strings using the + operator.</li>
</ol>

<p>.</p>

<p>4.4. FORMATTING STRINGS
Let’s take another look at humansize.py:</p>

<p>SUFFIXES = {1000: [&lsquo;KB&rsquo;, &lsquo;MB&rsquo;, &lsquo;GB&rsquo;, &lsquo;TB&rsquo;, &lsquo;PB&rsquo;, &lsquo;EB&rsquo;, &lsquo;ZB&rsquo;, &lsquo;YB&rsquo;], . 1024: [&lsquo;KiB&rsquo;, &lsquo;MiB&rsquo;, &lsquo;GiB&rsquo;, &lsquo;TiB&rsquo;, &lsquo;PiB&rsquo;, &lsquo;EiB&rsquo;, &lsquo;ZiB&rsquo;, &lsquo;YiB&rsquo;]}
def approximate_size(size, a_kilobyte_is_1024_bytes=True): &ldquo;&lsquo;Convert a file size to human-readable form. .
Keyword arguments:
size &ndash; file size in bytes
a_kilobyte_is_1024_bytes &ndash; if True (default), use multiples of 1024</p>

<p>if False, use multiples of 1000</p>

<p>Returns: string</p>

<p>&rdquo;&rsquo; . if size &lt; 0: raise ValueError(&lsquo;number must be non-negative&rsquo;) .
multiple = 1024 if a_kilobyte_is_1024_bytes else 1000</p>

<p>for suffix in SUFFIXES[multiple]:
size /= multiple
if size &lt; multiple:</p>

<p>return &lsquo;{0:.1f} {1}&lsquo;.format(size, suffix)   .
raise ValueError(&lsquo;number too large&rsquo;)</p>

<ol>
<li><p>&lsquo;KB&rsquo;, &lsquo;MB&rsquo;, &lsquo;GB&rsquo;… those are each strings.</p></li>

<li><p>Function docstrings are strings. This docstring spans multiple lines, so it uses three-in-a-row quotes to start and end the string.</p></li>

<li><p>These three-in-a-row quotes end the docstring.</p></li>

<li><p>There’s another string, being passed to the exception as a human-readable error message.</p></li>

<li><p>There’s a… whoa, what the heck is that?</p></li>
</ol>

<p>Python 3 supports formatting values into strings. Although this can include very complicated expressions, the most basic usage is to insert a value into a string with a single placeholder.
&gt;&gt;&gt; username = &lsquo;mark&rsquo;
&gt;&gt;&gt; password = &lsquo;PapayaWhip&rsquo; .
&gt;&gt;&gt; &ldquo;{0}&rsquo;s password is {1}&rdquo;.format(username, password) .
&ldquo;mark&rsquo;s password is PapayaWhip&rdquo;</p>

<ol>
<li><p>No, my password is not really PapayaWhip.</p></li>

<li><p>There’s a lot going on here. First, that’s a method call on a string literal. Strings are objects, and objects have methods. Second, the whole expression evaluates to a string. Third, {0} and {1} are replacement fields, which are replaced by the arguments passed to the format() method.</p></li>
</ol>

<p>4.4.1. COMPOUND FIELD NAMES
The previous example shows the simplest case, where the replacement fields are simply integers. Integer replacement fields are treated as positional indices into the argument list of the format() method. That means that {0} is replaced by the first argument (username in this case), {1} is replaced by the second argument (password), &amp;c. You can have as many positional indices as you have arguments, and you can have as many arguments as you want. But replacement fields are much more powerful than that.
&gt;&gt;&gt; import humansize
&gt;&gt;&gt; si_suffixes = humansize.SUFFIXES[1000] .
&gt;&gt;&gt; si_suffixes
[&lsquo;KB&rsquo;, &lsquo;MB&rsquo;, &lsquo;GB&rsquo;, &lsquo;TB&rsquo;, &lsquo;PB&rsquo;, &lsquo;EB&rsquo;, &lsquo;ZB&rsquo;, &lsquo;YB&rsquo;]
&gt;&gt;&gt; &lsquo;1000{0[0]} = 1{0[1]}&lsquo;.format(si_suffixes) .
&lsquo;1000KB = 1MB&rsquo;</p>

<ol>
<li><p>Rather than calling any function in the humansize module, you’re just grabbing one of the data structures it defines: the list of “SI” (powers-of-1000) suffixes.</p></li>

<li><p>This looks complicated, but it’s not. {0} would refer to the first argument passed to the format() method, si_suffixes. But si_suffixes is a list. So {0[0]} refers to the first item of the list which is the first argument passed to the format() method: &lsquo;KB&rsquo;. Meanwhile, {0[1]} refers to the second item of the same list: &lsquo;MB&rsquo;. Everything outside the curly braces — including 1000, the equals sign, and the spaces — is untouched. The final result is the string &lsquo;1000KB = 1MB&rsquo;.</p></li>
</ol>

<p>What this example shows is that format specifiers can access items and properties of data structures using (almost) Python syntax. This is called compound field names. The following compound field names “just work”:
•   Passing a list, and accessing an item of the list by index (as in the previous example)</p>

<p>•   Passing a dictionary, and accessing a value of the dictionary by key</p>

<p>•   Passing a module, and accessing its variables and functions by name</p>

<p>•   Passing a class instance, and accessing its properties and methods by name</p>

<p>•   Any combination of the above</p>

<p>Just to blow your mind, here’s an example that
combines all of the above:</p>

<blockquote>
<blockquote>
<blockquote>
<p>import humansize
import sys</p>

<p>&lsquo;1MB = 1000{0.modules[humansize].SUFFIXES[1000][0]}&lsquo;.format(sys)
&lsquo;1MB = 1000KB&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<p>Here’s how it works:
•   The sys module holds information about the currently running Python instance. Since you just imported it, you can pass the sys module itself as an argument to the format() method. So the replacement field {0} refers to the sys module.</p>

<p>•   sys.modules is a dictionary of all the modules that have been imported in this Python instance. The keys are the module names as strings; the values are the module objects themselves. So the replacement field {0.modules} refers to the dictionary of imported modules.</p>

<p>•   sys.modules[&lsquo;humansize&rsquo;] is the humansize module which you just imported. The replacement field {0.modules[humansize]} refers to the humansize module. Note the slight difference in syntax here. In real Python code, the keys of the sys.modules dictionary are strings; to refer to them, you need to put quotes around the module name (e.g. &lsquo;humansize&rsquo;). But within a replacement field, you skip the quotes around the dictionary key name (e.g. humansize). To quote PEP
3101:
Advanced
String
Formatting, “The rules for parsing an item key are very simple. If it starts with a digit, then it is treated as a number, otherwise it is used as a string.”</p>

<p>•   sys.modules[&lsquo;humansize&rsquo;].SUFFIXES is the dictionary defined at the top of the humansize module. The replacement field {0.modules[humansize].SUFFIXES} refers to that dictionary.</p>

<p>•   sys.modules[&lsquo;humansize&rsquo;].SUFFIXES[1000] is a list of SI suffixes: [&lsquo;KB&rsquo;, &lsquo;MB&rsquo;, &lsquo;GB&rsquo;, &lsquo;TB&rsquo;, &lsquo;PB&rsquo;, &lsquo;EB&rsquo;, &lsquo;ZB&rsquo;, &lsquo;YB&rsquo;]. So the replacement field {0.modules[humansize].SUFFIXES[1000]} refers to that list.
•   sys.modules[&lsquo;humansize&rsquo;].SUFFIXES[1000][0] is the first item of the list of SI suffixes: &lsquo;KB&rsquo;. Therefore, the complete replacement field {0.modules[humansize].SUFFIXES[1000][0]} is replaced by the two-character string KB.</p>

<p>4.4.2. FORMAT SPECIFIERS
But wait! There’s more! Let’s take another look at that strange line of code from humansize.py:
if size &lt; multiple:
return &lsquo;{0:.1f} {1}&lsquo;.format(size, suffix)</p>

<p>{1} is replaced with the second argument passed to the format() method, which is suffix. But what is {0:.1f}? It’s two things: {0}, which you recognize, and :.1f, which you don’t. The second half (including and after the colon) defines the format specifier, which further refines how the replaced variable should be formatted.
. Format specifiers allow you to munge the replacement text in a variety of useful ways, like the printf() function in C. You can add zero-or space-padding, align strings, control decimal precision, and even convert numbers to hexadecimal.
Within a replacement field, a colon (:) marks the start of the format specifier. The format specifier “.1” means “round to the nearest tenth” (i.e. display only one digit after the decimal point). The format specifier “f” means “fixed-point number” (as opposed to exponential notation or some other decimal representation). Thus, given a size of 698.24 and suffix of &lsquo;GB&rsquo;, the formatted string would be &lsquo;698.2 GB&rsquo;, because
698.24 gets rounded to one decimal place, then the suffix is appended after the number.
&gt;&gt;&gt; &lsquo;{0:.1f} {1}&lsquo;.format(698.24, &lsquo;GB&rsquo;)
&lsquo;698.2 GB&rsquo;</p>

<p>For all the gory details on format specifiers, consult the Format
Specification
Mini-Language
in the official Python documentation.
.</p>

<p>4.5. OTHER COMMON STRING METHODS
Besides formatting, strings can do a number of other useful tricks.
&gt;&gt;&gt; s = &ldquo;&lsquo;Finished files are the re-.
&hellip; sult of years of scientif­&hellip; ic study combined with the
&hellip; experience of years.&ldquo;&rsquo;
&gt;&gt;&gt; s.splitlines() .
[&lsquo;Finished files are the re-&rsquo;,</p>

<p>&lsquo;sult of years of scientif-&rsquo;,
&lsquo;ic study combined with the&rsquo;,
&lsquo;experience of years.&rsquo;]</p>

<blockquote>
<blockquote>
<blockquote>
<p>print(s.lower()) .
finished files are the re­sult of years of scientif­ic study combined with the
experience of years.
s.lower().count(&lsquo;f&rsquo;) .
6</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>You can input multiline strings in the Python interactive shell. Once you start a multiline string with triple quotation marks, just hit ENTER and the interactive shell will prompt you to continue the string. Typing the closing triple quotation marks ends the string, and the next ENTER will execute the command (in this case, assigning the string to s).</p></li>

<li><p>The splitlines() method takes one multiline string and returns a list of strings, one for each line of the original. Note that the carriage returns at the end of each line are not included.</p></li>

<li><p>The lower() method converts the entire string to lowercase. (Similarly, the upper() method converts a string to uppercase.)</p></li>

<li><p>The count() method counts the number of occurrences of a substring. Yes, there really are six “f”s in that sentence!</p></li>
</ol>

<p>Here’s another common case. Let’s say you have a list of key-value pairs in the form key1=value1&amp;key2=value2, and you want to split them up and make a dictionary of the form {key1: value1, key2: value2}.
&gt;&gt;&gt; query = &lsquo;user=pilgrim&amp;database=master&amp;password=PapayaWhip&rsquo;
&gt;&gt;&gt; a_list = query.split(&rsquo;&amp;&lsquo;) .
&gt;&gt;&gt; a_list
[&lsquo;user=pilgrim&rsquo;, &lsquo;database=master&rsquo;, &lsquo;password=PapayaWhip&rsquo;]
&gt;&gt;&gt; a_list_of_lists = [v.split(&lsquo;=&rsquo;, 1) for v in a_list if &lsquo;=&rsquo; in v] .
&gt;&gt;&gt; a_list_of_lists
[[&lsquo;user&rsquo;, &lsquo;pilgrim&rsquo;], [&lsquo;database&rsquo;, &lsquo;master&rsquo;], [&lsquo;password&rsquo;, &lsquo;PapayaWhip&rsquo;]]
&gt;&gt;&gt; a_dict = dict(a_list_of_lists) .
&gt;&gt;&gt; a_dict
{&lsquo;password&rsquo;: &lsquo;PapayaWhip&rsquo;, &lsquo;user&rsquo;: &lsquo;pilgrim&rsquo;, &lsquo;database&rsquo;: &lsquo;master&rsquo;}</p>

<ol>
<li><p>The split() string method has one required argument, a delimiter. The method splits a string into a list of strings based on the delimiter. Here, the delimiter is an ampersand character, but it could be anything.</p></li>

<li><p>Now we have a list of strings, each with a key, followed by an equals sign, followed by a value. We can use a list
comprehension
to iterate over the entire list and split each string into two strings based on the first equals sign. The optional second argument to the split() method is the number of times you want to split. 1 means “only split once,” so the split() method will return a two-item list. (In theory, a value could contain an equals sign too. If you just used &lsquo;key=value=foo&rsquo;.split(&lsquo;=&rsquo;), you would end up with a three-item list [&lsquo;key&rsquo;, &lsquo;value&rsquo;, &lsquo;foo&rsquo;].)</p></li>

<li><p>Finally, Python can turn that list-of-lists into a dictionary simply by passing it to the dict() function.</p></li>
</ol>

<p>. The previous example looks a lot like parsing query parameters in a URL, but real-life URL parsing is actually more complicated than this. If you’re dealing with URL query parameters, you’re better off using the urllib.parse.parse_qs() function, which handles some non-obvious edge cases.
4.5.1. SLICING A STRING
Once you’ve defined a string, you can get any part of it as a new string. This is called slicing the string. Slicing strings works exactly the same as slicing
lists, which makes sense, because strings are just sequences of characters.
&gt;&gt;&gt; a_string = &lsquo;My alphabet starts where your alphabet ends.&rsquo;
&gt;&gt;&gt; a_string[3:11] .
&lsquo;alphabet&rsquo;
&gt;&gt;&gt; a_string[3:-3] .
&lsquo;alphabet starts where your alphabet en&rsquo;
&gt;&gt;&gt; a_string[0:2] .
&lsquo;My&rsquo;
&gt;&gt;&gt; a_string[:18] .
&lsquo;My alphabet starts&rsquo;
&gt;&gt;&gt; a_string[18:] .
&lsquo; where your alphabet ends.&rsquo;</p>

<ol>
<li><p>You can get a part of a string, called a “slice”, by specifying two indices. The return value is a new string containing all the characters of the string, in order, starting with the first slice index.</p></li>

<li><p>Like slicing lists, you can use negative indices to slice strings.</p></li>

<li><p>Strings are zero-based, so a_string[0:2] returns the first two items of the string, starting at a_string[0], up to but not including a_string[2].</p></li>

<li><p>If the left slice index is 0, you can leave it out, and 0 is implied. So a_string[:18] is the same as a_string[0:18], because the starting 0 is implied.</p></li>

<li><p>Similarly, if the right slice index is the length of the string, you can leave it out. So a_string[18:] is the same as a_string[18:44], because this string has 44 characters. There is a pleasing symmetry here. In this 44-character string, a_string[:18] returns the first 18 characters, and a_string[18:] returns everything but the first 18 characters. In fact, a_string[:n] will always return the first n characters, and a_string[n:] will return the rest, regardless of the length of the string.</p></li>
</ol>

<p>.</p>

<p>4.6. STRINGS VS. BYTES
Bytes are bytes; characters are an abstraction. An immutable sequence of Unicode characters is called a string. An immutable sequence of numbers-between-0-and-255 is called a bytes object.
&gt;&gt;&gt; by = b&rsquo;abcd\x65&rsquo; .
&gt;&gt;&gt; by
b&rsquo;abcde&rsquo;
&gt;&gt;&gt; type(by) .
<class 'bytes'>
&gt;&gt;&gt; len(by) .
5
&gt;&gt;&gt; by += b&rsquo;\xff&rsquo; .
&gt;&gt;&gt; by
b&rsquo;abcde\xff&rsquo;
&gt;&gt;&gt; len(by) .
6
&gt;&gt;&gt; by[0] .
97
&gt;&gt;&gt; by[0] = 102 .</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
TypeError: &lsquo;bytes&rsquo; object does not support item assignment</p>

<ol>
<li><p>To define a bytes object, use the b&rdquo; “byte literal” syntax. Each byte within the byte literal can be an ASCII character or an encoded hexadecimal number from \x00 to \xff (0–255).</p></li>

<li><p>The type of a bytes object is bytes.</p></li>

<li><p>Just like lists and strings, you can get the length of a bytes object with the built-in len() function.</p></li>

<li><p>Just like lists and strings, you can use the + operator to concatenate bytes objects. The result is a new bytes object.</p></li>

<li><p>Concatenating a 5-byte bytes object and a 1-byte bytes object gives you a 6-byte bytes object.</p></li>

<li><p>Just like lists and strings, you can use index notation to get individual bytes in a bytes object. The items of a string are strings; the items of a bytes object are integers. Specifically, integers between 0–255.</p></li>

<li><p>A bytes object is immutable; you can not assign individual bytes. If you need to change individual bytes, you can either use string
slicing
and concatenation operators (which work the same as strings), or you can convert the bytes object into a bytearray object.</p></li>
</ol>

<blockquote>
<blockquote>
<blockquote>
<p>by = b&rsquo;abcd\x65&rsquo;
barr = bytearray(by) .
barr
bytearray(b&rsquo;abcde&rsquo;)
len(barr) .
5
barr[0] = 102 .
barr
bytearray(b&rsquo;fbcde&rsquo;)</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>To convert a bytes object into a mutable bytearray object, use the built-in bytearray() function.</p></li>

<li><p>All the methods and operations you can do on a bytes object, you can do on a bytearray object too.</p></li>

<li><p>The one difference is that, with the bytearray object, you can assign individual bytes using index notation. The assigned value must be an integer between 0–255.</p></li>
</ol>

<p>The one thing you can never do is mix bytes and strings.
&gt;&gt;&gt; by = b&rsquo;d&rsquo;
&gt;&gt;&gt; s = &lsquo;abcde&rsquo;
&gt;&gt;&gt; by + s .</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
TypeError: can&rsquo;t concat bytes to str</p>

<blockquote>
<blockquote>
<blockquote>
<p>s.count(by)     .
Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
TypeError: Can&rsquo;t convert &lsquo;bytes&rsquo; object to str implicitly</p>

<p>s.count(by.decode(&lsquo;ascii&rsquo;)) .
1</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>You can’t concatenate bytes and strings. They are two different data types.</p></li>

<li><p>You can’t count the occurrences of bytes in a string, because there are no bytes in a string. A string is a sequence of characters. Perhaps you meant “count the occurrences of the string that you would get after</p></li>
</ol>

<p>decoding this sequence of bytes in a particular character encoding”? Well then, you’ll need to say that explicitly. Python 3 won’t implicitly convert bytes to strings or strings to bytes.</p>

<ol>
<li>By an amazing coincidence, this line of code says “count the occurrences of the string that you would get after decoding this sequence of bytes in this particular character encoding.”</li>
</ol>

<p>And here is the link between strings and bytes: bytes objects have a decode() method that takes a character encoding and returns a string, and strings have an encode() method that takes a character encoding and returns a bytes object. In the previous example, the decoding was relatively straightforward — converting a sequence of bytes in the ASCII encoding into a string of characters. But the same process works with any encoding that supports the characters of the string — even legacy (non-Unicode) encodings.
&gt;&gt;&gt; a_string = &lsquo;.. Python&rsquo; .
&gt;&gt;&gt; len(a_string)
9
&gt;&gt;&gt; by = a_string.encode(&lsquo;utf-8&rsquo;) .
&gt;&gt;&gt; by
b&rsquo;\xe6\xb7\xb1\xe5\x85\xa5 Python&rsquo;
&gt;&gt;&gt; len(by)
13
&gt;&gt;&gt; by = a_string.encode(&lsquo;gb18030&rsquo;) .
&gt;&gt;&gt; by
b&rsquo;\xc9\xee\xc8\xeb Python&rsquo;
&gt;&gt;&gt; len(by)
11
&gt;&gt;&gt; by = a_string.encode(&lsquo;big5&rsquo;) .
&gt;&gt;&gt; by
b&rsquo;\xb2`\xa4J Python&rsquo;
&gt;&gt;&gt; len(by)
11
&gt;&gt;&gt; roundtrip = by.decode(&lsquo;big5&rsquo;) .
&gt;&gt;&gt; roundtrip
&lsquo;.. Python&rsquo;
&gt;&gt;&gt; a_string == roundtrip
True</p>

<ol>
<li>This is a string. It has nine characters.</li>
<li>Thisisa bytes object. It has 13 bytes. It is the sequence of bytes you get when you take a_string and encode it in UTF-8.</li>
<li>Thisisa bytes object. It has 11 bytes. It is the sequence of bytes you get when you take a_string and encode it in GB18030.</li>
<li>Thisisa bytes object. It has 11 bytes. It is an entirely different sequence of bytes that you get when you take a_string and encode it in Big5.</li>
<li>This is a string. It has nine characters. It is the sequence of characters you get when you take by and decode it using the Big5 encoding algorithm. It is identical to the original string.</li>
</ol>

<p>.</p>

<p>4.7. POSTSCRIPT: CHARACTER ENCODING OF PYTHON SOURCE CODE
Python 3 assumes that your source code — i.e. each .py file — is encoded in UTF-8.
. In Python 2, the default encoding for .py files was ASCII. In Python 3, the
default
encoding
is
UTF-8.
If you would like to use a different encoding within your Python code, you can put an encoding declaration on the first line of each file. This declaration defines a .py file to be windows-1252:</p>

<h1 id="coding-windows-1252">-*- coding: windows-1252 -*­</h1>

<p>Technically, the character encoding override can also be on the second line, if the first line is a UNIX-like hash-bang command.
#!/usr/bin/python3</p>

<h1 id="coding-windows-1252-1">-*- coding: windows-1252 -*­</h1>

<p>For more information, consult PEP
263:
Defining
Python
Source
Code
Encodings.
.</p>

<p>4.8. FURTHER READING
On Unicode in Python:
• Python
Unicode
HOWTO</p>

<p>•  What’s
New
In
Python
3:
Text
vs.
Data
Instead
Of
Unicode
vs.
8-bit</p>

<p>•  PEP  261
explains
how
Python
handles
astral
characters
outside
of
the
Basic
Multilingual
Plane
(i.e. characters</p>

<p>whose ordinal value is greater than 65535)<br />
On Unicode in general:<br />
•  The
Absolute
Minimum
Every
Software
Developer
Absolutely,
Positively
Must
Know
About
Unicode
and</p>

<p>Character
Sets
(No
Excuses!)</p>

<p>•  On
the
Goodness
of
Unicode</p>

<p>•  On
Character
Strings</p>

<p>•  Characters
vs.
Bytes</p>

<p>On character encoding in other formats:<br />
•  Character
encoding
in
XML</p>

<p>•  Character
encoding
in
HTML</p>

<p>On strings and string formatting:<br />
•  string —
Common
string
operations</p>

<p>•  Format
String
Syntax</p>

<p>•  Format
Specification
Mini-Language</p>

<p>•  PEP
3101:
Advanced
String
Formatting</p>

<p>CHAPTER 5. REGULAR EXPRESSIONS</p>

<p>. Some people, when confronted with a problem, think “I know, I’ll use regular expressions.” Now they have two problems. .
— Jamie Zawinski</p>

<p>5.1. DIVING IN
Getting a small bit of text out of a large block of text is a challenge. In Python, strings have methods for searching and replacing: index(), find(), split(), count(), replace(), &amp;c. But these methods are limited to the simplest of cases. For example, the index() method looks for a single, hard-coded substring, and the search is always case-sensitive. To do case-insensitive searches of a string s, you must call s.lower() or s.upper() and make sure your search strings are the appropriate case to match. The replace() and split() methods have the same limitations.
If your goal can be accomplished with string methods, you should use them. They’re fast and simple and easy to read, and there’s a lot to be said for fast, simple, readable code. But if you find yourself using a lot of different string functions with if statements to handle special cases, or if you’re chaining calls to split() and join() to slice-and-dice your strings, you may need to move up to regular expressions.
Regular expressions are a powerful and (mostly) standardized way of searching, replacing, and parsing text with complex patterns of characters. Although the regular expression syntax is tight and unlike normal code, the result can end up being more readable than a hand-rolled solution that uses a long chain of string functions. There are even ways of embedding comments within regular expressions, so you can include fine-grained documentation within them.
. If you’ve used regular expressions in other languages (like Perl, JavaScript, or PHP),
Python’s syntax will be very familiar. Read the summary of the re module
to get an
overview of the available functions and their arguments.</p>

<p>.</p>

<p>5.2. CASE STUDY: STREET ADDRESSES
This series of examples was inspired by a real-life problem I had in my day job several years ago, when I needed to scrub and standardize street addresses exported from a legacy system before importing them into a newer system. (See, I don’t just make this stuff up; it’s actually useful.) This example shows how I approached the problem.
&gt;&gt;&gt; s = &lsquo;100 NORTH MAIN ROAD&rsquo;
&gt;&gt;&gt; s.replace(&lsquo;ROAD&rsquo;, &lsquo;RD.&rsquo;) .
&lsquo;100 NORTH MAIN RD.&rsquo;
&gt;&gt;&gt; s = &lsquo;100 NORTH BROAD ROAD&rsquo;
&gt;&gt;&gt; s.replace(&lsquo;ROAD&rsquo;, &lsquo;RD.&rsquo;) .
&lsquo;100 NORTH BRD. RD.&rsquo;
&gt;&gt;&gt; s[:-4] + s[-4:].replace(&lsquo;ROAD&rsquo;, &lsquo;RD.&rsquo;) .
&lsquo;100 NORTH BROAD RD.&rsquo;
&gt;&gt;&gt; import re .
&gt;&gt;&gt; re.sub(&lsquo;ROAD$&rsquo;, &lsquo;RD.&rsquo;, s) .
&lsquo;100 NORTH BROAD RD.&rsquo;</p>

<ol>
<li><p>My goal is to standardize a street address so that &lsquo;ROAD&rsquo; is always abbreviated as &lsquo;RD.&rsquo;. At first glance, I thought this was simple enough that I could just use the string method replace(). After all, all the data was already uppercase, so case mismatches would not be a problem. And the search string, &lsquo;ROAD&rsquo;, was a constant. And in this deceptively simple example, s.replace() does indeed work.</p></li>

<li><p>Life, unfortunately, is full of counterexamples, and I quickly discovered this one. The problem here is that &lsquo;ROAD&rsquo; appears twice in the address, once as part of the street name &lsquo;BROAD&rsquo; and once as its own word. The replace() method sees these two occurrences and blindly replaces both of them; meanwhile, I see my addresses getting destroyed.</p></li>

<li><p>To solve the problem of addresses with more than one &lsquo;ROAD&rsquo; substring, you could resort to something like this: only search and replace &lsquo;ROAD&rsquo; in the last four characters of the address (s[-4:]), and leave the string alone (s[:-4]). But you can see that this is already getting unwieldy. For example, the pattern is dependent on the length of the string you’re replacing. (If you were replacing &lsquo;STREET&rsquo; with &lsquo;ST.&rsquo;, you would need to</p></li>
</ol>

<p>use s[:-6] and s[-6:].replace(&hellip;).) Would you like to come back in six months and debug this? I know I wouldn’t.</p>

<ol>
<li><p>It’s time to move up to regular expressions. In Python, all functionality related to regular expressions is contained in the re module.</p></li>

<li><p>Take a look at the first parameter: &lsquo;ROAD$&rsquo;. This is a simple regular expression that matches &lsquo;ROAD&rsquo; only when it occurs at the end of a string. The $ means “end of the string.” (There is a corresponding character, the caret ^, which means “beginning of the string.”) Using the re.sub() function, you search the string s for the regular expression &lsquo;ROAD$&rsquo; and replace it with &lsquo;RD.&rsquo;. This matches the ROAD at the end of the string s, but does not match the ROAD that’s part of the word BROAD, because that’s in the middle of s.</p></li>
</ol>

<p>Continuing with my story of scrubbing addresses, I soon
discovered that the previous example, matching &lsquo;ROAD&rsquo;
at the end of the address, was not good enough,
because not all addresses included a street designation
at all. Some addresses simply ended with the street
name. I got away with it most of the time, but if the
street name was &lsquo;BROAD&rsquo;, then the regular expression
would match &lsquo;ROAD&rsquo; at the end of the string as part of
the word &lsquo;BROAD&rsquo;, which is not what I wanted.</p>

<blockquote>
<blockquote>
<blockquote>
<p>s = &lsquo;100 BROAD&rsquo;
re.sub(&lsquo;ROAD$&rsquo;, &lsquo;RD.&rsquo;, s)
&lsquo;100 BRD.&rsquo;
re.sub(&rsquo;\bROAD$&lsquo;, &lsquo;RD.&rsquo;, s) .
&lsquo;100 BROAD&rsquo;
re.sub(r&rsquo;\bROAD$&lsquo;, &lsquo;RD.&rsquo;, s) .
&lsquo;100 BROAD&rsquo;
s = &lsquo;100 BROAD ROAD APT. 3&rsquo;
re.sub(r&rsquo;\bROAD$&lsquo;, &lsquo;RD.&rsquo;, s) .
&lsquo;100 BROAD ROAD APT. 3&rsquo;
re.sub(r&rsquo;\bROAD\b&rsquo;, &lsquo;RD.&rsquo;, s) .
&lsquo;100 BROAD RD. APT 3&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>What I really wanted was to match &lsquo;ROAD&rsquo; when it was at the end of the string and it was its own word (and not a part of some larger word). To express this in a regular expression, you use \b, which means “a word boundary must occur right here.” In Python, this is complicated by the fact that the &lsquo;\&rsquo; character in a string must itself be escaped. This is sometimes referred to as the backslash plague, and it is one reason why regular expressions are easier in Perl than in Python. On the down side, Perl mixes regular expressions with other syntax, so if you have a bug, it may be hard to tell whether it’s a bug in syntax or a bug in your regular expression.</p></li>

<li><p>To work around the backslash plague, you can use what is called a raw string, by prefixing the string with the letter r. This tells Python that nothing in this string should be escaped; &lsquo;\t&rsquo; is a tab character, but r&rsquo;\t&rsquo; is really the backslash character \ followed by the letter t. I recommend always using raw strings when dealing with regular expressions; otherwise, things get too confusing too quickly (and regular expressions are confusing enough already).</p></li>

<li><p><em>sigh</em> Unfortunately, I soon found more cases that contradicted my logic. In this case, the street address contained the word &lsquo;ROAD&rsquo; as a whole word by itself, but it wasn’t at the end, because the address had an apartment number after the street designation. Because &lsquo;ROAD&rsquo; isn’t at the very end of the string, it doesn’t match, so the entire call to re.sub() ends up replacing nothing at all, and you get the original string back, which is not what you want.</p></li>

<li><p>To solve this problem, I removed the $ character and added another \b. Now the regular expression reads “match &lsquo;ROAD&rsquo; when it’s a whole word by itself anywhere in the string,” whether at the end, the beginning, or somewhere in the middle.</p></li>
</ol>

<p>.</p>

<p>5.3. CASE STUDY: ROMAN NUMERALS
You’ve most likely seen Roman numerals, even if you didn’t recognize them. You may have seen them in copyrights of old movies and television shows (“Copyright MCMXLVI” instead of “Copyright 1946”), or on the dedication walls of libraries or universities (“established MDCCCLXXXVIII” instead of “established 1888”). You may also have seen them in outlines and bibliographical references. It’s a system of representing numbers that really does date back to the ancient Roman empire (hence the name).
In Roman numerals, there are seven characters that are repeated and combined in various ways to represent numbers.
•   I=1</p>

<p>•   V=5</p>

<p>•   X = 10</p>

<p>•   L = 50</p>

<p>•   C = 100</p>

<p>•   D = 500</p>

<p>•   M = 1000</p>

<p>The following are some general rules for constructing Roman numerals:
•   Sometimes characters are additive. I is 1, II is 2, and III is 3. VI is 6 (literally, “5 and 1”), VII is 7, and VIII is 8.</p>

<p>•   The tens characters (I, X, C, and M) can be repeated up to three times. At 4, you need to subtract from the next highest fives character. You can&rsquo;t represent 4 as IIII; instead, it is represented as IV (“1 less than 5”). 40 is written as XL (“10 less than 50”), 41 as XLI, 42 as XLII, 43 as XLIII, and then 44 as XLIV (“10 less than 50, then 1 less than 5”).</p>

<p>•   Sometimes characters are… the opposite of additive. By putting certain characters before others, you subtract from the final value. For example, at 9, you need to subtract from the next highest tens character: 8 is VIII, but 9 is IX (“1 less than 10”), not VIIII (since the I character can not be repeated four times). 90 is XC, 900 is CM.</p>

<p>•   The fives characters can not be repeated. 10 is always represented as X, never as VV. 100 is always C, never LL.</p>

<p>•   Roman numerals are read left to right, so the order of characters matters very much. DC is 600; CD is a completely different number (400,“100 less than 500”). CI is 101; IC is not even a valid Roman numeral (because you can&rsquo;t subtract 1 directly from 100; you would need to write it as XCIX,“10 less than 100, then 1 less than 10”).</p>

<p>5.3.1. CHECKING FOR THOUSANDS</p>

<p>What would it take to validate that an arbitrary string is a valid Roman numeral? Let’s take it one digit at a time. Since Roman numerals are always written highest to lowest, let’s start with the highest: the thousands place. For numbers 1000 and higher, the thousands are represented by a series of M characters.
&gt;&gt;&gt; import re
&gt;&gt;&gt; pattern = &lsquo;^M?M?M?$&rsquo; .
&gt;&gt;&gt; re.search(pattern, &rsquo;M&rsquo;) .
&lt;_sre.SRE_Match object at 0106FB58&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;MM&rsquo;) .
&lt;_sre.SRE_Match object at 0106C290&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;MMM&rsquo;) .
&lt;_sre.SRE_Match object at 0106AA38&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;MMMM&rsquo;) .
&gt;&gt;&gt; re.search(pattern, &ldquo;) .
&lt;_sre.SRE_Match object at 0106F4A8&gt;</p>

<ol>
<li><p>This pattern has three parts. ^ matches what follows only at the beginning of the string. If this were not specified, the pattern would match no matter where the M characters were, which is not what you want. You want to make sure that the M characters, if they’re there, are at the beginning of the string. M? optionally matches a single M character. Since this is repeated three times, you’re matching anywhere from zero to three M characters in a row. And $ matches the end of the string. When combined with the ^ character at the beginning, this means that the pattern must match the entire string, with no other characters before or after the M characters.</p></li>

<li><p>The essence of the re module is the search() function, that takes a regular expression (pattern) and a string (&rsquo;M&rsquo;) to try to match against the regular expression. If a match is found, search() returns an object which has various methods to describe the match; if no match is found, search() returns None, the Python null value. All you care about at the moment is whether the pattern matches, which you can tell by just looking at the return value of search(). &rsquo;M&rsquo; matches this regular expression, because the first optional M matches and the second and third optional M characters are ignored.</p></li>

<li><p>&lsquo;MM&rsquo; matches because the first and second optional M characters match and the third M is ignored.</p></li>

<li><p>&lsquo;MMM&rsquo; matches because all three M characters match.</p></li>

<li><p>&lsquo;MMMM&rsquo; does not match. All three M characters match, but then the regular expression insists on the string ending (because of the $ character), and the string doesn’t end yet (because of the fourth M). So search() returns None.</p></li>

<li><p>Interestingly, an empty string also matches this regular expression, since all the M characters are optional.</p></li>
</ol>

<p>5.3.2. CHECKING FOR HUNDREDS
The hundreds place is more difficult than the thousands,
because there are several mutually exclusive ways it
could be expressed, depending on its value.</p>

<p>• 100 = C</p>

<p>• 200 = CC</p>

<p>• 300 = CCC</p>

<p>• 400 = CD</p>

<p>• 500 = D</p>

<p>• 600 = DC</p>

<p>• 700 = DCC</p>

<p>• 800 = DCCC</p>

<p>• 900 = CM</p>

<p>So there are four possible patterns:</p>

<p>• CM</p>

<p>• CD</p>

<p>• Zero to three C characters (zero if the hundreds place is 0)</p>

<p>• D, followed by zero to three C characters</p>

<p>• an optional D, followed by zero to three C characters</p>

<p>The last two patterns can be combined:
This example shows how to validate the hundreds place of a Roman numeral.
&gt;&gt;&gt; import re
&gt;&gt;&gt; pattern = &lsquo;^M?M?M?(CM|CD|D?C?C?C?)$&rsquo; .
&gt;&gt;&gt; re.search(pattern, &lsquo;MCM&rsquo;) .
&lt;_sre.SRE_Match object at 01070390&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;MD&rsquo;) .
&lt;_sre.SRE_Match object at 01073A50&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;MMMCCC&rsquo;) .
&lt;_sre.SRE_Match object at 010748A8&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;MCMC&rsquo;) .
&gt;&gt;&gt; re.search(pattern, &ldquo;) .
&lt;_sre.SRE_Match object at 01071D98&gt;</p>

<ol>
<li><p>This pattern starts out the same as the previous one, checking for the beginning of the string (^), then the thousands place (M?M?M?). Then it has the new part, in parentheses, which defines a set of three mutually exclusive patterns, separated by vertical bars: CM, CD, and D?C?C?C? (which is an optional D followed by zero to three optional C characters). The regular expression parser checks for each of these patterns in order (from left to right), takes the first one that matches, and ignores the rest.</p></li>

<li><p>&lsquo;MCM&rsquo; matches because the first M matches, the second and third M characters are ignored, and the CM matches (so the CD and D?C?C?C? patterns are never even considered). MCM is the Roman numeral representation of 1900.</p></li>

<li><p>&lsquo;MD&rsquo; matches because the first M matches, the second and third M characters are ignored, and the D?C?C?C? pattern matches D (each of the three C characters are optional and are ignored). MD is the Roman numeral representation of 1500.</p></li>

<li><p>&lsquo;MMMCCC&rsquo; matches because all three M characters match, and the D?C?C?C? pattern matches CCC (the D is optional and is ignored). MMMCCC is the Roman numeral representation of 3300.</p></li>

<li><p>&lsquo;MCMC&rsquo; does not match. The first M matches, the second and third M characters are ignored, and the CM matches, but then the $ does not match because you’re not at the end of the string yet (you still have an unmatched C character). The C does not match as part of the D?C?C?C? pattern, because the mutually exclusive CM pattern has already matched.</p></li>

<li><p>Interestingly, an empty string still matches this pattern, because all the M characters are optional and ignored, and the empty string matches the D?C?C?C? pattern where all the characters are optional and ignored.</p></li>
</ol>

<p>Whew! See how quickly regular expressions can get nasty? And you’ve only covered the thousands and hundreds places of Roman numerals. But if you followed all that, the tens and ones places are easy, because they’re exactly the same pattern. But let’s look at another way to express the pattern.</p>

<p>.</p>

<p>5.4. USING THE {n,m} SYNTAX
In the previous section, you were dealing with a pattern where the same character could be repeated up to
three times. There is another way to express this in regular expressions, which some people find more readable. First look at the method we already used in the previous example.
&gt;&gt;&gt; import re &gt;&gt;&gt; pattern = &lsquo;^M?M?M?$&rsquo; &gt;&gt;&gt; re.search(pattern, &rsquo;M&rsquo;) . &lt;_sre.SRE_Match object at 0x008EE090&gt; &gt;&gt;&gt; pattern = &lsquo;^M?M?M?$&rsquo; &gt;&gt;&gt; re.search(pattern, &lsquo;MM&rsquo;) . &lt;_sre.SRE_Match object at 0x008EEB48&gt; &gt;&gt;&gt; pattern = &lsquo;^M?M?M?$&rsquo; &gt;&gt;&gt; re.search(pattern, &lsquo;MMM&rsquo;) . &lt;_sre.SRE_Match object at 0x008EE090&gt; &gt;&gt;&gt; re.search(pattern, &lsquo;MMMM&rsquo;) .</p>

<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>This matches the start of the string, and then the first optional M, but not the second and third M (but that’s okay because they’re optional), and then the end of the string.</p></li>

<li><p>This matches the start of the string, and then the first and second optional M, but not the third M (but that’s okay because it’s optional), and then the end of the string.</p></li>

<li><p>This matches the start of the string, and then all three optional M, and then the end of the string.</p></li>

<li><p>This matches the start of the string, and then all three optional M, but then does not match the end of the string (because there is still one unmatched M), so the pattern does not match and returns None.</p></li>
</ol>

<blockquote>
<blockquote>
<blockquote>
<p>pattern = &lsquo;^M{0,3}$&rsquo; .
re.search(pattern, &rsquo;M&rsquo;) .
&lt;_sre.SRE_Match object at 0x008EEB48&gt;
re.search(pattern, &lsquo;MM&rsquo;) .
&lt;_sre.SRE_Match object at 0x008EE090&gt;
re.search(pattern, &lsquo;MMM&rsquo;) .
&lt;_sre.SRE_Match object at 0x008EEDA8&gt;
re.search(pattern, &lsquo;MMMM&rsquo;) .</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>This pattern says: “Match the start of the string, then anywhere from zero to three M characters, then the end of the string.” The 0 and 3 can be any numbers; if you want to match at least one but no more than three M characters, you could say M{1,3}.</p></li>

<li><p>This matches the start of the string, then one M out of a possible three, then the end of the string.</p></li>

<li><p>This matches the start of the string, then two M out of a possible three, then the end of the string.</p></li>

<li><p>This matches the start of the string, then three M out of a possible three, then the end of the string.</p></li>

<li><p>This matches the start of the string, then three M out of a possible three, but then does not match the end of the string. The regular expression allows for up to only three M characters before the end of the string, but you have four, so the pattern does not match and returns None.</p></li>
</ol>

<p>5.4.1. CHECKING FOR TENS AND ONES
Now let’s expand the Roman numeral regular expression to cover the tens and ones place. This example shows the check for tens.
&gt;&gt;&gt; pattern = &lsquo;^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)$&rsquo;
&gt;&gt;&gt; re.search(pattern, &lsquo;MCMXL&rsquo;) .
&lt;_sre.SRE_Match object at 0x008EEB48&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;MCML&rsquo;) .
&lt;_sre.SRE_Match object at 0x008EEB48&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;MCMLX&rsquo;) .
&lt;_sre.SRE_Match object at 0x008EEB48&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;MCMLXXX&rsquo;) .
&lt;_sre.SRE_Match object at 0x008EEB48&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;MCMLXXXX&rsquo;) .
&gt;&gt;&gt;</p>

<ol>
<li><p>This matches the start of the string, then the first optional M, then CM, then XL, then the end of the string. Remember, the (A|B|C) syntax means “match exactly one of A, B, or C”. You match XL, so you ignore the XC and L?X?X?X? choices, and then move on to the end of the string. MCMXL is the Roman numeral representation of 1940.</p></li>

<li><p>This matches the start of the string, then the first optional M, then CM, then L?X?X?X?. Of the L?X?X?X?, it matches the L and skips all three optional X characters. Then you move to the end of the string. MCML is the Roman numeral representation of 1950.</p></li>

<li><p>This matches the start of the string, then the first optional M, then CM, then the optional L and the first optional X, skips the second and third optional X, then the end of the string. MCMLX is the Roman numeral representation of 1960.</p></li>

<li><p>This matches the start of the string, then the first optional M, then CM, then the optional L and all three optional X characters, then the end of the string. MCMLXXX is the Roman numeral representation of 1980.</p></li>

<li><p>This matches the start of the string, then the first optional M, then CM, then the optional L and all three optional X characters, then fails to match the end of the string because there is still one more X unaccounted for. So the entire pattern fails to match, and returns None. MCMLXXXX is not a valid Roman numeral.</p></li>
</ol>

<p>The expression for the ones place follows the same pattern. I’ll spare you the details and show you the end result.</p>

<blockquote>
<blockquote>
<blockquote>
<p>pattern = &lsquo;^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<p>So what does that look like using this alternate {n,m} syntax? This example shows the new syntax.
&gt;&gt;&gt; pattern = &lsquo;^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$&rsquo;
&gt;&gt;&gt; re.search(pattern, &lsquo;MDLV&rsquo;) .
&lt;_sre.SRE_Match object at 0x008EEB48&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;MMDCLXVI&rsquo;) .
&lt;_sre.SRE_Match object at 0x008EEB48&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;MMMDCCCLXXXVIII&rsquo;) .
&lt;_sre.SRE_Match object at 0x008EEB48&gt;
&gt;&gt;&gt; re.search(pattern, &lsquo;I&rsquo;) .
&lt;_sre.SRE_Match object at 0x008EEB48&gt;</p>

<ol>
<li><p>This matches the start of the string, then one of a possible three M characters, then D?C{0,3}. Of that, it matches the optional D and zero of three possible C characters. Moving on, it matches L?X{0,3} by matching the optional L and zero of three possible X characters. Then it matches V?I{0,3} by matching the optional V and zero of three possible I characters, and finally the end of the string. MDLV is the Roman numeral representation of 1555.</p></li>

<li><p>This matches the start of the string, then two of a possible three M characters, then the D?C{0,3} with a D and one of three possible C characters; then L?X{0,3} with an L and one of three possible X characters; then V?I{0,3} with a V and one of three possible I characters; then the end of the string. MMDCLXVI is the Roman numeral representation of 2666.</p></li>

<li><p>This matches the start of the string, then three out of three M characters, then D?C{0,3} with a D and three out of three C characters; then L?X{0,3} with an L and three out of three X characters; then V?I{0,3} with a V and three out of three I characters; then the end of the string. MMMDCCCLXXXVIII is the Roman numeral representation of 3888, and it’s the longest Roman numeral you can write without extended syntax.</p></li>

<li><p>Watch closely. (I feel like a magician. “Watch closely, kids, I’m going to pull a rabbit out of my hat.”) This matches the start of the string, then zero out of three M, then matches D?C{0,3} by skipping the optional D and matching zero out of three C, then matches L?X{0,3} by skipping the optional L and matching zero out of three X, then matches V?I{0,3} by skipping the optional V and matching one out of three I. Then the end of the string. Whoa.</p></li>
</ol>

<p>If you followed all that and understood it on the first try, you’re doing better than I did. Now imagine trying to understand someone else’s regular expressions, in the middle of a critical function of a large program. Or even imagine coming back to your own regular expressions a few months later. I’ve done it, and it’s not a pretty sight.
Now let’s explore an alternate syntax that can help keep your expressions maintainable.
.</p>

<p>5.5. VERBOSE REGULAR EXPRESSIONS</p>

<p>So far you’ve just been dealing with what I’ll call “compact” regular expressions. As you’ve seen, they are difficult to read, and even if you figure out what one does, that’s no guarantee that you’ll be able to understand it six months later. What you really need is inline documentation.
Python allows you to do this with something called verbose regular expressions. A verbose regular expression is different from a compact regular expression in two ways:
•   Whitespace is ignored. Spaces, tabs, and carriage returns are not matched as spaces, tabs, and carriage returns. They’re not matched at all. (If you want to match a space in a verbose regular expression, you’ll need to escape it by putting a backslash in front of it.)</p>

<p>•   Comments are ignored. A comment in a verbose regular expression is just like a comment in Python code: it starts with a # character and goes until the end of the line. In this case it’s a comment within a multi-line string instead of within your source code, but it works the same way.</p>

<p>This will be more clear with an example. Let’s revisit the compact regular expression you’ve been working with, and make it a verbose regular expression. This example shows how.
&gt;&gt;&gt;     pattern = &ldquo;&rsquo;
^ # beginning of string
M{0,3} # thousands - 0 to 3 Ms
(CM|CD|D?C{0,3}) # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),</p>

<h1 id="or-500-800-d-followed-by-0-to-3-cs">or 500-800 (D, followed by 0 to 3 Cs)</h1>

<p>(XC|XL|L?X{0,3}) # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),</p>

<h1 id="or-50-80-l-followed-by-0-to-3-xs">or 50-80 (L, followed by 0 to 3 Xs)</h1>

<p>(IX|IV|V?I{0,3}) # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),</p>

<h1 id="or-5-8-v-followed-by-0-to-3-is">or 5-8 (V, followed by 0 to 3 Is)</h1>

<p>$ # end of string
&ldquo;&rsquo;</p>

<blockquote>
<blockquote>
<blockquote>
<p>re.search(pattern, &rsquo;M&rsquo;, re.VERBOSE) .
&lt;_sre.SRE_Match object at 0x008EEB48&gt;
re.search(pattern, &lsquo;MCMLXXXIX&rsquo;, re.VERBOSE) .
&lt;_sre.SRE_Match object at 0x008EEB48&gt;
re.search(pattern, &lsquo;MMMDCCCLXXXVIII&rsquo;, re.VERBOSE) .
&lt;_sre.SRE_Match object at 0x008EEB48&gt;
re.search(pattern, &rsquo;M&rsquo;) .</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>The most important thing to remember when using verbose regular expressions is that you need to pass an extra argument when working with them: re.VERBOSE is a constant defined in the re module that signals that the pattern should be treated as a verbose regular expression. As you can see, this pattern has quite a bit of whitespace (all of which is ignored), and several comments (all of which are ignored). Once you ignore the whitespace and the comments, this is exactly the same regular expression as you saw in the previous section, but it’s a lot more readable.</p></li>

<li><p>This matches the start of the string, then one of a possible three M, then CM, then L and three of a possible three X, then IX, then the end of the string.</p></li>

<li><p>This matches the start of the string, then three of a possible three M, then D and three of a possible three C, then L and three of a possible three X, then V and three of a possible three I, then the end of the string.</p></li>

<li><p>This does not match. Why? Because it doesn’t have the re.VERBOSE flag, so the re.search function is treating the pattern as a compact regular expression, with significant whitespace and literal hash marks. Python can’t auto-detect whether a regular expression is verbose or not. Python assumes every regular expression is compact unless you explicitly state that it is verbose.</p></li>
</ol>

<p>.</p>

<p>5.6. CASE STUDY: PARSING PHONE NUMBERS
So far you’ve concentrated on matching whole patterns. Either the pattern matches, or it doesn’t. But regular
expressions are much more powerful than that. When a regular expression does match, you can pick out specific pieces of it. You can find out what matched where.
This example came from another real-world problem I encountered, again from a previous day job. The problem: parsing an American phone number. The client wanted to be able to enter the number free-form (in a single field), but then wanted to store the area code, trunk, number, and optionally an extension separately in the company’s database. I scoured the Web and found many examples of regular expressions that purported to do this, but none of them were permissive enough.
Here are the phone numbers I needed to be able to accept:</p>

<p>• 800-555-1212 • 800 555 1212 • 800.555.1212 • (800) 555-1212 • 1-800-555-1212 • 800-555-1212-1234 • 800-555-1212x1234 • 800-555-1212 ext. 1234 • work 1-(800) 555.1212 #1234
Quite a variety! In each of these cases, I need to know that the area code was 800, the trunk was 555, and the rest of the phone number was 1212. For those with an extension, I need to know that the extension was 1234.
Let’s work through developing a solution for phone number parsing. This example shows the first step.
&gt;&gt;&gt; phonePattern = re.compile(r&rsquo;^(\d{3})-(\d{3})-(\d{4})$&lsquo;) .
&gt;&gt;&gt; phonePattern.search(&lsquo;800-555-1212&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;)
&gt;&gt;&gt; phonePattern.search(&lsquo;800-555-1212-1234&rsquo;) .
&gt;&gt;&gt; phonePattern.search(&lsquo;800-555-1212-1234&rsquo;).groups() .</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
AttributeError: &lsquo;NoneType&rsquo; object has no attribute &lsquo;groups&rsquo;</p>

<ol>
<li><p>Always read regular expressions from left to right. This one matches the beginning of the string, and then (\d{3}). What’s \d{3}? Well, \d means “any numeric digit” (0 through 9). The {3} means “match exactly three numeric digits”; it’s a variation on the {n,m} syntax you saw earlier. Putting it all in parentheses means “match exactly three numeric digits, and then remember them as a group that I can ask for later”. Then match a literal hyphen. Then match another group of exactly three digits. Then another literal hyphen. Then another group of exactly four digits. Then match the end of the string.</p></li>

<li><p>To get access to the groups that the regular expression parser remembered along the way, use the groups() method on the object that the search() method returns. It will return a tuple of however many groups were defined in the regular expression. In this case, you defined three groups, one with three digits, one with three digits, and one with four digits.</p></li>

<li><p>This regular expression is not the final answer, because it doesn’t handle a phone number with an extension on the end. For that, you’ll need to expand the regular expression.</p></li>

<li><p>And this is why you should never “chain” the search() and groups() methods in production code. If the search() method returns no matches, it returns None, not a regular expression match object. Calling None.groups() raises a perfectly obvious exception: None doesn’t have a groups() method. (Of course, it’s slightly less obvious when you get this exception from deep within your code. Yes, I speak from experience here.)</p></li>
</ol>

<blockquote>
<blockquote>
<blockquote>
<p>phonePattern = re.compile(r&rsquo;^(\d{3})-(\d{3})-(\d{4})-(\d+)$&lsquo;) .
phonePattern.search(&lsquo;800-555-1212-1234&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &lsquo;1234&rsquo;)
phonePattern.search(&lsquo;800 555 1212 1234&rsquo;) .</p>

<p>phonePattern.search(&lsquo;800-555-1212&rsquo;) .</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>This regular expression is almost identical to the previous one. Just as before, you match the beginning of the string, then a remembered group of three digits, then a hyphen, then a remembered group of three digits, then a hyphen, then a remembered group of four digits. What’s new is that you then match another hyphen, and a remembered group of one or more digits, then the end of the string.</p></li>

<li><p>The groups() method now returns a tuple of four elements, since the regular expression now defines four groups to remember.</p></li>

<li><p>Unfortunately, this regular expression is not the final answer either, because it assumes that the different parts of the phone number are separated by hyphens. What if they’re separated by spaces, or commas, or dots? You need a more general solution to match several different types of separators.</p></li>

<li><p>Oops! Not only does this regular expression not do everything you want, it’s actually a step backwards, because now you can’t parse phone numbers without an extension. That’s not what you wanted at all; if the extension is there, you want to know what it is, but if it’s not there, you still want to know what the different parts of the main number are.</p></li>
</ol>

<p>The next example shows the regular expression to handle separators between the different parts of the phone number.
&gt;&gt;&gt; phonePattern = re.compile(r&rsquo;^(\d{3})\D+(\d{3})\D+(\d{4})\D+(\d+)$&lsquo;) .
&gt;&gt;&gt; phonePattern.search(&lsquo;800 555 1212 1234&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &lsquo;1234&rsquo;)
&gt;&gt;&gt; phonePattern.search(&lsquo;800-555-1212-1234&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &lsquo;1234&rsquo;)
&gt;&gt;&gt; phonePattern.search(&lsquo;80055512121234&rsquo;) .
&gt;&gt;&gt;
&gt;&gt;&gt; phonePattern.search(&lsquo;800-555-1212&rsquo;) .
&gt;&gt;&gt;</p>

<ol>
<li><p>Hang on to your hat. You’re matching the beginning of the string, then a group of three digits, then \D+. What the heck is that? Well, \D matches any character except a numeric digit, and + means “1 or more”. So \D+ matches one or more characters that are not digits. This is what you’re using instead of a literal hyphen, to try to match different separators.</p></li>

<li><p>Using \D+ instead of -means you can now match phone numbers where the parts are separated by spaces instead of hyphens.</p></li>

<li><p>Of course, phone numbers separated by hyphens still work too.</p></li>

<li><p>Unfortunately, this is still not the final answer, because it assumes that there is a separator at all. What if the phone number is entered without any spaces or hyphens at all?</p></li>

<li><p>Oops! This still hasn’t fixed the problem of requiring extensions. Now you have two problems, but you can solve both of them with the same technique.</p></li>
</ol>

<p>The next example shows the regular expression for handling phone numbers without separators.
&gt;&gt;&gt; phonePattern = re.compile(r&rsquo;^(\d{3})\D<em>(\d{3})\D</em>(\d{4})\D<em>(\d</em>)$&lsquo;) .
&gt;&gt;&gt; phonePattern.search(&lsquo;80055512121234&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &lsquo;1234&rsquo;)
&gt;&gt;&gt; phonePattern.search(&lsquo;800.555.1212 x1234&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &lsquo;1234&rsquo;)
&gt;&gt;&gt; phonePattern.search(&lsquo;800-555-1212&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &ldquo;)
&gt;&gt;&gt; phonePattern.search(&lsquo;(800)5551212 x1234&rsquo;) .
&gt;&gt;&gt;</p>

<ol>
<li><p>The only change you’ve made since that last step is changing all the + to <em>. Instead of \D+ between the parts of the phone number, you now match on \D</em>. Remember that + means “1 or more”? Well, * means “zero or more”. So now you should be able to parse phone numbers even when there is no separator character at all.</p></li>

<li><p>Lo and behold, it actually works. Why? You matched the beginning of the string, then a remembered group of three digits (800), then zero non-numeric characters, then a remembered group of three digits (555), then zero non-numeric characters, then a remembered group of four digits (1212), then zero non-numeric characters, then a remembered group of an arbitrary number of digits (1234), then the end of the string.</p></li>

<li><p>Other variations work now too: dots instead of hyphens, and both a space and an x before the extension.</p></li>

<li><p>Finally, you’ve solved the other long-standing problem: extensions are optional again. If no extension is found, the groups() method still returns a tuple of four elements, but the fourth element is just an empty string.</p></li>

<li><p>I hate to be the bearer of bad news, but you’re not finished yet. What’s the problem here? There’s an extra character before the area code, but the regular expression assumes that the area code is the first thing at the beginning of the string. No problem, you can use the same technique of “zero or more non-numeric characters” to skip over the leading characters before the area code.</p></li>
</ol>

<p>The next example shows how to handle leading characters in phone numbers.
&gt;&gt;&gt; phonePattern = re.compile(r&rsquo;^\D<em>(\d{3})\D</em>(\d{3})\D<em>(\d{4})\D</em>(\d*)$&lsquo;) .
&gt;&gt;&gt; phonePattern.search(&lsquo;(800)5551212 ext. 1234&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &lsquo;1234&rsquo;)
&gt;&gt;&gt; phonePattern.search(&lsquo;800-555-1212&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &ldquo;)
&gt;&gt;&gt; phonePattern.search(&lsquo;work 1-(800) 555.1212 #1234&rsquo;) .
&gt;&gt;&gt;</p>

<ol>
<li><p>This is the same as in the previous example, except now you’re matching \D*, zero or more non-numeric characters, before the first remembered group (the area code). Notice that you’re not remembering these non-numeric characters (they’re not in parentheses). If you find them, you’ll just skip over them and then start remembering the area code whenever you get to it.</p></li>

<li><p>You can successfully parse the phone number, even with the leading left parenthesis before the area code. (The right parenthesis after the area code is already handled; it’s treated as a non-numeric separator and matched by the \D* after the first remembered group.)</p></li>

<li><p>Just a sanity check to make sure you haven’t broken anything that used to work. Since the leading characters are entirely optional, this matches the beginning of the string, then zero non-numeric characters, then a remembered group of three digits (800), then one non-numeric character (the hyphen), then a remembered group of three digits (555), then one non-numeric character (the hyphen), then a remembered group of four digits (1212), then zero non-numeric characters, then a remembered group of zero digits, then the end of the string.</p></li>

<li><p>This is where regular expressions make me want to gouge my eyes out with a blunt object. Why doesn’t this phone number match? Because there’s a 1 before the area code, but you assumed that all the leading characters before the area code were non-numeric characters (\D*). Aargh.</p></li>
</ol>

<p>Let’s back up for a second. So far the regular expressions have all matched from the beginning of the string. But now you see that there may be an indeterminate amount of stuff at the beginning of the string that you want to ignore. Rather than trying to match it all just so you can skip over it, let’s take a different approach: don’t explicitly match the beginning of the string at all. This approach is shown in the next example.
&gt;&gt;&gt; phonePattern = re.compile(r&rsquo;(\d{3})\D<em>(\d{3})\D</em>(\d{4})\D<em>(\d</em>)$&lsquo;) .
&gt;&gt;&gt; phonePattern.search(&lsquo;work 1-(800) 555.1212 #1234&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &lsquo;1234&rsquo;)
&gt;&gt;&gt; phonePattern.search(&lsquo;800-555-1212&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &ldquo;)
&gt;&gt;&gt; phonePattern.search(&lsquo;80055512121234&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &lsquo;1234&rsquo;)</p>

<ol>
<li><p>Note the lack of ^ in this regular expression. You are not matching the beginning of the string anymore. There’s nothing that says you need to match the entire input with your regular expression. The regular expression engine will do the hard work of figuring out where the input string starts to match, and go from there.</p></li>

<li><p>Now you can successfully parse a phone number that includes leading characters and a leading digit, plus any number of any kind of separators around each part of the phone number.</p></li>

<li><p>Sanity check. This still works.</p></li>

<li><p>That still works too.</p></li>
</ol>

<p>See how quickly a regular expression can get out of control? Take a quick glance at any of the previous iterations. Can you tell the difference between one and the next?
While you still understand the final answer (and it is the final answer; if you’ve discovered a case it doesn’t handle, I don’t want to know about it), let’s write it out as a verbose regular expression, before you forget why you made the choices you made.
&gt;&gt;&gt; phonePattern = re.compile(r&rdquo;&rsquo;</p>

<h1 id="don-t-match-beginning-of-string-number-can-start-anywhere">don&rsquo;t match beginning of string, number can start anywhere</h1>

<p>(\d{3}) # area code is 3 digits (e.g. &lsquo;800&rsquo;)</p>

<p>\D* # optional separator is any number of non-digits</p>

<p>(\d{3}) # trunk is 3 digits (e.g. &lsquo;555&rsquo;)</p>

<p>\D* # optional separator</p>

<p>(\d{4}) # rest of number is 4 digits (e.g. &lsquo;1212&rsquo;)</p>

<p>\D* # optional separator</p>

<p>(\d*) # extension is optional and can be any number of digits</p>

<p>$ # end of string</p>

<p>&rdquo;&lsquo;, re.VERBOSE)</p>

<blockquote>
<blockquote>
<blockquote>
<p>phonePattern.search(&lsquo;work 1-(800) 555.1212 #1234&rsquo;).groups() .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &lsquo;1234&rsquo;)</p>

<p>phonePattern.search(&lsquo;800-555-1212&rsquo;)     .
(&lsquo;800&rsquo;, &lsquo;555&rsquo;, &lsquo;1212&rsquo;, &ldquo;)</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>Other than being spread out over multiple lines, this is exactly the same regular expression as the last step, so it’s no surprise that it parses the same inputs.</p></li>

<li><p>Final sanity check. Yes, this still works. You’re done.</p></li>
</ol>

<p>.
5.7. SUMMARY
This is just the tiniest tip of the iceberg of what regular expressions can do. In other words, even though you’re completely overwhelmed by them now, believe me, you ain’t seen nothing yet.
You should now be familiar with the following techniques:
•   ^ matches the beginning of a string.</p>

<p>•   $ matches the end of a string.</p>

<p>•   \b matches a word boundary.</p>

<p>•   \d matches any numeric digit.</p>

<p>•   \D matches any non-numeric character.</p>

<p>•   x? matches an optional x character (in other words, it matches an x zero or one times).</p>

<p>•   x* matches x zero or more times.</p>

<p>•   x+ matches x one or more times.</p>

<p>•   x{n,m} matches an x character at least n times, but not more than m times.</p>

<p>•   (a|b|c) matches exactly one of a, b or c.</p>

<p>•   (x) in general is a remembered group. You can get the value of what matched by using the groups() method of the object returned by re.search.</p>

<p>Regular expressions are extremely powerful, but they are not the correct solution for every problem. You should learn enough about them to know when they are appropriate, when they will solve your problems, and when they will cause more problems than they solve.
CHAPTER 6. CLOSURES &amp; GENERATORS</p>

<p>.   My spelling is Wobbly. It’s good spelling but it Wobbles, and the letters get in the wrong places. .
—   Winnie-the-Pooh</p>

<p>6.1. DIVING IN
Having grown up the son of a librarian and an English major, I have always been fascinated by languages. Not programming languages. Well yes, programming languages, but also natural languages. Take English. English is a schizophrenic language that borrows words from German, French, Spanish, and Latin (to name a few). Actually, “borrows” is the wrong word; “pillages” is more like it. Or perhaps “assimilates” — like the Borg. Yes, I like that.
We are the Borg. Your linguistic and etymological distinctiveness will be added to our own.
Resistance is futile.</p>

<p>In this chapter, you’re going to learn about plural nouns. Also, functions that return other functions, advanced regular expressions, and generators. But first, let’s talk about how to make plural nouns. (If you haven’t read the
chapter
on
regular
expressions, now would be a good time. This chapter assumes you understand the basics of regular expressions, and it quickly descends into more advanced uses.)
If you grew up in an English-speaking country or learned English in a formal school setting, you’re probably familiar with the basic rules:
•   If a word ends in S, X, or Z, add ES. Bass becomes basses, fax becomes faxes, and waltz becomes waltzes.</p>

<p>•   If a word ends in a noisy H, add ES; if it ends in a silent H, just add S. What’s a noisy H? One that gets combined with other letters to make a sound that you can hear. So coach becomes coaches and rash becomes rashes, because you can hear the CH and SH sounds when you say them. But cheetah becomes cheetahs, because the H is silent.</p>

<p>•   If a word ends in Y that sounds like I, change the Y to IES; if the Y is combined with a vowel to sound like something else, just add S. So vacancy becomes vacancies, but day becomes days.</p>

<p>•   If all else fails, just add S and hope for the best.</p>

<p>(I know, there are a lot of exceptions. Man becomes men and woman becomes women, but human becomes humans. Mouse becomes mice and louse becomes lice, but house becomes houses. Knife becomes knives and wife becomes wives, but lowlife becomes lowlifes. And don’t even get me started on words that are their own plural, like sheep, deer, and haiku.)
Other languages, of course, are completely different.
Let’s design a Python library that automatically pluralizes English nouns. We’ll start with just these four rules, but keep in mind that you’ll inevitably need to add more.</p>

<p>.</p>

<p>6.2. I KNOW, LET’S USE REGULAR EXPRESSIONS!
So you’re looking at words, which, at least in English, means you’re looking at strings of characters. You have rules that say you need to find different combinations of characters, then do different things to them. This sounds like a job for regular expressions!
import re</p>

<p>def plural(noun):
if re.search(&rsquo;[sxz]$&lsquo;, noun): .
return re.sub(&lsquo;$&rsquo;, &lsquo;es&rsquo;, noun) .
elif re.search(&rsquo;[^aeioudgkprt]h$&lsquo;, noun):
return re.sub(&lsquo;$&rsquo;, &lsquo;es&rsquo;, noun)
elif re.search(&rsquo;[^aeiou]y$&lsquo;, noun):
return re.sub(&lsquo;y$&rsquo;, &lsquo;ies&rsquo;, noun)
else:
return noun + &rsquo;s&rsquo;</p>

<ol>
<li><p>This is a regular expression, but it uses a syntax you didn’t see in Regular Expressions. The square brackets mean “match exactly one of these characters.” So [sxz] means “s, or x, or z”, but only one of them. The $ should be familiar; it matches the end of string. Combined, this regular expression tests whether noun ends with s, x, or z.</p></li>

<li><p>This re.sub() function performs regular expression-based string substitutions.</p></li>
</ol>

<p>Let’s look at regular expression substitutions in more detail.
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.search(&rsquo;[abc]&lsquo;, &lsquo;Mark&rsquo;) .
&lt;_sre.SRE_Match object at 0x001C1FA8&gt;
&gt;&gt;&gt; re.sub(&rsquo;[abc]&lsquo;, &lsquo;o&rsquo;, &lsquo;Mark&rsquo;) .
&lsquo;Mork&rsquo;
&gt;&gt;&gt; re.sub(&rsquo;[abc]&lsquo;, &lsquo;o&rsquo;, &lsquo;rock&rsquo;) .
&lsquo;rook&rsquo;
&gt;&gt;&gt; re.sub(&rsquo;[abc]&lsquo;, &lsquo;o&rsquo;, &lsquo;caps&rsquo;) .
&lsquo;oops&rsquo;</p>

<ol>
<li><p>Does the string Mark contain a, b, or c? Yes, it contains a.</p></li>

<li><p>OK, now find a, b, or c, and replace it with o. Mark becomes Mork.</p></li>

<li><p>The same function turns rock into rook.</p></li>

<li><p>You might think this would turn caps into oaps, but it doesn’t. re.sub replaces all of the matches, not just</p></li>
</ol>

<p>the first one. So this regular expression turns caps into oops, because both the c and the a get turned into o.
And now, back to the plural() function…
def plural(noun):
if re.search(&rsquo;[sxz]$&lsquo;, noun):
return re.sub(&lsquo;$&rsquo;, &lsquo;es&rsquo;, noun) .
elif re.search(&rsquo;[^aeioudgkprt]h$&lsquo;, noun): .
return re.sub(&lsquo;$&rsquo;, &lsquo;es&rsquo;, noun)
elif re.search(&rsquo;[^aeiou]y$&lsquo;, noun): .
return re.sub(&lsquo;y$&rsquo;, &lsquo;ies&rsquo;, noun)
else:
return noun + &rsquo;s&rsquo;</p>

<ol>
<li><p>Here, you’re replacing the end of the string (matched by $) with the string es. In other words, adding es to the string. You could accomplish the same thing with string concatenation, for example noun + &lsquo;es&rsquo;, but I chose to use regular expressions for each rule, for reasons that will become clear later in the chapter.</p></li>

<li><p>Look closely, this is another new variation. The ^ as the first character inside the square brackets means something special: negation. [^abc] means “any single character except a, b, or c”. So [^aeioudgkprt] means any character except a, e, i, o, u, d, g, k, p, r, or t. Then that character needs to be followed by h, followed by end of string. You’re looking for words that end in H where the H can be heard.</p></li>

<li><p>Same pattern here: match words that end in Y, where the character before the Y is not a, e, i, o, or u. You’re looking for words that end in Y that sounds like I.</p></li>
</ol>

<p>Let’s look at negation regular expressions in more detail.
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.search(&rsquo;[^aeiou]y$&lsquo;, &lsquo;vacancy&rsquo;) .
&lt;_sre.SRE_Match object at 0x001C1FA8&gt;
&gt;&gt;&gt; re.search(&rsquo;[^aeiou]y$&lsquo;, &lsquo;boy&rsquo;) .
&gt;&gt;&gt;
&gt;&gt;&gt; re.search(&rsquo;[^aeiou]y$&lsquo;, &lsquo;day&rsquo;)
&gt;&gt;&gt;
&gt;&gt;&gt; re.search(&rsquo;[^aeiou]y$&lsquo;, &lsquo;pita&rsquo;) .
&gt;&gt;&gt;</p>

<ol>
<li><p>vacancy matches this regular expression, because it ends in cy, and c is not a, e, i, o, or u.</p></li>

<li><p>boy does not match, because it ends in oy, and you specifically said that the character before the y could not be o. day does not match, because it ends in ay.</p></li>

<li><p>pita does not match, because it does not end in y.</p></li>
</ol>

<blockquote>
<blockquote>
<blockquote>
<p>re.sub(&lsquo;y$&rsquo;, &lsquo;ies&rsquo;, &lsquo;vacancy&rsquo;) .
&lsquo;vacancies&rsquo;
re.sub(&lsquo;y$&rsquo;, &lsquo;ies&rsquo;, &lsquo;agency&rsquo;)
&lsquo;agencies&rsquo;
re.sub(&lsquo;([^aeiou])y$&lsquo;, r&rsquo;\1ies&rsquo;, &lsquo;vacancy&rsquo;) .
&lsquo;vacancies&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>This regular expression turns vacancy into vacancies and agency into agencies, which is what you wanted. Note that it would also turn boy into boies, but that will never happen in the function because you did that re.search first to find out whether you should do this re.sub.</p></li>

<li><p>Just in passing, I want to point out that it is possible to combine these two regular expressions (one to find out if the rule applies, and another to actually apply it) into a single regular expression. Here’s what that would look like. Most of it should look familiar: you’re using a remembered group, which you learned in Case
study:
Parsing
Phone
Numbers. The group is used to remember the character before the letter y. Then in the substitution string, you use a new syntax, \1, which means “hey, that first group you remembered? put it right here.” In this case, you remember the c before the y; when you do the substitution, you substitute c in place of c, and ies in place of y. (If you have more than one remembered group, you can use \2 and \3 and so on.)</p></li>
</ol>

<p>Regular expression substitutions are extremely powerful, and the \1 syntax makes them even more powerful.
But combining the entire operation into one regular expression is also much harder to read, and it doesn’t directly map to the way you first described the pluralizing rules. You originally laid out rules like “if the word ends in S, X, or Z, then add ES”. If you look at this function, you have two lines of code that say “if the word ends in S, X, or Z, then add ES”. It doesn’t get much more direct than that.</p>

<p>.</p>

<p>6.3. A LIST OF FUNCTIONS
Now you’re going to add a level of abstraction. You started by defining a list of rules: if this, do that, otherwise go to the next rule. Let’s temporarily complicate part of the program so you can simplify another part.
import re</p>

<p>def match_sxz(noun):
return re.search(&rsquo;[sxz]$&lsquo;, noun)</p>

<p>def apply_sxz(noun):
return re.sub(&lsquo;$&rsquo;, &lsquo;es&rsquo;, noun)</p>

<p>def match_h(noun):
return re.search(&rsquo;[^aeioudgkprt]h$&lsquo;, noun)</p>

<p>def apply_h(noun):
return re.sub(&lsquo;$&rsquo;, &lsquo;es&rsquo;, noun)</p>

<p>def match_y(noun): . return re.search(&rsquo;[^aeiou]y$&lsquo;, noun)
def apply_y(noun): . return re.sub(&lsquo;y$&rsquo;, &lsquo;ies&rsquo;, noun)
def match_default(noun):
return True</p>

<p>def apply_default(noun):
return noun + &rsquo;s&rsquo;</p>

<p>rules = ((match_sxz, apply_sxz), . (match_h, apply_h), (match_y, apply_y), (match_default, apply_default) )</p>

<p>def plural(noun): for matches_rule, apply_rule in rules: .
if matches_rule(noun):</p>

<p>return apply_rule(noun)</p>

<ol>
<li><p>Now, each match rule is its own function which returns the results of calling the re.search() function.</p></li>

<li><p>Each apply rule is also its own function which calls the re.sub() function to apply the appropriate pluralization rule.</p></li>

<li><p>Instead of having one function (plural()) with multiple rules, you have the rules data structure, which is a sequence of pairs of functions.</p></li>

<li><p>Since the rules have been broken out into a separate data structure, the new plural() function can be reduced to a few lines of code. Using a for loop, you can pull out the match and apply rules two at a time (one match, one apply) from the rules structure. On the first iteration of the for loop, matches_rule will get match_sxz, and apply_rule will get apply_sxz. On the second iteration (assuming you get that far), matches_rule will be assigned match_h, and apply_rule will be assigned apply_h. The function is guaranteed to return something eventually, because the final match rule (match_default) simply returns True, meaning the corresponding apply rule (apply_default) will always be applied.</p></li>
</ol>

<p>The reason this technique works is that everything
in</p>

<p>Python
is
an
object, including functions. The rules data
structure contains functions — not names of functions,
but actual function objects. When they get assigned in
the for loop, then matches_rule and apply_rule are
actual functions that you can call. On the first iteration
of the for loop, this is equivalent to calling
matches_sxz(noun), and if it returns a match, calling
apply_sxz(noun).</p>

<p>If this additional level of abstraction is confusing, try
unrolling the function to see the equivalence. The entire
for loop is equivalent to the following:</p>

<p>def plural(noun):</p>

<p>if match_sxz(noun):
return apply_sxz(noun)</p>

<p>if match_h(noun):
return apply_h(noun)</p>

<p>if match_y(noun):
return apply_y(noun)</p>

<p>if match_default(noun):
return apply_default(noun)</p>

<p>The benefit here is that the plural() function is now simplified. It takes a sequence of rules, defined
elsewhere, and iterates through them in a generic fashion.</p>

<ol>
<li><p>Get a match rule</p></li>

<li><p>Does it match? Then call the apply rule and return the result.</p></li>

<li><p>No match? Go to step 1.</p></li>
</ol>

<p>The rules could be defined anywhere, in any way. The plural() function doesn’t care.
Now, was adding this level of abstraction worth it? Well, not yet. Let’s consider what it would take to add a new rule to the function. In the first example, it would require adding an if statement to the plural() function. In this second example, it would require adding two functions, match_foo() and apply_foo(), and then updating the rules sequence to specify where in the order the new match and apply functions should be called relative to the other rules.
But this is really just a stepping stone to the next section. Let’s move on…
.</p>

<p>6.4. A LIST OF PATTERNS
Defining separate named functions for each match and apply rule isn’t really necessary. You never call them directly; you add them to the rules sequence and call them through there. Furthermore, each function follows one of two patterns. All the match functions call re.search(), and all the apply functions call re.sub(). Let’s factor out the patterns so that defining new rules can be easier.
import re</p>

<p>def build_match_and_apply_functions(pattern, search, replace):
def matches_rule(word): .
return re.search(pattern, word)
def apply_rule(word): .
return re.sub(search, replace, word)
return (matches_rule, apply_rule) .</p>

<ol>
<li><p>build_match_and_apply_functions() is a function that builds other functions dynamically. It takes pattern, search and replace, then defines a matches_rule() function which calls re.search() with the pattern that was passed to the build_match_and_apply_functions() function, and the word that was passed to the matches_rule() function you’re building. Whoa.</p></li>

<li><p>Building the apply function works the same way. The apply function is a function that takes one parameter, and calls re.sub() with the search and replace parameters that were passed to the build_match_and_apply_functions() function, and the word that was passed to the apply_rule() function you’re building. This technique of using the values of outside parameters within a dynamic function is called closures. You’re essentially defining constants within the apply function you’re building: it takes one parameter (word), but it then acts on that plus two other values (search and replace) which were set when you defined the apply function.</p></li>

<li><p>Finally, the build_match_and_apply_functions() function returns a tuple of two values: the two functions you just created. The constants you defined within those functions (pattern within the matches_rule() function, and search and replace within the apply_rule() function) stay with those functions, even after you return from build_match_and_apply_functions(). That’s insanely cool.</p></li>
</ol>

<p>If this is incredibly confusing (and it should be, this is weird stuff), it may become clearer when you see how to use it.
patterns = \    .
(
(&rsquo;[sxz]$&lsquo;, &lsquo;$&rsquo;, &lsquo;es&rsquo;),
(&rsquo;[^aeioudgkprt]h$&lsquo;, &lsquo;$&rsquo;, &lsquo;es&rsquo;),
(&lsquo;(qu|[^aeiou])y$&lsquo;, &lsquo;y$&rsquo;, &lsquo;ies&rsquo;),
(&lsquo;$&rsquo;, &lsquo;$&rsquo;, &rsquo;s&rsquo;) .</p>

<p>)
rules = [build_match_and_apply_functions(pattern, search, replace) .
for (pattern, search, replace) in patterns]</p>

<ol>
<li><p>Our pluralization “rules” are now defined as a tuple of tuples of strings (not functions). The first string in each group is the regular expression pattern that you would use in re.search() to see if this rule matches. The second and third strings in each group are the search and replace expressions you would use in re.sub() to actually apply the rule to turn a noun into its plural.</p></li>

<li><p>There’s a slight change here, in the fallback rule. In the previous example, the match_default() function simply returned True, meaning that if none of the more specific rules matched, the code would simply add an s to the end of the given word. This example does something functionally equivalent. The final regular expression asks whether the word has an end ($ matches the end of a string). Of course, every string has an end, even an empty string, so this expression always matches. Thus, it serves the same purpose as the match_default() function that always returned True: it ensures that if no more specific rule matches, the code adds an s to the end of the given word.</p></li>

<li><p>This line is magic. It takes the sequence of strings in patterns and turns them into a sequence of functions. How? By “mapping” the strings to the build_match_and_apply_functions() function. That is, it takes each triplet of strings and calls the build_match_and_apply_functions() function with those three strings as arguments. The build_match_and_apply_functions() function returns a tuple of two functions. This means that rules ends up being functionally equivalent to the previous example: a list of tuples, where each tuple is a pair of functions. The first function is the match function that calls re.search(), and the second function is the apply function that calls re.sub().</p></li>
</ol>

<p>Rounding out this version of the script is the main entry point, the plural() function.
def plural(noun): for matches_rule, apply_rule in rules: . if matches_rule(noun): return apply_rule(noun)</p>

<ol>
<li>Since the rules list is the same as the previous example (really, it is), it should come as no surprise that the plural() function hasn’t changed at all. It’s completely generic; it takes a list of rule functions and calls them in order. It doesn’t care how the rules are defined. In the previous example, they were defined as separate named functions. Now they are built dynamically by mapping the output of the build_match_and_apply_functions() function onto a list of raw strings. It doesn’t matter; the plural() function still works the same way.</li>
</ol>

<p>.</p>

<p>6.5. A FILE OF PATTERNS
You’ve factored out all the duplicate code and added enough abstractions so that the pluralization rules are defined in a list of strings. The next logical step is to take these strings and put them in a separate file, where they can be maintained separately from the code that uses them.
First, let’s create a text file that contains the rules you want. No fancy data structures, just whitespace-delimited strings in three columns. Let’s call it plural4-rules.txt.
[sxz]$  $  es<br />
[^aeioudgkprt]h$  $  es<br />
[^aeiou]y$  y$  ies<br />
$  $  s</p>

<p>Now let’s see how you can use this rules file.
import re</p>

<p>def build_match_and_apply_functions(pattern, search, replace): .
def matches_rule(word):
return re.search(pattern, word)
def apply_rule(word):
return re.sub(search, replace, word)
return (matches_rule, apply_rule)</p>

<p>rules = []
with open(&lsquo;plural4-rules.txt&rsquo;, encoding=&lsquo;utf-8&rsquo;) as pattern_file: .</p>

<p>for line in pattern_file: . pattern, search, replace = line.split(None, 3) . rules.append(build_match_and_apply_functions( .
pattern, search, replace))</p>

<ol>
<li><p>The build_match_and_apply_functions() function has not changed. You’re still using closures to build two functions dynamically that use variables defined in the outer function.</p></li>

<li><p>The global open() function opens a file and returns a file object. In this case, the file we’re opening contains the pattern strings for pluralizing nouns. The with statement creates what’s called a context: when the with block ends, Python will automatically close the file, even if an exception is raised inside the with block. You’ll learn more about with blocks and file objects in the Files
chapter.</p></li>

<li><p>The for line in <fileobject> idiom reads data from the open file, one line at a time, and assigns the text to the line variable. You’ll learn more about reading from files in the Files
chapter.</p></li>

<li><p>Each line in the file really has three values, but they’re separated by whitespace (tabs or spaces, it makes no difference). To split it out, use the split() string method. The first argument to the split() method is None, which means “split on any whitespace (tabs or spaces, it makes no difference).” The second argument is 3, which means “split on whitespace 3 times, then leave the rest of the line alone.” A line like [sxz]$ $ es will be broken up into the list [&rsquo;[sxz]$&lsquo;, &lsquo;$&rsquo;, &lsquo;es&rsquo;], which means that pattern will get &lsquo;[sxz]$&lsquo;, search will get &lsquo;$&rsquo;, and replace will get &lsquo;es&rsquo;. That’s a lot of power in one little line of code.</p></li>

<li><p>Finally, you pass pattern, search, and replace to the build_match_and_apply_functions() function, which returns a tuple of functions. You append this tuple to the rules list, and rules ends up storing the list of match and apply functions that the plural() function expects.</p></li>
</ol>

<p>The improvement here is that you’ve completely separated the pluralization rules into an external file, so it can be maintained separately from the code that uses it. Code is code, data is data, and life is good.</p>

<p>.</p>

<p>6.6. GENERATORS
Wouldn’t it be grand to have a generic plural() function that parses the rules file? Get rules, check for a match, apply appropriate transformation, go to next rule. That’s all the plural() function has to do, and that’s all the plural() function should do.
def rules(rules_filename):</p>

<p>with open(rules_filename, encoding=&lsquo;utf-8&rsquo;) as pattern_file:</p>

<p>for line in pattern_file:</p>

<p>pattern, search, replace = line.split(None, 3)</p>

<p>yield build_match_and_apply_functions(pattern, search, replace)</p>

<p>def plural(noun, rules_filename=&lsquo;plural5-rules.txt&rsquo;):
for matches_rule, apply_rule in rules(rules_filename):
if matches_rule(noun):
return apply_rule(noun)
raise ValueError(&lsquo;no matching rule for {0}&rsquo;.format(noun))</p>

<p>How the heck does that work? Let’s look at an interactive example first.
&gt;&gt;&gt; def make_counter(x):
&hellip; print(&lsquo;entering make_counter&rsquo;)
&hellip; while True:
&hellip; yield x .
&hellip; print(&lsquo;incrementing x&rsquo;)
&hellip; x = x + 1
&hellip;
&gt;&gt;&gt; counter = make_counter(2) .
&gt;&gt;&gt; counter .
<generator object at 0x001C9C10>
&gt;&gt;&gt; next(counter) .
entering make_counter
2
&gt;&gt;&gt; next(counter) .
incrementing x
3
&gt;&gt;&gt; next(counter) .
incrementing x
4</p>

<ol>
<li><p>The presence of the yield keyword in make_counter means that this is not a normal function. It is a special kind of function which generates values one at a time. You can think of it as a resumable function. Calling it will return a generator that can be used to generate successive values of x.</p></li>

<li><p>To create an instance of the make_counter generator, just call it like any other function. Note that this does not actually execute the function code. You can tell this because the first line of the make_counter() function calls print(), but nothing has been printed yet.</p></li>

<li><p>The make_counter() function returns a generator object.</p></li>

<li><p>The next() function takes a generator object and returns its next value. The first time you call next() with the counter generator, it executes the code in make_counter() up to the first yield statement, then returns the value that was yielded. In this case, that will be 2, because you originally created the generator by calling make_counter(2).</p></li>

<li><p>Repeatedly calling next() with the same generator object resumes exactly where it left off and continues until it hits the next yield statement. All variables, local state, &amp;c. are saved on yield and restored on next(). The next line of code waiting to be executed calls print(), which prints incrementing x. After</p></li>
</ol>

<p>that, the statement x=x+1. Then it loops through the while loop again, and the first thing it hits is the statement yield x, which saves the state of everything and returns the current value of x (now 3).</p>

<ol>
<li>
The second time you call next(counter), you do all the same things again, but this time x is now 4.</li>
</ol>

<p>Since make_counter sets up an infinite loop, you could theoretically do this forever, and it would just keep incrementing x and spitting out values. But let’s look at more productive uses of generators instead.
6.6.1. A FIBONACCI GENERATOR
def fib(max):
a, b = 0, 1 .
while a &lt; max:</p>

<p>yield a .
a, b = b, a + b .</p>

<ol>
<li><p>The Fibonacci sequence is a sequence of numbers where each number is the sum of the two numbers before it. It starts with 0 and 1, goes up slowly at first, then more and more rapidly. To start the sequence, you need two variables: a starts at 0, and b starts at 1.</p></li>

<li><p>a is the current number in the sequence, so yield it.</p></li>

<li><p>b is the next number in the sequence, so assign that to a, but also calculate the next value (a+b) and assign that to b for later use. Note that this happens in parallel; if a is 3 and b is 5, then a, b = b, a + b will set a to 5 (the previous value of b) and b to 8 (the sum of the previous values of a and b).</p></li>
</ol>

<p>So you have a function that spits out successive
Fibonacci numbers. Sure, you could do that with
recursion, but this way is easier to read. Also, it works well with for loops.</p>

<blockquote>
<blockquote>
<blockquote>
<p>from fibonacci import fib</p>

<p>for n in fib(1000): .
&hellip; print(n, end=&rsquo; &lsquo;) .
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
list(fib(1000)) .
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>You can use a generator like fib() in a for loop directly. The for loop will automatically call the next() function to get values from the fib() generator and assign them to the for loop index variable (n).</p></li>

<li><p>Each time through the for loop, n gets a new value from the yield statement in fib(), and all you have to do is print it out. Once fib() runs out of numbers (a becomes bigger than max, which in this case is 1000), then the for loop exits gracefully.</p></li>

<li><p>This is a useful idiom: pass a generator to the list() function, and it will iterate through the entire generator (just like the for loop in the previous example) and return a list of all the values.</p></li>
</ol>

<p>6.6.2. A PLURAL RULE GENERATOR
Let’s go back to plural5.py and see how this version of the plural() function works.
def rules(rules_filename):</p>

<p>with open(rules_filename, encoding=&lsquo;utf-8&rsquo;) as pattern_file:</p>

<p>for line in pattern_file:</p>

<p>pattern, search, replace = line.split(None, 3)  .
yield build_match_and_apply_functions(pattern, search, replace) .
def plural(noun, rules_filename=&lsquo;plural5-rules.txt&rsquo;): for matches_rule, apply_rule in rules(rules_filename): . if matches_rule(noun): return apply_rule(noun) raise ValueError(&lsquo;no matching rule for {0}&rsquo;.format(noun))
1.  No magic here. Remember that the lines of the rules file have three values separated by whitespace, so you use line.split(None, 3) to get the three “columns” and assign them to three local variables.</p>

<ol>
<li><p>And then you yield. What do you yield? Two functions, built dynamically with your old friend, build_match_and_apply_functions(), which is identical to the previous examples. In other words, rules() is a generator that spits out match and apply functions on demand.</p></li>

<li><p>Since rules() is a generator, you can use it directly in a for loop. The first time through the for loop, you will call the rules() function, which will open the pattern file, read the first line, dynamically build a match function and an apply function from the patterns on that line, and yield the dynamically built functions. The second time through the for loop, you will pick up exactly where you left off in rules() (which was in the middle of the for line in pattern_file loop). The first thing it will do is read the next line of the file (which is still open), dynamically build another match and apply function based on the patterns on that line in the file, and yield the two functions.</p></li>
</ol>

<p>What have you gained over stage 4? Startup time. In stage 4, when you imported the plural4 module, it read the entire patterns file and built a list of all the possible rules, before you could even think about calling the plural() function. With generators, you can do everything lazily: you read the first rule and create functions and try them, and if that works you don’t ever read the rest of the file or create any other functions.
What have you lost? Performance! Every time you call the plural() function, the rules() generator starts over from the beginning — which means re-opening the patterns file and reading from the beginning, one line at a time.
What if you could have the best of both worlds: minimal startup cost (don’t execute any code on import), and maximum performance (don’t build the same functions over and over again). Oh, and you still want to keep the rules in a separate file (because code is code and data is data), just as long as you never have to read the same line twice.
To do that, you’ll need to build your own iterator. But before you do that, you need to learn about Python classes.
.</p>

<p>6.7. FURTHER READING
• PEP
255:
Simple
Generators</p>

<p>• Understanding
Python’s
“with”
statement</p>

<p>• Closures
in
Python</p>

<p>• Fibonacci
numbers</p>

<p>• English
Irregular
Plural
Nouns</p>

<p>CHAPTER 7. CLASSES &amp; ITERATORS</p>

<p>. East is East, and West is West, and never the twain shall meet. .
— Rudyard Kipling</p>

<p>7.1. DIVING IN
Iterators are the “secret sauce” of Python 3. They’re everywhere, underlying everything, always just out of sight. Comprehensions
are just a simple form of iterators. Generators are just a simple form of iterators.A function that yields values is a nice, compact way of building an iterator without building an iterator. Let me show you what I mean by that.
Remember the
Fibonacci
generator? Here it is as a built-from-scratch iterator:
class Fib:</p>

<p>&rdquo;&lsquo;iterator that yields numbers in the Fibonacci sequence&rdquo;&rsquo;</p>

<p>def <strong>init</strong>(self, max):
self.max = max</p>

<p>def <strong>iter</strong>(self):
self.a = 0
self.b = 1
return self</p>

<p>def <strong>next</strong>(self):
fib = self.a
if fib &gt; self.max:</p>

<p>raise StopIteration
self.a, self.b = self.b, self.a + self.b
return fib</p>

<p>Let’s take that one line at a time.
class Fib:</p>

<p>class? What’s a class?</p>

<p>.</p>

<p>7.2. DEFINING CLASSES
Python is fully object-oriented: you can define your own classes, inherit from your own or built-in classes, and instantiate the classes you’ve defined.
Defining a class in Python is simple. As with functions, there is no separate interface definition. Just define the class and start coding. A Python class starts with the reserved word class, followed by the class name. Technically, that’s all that’s required, since a class doesn’t need to inherit from any other class.
class PapayaWhip: .
pass .</p>

<ol>
<li><p>The name of this class is PapayaWhip, and it doesn’t inherit from any other class. Class names are usually capitalized, EachWordLikeThis, but this is only a convention, not a requirement.</p></li>

<li><p>You probably guessed this, but everything in a class is indented, just like the code within a function, if statement, for loop, or any other block of code. The first line not indented is outside the class.</p></li>
</ol>

<p>This PapayaWhip class doesn’t define any methods or attributes, but syntactically, there needs to be something in the definition, thus the pass statement. This is a Python reserved word that just means “move along, nothing to see here”. It’s a statement that does nothing, and it’s a good placeholder when you’re stubbing out functions or classes.
. The pass statement in Python is like a empty set of curly braces ({}) in Java or C.
Many classes are inherited from other classes, but this one is not. Many classes define methods, but this one does not. There is nothing that a Python class absolutely must have, other than a name. In particular, C++ programmers may find it odd that Python classes don’t have explicit constructors and destructors. Although it’s not required, Python classes can have something similar to a constructor: the <strong>init</strong>() method.
7.2.1. THE <strong>init</strong>() METHOD
This example shows the initialization of the Fib class using the <strong>init</strong> method.
class Fib:
&ldquo;&lsquo;iterator that yields numbers in the Fibonacci sequence&rdquo;&rsquo; .</p>

<p>def <strong>init</strong>(self, max):    .
1.  Classes can (and should) have docstrings too, just like modules and functions.</p>

<ol>
<li>The <strong>init</strong>() method is called immediately after an instance of the class is created. It would be tempting — but technically incorrect — to call this the “constructor” of the class. It’s tempting, because it looks like a C++ constructor (by convention, the <strong>init</strong>() method is the first method defined for the class), acts like one (it’s the first piece of code executed in a newly created instance of the class), and even sounds like one. Incorrect, because the object has already been constructed by the time the <strong>init</strong>() method is called, and you already have a valid reference to the new instance of the class.</li>
</ol>

<p>The first argument of every class method, including the <strong>init</strong>() method, is always a reference to the current instance of the class. By convention, this argument is named self. This argument fills the role of the reserved word this in C++ or Java, but self is not a reserved word in Python, merely a naming convention. Nonetheless, please don’t call it anything but self; this is a very strong convention.
In the <strong>init</strong>() method, self refers to the newly created object; in other class methods, it refers to the instance whose method was called. Although you need to specify self explicitly when defining the method, you do not specify it when calling the method; Python will add it for you automatically.</p>

<p>.
7.3. INSTANTIATING CLASSES
Instantiating classes in Python is straightforward. To instantiate a class, simply call the class as if it were a function, passing the arguments that the <strong>init</strong>() method requires. The return value will be the newly created object.
&gt;&gt;&gt; import fibonacci2</p>

<blockquote>
<blockquote>
<blockquote>
<p>fib = fibonacci2.Fib(100) .
fib .
<fibonacci2.Fib object at 0x00DB8810>
fib.<strong>class</strong> .
<class 'fibonacci2.Fib'>
fib.<strong>doc</strong> .
&lsquo;iterator that yields numbers in the Fibonacci sequence&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>You are creating an instance of the Fib class (defined in the fibonacci2 module) and assigning the newly created instance to the variable fib. You are passing one parameter, 100, which will end up as the max argument in Fib’s <strong>init</strong>() method.</p></li>

<li><p>fib is now an instance of the Fib class.</p></li>

<li><p>Every class instance has a built-in attribute, <strong>class</strong>, which is the object’s class. Java programmers may be familiar with the Class class, which contains methods like getName() and getSuperclass() to get metadata information about an object. In Python, this kind of metadata is available through attributes, but the idea is the same.</p></li>

<li><p>You can access the instance’s docstring just as with a function or a module. All instances of a class share the same docstring.</p></li>
</ol>

<p>. In Python, simply call a class as if it were a function to create a new instance of the class. There is no explicit new operator like there is in C++ or Java.
.</p>

<p>7.4. INSTANCE VARIABLES
On to the next line:
class Fib:</p>

<p>def <strong>init</strong>(self, max):
self.max = max .</p>

<ol>
<li>What is self.max? It’s an instance variable. It is completely separate from max, which was passed into the <strong>init</strong>() method as an argument. self.max is “global” to the instance. That means that you can access it from other methods.
class Fib:
def <strong>init</strong>(self, max):</li>
</ol>

<p>self.max = max .
.
.
.
def <strong>next</strong>(self):</p>

<p>fib = self.a
if fib &gt; self.max: .</p>

<ol>
<li><p>self.max is defined in the <strong>init</strong>() method…</p></li>

<li><p>…and referenced in the <strong>next</strong>() method.</p></li>
</ol>

<p>Instance variables are specific to one instance of a class. For example, if you create two Fib instances with different maximum values, they will each remember their own values.
&gt;&gt;&gt; import fibonacci2
&gt;&gt;&gt; fib1 = fibonacci2.Fib(100)
&gt;&gt;&gt; fib2 = fibonacci2.Fib(200)
&gt;&gt;&gt; fib1.max
100
&gt;&gt;&gt; fib2.max
200</p>

<p>.</p>

<p>7.5. A FIBONACCI ITERATOR</p>

<p>Now you’re ready to learn how to build an iterator. An iterator is just a class that defines an <strong>iter</strong>() method.
class Fib: .
def <strong>init</strong>(self, max): .
self.max = max</p>

<p>def <strong>iter</strong>(self): .
self.a = 0
self.b = 1
return self</p>

<p>def <strong>next</strong>(self): .
fib = self.a
if fib &gt; self.max:</p>

<p>raise StopIteration .
self.a, self.b = self.b, self.a + self.b
return fib .</p>

<ol>
<li><p>To build an iterator from scratch, Fib needs to be a class, not a function.</p></li>

<li><p>“Calling” Fib(max) is really creating an instance of this class and calling its <strong>init</strong>() method with max. The <strong>init</strong>() method saves the maximum value as an instance variable so other methods can refer to it later.</p></li>

<li><p>The <strong>iter</strong>() method is called whenever someone calls iter(fib). (As you’ll see in a minute, a for loop will call this automatically, but you can also call it yourself manually.) After performing beginning-of-iteration initialization (in this case, resetting self.a and self.b, our two counters), the <strong>iter</strong>() method can return any object that implements a <strong>next</strong>() method. In this case (and in most cases), <strong>iter</strong>() simply returns self, since this class implements its own <strong>next</strong>() method.</p></li>

<li><p>The <strong>next</strong>() method is called whenever someone calls next() on an iterator of an instance of a class.</p></li>
</ol>

<p>That will make more sense in a minute.</p>

<ol>
<li><p>When the <strong>next</strong>() method raises a StopIteration exception, this signals to the caller that the iteration is exhausted. Unlike most exceptions, this is not an error; it’s a normal condition that just means that the iterator has no more values to generate. If the caller is a for loop, it will notice this StopIteration exception and gracefully exit the loop. (In other words, it will swallow the exception.) This little bit of magic is actually the key to using iterators in for loops.</p></li>

<li><p>To spit out the next value, an iterator’s <strong>next</strong>() method simply returns the value. Do not use yield here; that’s a bit of syntactic sugar that only applies when you’re using generators. Here you’re creating your own iterator from scratch; use return instead.</p></li>
</ol>

<p>Thoroughly confused yet? Excellent. Let’s see how to call this iterator:
&gt;&gt;&gt; from fibonacci2 import Fib
&gt;&gt;&gt; for n in Fib(1000):
&hellip; print(n, end=&rsquo; &lsquo;)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</p>

<p>Why, it’s exactly the same! Byte for byte identical to how you called Fibonacci-as-a-generator
(modulo one capital letter). But how?
There’s a bit of magic involved in for loops. Here’s what happens:
•   The for loop calls Fib(1000), as shown. This returns an instance of the Fib class. Call this fib_inst.</p>

<p>•   Secretly, and quite cleverly, the for loop calls iter(fib_inst), which returns an iterator object. Call this fib_iter. In this case, fib_iter == fib_inst, because the <strong>iter</strong>() method returns self, but the for loop doesn’t know (or care) about that.</p>

<p>•   To “loop through” the iterator, the for loop calls next(fib_iter), which calls the <strong>next</strong>() method on the fib_iter object, which does the next-Fibonacci-number calculations and returns a value. The for loop takes this value and assigns it to n, then executes the body of the for loop for that value of n.</p>

<p>•   How does the for loop know when to stop? I’m glad you asked! When next(fib_iter) raises a StopIteration exception, the for loop will swallow the exception and gracefully exit. (Any other exception will pass through and be raised as usual.) And where have you seen a StopIteration exception? In the <strong>next</strong>() method, of course!</p>

<p>.</p>

<p>7.6. A PLURAL RULE ITERATOR
Now it’s time for the finale. Let’s rewrite the plural
rules
generator
as an iterator.</p>

<p>class LazyRules:</p>

<p>rules_filename = &lsquo;plural6-rules.txt&rsquo;</p>

<p>def <strong>init</strong>(self):
self.pattern_file = open(self.rules_filename, encoding=&lsquo;utf-8&rsquo;)
self.cache = []</p>

<p>def <strong>iter</strong>(self):
self.cache_index = 0
return self</p>

<p>def <strong>next</strong>(self):
self.cache_index += 1
if len(self.cache) &gt;= self.cache_index:</p>

<p>return self.cache[self.cache_index - 1]</p>

<p>if self.pattern_file.closed:
raise StopIteration</p>

<p>line = self.pattern_file.readline()</p>

<p>if not line:
self.pattern_file.close()
raise StopIteration</p>

<p>pattern, search, replace = line.split(None, 3)
funcs = build_match_and_apply_functions(</p>

<p>pattern, search, replace)
self.cache.append(funcs)
return funcs</p>

<p>rules = LazyRules()</p>

<p>So this is a class that implements <strong>iter</strong>() and <strong>next</strong>(), so it can be used as an iterator. Then, you instantiate the class and assign it to rules. This happens just once, on import.
Let’s take the class one bite at a time.
class LazyRules:
rules_filename = &lsquo;plural6-rules.txt&rsquo;</p>

<p>def <strong>init</strong>(self): self.pattern_file = open(self.rules_filename, encoding=&lsquo;utf-8&rsquo;) . self.cache = [] .
1.  When we instantiate the LazyRules class, open the pattern file but don’t read anything from it. (That comes later.)</p>

<ol>
<li>After opening the patterns file, initialize the cache. You’ll use this cache later (in the <strong>next</strong>() method) as you read lines from the pattern file.</li>
</ol>

<p>Before we continue, let’s take a closer look at rules_filename. It’s not defined within the <strong>iter</strong>() method. In fact, it’s not defined within any method. It’s defined at the class level. It’s a class variable, and although you can access it just like an instance variable (self.rules_filename), it is shared across all instances of the LazyRules class.
&gt;&gt;&gt; import plural6
&gt;&gt;&gt; r1 = plural6.LazyRules()
&gt;&gt;&gt; r2 = plural6.LazyRules()
&gt;&gt;&gt; r1.rules_filename .
&lsquo;plural6-rules.txt&rsquo;
&gt;&gt;&gt; r2.rules_filename
&lsquo;plural6-rules.txt&rsquo;
&gt;&gt;&gt; r2.rules_filename = &lsquo;r2-override.txt&rsquo; .
&gt;&gt;&gt; r2.rules_filename
&lsquo;r2-override.txt&rsquo;
&gt;&gt;&gt; r1.rules_filename
&lsquo;plural6-rules.txt&rsquo;
&gt;&gt;&gt; r2.<strong>class</strong>.rules_filename .
&lsquo;plural6-rules.txt&rsquo;
&gt;&gt;&gt; r2.<strong>class</strong>.rules_filename = &lsquo;papayawhip.txt&rsquo; .
&gt;&gt;&gt; r1.rules_filename
&lsquo;papayawhip.txt&rsquo;
&gt;&gt;&gt; r2.rules_filename .
&lsquo;r2-overridetxt&rsquo;</p>

<ol>
<li><p>Each instance of the class inherits the rules_filename attribute with the value defined by the class.</p></li>

<li><p>Changing the attribute’s value in one instance does not affect other instances…</p></li>

<li><p>…nor does it change the class attribute. You can access the class attribute (as opposed to an individual instance’s attribute) by using the special <strong>class</strong> attribute to access the class itself.</p></li>

<li><p>If you change the class attribute, all instances that are still inheriting that value (like r1 here) will be affected.</p></li>

<li><p>Instances that have overridden that attribute (like r2 here) will not be affected.</p></li>
</ol>

<p>And now back to our show.
def <strong>iter</strong>(self): .
self.cache_index = 0
return self .</p>

<ol>
<li>The <strong>iter</strong>() method will be called every time someone — say, a for loop — calls iter(rules).</li>
<li>The one thing that every <strong>iter</strong>() method must do is return an iterator. In this case, it returns self, which signals that this class defines a <strong>next</strong>() method which will take care of returning values throughout the iteration.
def <strong>next</strong>(self): .
.
.
.
pattern, search, replace = line.split(None, 3)
funcs = build_match_and_apply_functions( .</li>
</ol>

<p>pattern, search, replace) self.cache.append(funcs) . return funcs
1.  The <strong>next</strong>() method gets called whenever someone — say, a for loop — calls next(rules). This method will only make sense if we start at the end and work backwards. So let’s do that.</p>

<ol>
<li><p>The last part of this function should look familiar, at least. The build_match_and_apply_functions() function hasn’t changed; it’s the same as it ever was.</p></li>

<li><p>The only difference is that, before returning the match and apply functions (which are stored in the tuple funcs), we’re going to save them in self.cache.</p></li>
</ol>

<p>Moving backwards…
def <strong>next</strong>(self):
.
.
.
line = self.pattern_file.readline() .
if not line: .</p>

<p>self.pattern_file.close()
raise StopIteration .
.
.
.</p>

<ol>
<li><p>A bit of advanced file trickery here. The readline() method (note: singular, not the plural readlines()) reads exactly one line from an open file. Specifically, the next line. (File objects are iterators too! It’s iterators all the way down…)</p></li>

<li><p>If there was a line for readline() to read, line will not be an empty string. Even if the file contained a blank line, line would end up as the one-character string &lsquo;\n&rsquo; (a carriage return). If line is really an empty string, that means there are no more lines to read from the file.</p></li>

<li><p>When we reach the end of the file, we should close the file and raise the magic StopIteration exception. Remember, we got to this point because we needed a match and apply function for the next rule. The next rule comes from the next line of the file… but there is no next line! Therefore, we have no value to return. The iteration is over. (. The party’s over… .)</p></li>
</ol>

<p>Moving backwards all the way to the start of the <strong>next</strong>() method…
def <strong>next</strong>(self):
self.cache_index += 1
if len(self.cache) &gt;= self.cache_index:</p>

<p>return self.cache[self.cache_index - 1] .
if self.pattern_file.closed:
raise StopIteration .
.
.
.</p>

<ol>
<li><p>self.cache will be a list of the functions we need to match and apply individual rules. (At least that should sound familiar!) self.cache_index keeps track of which cached item we should return next. If we haven’t exhausted the cache yet (i.e. if the length of self.cache is greater than self.cache_index), then we have a cache hit! Hooray! We can return the match and apply functions from the cache instead of building them from scratch.</p></li>

<li><p>On the other hand, if we don’t get a hit from the cache, and the file object has been closed (which could happen, further down the method, as you saw in the previous code snippet), then there’s nothing more we can do. If the file is closed, it means we’ve exhausted it — we’ve already read through every line from the pattern file, and we’ve already built and cached the match and apply functions for each pattern. The file is exhausted; the cache is exhausted; I’m exhausted. Wait, what? Hang in there, we’re almost done.</p></li>
</ol>

<p>Putting it all together, here’s what happens when:
•   When the module is imported, it creates a single instance of the LazyRules class, called rules, which opens the pattern file but does not read from it.</p>

<p>•   When asked for the first match and apply function, it checks its cache but finds the cache is empty. So it reads a single line from the pattern file, builds the match and apply functions from those patterns, and caches them.</p>

<p>•   Let’s say, for the sake of argument, that the very first rule matched. If so, no further match and apply
functions are built, and no further lines are read from the pattern file.</p>

<p>•   Furthermore, for the sake of argument, suppose that the caller calls the plural() function again to pluralize a different word. The for loop in the plural() function will call iter(rules), which will reset the cache index but will not reset the open file object.</p>

<p>•   The first time through, the for loop will ask for a value from rules, which will invoke its <strong>next</strong>() method. This time, however, the cache is primed with a single pair of match and apply functions, corresponding to the patterns in the first line of the pattern file. Since they were built and cached in the course of pluralizing the previous word, they’re retrieved from the cache. The cache index increments, and the open file is never touched.</p>

<p>•   Let’s say, for the sake of argument, that the first rule does not match this time around. So the for loop comes around again and asks for another value from rules. This invokes the <strong>next</strong>() method a second time. This time, the cache is exhausted — it only contained one item, and we’re asking for a second — so the <strong>next</strong>() method continues. It reads another line from the open file, builds match and apply functions out of the patterns, and caches them.</p>

<p>•   This read-build-and-cache process will continue as long as the rules being read from the pattern file don’t match the word we’re trying to pluralize. If we do find a matching rule before the end of the file, we simply use it and stop, with the file still open. The file pointer will stay wherever we stopped reading, waiting for the next readline() command. In the meantime, the cache now has more items in it, and if we start all over again trying to pluralize a new word, each of those items in the cache will be tried before reading the next line from the pattern file.</p>

<p>We have achieved pluralization nirvana.
1.  Minimal startup cost. The only thing that happens on import is instantiating a single class and opening a file (but not reading from it).</p>

<ol>
<li><p>Maximum performance. The previous example would read through the file and build functions dynamically every time you wanted to pluralize a word. This version will cache functions as soon as they’re built, and in the worst case, it will only read through the pattern file once, no matter how many words you pluralize.</p></li>

<li><p>Separation of code and data. All the patterns are stored in a separate file. Code is code, and data is data, and never the twain shall meet.</p></li>
</ol>

<p>. Is this really nirvana? Well, yes and no. Here’s something to consider with the LazyRules example: the pattern file is opened (during <strong>init</strong>()), and it remains open until the final rule is reached. Python will eventually close the file when it exits, or after the last instantiation of the LazyRules class is destroyed, but still, that could be a long time. If this class is part of a long-running Python process, the Python interpreter may never exit, and the LazyRules object may never get destroyed.
There are ways around this. Instead of opening the file during <strong>init</strong>() and leaving it open while you read rules one line at a time, you could open the file, read all the rules, and immediately close the file. Or you could open the file, read one rule, save the file position with the tell() method, close the file, and later re-open it and use the seek() method
to continue reading where you left off. Or you could not worry about it and just leave the file open, like this example code does. Programming is design, and design is all about trade-offs and constraints. Leaving a file open too long might be a problem; making your code more complicated might be a problem. Which one is the bigger problem depends on your development team, your application, and your runtime environment.</p>

<p>.
7.7. FURTHER READING
•   Iterator
types</p>

<p>•   PEP
234:
Iterators</p>

<p>• PEP
255:
Simple
Generators</p>

<p>• Generator
Tricks
for
Systems
Programmers</p>

<p>CHAPTER 8. ADVANCED ITERATORS</p>

<p>. Great fleas have little fleas upon their backs to bite ’em, And little fleas have lesser fleas, and so ad infinitum. .
— Augustus De Morgan</p>

<p>8.1. DIVING IN
Just as regular
expressions
put strings
on steroids, the itertools module puts iterators
on steroids. But first, I want to show you a classic puzzle.
HAWAII + IDAHO + IOWA + OHIO == STATES
510199 + 98153 + 9301 + 3593 == 621246</p>

<p>H = 5
A = 1
W = 0
I = 9
D = 8
O = 3
S = 6
T = 2
E = 4</p>

<p>Puzzles like this are called cryptarithms or alphametics. The letters spell out actual words, but if you replace each letter with a digit from 0–9, it also “spells” an arithmetic equation. The trick is to figure out which letter maps to each digit. All the occurrences of each letter must map to the same digit, no digit can be repeated, and no “word” can start with the digit 0.
In this chapter, we’ll dive into an incredible Python program originally written by Raymond Hettinger. This program solves alphametic puzzles in just 14 lines of code.</p>

<p>import re</p>

<p>import itertools</p>

<p>def solve(puzzle):
words = re.findall(&rsquo;[A-Z]+&lsquo;, puzzle.upper())
unique_characters = set(&ldquo;.join(words))
assert len(unique_characters) &lt;= 10, &lsquo;Too many letters&rsquo;
first_letters = {word[0] for word in words}
n = len(first_letters)
sorted_characters = &ldquo;.join(first_letters) + </p>

<p>&rdquo;.join(unique_characters - first_letters)
characters = tuple(ord&copy; for c in sorted_characters)
digits = tuple(ord&copy; for c in &lsquo;0123456789&rsquo;)
zero = digits[0]
for guess in itertools.permutations(digits, len(characters)):</p>

<p>if zero not in guess[:n]:
equation = puzzle.translate(dict(zip(characters, guess)))
if eval(equation):</p>

<p>return equation</p>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&lsquo;:
import sys
for puzzle in sys.argv[1:]:</p>

<p>print(puzzle)
solution = solve(puzzle)
if solution:</p>

<p>print(solution)</p>

<p>You can run the program from the command line. On Linux, it would look like this. (These may take some time, depending on the speed of your computer, and there is no progress bar. Just be patient!)
you@localhost:~/diveintopython3/examples$ python3 alphametics.py &ldquo;HAWAII + IDAHO + IOWA + OHIO == STATES&rdquo;
HAWAII + IDAHO + IOWA + OHIO = STATES
510199 + 98153 + 9301 + 3593 == 621246
you@localhost:~/diveintopython3/examples$ python3 alphametics.py &ldquo;I + LOVE + YOU == DORA&rdquo;
I + LOVE + YOU == DORA
1 + 2784 + 975 == 3760
you@localhost:~/diveintopython3/examples$ python3 alphametics.py &ldquo;SEND + MORE == MONEY&rdquo;
SEND + MORE == MONEY
9567 + 1085 == 10652</p>

<p>.</p>

<p>8.2. FINDING ALL OCCURRENCES OF A PATTERN
The first thing this alphametics solver does is find all the letters (A–Z) in the puzzle.
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall(&rsquo;[0-9]+&lsquo;, &lsquo;16 2-by-4s in rows of 8&rsquo;) .
[&lsquo;16&rsquo;, &lsquo;2&rsquo;, &lsquo;4&rsquo;, &lsquo;8&rsquo;]
&gt;&gt;&gt; re.findall(&rsquo;[A-Z]+&lsquo;, &lsquo;SEND + MORE == MONEY&rsquo;) .
[&lsquo;SEND&rsquo;, &lsquo;MORE&rsquo;, &lsquo;MONEY&rsquo;]</p>

<ol>
<li><p>The re module is Python’s implementation of regular
expressions. It has a nifty function called findall() which takes a regular expression pattern and a string, and finds all occurrences of the pattern within the string. In this case, the pattern matches sequences of numbers. The findall() function returns a list of all the substrings that matched the pattern.</p></li>

<li><p>Here the regular expression pattern matches sequences of letters. Again, the return value is a list, and each item in the list is a string that matched the regular expression pattern.</p></li>
</ol>

<p>Here’s another example that will stretch your brain a little.
&gt;&gt;&gt; re.findall(&rsquo; s.*? s&rsquo;, &ldquo;The sixth sick sheikh&rsquo;s sixth sheep&rsquo;s sick.&rdquo;)</p>

<p>[&rsquo; sixth s&rsquo;, &ldquo; sheikh&rsquo;s s&rdquo;, &ldquo; sheep&rsquo;s s&rdquo;]</p>

<p>Surprised? The regular expression looks for a space, an
s, and then the shortest possible series of any character
(.*?), then a space, then another s. Well, looking at
that input string, I see five matches:</p>

<ol>
<li>The sixth
s
ick sheikh&rsquo;s sixth sheep&rsquo;s sick.</li>
<li>The sixth sick
s
heikh&rsquo;s sixth sheep&rsquo;s sick.</li>
<li>The sixth sick sheikh&rsquo;s
s
ixth sheep&rsquo;s sick.</li>
<li>The sixth sick sheikh&rsquo;s sixth
s
heep&rsquo;s sick.</li>
<li>The sixth sick sheikh&rsquo;s sixth sheep&rsquo;s
s
ick.</li>
</ol>

<p>But the re.findall() function only returned three
matches. Specifically, it returned the first, the third, and
the fifth. Why is that? Because it doesn’t return
overlapping matches. The first match overlaps with the
second, so the first is returned and the second is
skipped. Then the third overlaps with the fourth, so the
third is returned and the fourth is skipped. Finally, the
fifth is returned. Three matches, not five.</p>

<p>This has nothing to do with the alphametics solver; I just thought it was interesting.
.</p>

<p>8.3. FINDING THE UNIQUE ITEMS IN A SEQUENCE
Sets
make it trivial to find the unique items in a sequence.
&gt;&gt;&gt; a_list = [&lsquo;The&rsquo;, &lsquo;sixth&rsquo;, &lsquo;sick&rsquo;, &ldquo;sheik&rsquo;s&rdquo;, &lsquo;sixth&rsquo;, &ldquo;sheep&rsquo;s&rdquo;, &lsquo;sick&rsquo;]
&gt;&gt;&gt; set(a_list) .
{&lsquo;sixth&rsquo;, &lsquo;The&rsquo;, &ldquo;sheep&rsquo;s&rdquo;, &lsquo;sick&rsquo;, &ldquo;sheik&rsquo;s&rdquo;}
&gt;&gt;&gt; a_string = &lsquo;EAST IS EAST&rsquo;
&gt;&gt;&gt; set(a_string) .
{&lsquo;A&rsquo;, &lsquo; &lsquo;, &lsquo;E&rsquo;, &lsquo;I&rsquo;, &rsquo;S&rsquo;, &rsquo;T&rsquo;}
&gt;&gt;&gt; words = [&lsquo;SEND&rsquo;, &lsquo;MORE&rsquo;, &lsquo;MONEY&rsquo;]
&gt;&gt;&gt; &ldquo;.join(words) .
&lsquo;SENDMOREMONEY&rsquo;
&gt;&gt;&gt; set(&ldquo;.join(words)) .
{&lsquo;E&rsquo;, &rsquo;D&rsquo;, &rsquo;M&rsquo;, &lsquo;O&rsquo;, &lsquo;N&rsquo;, &rsquo;S&rsquo;, &lsquo;R&rsquo;, &lsquo;Y&rsquo;}</p>

<ol>
<li><p>Given a list of several strings, the set() function will return a set of unique strings from the list. This makes sense if you think of it like a for loop. Take the first item from the list, put it in the set. Second. Third. Fourth. Fifth — wait, that’s in the set already, so it only gets listed once, because Python sets don’t allow duplicates. Sixth. Seventh — again, a duplicate, so it only gets listed once. The end result? All the unique items in the original list, without any duplicates. The original list doesn’t even need to be sorted first.</p></li>

<li><p>The same technique works with strings, since a string is just a sequence of characters.</p></li>

<li><p>Given a list of strings, &ldquo;.join(a_list) concatenates all the strings together into one.</p></li>

<li><p>So, given a list of strings, this line of code returns all the unique characters across all the strings, with no duplicates.</p></li>
</ol>

<p>The alphametics solver uses this technique to build a set of all the unique characters in the puzzle.
unique_characters = set(&ldquo;.join(words))</p>

<p>This list is later used to assign digits to characters as the solver iterates through the possible solutions.
.</p>

<p>8.4. MAKING ASSERTIONS
Like many programming languages, Python has an assert statement. Here’s how it works.
&gt;&gt;&gt; assert 1 + 1 == 2 .
&gt;&gt;&gt; assert 1 + 1 == 3 .</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
AssertionError</p>

<blockquote>
<blockquote>
<blockquote>
<p>assert 2 + 2 == 5, &ldquo;Only for very large values of 2&rdquo; .
Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
AssertionError: Only for very large values of 2</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>The assert statement is followed by any valid Python expression. In this case, the expression 1 + 1 == 2 evaluates to True, so the assert statement does nothing.</p></li>

<li><p>However, if the Python expression evaluates to False, the assert statement will raise an AssertionError.</p></li>

<li><p>You can also include a human-readable message that is printed if the AssertionError is raised.</p></li>
</ol>

<p>Therefore, this line of code:
assert len(unique_characters) &lt;= 10, &lsquo;Too many letters&rsquo;</p>

<p>…is equivalent to this:
if len(unique_characters) &gt; 10:
raise AssertionError(&lsquo;Too many letters&rsquo;)</p>

<p>The alphametics solver uses this exact assert statement to bail out early if the puzzle contains more than ten unique letters. Since each letter is assigned a unique digit, and there are only ten digits, a puzzle with more than ten unique letters can not possibly have a solution.</p>

<p>.</p>

<p>8.5. GENERATOR EXPRESSIONS</p>

<p>A generator expression is like a generator
function
without the function.
&gt;&gt;&gt; unique_characters = {&lsquo;E&rsquo;, &rsquo;D&rsquo;, &rsquo;M&rsquo;, &lsquo;O&rsquo;, &lsquo;N&rsquo;, &rsquo;S&rsquo;, &lsquo;R&rsquo;, &lsquo;Y&rsquo;}
&gt;&gt;&gt; gen = (ord&copy; for c in unique_characters) .
&gt;&gt;&gt; gen .
<generator object <genexpr> at 0x00BADC10&gt;
&gt;&gt;&gt; next(gen) .
69
&gt;&gt;&gt; next(gen)
68
&gt;&gt;&gt; tuple(ord&copy; for c in unique_characters) .
(69, 68, 77, 79, 78, 83, 82, 89)</p>

<ol>
<li><p>A generator expression is like an anonymous function that yields values. The expression itself looks like a list
comprehension, but it’s wrapped in parentheses instead of square brackets.</p></li>

<li><p>The generator expression returns… an iterator.</p></li>

<li><p>Calling next(gen) returns the next value from the iterator.</p></li>

<li><p>If you like, you can iterate through all the possible values and return a tuple, list, or set, by passing the generator expression to tuple(), list(), or set(). In these cases, you don’t need an extra set of parentheses — just pass the “bare” expression ord&copy; for c in unique_characters to the tuple() function, and Python figures out that it’s a generator expression.</p></li>
</ol>

<p>. Using a generator expression instead of a list comprehension can save both CPU and RAM. If you’re building an list just to throw it away (e.g. passing it to tuple() or set()), use a generator expression instead!
Here’s another way to accomplish the same thing, using a generator
function:
def ord_map(a_string):
for c in a_string:
yield ord&copy;</p>

<p>gen = ord_map(unique_characters)</p>

<p>The generator expression is more compact but functionally equivalent.</p>

<p>.</p>

<p>8.6. CALCULATING PERMUTATIONS… THE LAZY WAY!
First of all, what the heck are permutations? Permutations are a mathematical concept. (There are actually several definitions, depending on what kind of math you’re doing. Here I’m talking about combinatorics, but if that doesn’t mean anything to you, don’t worry about it. As always, Wikipedia
is
your
friend.)
The idea is that you take a list of things (could be numbers, could be letters, could be dancing bears) and find all the possible ways to split them up into smaller lists. All the smaller lists have the same size, which can be as small as 1 and as large as the total number of items. Oh, and nothing can be repeated. Mathematicians say things like “let’s find the permutations of 3 different items taken 2 at a time,” which means you have a sequence of 3 items and you want to find all the possible ordered pairs.
&gt;&gt;&gt; import itertools .
&gt;&gt;&gt; perms = itertools.permutations([1, 2, 3], 2) .
&gt;&gt;&gt; next(perms) .
(1, 2)
&gt;&gt;&gt; next(perms)
(1, 3)
&gt;&gt;&gt; next(perms)
(2, 1) .
&gt;&gt;&gt; next(perms)
(2, 3)
&gt;&gt;&gt; next(perms)
(3, 1)
&gt;&gt;&gt; next(perms)
(3, 2)
&gt;&gt;&gt; next(perms) .</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
StopIteration</p>

<ol>
<li><p>The itertools module has all kinds of fun stuff in it, including a permutations() function that does all the hard work of finding permutations.</p></li>

<li><p>The permutations() function takes a sequence (here a list of three integers) and a number, which is the number of items you want in each smaller group. The function returns an iterator, which you can use in a for loop or any old place that iterates. Here I’ll step through the iterator manually to show all the values.</p></li>

<li><p>The first permutation of [1, 2, 3] taken 2 at a time is (1, 2).</p></li>

<li><p>Note that permutations are ordered: (2, 1) is different than (1, 2).</p></li>

<li><p>That’s it! Those are all the permutations of [1, 2, 3] taken 2 at a time. Pairs like (1, 1) and (2, 2) never show up, because they contain repeats so they aren’t valid permutations. When there are no more permutations, the iterator raises a StopIteration exception.</p></li>
</ol>

<p>The permutations() function doesn’t have to take a
list. It can take any sequence — even a string.</p>

<blockquote>
<blockquote>
<blockquote>
<p>import itertools</p>

<p>perms = itertools.permutations(&lsquo;ABC&rsquo;, 3) .
next(perms)
(&lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;) .
next(perms)
(&lsquo;A&rsquo;, &lsquo;C&rsquo;, &lsquo;B&rsquo;)
next(perms)
(&lsquo;B&rsquo;, &lsquo;A&rsquo;, &lsquo;C&rsquo;)
next(perms)
(&lsquo;B&rsquo;, &lsquo;C&rsquo;, &lsquo;A&rsquo;)
next(perms)
(&lsquo;C&rsquo;, &lsquo;A&rsquo;, &lsquo;B&rsquo;)
next(perms)
(&lsquo;C&rsquo;, &lsquo;B&rsquo;, &lsquo;A&rsquo;)
next(perms)</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
StopIteration</p>

<blockquote>
<blockquote>
<blockquote>
<p>list(itertools.permutations(&lsquo;ABC&rsquo;, 3)) .
[(&lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;), (&lsquo;A&rsquo;, &lsquo;C&rsquo;, &lsquo;B&rsquo;),
(&lsquo;B&rsquo;, &lsquo;A&rsquo;, &lsquo;C&rsquo;), (&lsquo;B&rsquo;, &lsquo;C&rsquo;, &lsquo;A&rsquo;),
(&lsquo;C&rsquo;, &lsquo;A&rsquo;, &lsquo;B&rsquo;), (&lsquo;C&rsquo;, &lsquo;B&rsquo;, &lsquo;A&rsquo;)]</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>A string is just a sequence of characters. For the purposes of finding permutations, the string &lsquo;ABC&rsquo; is equivalent to the list [&lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;].</p></li>

<li><p>The first permutation of the 3 items [&lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;], taken 3 at a time, is (&lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;). There are five other permutations — the same three characters in every conceivable order.</p></li>

<li><p>Since the permutations() function always returns an iterator, an easy way to debug permutations is to pass that iterator to the built-in list() function to see all the permutations immediately.</p></li>
</ol>

<p>.</p>

<p>8.7. OTHER FUN STUFF IN THE itertools MODULE</p>

<blockquote>
<blockquote>
<blockquote>
<p>import itertools
list(itertools.product(&lsquo;ABC&rsquo;, &lsquo;123&rsquo;)) .
[(&lsquo;A&rsquo;, &lsquo;1&rsquo;), (&lsquo;A&rsquo;, &lsquo;2&rsquo;), (&lsquo;A&rsquo;, &lsquo;3&rsquo;),</p>
</blockquote>
</blockquote>
</blockquote>

<p>(&lsquo;B&rsquo;, &lsquo;1&rsquo;), (&lsquo;B&rsquo;, &lsquo;2&rsquo;), (&lsquo;B&rsquo;, &lsquo;3&rsquo;),</p>

<p>(&lsquo;C&rsquo;, &lsquo;1&rsquo;), (&lsquo;C&rsquo;, &lsquo;2&rsquo;), (&lsquo;C&rsquo;, &lsquo;3&rsquo;)]
&gt;&gt;&gt; list(itertools.combinations(&lsquo;ABC&rsquo;, 2)) .
[(&lsquo;A&rsquo;, &lsquo;B&rsquo;), (&lsquo;A&rsquo;, &lsquo;C&rsquo;), (&lsquo;B&rsquo;, &lsquo;C&rsquo;)]</p>

<ol>
<li><p>The itertools.product() function returns an iterator containing the Cartesian product of two sequences.</p></li>

<li><p>The itertools.combinations() function returns an iterator containing all the possible combinations of the given sequence of the given length. This is like the itertools.permutations() function, except combinations don’t include items that are duplicates of other items in a different order. So itertools.permutations(&lsquo;ABC&rsquo;, 2) will return both (&lsquo;A&rsquo;, &lsquo;B&rsquo;) and (&lsquo;B&rsquo;, &lsquo;A&rsquo;) (among others), but itertools.combinations(&lsquo;ABC&rsquo;, 2) will not return (&lsquo;B&rsquo;, &lsquo;A&rsquo;) because it is a duplicate of (&lsquo;A&rsquo;, &lsquo;B&rsquo;) in a different order.</p></li>
</ol>

<blockquote>
<blockquote>
<blockquote>
<p>names = list(open(&lsquo;examples/favorite-people.txt&rsquo;, encoding=&lsquo;utf-8&rsquo;)) .
names
[&lsquo;Dora\n&rsquo;, &lsquo;Ethan\n&rsquo;, &lsquo;Wesley\n&rsquo;, &lsquo;John\n&rsquo;, &lsquo;Anne\n&rsquo;,
&lsquo;Mike\n&rsquo;, &lsquo;Chris\n&rsquo;, &lsquo;Sarah\n&rsquo;, &lsquo;Alex\n&rsquo;, &lsquo;Lizzie\n&rsquo;]
names = [name.rstrip() for name in names] .
names
[&lsquo;Dora&rsquo;, &lsquo;Ethan&rsquo;, &lsquo;Wesley&rsquo;, &lsquo;John&rsquo;, &lsquo;Anne&rsquo;,
&lsquo;Mike&rsquo;, &lsquo;Chris&rsquo;, &lsquo;Sarah&rsquo;, &lsquo;Alex&rsquo;, &lsquo;Lizzie&rsquo;]
names = sorted(names) .
names
[&lsquo;Alex&rsquo;, &lsquo;Anne&rsquo;, &lsquo;Chris&rsquo;, &lsquo;Dora&rsquo;, &lsquo;Ethan&rsquo;,
&lsquo;John&rsquo;, &lsquo;Lizzie&rsquo;, &lsquo;Mike&rsquo;, &lsquo;Sarah&rsquo;, &lsquo;Wesley&rsquo;]
names = sorted(names, key=len) .
names
[&lsquo;Alex&rsquo;, &lsquo;Anne&rsquo;, &lsquo;Dora&rsquo;, &lsquo;John&rsquo;, &lsquo;Mike&rsquo;,
&lsquo;Chris&rsquo;, &lsquo;Ethan&rsquo;, &lsquo;Sarah&rsquo;, &lsquo;Lizzie&rsquo;, &lsquo;Wesley&rsquo;]</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>This idiom returns a list of the lines in a text file.</p></li>

<li><p>Unfortunately (for this example), the list(open(filename)) idiom also includes the carriage returns at the end of each line. This list comprehension uses the rstrip() string method to strip trailing whitespace from each line. (Strings also have an lstrip() method to strip leading whitespace, and a strip() method which strips both.)</p></li>

<li><p>The sorted() function takes a list and returns it sorted. By default, it sorts alphabetically.</p></li>

<li><p>But the sorted() function can also take a function as the key parameter, and it sorts by that key. In this case, the sort function is len(), so it sorts by len(each item). Shorter names come first, then longer, then longest.</p></li>
</ol>

<p>What does this have to do with the itertools module? I’m glad you asked.
…continuing from the previous interactive shell…</p>

<blockquote>
<blockquote>
<blockquote>
<p>import itertools
groups = itertools.groupby(names, len) .
groups
<itertools.groupby object at 0x00BB20C0>
list(groups)
[(4, <itertools._grouper object at 0x00BA8BF0>),</p>
</blockquote>
</blockquote>
</blockquote>

<p>(5, <itertools._grouper object at 0x00BB4050>),</p>

<p>(6, <itertools._grouper object at 0x00BB4030>)]
&gt;&gt;&gt; groups = itertools.groupby(names, len) .
&gt;&gt;&gt; for name_length, name_iter in groups: .
&hellip; print(&lsquo;Names with {0:d} letters:&lsquo;.format(name_length))
&hellip; for name in name_iter:
&hellip; print(name)
&hellip;</p>

<p>Names with 4 letters:
Alex
Anne
Dora
John
Mike
Names with 5 letters:
Chris
Ethan
Sarah
Names with 6 letters:
Lizzie
Wesley</p>

<ol>
<li><p>The itertools.groupby() function takes a sequence and a key function, and returns an iterator that generates pairs. Each pair contains the result of key_function(each item) and another iterator containing all the items that shared that key result.</p></li>

<li><p>Calling the list() function “exhausted” the iterator, i.e. you’ve already generated every item in the iterator to make the list. There’s no “reset” button on an iterator; you can’t just start over once you’ve exhausted</p></li>
</ol>

<p>it. If you want to loop through it again (say, in the upcoming for loop), you need to call
itertools.groupby() again to create a new iterator.</p>

<ol>
<li>In this example, given a list of names already sorted by length, itertools.groupby(names, len) will put all the 4-letter names in one iterator, all the 5-letter names in another iterator, and so on. The groupby() function is completely generic; it could group strings by first letter, numbers by their number of factors, or any other key function you can think of.</li>
</ol>

<p>. The itertools.groupby() function only works if the input sequence is already sorted by the grouping function. In the example above, you grouped a list of names by the len() function. That only worked because the input list was already sorted by length.
Are you watching closely?
&gt;&gt;&gt; list(range(0, 3))
[0, 1, 2]
&gt;&gt;&gt; list(range(10, 13))
[10, 11, 12]
&gt;&gt;&gt; list(itertools.chain(range(0, 3), range(10, 13))) .
[0, 1, 2, 10, 11, 12]
&gt;&gt;&gt; list(zip(range(0, 3), range(10, 13))) .
[(0, 10), (1, 11), (2, 12)]
&gt;&gt;&gt; list(zip(range(0, 3), range(10, 14))) .
[(0, 10), (1, 11), (2, 12)]
&gt;&gt;&gt; list(itertools.zip_longest(range(0, 3), range(10, 14))) .
[(0, 10), (1, 11), (2, 12), (None, 13)]</p>

<ol>
<li><p>The itertools.chain() function takes two iterators and returns an iterator that contains all the items from the first iterator, followed by all the items from the second iterator. (Actually, it can take any number of iterators, and it chains them all in the order they were passed to the function.)</p></li>

<li><p>The zip() function does something prosaic that turns out to be extremely useful: it takes any number of sequences and returns an iterator which returns tuples of the first items of each sequence, then the second items of each, then the third, and so on.</p></li>

<li><p>The zip() function stops at the end of the shortest sequence. range(10, 14) has 4 items (10, 11, 12, and 13), but range(0, 3) only has 3, so the zip() function returns an iterator of 3 items.</p></li>

<li><p>On the other hand, the itertools.zip_longest() function stops at the end of the longest sequence, inserting None values for items past the end of the shorter sequences.</p></li>
</ol>

<p>OK, that was all very interesting, but how does it relate to the alphametics solver? Here’s how:
&gt;&gt;&gt; characters = (&rsquo;S&rsquo;, &rsquo;M&rsquo;, &lsquo;E&rsquo;, &rsquo;D&rsquo;, &lsquo;O&rsquo;, &lsquo;N&rsquo;, &lsquo;R&rsquo;, &lsquo;Y&rsquo;)
&gt;&gt;&gt; guess = (&lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;0&rsquo;, &lsquo;3&rsquo;, &lsquo;4&rsquo;, &lsquo;5&rsquo;, &lsquo;6&rsquo;, &lsquo;7&rsquo;)
&gt;&gt;&gt; tuple(zip(characters, guess)) .
((&rsquo;S&rsquo;, &lsquo;1&rsquo;), (&rsquo;M&rsquo;, &lsquo;2&rsquo;), (&lsquo;E&rsquo;, &lsquo;0&rsquo;), (&rsquo;D&rsquo;, &lsquo;3&rsquo;),</p>

<p>(&lsquo;O&rsquo;, &lsquo;4&rsquo;), (&lsquo;N&rsquo;, &lsquo;5&rsquo;), (&lsquo;R&rsquo;, &lsquo;6&rsquo;), (&lsquo;Y&rsquo;, &lsquo;7&rsquo;))
&gt;&gt;&gt; dict(zip(characters, guess)) .
{&lsquo;E&rsquo;: &lsquo;0&rsquo;, &rsquo;D&rsquo;: &lsquo;3&rsquo;, &rsquo;M&rsquo;: &lsquo;2&rsquo;, &lsquo;O&rsquo;: &lsquo;4&rsquo;,</p>

<p>&lsquo;N&rsquo;: &lsquo;5&rsquo;, &rsquo;S&rsquo;: &lsquo;1&rsquo;, &lsquo;R&rsquo;: &lsquo;6&rsquo;, &lsquo;Y&rsquo;: &lsquo;7&rsquo;}</p>

<ol>
<li><p>Given a list of letters and a list of digits (each represented here as 1-character strings), the zip function will create a pairing of letters and digits, in order.</p></li>

<li><p>Why is that cool? Because that data structure happens to be exactly the right structure to pass to the dict() function to create a dictionary that uses letters as keys and their associated digits as values. (This isn’t the only way to do it, of course. You could use a dictionary
comprehension
to create the dictionary directly.) Although the printed representation of the dictionary lists the pairs in a different order (dictionaries have no “order” per se), you can see that each letter is associated with the digit, based on the ordering of the original characters and guess sequences.</p></li>
</ol>

<p>The alphametics solver uses this technique to create a dictionary that maps letters in the puzzle to digits in the solution, for each possible solution.
characters = tuple(ord&copy; for c in sorted_characters)</p>

<p>digits = tuple(ord&copy; for c in &lsquo;0123456789&rsquo;)
&hellip;
for guess in itertools.permutations(digits, len(characters)):</p>

<p>&hellip;
equation = puzzle.translate(dict(zip(characters, guess)))</p>

<p>But what is this translate() method? Ah, now you’re getting to the really fun part.</p>

<p>.</p>

<p>8.8. A NEW KIND OF STRING MANIPULATION
Python strings have many methods. You learned about some of those methods in the
Strings
chapter: lower(), count(), and format(). Now I want to introduce you to a powerful but little-known string manipulation technique: the translate() method.
&gt;&gt;&gt; translation_table = {ord(&lsquo;A&rsquo;): ord(&lsquo;O&rsquo;)} .
&gt;&gt;&gt; translation_table .
{65: 79}
&gt;&gt;&gt; &lsquo;MARK&rsquo;.translate(translation_table) .
&lsquo;MORK&rsquo;</p>

<ol>
<li><p>String translation starts with a translation table, which is just a dictionary that maps one character to another. Actually, “character” is incorrect — the translation table really maps one byte to another.</p></li>

<li><p>Remember, bytes in Python 3 are integers. The ord() function returns the ASCII value of a character, which, in the case of A–Z, is always a byte from 65 to 90.</p></li>

<li><p>The translate() method on a string takes a translation table and runs the string through it. That is, it replaces all occurrences of the keys of the translation table with the corresponding values. In this case, “translating” MARK to MORK.</p></li>
</ol>

<p>What does this have to do with solving alphametic puzzles? As it turns out, everything.</p>

<blockquote>
<blockquote>
<blockquote>
<p>characters = tuple(ord&copy; for c in &lsquo;SMEDONRY&rsquo;) .
characters
(83, 77, 69, 68, 79, 78, 82, 89)
guess = tuple(ord&copy; for c in &lsquo;91570682&rsquo;) .
guess
(57, 49, 53, 55, 48, 54, 56, 50)
translation_table = dict(zip(characters, guess)) .
translation_table</p>
</blockquote>
</blockquote>
</blockquote>

<p>{68: 55, 69: 53, 77: 49, 78: 54, 79: 48, 82: 56, 83: 57, 89: 50}
&gt;&gt;&gt; &lsquo;SEND + MORE == MONEY&rsquo;.translate(translation_table) .
&lsquo;9567 + 1085 == 10652&rsquo;</p>

<ol>
<li><p>Using a generator
expression, we quickly compute the byte values for each character in a string. characters is an example of the value of sorted_characters in the alphametics.solve() function.</p></li>

<li><p>Using another generator expression, we quickly compute the byte values for each digit in this string. The result, guess, is of the form returned
by
the
itertools.permutations() function
in the alphametics.solve() function.</p></li>

<li><p>This translation table is generated by zipping
characters and
guess together
and building a dictionary from the resulting sequence of pairs. This is exactly what the alphametics.solve() function does inside the for loop.</p></li>

<li><p>Finally, we pass this translation table to the translate() method of the original puzzle string. This converts each letter in the string to the corresponding digit (based on the letters in characters and the digits in guess). The result is a valid Python expression, as a string.</p></li>
</ol>

<p>That’s pretty impressive. But what can you do with a string that happens to be a valid Python expression?</p>

<p>.
8.9. EVALUATING ARBITRARY STRINGS AS PYTHON EXPRESSIONS
This is the final piece of the puzzle (or rather, the final piece of the puzzle solver). After all that fancy string manipulation, we’re left with a string like &lsquo;9567 + 1085 == 10652&rsquo;. But that’s a string, and what good is a string? Enter eval(), the universal Python evaluation tool.
&gt;&gt;&gt; eval(&lsquo;1 + 1 == 2&rsquo;)
True
&gt;&gt;&gt; eval(&lsquo;1 + 1 == 3&rsquo;)
False
&gt;&gt;&gt; eval(&lsquo;9567 + 1085 == 10652&rsquo;)
True</p>

<p>But wait, there’s more! The eval() function isn’t limited to boolean expressions. It can handle any Python expression and returns any datatype.
&gt;&gt;&gt; eval(&lsquo;&ldquo;A&rdquo; + &ldquo;B&rdquo;&rsquo;)
&lsquo;AB&rsquo;
&gt;&gt;&gt; eval(&lsquo;&ldquo;MARK&rdquo;.translate({65: 79})&lsquo;)
&lsquo;MORK&rsquo;
&gt;&gt;&gt; eval(&lsquo;&ldquo;AAAAA&rdquo;.count(&ldquo;A&rdquo;)&rsquo;)
5
&gt;&gt;&gt; eval(&rsquo;[&rdquo;*&ldquo;] * 5&rsquo;)
[&rsquo;<em>&rsquo;, &lsquo;</em>&rsquo;, &lsquo;<em>&rsquo;, &lsquo;</em>&rsquo;, &lsquo;*&lsquo;]</p>

<p>But wait, that’s not all!
&gt;&gt;&gt; x = 5
&gt;&gt;&gt; eval(&ldquo;x * 5&rdquo;) .
25
&gt;&gt;&gt; eval(&ldquo;pow(x, 2)&rdquo;) .
25
&gt;&gt;&gt; import math
&gt;&gt;&gt; eval(&ldquo;math.sqrt(x)&rdquo;) .
2.2360679774997898</p>

<ol>
<li><p>The expression that eval() takes can reference global variables defined outside the eval(). If called within a function, it can reference local variables too.</p></li>

<li><p>And functions.</p></li>

<li><p>And modules.</p></li>
</ol>

<p>Hey, wait a minute…
&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; eval(&ldquo;subprocess.getoutput(&lsquo;ls ~&lsquo;)&ldquo;) .
&lsquo;Desktop Library Pictures </p>

<p>Documents Movies Public \
Music Sites&rsquo;
&gt;&gt;&gt; eval(&ldquo;subprocess.getoutput(&lsquo;rm /some/random/file&rsquo;)&rdquo;) .</p>

<ol>
<li><p>The subprocess module allows you to run arbitrary shell commands and get the result as a Python string.</p></li>

<li><p>Arbitrary shell commands can have permanent consequences.</p></li>
</ol>

<p>It’s even worse than that, because there’s a global <strong>import</strong>() function that takes a module name as a string, imports the module, and returns a reference to it. Combined with the power of eval(), you can construct a single expression that will wipe out all your files:
&gt;&gt;&gt; eval(&rdquo;<strong>import</strong>(&lsquo;subprocess&rsquo;).getoutput(&lsquo;rm /some/random/file&rsquo;)&ldquo;) .
1.  Now imagine the output of &lsquo;rm -rf ~&lsquo;. Actually there wouldn’t be any output, but you wouldn’t have any files left either.</p>

<p>eval() is
EVIL</p>

<p>Well, the evil part is evaluating arbitrary expressions from untrusted sources. You should only use eval() on trusted input. Of course, the trick is figuring out what’s “trusted.” But here’s something I know for certain: you should NOT take this alphametics solver and put it on the internet as a fun little web service. Don’t make the mistake of thinking, “Gosh, the function does a lot of string manipulation before getting a string to evaluate; I can’t imagine how someone could exploit that.” Someone WILL figure out how to sneak nasty executable code past all that string manipulation (stranger
things
have
happened), and then you can kiss your server goodbye.
But surely there’s some way to evaluate expressions safely? To put eval() in a sandbox where it can’t access or harm the outside world? Well, yes and no.
&gt;&gt;&gt; x = 5
&gt;&gt;&gt; eval(&ldquo;x * 5&rdquo;, {}, {}) .</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
File &ldquo;<string>&rdquo;, line 1, in <module></p>

<p>NameError: name &lsquo;x&rsquo; is not defined</p>

<blockquote>
<blockquote>
<blockquote>
<p>eval(&ldquo;x * 5&rdquo;, {&ldquo;x&rdquo;: x}, {}) .
import math
eval(&ldquo;math.sqrt(x)&rdquo;, {&ldquo;x&rdquo;: x}, {}) .</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
File &ldquo;<string>&rdquo;, line 1, in <module></p>

<p>NameError: name &lsquo;math&rsquo; is not defined</p>

<ol>
<li><p>The second and third parameters passed to the eval() function act as the global and local namespaces for evaluating the expression. In this case, they are both empty, which means that when the string &ldquo;x * 5&rdquo; is evaluated, there is no reference to x in either the global or local namespace, so eval() throws an exception.</p></li>

<li><p>You can selectively include specific values in the global namespace by listing them individually. Then those — and only those — variables will be available during evaluation.</p></li>

<li><p>Even though you just imported the math module, you didn’t include it in the namespace passed to the eval() function, so the evaluation failed.</p></li>
</ol>

<p>Gee, that was easy. Lemme make an alphametics web service now!
&gt;&gt;&gt; eval(&ldquo;pow(5, 2)&rdquo;, {}, {}) .
25
&gt;&gt;&gt; eval(&rdquo;<strong>import</strong>(&lsquo;math&rsquo;).sqrt(5)&ldquo;, {}, {}) .
2.2360679774997898</p>

<ol>
<li><p>Even though you’ve passed empty dictionaries for the global and local namespaces, all of Python’s built-in functions are still available during evaluation. So pow(5, 2) works, because 5 and 2 are literals, and pow() is a built-in function.</p></li>

<li><p>Unfortunately (and if you don’t see why it’s unfortunate, read on), the <strong>import</strong>() function is also a built-in function, so it works too.</p></li>
</ol>

<p>Yeah, that means you can still do nasty things, even if you explicitly set the global and local namespaces to empty dictionaries when calling eval():
&gt;&gt;&gt; eval(&rdquo;<strong>import</strong>(&lsquo;subprocess&rsquo;).getoutput(&lsquo;rm /some/random/file&rsquo;)&ldquo;, {}, {})</p>

<p>Oops. I’m glad I didn’t make that alphametics web service. Is there any way to use eval() safely? Well, yes and no.
&gt;&gt;&gt; eval(&rdquo;<strong>import</strong>(&lsquo;math&rsquo;).sqrt(5)&ldquo;,
&hellip; {&rdquo;<strong>builtins</strong>&ldquo;:None}, {}) .</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
File &ldquo;<string>&rdquo;, line 1, in <module></p>

<p>NameError: name &lsquo;<strong>import</strong>&rsquo; is not defined</p>

<blockquote>
<blockquote>
<blockquote>
<p>eval(&rdquo;<strong>import</strong>(&lsquo;subprocess&rsquo;).getoutput(&lsquo;rm -rf /&rsquo;)&ldquo;,
&hellip; {&rdquo;<strong>builtins</strong>&ldquo;:None}, {}) .</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
File &ldquo;<string>&rdquo;, line 1, in <module></p>

<p>NameError: name &lsquo;<strong>import</strong>&rsquo; is not defined</p>

<ol>
<li>To evaluate untrusted expressions safely, you need to define a global namespace dictionary that maps &ldquo;<strong>builtins</strong>&rdquo; to None, the Python null value. Internally, the “built-in” functions are contained within a</li>
</ol>

<p>pseudo-module called &ldquo;<strong>builtins</strong>&rdquo;. This pseudo-module (i.e. the set of built-in functions) is made
available to evaluated expressions unless you explicitly override it.</p>

<ol>
<li>Be sure you’ve overridden <strong>builtins</strong>. Not <strong>builtin</strong>, <strong>built-ins</strong>, or some other variation that will work just fine but expose you to catastrophic risks.</li>
</ol>

<p>So  eval() is safe now? Well, yes and no.
&gt;&gt;&gt; eval(&ldquo;2 ** 2147483647&rdquo;,
&hellip; {&rdquo;<strong>builtins</strong>&ldquo;:None}, {}) .</p>

<ol>
<li>Even without access to <strong>builtins</strong>, you can still launch a denial-of-service attack. For example, trying to raise 2 to the 2147483647th power will spike your server’s CPU utilization to 100% for quite some time. (If you’re trying this in the interactive shell, press Ctrl-C a few times to break out of it.) Technically this expression will return a value eventually, but in the meantime your server will be doing a whole lot of nothing.
In the end, it is possible to safely evaluate untrusted Python expressions, for some definition of “safe” that turns out not to be terribly useful in real life. It’s fine if you’re just playing around, and it’s fine if you only ever pass it trusted input. But anything else is just asking for trouble.
.
8.10. PUTTING IT ALL TOGETHER
To recap: this program solves alphametic puzzles by brute force, i.e. through an exhaustive search of all possible solutions. To do this, it…</li>

<li><p>Finds
all
the
letters
in
the
puzzle
with the re.findall() function</p></li>

<li><p>Find
all
the
unique letters
in
the
puzzle
with sets and the set() function</p></li>

<li><p>Checks
if
there
are
more
than</p></li>

<li><p>unique
letters
(meaning the puzzle is definitely unsolvable) with an assert statement</p></li>

<li><p>Converts the letters to their ASCII equivalents with a generator object</p></li>

<li><p>Calculates
all
the
possible
solutions
with the itertools.permutations() function</p></li>

<li><p>Converts
each
possible
solution
to
a
Python
expression
with the translate() string method</p></li>

<li><p>Tests
each
possible
solution
by
evaluating
the
Python
expression
with the eval() function</p></li>

<li><p>Returns the first solution that evaluates to True</p></li>
</ol>

<p>…in just 14 lines of code.
.</p>

<p>8.11. FURTHER READING
• itertools module</p>

<p>• itertools —
Iterator
functions
for
efficient
looping</p>

<p>• Watch
Raymond
Hettinger’s
“Easy
AI
with
Python”
talk
at PyCon 2009</p>

<p>• Recipe
576615:
Alphametics
solver, Raymond Hettinger’s original alphametics solver for Python 2</p>

<p>• More
of
Raymond
Hettinger’s
recipes
in the ActiveState Code repository</p>

<p>• Alphametics
on
Wikipedia</p>

<p>• Alphametics
Index, including lots
of
puzzles
and a
generator
to
make
your
own</p>

<p>Many thanks to Raymond Hettinger for agreeing to relicense his code so I could port it to Python 3 and use it as the basis for this chapter.
CHAPTER 9. UNIT TESTING</p>

<p>. Certitude is not the test of certainty. We have been cocksure of many things that were not so. .
—   Oliver Wendell Holmes, Jr.
9.1. (NOT) DIVING IN
Kids today. So spoiled by these fast computers and fancy “dynamic” languages. Write first, ship second, debug third (if ever). In my day, we had discipline. Discipline, I say! We had to write programs by hand, on paper, and feed them to the computer on punchcards. And we liked it!
In this chapter, you’re going to write and debug a set of utility functions to convert to and from Roman numerals. You saw the mechanics of constructing and validating Roman numerals in “Case
study:
roman
numerals”. Now step back and consider what it would take to expand that into a two-way utility.
The
rules
for
Roman
numerals
lead to a number of interesting observations:
1.  There is only one correct way to represent a particular number as a Roman numeral.</p>

<ol>
<li><p>The converse is also true: if a string of characters is a valid Roman numeral, it represents only one number (that is, it can only be interpreted one way).</p></li>

<li><p>There is a limited range of numbers that can be expressed as Roman numerals, specifically 1 through 3999. The Romans did have several ways of expressing larger numbers, for instance by having a bar over a numeral to represent that its normal value should be multiplied by 1000. For the purposes of this chapter, let’s stipulate that Roman numerals go from 1 to 3999.</p></li>

<li><p>There is no way to represent 0 in Roman numerals.</p></li>

<li><p>There is no way to represent negative numbers in Roman numerals.</p></li>

<li><p>There is no way to represent fractions or non-integer numbers in Roman numerals.</p></li>
</ol>

<p>Let’s start mapping out what a roman.py module should do. It will have two main functions, to_roman() and
from_roman(). The to_roman() function should take an integer from 1 to 3999 and return the Roman
numeral representation as a string…</p>

<p>Stop right there. Now let’s do something a little unexpected: write a test case that checks whether the to_roman() function does what you want it to. You read that right: you’re going to write code that tests code that you haven’t written yet.
This is called test-driven development, or TDD. The set of two conversion functions — to_roman(), and later from_roman() — can be written and tested as a unit, separate from any larger program that imports them. Python has a framework for unit testing, the appropriately-named unittest module.
Unit testing is an important part of an overall testing-centric development strategy. If you write unit tests, it is important to write them early and to keep them updated as code and requirements change. Many people advocate writing tests before they write the code they’re testing, and that’s the style I’m going to demonstrate in this chapter. But unit tests are beneficial no matter when you write them.
•   Before writing code, writing unit tests forces you to detail your requirements in a useful fashion.</p>

<p>•   While writing code, unit tests keep you from over-coding. When all the test cases pass, the function is complete.</p>

<p>•   When refactoring code, they can help prove that the new version behaves the same way as the old version.</p>

<p>•   When maintaining code, having tests will help you cover your ass when someone comes screaming that your latest change broke their old code. (“But sir, all the unit tests passed when I checked it in&hellip;”)</p>

<p>•   When writing code in a team, having a comprehensive test suite dramatically decreases the chances that your code will break someone else’s code, because you can run their unit tests first. (I’ve seen this sort of thing in code sprints. A team breaks up the assignment, everybody takes the specs for their task, writes unit tests for it, then shares their unit tests with the rest of the team. That way, nobody goes off too far into developing code that doesn’t play well with others.)</p>

<p>.</p>

<p>9.2. A SINGLE QUESTION
A test case answers a single question about the code it is testing. A test case should be able to&hellip;
•   &hellip;run completely by itself, without any human input. Unit testing is about automation.</p>

<p>•   &hellip;determine by itself whether the function it is testing has passed or failed, without a human interpreting the results.</p>

<p>•   &hellip;run in isolation, separate from any other test cases (even if they test the same functions). Each test case is</p>

<p>an island.
Given that, let’s build a test case for the first requirement:</p>

<ol>
<li>The to_roman() function should return the Roman numeral representation for all integers 1 to 3999.
It is not immediately obvious how this code does… well, anything. It defines a class which has no <strong>init</strong>() method. The class does have another method, but it is never called. The entire script has a <strong>main</strong> block, but it doesn’t reference the class or its method. But it does do something, I promise.
import roman1
import unittest</li>
</ol>

<p>class KnownValues(unittest.TestCase): . known_values = ( (1, &lsquo;I&rsquo;),
(2, &lsquo;II&rsquo;),
(3, &lsquo;III&rsquo;),
(4, &lsquo;IV&rsquo;),
(5, &lsquo;V&rsquo;),
(6, &lsquo;VI&rsquo;),
(7, &lsquo;VII&rsquo;),
(8, &lsquo;VIII&rsquo;),
(9, &lsquo;IX&rsquo;),
(10, &lsquo;X&rsquo;),
(50, &lsquo;L&rsquo;),
(100, &lsquo;C&rsquo;),
(500, &rsquo;D&rsquo;),
(1000, &rsquo;M&rsquo;),
(31, &lsquo;XXXI&rsquo;),
(148, &lsquo;CXLVIII&rsquo;),
(294, &lsquo;CCXCIV&rsquo;),
(312, &lsquo;CCCXII&rsquo;),
(421, &lsquo;CDXXI&rsquo;),
(528, &lsquo;DXXVIII&rsquo;),
(621, &lsquo;DCXXI&rsquo;),
(782, &lsquo;DCCLXXXII&rsquo;),
(870, &lsquo;DCCCLXX&rsquo;),
(941, &lsquo;CMXLI&rsquo;),
(1043, &lsquo;MXLIII&rsquo;),
(1110, &lsquo;MCX&rsquo;),
(1226, &lsquo;MCCXXVI&rsquo;),
(1301, &lsquo;MCCCI&rsquo;),
(1485, &lsquo;MCDLXXXV&rsquo;),
(1509, &lsquo;MDIX&rsquo;),</p>

<p>(1607, &lsquo;MDCVII&rsquo;),</p>

<p>(1754, &lsquo;MDCCLIV&rsquo;), (1832, &lsquo;MDCCCXXXII&rsquo;), (1993, &lsquo;MCMXCIII&rsquo;), (2074, &lsquo;MMLXXIV&rsquo;), (2152, &lsquo;MMCLII&rsquo;), (2212, &lsquo;MMCCXII&rsquo;), (2343, &lsquo;MMCCCXLIII&rsquo;), (2499, &lsquo;MMCDXCIX&rsquo;), (2574, &lsquo;MMDLXXIV&rsquo;), (2646, &lsquo;MMDCXLVI&rsquo;), (2723, &lsquo;MMDCCXXIII&rsquo;), (2892, &lsquo;MMDCCCXCII&rsquo;), (2975, &lsquo;MMCMLXXV&rsquo;), (3051, &lsquo;MMMLI&rsquo;), (3185, &lsquo;MMMCLXXXV&rsquo;), (3250, &lsquo;MMMCCL&rsquo;), (3313, &lsquo;MMMCCCXIII&rsquo;), (3408, &lsquo;MMMCDVIII&rsquo;), (3501, &lsquo;MMMDI&rsquo;), (3610, &lsquo;MMMDCX&rsquo;), (3743, &lsquo;MMMDCCXLIII&rsquo;), (3844, &lsquo;MMMDCCCXLIV&rsquo;), (3888, &lsquo;MMMDCCCLXXXVIII&rsquo;), (3940, &lsquo;MMMCMXL&rsquo;), (3999, &lsquo;MMMCMXCIX&rsquo;)) .
def test_to_roman_known_values(self): .
&ldquo;&lsquo;to_roman should give known result with known input&rdquo;&rsquo;</p>

<p>for integer, numeral in self.known_values:</p>

<p>result = roman1.to_roman(integer) .
self.assertEqual(numeral, result) .
if <strong>name</strong> == &lsquo;<strong>main</strong>&lsquo;:</p>

<p>unittest.main()</p>

<ol>
<li><p>To write a test case, first subclass the TestCase class of the unittest module. This class provides many useful methods which you can use in your test case to test specific conditions.</p></li>

<li><p>This is a list of integer/numeral pairs that I verified manually. It includes the lowest ten numbers, the highest number, every number that translates to a single-character Roman numeral, and a random sampling of other valid numbers. You don’t need to test every possible input, but you should try to test all the obvious edge cases.</p></li>

<li><p>Every individual test is its own method. A test method takes no parameters, returns no value, and must have a name beginning with the four letters test. If a test method exits normally without raising an exception, the test is considered passed; if the method raises an exception, the test is considered failed.</p></li>

<li><p>Here you call the actual to_roman() function. (Well, the function hasn’t been written yet, but once it is, this is the line that will call it.) Notice that you have now defined the API for the to_roman() function: it must take an integer (the number to convert) and return a string (the Roman numeral representation). If the API is different than that, this test is considered failed. Also notice that you are not trapping any exceptions when you call to_roman(). This is intentional. to_roman() shouldn’t raise an exception when you call it with valid input, and these input values are all valid. If to_roman() raises an exception, this test is considered failed.</p></li>

<li><p>Assuming the to_roman() function was defined correctly, called correctly, completed successfully, and returned a value, the last step is to check whether it returned the right value. This is a common question, and the TestCase class provides a method, assertEqual, to check whether two values are equal. If the result returned from to_roman() (result) does not match the known value you were expecting (numeral), assertEqual will raise an exception and the test will fail. If the two values are equal, assertEqual will do nothing. If every value returned from to_roman() matches the known value you expect, assertEqual never raises an exception, so test_to_roman_known_values eventually exits normally, which means to_roman() has passed this test.</p></li>
</ol>

<p>Once you have a test case, you can start coding the to_roman() function. First, you should stub it out as an empty function and make sure the tests fail. If the tests succeed before you’ve written any code, your tests aren’t testing your code at all! Unit testing is a dance: tests lead, code follows. Write a test that fails, then code until it passes.</p>

<h1 id="roman1-py">roman1.py</h1>

<p>def to_roman(n):
&ldquo;&lsquo;convert integer to Roman numeral&rdquo;&rsquo;</p>

<p>pass    .
1.  At this stage, you want to define the API of the to_roman() function, but you don’t want to code it yet. (Your test needs to fail first.) To stub it out, use the Python reserved word pass, which does precisely nothing.
Execute romantest1.py on the command line to run the test. If you call it with the -v command-line option, it will give more verbose output so you can see exactly what’s going on as each test case runs. With any luck, your output should look like this:
you@localhost:~/diveintopython3/examples$ python3 romantest1.py -v
test_to_roman_known_values (<strong>main</strong>.KnownValues) .
to_roman should give known result with known input &hellip; FAIL .</p>

<p>======================================================================
FAIL: to_roman should give known result with known input</p>

<p>Traceback (most recent call last):
File &ldquo;romantest1.py&rdquo;, line 73, in test_to_roman_known_values
self.assertEqual(numeral, result)
AssertionError: &lsquo;I&rsquo; != None .</p>

<p>Ran 1 test in 0.016s    .
FAILED (failures=1)     .
1.  Running the script runs unittest.main(), which runs each test case. Each test case is a method within a class in romantest.py. There is no required organization of these test classes; they can each contain a single test method, or you can have one class that contains multiple test methods. The only requirement is that each test class must inherit from unittest.TestCase.</p>

<ol>
<li><p>For each test case, the unittest module will print out the docstring of the method and whether that test passed or failed. As expected, this test case fails.</p></li>

<li><p>For each failed test case, unittest displays the trace information showing exactly what happened. In this case, the call to assertEqual() raised an AssertionError because it was expecting to_roman(1) to return &lsquo;I&rsquo;, but it didn’t. (Since there was no explicit return statement, the function returned None, the Python null value.)</p></li>

<li><p>After the detail of each test, unittest displays a summary of how many tests were performed and how long it took.</p></li>

<li><p>Overall, the test run failed because at least one test case did not pass. When a test case doesn’t pass, unittest distinguishes between failures and errors. A failure is a call to an assertXYZ method, like assertEqual or assertRaises, that fails because the asserted condition is not true or the expected exception was not raised. An error is any other sort of exception raised in the code you’re testing or the unit test case itself.</p></li>
</ol>

<p>Now, finally, you can write the to_roman() function.
roman_numeral_map = ((&rsquo;M&rsquo;, 1000),</p>

<p>(&lsquo;CM&rsquo;, 900),</p>

<p>(&rsquo;D&rsquo;, 500),</p>

<p>(&lsquo;CD&rsquo;, 400),</p>

<p>(&lsquo;C&rsquo;, 100),</p>

<p>(&lsquo;XC&rsquo;, 90),</p>

<p>(&lsquo;L&rsquo;, 50),</p>

<p>(&lsquo;XL&rsquo;, 40),</p>

<p>(&lsquo;X&rsquo;, 10),</p>

<p>(&lsquo;IX&rsquo;, 9),</p>

<p>(&lsquo;V&rsquo;, 5),</p>

<p>(&lsquo;IV&rsquo;, 4),</p>

<p>(&lsquo;I&rsquo;, 1))   .
def to_roman(n):</p>

<p>&rdquo;&lsquo;convert integer to Roman numeral&rdquo;&rsquo;</p>

<p>result = &ldquo;</p>

<p>for numeral, integer in roman_numeral_map:</p>

<p>while n &gt;= integer:     .
result += numeral</p>

<p>n -= integer</p>

<p>return result</p>

<ol>
<li><p>roman_numeral_map is a tuple of tuples which defines three things: the character representations of the most basic Roman numerals; the order of the Roman numerals (in descending value order, from M all the way down to I); the value of each Roman numeral. Each inner tuple is a pair of (numeral, value). It’s not just single-character Roman numerals; it also defines two-character pairs like CM (“one hundred less than one thousand”). This makes the to_roman() function code simpler.</p></li>

<li><p>Here’s where the rich data structure of roman_numeral_map pays off, because you don’t need any special logic to handle the subtraction rule. To convert to Roman numerals, simply iterate through roman_numeral_map looking for the largest integer value less than or equal to the input. Once found, add</p></li>
</ol>

<p>the Roman numeral representation to the end of the output, subtract the corresponding integer value from the input, lather, rinse, repeat.
If you’re still not clear how the to_roman() function works, add a print() call to the end of the while loop:
while n &gt;= integer:
result += numeral
n -= integer
print(&lsquo;subtracting {0} from input, adding {1} to output&rsquo;.format(integer, numeral))</p>

<p>With the debug print() statements, the output looks like this:
&gt;&gt;&gt; import roman1
&gt;&gt;&gt; roman1.to_roman(1424)
subtracting 1000 from input, adding M to output
subtracting 400 from input, adding CD to output
subtracting 10 from input, adding X to output
subtracting 10 from input, adding X to output
subtracting 4 from input, adding IV to output
&lsquo;MCDXXIV&rsquo;</p>

<p>So the to_roman() function appears to work, at least in this manual spot check. But will it pass the test case you wrote?
you@localhost:~/diveintopython3/examples$ python3 romantest1.py -v
test_to_roman_known_values (<strong>main</strong>.KnownValues)
to_roman should give known result with known input &hellip; ok .</p>

<p>Ran 1 test in 0.016s</p>

<p>OK</p>

<ol>
<li>Hooray! The to_roman() function passes the “known values” test case. It’s not comprehensive, but it does put the function through its paces with a variety of inputs, including inputs that produce every single-character Roman numeral, the largest possible input (3999), and the input that produces the longest possible Roman numeral (3888). At this point, you can be reasonably confident that the function works for any good input value you could throw at it.
“Good” input? Hmm. What about bad input?
.
9.3. “HALT AND CATCH FIRE”
It is not enough to test that functions succeed when
given good input; you must also test that they fail when</li>
</ol>

<p>given bad input. And not just any sort of failure; they must fail in the way you expect.
&gt;&gt;&gt; import roman1
&gt;&gt;&gt; roman1.to_roman(4000)
&lsquo;MMMM&rsquo;
&gt;&gt;&gt; roman1.to_roman(5000)
&lsquo;MMMMM&rsquo;
&gt;&gt;&gt; roman1.to_roman(9000) .
&lsquo;MMMMMMMMM&rsquo;</p>

<ol>
<li>That’s definitely not what you wanted — that’s not even a valid Roman numeral! In fact, each of these numbers is outside the range of acceptable input, but the function</li>
</ol>

<p>returns a bogus value anyway. Silently returning bad values is baaaaaaad; if a program is going to fail, it is far better if it fails quickly and noisily. “Halt and catch fire,” as the saying goes. The Pythonic way to halt and catch fire is to raise an exception.
The question to ask yourself is, “How can I express this as a testable requirement?” How’s this for starters:
The to_roman() function should raise an
OutOfRangeError when given an integer greater
than 3999.</p>

<p>What would that test look like?
class ToRomanBadInput(unittest.TestCase):</p>

<p>def test_too_large(self): . &ldquo;&lsquo;to_roman should fail with large input&rdquo;&rsquo; self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000) .
1.  Like the previous test case, you create a class that inherits from unittest.TestCase. You can have more than one test per class (as you’ll see later in this chapter), but I chose to create a new class here because this test is something different than the last one. We’ll keep all the good input tests together in one class, and all the bad input tests together in another.</p>

<ol>
<li><p>Like the previous test case, the test itself is a method of the class, with a name starting with test.</p></li>

<li><p>The unittest.TestCase class provides the assertRaises method, which takes the following arguments: the exception you’re expecting, the function you’re testing, and the arguments you’re passing to that function. (If the function you’re testing takes more than one argument, pass them all to assertRaises, in order, and it will pass them right along to the function you’re testing.)</p></li>
</ol>

<p>Pay close attention to this last line of code. Instead of calling to_roman() directly and manually checking that it raises a particular exception (by wrapping it in a
try&hellip;except block), the assertRaises method has encapsulated all of that for us. All you do is tell it what exception you’re expecting (roman2.OutOfRangeError), the function (to_roman()), and the function’s arguments (4000). The assertRaises method takes care of calling to_roman() and checking that it raises roman2.OutOfRangeError.</p>

<p>Also note that you’re passing the to_roman() function itself as an argument; you’re not calling it, and you’re not passing the name of it as a string. Have I mentioned recently how handy it is that everything
in
Python
is
an
object?
So what happens when you run the test suite with this new test?
you@localhost:~/diveintopython3/examples$ python3 romantest2.py -v
test_to_roman_known_values (<strong>main</strong>.KnownValues)
to_roman should give known result with known input &hellip; ok
test_too_large (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with large input &hellip; ERROR .</p>

<p>======================================================================
ERROR: to_roman should fail with large input</p>

<p>Traceback (most recent call last):
File &ldquo;romantest2.py&rdquo;, line 78, in test_too_large
self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
AttributeError: &lsquo;module&rsquo; object has no attribute &lsquo;OutOfRangeError&rsquo; .</p>

<p>Ran 2 tests in 0.000s</p>

<p>FAILED (errors=1)</p>

<ol>
<li><p>You should have expected this to fail (since you haven’t written any code to pass it yet), but&hellip; it didn’t actually “fail,” it had an “error” instead. This is a subtle but important distinction. A unit test actually has three return values: pass, fail, and error. Pass, of course, means that the test passed — the code did what you expected. “Fail” is what the previous test case did (until you wrote code to make it pass) — it executed the code but the result was not what you expected. “Error” means that the code didn’t even execute properly.</p></li>

<li><p>Why didn’t the code execute properly? The traceback tells all. The module you’re testing doesn’t have an exception called OutOfRangeError. Remember, you passed this exception to the assertRaises() method, because it’s the exception you want the function to raise given an out-of-range input. But the exception</p></li>
</ol>

<p>doesn’t exist, so the call to the assertRaises() method failed. It never got a chance to test the
to_roman() function; it didn’t get that far.</p>

<p>To solve this problem, you need to define the OutOfRangeError exception in roman2.py.
class OutOfRangeError(ValueError): .
pass .</p>

<ol>
<li><p>Exceptions are classes. An “out of range” error is a kind of value error — the argument value is out of its acceptable range. So this exception inherits from the built-in ValueError exception. This is not strictly necessary (it could just inherit from the base Exception class), but it feels right.</p></li>

<li><p>Exceptions don’t actually do anything, but you need at least one line of code to make a class. Calling pass does precisely nothing, but it’s a line of Python code, so that makes it a class.</p></li>
</ol>

<p>Now run the test suite again.
you@localhost:~/diveintopython3/examples$ python3 romantest2.py -v
test_to_roman_known_values (<strong>main</strong>.KnownValues)
to_roman should give known result with known input &hellip; ok
test_too_large (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with large input &hellip; FAIL .</p>

<p>======================================================================
FAIL: to_roman should fail with large input</p>

<p>Traceback (most recent call last):
File &ldquo;romantest2.py&rdquo;, line 78, in test_too_large
self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
AssertionError: OutOfRangeError not raised by to_roman .</p>

<p>Ran 2 tests in 0.016s</p>

<p>FAILED (failures=1)</p>

<ol>
<li><p>The new test is still not passing, but it’s not returning an error either. Instead, the test is failing. That’s progress! It means the call to the assertRaises() method succeeded this time, and the unit test framework actually tested the to_roman() function.</p></li>

<li><p>Of course, the to_roman() function isn’t raising the OutOfRangeError exception you just defined, because you haven’t told it to do that yet. That’s excellent news! It means this is a valid test case — it fails before you write the code to make it pass.</p></li>
</ol>

<p>Now you can write the code to make this test pass.
def to_roman(n):
&ldquo;&lsquo;convert integer to Roman numeral&rdquo;&rsquo;
if n &gt; 3999:</p>

<p>raise OutOfRangeError(&lsquo;number out of range (must be less than 4000)&rsquo;) .
result = &ldquo;
for numeral, integer in roman_numeral_map:</p>

<p>while n &gt;= integer:
result += numeral
n -= integer</p>

<p>return result</p>

<ol>
<li>This is straightforward: if the given input (n) is greater than 3999, raise an OutOfRangeError exception. The unit test does not check the human-readable string that accompanies the exception, although you could write another test that did check it (but watch out for internationalization issues for strings that vary by the user’s language or environment).
Does this make the test pass? Let’s find out.
you@localhost:~/diveintopython3/examples$ python3 romantest2.py -v</li>
</ol>

<p>test_to_roman_known_values (<strong>main</strong>.KnownValues)
to_roman should give known result with known input &hellip; ok
test_too_large (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with large input &hellip; ok .</p>

<p>Ran 2 tests in 0.000s</p>

<p>OK</p>

<ol>
<li>Hooray! Both tests pass. Because you worked iteratively, bouncing back and forth between testing and coding, you can be sure that the two lines of code you just wrote were the cause of that one test going from “fail” to “pass.” That kind of confidence doesn’t come cheap, but it will pay for itself over the lifetime of your code.
.
9.4. MORE HALTING, MORE FIRE
Along with testing numbers that are too large, you need to test numbers that are too small. As we
noted
in
our
functional
requirements, Roman numerals cannot express 0 or negative numbers.
&gt;&gt;&gt; import roman2
&gt;&gt;&gt; roman2.to_roman(0)
&ldquo;
&gt;&gt;&gt; roman2.to_roman(-1)
&ldquo;</li>
</ol>

<p>Well that’s not good. Let’s add tests for each of these conditions.
class ToRomanBadInput(unittest.TestCase):</p>

<p>def test_too_large(self): &ldquo;&lsquo;to_roman should fail with large input&rdquo;&rsquo; self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 4000) .
def test_zero(self): &ldquo;&lsquo;to_roman should fail with 0 input&rdquo;&rsquo; self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 0) .
def test_negative(self): &ldquo;&lsquo;to_roman should fail with negative input&rdquo;&rsquo; self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, -1) .
1.  The test_too_large() method has not changed since the previous step. I’m including it here to show where the new code fits.</p>

<ol>
<li><p>Here’s a new test: the test_zero() method. Like the test_too_large() method, it tells the assertRaises() method defined in unittest.TestCase to call our to_roman() function with a parameter of 0, and check that it raises the appropriate exception, OutOfRangeError.</p></li>

<li><p>The test_negative() method is almost identical, except it passes -1 to the to_roman() function. If either of these new tests does not raise an OutOfRangeError (either because the function returns an actual value, or because it raises some other exception), the test is considered failed.</p></li>
</ol>

<p>Now check that the tests fail:
you@localhost:~/diveintopython3/examples$ python3 romantest3.py -v
test_to_roman_known_values (<strong>main</strong>.KnownValues)
to_roman should give known result with known input &hellip; ok
test_negative (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with negative input &hellip; FAIL
test_too_large (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with large input &hellip; ok
test_zero (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with 0 input &hellip; FAIL</p>

<p>======================================================================
FAIL: to_roman should fail with negative input</p>

<p>Traceback (most recent call last):
File &ldquo;romantest3.py&rdquo;, line 86, in test_negative
self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, -1)
AssertionError: OutOfRangeError not raised by to_roman</p>

<p>======================================================================
FAIL: to_roman should fail with 0 input</p>

<p>Traceback (most recent call last):
File &ldquo;romantest3.py&rdquo;, line 82, in test_zero
self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 0)
AssertionError: OutOfRangeError not raised by to_roman</p>

<p>Ran 4 tests in 0.000s</p>

<p>FAILED (failures=2)</p>

<p>Excellent. Both tests failed, as expected. Now let’s switch over to the code and see what we can do to make them pass.
def to_roman(n):</p>

<p>&rdquo;&lsquo;convert integer to Roman numeral&rdquo;&rsquo;</p>

<p>if not (0 &lt; n &lt; 4000): . raise OutOfRangeError(&lsquo;number out of range (must be 1..3999)&rsquo;) .
result = &ldquo;
for numeral, integer in roman_numeral_map:</p>

<p>while n &gt;= integer:
result += numeral
n -= integer</p>

<p>return result</p>

<ol>
<li><p>This is a nice Pythonic shortcut: multiple comparisons at once. This is equivalent to if not ((0 &lt; n) and (n &lt; 4000)), but it’s much easier to read. This one line of code should catch inputs that are too large, negative, or zero.</p></li>

<li><p>If you change your conditions, make sure to update your human-readable error strings to match. The unittest framework won’t care, but it’ll make it difficult to do manual debugging if your code is throwing incorrectly-described exceptions.</p></li>
</ol>

<p>I could show you a whole series of unrelated examples to show that the multiple-comparisons-at-once shortcut works, but instead I’ll just run the unit tests and prove it.
you@localhost:~/diveintopython3/examples$ python3 romantest3.py -v
test_to_roman_known_values (<strong>main</strong>.KnownValues)
to_roman should give known result with known input &hellip; ok
test_negative (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with negative input &hellip; ok
test_too_large (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with large input &hellip; ok
test_zero (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with 0 input &hellip; ok</p>

<p>Ran 4 tests in 0.016s</p>

<p>OK</p>

<p>.
9.5. AND ONE MORE THING…
There was one more functional
requirement
for converting numbers to Roman numerals: dealing with non-integers.
&gt;&gt;&gt; import roman3
&gt;&gt;&gt; roman3.to_roman(0.5) .
&ldquo;
&gt;&gt;&gt; roman3.to_roman(1.0) .
&lsquo;I&rsquo;</p>

<ol>
<li><p>Oh, that’s bad.</p></li>

<li><p>Oh, that’s even worse. Both of these cases should raise an exception. Instead, they give bogus results.</p></li>
</ol>

<p>Testing for non-integers is not difficult. First, define a NotIntegerError exception.</p>

<h1 id="roman4-py">roman4.py</h1>

<p>class OutOfRangeError(ValueError): pass
class NotIntegerError(ValueError): pass</p>

<p>Next, write a test case that checks for the NotIntegerError exception.
class ToRomanBadInput(unittest.TestCase):
.
.
.
def test_non_integer(self):</p>

<p>&rdquo;&lsquo;to_roman should fail with non-integer input&rdquo;&rsquo;
self.assertRaises(roman4.NotIntegerError, roman4.to_roman, 0.5)</p>

<p>Now check that the test fails properly.
you@localhost:~/diveintopython3/examples$ python3 romantest4.py -v</p>

<p>test_to_roman_known_values (<strong>main</strong>.KnownValues)
to_roman should give known result with known input &hellip; ok
test_negative (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with negative input &hellip; ok
test_non_integer (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with non-integer input &hellip; FAIL
test_too_large (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with large input &hellip; ok
test_zero (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with 0 input &hellip; ok</p>

<p>======================================================================
FAIL: to_roman should fail with non-integer input</p>

<p>Traceback (most recent call last):
File &ldquo;romantest4.py&rdquo;, line 90, in test_non_integer
self.assertRaises(roman4.NotIntegerError, roman4.to_roman, 0.5)
AssertionError: NotIntegerError not raised by to_roman</p>

<p>Ran 5 tests in 0.000s</p>

<p>FAILED (failures=1)</p>

<p>Write the code that makes the test pass.
def to_roman(n):
&ldquo;&lsquo;convert integer to Roman numeral&rdquo;&rsquo;
if not (0 &lt; n &lt; 4000):</p>

<p>raise OutOfRangeError(&lsquo;number out of range (must be 1..3999)&rsquo;) if not isinstance(n, int): . raise NotIntegerError(&lsquo;non-integers can not be converted&rsquo;) .
result = &ldquo;
for numeral, integer in roman_numeral_map:</p>

<p>while n &gt;= integer:
result += numeral
n -= integer</p>

<p>return result</p>

<ol>
<li><p>The built-in isinstance() function tests whether a variable is a particular type (or, technically, any descendant type).</p></li>

<li><p>If the argument n is not an int, raise our newly minted NotIntegerError exception.</p></li>
</ol>

<p>Finally, check that the code does indeed make the test pass.
you@localhost:~/diveintopython3/examples$ python3 romantest4.py -v</p>

<p>test_to_roman_known_values (<strong>main</strong>.KnownValues)
to_roman should give known result with known input &hellip; ok
test_negative (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with negative input &hellip; ok
test_non_integer (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with non-integer input &hellip; ok
test_too_large (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with large input &hellip; ok
test_zero (<strong>main</strong>.ToRomanBadInput)
to_roman should fail with 0 input &hellip; ok</p>

<p>Ran 5 tests in 0.000s</p>

<p>OK</p>

<p>The to_roman() function passes all of its tests, and I can’t think of any more tests, so it’s time to move on to from_roman().
.</p>

<p>9.6. A PLEASING SYMMETRY
Converting a string from a Roman numeral to an integer sounds more difficult than converting an integer to a Roman numeral. Certainly there is the issue of validation. It’s easy to check if an integer is greater than 0, but a bit harder to check whether a string is a valid Roman numeral. But we already constructed a
regular
expression
to
check
for
Roman
numerals, so that part is done.
That leaves the problem of converting the string itself. As we’ll see in a minute, thanks to the rich data structure we defined to map individual Roman numerals to integer values, the nitty-gritty of the from_roman() function is as straightforward as the to_roman() function.
But first, the tests. We’ll need a “known values” test to spot-check for accuracy. Our test suite already contains a
mapping
of
known
values; let’s reuse that.
def test_from_roman_known_values(self):
&ldquo;&lsquo;from_roman should give known result with known input&rdquo;&rsquo;
for integer, numeral in self.known_values:</p>

<p>result = roman5.from_roman(numeral)
self.assertEqual(integer, result)</p>

<p>There’s a pleasing symmetry here. The to_roman() and from_roman() functions are inverses of each other. The first converts integers to specially-formatted strings, the second converts specially-formated strings to integers. In theory, we should be able to “round-trip” a number by passing to the to_roman() function to get a string, then passing that string to the from_roman() function to get an integer, and end up with the same number.
n = from_roman(to_roman(n)) for all values of n</p>

<p>In this case, “all values” means any number between 1..3999, since that is the valid range of inputs to the to_roman() function. We can express this symmetry in a test case that runs through all the values 1..3999, calls to_roman(), calls from_roman(), and checks that the output is the same as the original input.
class RoundtripCheck(unittest.TestCase):</p>

<p>def test_roundtrip(self):
&ldquo;&lsquo;from_roman(to_roman(n))==n for all n&rdquo;&rsquo;
for integer in range(1, 4000):</p>

<p>numeral = roman5.to_roman(integer)
result = roman5.from_roman(numeral)
self.assertEqual(integer, result)</p>

<p>These new tests won’t even fail yet. We haven’t defined a from_roman() function at all, so they’ll just raise errors.
you@localhost:~/diveintopython3/examples$ python3 romantest5.py</p>

<h1 id="e-e">E.E&hellip;.</h1>

<p>ERROR: test_from_roman_known_values (<strong>main</strong>.KnownValues)
from_roman should give known result with known input</p>

<p>Traceback (most recent call last):
File &ldquo;romantest5.py&rdquo;, line 78, in test_from_roman_known_values
result = roman5.from_roman(numeral)
AttributeError: &lsquo;module&rsquo; object has no attribute &lsquo;from_roman&rsquo;</p>

<p>======================================================================
ERROR: test_roundtrip (<strong>main</strong>.RoundtripCheck)
from_roman(to_roman(n))==n for all n</p>

<p>Traceback (most recent call last):
File &ldquo;romantest5.py&rdquo;, line 103, in test_roundtrip
result = roman5.from_roman(numeral)
AttributeError: &lsquo;module&rsquo; object has no attribute &lsquo;from_roman&rsquo;</p>

<p>Ran 7 tests in 0.019s</p>

<p>FAILED (errors=2)</p>

<p>A quick stub function will solve that problem.</p>

<h1 id="roman5-py">roman5.py</h1>

<p>def from_roman(s):
&ldquo;&lsquo;convert Roman numeral to integer&rdquo;&rsquo;</p>

<p>(Hey, did you notice that? I defined a function with nothing but a docstring. That’s legal Python. In fact, some programmers swear by it. “Don’t stub; document!”)
Now the test cases will actually fail.
you@localhost:~/diveintopython3/examples$ python3 romantest5.py</p>

<h1 id="f-f">F.F&hellip;.</h1>

<p>FAIL: test_from_roman_known_values (<strong>main</strong>.KnownValues)
from_roman should give known result with known input</p>

<p>Traceback (most recent call last):
File &ldquo;romantest5.py&rdquo;, line 79, in test_from_roman_known_values
self.assertEqual(integer, result)
AssertionError: 1 != None</p>

<p>======================================================================
FAIL: test_roundtrip (<strong>main</strong>.RoundtripCheck)
from_roman(to_roman(n))==n for all n</p>

<p>Traceback (most recent call last):
File &ldquo;romantest5.py&rdquo;, line 104, in test_roundtrip
self.assertEqual(integer, result)
AssertionError: 1 != None</p>

<p>Ran 7 tests in 0.002s</p>

<p>FAILED (failures=2)</p>

<p>Now it’s time to write the from_roman() function.
def from_roman(s):
&ldquo;&rdquo;&ldquo;convert Roman numeral to integer&rdquo;&ldquo;&rdquo;
result = 0
index = 0
for numeral, integer in roman_numeral_map:</p>

<p>while s[index:index+len(numeral)] == numeral: . result += integer index += len(numeral)
return result</p>

<ol>
<li>The pattern here is the same as the to_roman() function. You iterate through your Roman numeral data structure (a tuple of tuples), but instead of matching the highest integer values as often as possible, you match the “highest” Roman numeral character strings as often as possible.
If you&rsquo;re not clear how from_roman() works, add a print statement to the end of the while loop:
def from_roman(s):
&ldquo;&rdquo;&ldquo;convert Roman numeral to integer&rdquo;&ldquo;&rdquo;
result = 0
index = 0
for numeral, integer in roman_numeral_map:</li>
</ol>

<p>while s[index:index+len(numeral)] == numeral:
result += integer
index += len(numeral)
print(&lsquo;found&rsquo;, numeral, &lsquo;of length&rsquo;, len(numeral), &lsquo;, adding&rsquo;, integer)</p>

<blockquote>
<blockquote>
<blockquote>
<p>import roman5</p>

<p>roman5.from_roman(&lsquo;MCMLXXII&rsquo;)
found M of length 1, adding 1000
found CM of length 2, adding 900
found L of length 1, adding 50
found X of length 1, adding 10
found X of length 1, adding 10
found I of length 1, adding 1
found I of length 1, adding 1
1972</p>
</blockquote>
</blockquote>
</blockquote>

<p>Time to re-run the tests.
you@localhost:~/diveintopython3/examples$ python3 romantest5.py
&hellip;&hellip;.</p>

<p>Ran 7 tests in 0.060s</p>

<p>OK</p>

<p>Two pieces of exciting news here. The first is that the from_roman() function works for good input, at least for all the known
values. The second is that the “round trip” test also passed. Combined with the known values tests, you can be reasonably sure that both the to_roman() and from_roman() functions work properly for all possible good values. (This is not guaranteed; it is theoretically possible that to_roman() has a bug that produces the wrong Roman numeral for some particular set of inputs, and that from_roman() has a reciprocal bug that produces the same wrong integer values for exactly that set of Roman numerals that to_roman() generated incorrectly. Depending on your application and your requirements, this possibility may bother you; if so, write more comprehensive test cases until it doesn&rsquo;t bother you.)
.</p>

<p>9.7. MORE BAD INPUT
Now that the from_roman() function works properly with good input, it&rsquo;s time to fit in the last piece of the puzzle: making it work properly with bad input. That means finding a way to look at a string and determine if it&rsquo;s a valid Roman numeral. This is inherently more difficult than validating
numeric
input
in the to_roman() function, but you have a powerful tool at your disposal: regular expressions. (If you’re not familiar with regular expressions, now would be a good time to read the
regular
expressions
chapter.)
As you saw in Case
Study:
Roman
Numerals, there are several simple rules for constructing a Roman
numeral, using the letters M, D, C, L, X, V, and I. Let&rsquo;s review the rules:</p>

<p>•   Sometimes characters are additive. I is 1, II is 2, and III is 3. VI is 6 (literally, “5 and 1”), VII is 7, and VIII is 8.</p>

<p>•   The tens characters (I, X, C, and M) can be repeated up to three times. At 4, you need to subtract from the next highest fives character. You can&rsquo;t represent 4 as IIII; instead, it is represented as IV (“1 less than 5”). 40 is written as XL (“10 less than 50”), 41 as XLI, 42 as XLII, 43 as XLIII, and then 44 as XLIV (“10 less than 50, then 1 less than 5”).</p>

<p>•   Sometimes characters are… the opposite of additive. By putting certain characters before others, you subtract from the final value. For example, at 9, you need to subtract from the next highest tens character: 8 is VIII, but 9 is IX (“1 less than 10”), not VIIII (since the I character can not be repeated four times). 90 is XC, 900 is CM.</p>

<p>•   The fives characters can not be repeated. 10 is always represented as X, never as VV. 100 is always C, never LL.</p>

<p>•   Roman numerals are read left to right, so the order of characters matters very much. DC is 600; CD is a completely different number (400,“100 less than 500”). CI is 101; IC is not even a valid Roman numeral (because you can&rsquo;t subtract 1 directly from 100; you would need to write it as XCIX,“10 less than 100, then 1 less than 10”).</p>

<p>Thus, one useful test would be to ensure that the from_roman() function should fail when you pass it a
string with too many repeated numerals. How many is “too many” depends on the numeral.</p>

<p>class FromRomanBadInput(unittest.TestCase):</p>

<p>def test_too_many_repeated_numerals(self):
&ldquo;&lsquo;from_roman should fail with too many repeated numerals&rdquo;&rsquo;
for s in (&lsquo;MMMM&rsquo;, &lsquo;DD&rsquo;, &lsquo;CCCC&rsquo;, &rsquo;LL&rsquo;, &lsquo;XXXX&rsquo;, &lsquo;VV&rsquo;, &lsquo;IIII&rsquo;):</p>

<p>self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)</p>

<p>Another useful test would be to check that certain patterns aren’t repeated. For example, IX is 9, but IXIX is never valid.
def test_repeated_pairs(self):
&ldquo;&lsquo;from_roman should fail with repeated pairs of numerals&rdquo;&rsquo;
for s in (&lsquo;CMCM&rsquo;, &lsquo;CDCD&rsquo;, &lsquo;XCXC&rsquo;, &lsquo;XLXL&rsquo;, &lsquo;IXIX&rsquo;, &lsquo;IVIV&rsquo;):</p>

<p>self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)</p>

<p>A third test could check that numerals appear in the correct order, from highest to lowest value. For example, CL is 150, but LC is never valid, because the numeral for 50 can never come before the numeral for 100. This test includes a randomly chosen set of invalid antecedents: I before M, V before X, and so on.
def test_malformed_antecedents(self):
&ldquo;&lsquo;from_roman should fail with malformed antecedents&rdquo;&rsquo;
for s in (&lsquo;IIMXCC&rsquo;, &lsquo;VX&rsquo;, &lsquo;DCM&rsquo;, &lsquo;CMM&rsquo;, &lsquo;IXIV&rsquo;,</p>

<p>&lsquo;MCMC&rsquo;, &lsquo;XCX&rsquo;, &lsquo;IVI&rsquo;, &lsquo;LM&rsquo;, &lsquo;LD&rsquo;, &lsquo;LC&rsquo;):
self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)</p>

<p>Each of these tests relies the from_roman() function raising a new exception, InvalidRomanNumeralError, which we haven’t defined yet.</p>

<h1 id="roman6-py">roman6.py</h1>

<p>class InvalidRomanNumeralError(ValueError): pass</p>

<p>All three of these tests should fail, since the from_roman() function doesn’t currently have any validity checking. (If they don’t fail now, then what the heck are they testing?)
you@localhost:~/diveintopython3/examples$ python3 romantest6.py</p>

<h1 id="fff">FFF&hellip;&hellip;.</h1>

<p>FAIL: test_malformed_antecedents (<strong>main</strong>.FromRomanBadInput)
from_roman should fail with malformed antecedents</p>

<p>Traceback (most recent call last):
File &ldquo;romantest6.py&rdquo;, line 113, in test_malformed_antecedents
self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)
AssertionError: InvalidRomanNumeralError not raised by from_roman</p>

<p>======================================================================
FAIL: test_repeated_pairs (<strong>main</strong>.FromRomanBadInput)
from_roman should fail with repeated pairs of numerals</p>

<p>Traceback (most recent call last):
File &ldquo;romantest6.py&rdquo;, line 107, in test_repeated_pairs
self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)
AssertionError: InvalidRomanNumeralError not raised by from_roman</p>

<p>======================================================================
FAIL: test_too_many_repeated_numerals (<strong>main</strong>.FromRomanBadInput)
from_roman should fail with too many repeated numerals</p>

<p>Traceback (most recent call last):
File &ldquo;romantest6.py&rdquo;, line 102, in test_too_many_repeated_numerals
self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)
AssertionError: InvalidRomanNumeralError not raised by from_roman</p>

<p>Ran 10 tests in 0.058s</p>

<p>FAILED (failures=3)</p>

<p>Good deal. Now, all we need to do is add the regular
expression
to
test
for
valid
Roman
numerals
into the from_roman() function.
roman_numeral_pattern = re.compile(&ldquo;&rsquo;</p>

<p>^  # beginning of string<br />
M{0,3}  # thousands - 0 to 3 Ms<br />
(CM|CD|D?C{0,3})  # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),</p>

<h1 id="or-500-800-d-followed-by-0-to-3-cs-1">or 500-800 (D, followed by 0 to 3 Cs)</h1>

<p>(XC|XL|L?X{0,3})  # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),</p>

<h1 id="or-50-80-l-followed-by-0-to-3-xs-1">or 50-80 (L, followed by 0 to 3 Xs)</h1>

<p>(IX|IV|V?I{0,3})  # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),</p>

<h1 id="or-5-8-v-followed-by-0-to-3-is-1">or 5-8 (V, followed by 0 to 3 Is)</h1>

<p>$  # end of string<br />
&rdquo;&lsquo;, re.VERBOSE)</p>

<p>def from_roman(s):
&ldquo;&lsquo;convert Roman numeral to integer&rdquo;&rsquo;
if not roman_numeral_pattern.search(s):</p>

<p>raise InvalidRomanNumeralError(&lsquo;Invalid Roman numeral: {0}&lsquo;.format(s))</p>

<p>result = 0
index = 0
for numeral, integer in roman_numeral_map:</p>

<p>while s[index : index + len(numeral)] == numeral:
result += integer
index += len(numeral)</p>

<p>return result</p>

<p>And re-run the tests…
you@localhost:~/diveintopython3/examples$ python3 romantest7.py</p>

<p>&hellip;&hellip;&hellip;.</p>

<p>Ran 10 tests in 0.066s</p>

<p>OK</p>

<p>And the anticlimax award of the year goes to… the word “OK”, which is printed by the unittest module when all the tests pass.
CHAPTER 10. REFACTORING</p>

<p>. After one has played a vast quantity of notes and more notes, it is simplicity that emerges as the crowning reward of art. .
— Frédéric Chopin
10.1. DIVING IN
Like it or not, bugs happen. Despite your best efforts to write comprehensive unit
tests, bugs happen. What do I mean by “bug”? A bug is a test case you haven’t written yet.
&gt;&gt;&gt; import roman7
&gt;&gt;&gt; roman7.from_roman(&ldquo;) .
0</p>

<ol>
<li>This is a bug. An empty string should raise an InvalidRomanNumeralError exception, just like any other sequence of characters that don’t represent a valid Roman numeral.
After reproducing the bug, and before fixing it, you should write a test case that fails, thus illustrating the bug.
class FromRomanBadInput(unittest.TestCase):
.
.
.
def testBlank(self):</li>
</ol>

<p>&rdquo;&lsquo;from_roman should fail with blank string&rdquo;&rsquo; self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, &ldquo;) .
1.  Pretty simple stuff here. Call from_roman() with an empty string and make sure it raises an InvalidRomanNumeralError exception. The hard part was finding the bug; now that you know about it, testing for it is the easy part.
Since your code has a bug, and you now have a test case that tests this bug, the test case will fail:
you@localhost:~/diveintopython3/examples$ python3 romantest8.py -v
from_roman should fail with blank string &hellip; FAIL
from_roman should fail with malformed antecedents &hellip; ok
from_roman should fail with repeated pairs of numerals &hellip; ok
from_roman should fail with too many repeated numerals &hellip; ok
from_roman should give known result with known input &hellip; ok
to_roman should give known result with known input &hellip; ok
from_roman(to_roman(n))==n for all n &hellip; ok
to_roman should fail with negative input &hellip; ok
to_roman should fail with non-integer input &hellip; ok
to_roman should fail with large input &hellip; ok
to_roman should fail with 0 input &hellip; ok</p>

<p>======================================================================
FAIL: from_roman should fail with blank string</p>

<p>Traceback (most recent call last):
File &ldquo;romantest8.py&rdquo;, line 117, in test_blank
self.assertRaises(roman8.InvalidRomanNumeralError, roman8.from_roman, &ldquo;)
AssertionError: InvalidRomanNumeralError not raised by from_roman</p>

<p>Ran 11 tests in 0.171s</p>

<p>FAILED (failures=1)</p>

<p>Now you can fix the bug.
def from_roman(s):</p>

<p>&rdquo;&lsquo;convert Roman numeral to integer&rdquo;&rsquo; if not s: . raise InvalidRomanNumeralError(&lsquo;Input can not be blank&rsquo;) if not re.search(romanNumeralPattern, s): raise InvalidRomanNumeralError(&lsquo;Invalid Roman numeral: {}&lsquo;.format(s)) .
result = 0
index = 0
for numeral, integer in romanNumeralMap:</p>

<p>while s[index:index+len(numeral)] == numeral:
result += integer
index += len(numeral)</p>

<p>return result</p>

<ol>
<li><p>Only two lines of code are required: an explicit check for an empty string, and a raise statement.</p></li>

<li><p>I don’t think I’ve mentioned this yet anywhere in this book, so let this serve as your final lesson in string
formatting. Starting in Python 3.1, you can skip the numbers when using positional indexes in a format specifier. That is, instead of using the format specifier {0} to refer to the first parameter to the format() method, you can simply use {} and Python will fill in the proper positional index for you. This works for any number of arguments; the first {} is {0}, the second {} is {1}, and so forth.</p></li>
</ol>

<p>you@localhost:~/diveintopython3/examples$ python3 romantest8.py -v
from_roman should fail with blank string &hellip; ok .
from_roman should fail with malformed antecedents &hellip; ok
from_roman should fail with repeated pairs of numerals &hellip; ok
from_roman should fail with too many repeated numerals &hellip; ok
from_roman should give known result with known input &hellip; ok
to_roman should give known result with known input &hellip; ok
from_roman(to_roman(n))==n for all n &hellip; ok
to_roman should fail with negative input &hellip; ok
to_roman should fail with non-integer input &hellip; ok
to_roman should fail with large input &hellip; ok
to_roman should fail with 0 input &hellip; ok</p>

<p>Ran 11 tests in 0.156s</p>

<p>OK .
1. The blank string test case now passes, so the bug is fixed.</p>

<ol>
<li>All the other test cases still pass, which means that this bug fix didn’t break anything else. Stop coding.</li>
</ol>

<p>Coding this way does not make fixing bugs any easier. Simple bugs (like this one) require simple test cases; complex bugs will require complex test cases. In a testing-centric environment, it may seem like it takes longer to fix a bug, since you need to articulate in code exactly what the bug is (to write the test case), then fix the bug itself. Then if the test case doesn’t pass right away, you need to figure out whether the fix was wrong, or whether the test case itself has a bug in it. However, in the long run, this back-and-forth between test code and code tested pays for itself, because it makes it more likely that bugs are fixed correctly the first time. Also, since you can easily re-run all the test cases along with your new one, you are much less likely to break old code when fixing new code. Today’s unit test is tomorrow’s regression test.
.</p>

<p>10.2. HANDLING CHANGING REQUIREMENTS
Despite your best efforts to pin your customers to the ground and extract exact requirements from them on pain of horrible nasty things involving scissors and hot wax, requirements will change. Most customers don’t know what they want until they see it, and even if they do, they aren’t that good at articulating what they want precisely enough to be useful. And even if they do, they’ll want more in the next release anyway. So be prepared to update your test cases as requirements change.
Suppose, for instance, that you wanted to expand the range of the Roman numeral conversion functions. Normally, no character in a Roman numeral can be repeated more than three times in a row. But the Romans were willing to make an exception to that rule by having 4 M characters in a row to represent 4000. If you make this change, you’ll be able to expand the range of convertible numbers from 1..3999 to 1..4999. But first, you need to make some changes to your test cases.
class KnownValues(unittest.TestCase):</p>

<p>known_values = ( (1, &lsquo;I&rsquo;),
.
.
.</p>

<p>(3999, &lsquo;MMMCMXCIX&rsquo;),
(4000, &lsquo;MMMM&rsquo;), .
(4500, &lsquo;MMMMD&rsquo;),
(4888, &lsquo;MMMMDCCCLXXXVIII&rsquo;),
(4999, &lsquo;MMMMCMXCIX&rsquo;) )</p>

<p>class ToRomanBadInput(unittest.TestCase):</p>

<p>def test_too_large(self):
&ldquo;&lsquo;to_roman should fail with large input&rdquo;&rsquo;
self.assertRaises(roman8.OutOfRangeError, roman8.to_roman, 5000) .</p>

<p>.
.
.</p>

<p>class FromRomanBadInput(unittest.TestCase):</p>

<p>def test_too_many_repeated_numerals(self):
&ldquo;&lsquo;from_roman should fail with too many repeated numerals&rdquo;&rsquo;
for s in (&lsquo;MMMMM&rsquo;, &lsquo;DD&rsquo;, &lsquo;CCCC&rsquo;, &rsquo;LL&rsquo;, &lsquo;XXXX&rsquo;, &lsquo;VV&rsquo;, &lsquo;IIII&rsquo;): .</p>

<p>self.assertRaises(roman8.InvalidRomanNumeralError, roman8.from_roman, s)</p>

<p>.
.
.</p>

<p>class RoundtripCheck(unittest.TestCase):</p>

<p>def test_roundtrip(self):
&ldquo;&lsquo;from_roman(to_roman(n))==n for all n&rdquo;&rsquo;
for integer in range(1, 5000): .</p>

<p>numeral = roman8.to_roman(integer)
result = roman8.from_roman(numeral)
self.assertEqual(integer, result)</p>

<ol>
<li><p>The existing known values don’t change (they’re all still reasonable values to test), but you need to add a few more in the 4000 range. Here I’ve included 4000 (the shortest), 4500 (the second shortest), 4888 (the longest), and 4999 (the largest).</p></li>

<li><p>The definition of “large input” has changed. This test used to call to_roman() with 4000 and expect an error; now that 4000-4999 are good values, you need to bump this up to 5000.</p></li>

<li><p>The definition of “too many repeated numerals” has also changed. This test used to call from_roman() with &lsquo;MMMM&rsquo; and expect an error; now that MMMM is considered a valid Roman numeral, you need to bump this up to &lsquo;MMMMM&rsquo;.</p></li>

<li><p>The sanity check loops through every number in the range, from 1 to 3999. Since the range has now expanded, this for loop need to be updated as well to go up to 4999.</p></li>
</ol>

<p>Now your test cases are up to date with the new requirements, but your code is not, so you expect several of the test cases to fail.
you@localhost:~/diveintopython3/examples$ python3 romantest9.py -v</p>

<p>from_roman should fail with blank string &hellip; ok<br />
from_roman should fail with malformed antecedents &hellip; ok<br />
from_roman should fail with non-string input &hellip; ok<br />
from_roman should fail with repeated pairs of numerals &hellip; ok<br />
from_roman should fail with too many repeated numerals &hellip; ok<br />
from_roman should give known result with known input &hellip; ERROR  .<br />
to_roman should give known result with known input &hellip; ERROR  .<br />
from_roman(to_roman(n))==n for all n &hellip; ERROR  .<br />
to_roman should fail with negative input &hellip; ok<br />
to_roman should fail with non-integer input &hellip; ok<br />
to_roman should fail with large input &hellip; ok<br />
to_roman should fail with 0 input &hellip; ok</p>

<p>======================================================================
ERROR: from_roman should give known result with known input</p>

<p>Traceback (most recent call last):
File &ldquo;romantest9.py&rdquo;, line 82, in test_from_roman_known_values
result = roman9.from_roman(numeral)
File &ldquo;C:\home\diveintopython3\examples\roman9.py&rdquo;, line 60, in from_roman
raise InvalidRomanNumeralError(&lsquo;Invalid Roman numeral: {0}&lsquo;.format(s))
roman9.InvalidRomanNumeralError: Invalid Roman numeral: MMMM</p>

<p>======================================================================
ERROR: to_roman should give known result with known input</p>

<p>Traceback (most recent call last):
File &ldquo;romantest9.py&rdquo;, line 76, in test_to_roman_known_values
result = roman9.to_roman(integer)
File &ldquo;C:\home\diveintopython3\examples\roman9.py&rdquo;, line 42, in to_roman
raise OutOfRangeError(&lsquo;number out of range (must be 0..3999)&rsquo;)
roman9.OutOfRangeError: number out of range (must be 0..3999)</p>

<p>======================================================================
ERROR: from_roman(to_roman(n))==n for all n</p>

<p>Traceback (most recent call last):
File &ldquo;romantest9.py&rdquo;, line 131, in testSanity
numeral = roman9.to_roman(integer)
File &ldquo;C:\home\diveintopython3\examples\roman9.py&rdquo;, line 42, in to_roman
raise OutOfRangeError(&lsquo;number out of range (must be 0..3999)&rsquo;)
roman9.OutOfRangeError: number out of range (must be 0..3999)</p>

<p>Ran 12 tests in 0.171s</p>

<p>FAILED (errors=3)</p>

<ol>
<li><p>The from_roman() known values test will fail as soon as it hits &lsquo;MMMM&rsquo;, because from_roman() still thinks this is an invalid Roman numeral.</p></li>

<li><p>The to_roman() known values test will fail as soon as it hits 4000, because to_roman() still thinks this is out of range.</p></li>

<li><p>The roundtrip check will also fail as soon as it hits 4000, because to_roman() still thinks this is out of range.</p></li>
</ol>

<p>Now that you have test cases that fail due to the new requirements, you can think about fixing the code to bring it in line with the test cases. (When you first start coding unit tests, it might feel strange that the code being tested is never “ahead” of the test cases. While it’s behind, you still have some work to do, and as soon as it catches up to the test cases, you stop coding. After you get used to it, you’ll wonder how you ever programmed without tests.)
roman_numeral_pattern = re.compile(&ldquo;&rsquo;</p>

<p>^  # beginning of string<br />
M{0,4}  # thousands - 0 to 4 Ms  .<br />
(CM|CD|D?C{0,3})  # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),</p>

<h1 id="or-500-800-d-followed-by-0-to-3-cs-2">or 500-800 (D, followed by 0 to 3 Cs)</h1>

<p>(XC|XL|L?X{0,3})  # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),</p>

<h1 id="or-50-80-l-followed-by-0-to-3-xs-2">or 50-80 (L, followed by 0 to 3 Xs)</h1>

<p>(IX|IV|V?I{0,3})  # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),</p>

<h1 id="or-5-8-v-followed-by-0-to-3-is-2">or 5-8 (V, followed by 0 to 3 Is)</h1>

<p>$  # end of string<br />
&rdquo;&lsquo;, re.VERBOSE)</p>

<p>def to_roman(n): &ldquo;&lsquo;convert integer to Roman numeral&rdquo;&rsquo; if not (0 &lt; n &lt; 5000): .
raise OutOfRangeError(&lsquo;number out of range (must be 1..4999)&rsquo;)
if not isinstance(n, int):
raise NotIntegerError(&lsquo;non-integers can not be converted&rsquo;)</p>

<p>result = &ldquo;
for numeral, integer in roman_numeral_map:</p>

<p>while n &gt;= integer:
result += numeral
n -= integer</p>

<p>return result</p>

<p>def from_roman(s):
.
.
.</p>

<ol>
<li>You don’t need to make any changes to the from_roman() function at all. The only change is to roman_numeral_pattern. If you look closely, you’ll notice that I changed the maximum number of optional M characters from 3 to 4 in the first section of the regular expression. This will allow the Roman numeral</li>
</ol>

<p>equivalents of 4999 instead of 3999. The actual from_roman() function is completely generic; it just looks for repeated Roman numeral characters and adds them up, without caring how many times they repeat. The only reason it didn’t handle &lsquo;MMMM&rsquo; before is that you explicitly stopped it with the regular expression pattern matching.</p>

<ol>
<li>The to_roman() function only needs one small change, in the range check. Where you used to check 0&lt;n &lt; 4000, you now check 0 &lt; n &lt; 5000. And you change the error message that you raise to reflect the new acceptable range (1..4999 instead of 1..3999). You don’t need to make any changes to the rest of the function; it handles the new cases already. (It merrily adds &rsquo;M&rsquo; for each thousand that it finds; given 4000, it will spit out &lsquo;MMMM&rsquo;. The only reason it didn’t do this before is that you explicitly stopped it with the range check.)</li>
</ol>

<p>You may be skeptical that these two small changes are all that you need. Hey, don’t take my word for it; see for yourself.
you@localhost:~/diveintopython3/examples$ python3 romantest9.py -v
from_roman should fail with blank string &hellip; ok
from_roman should fail with malformed antecedents &hellip; ok
from_roman should fail with non-string input &hellip; ok
from_roman should fail with repeated pairs of numerals &hellip; ok
from_roman should fail with too many repeated numerals &hellip; ok
from_roman should give known result with known input &hellip; ok
to_roman should give known result with known input &hellip; ok
from_roman(to_roman(n))==n for all n &hellip; ok
to_roman should fail with negative input &hellip; ok
to_roman should fail with non-integer input &hellip; ok
to_roman should fail with large input &hellip; ok
to_roman should fail with 0 input &hellip; ok</p>

<p>Ran 12 tests in 0.203s</p>

<p>OK .
1.  All the test cases pass. Stop coding.
Comprehensive unit testing means never having to rely on a programmer who says “Trust me.”
.</p>

<p>10.3. REFACTORING
The best thing about comprehensive unit testing is not the feeling you get when all your test cases finally pass, or even the feeling you get when someone else blames you for breaking their code and you can actually prove that you didn’t. The best thing about unit testing is that it gives you the freedom to refactor mercilessly.
Refactoring is the process of taking working code and making it work better. Usually, “better” means “faster”, although it can also mean “using less memory”, or “using less disk space”, or simply “more elegantly”. Whatever it means to you, to your project, in your environment, refactoring is important to the long-term health of any program.
Here, “better” means both “faster” and “easier to maintain.” Specifically, the from_roman() function is slower and more complex than I’d like, because of that big nasty regular expression that you use to validate Roman numerals. Now, you might think, “Sure, the regular expression is big and hairy, but how else am I supposed to validate that an arbitrary string is a valid a Roman numeral?”
Answer: there’s only 5000 of them; why don’t you just build a lookup table? This idea gets even better when you realize that you don’t need to use regular expressions at all. As you build the lookup table for converting integers to Roman numerals, you can build the reverse lookup table to convert Roman numerals to integers. By the time you need to check whether an arbitrary string is a valid Roman numeral, you will have collected all the valid Roman numerals. “Validating” is reduced to a single dictionary lookup.
And best of all, you already have a complete set of unit tests. You can change over half the code in the module, but the unit tests will stay the same. That means you can prove — to yourself and to others — that the new code works just as well as the original.
class OutOfRangeError(ValueError): pass</p>

<p>class NotIntegerError(ValueError): pass
class InvalidRomanNumeralError(ValueError): pass</p>

<p>roman_numeral_map = ((&rsquo;M&rsquo;, 1000),
(&lsquo;CM&rsquo;, 900),
(&rsquo;D&rsquo;, 500),
(&lsquo;CD&rsquo;, 400),
(&lsquo;C&rsquo;, 100),
(&lsquo;XC&rsquo;, 90),
(&lsquo;L&rsquo;, 50),
(&lsquo;XL&rsquo;, 40),
(&lsquo;X&rsquo;, 10),
(&lsquo;IX&rsquo;, 9),
(&lsquo;V&rsquo;, 5),
(&lsquo;IV&rsquo;, 4),
(&lsquo;I&rsquo;, 1))</p>

<p>to_roman_table = [ None ]
from_roman_table = {}</p>

<p>def to_roman(n):
&ldquo;&lsquo;convert integer to Roman numeral&rdquo;&rsquo;
if not (0 &lt; n &lt; 5000):
raise OutOfRangeError(&lsquo;number out of range (must be 1..4999)&rsquo;)
if int(n) != n:
raise NotIntegerError(&lsquo;non-integers can not be converted&rsquo;)
return to_roman_table[n]</p>

<p>def from_roman(s):
&ldquo;&lsquo;convert Roman numeral to integer&rdquo;&rsquo;
if not isinstance(s, str):
raise InvalidRomanNumeralError(&lsquo;Input must be a string&rsquo;)
if not s:</p>

<p>raise InvalidRomanNumeralError(&lsquo;Input can not be blank&rsquo;)
if s not in from_roman_table:
raise InvalidRomanNumeralError(&lsquo;Invalid Roman numeral: {0}&lsquo;.format(s))
return from_roman_table[s]</p>

<p>def build_lookup_tables():</p>

<p>def to_roman(n):
result = &ldquo;
for numeral, integer in roman_numeral_map:</p>

<p>if n &gt;= integer:
result = numeral
n -= integer
break</p>

<p>if n &gt; 0:
result += to_roman_table[n]
return result</p>

<p>for integer in range(1, 5000):
roman_numeral = to_roman(integer)
to_roman_table.append(roman_numeral)
from_roman_table[roman_numeral] = integer</p>

<p>build_lookup_tables()</p>

<p>Let’s break that down into digestable pieces. Arguably, the most important line is the last one:
build_lookup_tables()</p>

<p>You will note that is a function call, but there’s no if statement around it. This is not an if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo; block; it gets called when the module is imported. (It is important to understand that modules are only imported once, then cached. If you import an already-imported module, it does nothing. So this code will only get called the first time you import this module.)
So what does the build_lookup_tables() function do? I’m glad you asked.
to_roman_table = [ None ]</p>

<p>from_roman_table = {}
.
.
.
def build_lookup_tables():</p>

<p>def to_roman(n): .
result = &ldquo;
for numeral, integer in roman_numeral_map:</p>

<p>if n &gt;= integer:
result = numeral
n -= integer
break</p>

<p>if n &gt; 0:
result += to_roman_table[n]
return result</p>

<p>for integer in range(1, 5000):
roman_numeral = to_roman(integer) .
to_roman_table.append(roman_numeral) .
from_roman_table[roman_numeral] = integer</p>

<ol>
<li><p>This is a clever bit of programming… perhaps too clever. The to_roman() function is defined above; it looks up values in the lookup table and returns them. But the build_lookup_tables() function redefines the to_roman() function to actually do work (like the previous examples did, before you added a lookup table). Within the build_lookup_tables() function, calling to_roman() will call this redefined version. Once the build_lookup_tables() function exits, the redefined version disappears — it is only defined in the local scope of the build_lookup_tables() function.</p></li>

<li><p>This line of code will call the redefined to_roman() function, which actually calculates the Roman numeral.</p></li>

<li><p>Once you have the result (from the redefined to_roman() function), you add the integer and its Roman numeral equivalent to both lookup tables.</p></li>
</ol>

<p>Once the lookup tables are built, the rest of the code is both easy and fast.
def to_roman(n):
&ldquo;&lsquo;convert integer to Roman numeral&rdquo;&rsquo;
if not (0 &lt; n &lt; 5000):</p>

<p>raise OutOfRangeError(&lsquo;number out of range (must be 1..4999)&rsquo;) if int(n) != n: raise NotIntegerError(&lsquo;non-integers can not be converted&rsquo;) return to_roman_table[n] .
def from_roman(s):
&ldquo;&lsquo;convert Roman numeral to integer&rdquo;&rsquo;
if not isinstance(s, str):</p>

<p>raise InvalidRomanNumeralError(&lsquo;Input must be a string&rsquo;) if not s: raise InvalidRomanNumeralError(&lsquo;Input can not be blank&rsquo;) if s not in from_roman_table: raise InvalidRomanNumeralError(&lsquo;Invalid Roman numeral: {0}&lsquo;.format(s)) return from_roman_table[s] .
1.  After doing the same bounds checking as before, the to_roman() function simply finds the appropriate value in the lookup table and returns it.</p>

<ol>
<li>Similarly, the from_roman() function is reduced to some bounds checking and one line of code. No more regular expressions. No more looping. O(1) conversion to and from Roman numerals.</li>
</ol>

<p>But does it work? Why yes, yes it does. And I can prove it.
you@localhost:~/diveintopython3/examples$ python3 romantest10.py -v
from_roman should fail with blank string &hellip; ok
from_roman should fail with malformed antecedents &hellip; ok
from_roman should fail with non-string input &hellip; ok
from_roman should fail with repeated pairs of numerals &hellip; ok
from_roman should fail with too many repeated numerals &hellip; ok
from_roman should give known result with known input &hellip; ok
to_roman should give known result with known input &hellip; ok
from_roman(to_roman(n))==n for all n &hellip; ok
to_roman should fail with negative input &hellip; ok
to_roman should fail with non-integer input &hellip; ok
to_roman should fail with large input &hellip; ok
to_roman should fail with 0 input &hellip; ok</p>

<p>Ran 12 tests in 0.031s  .
OK</p>

<ol>
<li>Not that you asked, but it’s fast, too! Like, almost 10× as fast. Of course, it’s not entirely a fair comparison, because this version takes longer to import (when it builds the lookup tables). But since the import is only done once, the startup cost is amortized over all the calls to the to_roman() and from_roman() functions. Since the tests make several thousand function calls (the roundtrip test alone makes 10,000), this savings adds up in a hurry!
The moral of the story?
•   Simplicity is a virtue.</li>
</ol>

<p>•   Especially when regular expressions are involved.</p>

<p>•   Unit tests can give you the confidence to do large-scale refactoring.</p>

<p>.</p>

<p>10.4. SUMMARY
Unit testing is a powerful concept which, if properly implemented, can both reduce maintenance costs and increase flexibility in any long-term project. It is also important to understand that unit testing is not a panacea, a Magic Problem Solver, or a silver bullet. Writing good test cases is hard, and keeping them up to date takes discipline (especially when customers are screaming for critical bug fixes). Unit testing is not a replacement for other forms of testing, including functional testing, integration testing, and user acceptance testing. But it is feasible, and it does work, and once you’ve seen it work, you’ll wonder how you ever got along without it.
These few chapters have covered a lot of ground, and much of it wasn’t even Python-specific. There are unit testing frameworks for many languages, all of which require you to understand the same basic concepts:
•   Designing test cases that are specific, automated, and independent</p>

<p>•   Writing test cases before the code they are testing</p>

<p>•   Writing tests that test good input and check for proper results</p>

<p>•   Writing tests that test bad input and check for proper failure responses</p>

<p>•   Writing and updating test cases to reflect new requirements</p>

<p>•   Refactoring mercilessly to improve performance, scalability, readability, maintainability, or whatever other -ility you’re lacking</p>

<p>CHAPTER 11. FILES</p>

<p>. A nine mile walk is no joke, especially in the rain. .
—   Harry Kemelman, The Nine Mile Walk
11.1. DIVING IN
My Windows laptop had 38,493 files before I installed a single application. Installing Python 3 added almost 3,000 files to that total. Files are the primary storage paradigm of every major operating system; the concept is so ingrained that most people would have trouble imagining
an
alternative. Your computer is, metaphorically speaking, drowning in files.
11.2. READING FROM TEXT FILES
Before you can read from a file, you need to open it. Opening a file in Python couldn’t be easier:
a_file = open(&lsquo;examples/chinese.txt&rsquo;, encoding=&lsquo;utf-8&rsquo;)</p>

<p>Python has a built-in open() function, which takes a filename as an argument. Here the filename is
&lsquo;examples/chinese.txt&rsquo;. There are five interesting things about this filename:</p>

<ol>
<li><p>It’s not just the name of a file; it’s a combination of a directory path and a filename. A hypothetical file-opening function could have taken two arguments — a directory path and a filename — but the open() function only takes one. In Python, whenever you need a “filename,” you can include some or all of a directory path as well.</p></li>

<li><p>The directory path uses a forward slash, but I didn’t say what operating system I was using. Windows uses backward slashes to denote subdirectories, while Mac OS X and Linux use forward slashes. But in Python, forward slashes always Just Work, even on Windows.</p></li>

<li><p>The directory path does not begin with a slash or a drive letter, so it is called a relative path. Relative to what, you might ask? Patience, grasshopper.</p></li>

<li><p>It’s a string. All modern operating systems (even Windows!) use Unicode to store the names of files and directories. Python 3 fully supports non-ASCII pathnames.</p></li>

<li><p>It doesn’t need to be on your local disk. You might have a network drive mounted. That “file” might be a figment of an
entirely
virtual
filesystem. If your computer considers it a file and can access it as a file, Python can open it.</p></li>
</ol>

<p>But that call to the open() function didn’t stop at the filename. There’s another argument, called encoding. Oh dear, that
sounds
dreadfully
familiar.
11.2.1. CHARACTER ENCODING REARS ITS UGLY HEAD
Bytes are bytes; characters
are
an
abstraction. A string is a sequence of Unicode characters. But a file on disk is not a sequence of Unicode characters; a file on disk is a sequence of bytes. So if you read a “text file” from disk, how does Python convert that sequence of bytes into a sequence of characters? It decodes the bytes according to a specific character encoding algorithm and returns a sequence of Unicode characters (otherwise known as a string).</p>

<h1 id="this-example-was-created-on-windows-other-platforms-may">This example was created on Windows. Other platforms may</h1>

<h1 id="behave-differently-for-reasons-outlined-below">behave differently, for reasons outlined below.</h1>

<blockquote>
<blockquote>
<blockquote>
<p>file = open(&lsquo;examples/chinese.txt&rsquo;)
a_string = file.read()</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
File &ldquo;C:\Python31\lib\encodings\cp1252.py&rdquo;, line 23, in decode</p>

<p>return codecs.charmap_decode(input,self.errors,decoding_table)[0]
UnicodeDecodeError: &lsquo;charmap&rsquo; codec can&rsquo;t decode byte 0x8f in position 28: character maps to <undefined></p>

<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>

<p>What just happened? You didn’t specify a character encoding, so Python is forced to use the default encoding. What’s the default encoding? If you look closely at the traceback, you can see that it’s dying in cp1252.py, meaning that Python is using CP-1252 as the default encoding here. (CP-1252 is a common encoding on computers running Microsoft Windows.) The CP-1252 character set doesn’t support the characters that are in this file, so the read fails with an ugly UnicodeDecodeError.
But wait, it’s worse than that! The default encoding is platform-dependent, so this code might work on your computer (if your default encoding is UTF-8), but then it will fail when you distribute it to someone else (whose default encoding is different, like CP-1252).</p>

<p>. If you need to get the default character encoding, import the locale module and call locale.getpreferredencoding(). On my Windows laptop, it returns &lsquo;cp1252&rsquo;, but on my Linux box upstairs, it returns &lsquo;UTF8&rsquo;. I can’t even maintain consistency in my own house! Your results may be different (even on Windows) depending on which version of your operating system you have installed and how your regional/language settings are configured. This is why it’s so important to specify the encoding every time you open a file.
11.2.2. STREAM OBJECTS
So far, all we know is that Python has a built-in function called open(). The open() function returns a stream object, which has methods and attributes for getting information about and manipulating a stream of characters.
&gt;&gt;&gt; a_file = open(&lsquo;examples/chinese.txt&rsquo;, encoding=&lsquo;utf-8&rsquo;)</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_file.name .
&lsquo;examples/chinese.txt&rsquo;
a_file.encoding .
&lsquo;utf-8&rsquo;
a_file.mode .
&lsquo;r&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li>The name attribute reflects the name you passed in to the open() function when you opened the file. It is not normalized to an absolute pathname.</li>
<li>Likewise, encoding attribute reflects the encoding you passed in to the open() function. If you didn’t specify the encoding when you opened the file (bad developer!) then the encoding attribute will reflect locale.getpreferredencoding().</li>
<li>The mode attribute tells you in which mode the file was opened. You can pass an optional mode parameter to the open() function. You didn’t specify a mode when you opened this file, so Python defaults to &lsquo;r&rsquo;, which means “open for reading only, in text mode.” As you’ll see later in this chapter, the file mode serves several purposes; different modes let you write to a file, append to a file, or open a file in binary mode (in which you deal with bytes instead of strings).</li>
</ol>

<p>. The documentation
for
the
open() function
lists all the possible file modes.
11.2.3. READING DATA FROM A TEXT FILE
After you open a file for reading, you’ll probably want to read from it at some point.
&gt;&gt;&gt; a_file = open(&lsquo;examples/chinese.txt&rsquo;, encoding=&lsquo;utf-8&rsquo;)
&gt;&gt;&gt; a_file.read() .
&lsquo;Dive Into Python &hellip;&hellip;&hellip;&hellip;.. Python ..\n&rsquo;
&gt;&gt;&gt; a_file.read() .
&ldquo;</p>

<ol>
<li><p>Once you open a file (with the correct encoding), reading from it is just a matter of calling the stream
object’s read() method. The result is a string.</p></li>

<li><p>Perhaps somewhat surprisingly, reading the file again does not raise an exception. Python does not consider reading past end-of-file to be an error; it simply returns an empty string.</p></li>
</ol>

<p>What if you want to re-read a file?</p>

<h1 id="continued-from-the-previous-example-3">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>a_file.read() .
&ldquo;
a_file.seek(0) .
0
a_file.read(16) .
&lsquo;Dive Into Python&rsquo;
a_file.read(1) .
&lsquo; &rsquo;
a_file.read(1)
&lsquo;.&rsquo;
a_file.tell() .
20</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>Since you’re still at the end of the file, further calls to the stream object’s read() method simply return an
empty string.</p></li>

<li><p>The seek() method moves to a specific byte position in a file.</p></li>

<li><p>The read() method can take an optional parameter, the number of characters to read.</p></li>

<li><p>If you like, you can even read one character at a time.</p></li>

<li><p>16+1+1 =…20?</p></li>
</ol>

<p>Let’s try that again.</p>

<h1 id="continued-from-the-previous-example-4">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>a_file.seek(17) .
17
a_file.read(1) .
&lsquo;.&rsquo;
a_file.tell() .
20</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li>Move to the 17th byte.</li>
<li>Read one character.</li>
<li>Now you’re on the 20th byte.</li>
</ol>

<p>Do you see it yet? The seek() and tell() methods always count bytes, but since you opened this file as text, the read() method counts characters. Chinese characters require
multiple
bytes
to
encode
in
UTF-8. The English characters in the file only require one byte each, so you might be misled into thinking that the seek() and read() methods are counting the same thing. But that’s only true for some characters.
But wait, it gets worse!
&gt;&gt;&gt; a_file.seek(18) .
18
&gt;&gt;&gt; a_file.read(1) .</p>

<p>Traceback (most recent call last):
File &ldquo;<pyshell#12>&rdquo;, line 1, in <module>
a_file.read(1)
File &ldquo;C:\Python31\lib\codecs.py&rdquo;, line 300, in decode
(result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: &lsquo;utf8&rsquo; codec can&rsquo;t decode byte 0x98 in position 0: unexpected code byte</p>

<ol>
<li>Move to the 18th byte and try to read one character.</li>
<li>Why does this fail? Because there isn’t a character at the 18th byte. The nearest character starts at the 17th byte (and goes for three bytes). Trying to read a character from the middle will fail with a UnicodeDecodeError.</li>
</ol>

<p>11.2.4. CLOSING FILES</p>

<p>Open files consume system resources, and depending on the file mode, other programs may not be able to access them. It’s important to close files as soon as you’re finished with them.</p>

<h1 id="continued-from-the-previous-example-5">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>a_file.close()</p>
</blockquote>
</blockquote>
</blockquote>

<p>Well that was anticlimactic.
The stream object a_file still exists; calling its close() method doesn’t destroy the object itself. But it’s not terribly useful.</p>

<h1 id="continued-from-the-previous-example-6">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>a_file.read() .</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):
File &ldquo;<pyshell#24>&rdquo;, line 1, in <module>
a_file.read()
ValueError: I/O operation on closed file.</p>

<blockquote>
<blockquote>
<blockquote>
<p>a_file.seek(0) .
Traceback (most recent call last):
File &ldquo;<pyshell#25>&rdquo;, line 1, in <module>
a_file.seek(0)
ValueError: I/O operation on closed file.</p>

<p>a_file.tell() .
Traceback (most recent call last):
File &ldquo;<pyshell#26>&rdquo;, line 1, in <module>
a_file.tell()
ValueError: I/O operation on closed file.</p>

<p>a_file.close() .
a_file.closed .
True</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li>You can’t read from a closed file; that raises an IOError exception.</li>

<li><p>You can’t seek in a closed file either.</p></li>

<li><p>There’s no current position in a closed file, so the tell() method also fails.</p></li>

<li><p>Perhaps surprisingly, calling the close() method on a stream object whose file has been closed does not raise an exception. It’s just a no-op.</p></li>

<li><p>Closed stream objects do have one useful attribute: the closed attribute will confirm that the file is closed.</p></li>
</ol>

<p>11.2.5. CLOSING FILES AUTOMATICALLY
Stream objects have an explicit close() method, but
what happens if your code has a bug and crashes before
you call close()? That file could theoretically stay open
for much longer than necessary. While you’re debugging
on your local computer, that’s not a big deal. On a
production server, maybe it is.</p>

<p>Python 2 had a solution for this: the try..finally
block. That still works in Python 3, and you may see it
in other people’s code or in older code that was ported</p>

<p>to
Python
3. But Python 2.6 introduced a cleaner
solution, which is now the preferred solution in Python</p>

<p>3: the with statement.</p>

<p>with open(&lsquo;examples/chinese.txt&rsquo;, encoding=&lsquo;utf-8&rsquo;) as a_file:</p>

<p>a_file.seek(17)</p>

<p>a_character = a_file.read(1)</p>

<p>print(a_character)</p>

<p>This code calls open(), but it never calls a_file.close(). The with statement starts a code block, like an if statement or a for loop. Inside this code block, you can use the variable a_file as the stream object returned from the call to open(). All the regular stream object methods are available — seek(), read(), whatever you need. When the with block ends, Python calls a_file.close() automatically.
Here’s the kicker: no matter how or when you exit the with block, Python will close that file… even if you “exit” it via an unhandled exception. That’s right, even if your code raises an exception and your entire program comes to a screeching halt, that file will get closed. Guaranteed.
. In technical terms, the with statement creates a runtime context. In these examples,
the stream object acts as a context manager. Python creates the stream object
a_file and tells it that it is entering a runtime context. When the with code block
is completed, Python tells the stream object that it is exiting the runtime context,
and the stream object calls its own close() method. See Appendix
B,
“Classes
That</p>

<p>Can
Be
Used
in
a
with Block”
for details.</p>

<p>There’s nothing file-specific about the with statement; it’s just a generic framework for creating runtime contexts and telling objects that they’re entering and exiting a runtime context. If the object in question is a stream object, then it does useful file-like things (like closing the file automatically). But that behavior is defined in the stream object, not in the with statement. There are lots of other ways to use context managers that have nothing to do with files. You can even create your own, as you’ll see later in this chapter.
11.2.6. READING DATA ONE LINE AT A TIME
A “line” of a text file is just what you think it is — you type a few words and press ENTER, and now you’re on a new line. A line of text is a sequence of characters delimited by… what exactly? Well, it’s complicated, because text files can use several different characters to mark the end of a line. Every operating system has its own convention. Some use a carriage return character, others use a line feed character, and some use both characters at the end of every line.
Now breathe a sigh of relief, because Python handles line endings automatically by default. If you say, “I want to read this text file one line at a time,” Python will figure out which kind of line ending the text file uses and and it will all Just Work.
.</p>

<p>If you need fine-grained control over what’s considered a line ending, you can pass the optional newline parameter to the open() function. See the
open() function
documentation
for all the gory details.
So, how do you actually do it? Read a file one line at a time, that is. It’s so simple, it’s beautiful.
line_number = 0
with open(&lsquo;examples/favorite-people.txt&rsquo;, encoding=&lsquo;utf-8&rsquo;) as a_file: .</p>

<p>for a_line in a_file: . line_number += 1 print(&lsquo;{:&gt;4} {}&lsquo;.format(line_number, a_line.rstrip())) .
1.  Using the
with pattern, you safely open the file and let Python close it for you.</p>

<ol>
<li><p>To read a file one line at a time, use a for loop. That’s it. Besides having explicit methods like read(), the stream object is also an iterator which spits out a single line every time you ask for a value.</p></li>

<li><p>Using the
format() string
method, you can print out the line number and the line itself. The format specifier {:&gt;4} means “print this argument right-justified within 4 spaces.” The a_line variable contains the complete line, carriage returns and all. The rstrip() string method removes the trailing whitespace, including the carriage return characters.</p></li>
</ol>

<p>you@localhost:~/diveintopython3$ python3 examples/oneline.py
1 Dora
2 Ethan
3 Wesley
4 John
5 Anne
6 Mike
7 Chris
8 Sarah
9 Alex</p>

<p>10 Lizzie</p>

<p>Did you get this error?
you@localhost:~/diveintopython3$ python3 examples/oneline.py</p>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;examples/oneline.py&rdquo;, line 4, in <module></p>

<p>print(&lsquo;{:&gt;4} {}&lsquo;.format(line_number, a_line.rstrip()))</p>

<p>ValueError: zero length field name in format</p>

<p>If so, you’re probably using Python 3.0. You should really upgrade to Python 3.1.
Python 3.0 supported string formatting, but only with explicitly
numbered
format
specifiers. Python 3.1 allows you to omit the argument indexes in your format specifiers. Here is the Python 3.0-compatible version for comparison:
print(&lsquo;{0
:&gt;4} {1
}&lsquo;.format(line_number, a_line.rstrip()))</p>

<p>.
11.3. WRITING TO TEXT FILES
You can write to files in much the same way that you read from them. First you open a file and get a stream object, then you use methods on the stream object to write data to the file, then you close the file.
To open a file for writing, use the open() function and specify the write mode. There are two file modes for writing:
•   “Write” mode will overwrite the file. Pass mode=&lsquo;w&rsquo; to the open() function.</p>

<p>• “Append” mode will add data to the end of the file. Pass mode=&lsquo;a&rsquo; to the open() function.</p>

<p>Either mode will create the file automatically if it doesn’t already exist, so there’s never a need for any sort of fiddly “if the file doesn’t exist yet, create a new empty file just so you can open it for the first time” function. Just open a file and start writing.
You should always close a file as soon as you’re done</p>

<p>writing to it, to release the file handle and ensure that
the data is actually written to disk. As with reading data from a file, you can call the stream object’s close()
method, or you can use the with statement and let Python close the file for you. I bet you can guess which
technique I recommend.</p>

<blockquote>
<blockquote>
<blockquote>
<p>with open(&lsquo;test.log&rsquo;, mode=&lsquo;w&rsquo;, encoding=&lsquo;utf-8&rsquo;) as a_file: .
&hellip; a_file.write(&lsquo;test succeeded&rsquo;) .
with open(&lsquo;test.log&rsquo;, encoding=&lsquo;utf-8&rsquo;) as a_file:
&hellip; print(a_file.read())
test succeeded
with open(&lsquo;test.log&rsquo;, mode=&lsquo;a&rsquo;, encoding=&lsquo;utf-8&rsquo;) as a_file: .
&hellip; a_file.write(&lsquo;and again&rsquo;)
with open(&lsquo;test.log&rsquo;, encoding=&lsquo;utf-8&rsquo;) as a_file:
&hellip; print(a_file.read())
test succeededand again .</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>You start boldly by creating the new file test.log (or overwriting the existing file), and opening the file for writing. The mode=&lsquo;w&rsquo; parameter means open the file for writing. Yes, that’s all as dangerous as it sounds. I hope you didn’t care about the previous contents of that file (if any), because that data is gone now.</p></li>

<li><p>You can add data to the newly opened file with the write() method of the stream object returned by the open() function. After the with block ends, Python automatically closes the file.</p></li>

<li><p>That was so fun, let’s do it again. But this time, with mode=&lsquo;a&rsquo; to append to the file instead of overwriting it. Appending will never harm the existing contents of the file.</p></li>

<li><p>Both the original line you wrote and the second line you appended are now in the file test.log. Also note that neither carriage returns nor line feeds are included. Since you didn’t write them explicitly to the file either time, the file doesn’t include them. You can write a carriage return with the &lsquo;\r&rsquo; character, and/or a line feed with the &lsquo;\n&rsquo; character. Since you didn’t do either, everything you wrote to the file ended up on one line.</p></li>
</ol>

<p>11.3.1. CHARACTER ENCODING AGAIN
Did you notice the encoding parameter that got passed in to the open() function while you were opening
a
file
for
writing? It’s important; don’t ever leave it out! As you saw in the beginning of this chapter, files don’t contain strings, they contain bytes. Reading a “string” from a text file only works because you told Python what encoding to use to read a stream of bytes and convert it to a string. Writing text to a file presents the same problem in reverse. You can’t write characters to a file; characters
are
an
abstraction. In order to write to the file, Python needs to know how to convert your string into a sequence of bytes. The only way to be sure it’s performing the correct conversion is to specify the encoding parameter when you open the file for writing.
.</p>

<p>11.4. BINARY FILES
Not all files contain text. Some of them contain pictures of my dog.</p>

<blockquote>
<blockquote>
<blockquote>
<p>an_image = open(&lsquo;examples/beauregard.jpg&rsquo;, mode=&lsquo;rb&rsquo;) .
an_image.mode .
&lsquo;rb&rsquo;
an_image.name .
&lsquo;examples/beauregard.jpg&rsquo;
an_image.encoding .</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
AttributeError: &lsquo;_io.BufferedReader&rsquo; object has no attribute &lsquo;encoding&rsquo;</p>

<ol>
<li><p>Opening a file in binary mode is simple but subtle. The only difference from opening it in text mode is that the mode parameter contains a &lsquo;b&rsquo; character.</p></li>

<li><p>The stream object you get from opening a file in binary mode has many of the same attributes, including mode, which reflects the mode parameter you passed into the open() function.</p></li>

<li><p>Binary stream objects also have a name attribute, just like text stream objects.</p></li>

<li><p>Here’s one difference, though: a binary stream object has no encoding attribute. That makes sense, right? You’re reading (or writing) bytes, not strings, so there’s no conversion for Python to do. What you get out of a binary file is exactly what you put into it, no conversion necessary.</p></li>
</ol>

<p>Did I mention you’re reading bytes? Oh yes you are.</p>

<h1 id="continued-from-the-previous-example-7">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>an_image.tell()
0
data = an_image.read(3) .
data
b&rsquo;\xff\xd8\xff&rsquo;
type(data) .
<class 'bytes'>
an_image.tell() .
3
an_image.seek(0)
0
data = an_image.read()
len(data)
3150</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>Like text files, you can read binary files a little bit at a time. But there’s a crucial difference…</p></li>

<li><p>…you’re reading bytes, not strings. Since you opened the file in binary mode, the read() method takes the number of bytes to read, not the number of characters.</p></li>

<li><p>That means that there’s never an
unexpected
mismatch
between the number you passed into the read() method and the position index you get out of the tell() method. The read() method reads bytes, and the seek() and tell() methods track the number of bytes read. For binary files, they’ll always agree.</p></li>
</ol>

<p>.
11.5. STREAM OBJECTS FROM NON-FILE SOURCES
Imagine you’re writing a library, and one of your library functions is going to read some data from a file. The function could simply take a filename as a string, go open the file for reading, read it, and close it before exiting. But you shouldn’t do that. Instead, your API should take an arbitrary stream object.
In the simplest case, a stream object is anything with a read() method which takes an optional size parameter and returns a string. When called with no size parameter, the read() method should read everything there is to read from the input source and return all the data as a single value. When called with a size parameter, it reads that much from the input source and returns that much data. When called again, it picks up where it left off and returns the next chunk of data.</p>

<p>That sounds exactly like the stream object you get from opening a real file. The difference is that you’re not limiting yourself to real files. The input source that’s being “read” could be anything: a web page, a string in memory, even the output of another program. As long as your functions take a stream object and simply call the object’s read() method, you can handle any input source that acts like a file, without specific code to handle each kind of input.
&gt;&gt;&gt; a_string = &lsquo;PapayaWhip is the new black.&rsquo;</p>

<blockquote>
<blockquote>
<blockquote>
<p>import io .
a_file = io.StringIO(a_string) .
a_file.read() .
&lsquo;PapayaWhip is the new black.&rsquo;
a_file.read() .
&ldquo;
a_file.seek(0) .
0
a_file.read(10) .
&lsquo;PapayaWhip&rsquo;
a_file.tell()
10
a_file.seek(18)
18
a_file.read()
&lsquo;new black.&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>The io module defines the StringIO class that you can use to treat a string in memory as a file.</p></li>

<li><p>To create a stream object out of a string, create an instance of the io.StringIO() class and pass it the string you want to use as your “file” data. Now you have a stream object, and you can do all sorts of stream-like things with it.</p></li>

<li><p>Calling the read() method “reads” the entire “file,” which in the case of a StringIO object simply returns the original string.</p></li>

<li><p>Just like a real file, calling the read() method again returns an empty string.</p></li>

<li><p>You can explicitly seek to the beginning of the string, just like seeking through a real file, by using the seek() method of the StringIO object.</p></li>

<li><p>You can also read the string in chunks, by passing a size parameter to the read() method.</p></li>
</ol>

<p>. io.StringIO lets you treat a string as a text file. There’s also a io.BytesIO class,
which lets you treat a byte array as a binary file.
11.5.1. HANDLING COMPRESSED FILES</p>

<p>The Python standard library contains modules that support reading and writing compressed files. There are a number of different compression schemes; the two most popular on non-Windows systems are gzip
and bzip2. (You may have also encountered PKZIP
archives
and GNU
Tar
archives. Python has modules for those, too.)
The gzip module lets you create a stream object for reading or writing a gzip-compressed file. The stream object it gives you supports the read() method (if you opened it for reading) or the write() method (if you opened it for writing). That means you can use the methods you’ve already learned for regular files to directly read or write a gzip-compressed file, without creating a temporary file to store the decompressed data.
As an added bonus, it supports the with statement too, so you can let Python automatically close your gzip­compressed file when you’re done with it.
you@localhost:~$ python3</p>

<blockquote>
<blockquote>
<blockquote>
<p>import gzip
with gzip.open(&lsquo;out.log.gz&rsquo;, mode=&lsquo;wb&rsquo;) as z_file: .
&hellip; z_file.write(&lsquo;A nine mile walk is no joke, especially in the rain.&rsquo;.encode(&lsquo;utf-8&rsquo;))</p>
</blockquote>
</blockquote>
</blockquote>

<p>&hellip;
&gt;&gt;&gt; exit()</p>

<p>you@localhost:~$ ls -l out.log.gz .
-rw-r&ndash;r&ndash;1 mark mark 79 2009-07-19 14:29 out.log.gz
you@localhost:~$ gunzip out.log.gz .
you@localhost:~$ cat out.log .
A nine mile walk is no joke, especially in the rain.</p>

<ol>
<li><p>You should always open gzipped files in binary mode. (Note the &lsquo;b&rsquo; character in the mode argument.)</p></li>

<li><p>I constructed this example on Linux. If you’re not familiar with the command line, this command is showing the “long listing” of the gzip-compressed file you just created in the Python Shell. This listing shows that the file exists (good), and that it is 79 bytes long. That’s actually larger than the string you started with! The gzip</p></li>
</ol>

<p>file format includes a fixed-length header that contains some metadata about the file, so it’s inefficient for extremely small files.</p>

<ol>
<li><p>The gunzip command (pronounced “gee-unzip”) decompresses the file and stores the contents in a new file named the same as the compressed file but without the .gz file extension.</p></li>

<li><p>The cat command displays the contents of a file. This file contains the string you originally wrote directly to the compressed file out.log.gz from within the Python Shell.</p></li>
</ol>

<p>Did you get this error?
&gt;&gt;&gt; with gzip.open(&lsquo;out.log.gz&rsquo;, mode=&lsquo;wb&rsquo;) as z_file:
&hellip; z_file.write(&lsquo;A nine mile walk is no joke, especially in the rain.&rsquo;.encode(&lsquo;utf-8&rsquo;))
&hellip;</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
AttributeError: &lsquo;GzipFile&rsquo; object has no attribute &lsquo;<strong>exit</strong>&lsquo;</p>

<p>If so, you’re probably using Python 3.0. You should really upgrade to Python 3.1.
Python 3.0 had a gzip module, but it did not support using a gzipped-file object as a context manager. Python 3.1 added the ability to use gzipped-file objects in a with statement.
.</p>

<p>11.6. STANDARD INPUT, OUTPUT, AND ERROR
Command-line gurus are already familiar with the concept of standard input, standard output, and standard
error. This section is for the rest of you.
Standard output and standard error (commonly abbreviated stdout and stderr) are pipes that are built into every UNIX-like system, including Mac OS X and Linux. When you call the print() function, the thing you’re printing is sent to the stdout pipe. When your program crashes and prints out a traceback, it goes to the stderr pipe. By default, both of these pipes are just connected to the terminal window where you are</p>

<p>working; when your program prints something, you see the output in your terminal window, and when a program crashes, you see the traceback in your terminal window too. In the graphical Python Shell, the stdout and stderr pipes default to your “Interactive Window”.
&gt;&gt;&gt; for i in range(3):
&hellip; print(&lsquo;PapayaWhip&rsquo;) .
PapayaWhip
PapayaWhip
PapayaWhip
&gt;&gt;&gt; import sys
&gt;&gt;&gt; for i in range(3):
&hellip; sys.stdout.write(&lsquo;is the&rsquo;) .
is theis theis the
&gt;&gt;&gt; for i in range(3):
&hellip; sys.stderr.write(&lsquo;new black&rsquo;) .
new blacknew blacknew black</p>

<ol>
<li>The print() function, in a loop. Nothing surprising here.</li>

<li><p>stdout is defined in the sys module, and it is a stream
object. Calling its write() function will print out whatever string you give it. In fact, this is what the print function really does; it adds a carriage return to the end of the string you’re printing, and calls sys.stdout.write.</p></li>

<li><p>In the simplest case, sys.stdout and sys.stderr send their output to the same place: the Python IDE (if you’re in one), or the terminal (if you’re running Python from the command line). Like standard output, standard error does not add carriage returns for you. If you want carriage returns, you’ll need to write carriage return characters.</p></li>
</ol>

<p>sys.stdout and sys.stderr are stream objects, but they are write-only. Attempting to call their read() method will always raise an IOError.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.stdout.read()</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
IOError: not readable</p>

<p>11.6.1. REDIRECTING STANDARD OUTPUT
sys.stdout and sys.stderr are stream objects, albeit ones that only support writing. But they’re not constants; they’re variables. That means you can assign them a new value — any other stream object — to redirect their output.
import sys</p>

<p>class RedirectStdoutTo:
def <strong>init</strong>(self, out_new):
self.out_new = out_new</p>

<p>def <strong>enter</strong>(self):
self.out_old = sys.stdout
sys.stdout = self.out_new</p>

<p>def <strong>exit</strong>(self, *args):
sys.stdout = self.out_old</p>

<p>print(&lsquo;A&rsquo;)</p>

<p>with open(&lsquo;out.log&rsquo;, mode=&lsquo;w&rsquo;, encoding=&lsquo;utf-8&rsquo;) as a_file, RedirectStdoutTo(a_file):
print(&lsquo;B&rsquo;)</p>

<p>print(&lsquo;C&rsquo;)</p>

<p>Check this out:
you@localhost:~/diveintopython3/examples$ python3 stdout.py
A</p>

<p>you@localhost:~/diveintopython3/examples$ cat out.log
B</p>

<p>Did you get this error?
you@localhost:~/diveintopython3/examples$ python3 stdout.py</p>

<p>File &ldquo;stdout.py&rdquo;, line 15
with open(&lsquo;out.log&rsquo;, mode=&lsquo;w&rsquo;, encoding=&lsquo;utf-8&rsquo;) as a_file, RedirectStdoutTo(a_file):
^
SyntaxError: invalid syntax</p>

<p>If so, you’re probably using Python 3.0. You should really upgrade to Python 3.1.
Python 3.0 supported the with statement, but each statement can only use one context manager. Python 3.1 allows you to chain multiple context managers in a single with statement.
Let’s take the last part first.
print(&lsquo;A&rsquo;)
with open(&lsquo;out.log&rsquo;, mode=&lsquo;w&rsquo;, encoding=&lsquo;utf-8&rsquo;) as a_file, RedirectStdoutTo(a_file):
print(&lsquo;B&rsquo;)
print(&lsquo;C&rsquo;)</p>

<p>That’s a complicated with statement. Let me rewrite it as something more recognizable.
with open(&lsquo;out.log&rsquo;, mode=&lsquo;w&rsquo;, encoding=&lsquo;utf-8&rsquo;) as a_file:
with RedirectStdoutTo(a_file):
print(&lsquo;B&rsquo;)</p>

<p>As the rewrite shows, you actually have two with statements, one nested within the scope of the other. The “outer” with statement should be familiar by now: it opens a UTF-8-encoded text file named out.log for writing and assigns the stream object to a variable named a_file. But that’s not the only thing odd here.
with RedirectStdoutTo(a_file):</p>

<p>Where’s the as clause? The with statement doesn’t actually require one. Just like you can call a function and ignore its return value, you can have a with statement that doesn’t assign the with context to a variable. In this case, you’re only interested in the side effects of the RedirectStdoutTo context.
What are those side effects? Take a look inside the RedirectStdoutTo class. This class is a custom context
manager. Any class can be a context manager by defining two special
methods: <strong>enter</strong>() and <strong>exit</strong>().
class RedirectStdoutTo:</p>

<p>def <strong>init</strong>(self, out_new): .
self.out_new = out_new</p>

<p>def <strong>enter</strong>(self): .
self.out_old = sys.stdout
sys.stdout = self.out_new</p>

<p>def <strong>exit</strong>(self, *args): .
sys.stdout = self.out_old</p>

<ol>
<li><p>The <strong>init</strong>() method is called immediately after an instance is created. It takes one parameter, the stream object that you want to use as standard output for the life of the context. This method just saves the stream object in an instance variable so other methods can use it later.</p></li>

<li><p>The <strong>enter</strong>() method is a special
class
method; Python calls it when entering a context (i.e. at the beginning of the with statement). This method saves the current value of sys.stdout in self.out_old, then redirects standard output by assigning self.out_new to sys.stdout.</p></li>

<li><p>The <strong>exit</strong>() method is another special class method; Python calls it when exiting the context (i.e. at the end of the with statement). This method restores standard output to its original value by assigning the saved self.out_old value to sys.stdout.</p></li>
</ol>

<p>Putting it all together:
print(&lsquo;A&rsquo;)  .
with open(&lsquo;out.log&rsquo;, mode=&lsquo;w&rsquo;, encoding=&lsquo;utf-8&rsquo;) as a_file, RedirectStdoutTo(a_file): . print(&lsquo;B&rsquo;) .
print(&lsquo;C&rsquo;)  .
1.  This will print to the IDE “Interactive Window” (or the terminal, if running the script from the command line).</p>

<ol>
<li><p>This with statement
takes a comma-separated list of contexts. The comma-separated list acts like a series of nested with blocks. The first context listed is the “outer” block; the last one listed is the “inner” block. The first context opens a file; the second context redirects sys.stdout to the stream object that was created in the first context.</p></li>

<li><p>Because this print() function is executed with the context created by the with statement, it will not print to the screen; it will write to the file out.log.</p></li>

<li><p>The with code block is over. Python has told each context manager to do whatever it is they do upon exiting a context. The context managers form a last-in-first-out stack. Upon exiting, the second context changed sys.stdout back to its original value, then the first context closed the file named out.log. Since standard output has been restored to its original value, calling the print() function will once again print to the screen.</p></li>
</ol>

<p>Redirecting standard error works exactly the same way, using sys.stderr instead of sys.stdout.
.
11.7. FURTHER READING
•   Reading
and
writing
files
in the Python.org tutorial</p>

<p>•   io module</p>

<p>•   Stream
objects</p>

<p>•   Context
manager
types</p>

<p>•   sys.stdout and
sys.stderr
•   FUSE
on
Wikipedia</p>

<p>CHAPTER 12. XML</p>

<p>. In the archonship of Aristaechmus, Draco enacted his ordinances. .
— Aristotle
12.1. DIVING IN
Nearly all the chapters in this book revolve around a piece of sample code. But XML isn’t about code; it’s about data. One common use of XML is “syndication feeds” that list the latest articles on a blog, forum, or other frequently-updated website. Most popular blogging software can produce a feed and update it whenever new articles, discussion threads, or blog posts are published. You can follow a blog by “subscribing” to its feed, and you can follow multiple blogs with a dedicated “feed
aggregator” like Google
Reader.
Here, then, is the XML data we’ll be working with in this chapter. It’s a feed — specifically, an Atom
syndication
feed.
&lt;?xml version=&lsquo;1.0&rsquo; encoding=&lsquo;utf-8&rsquo;?&gt;</p>

<p><feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>
<title>dive into mark</title>
<subtitle>currently between addictions</subtitle>
<id>tag:diveintomark.org,2001-07-29:/</id>
<updated>2009-03-27T21:56:07Z</updated>
<link rel='alternate' type='text/html' href='http://diveintomark.org/'/>
<link rel='self' type='application/atom+xml' href='http://diveintomark.org/feed/'/>
<entry></p>

<p><author>
<name>Mark</name>
<uri><a href="http://diveintomark.org/">http://diveintomark.org/</a></uri></p>

<p></author>
<title>Dive into history, 2009 edition</title>
&lt;link rel=&lsquo;alternate&rsquo; type=&lsquo;text/html&rsquo;</p>

<p>href=&lsquo;<a href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'/&gt;">http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'/&gt;</a>
<id>tag:diveintomark.org,2009-03-27:/archives/20090327172042</id>
<updated>2009-03-27T21:56:07Z</updated>
<published>2009-03-27T17:20:42Z</published>
<category scheme='http://diveintomark.org' term='diveintopython'/>
<category scheme='http://diveintomark.org' term='docbook'/>
<category scheme='http://diveintomark.org' term='html'/></p>

<p><summary type='html'>Putting an entire chapter on one page sounds
bloated, but consider this &amp;mdash; my longest chapter so far
would be 75 printed pages, and it loads in under 5 seconds&amp;hellip;
On dialup.</summary></p>

<p></entry>
<entry></p>

<p><author>
<name>Mark</name>
<uri><a href="http://diveintomark.org/">http://diveintomark.org/</a></uri></p>

<p></author>
<title>Accessibility is a harsh mistress</title>
&lt;link rel=&lsquo;alternate&rsquo; type=&lsquo;text/html&rsquo;</p>

<p>href=&lsquo;<a href="http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress'/&gt;">http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress'/&gt;</a>
<id>tag:diveintomark.org,2009-03-21:/archives/20090321200928</id>
<updated>2009-03-22T01:05:37Z</updated>
<published>2009-03-21T20:09:28Z</published>
<category scheme='http://diveintomark.org' term='accessibility'/>
<summary type='html'>The accessibility orthodoxy does not permit people to</p>

<p>question the value of features that are rarely useful and rarely used.</summary>
</entry>
<entry></p>

<p><author></p>

<p><name>Mark</name>
</author>
<title>A gentle introduction to video encoding, part 1: container formats</title>
&lt;link rel=&lsquo;alternate&rsquo; type=&lsquo;text/html&rsquo;</p>

<p>href=&lsquo;<a href="http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats'/&gt;">http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats'/&gt;</a>
<id>tag:diveintomark.org,2008-12-18:/archives/20081218155422</id>
<updated>2009-01-11T19:39:22Z</updated>
<published>2008-12-18T15:54:22Z</published>
<category scheme='http://diveintomark.org' term='asf'/>
<category scheme='http://diveintomark.org' term='avi'/>
<category scheme='http://diveintomark.org' term='encoding'/>
<category scheme='http://diveintomark.org' term='flv'/>
<category scheme='http://diveintomark.org' term='GIVE'/>
<category scheme='http://diveintomark.org' term='mp4'/>
<category scheme='http://diveintomark.org' term='ogg'/>
<category scheme='http://diveintomark.org' term='video'/>
<summary type='html'>These notes will eventually become part of a</p>

<p>tech talk on video encoding.</summary>
</entry>
</feed></p>

<p>.</p>

<p>12.2. A 5-MINUTE CRASH COURSE IN XML
If you already know about XML, you can skip this section.
XML is a generalized way of describing hierarchical structured data. An XML document contains one or more elements, which are delimited by start and end tags. This is a complete (albeit boring) XML document:
<foo> .
</foo> .</p>

<ol>
<li><p>This is the start tag of the foo element.</p></li>

<li><p>This is the matching end tag of the foo element. Like balancing parentheses in writing or mathematics or code, every start tag must be closed (matched) by a corresponding end tag.</p></li>
</ol>

<p>Elements can be nested to any depth. An element bar inside an element foo is said to be a subelement or child of foo.
<foo>
<bar></bar>
</foo></p>

<p>The first element in every XML document is called the root element. An XML document can only have one root element. The following is not an XML document, because it has two root elements:
<foo></foo>
<bar></bar></p>

<p>Elements can have attributes, which are name-value pairs. Attributes are listed within the start tag of an element and separated by whitespace. Attribute names can not be repeated within an element. Attribute values must be quoted. You may use either single or double quotes.
<foo lang='en'
> .
<bar id=xml-'papayawhip'>lang=&ldquo;fr&rdquo;
&gt;</bar> .</p>

<p></foo></p>

<ol>
<li><p>The foo element has one attribute, named lang. The value of its lang attribute is en.</p></li>

<li><p>The bar element has two attributes, named id and lang. The value of its lang attribute is fr. This doesn’t conflict with the foo element in any way. Each element has its own set of attributes.</p></li>
</ol>

<p>If an element has more than one attribute, the ordering of the attributes is not significant. An element’s attributes form an unordered set of keys and values, like a Python dictionary. There is no limit to the number of attributes you can define on each element.
Elements can have text content.
<foo lang='en'>
<bar lang='fr'>PapayaWhip
</bar>
</foo></p>

<p>Elements that contain no text and no children are empty.
<foo></foo></p>

<p>There is a shorthand for writing empty elements. By putting a / character in the start tag, you can skip the end tag altogther. The XML document in the previous example could be written like this instead:
<foo/
></p>

<p>Like Python functions can be declared in different modules, XML elements can be declared in different namespaces. Namespaces usually look like URLs. You use an xmlns declaration to define a default namespace. A namespace declaration looks similar to an attribute, but it has a different purpose.
<feed xmlns='http://www.w3.org/2005/Atom'
> .
<title>dive into mark</title> .
</feed></p>

<ol>
<li>The feed element is in the <a href="http://www.w3.org/2005/Atom">http://www.w3.org/2005/Atom</a> namespace.</li>
<li>The title element is also in the <a href="http://www.w3.org/2005/Atom">http://www.w3.org/2005/Atom</a> namespace. The namespace declaration affects the element where it’s declared, plus all child elements.
You can also use an xmlns:prefix declaration to define a namespace and associate it with a prefix. Then each element in that namespace must be explicitly declared with the prefix.
<atom:feed xmlns:atom='http://www.w3.org/2005/Atom'
> .
<a href="atom:title">atom:title</a>dive into mark<a href="/atom:title">/atom:title</a> .</li>
</ol>

<p><a href="/atom:feed">/atom:feed</a></p>

<ol>
<li><p>The feed element is in the <a href="http://www.w3.org/2005/Atom">http://www.w3.org/2005/Atom</a> namespace.</p></li>

<li><p>The title element is also in the <a href="http://www.w3.org/2005/Atom">http://www.w3.org/2005/Atom</a> namespace.</p></li>
</ol>

<p>As far as an XML parser is concerned, the previous two XML documents are identical. Namespace + element name = XML identity. Prefixes only exist to refer to namespaces, so the actual prefix name (atom:) is irrelevant. The namespaces match, the element names match, the attributes (or lack of attributes) match, and each element’s text content matches, therefore the XML documents are the same.
Finally, XML documents can contain character
encoding
information
on the first line, before the root element. (If you’re curious how a document can contain information which needs to be known before the document can be parsed, Section
F
of
the
XML
specification
details how to resolve this Catch-22.)
&lt;?xml version=&lsquo;1.0&rsquo; encoding=&lsquo;utf-8&rsquo;
?&gt;</p>

<p>And now you know just enough XML to be dangerous!
.</p>

<p>12.3. THE STRUCTURE OF AN ATOM FEED
Think of a weblog, or in fact any website with frequently updated content, like CNN.com. The site itself has a title (“CNN.com”), a subtitle (“Breaking News, U.S., World, Weather, Entertainment &amp;Video News”), a last-updated date (“updated 12:43 p.m. EDT, Sat May 16, 2009”), and a list of articles posted at different times. Each article also has a title, a first-published date (and maybe also a last-updated date, if they published a correction or fixed a typo), and a unique URL.
The Atom syndication format is designed to capture all of this information in a standard format. My weblog and CNN.com are wildly different in design, scope, and audience, but they both have the same basic structure. CNN.com has a title; my blog has a title. CNN.com publishes articles; I publish articles.
At the top level is the root element, which every Atom feed shares: the feed element in the
<a href="http://www.w3.org/2005/Atom">http://www.w3.org/2005/Atom</a> namespace.</p>

<p><feed xmlns='http://www.w3.org/2005/Atom' . 
xml:lang='en'> .</p>

<ol>
<li><a href="http://www.w3.org/2005/Atom">http://www.w3.org/2005/Atom</a> is the Atom namespace.</li>
<li>Any element can contain an xml:lang attribute, which declares the language of the element and its children. In this case, the xml:lang attribute is declared once on the root element, which means the entire feed is in English.
An Atom feed contains several pieces of information about the feed itself. These are declared as children of the root-level feed element.
<feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'> <title>dive into mark</title> . <subtitle>currently between addictions</subtitle> . <id>tag:diveintomark.org,2001-07-29:/</id> . <updated>2009-03-27T21:56:07Z</updated> . <link rel='alternate' type='text/html' href='http://diveintomark.org/'/> .</li>

<li><p>The title of this feed is dive into mark.</p></li>

<li><p>The subtitle of this feed is currently between addictions.</p></li>

<li><p>Every feed needs a globally unique identifier. See RFC
4151
for how to create one.</p></li>

<li><p>This feed was last updated on March 27, 2009, at 21:56 GMT. This is usually equivalent to the last-modified date of the most recent article.</p></li>

<li><p>Now things start to get interesting. This link element has no text content, but it has three attributes: rel, type, and href. The rel value tells you what kind of link this is; rel=&lsquo;alternate&rsquo; means that this is a link to an alternate representation of this feed. The type=&lsquo;text/html&rsquo; attribute means that this is a link to an HTML page. And the link target is given in the href attribute.</p></li>
</ol>

<p>Now we know that this is a feed for a site named “dive into mark“ which is available at
<a href="http://diveintomark.org/">http://diveintomark.org/</a> and was last updated on March 27, 2009.
. Although the order of elements can be relevant in some XML documents, it is not
relevant in an Atom feed.
After the feed-level metadata is the list of the most recent articles. An article looks like this:
<entry></p>

<p><author> . <name>Mark</name> <uri><a href="http://diveintomark.org/">http://diveintomark.org/</a></uri>
</author>
<title>Dive into history, 2009 edition</title> .
&lt;link rel=&lsquo;alternate&rsquo; type=&lsquo;text/html&rsquo; .</p>

<p>href=&lsquo;<a href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'/&gt;">http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'/&gt;</a> <id>tag:diveintomark.org,2009-03-27:/archives/20090327172042</id> . <updated>2009-03-27T21:56:07Z</updated> . <published>2009-03-27T17:20:42Z</published> <category scheme='http://diveintomark.org' term='diveintopython'/> . <category scheme='http://diveintomark.org' term='docbook'/> <category scheme='http://diveintomark.org' term='html'/> <summary type='html'>Putting an entire chapter on one page sounds .
bloated, but consider this &amp;mdash; my longest chapter so far
would be 75 printed pages, and it loads in under 5 seconds&amp;hellip;
On dialup.</summary></p>

<p></entry>    .
1.  The author element tells who wrote this article: some guy named Mark, whom you can find loafing at <a href="http://diveintomark.org/">http://diveintomark.org/</a>. (This is the same as the alternate link in the feed metadata, but it doesn’t have to be. Many weblogs have multiple authors, each with their own personal website.)</p>

<ol>
<li><p>The title element gives the title of the article, “Dive into history, 2009 edition”.</p></li>

<li><p>As with the feed-level alternate link, this link element gives the address of the HTML version of this article.</p></li>

<li><p>Entries, like feeds, need a unique identifier.</p></li>

<li><p>Entries have two dates: a first-published date (published) and a last-modified date (updated).</p></li>

<li><p>Entries can have an arbitrary number of categories. This article is filed under diveintopython, docbook, and html.</p></li>

<li><p>The summary element gives a brief summary of the article. (There is also a content element, not shown here, if you want to include the complete article text in your feed.) This summary element has the Atom-specific type=&lsquo;html&rsquo; attribute, which specifies that this summary is a snippet of HTML, not plain text. This is important, since it has HTML-specific entities in it (&mdash; and &hellip;) which should be rendered as “—” and “…” rather than displayed directly.</p></li>

<li><p>Finally, the end tag for the entry element, signaling the end of the metadata for this article.</p></li>
</ol>

<p>.</p>

<p>12.4. PARSING XML
Python can parse XML documents in several ways. It has traditional DOM
and SAX
parsers, but I will focus on a different library called ElementTree.
&gt;&gt;&gt; import xml.etree.ElementTree as etree .
&gt;&gt;&gt; tree = etree.parse(&lsquo;examples/feed.xml&rsquo;) .
&gt;&gt;&gt; root = tree.getroot() .
&gt;&gt;&gt; root .
<Element {http://www.w3.org/2005/Atom}feed at cd1eb0></p>

<ol>
<li><p>The ElementTree library is part of the Python standard library, in xml.etree.ElementTree.</p></li>

<li><p>The primary entry point for the ElementTree library is the parse() function, which can take a filename or a file-like
object. This function parses the entire document at once. If memory is tight, there are ways to parse
an
XML
document
incrementally
instead.</p></li>

<li><p>The parse() function returns an object which represents the entire document. This is not the root element. To get a reference to the root element, call the getroot() method.</p></li>

<li><p>As expected, the root element is the feed element in the <a href="http://www.w3.org/2005/Atom">http://www.w3.org/2005/Atom</a> namespace. The string representation of this object reinforces an important point: an XML element is a combination of its namespace and its tag name (also called the local name). Every element in this document is in the Atom namespace, so the root element is represented as {<a href="http://www.w3.org/2005/Atom}feed">http://www.w3.org/2005/Atom}feed</a>.</p></li>
</ol>

<p>. ElementTree represents XML elements as {namespace}localname. You’ll see and use this format in multiple places in the ElementTree API.
12.4.1. ELEMENTS ARE LISTS
In the ElementTree API, an element acts like a list. The items of the list are the element’s children.</p>

<h1 id="continued-from-the-previous-example-8">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>root.tag .
&lsquo;{<a href="http://www.w3.org/2005/Atom}feed'">http://www.w3.org/2005/Atom}feed'</a>
len(root) .
8
for child in root: .
&hellip; print(child) .</p>
</blockquote>
</blockquote>
</blockquote>

<p>&hellip;</p>

<p><Element {http://www.w3.org/2005/Atom}title at e2b5d0>
<Element {http://www.w3.org/2005/Atom}subtitle at e2b4e0>
<Element {http://www.w3.org/2005/Atom}id at e2b6c0>
<Element {http://www.w3.org/2005/Atom}updated at e2b6f0>
<Element {http://www.w3.org/2005/Atom}link at e2b4b0>
<Element {http://www.w3.org/2005/Atom}entry at e2b720>
<Element {http://www.w3.org/2005/Atom}entry at e2b510>
<Element {http://www.w3.org/2005/Atom}entry at e2b750></p>

<ol>
<li><p>Continuing from the previous example, the root element is {<a href="http://www.w3.org/2005/Atom}feed">http://www.w3.org/2005/Atom}feed</a>.</p></li>

<li><p>The “length” of the root element is the number of child elements.</p></li>

<li><p>You can use the element itself as an iterator to loop through all of its child elements.</p></li>

<li><p>As you can see from the output, there are indeed 8 child elements: all of the feed-level metadata (title, subtitle, id, updated, and link) followed by the three entry elements.</p></li>
</ol>

<p>You may have guessed this already, but I want to point it out explicitly: the list of child elements only includes direct children. Each of the entry elements contain their own children, but those are not included in the list. They would be included in the list of each entry’s children, but they are not included in the list of the feed’s children. There are ways to find elements no matter how deeply nested they are; we’ll look at two such ways later in this chapter.</p>

<p>12.4.2. ATTRIBUTES ARE DICTONARIES
XML isn’t just a collection of elements; each element can also have its own set of attributes. Once you have a reference to a specific element, you can easily get its attributes as a Python dictionary.</p>

<h1 id="continuing-from-the-previous-example">continuing from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>root.attrib .
{&lsquo;{<a href="http://www.w3.org/XML/1998/namespace}lang':">http://www.w3.org/XML/1998/namespace}lang':</a> &lsquo;en&rsquo;}
root[4] .
<Element {http://www.w3.org/2005/Atom}link at e181b0>
root[4].attrib .
{&lsquo;href&rsquo;: &lsquo;<a href="http://diveintomark.org/'">http://diveintomark.org/'</a>,</p>
</blockquote>
</blockquote>
</blockquote>

<p>&lsquo;type&rsquo;: &lsquo;text/html&rsquo;,</p>

<p>&lsquo;rel&rsquo;: &lsquo;alternate&rsquo;}
&gt;&gt;&gt; root[3] .
<Element {http://www.w3.org/2005/Atom}updated at e2b4e0>
&gt;&gt;&gt; root[3].attrib .
{}</p>

<ol>
<li><p>The attrib property is a dictionary of the element’s attributes. The original markup here was <feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>. The xml: prefix refers to a built-in namespace that every XML document can use without declaring it.</p></li>

<li><p>The fifth child — [4] in a 0-based list — is the link element.</p></li>

<li><p>The link element has three attributes: href, type, and rel.</p></li>

<li><p>The fourth child — [3] in a 0-based list — is the updated element.</p></li>

<li><p>The updated element has no attributes, so its .attrib is just an empty dictionary.
.
12.5. SEARCHING FOR NODES WITHIN AN XML DOCUMENT
So far, we’ve worked with this XML document “from the top down,” starting with the root element, getting its child elements, and so on throughout the document. But many uses of XML require you to find specific elements. Etree can do that, too.
&gt;&gt;&gt; import xml.etree.ElementTree as etree
&gt;&gt;&gt; tree = etree.parse(&lsquo;examples/feed.xml&rsquo;)
&gt;&gt;&gt; root = tree.getroot()
&gt;&gt;&gt; root.findall(&lsquo;{<a href="http://www.w3.org/2005/Atom}entry'">http://www.w3.org/2005/Atom}entry'</a>) .
[<Element {http://www.w3.org/2005/Atom}entry at e2b4e0>,</p></li>
</ol>

<p><Element {http://www.w3.org/2005/Atom}entry at e2b510>,</p>

<p><Element {http://www.w3.org/2005/Atom}entry at e2b540>]
&gt;&gt;&gt; root.tag
&lsquo;{<a href="http://www.w3.org/2005/Atom}feed'">http://www.w3.org/2005/Atom}feed'</a>
&gt;&gt;&gt; root.findall(&lsquo;{<a href="http://www.w3.org/2005/Atom}feed'">http://www.w3.org/2005/Atom}feed'</a>) .
[]
&gt;&gt;&gt; root.findall(&lsquo;{<a href="http://www.w3.org/2005/Atom}author'">http://www.w3.org/2005/Atom}author'</a>) .
[]</p>

<ol>
<li><p>The findall() method finds child elements that match a specific query. (More on the query format in a minute.)</p></li>

<li><p>Each element — including the root element, but also child elements — has a findall() method. It finds all matching elements among the element’s children. But why aren’t there any results? Although it may not be obvious, this particular query only searches the element’s children. Since the root feed element has no child named feed, this query returns an empty list.</p></li>

<li><p>This result may also surprise you. There
is
an
author element
in this document; in fact, there are three (one in each entry). But those author elements are not direct children of the root element; they are</p></li>
</ol>

<p>“grandchildren” (literally, a child element of a child element). If you want to look for author elements at any nesting level, you can do that, but the query format is slightly different.
&gt;&gt;&gt; tree.findall(&lsquo;{<a href="http://www.w3.org/2005/Atom}entry'">http://www.w3.org/2005/Atom}entry'</a>) .
[<Element {http://www.w3.org/2005/Atom}entry at e2b4e0>,
<Element {http://www.w3.org/2005/Atom}entry at e2b510>,
<Element {http://www.w3.org/2005/Atom}entry at e2b540>]</p>

<blockquote>
<blockquote>
<blockquote>
<p>tree.findall(&lsquo;{<a href="http://www.w3.org/2005/Atom}author'">http://www.w3.org/2005/Atom}author'</a>) .
[]</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>For convenience, the tree object (returned from the etree.parse() function) has several methods that mirror the methods on the root element. The results are the same as if you had called the tree.getroot().findall() method.</p></li>

<li><p>Perhaps surprisingly, this query does not find the author elements in this document. Why not? Because this is just a shortcut for tree.getroot().findall(&lsquo;{<a href="http://www.w3.org/2005/Atom}author'">http://www.w3.org/2005/Atom}author'</a>), which means “find all the author elements that are children of the root element.” The author elements are not children of the root element; they’re children of the entry elements. Thus the query doesn’t return any matches.</p></li>
</ol>

<p>There is also a find() method which returns the first matching element. This is useful for situations where you are only expecting one match, or if there are multiple matches, you only care about the first one.
&gt;&gt;&gt; entries = tree.findall(&lsquo;{<a href="http://www.w3.org/2005/Atom}entry'">http://www.w3.org/2005/Atom}entry'</a>) .
&gt;&gt;&gt; len(entries)
3
&gt;&gt;&gt; title_element = entries[0].find(&lsquo;{<a href="http://www.w3.org/2005/Atom}title'">http://www.w3.org/2005/Atom}title'</a>) .
&gt;&gt;&gt; title_element.text
&lsquo;Dive into history, 2009 edition&rsquo;
&gt;&gt;&gt; foo_element = entries[0].find(&lsquo;{<a href="http://www.w3.org/2005/Atom}foo'">http://www.w3.org/2005/Atom}foo'</a>) .
&gt;&gt;&gt; foo_element
&gt;&gt;&gt; type(foo_element)
<class 'NoneType'></p>

<ol>
<li><p>You saw this in the previous example. It finds all the atom:entry elements.</p></li>

<li><p>The find() method takes an ElementTree query and returns the first matching element.</p></li>

<li><p>There are no elements in this entry named foo, so this returns None.</p></li>
</ol>

<p>. There is a “gotcha” with the find() method that will eventually bite you. In a
boolean context, ElementTree element objects will evaluate to False if they contain
no children (i.e. if len(element) is 0). This means that if element.find(&lsquo;&hellip;&rsquo;) is
not testing whether the find() method found a matching element; it’s testing
whether that matching element has any child elements! To test whether the find()
method returned an element, use if element.find(&lsquo;&hellip;&rsquo;) is not None.</p>

<p>There is a way to search for descendant elements, i.e. children, grandchildren, and any element at any nesting level.
&gt;&gt;&gt; all_links = tree.findall(&lsquo;//{<a href="http://www.w3.org/2005/Atom}link'">http://www.w3.org/2005/Atom}link'</a>) .
&gt;&gt;&gt; all_links
[<Element {http://www.w3.org/2005/Atom}link at e181b0>,</p>

<p><Element {http://www.w3.org/2005/Atom}link at e2b570>,
<Element {http://www.w3.org/2005/Atom}link at e2b480>,
<Element {http://www.w3.org/2005/Atom}link at e2b5a0>]</p>

<blockquote>
<blockquote>
<blockquote>
<p>all_links[0].attrib     .
{&lsquo;href&rsquo;: &lsquo;<a href="http://diveintomark.org/'">http://diveintomark.org/'</a>,
&lsquo;type&rsquo;: &lsquo;text/html&rsquo;,
&lsquo;rel&rsquo;: &lsquo;alternate&rsquo;}</p>

<p>all_links[1].attrib     .
{&lsquo;href&rsquo;: &lsquo;<a href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'">http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'</a>,
&lsquo;type&rsquo;: &lsquo;text/html&rsquo;,
&lsquo;rel&rsquo;: &lsquo;alternate&rsquo;}</p>

<p>all_links[2].attrib</p>
</blockquote>
</blockquote>
</blockquote>

<p>{&lsquo;href&rsquo;: &lsquo;<a href="http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress'">http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress'</a>,
&lsquo;type&rsquo;: &lsquo;text/html&rsquo;,
&lsquo;rel&rsquo;: &lsquo;alternate&rsquo;}</p>

<blockquote>
<blockquote>
<blockquote>
<p>all_links[3].attrib</p>
</blockquote>
</blockquote>
</blockquote>

<p>{&lsquo;href&rsquo;: &lsquo;<a href="http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats'">http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats'</a>,
&lsquo;type&rsquo;: &lsquo;text/html&rsquo;,
&lsquo;rel&rsquo;: &lsquo;alternate&rsquo;}</p>

<ol>
<li><p>This query — //{<a href="http://www.w3.org/2005/Atom}link">http://www.w3.org/2005/Atom}link</a> — is very similar to the previous examples, except for the two slashes at the beginning of the query. Those two slashes mean “don’t just look for direct children; I want any elements, regardless of nesting level.” So the result is a list of four link elements, not just one.</p></li>

<li><p>The first result is a direct child of the root element. As you can see from its attributes, this is the feed-level alternate link that points to the HTML version of the website that the feed describes.</p></li>

<li><p>The other three results are each entry-level alternate links. Each entry has a single link child element, and because of the double slash at the beginning of the query, this query finds all of them.</p></li>
</ol>

<p>Overall, ElementTree’s findall() method is a very powerful feature, but the query language can be a bit surprising. It is officially described as “limited
support
for
XPath
expressions.” XPath
is a W3C standard for querying XML documents. ElementTree’s query language is similar enough to XPath to do basic searching, but dissimilar enough that it may annoy you if you already know XPath. Now let’s look at a third-party XML library that extends the ElementTree API with full XPath support.
.
12.6. GOING FURTHER WITH LXML
lxml is an open source third-party library that builds on the popular libxml2
parser. It provides a 100% compatible ElementTree API, then extends it with full XPath 1.0 support and a few other niceties. There are installers
available
for
Windows; Linux users should always try to use distribution-specific tools like yum or apt-get to install precompiled binaries from their repositories. Otherwise you’ll need to install
lxml manually.
&gt;&gt;&gt; from lxml import etree .
&gt;&gt;&gt; tree = etree.parse(&lsquo;examples/feed.xml&rsquo;) .
&gt;&gt;&gt; root = tree.getroot() .
&gt;&gt;&gt; root.findall(&lsquo;{<a href="http://www.w3.org/2005/Atom}entry'">http://www.w3.org/2005/Atom}entry'</a>) .
[<Element {http://www.w3.org/2005/Atom}entry at e2b4e0>,</p>

<p><Element {http://www.w3.org/2005/Atom}entry at e2b510>,</p>

<p><Element {http://www.w3.org/2005/Atom}entry at e2b540>]</p>

<ol>
<li><p>Once imported, lxml provides the same API as the built-in ElementTree library.</p></li>

<li><p>parse() function: same as ElementTree.</p></li>

<li><p>getroot() method: also the same.</p></li>

<li><p>findall() method: exactly the same.</p></li>
</ol>

<p>For large XML documents, lxml is significantly faster than the built-in ElementTree library. If you’re only using the ElementTree API and want to use the fastest available implementation, you can try to import lxml and fall back to the built-in ElementTree.
try:</p>

<p>from lxml import etree
except ImportError:
import xml.etree.ElementTree as etree</p>

<p>But lxml is more than just a faster ElementTree. Its findall() method includes support for more
complicated expressions.</p>

<blockquote>
<blockquote>
<blockquote>
<p>import lxml.etree . &gt;&gt;&gt; tree = lxml.etree.parse(&lsquo;examples/feed.xml&rsquo;) &gt;&gt;&gt; tree.findall(&lsquo;//{<a href="http://www.w3.org/2005/Atom}*[@href]'">http://www.w3.org/2005/Atom}*[@href]'</a>) . [<Element {http://www.w3.org/2005/Atom}link at eeb8a0>,
<Element {http://www.w3.org/2005/Atom}link at eeb990>,
<Element {http://www.w3.org/2005/Atom}link at eeb960>,
<Element {http://www.w3.org/2005/Atom}link at eeb9c0>]</p>

<p>tree.findall(&ldquo;//{<a href="http://www.w3.org/2005/Atom}*[@href='http://diveintomark.org/']&quot;">http://www.w3.org/2005/Atom}*[@href='http://diveintomark.org/']&quot;</a>) .
[<Element {http://www.w3.org/2005/Atom}link at eeb930>]
NS = &lsquo;{<a href="http://www.w3.org/2005/Atom}'">http://www.w3.org/2005/Atom}'</a>
tree.findall(&lsquo;//{NS}author[{NS}uri]&lsquo;.format(NS=NS)) .
[<Element {http://www.w3.org/2005/Atom}author at eeba80>,</p>
</blockquote>
</blockquote>
</blockquote>

<p><Element {http://www.w3.org/2005/Atom}author at eebba0>]</p>

<ol>
<li><p>In this example, I’m going to import lxml.etree (instead of, say, from lxml import etree), to emphasize that these features are specific to lxml.</p></li>

<li><p>This query finds all elements in the Atom namespace, anywhere in the document, that have an href attribute. The // at the beginning of the query means “elements anywhere (not just as children of the root element).” {<a href="http://www.w3.org/2005/Atom">http://www.w3.org/2005/Atom</a>} means “only elements in the Atom namespace.” * means “elements with any local name.” And [@href] means “has an href attribute.”</p></li>

<li><p>The query finds all Atom elements with an href whose value is <a href="http://diveintomark.org/">http://diveintomark.org/</a>.</p></li>

<li><p>After doing some quick string
formatting
(because otherwise these compound queries get ridiculously long), this query searches for Atom author elements that have an Atom uri element as a child. This only returns two author elements, the ones in the first and second entry. The author in the last entry contains only a name, not a uri.</p></li>
</ol>

<p>Not enough for you? lxml also integrates support for arbitrary XPath 1.0 expressions. I’m not going to go into depth about XPath syntax; that could be a whole book unto itself! But I will show you how it integrates into lxml.
&gt;&gt;&gt; import lxml.etree
&gt;&gt;&gt; tree = lxml.etree.parse(&lsquo;examples/feed.xml&rsquo;)
&gt;&gt;&gt; NSMAP = {&lsquo;atom&rsquo;: &lsquo;<a href="http://www.w3.org/2005/Atom'">http://www.w3.org/2005/Atom'</a>} .
&gt;&gt;&gt; entries = tree.xpath(&ldquo;//atom:category[@term=&lsquo;accessibility&rsquo;]/..&ldquo;, .
&hellip; namespaces=NSMAP)
&gt;&gt;&gt; entries .
[<Element {http://www.w3.org/2005/Atom}entry at e2b630>]
&gt;&gt;&gt; entry = entries[0]
&gt;&gt;&gt; entry.xpath(&lsquo;./atom:title/text()&lsquo;, namespaces=NSMAP) .
[&lsquo;Accessibility is a harsh mistress&rsquo;]</p>

<ol>
<li><p>To perform XPath queries on namespaced elements, you need to define a namespace prefix mapping. This is just a Python dictionary.</p></li>

<li><p>Here is an XPath query. The XPath expression searches for category elements (in the Atom namespace) that contain a term attribute with the value accessibility. But that’s not actually the query result. Look at the very end of the query string; did you notice the /.. bit? That means “and then return the parent element of the category element you just found.” So this single XPath query will find all entries with a child element of <category term='accessibility'>.</p></li>

<li><p>The xpath() function returns a list of ElementTree objects. In this document, there is only one entry with a category whose term is accessibility.</p></li>

<li><p>XPath expressions don’t always return a list of elements. Technically, the DOM of a parsed XML document doesn’t contain elements; it contains nodes. Depending on their type, nodes can be elements, attributes, or even text content. The result of an XPath query is a list of nodes. This query returns a list of text nodes: the text content (text()) of the title element (atom:title) that is a child of the current element (./).</p></li>
</ol>

<p>.</p>

<p>12.7. GENERATING XML</p>

<p>Python’s support for XML is not limited to parsing existing documents. You can also create XML documents from scratch.
&gt;&gt;&gt; import xml.etree.ElementTree as etree
&gt;&gt;&gt; new_feed = etree.Element(&lsquo;{<a href="http://www.w3.org/2005/Atom}feed'">http://www.w3.org/2005/Atom}feed'</a>, .
&hellip; attrib={&lsquo;{<a href="http://www.w3.org/XML/1998/namespace}lang':">http://www.w3.org/XML/1998/namespace}lang':</a> &lsquo;en&rsquo;}) .
&gt;&gt;&gt; print(etree.tostring(new_feed)) .
<ns0:feed xmlns:ns0='http://www.w3.org/2005/Atom' xml:lang='en'/></p>

<ol>
<li><p>To create a new element, instantiate the Element class. You pass the element name (namespace + local name) as the first argument. This statement creates a feed element in the Atom namespace. This will be our new document’s root element.</p></li>

<li><p>To add attributes to the newly created element, pass a dictionary of attribute names and values in the attrib argument. Note that the attribute name should be in the standard ElementTree format, {namespace}localname.</p></li>

<li><p>At any time, you can serialize any element (and its children) with the ElementTree tostring() function.</p></li>
</ol>

<p>Was that serialization surprising to you? The way ElementTree serializes namespaced XML elements is technically accurate but not optimal. The sample XML document at the beginning of this chapter defined a default namespace (xmlns=&lsquo;<a href="http://www.w3.org/2005/Atom'">http://www.w3.org/2005/Atom'</a>). Defining a default namespace is useful for documents — like Atom feeds — where every element is in the same namespace, because you can declare the namespace once and declare each element with just its local name (<feed>, <link>, <entry>). There is no need to use any prefixes unless you want to declare elements from another namespace.
An XML parser won’t “see” any difference between an XML document with a default namespace and an XML document with a prefixed namespace. The resulting DOM of this serialization:
<ns0:feed xmlns:ns0='http://www.w3.org/2005/Atom' xml:lang='en'/></p>

<p>is identical to the DOM of this serialization:
<feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'/></p>

<p>The only practical difference is that the second serialization is several characters shorter. If we were to recast our entire sample feed with a ns0: prefix in every start and end tag, it would add 4 characters per start tag × 79 tags + 4 characters for the namespace declaration itself, for a total of 320 characters. Assuming UTF-8
encoding, that’s 320 extra bytes. (After gzipping, the difference drops to 21 bytes, but still, 21 bytes is 21 bytes.) Maybe that doesn’t matter to you, but for something like an Atom feed, which may be downloaded several thousand times whenever it changes, saving a few bytes per request can quickly add up.
The built-in ElementTree library does not offer this fine-grained control over serializing namespaced
elements, but lxml does.</p>

<blockquote>
<blockquote>
<blockquote>
<p>import lxml.etree
NSMAP = {None: &lsquo;<a href="http://www.w3.org/2005/Atom'">http://www.w3.org/2005/Atom'</a>} .
new_feed = lxml.etree.Element(&lsquo;feed&rsquo;, nsmap=NSMAP) .
print(lxml.etree.tounicode(new_feed)) .
<feed xmlns='http://www.w3.org/2005/Atom'/>
new_feed.set(&lsquo;{<a href="http://www.w3.org/XML/1998/namespace}lang'">http://www.w3.org/XML/1998/namespace}lang'</a>, &lsquo;en&rsquo;) .
print(lxml.etree.tounicode(new_feed))
<feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'/></p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>To start, define a namespace mapping as a dictionary. Dictionary values are namespaces; dictionary keys are the desired prefix. Using None as a prefix effectively declares a default namespace.</p></li>

<li><p>Now you can pass the lxml-specific nsmap argument when you create an element, and lxml will respect the namespace prefixes you’ve defined.</p></li>

<li><p>As expected, this serialization defines the Atom namespace as the default namespace and declares the feed element without a namespace prefix.</p></li>

<li><p>Oops, we forgot to add the xml:lang attribute. You can always add attributes to any element with the set() method. It takes two arguments: the attribute name in standard ElementTree format, then the attribute value. (This method is not lxml-specific. The only lxml-specific part of this example was the nsmap argument to control the namespace prefixes in the serialized output.)</p></li>
</ol>

<p>Are XML documents limited to one element per document? No, of course not. You can easily create child elements, too.
&gt;&gt;&gt; title = lxml.etree.SubElement(new_feed, &lsquo;title&rsquo;, .
&hellip; attrib={&lsquo;type&rsquo;:&lsquo;html&rsquo;}) .
&gt;&gt;&gt; print(lxml.etree.tounicode(new_feed)) .
<feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'><title type='html'/></feed>
&gt;&gt;&gt; title.text = &lsquo;dive into &hellip;&rsquo; .
&gt;&gt;&gt; print(lxml.etree.tounicode(new_feed)) .
<feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'><title type='html'>dive into &amp;hellip;</title></feed>
&gt;&gt;&gt; print(lxml.etree.tounicode(new_feed, pretty_print=True)) .
<feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>
<title type='html'>dive into&amp;hellip;</title>
</feed></p>

<ol>
<li><p>To create a child element of an existing element, instantiate the SubElement class. The only required arguments are the parent element (new_feed in this case) and the new element’s name. Since this child element will inherit the namespace mapping of its parent, there is no need to redeclare the namespace or prefix here.</p></li>

<li><p>You can also pass in an attribute dictionary. Keys are attribute names; values are attribute values.</p></li>

<li><p>As expected, the new title element was created in the Atom namespace, and it was inserted as a child of the feed element. Since the title element has no text content and no children of its own, lxml serializes it as an empty element (with the /&gt; shortcut).</p></li>

<li><p>To set the text content of an element, simply set its .text property.</p></li>

<li><p>Now the title element is serialized with its text content. Any text content that contains less-than signs or ampersands needs to be escaped when serialized. lxml handles this escaping automatically.</p></li>

<li><p>You can also apply “pretty printing” to the serialization, which inserts line breaks after end tags, and after start tags of elements that contain child elements but no text content. In technical terms, lxml adds “insignificant whitespace” to make the output more readable.</p></li>
</ol>

<p>. You might also want to check out xmlwitch, another third-party library for generating XML. It makes extensive use of the
with statement
to make XML generation code more readable.
.</p>

<p>12.8. PARSING BROKEN XML</p>

<p>The XML specification mandates that all conforming XML parsers employ “draconian error handling.” That is, they must halt and catch fire as soon as they detect any sort of wellformedness error in the XML document. Wellformedness errors include mismatched start and end tags, undefined entities, illegal Unicode characters, and a number of other esoteric rules. This is in stark contrast to other common formats like HTML — your browser doesn’t stop rendering a web page if you forget to close an HTML tag or escape an ampersand in an attribute value. (It is a common misconception that HTML has no defined error handling. HTML
error
handling
is actually quite well-defined, but it’s significantly more complicated than “halt and catch fire on first error.”)
Some people (myself included) believe that it was a mistake for the inventors of XML to mandate draconian error handling. Don’t get me wrong; I can certainly see the allure of simplifying the error handling rules. But in practice, the concept of “wellformedness” is trickier than it sounds, especially for XML documents (like Atom feeds) that are published on the web and served over HTTP. Despite the maturity of XML, which standardized on draconian error handling in 1997, surveys continually show a significant fraction of Atom feeds on the web are plagued with wellformedness errors.
So, I have both theoretical and practical reasons to parse XML documents “at any cost,” that is, not to halt and catch fire at the first wellformedness error. If you find yourself wanting to do this too, lxml can help.
Here is a fragment of a broken XML document. I’ve highlighted the wellformedness error.
&lt;?xml version=&lsquo;1.0&rsquo; encoding=&lsquo;utf-8&rsquo;?&gt;</p>

<p><feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'></p>

<p><title>dive into &hellip;
</title></p>

<p>&hellip;</p>

<p></feed></p>

<p>That’s an error, because the &hellip; entity is not defined in XML. (It is defined in HTML.) If you try to parse this broken feed with the default settings, lxml will choke on the undefined entity.
&gt;&gt;&gt; import lxml.etree</p>

<blockquote>
<blockquote>
<blockquote>
<p>tree = lxml.etree.parse(&lsquo;examples/feed-broken.xml&rsquo;)</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;<stdin>&rdquo;, line 1, in <module></p>

<p>File &ldquo;lxml.etree.pyx&rdquo;, line 2693, in lxml.etree.parse (src/lxml/lxml.etree.c:52591)</p>

<p>File &ldquo;parser.pxi&rdquo;, line 1478, in lxml.etree._parseDocument (src/lxml/lxml.etree.c:75665)</p>

<p>File &ldquo;parser.pxi&rdquo;, line 1507, in lxml.etree._parseDocumentFromURL (src/lxml/lxml.etree.c:75993)</p>

<p>File &ldquo;parser.pxi&rdquo;, line 1407, in lxml.etree._parseDocFromFile (src/lxml/lxml.etree.c:75002)</p>

<p>File &ldquo;parser.pxi&rdquo;, line 965, in lxml.etree._BaseParser._parseDocFromFile (src/lxml/lxml.etree.c:72023)</p>

<p>File &ldquo;parser.pxi&rdquo;, line 539, in lxml.etree._ParserContext._handleParseResultDoc (src/lxml/lxml.etree.c:67830)</p>

<p>File &ldquo;parser.pxi&rdquo;, line 625, in lxml.etree._handleParseResult (src/lxml/lxml.etree.c:68877)</p>

<p>File &ldquo;parser.pxi&rdquo;, line 565, in lxml.etree._raiseParseError (src/lxml/lxml.etree.c:68125)</p>

<p>lxml.etree.XMLSyntaxError: Entity &lsquo;hellip&rsquo; not defined, line 3, column 28</p>

<p>To parse this broken XML document, despite its wellformedness error, you need to create a custom XML parser.
&gt;&gt;&gt; parser = lxml.etree.XMLParser(recover=True) .
&gt;&gt;&gt; tree = lxml.etree.parse(&lsquo;examples/feed-broken.xml&rsquo;, parser) .
&gt;&gt;&gt; parser.error_log .
examples/feed-broken.xml:3:28:FATAL:PARSER:ERR_UNDECLARED_ENTITY: Entity &lsquo;hellip&rsquo; not defined</p>

<blockquote>
<blockquote>
<blockquote>
<p>tree.findall(&lsquo;{<a href="http://www.w3.org/2005/Atom}title'">http://www.w3.org/2005/Atom}title'</a>)</p>
</blockquote>
</blockquote>
</blockquote>

<p>[<Element {http://www.w3.org/2005/Atom}title at ead510>]</p>

<blockquote>
<blockquote>
<blockquote>
<p>title = tree.findall(&lsquo;{<a href="http://www.w3.org/2005/Atom}title')[0">http://www.w3.org/2005/Atom}title')[0</a>]</p>

<p>title.text .
&lsquo;dive into &lsquo;</p>

<p>print(lxml.etree.tounicode(tree.getroot())) .
<feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'></p>
</blockquote>
</blockquote>
</blockquote>

<p><title>dive into </title></p>

<p>.</p>

<p>. [rest of serialization snipped for brevity]</p>

<p>.</p>

<ol>
<li><p>To create a custom parser, instantiate the lxml.etree.XMLParser class. It can take a
number
of
different
named
arguments. The one we’re interested in here is the recover argument. When set to True, the XML parser will try its best to “recover” from wellformedness errors.</p></li>

<li><p>To parse an XML document with your custom parser, pass the parser object as the second argument to the parse() function. Note that lxml does not raise an exception about the undefined &hellip; entity.</p></li>

<li><p>The parser keeps a log of the wellformedness errors that it has encountered. (This is actually true regardless of whether it is set to recover from those errors or not.)</p></li>

<li><p>Since it didn’t know what to do with the undefined &hellip; entity, the parser just silently dropped it. The text content of the title element becomes &lsquo;dive into &lsquo;.</p></li>

<li><p>As you can see from the serialization, the &hellip; entity didn’t get moved; it was simply dropped.</p></li>
</ol>

<p>It is important to reiterate that there is no guarantee of interoperability with “recovering” XML parsers. A different parser might decide that it recognized the &hellip; entity from HTML, and replace it with &amp;hellip; instead. Is that “better”? Maybe. Is it “more correct”? No, they are both equally incorrect. The correct behavior (according to the XML specification) is to halt and catch fire. If you’ve decided not to do that, you’re on your own.
.</p>

<p>12.9. FURTHER READING
•   XML
on
Wikipedia.org</p>

<p>•   The
ElementTree
XML
API</p>

<p>•   Elements
and
Element
Trees</p>

<p>•   XPath
Support
in
ElementTree</p>

<p>•   The
ElementTree
iterparse
Function</p>

<p>•   lxml
•   Parsing
XML
and
HTML
with
lxml</p>

<p>•   XPath
and
XSLT
with
lxml</p>

<p>•   xmlwitch</p>

<p>CHAPTER 13. SERIALIZING PYTHON OBJECTS</p>

<p>. Every Saturday since we’ve lived in this apartment, I have awakened at 6:15, poured myself a bowl of cereal, added a quarter-cup of 2% milk, sat on this end of this couch, turned on BBC America, and watched Doctor Who. .
—   Sheldon, The Big Bang Theory
13.1. DIVING IN
On the surface, the concept of serialization is simple. You have a data structure in memory that you want to save, reuse, or send to someone else. How would you do that? Well, that depends on how you want to save it, how you want to reuse it, and to whom you want to send it. Many games allow you to save your progress when you quit the game and pick up where you left off when you relaunch the game. (Actually, many non-gaming applications do this as well.) In this case, a data structure that captures “your progress so far” needs to be stored on disk when you quit, then loaded from disk when you relaunch. The data is only meant to be used by the same program that created it, never sent over a network, and never read by anything other than the program that created it. Therefore, the interoperability issues are limited to ensuring that later versions of the program can read data written by earlier versions.
For cases like this, the pickle module is ideal. It’s part of the Python standard library, so it’s always
available. It’s fast; the bulk of it is written in C, like the Python interpreter itself. It can store arbitrarily
complex Python data structures.</p>

<p>What can the pickle module store?
•   All the native
datatypes
that Python supports: booleans, integers, floating point numbers, complex numbers, strings, bytes objects, byte arrays, and None.</p>

<p>•   Lists, tuples, dictionaries, and sets containing any combination of native datatypes.</p>

<p>•   Lists, tuples, dictionaries, and sets containing any combination of lists, tuples, dictionaries, and sets containing any combination of native datatypes (and so on, to the
maximum
nesting
level
that
Python
supports).</p>

<p>• Functions, classes, and instances of classes (with caveats).</p>

<p>If this isn’t enough for you, the pickle module is also extensible. If you’re interested in extensibility, check out the links in the Further
Reading
section at the end of the chapter.</p>

<p>13.1.1. A QUICK NOTE ABOUT THE EXAMPLES IN THIS CHAPTER
This chapter tells a tale with two Python Shells. All of the examples in this chapter are part of a single story arc. You will be asked to switch back and forth between the two Python Shells as I demonstrate the pickle and json modules.
To help keep things straight, open the Python Shell and define the following variable:
&gt;&gt;&gt; shell = 1</p>

<p>Keep that window open. Now open another Python Shell and define the following variable:
&gt;&gt;&gt; shell = 2</p>

<p>Throughout this chapter, I will use the shell variable to indicate which Python Shell is being used in each example.
.
13.2. SAVING DATA TO A PICKLE FILE
The pickle module works with data structures. Let’s build one.
&gt;&gt;&gt; shell</p>

<p>1</p>

<blockquote>
<blockquote>
<blockquote>
<p>entry = {}</p>

<p>entry[&lsquo;title&rsquo;] = &lsquo;Dive into history, 2009 edition&rsquo;</p>

<p>entry[&lsquo;article_link&rsquo;] = &lsquo;<a href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'">http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'</a></p>

<p>entry[&lsquo;comments_link&rsquo;] = None</p>

<p>entry[&lsquo;internal_id&rsquo;] = b&rsquo;\xDE\xD5\xB4\xF8&rsquo;</p>

<p>entry[&lsquo;tags&rsquo;] = (&lsquo;diveintopython&rsquo;, &lsquo;docbook&rsquo;, &lsquo;html&rsquo;)</p>

<p>entry[&lsquo;published&rsquo;] = True</p>

<p>import time</p>

<p>entry[&lsquo;published_date&rsquo;] = time.strptime(&lsquo;Fri Mar 27 22:20:42 2009&rsquo;)</p>

<p>entry[&lsquo;published_date&rsquo;]</p>
</blockquote>
</blockquote>
</blockquote>

<p>time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1)</p>

<ol>
<li><p>Follow along in Python Shell #1.</p></li>

<li><p>The idea here is to build a Python dictionary that could represent something useful, like an entry
in
an
Atom
feed. But I also want to ensure that it contains several different types of data, to show off the pickle module. Don’t read too much into these values.</p></li>

<li><p>The time module contains a data structure (time_struct) to represent a point in time (accurate to one millisecond) and functions to manipulate time structs. The strptime() function takes a formatted string an converts it to a time_struct. This string is in the default format, but you can control that with format codes. See the time module
for more details.</p></li>
</ol>

<p>That’s a handsome-looking Python dictionary. Let’s save it to a file.
&gt;&gt;&gt; shell .
1
&gt;&gt;&gt; import pickle
&gt;&gt;&gt; with open(&lsquo;entry.pickle&rsquo;, &lsquo;wb&rsquo;) as f: .
&hellip; pickle.dump(entry, f) .
&hellip;</p>

<ol>
<li>This is still in Python Shell #1.</li>

<li><p>Use the open() function to open a file. Set the file mode to &lsquo;wb&rsquo; to open the file for writing in
binary
mode. Wrap it in a with statement
to ensure the file is closed automatically when you’re done with it.</p></li>

<li><p>The dump() function in the pickle module takes a serializable Python data structure, serializes it into a binary, Python-specific format using the latest version of the pickle protocol, and saves it to an open file.</p></li>
</ol>

<p>That last sentence was pretty important.
•   The pickle module takes a Python data structure and saves it to a file.</p>

<p>•   To do this, it serializes the data structure using a data format called “the pickle protocol.”</p>

<p>•   The pickle protocol is Python-specific; there is no guarantee of cross-language compatibility. You probably couldn’t take the entry.pickle file you just created and do anything useful with it in Perl, PHP, Java, or any other language.</p>

<p>•   Not every Python data structure can be serialized by the pickle module. The pickle protocol has changed
several times as new data types have been added to the Python language, but there are still limitations.</p>

<p>•   As a result of these changes, there is no guarantee of compatibility between different versions of Python itself. Newer versions of Python support the older serialization formats, but older versions of Python do not support newer formats (since they don’t support the newer data types).</p>

<p>•   Unless you specify otherwise, the functions in the pickle module will use the latest version of the pickle protocol. This ensures that you have maximum flexibility in the types of data you can serialize, but it also means that the resulting file will not be readable by older versions of Python that do not support the latest version of the pickle protocol.</p>

<p>•   The latest version of the pickle protocol is a binary format. Be sure to open your pickle files in
binary
mode, or the data will get corrupted during writing.</p>

<p>.</p>

<p>13.3. LOADING DATA FROM A PICKLE FILE
Now switch to your second Python Shell — i.e. not the one where you created the entry dictionary.
&gt;&gt;&gt; shell .
2
&gt;&gt;&gt; entry .</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
NameError: name &lsquo;entry&rsquo; is not defined</p>

<blockquote>
<blockquote>
<blockquote>
<p>import pickle
with open(&lsquo;entry.pickle&rsquo;, &lsquo;rb&rsquo;) as f: .
&hellip; entry = pickle.load(f) .</p>
</blockquote>
</blockquote>
</blockquote>

<p>&hellip;
&gt;&gt;&gt; entry .
{&lsquo;comments_link&rsquo;: None,</p>

<p>&lsquo;internal_id&rsquo;: b&rsquo;\xDE\xD5\xB4\xF8&rsquo;,
&lsquo;title&rsquo;: &lsquo;Dive into history, 2009 edition&rsquo;,
&lsquo;tags&rsquo;: (&lsquo;diveintopython&rsquo;, &lsquo;docbook&rsquo;, &lsquo;html&rsquo;),
&lsquo;article_link&rsquo;:
&lsquo;<a href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'">http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'</a>,
&lsquo;published_date&rsquo;: time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1),
&lsquo;published&rsquo;: True}</p>

<ol>
<li><p>This is Python Shell #2.</p></li>

<li><p>There is no entry variable defined here. You defined an entry variable in Python Shell #1, but that’s a completely different environment with its own state.</p></li>

<li><p>Open the entry.pickle file you created in Python Shell #1. The pickle module uses a binary data format, so you should always open pickle files in binary mode.</p></li>

<li><p>The pickle.load() function takes a stream
object, reads the serialized data from the stream, creates a new Python object, recreates the serialized data in the new Python object, and returns the new Python object.</p></li>

<li><p>Now the entry variable is a dictionary with familiar-looking keys and values.</p></li>
</ol>

<p>The pickle.dump() / pickle.load() cycle results in a new data structure that is equal to the original data structure.
&gt;&gt;&gt; shell .
1
&gt;&gt;&gt; with open(&lsquo;entry.pickle&rsquo;, &lsquo;rb&rsquo;) as f: .
&hellip; entry2 = pickle.load(f) .
&hellip;
&gt;&gt;&gt; entry2 == entry .
True
&gt;&gt;&gt; entry2 is entry .
False
&gt;&gt;&gt; entry2[&lsquo;tags&rsquo;] .
(&lsquo;diveintopython&rsquo;, &lsquo;docbook&rsquo;, &lsquo;html&rsquo;)
&gt;&gt;&gt; entry2[&lsquo;internal_id&rsquo;]
b&rsquo;\xDE\xD5\xB4\xF8&rsquo;</p>

<ol>
<li><p>Switch back to Python Shell #1.</p></li>

<li><p>Open the entry.pickle file.</p></li>

<li><p>Load the serialized data into a new variable, entry2.</p></li>

<li><p>Python confirms that the two dictionaries, entry and entry2, are equal. In this shell, you built entry from the ground up, starting with an empty dictionary and manually assigning values to specific keys. You serialized this dictionary and stored it in the entry.pickle file. Now you’ve read the serialized data from that file and created a perfect replica of the original data structure.</p></li>

<li><p>Equality is not the same as identity. I said you’ve created a perfect replica of the original data structure, which is true. But it’s still a copy.</p></li>

<li><p>For reasons that will become clear later in this chapter, I want to point out that the value of the &lsquo;tags&rsquo; key is a tuple, and the value of the &lsquo;internal_id&rsquo; key is a bytes object.</p></li>
</ol>

<p>.
13.4. PICKLING WITHOUT A FILE
The examples in the previous section showed how to serialize a Python object directly to a file on disk. But what if you don’t want or need a file? You can also serialize to a bytes object in memory.
&gt;&gt;&gt; shell</p>

<p>1
&gt;&gt;&gt; b = pickle.dumps(entry) .
&gt;&gt;&gt; type(b) .
<class 'bytes'>
&gt;&gt;&gt; entry3 = pickle.loads(b) .
&gt;&gt;&gt; entry3 == entry .
True</p>

<ol>
<li><p>The pickle.dumps() function (note the &rsquo;s&rsquo; at the end of the function name) performs the same serialization as the pickle.dump() function. Instead of taking a stream object and writing the serialized data to a file on disk, it simply returns the serialized data.</p></li>

<li><p>Since the pickle protocol uses a binary data format, the pickle.dumps() function returns a bytes object.</p></li>

<li><p>The pickle.loads() function (again, note the &rsquo;s&rsquo; at the end of the function name) performs the same deserialization as the pickle.load() function. Instead of taking a stream object and reading the serialized data from a file, it takes a bytes object containing serialized data, such as the one returned by the pickle.dumps() function.</p></li>

<li><p>The end result is the same: a perfect replica of the original dictionary.</p></li>
</ol>

<p>.
13.5. BYTES AND STRINGS REAR THEIR UGLY HEADS AGAIN
The pickle protocol has been around for many years, and it has matured as Python itself has matured. There are now four
different
versions
of the pickle protocol.
•   Python 1.x had two pickle protocols, a text-based format (“version 0”) and a binary format (“version 1”).</p>

<p>•   Python 2.3 introduced a new pickle protocol (“version 2”) to handle new functionality in Python class
objects. It is a binary format.</p>

<p>•   Python 3.0 introduced another pickle protocol (“version 3”) with explicit support for bytes objects and byte arrays. It is a binary format.</p>

<p>Oh look, the
difference
between
bytes
and
strings
rears its ugly head again. (If you’re surprised, you haven’t
been paying attention.) What this means in practice is that, while Python 3 can read data pickled with protocol version 2, Python 2 can not read data pickled with protocol version 3.
.</p>

<p>13.6. DEBUGGING PICKLE FILES
What does the pickle protocol look like? Let’s jump out of the Python Shell for a moment and take a look at that entry.pickle file we created.
you@localhost:~/diveintopython3/examples$ ls -l entry.pickle
-rw-r&ndash;r&ndash; 1 you you 358 Aug 3 13:34 entry.pickle
you@localhost:~/diveintopython3/examples$ cat entry.pickle
comments_linkqNXtagsqXdiveintopythonqXdocbookqXhtmlq?qX publishedq?
XlinkXJhttp://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition
q Xpublished_dateq
ctime
struct_time
?qRqXtitleqXDive into history, 2009 editionqu.</p>

<p>That wasn’t terribly helpful. You can see the strings, but other datatypes end up as unprintable (or at least unreadable) characters. Fields are not obviously delimited by tabs or spaces. This is not a format you would want to debug by yourself.
&gt;&gt;&gt; shell</p>

<blockquote>
<blockquote>
<blockquote>
<p>import pickletools
with open(&lsquo;entry.pickle&rsquo;, &lsquo;rb&rsquo;) as f:
&hellip; pickletools.dis(f)</p>
</blockquote>
</blockquote>
</blockquote>

<p>0: \x80 PROTO 3</p>

<p>2: }</p>

<p>3: q</p>

<p>5: (</p>

<p>6: X</p>

<p>25: q</p>

<p>27: c</p>

<p>45: q</p>

<p>47: (</p>

<p>48: M</p>

<p>51: K</p>

<p>53: K</p>

<p>55: K</p>

<p>57: K</p>

<p>59: K</p>

<p>61: K</p>

<p>63: K</p>

<p>65: J</p>

<p>70: t</p>

<p>71: q</p>

<p>73: }</p>

<p>74: q
76: \x86</p>

<p>77: q</p>

<p>79: R</p>

<p>80: q</p>

<p>82: X</p>

<p>100: q</p>

<p>102: N</p>

<p>EMPTY_DICT
BINPUT 0
MARK</p>

<p>BINUNICODE &lsquo;published_date&rsquo;</p>

<p>BINPUT 1</p>

<p>GLOBAL &lsquo;time struct_time&rsquo;</p>

<p>BINPUT 2</p>

<p>MARK
BININT2
BININT1
BININT1
BININT1
BININT1
BININT1
BININT1
BININT1
BININT
TUPLE</p>

<p>BINPUT 3</p>

<p>EMPTY_DICT</p>

<p>BINPUT  4<br />
TUPLE2<br />
BINPUT  5<br />
REDUCE<br />
BINPUT  6</p>

<p>2009
3
27
22
20
42
4
86
-1
(MARK at 47)</p>

<p>BINUNICODE &lsquo;comments_link&rsquo;
BINPUT 7
NONE</p>

<p>103: X BINUNICODE &lsquo;internal_id&rsquo;</p>

<p>119: q  BINPUT 8<br />
121: C  SHORT_BINBYTES &lsquo;ÞÕ´ø&rsquo;<br />
127: q  BINPUT 9<br />
129: X  BINUNICODE &lsquo;tags&rsquo;<br />
138: q  BINPUT 10<br />
140: X  BINUNICODE &lsquo;diveintopython&rsquo;<br />
159: q  BINPUT 11<br />
161: X  BINUNICODE &lsquo;docbook&rsquo;<br />
173: q  BINPUT 12<br />
175: X  BINUNICODE &lsquo;html&rsquo;<br />
184: q  BINPUT 13<br />
186: \x87  TUPLE3<br />
187: q  BINPUT 14<br />
189: X  BINUNICODE &lsquo;title&rsquo;<br />
199: q  BINPUT 15<br />
201: X  BINUNICODE &lsquo;Dive into history, 2009 edition&rsquo;<br />
237: q  BINPUT 16<br />
239: X  BINUNICODE &lsquo;article_link&rsquo;<br />
256: q  BINPUT 17<br />
258: X  BINUNICODE &lsquo;<a href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'">http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'</a><br />
337: q  BINPUT 18<br />
339: X  BINUNICODE &lsquo;published&rsquo;<br />
353: q  BINPUT 19<br />
355: \x88  NEWTRUE<br />
356: u  SETITEMS (MARK at 5)</p>

<p>357: . STOP
highest protocol among opcodes = 3</p>

<p>The most interesting piece of information in that disassembly is on the last line, because it includes the version of the pickle protocol with which this file was saved. There is no explicit version marker in the pickle protocol. To determine which protocol version was used to store a pickle file, you need to look at the markers (“opcodes”) within the pickled data and use hard-coded knowledge of which opcodes were introduced with each version of the pickle protocol. The pickle.dis() function does exactly that, and it prints the result in the last line of the disassembly output. Here is a function that returns just the version number, without printing anything:
import pickletools</p>

<p>def protocol_version(file_object):</p>

<p>maxproto = -1</p>

<p>for opcode, arg, pos in pickletools.genops(file_object):</p>

<p>maxproto = max(maxproto, opcode.proto)</p>

<p>return maxproto</p>

<p>And here it is in action:
&gt;&gt;&gt; import pickleversion
&gt;&gt;&gt; with open(&lsquo;entry.pickle&rsquo;, &lsquo;rb&rsquo;) as f:
&hellip; v = pickleversion.protocol_version(f)
&gt;&gt;&gt; v</p>

<p>.</p>

<p>13.7. SERIALIZING PYTHON OBJECTS TO BE READ BY OTHER LANGUAGES
The data format used by the pickle module is Python-specific. It makes no attempt to be compatible with other programming languages. If cross-language compatibility is one of your requirements, you need to look at other serialization formats. One such format is JSON. “JSON” stands for “JavaScript Object Notation,” but don’t let the name fool you — JSON is explicitly designed to be usable across multiple programming languages.
Python 3 includes a json module in the standard library. Like the pickle module, the json module has functions for serializing data structures, storing the serialized data on disk, loading serialized data from disk, and unserializing the data back into a new Python object. But there are some important differences, too. First of all, the JSON data format is text-based, not binary. RFC
4627
defines the JSON format and how different types of data must be encoded as text. For example, a boolean value is stored as either the five-character string &lsquo;false&rsquo; or the four-character string &lsquo;true&rsquo;. All JSON values are case-sensitive.
Second, as with any text-based format, there is the issue of whitespace. JSON allows arbitrary amounts of whitespace (spaces, tabs, carriage returns, and line feeds) between values. This whitespace is “insignificant,” which means that JSON encoders can add as much or as little whitespace as they like, and JSON decoders are required to ignore the whitespace between values. This allows you to “pretty-print” your JSON data, nicely nesting values within values at different indentation levels so you can read it in a standard browser or text editor. Python’s json module has options for pretty-printing during encoding.
Third, there’s the perennial problem of character encoding. JSON encodes values as plain text, but as you know, there
ain’t
no
such
thing
as
“plain
text.”
JSON must be stored in a Unicode encoding (UTF-32, UTF-16, or the default, UTF-8), and section
3
of
RFC
4627
defines how to tell which encoding is being used.
.</p>

<p>13.8. SAVING DATA TO A JSON FILE
JSON looks remarkably like a data structure you might define manually in JavaScript. This is no accident; you can actually use the JavaScript eval() function to “decode” JSON-serialized data. (The usual caveats
about
untrusted
input
apply, but the point is that JSON is valid JavaScript.) As such, JSON may already look familiar to you.
&gt;&gt;&gt; shell</p>

<p>1
&gt;&gt;&gt; basic_entry = {} .
&gt;&gt;&gt; basic_entry[&lsquo;id&rsquo;] = 256
&gt;&gt;&gt; basic_entry[&lsquo;title&rsquo;] = &lsquo;Dive into history, 2009 edition&rsquo;
&gt;&gt;&gt; basic_entry[&lsquo;tags&rsquo;] = (&lsquo;diveintopython&rsquo;, &lsquo;docbook&rsquo;, &lsquo;html&rsquo;)
&gt;&gt;&gt; basic_entry[&lsquo;published&rsquo;] = True
&gt;&gt;&gt; basic_entry[&lsquo;comments_link&rsquo;] = None
&gt;&gt;&gt; import json
&gt;&gt;&gt; with open(&lsquo;basic.json&rsquo;, mode=&lsquo;w&rsquo;, encoding=&lsquo;utf-8&rsquo;) as f: .
&hellip; json.dump(basic_entry, f) .</p>

<ol>
<li><p>We’re going to create a new data structure instead of re-using the existing entry data structure. Later in this chapter, we’ll see what happens when we try to encode the more complex data structure in JSON.</p></li>

<li><p>JSON is a text-based format, which means you need to open this file in text mode and specify a character encoding. You can never go wrong with UTF-8.</p></li>

<li><p>Like the pickle module, the json module defines a dump() function which takes a Python data structure and a writeable stream object. The dump() function serializes the Python data structure and writes it to the stream object. Doing this inside a with statement will ensure that the file is closed properly when we’re done.</p></li>
</ol>

<p>So what does the resulting JSON serialization look like?
you@localhost:~/diveintopython3/examples$ cat basic.json
{&ldquo;published&rdquo;: true, &ldquo;tags&rdquo;: [&ldquo;diveintopython&rdquo;, &ldquo;docbook&rdquo;, &ldquo;html&rdquo;], &ldquo;comments_link&rdquo;: null,
&ldquo;id&rdquo;: 256, &ldquo;title&rdquo;: &ldquo;Dive into history, 2009 edition&rdquo;}</p>

<p>That’s certainly more
readable
than
a
pickle
file. But JSON can contain arbitrary whitespace between values, and the json module provides an easy way to take advantage of this to create even more readable JSON files.
&gt;&gt;&gt; shell</p>

<p>1
&gt;&gt;&gt; with open(&lsquo;basic-pretty.json&rsquo;, mode=&lsquo;w&rsquo;, encoding=&lsquo;utf-8&rsquo;) as f:
&hellip; json.dump(basic_entry, f, indent=2
) .</p>

<ol>
<li>If you pass an indent parameter to the json.dump() function, it will make the resulting JSON file more readable, at the expense of larger file size. The indent parameter is an integer. 0 means “put each value on its own line.” A number greater than 0 means “put each value on its own line, and use this number of spaces to indent nested data structures.”
And this is the result:
you@localhost:~/diveintopython3/examples$ cat basic-pretty.json</li>
</ol>

<p>{
&ldquo;published&rdquo;: true,
&ldquo;tags&rdquo;: [</p>

<p>&ldquo;diveintopython&rdquo;,
&ldquo;docbook&rdquo;,
&ldquo;html&rdquo;</p>

<p>],
&ldquo;comments_link&rdquo;: null,
&ldquo;id&rdquo;: 256,
&ldquo;title&rdquo;: &ldquo;Dive into history, 2009 edition&rdquo;</p>

<p>}</p>

<p>.</p>

<p>13.9. MAPPING OF PYTHON DATATYPES TO JSON
Since JSON is not Python-specific, there are some mismatches in its coverage of Python datatypes. Some of them are simply naming differences, but there is two important Python datatypes that are completely missing. See if you can spot them: Did you notice what was missing? Tuples &amp;bytes! JSON has an array type, which the json module maps to a Python list, but it does not have a separate type for “frozen arrays” (tuples). And while JSON supports strings quite nicely, it has no support for bytes objects or byte arrays.</p>

<p>.</p>

<p>13.10. SERIALIZING DATATYPES UNSUPPORTED BY JSON
Even if JSON has no built-in support for bytes, that doesn’t mean you can’t serialize bytes objects. The json module provides extensibility hooks for encoding and decoding unknown datatypes. (By “unknown,” I mean “not defined in JSON.” Obviously the json module knows about byte arrays, but it’s constrained by the limitations of the JSON specification.) If you want to encode bytes or other datatypes that JSON doesn’t support natively, you need to provide custom encoders and decoders for those types.
&gt;&gt;&gt; shell</p>

<p>1
&gt;&gt;&gt; entry .
{&lsquo;comments_link&rsquo;: None,</p>

<p>&lsquo;internal_id&rsquo;: b&rsquo;\xDE\xD5\xB4\xF8&rsquo;,
&lsquo;title&rsquo;: &lsquo;Dive into history, 2009 edition&rsquo;,
&lsquo;tags&rsquo;: (&lsquo;diveintopython&rsquo;, &lsquo;docbook&rsquo;, &lsquo;html&rsquo;),
&lsquo;article_link&rsquo;: &lsquo;<a href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'">http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'</a>,
&lsquo;published_date&rsquo;: time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1),
&lsquo;published&rsquo;: True}</p>

<blockquote>
<blockquote>
<blockquote>
<p>import json
with open(&lsquo;entry.json&rsquo;, &lsquo;w&rsquo;, encoding=&lsquo;utf-8&rsquo;) as f: .
&hellip; json.dump(entry, f) .</p>
</blockquote>
</blockquote>
</blockquote>

<p>&hellip;</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 5, in <module>
File &ldquo;C:\Python31\lib\json__init__.py&rdquo;, line 178, in dump</p>

<p>for chunk in iterable:
File &ldquo;C:\Python31\lib\json\encoder.py&rdquo;, line 408, in _iterencode
for chunk in _iterencode_dict(o, _current_indent_level):
File &ldquo;C:\Python31\lib\json\encoder.py&rdquo;, line 382, in _iterencode_dict
for chunk in chunks:
File &ldquo;C:\Python31\lib\json\encoder.py&rdquo;, line 416, in _iterencode</p>

<p>o = _default(o)
File &ldquo;C:\Python31\lib\json\encoder.py&rdquo;, line 170, in default</p>

<p>raise TypeError(repr(o) + &ldquo; is not JSON serializable&rdquo;)
TypeError: b&rsquo;\xDE\xD5\xB4\xF8&rsquo; is not JSON serializable</p>

<ol>
<li><p>OK, it’s time to revisit the entry data structure. This has it all: a boolean value, a None value, a string, a tuple of strings, a bytes object, and a time structure.</p></li>

<li><p>I know I’ve said it before, but it’s worth repeating: JSON is a text-based format. Always open JSON files in text mode with a UTF-8 character encoding.</p></li>

<li><p>Well that’s not good. What happened?</p></li>
</ol>

<p>Here’s what happened: the json.dump() function tried to serialize the bytes object b&rsquo;\xDE\xD5\xB4\xF8&rsquo;, but it failed, because JSON has no support for bytes objects. However, if storing bytes is important to you, you can define your own “mini-serialization format.”
def to_json(python_object): .
if isinstance(python_object, bytes): .
return {&rsquo;<strong>class</strong>&lsquo;: &lsquo;bytes&rsquo;,
&lsquo;<strong>value</strong>&lsquo;: list(python_object)} .
raise TypeError(repr(python_object) + &lsquo; is not JSON serializable&rsquo;) .</p>

<ol>
<li><p>To define your own “mini-serialization format” for a datatype that JSON doesn’t support natively, just define a function that takes a Python object as a parameter. This Python object will be the actual object that the json.dump() function is unable to serialize by itself — in this case, the bytes object b&rsquo;\xDE\xD5\xB4\xF8&rsquo;.</p></li>

<li><p>Your custom serialization function should check the type of the Python object that the json.dump() function passed to it. This is not strictly necessary if your function only serializes one datatype, but it makes it crystal clear what case your function is covering, and it makes it easier to extend if you need to add serializations for more datatypes later.</p></li>

<li><p>In this case, I’ve chosen to convert a bytes object into a dictionary. The <strong>class</strong> key will hold the original datatype (as a string, &lsquo;bytes&rsquo;), and the <strong>value</strong> key will hold the actual value. Of course this can’t be a bytes object; the entire point is to convert it into something that can be serialized in JSON! A bytes object is just a sequence of integers; each integer is somewhere in the range 0–255. We can use the list() function to convert the bytes object into a list of integers. So b&rsquo;\xDE\xD5\xB4\xF8&rsquo; becomes [222, 213, 180, 248]. (Do the math! It works! The byte \xDE in hexadecimal is 222 in decimal, \xD5 is 213, and so on.)</p></li>

<li><p>This line is important. The data structure you’re serializing may contain types that neither the built-in JSON serializer nor your custom serializer can handle. In this case, your custom serializer must raise a TypeError so that the json.dump() function knows that your custom serializer did not recognize the type.</p></li>
</ol>

<p>That’s it; you don’t need to do anything else. In particular, this custom serialization function returns a Python dictionary, not a string. You’re not doing the entire serializing-to-JSON yourself; you’re only doing the converting-to-a-supported-datatype part. The json.dump() function will do the rest.
&gt;&gt;&gt; shell</p>

<p>1</p>

<blockquote>
<blockquote>
<blockquote>
<p>import customserializer     .
with open(&lsquo;entry.json&rsquo;, &lsquo;w&rsquo;, encoding=&lsquo;utf-8&rsquo;) as f:    .
&hellip; json.dump(entry, f, default=customserializer.to_json
)   .
&hellip;</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;<stdin>&rdquo;, line 9, in <module></p>

<p>json.dump(entry, f, default=customserializer.to_json)</p>

<p>File &ldquo;C:\Python31\lib\json__init__.py&rdquo;, line 178, in dump</p>

<p>for chunk in iterable:</p>

<p>File &ldquo;C:\Python31\lib\json\encoder.py&rdquo;, line 408, in _iterencode</p>

<p>for chunk in _iterencode_dict(o, _current_indent_level):</p>

<p>File &ldquo;C:\Python31\lib\json\encoder.py&rdquo;, line 382, in _iterencode_dict</p>

<p>for chunk in chunks:</p>

<p>File &ldquo;C:\Python31\lib\json\encoder.py&rdquo;, line 416, in _iterencode</p>

<p>o = _default(o)
File &ldquo;/Users/pilgrim/diveintopython3/examples/customserializer.py&rdquo;, line 12, in to_json</p>

<p>raise TypeError(repr(python_object) + &lsquo; is not JSON serializable&rsquo;) . TypeError: time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1) is not JSON serializable
1.  The customserializer module is where you just defined the to_json() function in the previous example.</p>

<ol>
<li><p>Text mode, UTF-8 encoding, yadda yadda. (You’ll forget! I forget sometimes! And everything will work right up until the moment that it fails, and then it will fail most spectacularly.)</p></li>

<li><p>This is the important bit: to hook your custom conversion function into the json.dump() function, pass your function into the json.dump() function in the default parameter. (Hooray, everything
in
Python
is
an
object!)</p></li>

<li><p>OK, so it didn’t actually work. But take a look at the exception. The json.dump() function is no longer complaining about being unable to serialize the bytes object. Now it’s complaining about a completely different object: the time.struct_time object.</p></li>
</ol>

<p>While getting a different exception might not seem like progress, it really is! It’ll just take one more tweak
to get past this.</p>

<p>import time</p>

<p>def to_json(python_object):
if isinstance(python_object, time.struct_time): .
return {&rsquo;<strong>class</strong>&lsquo;: &lsquo;time.asctime&rsquo;,
&lsquo;<strong>value</strong>&lsquo;: time.asctime(python_object)} .
if isinstance(python_object, bytes):
return {&rsquo;<strong>class</strong>&lsquo;: &lsquo;bytes&rsquo;,
&lsquo;<strong>value</strong>&lsquo;: list(python_object)}
raise TypeError(repr(python_object) + &lsquo; is not JSON serializable&rsquo;)</p>

<ol>
<li><p>Adding to our existing customserializer.to_json() function, we need to check whether the Python object (that the json.dump() function is having trouble with) is a time.struct_time.</p></li>

<li><p>If so, we’ll do something similar to the conversion we did with the bytes object: convert the time.struct_time object to a dictionary that only contains JSON-serializable values. In this case, the easiest way to convert a datetime into a JSON-serializable value is to convert it to a string with the time.asctime() function. The time.asctime() function will convert that nasty-looking time.struct_time into the string &lsquo;Fri Mar 27 22:20:42 2009&rsquo;.</p></li>
</ol>

<p>With these two custom conversions, the entire entry data structure should serialize to JSON without any further problems.
&gt;&gt;&gt; shell
1
&gt;&gt;&gt; with open(&lsquo;entry.json&rsquo;, &lsquo;w&rsquo;, encoding=&lsquo;utf-8&rsquo;) as f:
&hellip; json.dump(entry, f, default=customserializer.to_json)
&hellip;</p>

<p>you@localhost:~/diveintopython3/examples$ ls -l example.json
-rw-r&ndash;r&ndash; 1 you you 391 Aug 3 13:34 entry.json
you@localhost:~/diveintopython3/examples$ cat example.json
{&ldquo;published_date&rdquo;: {&rdquo;<strong>class</strong>&ldquo;: &ldquo;time.asctime&rdquo;, &ldquo;<strong>value</strong>&ldquo;: &ldquo;Fri Mar 27 22:20:42 2009&rdquo;},
&ldquo;comments_link&rdquo;: null, &ldquo;internal_id&rdquo;: {&rdquo;<strong>class</strong>&ldquo;: &ldquo;bytes&rdquo;, &ldquo;<strong>value</strong>&ldquo;: [222, 213, 180, 248]},
&ldquo;tags&rdquo;: [&ldquo;diveintopython&rdquo;, &ldquo;docbook&rdquo;, &ldquo;html&rdquo;], &ldquo;title&rdquo;: &ldquo;Dive into history, 2009 edition&rdquo;,
&ldquo;article_link&rdquo;: &ldquo;<a href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&quot;">http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&quot;</a>,
&ldquo;published&rdquo;: true}</p>

<p>.
13.11. LOADING DATA FROM A JSON FILE
Like the pickle module, the json module has a load() function which takes a stream object, reads JSON-encoded data from it, and creates a new Python object that mirrors the JSON data structure.
&gt;&gt;&gt; shell</p>

<p>2
&gt;&gt;&gt; del entry .
&gt;&gt;&gt; entry</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
NameError: name &lsquo;entry&rsquo; is not defined</p>

<blockquote>
<blockquote>
<blockquote>
<p>import json
with open(&lsquo;entry.json&rsquo;, &lsquo;r&rsquo;, encoding=&lsquo;utf-8&rsquo;) as f:
&hellip; entry = json.load(f) .
&hellip;
entry .
{&lsquo;comments_link&rsquo;: None,</p>
</blockquote>
</blockquote>
</blockquote>

<p>&lsquo;internal_id&rsquo;: {&rsquo;<strong>class</strong>&lsquo;: &lsquo;bytes&rsquo;, &lsquo;<strong>value</strong>&lsquo;: [222, 213, 180, 248]},
&lsquo;title&rsquo;: &lsquo;Dive into history, 2009 edition&rsquo;,
&lsquo;tags&rsquo;: [&lsquo;diveintopython&rsquo;, &lsquo;docbook&rsquo;, &lsquo;html&rsquo;],
&lsquo;article_link&rsquo;: &lsquo;<a href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'">http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'</a>,
&lsquo;published_date&rsquo;: {&rsquo;<strong>class</strong>&lsquo;: &lsquo;time.asctime&rsquo;, &lsquo;<strong>value</strong>&lsquo;: &lsquo;Fri Mar 27 22:20:42 2009&rsquo;},
&lsquo;published&rsquo;: True}</p>

<ol>
<li><p>For demonstration purposes, switch to Python Shell #2 and delete the entry data structure that you created earlier in this chapter with the pickle module.</p></li>

<li><p>In the simplest case, the json.load() function works the same as the pickle.load() function. You pass in a stream object and it returns a new Python object.</p></li>

<li><p>I have good news and bad news. Good news first: the json.load() function successfully read the entry.json file you created in Python Shell #1 and created a new Python object that contained the data. Now the bad news: it didn’t recreate the original entry data structure. The two values &lsquo;internal_id&rsquo; and &lsquo;published_date&rsquo; were recreated as dictionaries — specifically, the dictionaries with JSON-compatible values that you created in the to_json() conversion function.</p></li>
</ol>

<p>json.load() doesn’t know anything about any conversion function you may have passed to json.dump(). What you need is the opposite of the to_json() function — a function that will take a custom-converted JSON object and convert it back to the original Python datatype.</p>

<h1 id="add-this-to-customserializer-py">add this to customserializer.py</h1>

<p>def from_json(json_object): .
if &lsquo;<strong>class</strong>&rsquo; in json_object: .
if json_object[&rsquo;<strong>class</strong>&rsquo;] == &lsquo;time.asctime&rsquo;:
return time.strptime(json_object[&rsquo;<strong>value</strong>&rsquo;]) .
if json_object[&rsquo;<strong>class</strong>&rsquo;] == &lsquo;bytes&rsquo;:
return bytes(json_object[&rsquo;<strong>value</strong>&rsquo;]) .
return json_object</p>

<ol>
<li><p>This conversion function also takes one parameter and returns one value. But the parameter it takes is not a string, it’s a Python object — the result of deserializing a JSON-encoded string into Python.</p></li>

<li><p>All you need to do is check whether this object contains the &lsquo;<strong>class</strong>&rsquo; key that the to_json() function created. If so, the value of the &lsquo;<strong>class</strong>&rsquo; key will tell you how to decode the value back into the original Python datatype.</p></li>

<li><p>To decode the time string returned by the time.asctime() function, you use the time.strptime() function. This function takes a formatted datetime string (in a customizable format, but it defaults to the same format that time.asctime() defaults to) and returns a time.struct_time.</p></li>

<li><p>To convert a list of integers back into a bytes object, you can use the bytes() function.</p></li>
</ol>

<p>That was it; there were only two datatypes handled in the to_json() function, and now those two
datatypes are handled in the from_json() function. This is the result:</p>

<blockquote>
<blockquote>
<blockquote>
<p>shell
2
import customserializer
with open(&lsquo;entry.json&rsquo;, &lsquo;r&rsquo;, encoding=&lsquo;utf-8&rsquo;) as f:
&hellip; entry = json.load(f, object_hook=customserializer.from_json) .
&hellip;
entry .
{&lsquo;comments_link&rsquo;: None,</p>
</blockquote>
</blockquote>
</blockquote>

<p>&lsquo;internal_id&rsquo;: b&rsquo;\xDE\xD5\xB4\xF8&rsquo;,
&lsquo;title&rsquo;: &lsquo;Dive into history, 2009 edition&rsquo;,
&lsquo;tags&rsquo;: [&lsquo;diveintopython&rsquo;, &lsquo;docbook&rsquo;, &lsquo;html&rsquo;],
&lsquo;article_link&rsquo;: &lsquo;<a href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'">http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'</a>,
&lsquo;published_date&rsquo;: time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1),
&lsquo;published&rsquo;: True}</p>

<ol>
<li><p>To hook the from_json() function into the deserialization process, pass it as the object_hook parameter to the json.load() function. Functions that take functions; it’s so handy!</p></li>

<li><p>The entry data structure now contains an &lsquo;internal_id&rsquo; key whose value is a bytes object. It also contains a &lsquo;published_date&rsquo; key whose value is a time.struct_time object.</p></li>
</ol>

<p>There is one final glitch, though.
&gt;&gt;&gt; shell
1
&gt;&gt;&gt; import customserializer
&gt;&gt;&gt; with open(&lsquo;entry.json&rsquo;, &lsquo;r&rsquo;, encoding=&lsquo;utf-8&rsquo;) as f:
&hellip; entry2 = json.load(f, object_hook=customserializer.from_json)
&hellip;
&gt;&gt;&gt; entry2 == entry .
False
&gt;&gt;&gt; entry[&lsquo;tags&rsquo;] .
(&lsquo;diveintopython&rsquo;, &lsquo;docbook&rsquo;, &lsquo;html&rsquo;)
&gt;&gt;&gt; entry2[&lsquo;tags&rsquo;] .
[&lsquo;diveintopython&rsquo;, &lsquo;docbook&rsquo;, &lsquo;html&rsquo;]</p>

<ol>
<li><p>Even after hooking the to_json() function into the serialization, and hooking the from_json() function into the deserialization, we still haven’t recreated a perfect replica of the original data structure. Why not?</p></li>

<li><p>In the original entry data structure, the value of the &lsquo;tags&rsquo; key was a tuple of three strings.</p></li>

<li><p>But in the round-tripped entry2 data structure, the value of the &lsquo;tags&rsquo; key is a list of three strings. JSON doesn’t distinguish between tuples and lists; it only has a single list-like datatype, the array, and the json module silently converts both tuples and lists into JSON arrays during serialization. For most uses, you can ignore the difference between tuples and lists, but it’s something to keep in mind as you work with the json module.</p></li>
</ol>

<p>13.12. FURTHER READING
. Many articles about the pickle module make references to cPickle. In Python 2, there were two implementations of the pickle module, one written in pure Python and another written in C (but still callable from Python). In Python 3, these
two
modules
have
been
consolidated, so you should always just import pickle. You may find these articles useful, but you should ignore the now-obsolete information about cPickle.
On pickling with the pickle module:
•   pickle module</p>

<p>•   pickle and
cPickle —
Python
object
serialization</p>

<p>•   Using
pickle</p>

<p>•   Python
persistence
management</p>

<p>•   json —
JavaScript
Object
Notation
Serializer</p>

<p>•   JSON
encoding
and
ecoding
with
custom
objects
in
Python</p>

<p>• Pickling
class
instances</p>

<p>• Persistence
of
external
objects</p>

<p>• Handling
stateful
objects</p>

<p>On  JSON and the json module:
On pickle extensibility:
CHAPTER 14. HTTP WEB SERVICES</p>

<p>. A ruffled mind makes a restless pillow. .
— Charlotte Brontë
14.1. DIVING IN
Philosophically, I can describe HTTP web services in 12 words: exchanging data with remote servers using nothing but the operations of HTTP. If you want to get data from the server, use HTTP GET. If you want to send new data to the server, use HTTP POST. Some more advanced HTTP web service APIs also allow creating, modifying, and deleting data, using HTTP PUT and HTTP DELETE. That’s it. No registries, no envelopes, no wrappers, no tunneling. The “verbs” built into the HTTP protocol (GET, POST, PUT, and DELETE) map directly to application-level operations for retrieving, creating, modifying, and deleting data.
The main advantage of this approach is simplicity, and its simplicity has proven popular. Data — usually XML
or JSON
— can be built and stored statically, or generated dynamically by a server-side script, and all major programming languages (including Python, of course!) include an HTTP library for downloading it. Debugging is also easier; because each resource in an HTTP web service has a unique address (in the form of a URL), you can load it in your web browser and immediately see the raw data.
Examples of HTTP web services:
•   Google
Data
APIs
allow you to interact with a wide variety of Google services, including Blogger
and YouTube.</p>

<p>•   Flickr
Services
allow you to upload and download photos from Flickr.</p>

<p>•   Twitter
API
allows you to publish status updates on Twitter.</p>

<p>•   …and
many
more</p>

<p>•   http.client is a low-level library that implements RFC
2616, the HTTP protocol.</p>

<p>•   urllib.request is an abstraction layer built on top of http.client. It provides a standard API for accessing both HTTP and FTP servers, automatically follows HTTP redirects, and handles some common forms of HTTP authentication.</p>

<p>Python 3 comes with two different libraries for interacting with HTTP web services: So which one should you use? Neither of them. Instead, you should use httplib2, an open source third-party library that implements HTTP more fully than http.client but provides a better abstraction than urllib.request.
To understand why httplib2 is the right choice, you first need to understand HTTP.
.</p>

<p>14.2. FEATURES OF HTTP
There are five important features which all HTTP clients should support.
14.2.1. CACHING
The most important thing to understand about any type of web service is that network access is incredibly expensive. I don’t mean “dollars and cents” expensive (although bandwidth ain’t free). I mean that it takes an extraordinary long time to open a connection, send a request, and retrieve a response from a remote server. Even on the fastest broadband connection, latency (the time it takes to send a request and start retrieving data in a response) can still be higher than you anticipated. A router misbehaves, a packet is dropped, an intermediate proxy is under attack — there’s never
a
dull
moment
on the public internet, and there may be nothing you can do about it.
HTTP is designed with caching in mind. There is an entire class of devices (called “caching proxies”) whose only job is to sit between you and the rest of the world and minimize network access. Your company or ISP almost certainly maintains caching proxies, even if you’re unaware of them. They work because caching built into the HTTP protocol.
Here’s a concrete example of how caching works. You visit diveintomark.org in your browser. That page includes a background image, wearehugh.com/m.jpg. When your browser downloads that image, the server includes the following HTTP headers:
HTTP/1.1 200 OK
Date: Sun, 31 May 2009 17:14:04 GMT
Server: Apache
Last-Modified: Fri, 22 Aug 2008 04:28:16 GMT
ETag: &ldquo;3075-ddc8d800&rdquo;
Accept-Ranges: bytes
Content-Length: 12405
Cache-Control: max-age=31536000, public
Expires: Mon, 31 May 2010 17:14:04 GMT
Connection: close
Content-Type: image/jpeg</p>

<p>The Cache-Control and Expires headers tell your browser (and any caching proxies between you and the server) that this image can be cached for up to a year. A year! And if, in the next year, you visit another page which also includes a link to this image, your browser will load the image from its cache without generating any network activity whatsoever.
But wait, it gets better. Let’s say your browser purges the image from your local cache for some reason. Maybe it ran out of disk space; maybe you manually cleared the cache. Whatever. But the HTTP headers said that this data could be cached by public caching proxies. (Technically, the important thing is what the headers don’t say; the Cache-Control header doesn’t have the private keyword, so this data is cacheable by default.) Caching proxies are designed to have tons of storage space, probably far more than your local browser has allocated.
If your company or ISP maintain a caching proxy, the proxy may still have the image cached. When you visit diveintomark.org again, your browser will look in its local cache for the image, but it won’t find it, so it will make a network request to try to download it from the remote server. But if the caching proxy still has a copy of the image, it will intercept that request and serve the image from its cache. That means that your request will never reach the remote server; in fact, it will never leave your company’s network. That makes for a faster download (fewer network hops) and saves your company money (less data being downloaded from the outside world).
HTTP caching only works when everybody does their part. On one side, servers need to send the correct headers in their response. On the other side, clients need to understand and respect those headers before they request the same data twice. The proxies in the middle are not a panacea; they can only be as smart as the servers and clients allow them to be.
Python’s HTTP libraries do not support caching, but httplib2 does.</p>

<p>14.2.2. LAST-MODIFIED CHECKING
Some data never changes, while other data changes all the time. In between, there is a vast field of data that might have changed, but hasn’t. CNN.com’s feed is updated every few minutes, but my weblog’s feed may not change for days or weeks at a time. In the latter case, I don’t want to tell clients to cache my feed for weeks at a time, because then when I do actually post something, people may not read it for weeks (because they’re respecting my cache headers which said “don’t bother checking this feed for weeks”). On the other hand, I don’t want clients downloading my entire feed once an hour if it hasn’t changed!
HTTP has a solution to this, too. When you request data for the first time, the server can send back a Last-
Modified header. This is exactly what it sounds like: the date that the data was changed. That background image referenced from diveintomark.org included a Last-Modified header.
HTTP/1.1 200 OK
Date: Sun, 31 May 2009 17:14:04 GMT
Server: Apache
Last-Modified: Fri, 22 Aug 2008 04:28:16 GMT
ETag: &ldquo;3075-ddc8d800&rdquo;
Accept-Ranges: bytes
Content-Length: 12405
Cache-Control: max-age=31536000, public
Expires: Mon, 31 May 2010 17:14:04 GMT
Connection: close
Content-Type: image/jpeg</p>

<p>When you request the same data a second (or third or fourth) time, you can send an If-Modified-Since header with your request, with the date you got back from the server last time. If the data has changed since then, then the server ignores the If-Modified-Since header and just gives you the new data with a 200 status code. But if the data hasn’t changed since then, the server sends back a special HTTP 304 status code, which means “this data hasn’t changed since the last time you asked for it.” You can test this on the command line, using curl:
you@localhost:~$ curl -I -H &ldquo;If-Modified-Since: Fri, 22 Aug 2008 04:28:16 GMT&rdquo;
<a href="http://wearehugh.com/m.jpg">http://wearehugh.com/m.jpg</a>
HTTP/1.1 304 Not Modified
Date: Sun, 31 May 2009 18:04:39 GMT
Server: Apache
Connection: close
ETag: &ldquo;3075-ddc8d800&rdquo;
Expires: Mon, 31 May 2010 18:04:39 GMT
Cache-Control: max-age=31536000, public</p>

<p>Why is this an improvement? Because when the server sends a 304, it doesn’t re-send the data. All you get is the status code. Even after your cached copy has expired, last-modified checking ensures that you won’t download the same data twice if it hasn’t changed. (As an extra bonus, this 304 response also includes caching headers. Proxies will keep a copy of data even after it officially “expires,” in the hopes that the data hasn’t really changed and the next request responds with a 304 status code and updated cache information.)
Python’s HTTP libraries do not support last-modified date checking, but httplib2 does.
14.2.3. ETAG CHECKING
ETags are an alternate way to accomplish the same thing as the last-modified
checking. With Etags, the server sends a hash code in an ETag header along with the data you requested. (Exactly how this hash is determined is entirely up to the server. The only requirement is that it changes when the data changes.) That background image referenced from diveintomark.org had an ETag header.
HTTP/1.1 200 OK
Date: Sun, 31 May 2009 17:14:04 GMT
Server: Apache
Last-Modified: Fri, 22 Aug 2008 04:28:16 GMT
ETag: &ldquo;3075-ddc8d800&rdquo;
Accept-Ranges: bytes
Content-Length: 12405
Cache-Control: max-age=31536000, public
Expires: Mon, 31 May 2010 17:14:04 GMT
Connection: close
Content-Type: image/jpeg</p>

<p>The second time you request the same data, you include the ETag hash in an If-None-Match header of your request. If the data hasn’t changed, the server will send you back a 304 status code. As with the last-modified date checking, the server sends back only the 304 status code; it doesn’t send you the same data a second time. By including the ETag hash in your second request, you’re telling the server that there’s no need to re-send the same data if it still matches this hash, since you
still
have
the
data
from
the
last
time.
Again with the curl:</p>

<p>you@localhost:~$ curl -I -H &ldquo;If-None-Match: \&ldquo;3075-ddc8d800\&ldquo;&rdquo;
<a href="http://wearehugh.com/m.jpg">http://wearehugh.com/m.jpg</a> . HTTP/1.1 304 Not Modified Date: Sun, 31 May 2009 18:04:39 GMT Server: Apache Connection: close ETag: &ldquo;3075-ddc8d800&rdquo; Expires: Mon, 31 May 2010 18:04:39 GMT Cache-Control: max-age=31536000, public
1.  ETags are commonly enclosed in quotation marks, but the quotation marks are part of the value. That means you need to send the quotation marks back to the server in the If-None-Match header.
Python’s HTTP libraries do not support ETags, but httplib2 does.</p>

<p>14.2.4. COMPRESSION</p>

<p>When you talk about HTTP web services, you’re almost always talking about moving text-based data back and forth over the wire. Maybe it’s XML, maybe it’s JSON, maybe it’s just plain
text. Regardless of the format, text compresses well. The example feed in the
XML
chapter
is 3070 bytes uncompressed, but would be 941 bytes after gzip compression. That’s just 30% of the original size!
HTTP supports several
compression
algorithms. The two most common types are gzip
and deflate. When you request a resource over HTTP, you can ask the server to send it in compressed format. You include an Accept-encoding header in your request that lists which compression algorithms you support. If the server supports any of the same algorithms, it will send you back compressed data (with a Content-encoding header that tells you which algorithm it used). Then it’s up to you to decompress the data.
. Important tip for server-side developers: make sure that the compressed version of a
resource has a different Etag
than the uncompressed version. Otherwise, caching
proxies will get confused and may serve the compressed version to clients that can’t
handle it. Read the discussion of Apache
bug
39727
for more details on this subtle
issue.</p>

<p>Python’s HTTP libraries do not support compression, but httplib2 does.
14.2.5. REDIRECTS
Cool
URIs
don’t
change, but many URIs are seriously uncool. Web sites get reorganized, pages move to new addresses. Even web services can reorganize. A syndicated feed at <a href="http://example.com/index.xml">http://example.com/index.xml</a> might be moved to <a href="http://example.com/xml/atom.xml">http://example.com/xml/atom.xml</a>. Or an entire domain might move, as an organization expands and reorganizes; <a href="http://www.example.com/index.xml">http://www.example.com/index.xml</a> becomes <a href="http://server­farm-1.example.com/index.xml">http://server­farm-1.example.com/index.xml</a>.
Every time you request any kind of resource from an
HTTP server, the server includes a status code in its
response. Status code 200 means “everything’s normal, here’s the page you asked for”. Status code 404 means “page not found”. (You’ve probably seen 404 errors while browsing the web.) Status codes in the 300’s indicate some form of redirection.
HTTP has several different ways of signifying that a resource has moved. The two most common techiques are status codes 302 and 301. Status code 302 is a temporary redirect; it means “oops, that got moved over</p>

<p>here temporarily” (and then gives the temporary address in a Location header). Status code 301 is a permanent redirect; it means “oops, that got moved permanently” (and then gives the new address in a Location header). If you get a 302 status code and a new address, the HTTP specification says you should use the new address to get what you asked for, but the next time you want to access the same resource, you should retry the old address. But if you get a 301 status code and a new address, you’re supposed to use the new address from then on.
The urllib.request module automatically “follow” redirects when it receives the appropriate status code from the HTTP server, but it doesn’t tell you that it did so. You’ll end up getting data you asked for, but you’ll never know that the underlying library “helpfully” followed a redirect for you. So you’ll continue pounding away at the old address, and each time you’ll get redirected to the new address, and each time the urllib.request module will “helpfully” follow the redirect. In other words, it treats permanent redirects the same as temporary redirects. That means two round trips instead of one, which is bad for the server and bad for you.
httplib2 handles permanent redirects for you. Not only will it tell you that a permanent redirect occurred, it will keep track of them locally and automatically rewrite redirected URLs before requesting them.
.</p>

<p>14.3. HOW NOT TO FETCH DATA OVER HTTP</p>

<p>Let’s say you want to download a resource over HTTP, such as an
Atom
feed. Being a feed, you’re not just going to download it once; you’re going to download it over and over again. (Most feed readers will check for changes once an hour.) Let’s do it the quick-and-dirty way first, and then see how you can do better.
&gt;&gt;&gt; import urllib.request
&gt;&gt;&gt; a_url = &lsquo;<a href="http://diveintopython3.org/examples/feed.xml'">http://diveintopython3.org/examples/feed.xml'</a>
&gt;&gt;&gt; data = urllib.request.urlopen(a_url).read() .
&gt;&gt;&gt; type(data) .
<class 'bytes'>
&gt;&gt;&gt; print(data)
&lt;?xml version=&lsquo;1.0&rsquo; encoding=&lsquo;utf-8&rsquo;?&gt;
<feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'></p>

<p><title>dive into mark</title>
<subtitle>currently between addictions</subtitle>
<id>tag:diveintomark.org,2001-07-29:/</id>
<updated>2009-03-27T21:56:07Z</updated>
<link rel='alternate' type='text/html' href='http://diveintomark.org/'/>
…</p>

<ol>
<li><p>Downloading anything over HTTP is incredibly easy in Python; in fact, it’s a one-liner. The urllib.request module has a handy urlopen() function that takes the address of the page you want, and returns a file-like object that you can just read() from to get the full contents of the page. It just can’t get any easier.</p></li>

<li><p>The urlopen().read() method always returns a
bytes object,
not
a
string. Remember, bytes are bytes; characters are an abstraction. HTTP servers don’t deal in abstractions. If you request a resource, you get bytes. If you want it as a string, you’ll need to determine
the
character
encoding
and explicitly convert it to a string.</p></li>
</ol>

<p>So what’s wrong with this? For a quick one-off during testing or development, there’s nothing wrong with it. I do it all the time. I wanted the contents of the feed, and I got the contents of the feed. The same technique works for any web page. But once you start thinking in terms of a web service that you want to access on a regular basis (e.g. requesting this feed once an hour), then you’re being inefficient, and you’re being rude.
.</p>

<p>14.4. WHAT’S ON THE WIRE?
To see why this is inefficient and rude, let’s turn on the debugging features of Python’s HTTP library and see what’s being sent “on the wire” (i.e. over the network).
&gt;&gt;&gt; from http.client import HTTPConnection
&gt;&gt;&gt; HTTPConnection.debuglevel = 1 .
&gt;&gt;&gt; from urllib.request import urlopen
&gt;&gt;&gt; response = urlopen(&lsquo;<a href="http://diveintopython3.org/examples/feed.xml'">http://diveintopython3.org/examples/feed.xml'</a>) .
send: b&rsquo;GET /examples/feed.xml HTTP/1.1 .
Host: diveintopython3.org .
Accept-Encoding: identity .
User-Agent: Python-urllib/3.1&rsquo; .
Connection: close
reply: &lsquo;HTTP/1.1 200 OK&rsquo;
…further debugging information omitted…</p>

<ol>
<li><p>As I mentioned at the beginning of the chapter, urllib.request relies on another standard Python library, http.client. Normally you don’t need to touch http.client directly. (The urllib.request module imports it automatically.) But we import it here so we can toggle the debugging flag on the HTTPConnection class that urllib.request uses to connect to the HTTP server.</p></li>

<li><p>Now that the debugging flag is set, information on the HTTP request and response is printed out in real time. As you can see, when you request the Atom feed, the urllib.request module sends five lines to the server.</p></li>

<li><p>The first line specifies the HTTP verb you’re using, and the path of the resource (minus the domain name).</p></li>

<li><p>The second line specifies the domain name from which we’re requesting this feed.</p></li>

<li><p>The third line specifies the compression algorithms that the client supports. As I mentioned earlier, urllib.request does
not
support
compression
by default.</p></li>

<li><p>The fourth line specifies the name of the library that is making the request. By default, this is Python-urllib plus a version number. Both urllib.request and httplib2 support changing the user agent, simply by adding a User-Agent header to the request (which will override the default value).</p></li>
</ol>

<p>Now let’s look at what the server sent back in its
response.</p>

<h1 id="continued-from-previous-example">continued from previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>print(response.headers.as_string()) .
Date: Sun, 31 May 2009 19:23:06 GMT .
Server: Apache
Last-Modified: Sun, 31 May 2009 06:39:55 GMT .
ETag: &ldquo;bfe-93d9c4c0&rdquo; .
Accept-Ranges: bytes
Content-Length: 3070 .
Cache-Control: max-age=86400 .
Expires: Mon, 01 Jun 2009 19:23:06 GMT
Vary: Accept-Encoding
Connection: close
Content-Type: application/xml
data = response.read() .
len(data)
3070</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>The response returned from the urllib.request.urlopen() function contains all the HTTP headers the server sent back. It also contains methods to download the actual data; we’ll get to that in a minute.</p></li>

<li><p>The server tells you when it handled your request.</p></li>

<li><p>This response includes a Last-Modified header.</p></li>

<li><p>This response includes an ETag header.</p></li>

<li><p>The data is 3070 bytes long. Notice what isn’t here: a Content-encoding header. Your request stated that you only accept uncompressed data (Accept-encoding: identity), and sure enough, this response contains uncompressed data.</p></li>

<li><p>This response includes caching headers that state that this feed can be cached for up to 24 hours (86400 seconds).</p></li>

<li><p>And finally, download the actual data by calling response.read(). As you can tell from the len() function, this downloads all 3070 bytes at once.</p></li>
</ol>

<p>As you can see, this code is already inefficient: it asked for (and received) uncompressed data. I know for a fact that this server supports gzip
compression, but HTTP compression is opt-in. We didn’t ask for it, so we didn’t get it. That means we’re downloading 3070 bytes when we could have just downloaded 941. Bad dog, no biscuit.
But wait, it gets worse! To see just how inefficient this code is, let’s request the same feed a second time.</p>

<h1 id="continued-from-the-previous-example-9">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>response2 = urlopen(&lsquo;<a href="http://diveintopython3.org/examples/feed.xml'">http://diveintopython3.org/examples/feed.xml'</a>)
send: b&rsquo;GET /examples/feed.xml HTTP/1.1
Host: diveintopython3.org
Accept-Encoding: identity
User-Agent: Python-urllib/3.1&rsquo;
Connection: close
reply: &lsquo;HTTP/1.1 200 OK&rsquo;
…further debugging information omitted…</p>
</blockquote>
</blockquote>
</blockquote>

<p>Notice anything peculiar about this request? It hasn’t changed! It’s exactly the same as the first request. No sign of If-Modified-Since headers. No sign of If-None-Match headers. No respect for the caching headers. Still no compression.
And what happens when you do the same thing twice? You get the same response. Twice.</p>

<h1 id="continued-from-the-previous-example-10">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>print(response2.headers.as_string()) .
Date: Mon, 01 Jun 2009 03:58:00 GMT
Server: Apache
Last-Modified: Sun, 31 May 2009 22:51:11 GMT
ETag: &ldquo;bfe-255ef5c0&rdquo;
Accept-Ranges: bytes
Content-Length: 3070
Cache-Control: max-age=86400
Expires: Tue, 02 Jun 2009 03:58:00 GMT
Vary: Accept-Encoding
Connection: close
Content-Type: application/xml
data2 = response2.read()
len(data2) .
3070
data2 == data .
True</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>The server is still sending the same array of “smart” headers: Cache-Control and Expires to allow caching, Last-Modified and ETag to enable “not-modified” tracking. Even the Vary: Accept-Encoding header hints that the server would support compression, if only you would ask for it. But you didn’t.</p></li>

<li><p>Once again, fetching this data downloads the whole 3070 bytes…</p></li>

<li><p>…the exact same 3070 bytes you downloaded last time.</p></li>
</ol>

<p>HTTP is designed to work better than this. urllib speaks HTTP like I speak Spanish — enough to get by in a jam, but not enough to hold a conversation. HTTP is a conversation. It’s time to upgrade to a library that speaks HTTP fluently.
.
14.5. INTRODUCING httplib2
Before you can use httplib2, you’ll need to install it. Visit code.google.com/p/httplib2/ and download the latest version. httplib2 is available for Python 2.x and Python 3.x; make sure you get the Python 3 version, named something like httplib2-python3-0.5.0.zip.
Unzip the archive, open a terminal window, and go to the newly created httplib2 directory. On Windows, open the Start menu, select Run&hellip;, type cmd.exe and press ENTER.
c:\Users\pilgrim\Downloads&gt; dir
Volume in drive C has no label.
Volume Serial Number is DED5-B4F8</p>

<p>Directory of c:\Users\pilgrim\Downloads</p>

<p>07/28/2009 12:36 PM <DIR> .
07/28/2009 12:36 PM <DIR> ..
07/28/2009 12:36 PM <DIR> httplib2-python3-0.5.0
07/28/2009 12:33 PM 18,997 httplib2-python3-0.5.0.zip</p>

<p>1 File(s) 18,997 bytes
3 Dir(s) 61,496,684,544 bytes free</p>

<p>c:\Users\pilgrim\Downloads&gt; cd httplib2-python3-0.5.0
c:\Users\pilgrim\Downloads\httplib2-python3-0.5.0&gt; c:\python31\python.exe setup.py install
running install
running build
running build_py
running install_lib
creating c:\python31\Lib\site-packages\httplib2
copying build\lib\httplib2\iri2uri.py -&gt; c:\python31\Lib\site-packages\httplib2
copying build\lib\httplib2__init<strong>.py -&gt; c:\python31\Lib\site-packages\httplib2
byte-compiling c:\python31\Lib\site-packages\httplib2\iri2uri.py to iri2uri.pyc
byte-compiling c:\python31\Lib\site-packages\httplib2__init</strong>.py to <strong>init</strong>.pyc
running install_egg_info
Writing c:\python31\Lib\site-packages\httplib2-python3_0.5.0-py3.1.egg-info</p>

<p>On Mac OS X, run the Terminal.app application in your /Applications/Utilities/ folder. On Linux, run the Terminal application, which is usually in your Applications menu under Accessories or System.
you@localhost:~/Desktop$ unzip httplib2-python3-0.5.0.zip</p>

<p>Archive: httplib2-python3-0.5.0.zip</p>

<p>inflating: httplib2-python3-0.5.0/README</p>

<p>inflating: httplib2-python3-0.5.0/setup.py</p>

<p>inflating: httplib2-python3-0.5.0/PKG-INFO</p>

<p>inflating: httplib2-python3-0.5.0/httplib2/<strong>init</strong>.py</p>

<p>inflating: httplib2-python3-0.5.0/httplib2/iri2uri.py</p>

<p>you@localhost:~/Desktop$ cd httplib2-python3-0.5.0/</p>

<p>you@localhost:~/Desktop/httplib2-python3-0.5.0$ sudo python3 setup.py install</p>

<p>running install</p>

<p>running build</p>

<p>running build_py</p>

<p>creating build</p>

<p>creating build/lib.linux-x86_64-3.1</p>

<p>creating build/lib.linux-x86_64-3.1/httplib2</p>

<p>copying httplib2/iri2uri.py -&gt; build/lib.linux-x86_64-3.1/httplib2</p>

<p>copying httplib2/<strong>init</strong>.py -&gt; build/lib.linux-x86_64-3.1/httplib2</p>

<p>running install_lib</p>

<p>creating /usr/local/lib/python3.1/dist-packages/httplib2</p>

<p>copying build/lib.linux-x86_64-3.1/httplib2/iri2uri.py -&gt; /usr/local/lib/python3.1/dist-packages/httplib2</p>

<p>copying build/lib.linux-x86_64-3.1/httplib2/<strong>init</strong>.py -&gt; /usr/local/lib/python3.1/dist-packages/httplib2</p>

<p>byte-compiling /usr/local/lib/python3.1/dist-packages/httplib2/iri2uri.py to iri2uri.pyc</p>

<p>byte-compiling /usr/local/lib/python3.1/dist-packages/httplib2/<strong>init</strong>.py to <strong>init</strong>.pyc</p>

<p>running install_egg_info</p>

<p>Writing /usr/local/lib/python3.1/dist-packages/httplib2-python3_0.5.0.egg-info</p>

<p>To use httplib2, create an instance of the httplib2.Http class.
&gt;&gt;&gt; import httplib2
&gt;&gt;&gt; h = httplib2.Http(&lsquo;.cache&rsquo;) .
&gt;&gt;&gt; response, content = h.request(&lsquo;<a href="http://diveintopython3.org/examples/feed.xml'">http://diveintopython3.org/examples/feed.xml'</a>) .
&gt;&gt;&gt; response.status .
200
&gt;&gt;&gt; content[:52] .
b&rdquo;&lt;?xml version=&lsquo;1.0&rsquo; encoding=&lsquo;utf-8&rsquo;?&gt;\r\n<feed xmlns=" 
>&gt;&gt; len(content)
3070</p>

<ol>
<li><p>The primary interface to httplib2 is the Http object. For reasons you’ll see in the next section, you should always pass a directory name when you create an Http object. The directory does not need to exist; httplib2 will create it if necessary.</p></li>

<li><p>Once you have an Http object, retrieving data is as simple as calling the request() method with the address of the data you want. This will issue an HTTP GET request for that URL. (Later in this chapter, you’ll see how to issue other HTTP requests, like POST.)</p></li>

<li><p>The request() method returns two values. The first is an httplib2.Response object, which contains all the HTTP headers the server returned. For example, a status code of 200 indicates that the request was successful.</p></li>

<li><p>The content variable contains the actual data that was returned by the HTTP server. The data is returned as a
bytes object,
not
a
string. If you want it as a string, you’ll need to determine
the
character
encoding
and convert it yourself.</p></li>
</ol>

<p>. You probably only need one httplib2.Http object. There are valid reasons for creating more than one, but you should only do so if you know why you need them. “I need to request data from two different URLs” is not a valid reason. Re-use the Http object and just call the request() method twice.</p>

<p>14.5.1. A SHORT DIGRESSION TO EXPLAIN WHY httplib2 RETURNS BYTES INSTEAD OF STRINGS
Bytes. Strings. What a pain. Why can’t httplib2 “just” do the conversion for you? Well, it’s complicated, because the rules for determining the character encoding are specific to what kind of resource you’re requesting. How could httplib2 know what kind of resource you’re requesting? It’s usually listed in the Content-Type HTTP header, but that’s an optional feature of HTTP and not all HTTP servers include it. If that header is not included in the HTTP response, it’s left up to the client to guess. (This is commonly called “content sniffing,” and it’s never perfect.)
If you know what sort of resource you’re expecting (an XML document in this case), perhaps you could “just” pass the returned bytes object to the xml.etree.ElementTree.parse() function. That’ll work as long as the XML document includes information on its own character encoding (as this one does), but that’s an optional feature and not all XML documents do that. If an XML document doesn’t include encoding information, the client is supposed to look at the enclosing transport — i.e. the Content-Type HTTP header, which can include a charset parameter.
But it’s worse than that. Now character encoding information can be in two
places: within the XML document itself, and within the Content-Type HTTP
header. If the information is in both places, which one wins? According to RFC</p>

<p>3023
(I swear I am not making this up), if the media type given in the Content-
Type HTTP header is application/xml, application/xml-dtd, application/
xml-external-parsed-entity, or any one of the subtypes of application/xml
such as application/atom+xml or application/rss+xml or even application/
rdf+xml, then the encoding is</p>

<ol>
<li><p>the encoding given in the charset parameter of the Content-Type HTTP header, or</p></li>

<li><p>the encoding given in the encoding attribute of the XML declaration within the document, or 3. UTF-8</p></li>
</ol>

<p>On the other hand, if the media type given in the Content-Type HTTP header is text/xml, text/xml­external-parsed-entity, or a subtype like text/AnythingAtAll+xml, then the encoding attribute of the XML declaration within the document is ignored completely, and the encoding is</p>

<ol>
<li>the encoding given in the charset parameter of the Content-Type HTTP header, or</li>
<li>us-ascii
And that’s just for XML documents. For HTML documents, web browsers have constructed such byzantine
rules
for
content-sniffing
[PDF] that we’re
still
trying
to
figure
them
all
out.
“Patches
welcome.”</li>
</ol>

<p>14.5.2. HOW httplib2 HANDLES CACHING
Remember in the previous section when I said you should always create an httplib2.Http object with a directory name? Caching is the reason.</p>

<h1 id="continued-from-the-previous-example-11">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>response2, content2 = h.request(&lsquo;<a href="http://diveintopython3.org/examples/feed.xml'">http://diveintopython3.org/examples/feed.xml'</a>) .
response2.status .
200
content2[:52] .
b&rdquo;&lt;?xml version=&lsquo;1.0&rsquo; encoding=&lsquo;utf-8&rsquo;?&gt;\r\n&lt;feed xmlns=&rdquo;
len(content2)
3070</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>This shouldn’t be terribly surprising. It’s the same thing you did last time, except you’re putting the result into two new variables.</p></li>

<li><p>The HTTP status is once again 200, just like last time.</p></li>

<li><p>The downloaded content is the same as last time, too.</p></li>
</ol>

<p>So… who cares? Quit your Python interactive shell and relaunch it with a new session, and I’ll show you.</p>

<h1 id="not-continued-from-previous-example">NOT continued from previous example!</h1>

<h1 id="please-exit-out-of-the-interactive-shell">Please exit out of the interactive shell</h1>

<h1 id="and-launch-a-new-one">and launch a new one.</h1>

<blockquote>
<blockquote>
<blockquote>
<p>import httplib2
httplib2.debuglevel = 1 .
h = httplib2.Http(&lsquo;.cache&rsquo;) .
response, content = h.request(&lsquo;<a href="http://diveintopython3.org/examples/feed.xml'">http://diveintopython3.org/examples/feed.xml'</a>) .
len(content) .
3070
response.status .
200
response.fromcache .
True</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>Let’s turn on debugging and see what’s
on
the
wire. This is the httplib2 equivalent of turning on debugging in http.client. httplib2 will print all the data being sent to the server and some key information being sent back.</p></li>

<li><p>Create an httplib2.Http object with the same directory name as before.</p></li>

<li><p>Request the same URL as before. Nothing appears to happen. More precisely, nothing gets sent to the server, and nothing gets returned from the server. There is absolutely no network activity whatsoever.</p></li>

<li><p>Yet we did “receive” some data — in fact, we received all of it.</p></li>

<li><p>We also “received” an HTTP status code indicating that the “request” was successful.</p></li>

<li><p>Here’s the rub: this “response” was generated from httplib2’s local cache. That directory name you passed in when you created the httplib2.Http object — that directory holds httplib2’s cache of all the operations it’s ever performed.</p></li>
</ol>

<p>. If you want to turn on httplib2 debugging, you need to set a module-level constant
(httplib2.debuglevel), then create a new httplib2.Http object. If you want to turn off debugging, you need to change the same module-level constant, then create a new httplib2.Http object.
You previously requested the data at this URL. That request was successful (status: 200). That response included not only the feed data, but also a set of caching
headers
that told anyone who was listening that they could cache this resource for up to 24 hours (Cache­</p>

<p>Control: max-age=86400, which is 24 hours measured in seconds). httplib2 understand and respects those caching headers, and it stored the previous response in the .cache directory (which you passed in when you create the Http object). That cache hasn’t expired yet, so the second time you request the data at this URL, httplib2 simply returns the cached result without ever hitting the network.
I say “simply,” but obviously there is a lot of complexity hidden behind that simplicity. httplib2 handles HTTP caching automatically and by default. If for some reason you need to know whether a response came from the cache, you can check response.fromcache. Otherwise, it Just Works.
Now, suppose you have data cached, but you want to bypass the cache and re-request it from the remote server. Browsers sometimes do this if the user specifically requests it. For example, pressing F5 refreshes the current page, but pressing Ctrl+F5 bypasses the cache and re-requests the current page from the remote server. You might think “oh, I’ll just delete the data from my local cache, then request it again.” You could do that, but remember that there may be more parties involved than just you and the remote server. What about those intermediate proxy servers? They’re completely beyond your control, and they may still have that data cached, and will happily return it to you because (as far as they are concerned) their cache is still valid.
Instead of manipulating your local cache and hoping for the best, you should use the features of HTTP to ensure that your request actually reaches the remote server.</p>

<h1 id="continued-from-the-previous-example-12">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>response2, content2 = h.request(&lsquo;<a href="http://diveintopython3.org/examples/feed.xml'">http://diveintopython3.org/examples/feed.xml'</a>,</p>
</blockquote>
</blockquote>
</blockquote>

<p>&hellip;  headers={&lsquo;cache-control&rsquo;:&lsquo;no-cache&rsquo;})  .<br />
connect: (diveintopython3.org, 80)  .<br />
send: b&rsquo;GET /examples/feed.xml HTTP/1.1<br />
Host: diveintopython3.org<br />
user-agent: Python-httplib2/$Rev: 259 $<br />
accept-encoding: deflate, gzip<br />
cache-control: no-cache&rsquo;<br />
reply: &lsquo;HTTP/1.1 200 OK&rsquo;<br />
…further debugging information omitted…<br />
&gt;&gt;&gt; response2.status<br />
200<br />
&gt;&gt;&gt; response2.fromcache  .<br />
False<br />
&gt;&gt;&gt; print(dict(response2.items()))  .<br />
{&lsquo;status&rsquo;: &lsquo;200&rsquo;,<br />
&lsquo;content-length&rsquo;: &lsquo;3070&rsquo;,</p>

<p>&lsquo;content-location&rsquo;: &lsquo;<a href="http://diveintopython3.org/examples/feed.xml'">http://diveintopython3.org/examples/feed.xml'</a>,
&lsquo;accept-ranges&rsquo;: &lsquo;bytes&rsquo;,
&lsquo;expires&rsquo;: &lsquo;Wed, 03 Jun 2009 00:40:26 GMT&rsquo;,
&lsquo;vary&rsquo;: &lsquo;Accept-Encoding&rsquo;,
&lsquo;server&rsquo;: &lsquo;Apache&rsquo;,
&lsquo;last-modified&rsquo;: &lsquo;Sun, 31 May 2009 22:51:11 GMT&rsquo;,
&lsquo;connection&rsquo;: &lsquo;close&rsquo;,
&lsquo;-content-encoding&rsquo;: &lsquo;gzip&rsquo;,
&lsquo;etag&rsquo;: &lsquo;&ldquo;bfe-255ef5c0&rdquo;&rsquo;,
&lsquo;cache-control&rsquo;: &lsquo;max-age=86400&rsquo;,
&lsquo;date&rsquo;: &lsquo;Tue, 02 Jun 2009 00:40:26 GMT&rsquo;,
&lsquo;content-type&rsquo;: &lsquo;application/xml&rsquo;}</p>

<ol>
<li><p>httplib2 allows you to add arbitrary HTTP headers to any outgoing request. In order to bypass all caches (not just your local disk cache, but also any caching proxies between you and the remote server), add a no-cache header in the headers dictionary.</p></li>

<li><p>Now you see httplib2 initiating a network request. httplib2 understands and respects caching headers in both directions — as part of the incoming response and as part of the outgoing request. It noticed that you added the no-cache header, so it bypassed its local cache altogether and then had no choice but to hit the network to request the data.</p></li>

<li><p>This response was not generated from your local cache. You knew that, of course, because you saw the debugging information on the outgoing request. But it’s nice to have that programmatically verified.</p></li>

<li><p>The request succeeded; you downloaded the entire feed again from the remote server. Of course, the server also sent back a full complement of HTTP headers along with the feed data. That includes caching headers, which httplib2 uses to update its local cache, in the hopes of avoiding network access the next time you request this feed. Everything about HTTP caching is designed to maximize cache hits and minimize network access. Even though you bypassed the cache this time, the remote server would really appreciate it if you would cache the result for next time.</p></li>
</ol>

<p>14.5.3. HOW httplib2 HANDLES Last-Modified AND ETag HEADERS
The Cache-Control and Expires caching
headers
are called freshness indicators. They tell caches in no uncertain terms that you can completely avoid all network access until the cache expires. And that’s exactly the behavior you saw in
the
previous
section: given a freshness indicator, httplib2 does not generate a single byte of network activity to serve up cached data (unless you explicitly bypass
the
cache, of course).
But what about the case where the data might have changed, but hasn’t? HTTP defines Last-Modified and Etag headers for this purpose. These headers are called validators. If the local cache is no longer fresh, a client can send the validators with the next request to see if the data has actually changed. If the data hasn’t changed, the server sends back a 304 status code and no data. So there’s still a round-trip over the network, but you end up downloading fewer bytes.
&gt;&gt;&gt; import httplib2</p>

<blockquote>
<blockquote>
<blockquote>
<p>httplib2.debuglevel = 1</p>

<p>h = httplib2.Http(&lsquo;.cache&rsquo;)</p>

<p>response, content = h.request(&lsquo;<a href="http://diveintopython3.org/'">http://diveintopython3.org/'</a>) .
connect: (diveintopython3.org, 80)</p>
</blockquote>
</blockquote>
</blockquote>

<p>send: b&rsquo;GET / HTTP/1.1</p>

<p>Host: diveintopython3.org</p>

<p>accept-encoding: deflate, gzip</p>

<p>user-agent: Python-httplib2/$Rev: 259 $&rsquo;</p>

<p>reply: &lsquo;HTTP/1.1 200 OK&rsquo;</p>

<blockquote>
<blockquote>
<blockquote>
<p>print(dict(response.items()))   .
{&lsquo;-content-encoding&rsquo;: &lsquo;gzip&rsquo;,</p>
</blockquote>
</blockquote>
</blockquote>

<p>&lsquo;accept-ranges&rsquo;: &lsquo;bytes&rsquo;,</p>

<p>&lsquo;connection&rsquo;: &lsquo;close&rsquo;,</p>

<p>&lsquo;content-length&rsquo;: &lsquo;6657&rsquo;,</p>

<p>&lsquo;content-location&rsquo;: &lsquo;<a href="http://diveintopython3.org/'">http://diveintopython3.org/'</a>,</p>

<p>&lsquo;content-type&rsquo;: &lsquo;text/html&rsquo;,</p>

<p>&lsquo;date&rsquo;: &lsquo;Tue, 02 Jun 2009 03:26:54 GMT&rsquo;,</p>

<p>&lsquo;etag&rsquo;: &lsquo;&ldquo;7f806d-1a01-9fb97900&rdquo;&rsquo;,
&lsquo;last-modified&rsquo;: &lsquo;Tue, 02 Jun 2009 02:51:48 GMT&rsquo;,</p>

<p>&lsquo;server&rsquo;: &lsquo;Apache&rsquo;,</p>

<p>&lsquo;status&rsquo;: &lsquo;200&rsquo;,</p>

<p>&lsquo;vary&rsquo;: &lsquo;Accept-Encoding,User-Agent&rsquo;}</p>

<blockquote>
<blockquote>
<blockquote>
<p>len(content)    .
6657</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>Instead of the feed, this time we’re going to download the site’s home page, which is HTML. Since this is the first time you’ve ever requested this page, httplib2 has little to work with, and it sends out a minimum of headers with the request.</p></li>

<li><p>The response contains a multitude of HTTP headers… but no caching information. However, it does include both an ETag and Last-Modified header.</p></li>

<li><p>At the time I constructed this example, this page was 6657 bytes. It’s probably changed since then, but don’t worry about it.</p></li>
</ol>

<h1 id="continued-from-the-previous-example-13">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>response, content = h.request(&lsquo;<a href="http://diveintopython3.org/'">http://diveintopython3.org/'</a>) .
connect: (diveintopython3.org, 80)
send: b&rsquo;GET / HTTP/1.1
Host: diveintopython3.org
if-none-match: &ldquo;7f806d-1a01-9fb97900&rdquo; .
if-modified-since: Tue, 02 Jun 2009 02:51:48 GMT .
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $&rsquo;
reply: &lsquo;HTTP/1.1 304 Not Modified&rsquo; .
response.fromcache .
True
response.status .
200
response.dict[&lsquo;status&rsquo;] .
&lsquo;304&rsquo;
len(content) .
6657</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>You request the same page again, with the same Http object (and the same local cache).</p></li>

<li><p>httplib2 sends the ETag validator back to the server in the If-None-Match header.</p></li>

<li><p>httplib2 also sends the Last-Modified validator back to the server in the If-Modified-Since header.</p></li>

<li><p>The server looked at these validators, looked at the page you requested, and determined that the page has not changed since you last requested it, so it sends back a 304 status code and no data.</p></li>

<li><p>Back on the client, httplib2 notices the 304 status code and loads the content of the page from its cache.</p></li>

<li><p>This might be a bit confusing. There are really two status codes — 304 (returned from the server this time, which caused httplib2 to look in its cache), and 200 (returned from the server last time, and stored in httplib2’s cache along with the page data). response.status returns the status from the cache.</p></li>

<li><p>If you want the raw status code returned from the server, you can get that by looking in response.dict, which is a dictionary of the actual headers returned from the server.</p></li>

<li><p>However, you still get the data in the content variable. Generally, you don’t need to know why a response was served from the cache. (You may not even care that it was served from the cache at all, and that’s fine too. httplib2 is smart enough to let you act dumb.) By the time the request() method returns to the caller, httplib2 has already updated its cache and returned the data to you.</p></li>
</ol>

<p>14.5.4. HOW http2lib HANDLES COMPRESSION
HTTP supports several
types
of
compression; the two most common types are gzip and deflate. httplib2 supports both of these.</p>

<blockquote>
<blockquote>
<blockquote>
<p>response, content = h.request(&lsquo;<a href="http://diveintopython3.org/'">http://diveintopython3.org/'</a>)</p>
</blockquote>
</blockquote>
</blockquote>

<p>connect: (diveintopython3.org, 80)
send: b&rsquo;GET / HTTP/1.1
Host: diveintopython3.org
accept-encoding: deflate, gzip .
user-agent: Python-httplib2/$Rev: 259 $&rsquo;
reply: &lsquo;HTTP/1.1 200 OK&rsquo;
&gt;&gt;&gt; print(dict(response.items()))
{&lsquo;-content-encoding&rsquo;: &lsquo;gzip&rsquo;, .</p>

<p>&lsquo;accept-ranges&rsquo;: &lsquo;bytes&rsquo;,
&lsquo;connection&rsquo;: &lsquo;close&rsquo;,
&lsquo;content-length&rsquo;: &lsquo;6657&rsquo;,
&lsquo;content-location&rsquo;: &lsquo;<a href="http://diveintopython3.org/'">http://diveintopython3.org/'</a>,
&lsquo;content-type&rsquo;: &lsquo;text/html&rsquo;,
&lsquo;date&rsquo;: &lsquo;Tue, 02 Jun 2009 03:26:54 GMT&rsquo;,
&lsquo;etag&rsquo;: &lsquo;&ldquo;7f806d-1a01-9fb97900&rdquo;&rsquo;,
&lsquo;last-modified&rsquo;: &lsquo;Tue, 02 Jun 2009 02:51:48 GMT&rsquo;,
&lsquo;server&rsquo;: &lsquo;Apache&rsquo;,
&lsquo;status&rsquo;: &lsquo;304&rsquo;,
&lsquo;vary&rsquo;: &lsquo;Accept-Encoding,User-Agent&rsquo;}</p>

<ol>
<li><p>Every time httplib2 sends a request, it includes an Accept-Encoding header to tell the server that it can handle either deflate or gzip compression.</p></li>

<li><p>In this case, the server has responded with a gzip-compressed payload. By the time the request() method returns, httplib2 has already decompressed the body of the response and placed it in the content variable. If you’re curious about whether or not the response was compressed, you can check response[&lsquo;-content­encoding&rsquo;]; otherwise, don’t worry about it.</p></li>
</ol>

<p>14.5.5. HOW httplib2 HANDLES REDIRECTS
HTTP defines two
kinds
of
redirects: temporary and permanent. There’s nothing special to do with
temporary redirects except follow them, which httplib2 does automatically.</p>

<blockquote>
<blockquote>
<blockquote>
<p>import httplib2
httplib2.debuglevel = 1
h = httplib2.Http(&lsquo;.cache&rsquo;)
response, content = h.request(&lsquo;<a href="http://diveintopython3.org/examples/feed-302.xml'">http://diveintopython3.org/examples/feed-302.xml'</a>) .
connect: (diveintopython3.org, 80)
send: b&rsquo;GET /examples/feed-302.xml HTTP/1.1 .
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $&rsquo;
reply: &lsquo;HTTP/1.1 302 Found&rsquo; .
send: b&rsquo;GET /examples/feed.xml HTTP/1.1 .
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $&rsquo;
reply: &lsquo;HTTP/1.1 200 OK&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>There is no feed at this URL. I’ve set up my server to issue a temporary redirect to the correct address.</p></li>

<li><p>There’s the request.</p></li>

<li><p>And there’s the response: 302 Found. Not shown here, this response also includes a Location header that points to the real URL.</p></li>

<li><p>httplib2 immediately turns around and “follows” the redirect by issuing another request for the URL given in the Location header: <a href="http://diveintopython3.org/examples/feed.xml">http://diveintopython3.org/examples/feed.xml</a></p></li>
</ol>

<p>“Following” a redirect is nothing more than this example shows. httplib2 sends a request for the URL you asked for. The server comes back with a response that says “No no, look over there instead.” httplib2 sends another request for the new URL.</p>

<h1 id="continued-from-the-previous-example-14">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>response .
{&lsquo;status&rsquo;: &lsquo;200&rsquo;,</p>
</blockquote>
</blockquote>
</blockquote>

<p>&lsquo;content-length&rsquo;: &lsquo;3070&rsquo;,
&lsquo;content-location&rsquo;: &lsquo;<a href="http://diveintopython3.org/examples/feed.xml'">http://diveintopython3.org/examples/feed.xml'</a>, .
&lsquo;accept-ranges&rsquo;: &lsquo;bytes&rsquo;,
&lsquo;expires&rsquo;: &lsquo;Thu, 04 Jun 2009 02:21:41 GMT&rsquo;,
&lsquo;vary&rsquo;: &lsquo;Accept-Encoding&rsquo;,
&lsquo;server&rsquo;: &lsquo;Apache&rsquo;,
&lsquo;last-modified&rsquo;: &lsquo;Wed, 03 Jun 2009 02:20:15 GMT&rsquo;,
&lsquo;connection&rsquo;: &lsquo;close&rsquo;,
&lsquo;-content-encoding&rsquo;: &lsquo;gzip&rsquo;, .
&lsquo;etag&rsquo;: &lsquo;&ldquo;bfe-4cbbf5c0&rdquo;&rsquo;,
&lsquo;cache-control&rsquo;: &lsquo;max-age=86400&rsquo;, .
&lsquo;date&rsquo;: &lsquo;Wed, 03 Jun 2009 02:21:41 GMT&rsquo;,
&lsquo;content-type&rsquo;: &lsquo;application/xml&rsquo;}</p>

<ol>
<li><p>The response you get back from this single call to the request() method is the response from the final URL.</p></li>

<li><p>httplib2 adds the final URL to the response dictionary, as content-location. This is not a header that came from the server; it’s specific to httplib2.</p></li>

<li><p>Apropos of nothing, this feed is compressed.</p></li>

<li><p>And cacheable. (This is important, as you’ll see in a minute.)</p></li>
</ol>

<p>The response you get back gives you information about the final URL. What if you want more information about the intermediate URLs, the ones that eventually redirected to the final URL? httplib2 lets you do that, too.</p>

<h1 id="continued-from-the-previous-example-15">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>response.previous .
{&lsquo;status&rsquo;: &lsquo;302&rsquo;,</p>
</blockquote>
</blockquote>
</blockquote>

<p>&lsquo;content-length&rsquo;: &lsquo;228&rsquo;,
&lsquo;content-location&rsquo;: &lsquo;<a href="http://diveintopython3.org/examples/feed-302.xml'">http://diveintopython3.org/examples/feed-302.xml'</a>,
&lsquo;expires&rsquo;: &lsquo;Thu, 04 Jun 2009 02:21:41 GMT&rsquo;,
&lsquo;server&rsquo;: &lsquo;Apache&rsquo;,
&lsquo;connection&rsquo;: &lsquo;close&rsquo;,
&lsquo;location&rsquo;: &lsquo;<a href="http://diveintopython3.org/examples/feed.xml'">http://diveintopython3.org/examples/feed.xml'</a>,
&lsquo;cache-control&rsquo;: &lsquo;max-age=86400&rsquo;,
&lsquo;date&rsquo;: &lsquo;Wed, 03 Jun 2009 02:21:41 GMT&rsquo;,
&lsquo;content-type&rsquo;: &lsquo;text/html; charset=iso-8859-1&rsquo;}</p>

<blockquote>
<blockquote>
<blockquote>
<p>type(response) .
<class 'httplib2.Response'>
type(response.previous)
<class 'httplib2.Response'>
response.previous.previous .</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li>The response.previous attribute holds a reference to the previous response object that httplib2 followed to get to the current response object.</li>
<li>Both response and response.previous are httplib2.Response objects.</li>

<li><p>That means you can check response.previous.previous to follow the redirect chain backwards even further. (Scenario: one URL redirects to a second URL which redirects to a third URL. It could happen!) In this case, we’ve already reached the beginning of the redirect chain, so the attribute is None.
What happens if you request the same URL again?</p>

<h1 id="continued-from-the-previous-example-16">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>response2, content2 = h.request(&lsquo;<a href="http://diveintopython3.org/examples/feed-302.xml'">http://diveintopython3.org/examples/feed-302.xml'</a>) .
connect: (diveintopython3.org, 80)
send: b&rsquo;GET /examples/feed-302.xml HTTP/1.1 .
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $&rsquo;
reply: &lsquo;HTTP/1.1 302 Found&rsquo; .
content2 == content .
True</p>
</blockquote>
</blockquote>
</blockquote></li>

<li><p>Same URL, same httplib2.Http object (and therefore the same cache).</p></li>

<li><p>The 302 response was not cached, so httplib2 sends another request for the same URL.</p></li>

<li><p>Once again, the server responds with a 302. But notice what didn’t happen: there wasn’t ever a second request for the final URL, <a href="http://diveintopython3.org/examples/feed.xml">http://diveintopython3.org/examples/feed.xml</a>. That response was cached (remember the Cache-Control header that you saw in the previous example). Once httplib2 received the 302 Found code, it checked its cache before issuing another request. The cache contained a fresh copy of <a href="http://diveintopython3.org/examples/feed.xml">http://diveintopython3.org/examples/feed.xml</a>, so there was no need to re-request it.</p></li>

<li><p>By the time the request() method returns, it has read the feed data from the cache and returned it. Of course, it’s the same as the data you received last time.</p></li>
</ol>

<p>In other words, you don’t have to do anything special for temporary redirects. httplib2 will follow them automatically, and the fact that one URL redirects to another has no bearing on httplib2’s support for compression, caching, ETags, or any of the other features of HTTP.
Permanent redirects are just as simple.</p>

<h1 id="continued-from-the-previous-example-17">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>response, content = h.request(&lsquo;<a href="http://diveintopython3.org/examples/feed-301.xml'">http://diveintopython3.org/examples/feed-301.xml'</a>) .
connect: (diveintopython3.org, 80)
send: b&rsquo;GET /examples/feed-301.xml HTTP/1.1
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $&rsquo;
reply: &lsquo;HTTP/1.1 301 Moved Permanently&rsquo; .
response.fromcache .
True</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>Once again, this URL doesn’t really exist. I’ve set up my server to issue a permanent redirect to <a href="http://diveintopython3.org/examples/feed.xml">http://diveintopython3.org/examples/feed.xml</a>.</p></li>

<li><p>And here it is: status code 301. But again, notice what didn’t happen: there was no request to the redirect URL. Why not? Because it’s already cached locally.</p></li>

<li><p>httplib2 “followed” the redirect right into its cache.</p></li>
</ol>

<p>But wait! There’s more!</p>

<h1 id="continued-from-the-previous-example-18">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>response2, content2 = h.request(&lsquo;<a href="http://diveintopython3.org/examples/feed-301.xml'">http://diveintopython3.org/examples/feed-301.xml'</a>) .
response2.fromcache .
True
content2 == content .
True</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>Here’s the difference between temporary and permanent redirects: once httplib2 follows a permanent redirect, all further requests for that URL will transparently be rewritten to the target URL without hitting the network for the original URL . Remember, debugging is still turned on, yet there is no output of network activity whatsoever.</p></li>

<li><p>Yep, this response was retrieved from the local cache.</p></li>

<li><p>Yep, you got the entire feed (from the cache).</p></li>
</ol>

<p>HTTP. It works.
.</p>

<p>14.6. BEYOND HTTP GET
HTTP web services are not limited to GET requests. What if you want to create something new? Whenever you post a comment on a discussion forum, update your weblog, publish your status on a microblogging service like Twitter
or Identi.ca, you’re probably already using HTTP POST.
Both Twitter and Identi.ca both offer a simple HTTP-based API for publishing and updating your status in 140 characters or less. Let’s look at Identi.ca’s
API
documentation
for
updating
your
status:</p>

<p>Identi.ca REST API Method: statuses/update
Updates the authenticating user’s status. Requires the status parameter specified below. Request must be a POST.
URL
<a href="https://identi.ca/api/statuses/update.format">https://identi.ca/api/statuses/update.format</a></p>

<p>Formats
xml, json, rss, atom
HTTP Method(s)
POST</p>

<p>Requires Authentication
true
Parameters
status. Required. The text of your status update. URL-encode as necessary.
How does this work? To publish a new message on Identi.ca, you need to issue an HTTP POST request to <a href="http://identi.ca/api/statuses/update.format">http://identi.ca/api/statuses/update.format</a>. (The format bit is not part of the URL; you replace it with the data format you want the server to return in response to your request. So if you want a response in XML, you would post the request to <a href="https://identi.ca/api/statuses/update.xml.">https://identi.ca/api/statuses/update.xml.</a>) The request needs to include a parameter called status, which contains the text of your status update. And the request needs to be authenticated.
Authenticated? Sure. To update your status on Identi.ca, you need to prove who you are. Identi.ca is not a wiki; only you can update your own status. Identi.ca uses HTTP
Basic
Authentication
(a.k.a. RFC
2617) over SSL to provide secure but easy-to-use authentication. httplib2 supports both SSL and HTTP Basic Authentication, so this part is easy.
A POST request is different from a GET request, because it includes a payload. The payload is the data you want to send to the server. The one piece of data that this API method requires is status, and it should be URL-encoded. This is a very simple serialization format that takes a set of key-value pairs (i.e. a dictionary) and transforms it into a string.
&gt;&gt;&gt; from urllib.parse import urlencode .
&gt;&gt;&gt; data = {&lsquo;status&rsquo;: &lsquo;Test update from Python 3&rsquo;} .
&gt;&gt;&gt; urlencode(data) .
&lsquo;status=Test+update+from+Python+3&rsquo;</p>

<ol>
<li><p>Python comes with a utility function to URL-encode a dictionary: urllib.parse.urlencode().</p></li>

<li><p>This is the sort of dictionary that the Identi.ca API is looking for. It contains one key, status, whose value is the text of a single status update.</p></li>

<li><p>This is what the URL-encoded string looks like. This is the payload that will be sent “on the wire” to the Identi.ca API server in your HTTP POST request.</p></li>
</ol>

<blockquote>
<blockquote>
<blockquote>
<p>from urllib.parse import urlencode
import httplib2
httplib2.debuglevel = 1
h = httplib2.Http(&lsquo;.cache&rsquo;)
data = {&lsquo;status&rsquo;: &lsquo;Test update from Python 3&rsquo;}
h.add_credentials(&lsquo;diveintomark&rsquo;, &lsquo;MY_SECRET_PASSWORD&rsquo;, &lsquo;identi.ca&rsquo;) .
resp, content = h.request(&lsquo;<a href="https://identi.ca/api/statuses/update.xml'">https://identi.ca/api/statuses/update.xml'</a>,
&hellip; &lsquo;POST&rsquo;, .
&hellip; urlencode(data), .
&hellip; headers={&lsquo;Content-Type&rsquo;: &lsquo;application/x-www-form-urlencoded&rsquo;}) .</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>This is how httplib2 handles authentication. Store your username and password with the add_credentials() method. When httplib2 tries to issue the request, the server will respond with a 401 Unauthorized status code, and it will list which authentication methods it supports (in the WWW-Authenticate header). httplib2 will automatically construct an Authorization header and re-request the URL.</p></li>

<li><p>The second parameter is the type of HTTP request, in this case POST.</p></li>

<li><p>The third parameter is the payload to send to the server. We’re sending the URL-encoded dictionary with a status message.</p></li>

<li><p>Finally, we need to tell the server that the payload is URL-encoded data.</p></li>
</ol>

<p>. The third parameter to the add_credentials() method is the domain in which the credentials are valid. You should always specify this! If you leave out the domain and later reuse the httplib2.Http object on a different authenticated site, httplib2 might end up leaking one site’s username and password to the other site.
This is what goes over the wire:</p>

<h1 id="continued-from-the-previous-example-19">continued from the previous example</h1>

<p>send: b&rsquo;POST /api/statuses/update.xml HTTP/1.1
Host: identi.ca
Accept-Encoding: identity
Content-Length: 32
content-type: application/x-www-form-urlencoded
user-agent: Python-httplib2/$Rev: 259 $</p>

<p>status=Test+update+from+Python+3&rsquo;
reply: &lsquo;HTTP/1.1 401 Unauthorized&rsquo; .
send: b&rsquo;POST /api/statuses/update.xml HTTP/1.1 .
Host: identi.ca
Accept-Encoding: identity
Content-Length: 32
content-type: application/x-www-form-urlencoded
authorization: Basic SECRET_HASH_CONSTRUCTED_BY_HTTPLIB2 .
user-agent: Python-httplib2/$Rev: 259 $</p>

<p>status=Test+update+from+Python+3&rsquo;
reply: &lsquo;HTTP/1.1 200 OK&rsquo; .</p>

<ol>
<li><p>After the first request, the server responds with a 401 Unauthorized status code. httplib2 will never send authentication headers unless the server explicitly asks for them. This is how the server asks for them.</p></li>

<li><p>httplib2 immediately turns around and requests the same URL a second time.</p></li>

<li><p>This time, it includes the username and password that you added with the add_credentials() method.</p></li>

<li><p>It worked!</p></li>
</ol>

<p>What does the server send back after a successful request? That depends entirely on the web service API. In some protocols (like the Atom
Publishing
Protocol), the server sends back a 201 Created status code and the location of the newly created resource in the Location header. Identi.ca sends back a 200 OK and an XML document containing information about the newly created resource.</p>

<h1 id="continued-from-the-previous-example-20">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>print(content.decode(&lsquo;utf-8&rsquo;)) .
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;
<status></p>
</blockquote>
</blockquote>
</blockquote>

<p><text>Test update from Python 3</text> .
<truncated>false</truncated>
<created_at>Wed Jun 10 03:53:46 +0000 2009</created_at>
<in_reply_to_status_id></in_reply_to_status_id>
<source>api</source>
<id>5131472</id> .
<in_reply_to_user_id></in_reply_to_user_id>
<in_reply_to_screen_name></in_reply_to_screen_name>
<favorited>false</favorited>
<user></p>

<p><id>3212</id>
<name>Mark Pilgrim</name>
<screen_name>diveintomark</screen_name>
<location>27502, US</location>
<description>tech writer, husband, father</description>
<profile_image_url><a href="http://avatar.identi.ca/3212-48-20081216000626.png">http://avatar.identi.ca/3212-48-20081216000626.png</a></profile_image_url>
<url><a href="http://diveintomark.org/">http://diveintomark.org/</a></url>
<protected>false</protected>
<followers_count>329</followers_count>
<profile_background_color></profile_background_color>
<profile_text_color></profile_text_color>
<profile_link_color></profile_link_color>
<profile_sidebar_fill_color></profile_sidebar_fill_color>
<profile_sidebar_border_color></profile_sidebar_border_color>
<friends_count>2</friends_count>
<created_at>Wed Jul 02 22:03:58 +0000 2008</created_at>
<favourites_count>30768</favourites_count>
<utc_offset>0</utc_offset>
<time_zone>UTC</time_zone>
<profile_background_image_url></profile_background_image_url></p>

<p><profile_background_tile>false</profile_background_tile></p>

<p><statuses_count>122</statuses_count>
<following>false</following>
<notifications>false</notifications></p>

<p></user>
</status></p>

<ol>
<li><p>Remember, the data returned by httplib2 is always bytes, not a string. To convert it to a string, you need to decode it using the proper character encoding. Identi.ca’s API always returns results in UTF-8, so that part is easy.</p></li>

<li><p>There’s the text of the status message we just published.</p></li>

<li><p>There’s the unique identifier for the new status message. Identi.ca uses this to construct a URL for viewing the message on the web.</p></li>
</ol>

<p>And here it is:</p>

<p>.
14.7. BEYOND HTTP POST
HTTP isn’t limited to GET and POST. Those are certainly the most common types of requests, especially in web browsers. But web service APIs can go beyond GET and POST, and httplib2 is ready.</p>

<h1 id="continued-from-the-previous-example-21">continued from the previous example</h1>

<blockquote>
<blockquote>
<blockquote>
<p>from xml.etree import ElementTree as etree
tree = etree.fromstring(content) .
status_id = tree.findtext(&lsquo;id&rsquo;) .
status_id
&lsquo;5131472&rsquo;
url = &lsquo;<a href="https://identi.ca/api/statuses/destroy/{0}.xml'.format(status_id">https://identi.ca/api/statuses/destroy/{0}.xml'.format(status_id</a>) .
resp, deleted_content = h.request(url, &lsquo;DELETE&rsquo;) .</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>The server returned XML, right? You know how
to
parse
XML.</p></li>

<li><p>The findtext() method finds the first instance of the given expression and extracts its text content. In this case, we’re just looking for an <id> element.</p></li>

<li><p>Based on the text content of the <id> element, we can construct a URL to delete the status message we just published.</p></li>

<li><p>To delete a message, you simply issue an HTTP DELETE request to that URL.</p></li>
</ol>

<p>This is what goes over the wire:
send: b&rsquo;DELETE /api/statuses/destroy/5131472.xml HTTP/1.1 .
Host: identi.ca
Accept-Encoding: identity
user-agent: Python-httplib2/$Rev: 259 $</p>

<p>&rsquo;
reply: &lsquo;HTTP/1.1 401 Unauthorized&rsquo; .
send: b&rsquo;DELETE /api/statuses/destroy/5131472.xml HTTP/1.1 .
Host: identi.ca
Accept-Encoding: identity
authorization: Basic SECRET_HASH_CONSTRUCTED_BY_HTTPLIB2 .
user-agent: Python-httplib2/$Rev: 259 $</p>

<p>&rsquo;
reply: &lsquo;HTTP/1.1 200 OK&rsquo; .
&gt;&gt;&gt; resp.status
200</p>

<ol>
<li><p>“Delete this status message.”</p></li>

<li><p>“I’m sorry, Dave, I’m afraid I can’t do that.”</p></li>

<li><p>“Unauthorized. Hmmph. Delete this status message, please…</p></li>

<li><p>…and here’s my username and password.”</p></li>

<li><p>“Consider it done!”</p></li>
</ol>

<p>And just like that, poof, it’s gone.</p>

<p>.
14.8. FURTHER READING
httplib2:
• httplib2 project
page</p>

<p>• More
httplib2 code
examples</p>

<p>• Doing
HTTP
Caching
Right:
Introducing
httplib2</p>

<p>• httplib2:
HTTP
Persistence
and
Authentication</p>

<p>• HTTP
Caching
Tutorial
by Mark Nottingham</p>

<p>• How
to
control
caching
with
HTTP
headers
on Google Doctype</p>

<p>RFCs:</p>

<p>• RFC
2616:
HTTP</p>

<p>• RFC
2617:
HTTP
Basic
Authentication</p>

<p>• RFC
1951:
deflate
compression</p>

<p>• RFC
1952:
gzip
compression</p>

<p>HTTP caching:
CHAPTER 15. CASE STUDY: PORTING chardet TO PYTHON 3
. Words, words. They’re all we have to go on. .
— Rosencrantz and Guildenstern are Dead
15.1. DIVING IN
Question: what’s the #1 cause of gibberish text on the web, in your inbox, and across every computer system ever written? It’s character encoding. In the Strings
chapter, I talked about the history of character encoding and the creation of Unicode, the “one encoding to rule them all.” I’d love it if I never had to see a gibberish character on a web page again, because all authoring systems stored accurate encoding information, all transfer protocols were Unicode-aware, and every system that handled text maintained perfect fidelity when converting between encodings.
I’d also like a pony.
A Unicode pony.
A Unipony, as it were.
I’ll settle for character encoding auto-detection.
.</p>

<p>15.2. WHAT IS CHARACTER ENCODING AUTO-DETECTION?</p>

<p>It means taking a sequence of bytes in an unknown character encoding, and attempting to determine the encoding so you can read the text. It’s like cracking a code when you don’t have the decryption key.</p>

<p>15.2.1. ISN’T THAT IMPOSSIBLE?
In general, yes. However, some encodings are optimized for specific languages, and languages are not random. Some character sequences pop up all the time, while other sequences make no sense. A person fluent in English who opens a newspaper and finds “txzqJv 2!dasd0a QqdKjvz” will instantly recognize that that isn’t English (even though it is composed entirely of English letters). By studying lots of “typical” text, a computer algorithm can simulate this kind of fluency and make an educated guess about a text’s language.
In other words, encoding detection is really language detection, combined with knowledge of which languages tend to use which character encodings.</p>

<p>15.2.2. DOES SUCH AN ALGORITHM EXIST?
As it turns out, yes. All major browsers have character encoding auto-detection, because the web is full of pages that have no encoding information whatsoever. Mozilla
Firefox
contains
an
encoding
auto-detection
library
which is open source. I
ported
the
library
to
Python
2
and dubbed it the chardet module. This chapter will take you step-by-step through the process of porting the chardet module from Python 2 to Python 3.
.</p>

<p>15.3. INTRODUCING THE chardet MODULE
Before we set off porting the code, it would help if you understood how the code worked! This is a brief guide to navigating the code itself. The chardet library is too large to include inline here, but you can download
it
from
chardet.feedparser.org.
The main entry point for the detection algorithm is
universaldetector.py, which has one class,
UniversalDetector. (You might think the main entry
point is the detect function in chardet/<strong>init</strong>.py,
but that’s really just a convenience function that creates
a UniversalDetector object, calls it, and returns its
result.)</p>

<p>There are 5 categories of encodings that
UniversalDetector handles:</p>

<ol>
<li><p>UTF-N with a Byte Order Mark (BOM). This includes UTF-8, both Big-Endian and Little-Endian variants of UTF-16, and all 4 byte-order variants of UTF-32.</p></li>

<li><p>Escaped encodings, which are entirely 7-bit ASCII compatible, where non-ASCII characters start with an escape sequence. Examples: ISO-2022-JP (Japanese) and HZ-GB-2312 (Chinese).</p></li>

<li><p>Multi-byte encodings, where each character is represented by a variable number of bytes. Examples: BIG5 (Chinese), SHIFT_JIS (Japanese), EUC-KR (Korean), and UTF-8 without a BOM.</p></li>

<li><p>Single-byte encodings, where each character is represented by one byte. Examples: KOI8-R (Russian), WINDOWS-1255 (Hebrew), and TIS-620 (Thai).</p></li>

<li><p>WINDOWS-1252, which is used primarily on Microsoft Windows by middle managers who wouldn’t know a character encoding from a hole in the ground.</p></li>
</ol>

<p>15.3.1. UTF-N WITH A BOM
If the text starts with a BOM, we can reasonably assume that the text is encoded in UTF-8, UTF-16, or UTF-32. (The BOM will tell us exactly which one; that’s what it’s for.) This is handled inline in UniversalDetector, which returns the result immediately without any further processing.</p>

<p>15.3.2. ESCAPED ENCODINGS</p>

<p>If the text contains a recognizable escape sequence that might indicate an escaped encoding, UniversalDetector creates an EscCharSetProber (defined in escprober.py) and feeds it the text.
EscCharSetProber creates a series of state machines, based on models of HZ-GB-2312, ISO-2022-CN, ISO-2022-JP, and ISO-2022-KR (defined in escsm.py). EscCharSetProber feeds the text to each of these state machines, one byte at a time. If any state machine ends up uniquely identifying the encoding, EscCharSetProber immediately returns the positive result to UniversalDetector, which returns it to the caller. If any state machine hits an illegal sequence, it is dropped and processing continues with the other state machines.</p>

<p>15.3.3. MULTI-BYTE ENCODINGS
Assuming no BOM, UniversalDetector checks whether the text contains any high-bit characters. If so, it creates a series of “probers” for detecting multi-byte encodings, single-byte encodings, and as a last resort, windows-1252.
The multi-byte encoding prober, MBCSGroupProber (defined in mbcsgroupprober.py), is really just a shell that manages a group of other probers, one for each multi-byte encoding: BIG5, GB2312, EUC-TW, EUC­KR, EUC-JP, SHIFT_JIS, and UTF-8. MBCSGroupProber feeds the text to each of these encoding-specific probers and checks the results. If a prober reports that it has found an illegal byte sequence, it is dropped from further processing (so that, for instance, any subsequent calls to UniversalDetector.feed() will skip that prober). If a prober reports that it is reasonably confident that it has detected the encoding, MBCSGroupProber reports this positive result to UniversalDetector, which reports the result to the caller.
Most of the multi-byte encoding probers are inherited from MultiByteCharSetProber (defined in mbcharsetprober.py), and simply hook up the appropriate state machine and distribution analyzer and let MultiByteCharSetProber do the rest of the work. MultiByteCharSetProber runs the text through the encoding-specific state machine, one byte at a time, to look for byte sequences that would indicate a conclusive positive or negative result. At the same time, MultiByteCharSetProber feeds the text to an encoding-specific distribution analyzer.
The distribution analyzers (each defined in chardistribution.py) use language-specific models of which characters are used most frequently. Once MultiByteCharSetProber has fed enough text to the distribution analyzer, it calculates a confidence rating based on the number of frequently-used characters, the total number of characters, and a language-specific distribution ratio. If the confidence is high enough, MultiByteCharSetProber returns the result to MBCSGroupProber, which returns it to UniversalDetector, which returns it to the caller.
The case of Japanese is more difficult. Single-character distribution analysis is not always sufficient to distinguish between EUC-JP and SHIFT_JIS, so the SJISProber (defined in sjisprober.py) also uses 2-character distribution analysis. SJISContextAnalysis and EUCJPContextAnalysis (both defined in jpcntx.py and both inheriting from a common JapaneseContextAnalysis class) check the frequency of Hiragana syllabary characters within the text. Once enough text has been processed, they return a confidence level to SJISProber, which checks both analyzers and returns the higher confidence level to MBCSGroupProber.</p>

<p>15.3.4. SINGLE-BYTE ENCODINGS
The single-byte encoding prober, SBCSGroupProber (defined in sbcsgroupprober.py), is also just a shell
that manages a group of other probers, one for each combination of single-byte encoding and language: windows-1251, KOI8-R, ISO-8859-5, MacCyrillic, IBM855, and IBM866 (Russian); ISO-8859-7 and windows-1253 (Greek); ISO-8859-5 and windows-1251 (Bulgarian); ISO-8859-2 and windows-1250 (Hungarian); TIS-620 (Thai); windows-1255 and ISO-8859-8 (Hebrew).
SBCSGroupProber feeds the text to each of these encoding+language-specific probers and checks the results. These probers are all implemented as a single</p>

<p>class, SingleByteCharSetProber (defined in sbcharsetprober.py), which takes a language model as an argument. The language model defines how frequently different 2-character sequences appear in typical text. SingleByteCharSetProber processes the text and tallies the most frequently used 2-character sequences. Once enough text has been processed, it calculates a confidence level based on the number of frequently-used sequences, the total number of characters, and a language-specific distribution ratio.
Hebrew is handled as a special case. If the text appears to be Hebrew based on 2-character distribution analysis, HebrewProber (defined in hebrewprober.py) tries to distinguish between Visual Hebrew (where the source text actually stored “backwards” line-by-line, and then displayed verbatim so it can be read from right to left) and Logical Hebrew (where the source text is stored in reading order and then rendered right-to-left by the client). Because certain characters are encoded differently based on whether they appear in the middle of or at the end of a word, we can make a reasonable guess about direction of the source text, and return the appropriate encoding (windows-1255 for Logical Hebrew, or ISO-8859-8 for Visual Hebrew).
15.3.5. windows-1252
If UniversalDetector detects a high-bit character in the text, but none of the other multi-byte or single-byte encoding probers return a confident result, it creates a Latin1Prober (defined in latin1prober.py) to try to detect English text in a windows-1252 encoding. This detection is inherently unreliable, because English letters are encoded in the same way in many different encodings. The only way to distinguish windows-1252 is through commonly used symbols like smart quotes, curly apostrophes, copyright symbols, and the like. Latin1Prober automatically reduces its confidence rating to allow more accurate probers to win if at all possible.
.</p>

<p>15.4. RUNNING 2to3
We’re going to migrate the chardet module from Python 2 to Python 3. Python 3 comes with a utility script called 2to3, which takes your actual Python 2 source code as input and auto-converts as much as it can to Python 3. In some cases this is easy — a function was renamed or moved to a different module — but in other cases it can get pretty complex. To get a sense of all that it can do, refer to the appendix, Porting
code
to
Python
3
with
2to3. In this chapter, we’ll start by running 2to3 on the chardet
package, but as you’ll see, there will still be a lot of work to do after the automated tools have performed
their magic.
The main chardet package is split across several different files, all in the same directory. The 2to3 script makes it easy to convert multiple files at once: just pass a directory as a command line argument, and 2to3 will convert each of the files in turn.
C:\home\chardet&gt; python c:\Python30\Tools\Scripts\2to3.py -w chardet\
RefactoringTool: Skipping implicit fixer: buffer
RefactoringTool: Skipping implicit fixer: idioms
RefactoringTool: Skipping implicit fixer: set_literal
RefactoringTool: Skipping implicit fixer: ws_comma
&mdash; chardet__init<strong>.py (original)
+++ chardet__init</strong>.py (refactored)
@@ -18,7 +18,7 @@</p>

<p><strong>version</strong> = &ldquo;1.0.1&rdquo;</p>

<p>def detect(aBuf):</p>

<ul>
<li>import universaldetector<br /></li>
<li>from . import universaldetector<br /></li>
</ul>

<p>u = universaldetector.UniversalDetector()
u.reset()
u.feed(aBuf)</p>

<p>&mdash; chardet\big5prober.py (original)
+++ chardet\big5prober.py (refactored)
@@ -25,10 +25,10 @@</p>

<h1 id="02110-1301-usa">02110-1301 USA</h1>

<p>######################### END LICENSE BLOCK #########################</p>

<p>-from mbcharsetprober import MultiByteCharSetProber<br />
-from codingstatemachine import CodingStateMachine<br />
-from chardistribution import Big5DistributionAnalysis<br />
-from mbcssm import Big5SMModel<br />
+from .mbcharsetprober import MultiByteCharSetProber<br />
+from .codingstatemachine import CodingStateMachine<br />
+from .chardistribution import Big5DistributionAnalysis<br />
+from .mbcssm import Big5SMModel</p>

<p>class Big5Prober(MultiByteCharSetProber):
def <strong>init</strong>(self):
&mdash; chardet\chardistribution.py (original)</p>

<p>+++ chardet\chardistribution.py (refactored)</p>

<p>@@ -25,12 +25,12 @@</p>

<h1 id="02110-1301-usa-1">02110-1301 USA</h1>

<p>######################### END LICENSE BLOCK #########################</p>

<p>-import constants<br />
-from euctwfreq import EUCTWCharToFreqOrder, EUCTW_TABLE_SIZE, EUCTW_TYPICAL_DISTRIBUTION_RATIO<br />
-from euckrfreq import EUCKRCharToFreqOrder, EUCKR_TABLE_SIZE, EUCKR_TYPICAL_DISTRIBUTION_RATIO<br />
-from gb2312freq import GB2312CharToFreqOrder, GB2312_TABLE_SIZE, GB2312_TYPICAL_DISTRIBUTION_RATIO<br />
-from big5freq import Big5CharToFreqOrder, BIG5_TABLE_SIZE, BIG5_TYPICAL_DISTRIBUTION_RATIO<br />
-from jisfreq import JISCharToFreqOrder, JIS_TABLE_SIZE, JIS_TYPICAL_DISTRIBUTION_RATIO<br />
+from . import constants<br />
+from .euctwfreq import EUCTWCharToFreqOrder, EUCTW_TABLE_SIZE, EUCTW_TYPICAL_DISTRIBUTION_RATIO<br />
+from .euckrfreq import EUCKRCharToFreqOrder, EUCKR_TABLE_SIZE, EUCKR_TYPICAL_DISTRIBUTION_RATIO<br />
+from .gb2312freq import GB2312CharToFreqOrder, GB2312_TABLE_SIZE, GB2312_TYPICAL_DISTRIBUTION_RATIO<br />
+from .big5freq import Big5CharToFreqOrder, BIG5_TABLE_SIZE, BIG5_TYPICAL_DISTRIBUTION_RATIO<br />
+from .jisfreq import JISCharToFreqOrder, JIS_TABLE_SIZE, JIS_TYPICAL_DISTRIBUTION_RATIO</p>

<p>ENOUGH_DATA_THRESHOLD = 1024</p>

<p>SURE_YES = 0.99
.
.
. (it goes on like this for a while)
.
.
RefactoringTool: Files that were modified:
RefactoringTool: chardet__init__.py
RefactoringTool: chardet\big5prober.py
RefactoringTool: chardet\chardistribution.py
RefactoringTool: chardet\charsetgroupprober.py
RefactoringTool: chardet\codingstatemachine.py
RefactoringTool: chardet\constants.py
RefactoringTool: chardet\escprober.py
RefactoringTool: chardet\escsm.py</p>

<p>RefactoringTool: chardet\eucjpprober.py
RefactoringTool: chardet\euckrprober.py
RefactoringTool: chardet\euctwprober.py
RefactoringTool: chardet\gb2312prober.py
RefactoringTool: chardet\hebrewprober.py
RefactoringTool: chardet\jpcntx.py
RefactoringTool: chardet\langbulgarianmodel.py
RefactoringTool: chardet\langcyrillicmodel.py
RefactoringTool: chardet\langgreekmodel.py
RefactoringTool: chardet\langhebrewmodel.py
RefactoringTool: chardet\langhungarianmodel.py
RefactoringTool: chardet\langthaimodel.py
RefactoringTool: chardet\latin1prober.py
RefactoringTool: chardet\mbcharsetprober.py
RefactoringTool: chardet\mbcsgroupprober.py
RefactoringTool: chardet\mbcssm.py
RefactoringTool: chardet\sbcharsetprober.py
RefactoringTool: chardet\sbcsgroupprober.py
RefactoringTool: chardet\sjisprober.py
RefactoringTool: chardet\universaldetector.py
RefactoringTool: chardet\utf8prober.py</p>

<p>Now run the 2to3 script on the testing harness, test.py.
C:\home\chardet&gt; python c:\Python30\Tools\Scripts\2to3.py -w test.py
RefactoringTool: Skipping implicit fixer: buffer
RefactoringTool: Skipping implicit fixer: idioms
RefactoringTool: Skipping implicit fixer: set_literal
RefactoringTool: Skipping implicit fixer: ws_comma
&mdash; test.py (original)
+++ test.py (refactored)
@@ -4,7 +4,7 @@</p>

<p>count = 0
u = UniversalDetector()
for f in glob.glob(sys.argv[1]):</p>

<ul>
<li>print f.ljust(60),<br /></li>
<li>print(f.ljust(60), end=&rsquo; &lsquo;)<br /></li>
</ul>

<p>u.reset()
for line in file(f, &lsquo;rb&rsquo;):
u.feed(line)</p>

<p>@@ -12,8 +12,8 @@
u.close()
result = u.result
if result[&lsquo;encoding&rsquo;]:</p>

<ul>
<li>print result[&lsquo;encoding&rsquo;], &lsquo;with confidence&rsquo;, result[&lsquo;confidence&rsquo;]<br /></li>
<li>print(result[&lsquo;encoding&rsquo;], &lsquo;with confidence&rsquo;, result[&lsquo;confidence&rsquo;])<br /></li>
</ul>

<p>else:</p>

<ul>
<li>print &lsquo;******** no result&rsquo;<br /></li>
<li>print(&rsquo;******** no result&rsquo;)<br /></li>
</ul>

<p>count += 1</p>

<p>-print count, &lsquo;tests&rsquo;<br />
+print(count, &lsquo;tests&rsquo;)</p>

<p>RefactoringTool: Files that were modified:
RefactoringTool: test.py</p>

<p>Well, that wasn’t so hard. Just a few imports and print statements to convert. Speaking of which, what was the problem with all those import statements? To answer that, you need to understand how the chardet module is split into multiple files.
.
15.5. A SHORT DIGRESSION INTO MULTI-FILE MODULES
chardet is a multi-file module. I could have chosen to put all the code in one file (named chardet.py), but I didn’t. Instead, I made a directory (named chardet), then I made an <strong>init</strong>.py file in that directory. If Python sees an <strong>init</strong>.py file in a directory, it assumes that all of the files in that directory are part of the same module. The module’s name is the name of the directory. Files within the directory can reference other files within the same directory, or even within subdirectories. (More on that in a minute.) But the entire collection of files is presented to other Python code as a single module — as if all the functions and classes were in a single .py file.
What goes in the <strong>init</strong>.py file? Nothing. Everything. Something in between. The <strong>init</strong>.py file doesn’t need to define anything; it can literally be an empty file. Or you can use it to define your main entry point functions. Or you put all your functions in it. Or all but one.
. A directory with an <strong>init</strong>.py file is always treated as a multi-file module. Without an <strong>init</strong>.py file, a directory is just a directory of unrelated .py files.
Let’s see how that works in practice.
&gt;&gt;&gt; import chardet
&gt;&gt;&gt; dir(chardet) .
[&rsquo;<strong>builtins</strong>&rsquo;, &lsquo;<strong>doc</strong>&rsquo;, &lsquo;<strong>file</strong>&rsquo;, &lsquo;<strong>name</strong>&rsquo;,</p>

<p>&lsquo;<strong>package</strong>&rsquo;, &lsquo;<strong>path</strong>&rsquo;, &lsquo;<strong>version</strong>&rsquo;, &lsquo;detect&rsquo;]
&gt;&gt;&gt; chardet .
<module 'chardet' from 'C:\Python31\lib\site-packages\chardet\__init__.py'></p>

<ol>
<li><p>Other than the usual class attributes, the only thing in the chardet module is a detect() function.</p></li>

<li><p>Here’s your first clue that the chardet module is more than just a file: the “module” is listed as the <strong>init</strong>.py file within the chardet/ directory.</p></li>
</ol>

<p>Let’s take a peek in that <strong>init</strong>.py file.
def detect(aBuf): .
from . import universaldetector .
u = universaldetector.UniversalDetector()
u.reset()
u.feed(aBuf)
u.close()
return u.result</p>

<ol>
<li><p>The <strong>init</strong>.py file defines the detect() function, which is the main entry point into the chardet library.</p></li>

<li><p>But the detect() function hardly has any code! In fact, all it really does is import the universaldetector module and start using it. But where is universaldetector defined?</p></li>
</ol>

<p>The answer lies in that odd-looking import statement:
from . import universaldetector</p>

<p>Translated into English, that means “import the universaldetector module; that’s in the same directory I am,” where “I” is the chardet/<strong>init</strong>.py file. This is called a relative import. It’s a way for the files within a multi-file module to reference each other, without worrying about naming conflicts with other modules you may have installed in your
import
search
path. This import statement will only look for the universaldetector module within the chardet/ directory itself.
These two concepts — <strong>init</strong>.py and relative imports — mean that you can break up your module into as many pieces as you like. The chardet module comprises 36 .py files — 36! Yet all you need to do to start using it is import chardet, then you can call the main chardet.detect() function. Unbeknownst to your code, the detect() function is actually defined in the chardet/<strong>init</strong>.py file. Also unbeknownst to you, the detect() function uses a relative import to reference a class defined in chardet/ universaldetector.py, which in turn uses relative imports on five other files, all contained in the chardet/ directory.
.</p>

<p>If you ever find yourself writing a large library in Python (or more likely, when you realize that your small library has grown into a large one), take the time to refactor it into a multi-file module. It’s one of the many things Python is good at, so take advantage of it.
.
15.6. FIXING WHAT 2to3 CAN’T</p>

<p>15.6.1. False IS INVALID SYNTAX
Now for the real test: running the test harness against the test suite. Since the test suite is designed to cover
all the possible code paths, it’s a good way to test our ported code to make sure there aren’t any bugs lurking anywhere.
C:\home\chardet&gt; python test.py tests**</p>

<p>Traceback (most recent call last):
File &ldquo;test.py&rdquo;, line 1, in <module></p>

<p>from chardet.universaldetector import UniversalDetector
File &ldquo;C:\home\chardet\chardet\universaldetector.py&rdquo;, line 51
self.done = constants.False
^
SyntaxError: invalid syntax</p>

<p>Hmm, a small snag. In Python 3, False is a reserved word, so you can’t use it as a variable name. Let’s look at constants.py to see where it’s defined. Here’s the original version from constants.py, before the 2to3 script changed it:
import <strong>builtin</strong></p>

<p>if not hasattr(<strong>builtin</strong>, &lsquo;False&rsquo;):</p>

<p>False = 0</p>

<p>True = 1</p>

<p>else:</p>

<p>False = <strong>builtin</strong>.False</p>

<p>True = <strong>builtin</strong>.True</p>

<p>This piece of code is designed to allow this library to run under older versions of Python 2. Prior to Python 2.3, Python had no built-in bool type. This code detects the absence of the built-in constants True and False, and defines them if necessary.
However, Python 3 will always have a bool type, so this entire code snippet is unnecessary. The simplest solution is to replace all instances of constants.True and constants.False with True and False, respectively, then delete this dead code from constants.py.
So this line in universaldetector.py:
self.done = constants.False</p>

<p>Becomes
self.done = False</p>

<p>Ah, wasn’t that satisfying? The code is shorter and more readable already.</p>

<p>15.6.2. NO MODULE NAMED constants
Time to run test.py again and see how far it gets.
C:\home\chardet&gt; python test.py tests**</p>

<p>Traceback (most recent call last):
File &ldquo;test.py&rdquo;, line 1, in <module>
from chardet.universaldetector import UniversalDetector
File &ldquo;C:\home\chardet\chardet\universaldetector.py&rdquo;, line 29, in <module>
import constants, sys
ImportError: No module named constants</p>

<p>What’s that you say? No module named constants? Of course there’s a module named constants. It’s right there, in chardet/constants.py.
Remember when the 2to3 script fixed up all those import statements? This library has a lot of relative imports — that is, modules
that
import
other
modules
within
the
same
library
— but the logic behind relative imports has changed in Python 3. In Python 2, you could just import constants and it would look in the chardet/ directory first. In Python 3, all
import
statements
are
absolute
by
default. If you want to do a relative import in Python 3, you need to be explicit about it:
from . import constants</p>

<p>But wait. Wasn’t the 2to3 script supposed to take care of these for you? Well, it did, but this particular import statement combines two different types of imports into one line: a relative import of the constants module within the library, and an absolute import of the sys module that is pre-installed in the Python standard library. In Python 2, you could combine these into one import statement. In Python 3, you can’t, and the 2to3 script is not smart enough to split the import statement into two.
The solution is to split the import statement manually. So this two-in-one import:
import constants, sys</p>

<p>Needs to become two separate imports:
from . import constants
import sys</p>

<p>There are variations of this problem scattered throughout the chardet library. In some places it’s “import
constants, sys”; in other places, it’s “import constants, re”. The fix is the same: manually split the import statement into two lines, one for the relative import, the other for the absolute import.
Onward!</p>

<p>15.6.3. NAME &lsquo;file&rsquo; IS NOT DEFINED
And here we go again, running test.py to try to execute our test cases…
C:\home\chardet&gt; python test.py tests**
tests\ascii\howto.diveintomark.org.xml</p>

<p>Traceback (most recent call last):
File &ldquo;test.py&rdquo;, line 9, in <module>
for line in file(f, &lsquo;rb&rsquo;):
NameError: name &lsquo;file&rsquo; is not defined</p>

<p>This one surprised me, because I’ve been using this idiom as long as I can remember. In Python 2, the global file() function was an alias for the open() function, which was the standard way of opening
text
files
for
reading. In Python 3, the global file() function no longer exists, but the open() function still exists.</p>

<p>Thus, the simplest solution to the problem of the missing file() is to call the open() function instead:
for line in open(f, &lsquo;rb&rsquo;): And that’s all I have to say about that.</p>

<p>15.6.4. CAN’T USE A STRING PATTERN ON A BYTES-LIKE OBJECT
Now things are starting to get interesting. And by “interesting,” I mean “confusing as all hell.”
C:\home\chardet&gt; python test.py tests**</p>

<p>tests\ascii\howto.diveintomark.org.xml</p>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;test.py&rdquo;, line 10, in <module></p>

<p>u.feed(line)</p>

<p>File &ldquo;C:\home\chardet\chardet\universaldetector.py&rdquo;, line 98, in feed</p>

<p>if self._highBitDetector.search(aBuf):</p>

<p>TypeError: can&rsquo;t use a string pattern on a bytes-like object</p>

<p>To debug this, let’s see what self._highBitDetector is. It’s defined in the <strong>init</strong> method of the UniversalDetector class:
class UniversalDetector:
def <strong>init</strong>(self):
self._highBitDetector = re.compile(r&rsquo;[\x80-\xFF]&lsquo;)</p>

<p>This pre-compiles a regular expression designed to find non-ASCII characters in the range 128–255 (0x80–0xFF). Wait, that’s not quite right; I need to be more precise with my terminology. This pattern is designed to find non-ASCII bytes in the range 128-255.
And therein lies the problem.
In Python 2, a string was an array of bytes whose character encoding was tracked separately. If you wanted Python 2 to keep track of the character encoding, you had to use a Unicode string (u&rdquo;) instead. But in Python 3, a string is always what Python 2 called a Unicode string — that is, an array of Unicode characters (of possibly varying byte lengths). Since this regular expression is defined by a string pattern, it can only be used to search a string — again, an array of characters. But what we’re searching is not a string, it’s a byte array. Looking at the traceback, this error occurred in universaldetector.py:
def feed(self, aBuf):</p>

<p>.
.
.
if self._mInputState == ePureAscii:</p>

<p>if self._highBitDetector.search(aBuf):</p>

<p>And what is aBuf? Let’s backtrack further to a place that calls UniversalDetector.feed(). One place that calls it is the test harness, test.py.
u = UniversalDetector()
.
.
.
for line in open(f, &lsquo;rb&rsquo;):</p>

<p>u.feed(line)</p>

<p>And here we find our answer: in the UniversalDetector.feed() method, aBuf is a line read from a file on disk. Look carefully at the parameters used to open the file: &lsquo;rb&rsquo;. &lsquo;r&rsquo; is for “read”; OK, big deal, we’re reading the file. Ah, but &lsquo;b&rsquo; is
for
“binary.”
Without the &lsquo;b&rsquo; flag, this for loop would read the file, line by line, and convert each line into a string — an array of Unicode characters — according to the system default character encoding. But with the &lsquo;b&rsquo; flag, this for loop reads the file, line by line, and stores each line exactly as it appears in the file, as an array of bytes. That byte array gets passed to UniversalDetector.feed(), and eventually gets passed to the pre-compiled regular expression, self._highBitDetector, to search for high-bit… characters. But we don’t have characters; we have bytes. Oops.</p>

<p>What we need this regular expression to search is not an array of characters, but an array of bytes.
Once you realize that, the solution is not difficult. Regular expressions defined with strings can search strings. Regular expressions defined with byte arrays can search byte arrays. To define a byte array pattern, we simply change the type of the argument we use to define the regular expression to a byte array. (There is one other case of this same problem, on the very next line.)
class UniversalDetector:
def <strong>init</strong>(self):</p>

<ul>
<li>self._highBitDetector = re.compile(r&rsquo;[\x80-\xFF]&lsquo;)<br /></li>
<li>self._escDetector = re.compile(r&rsquo;(\033|~{)&lsquo;)<br /></li>
<li>self._highBitDetector = re.compile(b&rsquo;[\x80-\xFF]&lsquo;)<br /></li>
<li>self._escDetector = re.compile(b&rsquo;(\033|~{)&lsquo;)<br /></li>
</ul>

<p>self._mEscCharSetProber = None
self._mCharSetProbers = []
self.reset()</p>

<p>Searching the entire codebase for other uses of the re module turns up two more instances, in charsetprober.py. Again, the code is defining regular expressions as strings but executing them on aBuf, which is a byte array. The solution is the same: define the regular expression patterns as byte arrays.
class CharSetProber:</p>

<p>.</p>

<p>.</p>

<p>.</p>

<p>def filter_high_bit_only(self, aBuf):</p>

<ul>
<li>aBuf = re.sub(r&rsquo;([\x00-\x7F])+&lsquo;, &rsquo; &lsquo;, aBuf)<br /></li>
<li>aBuf = re.sub(b&rsquo;([\x00-\x7F])+&lsquo;, b&rsquo; &lsquo;, aBuf)<br /></li>
</ul>

<p>return aBuf</p>

<p>def filter_without_english_letters(self, aBuf):</p>

<ul>
<li>aBuf = re.sub(r&rsquo;([A-Za-z])+&lsquo;, &rsquo; &lsquo;, aBuf)<br /></li>
<li>aBuf = re.sub(b&rsquo;([A-Za-z])+&lsquo;, b&rsquo; &lsquo;, aBuf)<br /></li>
</ul>

<p>return aBuf</p>

<p>15.6.5. CAN&rsquo;T CONVERT &lsquo;bytes&rsquo; OBJECT TO str IMPLICITLY
Curiouser and curiouser…
C:\home\chardet&gt; python test.py tests**</p>

<p>tests\ascii\howto.diveintomark.org.xml</p>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;test.py&rdquo;, line 10, in <module></p>

<p>u.feed(line)</p>

<p>File &ldquo;C:\home\chardet\chardet\universaldetector.py&rdquo;, line 100, in feed</p>

<p>elif (self._mInputState == ePureAscii) and self._escDetector.search(self._mLastChar + aBuf):</p>

<p>TypeError: Can&rsquo;t convert &lsquo;bytes&rsquo; object to str implicitly</p>

<p>There’s an unfortunate clash of coding style and Python interpreter here. The TypeError could be anywhere on that line, but the traceback doesn’t tell you exactly where it is. It could be in the first conditional or the second, and the traceback would look the same. To narrow it down, you should split the line in half, like this:
elif (self._mInputState == ePureAscii) and \
self._escDetector.search(self._mLastChar + aBuf):</p>

<p>And re-run the test:
C:\home\chardet&gt; python test.py tests**
tests\ascii\howto.diveintomark.org.xml</p>

<p>Traceback (most recent call last):
File &ldquo;test.py&rdquo;, line 10, in <module>
u.feed(line)
File &ldquo;C:\home\chardet\chardet\universaldetector.py&rdquo;, line 101, in feed
self._escDetector.search(self._mLastChar + aBuf):
TypeError: Can&rsquo;t convert &lsquo;bytes&rsquo; object to str implicitly</p>

<p>Aha! The problem was not in the first conditional (self._mInputState == ePureAscii) but in the second one. So what could cause a TypeError there? Perhaps you’re thinking that the search() method is expecting a value of a different type, but that wouldn’t generate this traceback. Python functions can take any value; if you pass the right number of arguments, the function will execute. It may crash if you pass it a value of a different type than it’s expecting, but if that happened, the traceback would point to somewhere inside the function. But this traceback says it never got as far as calling the search() method. So the problem must be in that + operation, as it’s trying to construct the value that it will eventually pass to the search() method.
We know from previous
debugging
that aBuf is a byte array. So what is self._mLastChar? It’s an instance variable, defined in the reset() method, which is actually called from the <strong>init</strong>() method.
class UniversalDetector:</p>

<p>def <strong>init</strong>(self):
self._highBitDetector = re.compile(b&rsquo;[\x80-\xFF]&lsquo;)
self._escDetector = re.compile(b&rsquo;(\033|~{)&lsquo;)
self._mEscCharSetProber = None
self._mCharSetProbers = []
self.reset()</p>

<p>def reset(self):
self.result = {&lsquo;encoding&rsquo;: None, &lsquo;confidence&rsquo;: 0.0}
self.done = False
self._mStart = True
self._mGotData = False
self._mInputState = ePureAscii
self._mLastChar = &ldquo;</p>

<p>And now we have our answer. Do you see it? self._mLastChar is a string, but aBuf is a byte array. And you can’t concatenate a string to a byte array — not even a zero-length string.
So what is self._mLastChar anyway? In the feed() method, just a few lines down from where the trackback occurred.
if self._mInputState == ePureAscii:
if self._highBitDetector.search(aBuf):
self._mInputState = eHighbyte
elif (self._mInputState == ePureAscii) and \
self._escDetector.search(self._mLastChar + aBuf):
self._mInputState = eEscAscii</p>

<p>self._mLastChar = aBuf[-1]</p>

<p>The calling function calls this feed() method over and over again with a few bytes at a time. The method processes the bytes it was given (passed in as aBuf), then stores the last byte in self._mLastChar in case it’s needed during the next call. (In a multi-byte encoding, the feed() method might get called with half of a character, then called again with the other half.) But because aBuf is now a byte array instead of a string, self._mLastChar needs to be a byte array as well. Thus:
def reset(self):
.
.
.</p>

<ul>
<li>self._mLastChar = &ldquo;<br /></li>
<li>self._mLastChar = b&rdquo;<br /></li>
</ul>

<p>Searching the entire codebase for “mLastChar” turns up a similar problem in mbcharsetprober.py, but instead of tracking the last character, it tracks the last two characters. The MultiByteCharSetProber class uses a list of 1-character strings to track the last two characters. In Python 3, it needs to use a list of integers, because it’s not really tracking characters, it’s tracking bytes. (Bytes are just integers from 0-255.)
class MultiByteCharSetProber(CharSetProber):</p>

<p>def <strong>init</strong>(self):
CharSetProber.<strong>init</strong>(self)
self._mDistributionAnalyzer = None
self._mCodingSM = None</p>

<ul>
<li>self._mLastChar = [&rsquo;\x00&rsquo;, &lsquo;\x00&rsquo;]<br /></li>
<li>self._mLastChar = [0, 0]<br /></li>
</ul>

<p>def reset(self):
CharSetProber.reset(self)
if self._mCodingSM:
self._mCodingSM.reset()
if self._mDistributionAnalyzer:
self._mDistributionAnalyzer.reset()</p>

<ul>
<li>self._mLastChar = [&rsquo;\x00&rsquo;, &lsquo;\x00&rsquo;]<br /></li>
<li>self._mLastChar = [0, 0]<br /></li>
</ul>

<p>15.6.6. UNSUPPORTED OPERAND TYPE(S) FOR +: &lsquo;int&rsquo; AND &lsquo;bytes&rsquo;
I have good news, and I have bad news. The good news is we’re making progress…
C:\home\chardet&gt; python test.py tests**
tests\ascii\howto.diveintomark.org.xml</p>

<p>Traceback (most recent call last):
File &ldquo;test.py&rdquo;, line 10, in <module>
u.feed(line)
File &ldquo;C:\home\chardet\chardet\universaldetector.py&rdquo;, line 101, in feed
self._escDetector.search(self._mLastChar + aBuf):
TypeError: unsupported operand type(s) for +: &lsquo;int&rsquo; and &lsquo;bytes&rsquo;</p>

<p>…The bad news is it doesn’t always feel like progress.
But this is progress! Really! Even though the traceback calls out the same line of code, it’s a different error than it used to be. Progress! So what’s the problem now? The last time I checked, this line of code didn’t try to concatenate an int with a byte array (bytes). In fact, you just spent a lot of time ensuring
that
self._mLastChar was
a
byte
array. How did it turn into an int?
The answer lies not in the previous lines of code, but in the following lines.
if self._mInputState == ePureAscii:
if self._highBitDetector.search(aBuf):
self._mInputState = eHighbyte
elif (self._mInputState == ePureAscii) and \
self._escDetector.search(self._mLastChar + aBuf):
self._mInputState = eEscAscii</p>

<p>self._mLastChar = aBuf[-1]</p>

<p>This error doesn’t occur the first time the feed()
method gets called; it occurs the second time, after self._mLastChar has been set to the last byte of aBuf. Well, what’s the problem with that? Getting a single element from a byte array yields an integer, not a byte array. To see the difference, follow me to the interactive shell:
&gt;&gt;&gt; aBuf = b&rsquo;\xEF\xBB\xBF&rsquo; .
&gt;&gt;&gt; len(aBuf)
3
&gt;&gt;&gt; mLastChar = aBuf[-1]
&gt;&gt;&gt; mLastChar .
191
&gt;&gt;&gt; type(mLastChar) .
<class 'int'>
&gt;&gt;&gt; mLastChar + aBuf .</p>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module></p>

<p>TypeError: unsupported operand type(s) for +: &lsquo;int&rsquo; and &lsquo;bytes&rsquo;</p>

<blockquote>
<blockquote>
<blockquote>
<p>mLastChar = aBuf[-1:] .
mLastChar
b&rsquo;\xbf&rsquo;
mLastChar + aBuf .
b&rsquo;\xbf\xef\xbb\xbf&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>Define a byte array of length 3.</p></li>

<li><p>The last element of the byte array is 191.</p></li>

<li><p>That’s an integer.</p></li>

<li><p>Concatenating an integer with a byte array doesn’t work. You’ve now replicated the error you just found in universaldetector.py.</p></li>

<li><p>Ah, here’s the fix. Instead of taking the last element of the byte array, use list
slicing
to create a new byte array containing just the last element. That is, start with the last element and continue the slice until the end of the byte array. Now mLastChar is a byte array of length 1.</p></li>

<li><p>Concatenating a byte array of length 1 with a byte array of length 3 returns a new byte array of length 4.</p></li>
</ol>

<p>So, to ensure that the feed() method in universaldetector.py continues to work no matter how often it’s called, you need to initialize
self._mLastChar as
a
0-length
byte
array, then make sure it stays a byte array.
self._escDetector.search(self._mLastChar + aBuf):
self._mInputState = eEscAscii</p>

<p>-self._mLastChar = aBuf[-1]</p>

<ul>
<li>self._mLastChar = aBuf[-1:]</li>
</ul>

<p>15.6.7. ord() EXPECTED STRING OF LENGTH 1, BUT int FOUND
Tired yet? You’re almost there…
C:\home\chardet&gt; python test.py tests**</p>

<p>tests\ascii\howto.diveintomark.org.xml  ascii with confidence 1.0</p>

<p>tests\Big5\0804.blogspot.com.xml</p>

<p>Traceback (most recent call last):</p>

<p>File &ldquo;test.py&rdquo;, line 10, in <module></p>

<p>u.feed(line)</p>

<p>File &ldquo;C:\home\chardet\chardet\universaldetector.py&rdquo;, line 116, in feed</p>

<p>if prober.feed(aBuf) == constants.eFoundIt:</p>

<p>File &ldquo;C:\home\chardet\chardet\charsetgroupprober.py&rdquo;, line 60, in feed</p>

<p>st = prober.feed(aBuf)</p>

<p>File &ldquo;C:\home\chardet\chardet\utf8prober.py&rdquo;, line 53, in feed</p>

<p>codingState = self._mCodingSM.next_state&copy;</p>

<p>File &ldquo;C:\home\chardet\chardet\codingstatemachine.py&rdquo;, line 43, in next_state</p>

<p>byteCls = self._mModel[&lsquo;classTable&rsquo;][ord&copy;]</p>

<p>TypeError: ord() expected string of length 1, but int found</p>

<p>OK, so c is an int, but the ord() function was expecting a 1-character string. Fair enough. Where is c defined?</p>

<h1 id="codingstatemachine-py">codingstatemachine.py</h1>

<p>def next_state(self, c):</p>

<h1 id="for-each-byte-we-get-its-class">for each byte we get its class</h1>

<h1 id="if-it-is-first-byte-we-also-get-byte-length">if it is first byte, we also get byte length</h1>

<p>byteCls = self._mModel[&lsquo;classTable&rsquo;][ord&copy;]</p>

<p>That’s no help; it’s just passed into the function. Let’s pop the stack.</p>

<h1 id="utf8prober-py">utf8prober.py</h1>

<p>def feed(self, aBuf):
for c in aBuf:
codingState = self._mCodingSM.next_state&copy;</p>

<p>Do you see it? In Python 2, aBuf was a string, so c was a 1-character string. (That’s what you get when you iterate over a string — all the characters, one by one.) But now, aBuf is a byte array, so c is an int, not a 1-character string. In other words, there’s no need to call the ord() function because c is already an int!
Thus:
def next_state(self, c):</p>

<h1 id="for-each-byte-we-get-its-class-1">for each byte we get its class</h1>

<h1 id="if-it-is-first-byte-we-also-get-byte-length-1">if it is first byte, we also get byte length</h1>

<ul>
<li>byteCls = self._mModel[&lsquo;classTable&rsquo;][ord&copy;]<br /></li>
<li>byteCls = self._mModel[&lsquo;classTable&rsquo;][c]<br /></li>
</ul>

<p>Searching the entire codebase for instances of “ord&copy;” uncovers similar problems in sbcharsetprober.py…</p>

<h1 id="sbcharsetprober-py">sbcharsetprober.py</h1>

<p>def feed(self, aBuf):
if not self._mModel[&lsquo;keepEnglishLetter&rsquo;]:</p>

<p>aBuf = self.filter_without_english_letters(aBuf)
aLen = len(aBuf)
if not aLen:</p>

<p>return self.get_state()
for c in aBuf:
order = self._mModel[&lsquo;charToOrderMap&rsquo;][ord&copy;]</p>

<p>…and latin1prober.py…</p>

<h1 id="latin1prober-py">latin1prober.py</h1>

<p>def feed(self, aBuf):
aBuf = self.filter_with_english_letters(aBuf)
for c in aBuf:</p>

<p>charClass = Latin1_CharToClass[ord&copy;]</p>

<p>c is iterating over aBuf, which means it is an integer, not a 1-character string. The solution is the same: change ord&copy; to just plain c.</p>

<h1 id="sbcharsetprober-py-1">sbcharsetprober.py</h1>

<p>def feed(self, aBuf):
if not self._mModel[&lsquo;keepEnglishLetter&rsquo;]:</p>

<p>aBuf = self.filter_without_english_letters(aBuf)
aLen = len(aBuf)
if not aLen:</p>

<p>return self.get_state()
for c in aBuf:</p>

<ul>
<li>order = self._mModel[&lsquo;charToOrderMap&rsquo;][ord&copy;]<br /></li>
<li>order = self._mModel[&lsquo;charToOrderMap&rsquo;][c]<br /></li>
</ul>

<h1 id="latin1prober-py-1">latin1prober.py</h1>

<p>def feed(self, aBuf):
aBuf = self.filter_with_english_letters(aBuf)
for c in aBuf:</p>

<ul>
<li>charClass = Latin1_CharToClass[ord&copy;]<br /></li>
<li>charClass = Latin1_CharToClass[c]<br /></li>
</ul>

<p>15.6.8. UNORDERABLE TYPES: int() &gt;= str()
Let’s go again.
C:\home\chardet&gt; python test.py tests**
tests\ascii\howto.diveintomark.org.xml ascii with confidence 1.0
tests\Big5\0804.blogspot.com.xml</p>

<p>Traceback (most recent call last):
File &ldquo;test.py&rdquo;, line 10, in <module>
u.feed(line)
File &ldquo;C:\home\chardet\chardet\universaldetector.py&rdquo;, line 116, in feed
if prober.feed(aBuf) == constants.eFoundIt:
File &ldquo;C:\home\chardet\chardet\charsetgroupprober.py&rdquo;, line 60, in feed
st = prober.feed(aBuf)
File &ldquo;C:\home\chardet\chardet\sjisprober.py&rdquo;, line 68, in feed
self._mContextAnalyzer.feed(self._mLastChar[2 - charLen :], charLen)
File &ldquo;C:\home\chardet\chardet\jpcntx.py&rdquo;, line 145, in feed
order, charLen = self.get_order(aBuf[i:i+2])
File &ldquo;C:\home\chardet\chardet\jpcntx.py&rdquo;, line 176, in get_order
if ((aStr[0] &gt;= &lsquo;\x81&rsquo;) and (aStr[0] &lt;= &lsquo;\x9F&rsquo;)) or \
TypeError: unorderable types: int() &gt;= str()</p>

<p>So what’s this all about? “Unorderable types”? Once again, the difference between byte arrays and strings is rearing its ugly head. Take a look at the code:
class SJISContextAnalysis(JapaneseContextAnalysis):</p>

<p>def get_order(self, aStr):
if not aStr: return -1, 1</p>

<h1 id="find-out-current-char-s-byte-length">find out current char&rsquo;s byte length</h1>

<p>if ((aStr[0] &gt;= &lsquo;\x81&rsquo;) and (aStr[0] &lt;= &lsquo;\x9F&rsquo;)) or </p>

<p>((aStr[0] &gt;= &lsquo;\xE0&rsquo;) and (aStr[0] &lt;= &lsquo;\xFC&rsquo;)):
charLen = 2
else:
charLen = 1</p>

<p>And where does aStr come from? Let’s pop the stack:
def feed(self, aBuf, aLen):</p>

<p>.</p>

<p>.</p>

<p>.</p>

<p>i = self._mNeedToSkipCharNum</p>

<p>while i &lt; aLen:</p>

<p>order, charLen = self.get_order(aBuf[i:i+2])</p>

<p>Oh look, it’s our old friend, aBuf. As you might have guessed from every other issue we’ve encountered in this chapter, aBuf is a byte array. Here, the feed() method isn’t just passing it on wholesale; it’s slicing it. But as you saw earlier
in
this
chapter, slicing a byte array returns a byte array, so the aStr parameter that gets passed to the get_order() method is still a byte array.
And what is this code trying to do with aStr? It’s taking the first element of the byte array and comparing it to a string of length 1. In Python 2, that worked, because aStr and aBuf were strings, and aStr[0] would be a string, and you can compare strings for inequality. But in Python 3, aStr and aBuf are byte arrays, aStr[0] is an integer, and you can’t compare integers and strings for inequality without explicitly coercing one of them.
In this case, there’s no need to make the code more complicated by adding an explicit coercion. aStr[0] yields an integer; the things you’re comparing to are all constants. Let’s change them from 1-character strings to integers. And while we’re at it, let’s change aStr to aBuf, since it’s not actually a string.
class SJISContextAnalysis(JapaneseContextAnalysis):</p>

<ul>
<li>def get_order(self, aStr):<br /></li>
<li>if not aStr: return -1, 1<br /></li>
<li>def get_order(self, aBuf):<br /></li>
<li>if not aBuf: return -1, 1<br /></li>
</ul>

<h1 id="find-out-current-char-s-byte-length-1">find out current char&rsquo;s byte length</h1>

<ul>
<li>if ((aStr[0] &gt;= &lsquo;\x81&rsquo;) and (aStr[0] &lt;= &lsquo;\x9F&rsquo;)) or \<br /></li>
<li>((aBuf[0] &gt;= &lsquo;\xE0&rsquo;) and (aBuf[0] &lt;= &lsquo;\xFC&rsquo;)):<br /></li>
<li>if ((aBuf[0] &gt;= 0x81) and (aBuf[0] &lt;= 0x9F)) or \<br /></li>
<li>((aBuf[0] &gt;= 0xE0) and (aBuf[0] &lt;= 0xFC)):<br /></li>
</ul>

<p>charLen = 2
else:</p>

<p>charLen = 1</p>

<h1 id="return-its-order-if-it-is-hiragana">return its order if it is hiragana</h1>

<ul>
<li>if len(aStr) &gt; 1:<br /></li>
<li>if (aStr[0] == &lsquo;\202&rsquo;) and \<br /></li>
<li>(aStr[1] &gt;= &lsquo;\x9F&rsquo;) and \<br /></li>
<li>(aStr[1] &lt;= &lsquo;\xF1&rsquo;):<br /></li>
<li>return ord(aStr[1]) - 0x9F, charLen<br /></li>
<li>if len(aBuf) &gt; 1:<br /></li>
<li>if (aBuf[0] == 202) and \<br /></li>
<li>(aBuf[1] &gt;= 0x9F) and \<br /></li>
<li>(aBuf[1] &lt;= 0xF1):<br /></li>
<li>return aBuf[1] - 0x9F, charLen<br /></li>
</ul>

<p>return -1, charLen</p>

<p>class EUCJPContextAnalysis(JapaneseContextAnalysis):</p>

<ul>
<li>def get_order(self, aStr):<br /></li>
<li>if not aStr: return -1, 1<br /></li>
<li>def get_order(self, aBuf):<br /></li>
<li>if not aBuf: return -1, 1<br /></li>
</ul>

<h1 id="find-out-current-char-s-byte-length-2">find out current char&rsquo;s byte length</h1>

<ul>
<li>if (aStr[0] == &lsquo;\x8E&rsquo;) or \<br /></li>
<li>((aStr[0] &gt;= &lsquo;\xA1&rsquo;) and (aStr[0] &lt;= &lsquo;\xFE&rsquo;)):<br /></li>
<li>if (aBuf[0] == 0x8E) or \<br /></li>
<li>((aBuf[0] &gt;= 0xA1) and (aBuf[0] &lt;= 0xFE)):<br /></li>
</ul>

<p>charLen = 2</p>

<ul>
<li>elif aStr[0] == &lsquo;\x8F&rsquo;:<br /></li>
<li>elif aBuf[0] == 0x8F:<br /></li>
</ul>

<p>charLen = 3
else:
charLen = 1</p>

<h1 id="return-its-order-if-it-is-hiragana-1">return its order if it is hiragana</h1>

<ul>
<li>if len(aStr) &gt; 1:<br /></li>
<li>if (aStr[0] == &lsquo;\xA4&rsquo;) and \<br /></li>
<li>(aStr[1] &gt;= &lsquo;\xA1&rsquo;) and \<br /></li>
<li>(aStr[1] &lt;= &lsquo;\xF3&rsquo;):<br /></li>
<li>return ord(aStr[1]) - 0xA1, charLen<br /></li>
<li>if len(aBuf) &gt; 1:<br /></li>
<li>if (aBuf[0] == 0xA4) and \<br /></li>
<li>(aBuf[1] &gt;= 0xA1) and \<br /></li>
<li>(aBuf[1] &lt;= 0xF3):<br /></li>
<li>return aBuf[1] - 0xA1, charLen<br /></li>
</ul>

<p>return -1, charLen</p>

<p>Searching the entire codebase for occurrences of the ord() function uncovers the same problem in chardistribution.py (specifically, in the EUCTWDistributionAnalysis, EUCKRDistributionAnalysis, GB2312DistributionAnalysis, Big5DistributionAnalysis, SJISDistributionAnalysis, and EUCJPDistributionAnalysis classes. In each case, the fix is similar to the change we made to the EUCJPContextAnalysis and SJISContextAnalysis classes in jpcntx.py.</p>

<p>15.6.9. GLOBAL NAME &lsquo;reduce&rsquo; IS NOT DEFINED
Once more into the breach…
C:\home\chardet&gt; python test.py tests**</p>

<p>tests\ascii\howto.diveintomark.org.xml ascii with confidence 1.0
tests\Big5\0804.blogspot.com.xml</p>

<p>Traceback (most recent call last):
File &ldquo;test.py&rdquo;, line 12, in <module>
u.close()
File &ldquo;C:\home\chardet\chardet\universaldetector.py&rdquo;, line 141, in close
proberConfidence = prober.get_confidence()
File &ldquo;C:\home\chardet\chardet\latin1prober.py&rdquo;, line 126, in get_confidence
total = reduce(operator.add, self._mFreqCounter)
NameError: global name &lsquo;reduce&rsquo; is not defined</p>

<p>According to the official What’s
New
In
Python
3.0
guide, the reduce() function has been moved out of the global namespace and into the functools module. Quoting the guide: “Use functools.reduce() if you really need it; however, 99 percent of the time an explicit for loop is more readable.” You can read more about the decision from Guido van Rossum’s weblog: The
fate
of
reduce()
in
Python
3000.
def get_confidence(self):
if self.get_state() == constants.eNotMe:
return 0.01</p>

<p>total = reduce(operator.add, self._mFreqCounter)</p>

<p>The reduce() function takes two arguments — a function and a list (strictly speaking, any iterable object will do) — and applies the function cumulatively to each item of the list. In other words, this is a fancy and roundabout way of adding up all the items in a list and returning the result.
This monstrosity was so common that Python added a global sum() function.
def get_confidence(self):
if self.get_state() == constants.eNotMe:
return 0.01</p>

<ul>
<li>total = reduce(operator.add, self._mFreqCounter)<br /></li>
<li>total = sum(self._mFreqCounter)<br /></li>
</ul>

<p>Since you’re no longer using the operator module, you can remove that import from the top of the file as well.
from .charsetprober import CharSetProber
from . import constants</p>

<p>-import operator</p>

<p>I CAN HAZ TESTZ?</p>

<p>C:\home\chardet&gt; python test.py tests**</p>

<p>tests\ascii\howto.diveintomark.org.xml  ascii with confidence 1.0<br />
tests\Big5\0804.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\blog.worren.net.xml  Big5 with confidence 0.99<br />
tests\Big5\carbonxiv.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\catshadow.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\coolloud.org.tw.xml  Big5 with confidence 0.99<br />
tests\Big5\digitalwall.com.xml  Big5 with confidence 0.99<br />
tests\Big5\ebao.us.xml  Big5 with confidence 0.99<br />
tests\Big5\fudesign.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\kafkatseng.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\ke207.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\leavesth.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\letterlego.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\linyijen.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\marilynwu.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\myblog.pchome.com.tw.xml  Big5 with confidence 0.99<br />
tests\Big5\oui-design.com.xml  Big5 with confidence 0.99<br />
tests\Big5\sanwenji.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\sinica.edu.tw.xml  Big5 with confidence 0.99<br />
tests\Big5\sylvia1976.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\tlkkuo.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\tw.blog.xubg.com.xml  Big5 with confidence 0.99<br />
tests\Big5\unoriginalblog.com.xml  Big5 with confidence 0.99<br />
tests\Big5\upsaid.com.xml  Big5 with confidence 0.99<br />
tests\Big5\willythecop.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\Big5\ytc.blogspot.com.xml  Big5 with confidence 0.99<br />
tests\EUC-JP\aivy.co.jp.xml  EUC-JP with confidence 0.99<br />
tests\EUC-JP\akaname.main.jp.xml  EUC-JP with confidence 0.99<br />
tests\EUC-JP\arclamp.jp.xml  EUC-JP with confidence 0.99<br />
.<br />
.<br />
.<br />
316 tests</p>

<p>Holy crap, it actually works! /me does a little dance
.
15.7. SUMMARY
What have we learned?
1.  Porting any non-trivial amount of code from Python 2 to Python 3 is going to be a pain. There’s no way around it. It’s hard.</p>

<ol>
<li><p>The automated
2to3 tool
is helpful as far as it goes, but it will only do the easy parts — function renames, module renames, syntax changes. It’s an impressive piece of engineering, but in the end it’s just an intelligent search-and-replace bot.</p></li>

<li><p>The #1 porting problem in this library was the difference between strings and bytes. In this case that seems obvious, since the whole point of the chardet library is to convert a stream of bytes into a string. But “a stream of bytes” comes up more often than you might think. Reading a file in “binary” mode? You’ll get a stream of bytes. Fetching a web page? Calling a web API? They return a stream of bytes, too.</p></li>

<li><p>You need to understand your program. Thoroughly. Preferably because you wrote it, but at the very least, you need to be comfortable with all its quirks and musty corners. The bugs are everywhere.</p></li>

<li><p>Test cases are essential. Don’t port anything without them. The only reason I have any confidence that chardet works in Python 3 is that I started with a test suite that exercised all major code paths. If you don’t have any tests, write some tests before you start porting to Python 3. If you have a few tests, write more. If you have a lot of tests, then the real fun can begin.</p></li>
</ol>

<p>CHAPTER 16. PACKAGING PYTHON LIBRARIES</p>

<p>. You’ll find the shame is like the pain; you only feel it once. .
— Marquise de Merteuil, Dangerous Liaisons
16.1. DIVING IN
Real artists ship. Or so says Steve Jobs. Do you want to release a Python script, library, framework, or application? Excellent. The world needs more Python code. Python 3 comes with a packaging framework called Distutils. Distutils is many things: a build tool (for you), an installation tool (for your users), a package metadata format (for search engines), and more. It integrates with the Python
Package
Index
(“PyPI”), a central repository for open source Python libraries.
All of these facets of Distutils center around the setup script, traditionally called setup.py. In fact, you’ve already seen several Distutils setup scripts in this book. You used Distutils to install httplib2 in HTTP
Web
Services
and again to install chardet in Case
Study:
Porting
chardet to
Python
3.
In this chapter, you’ll learn how the setup scripts for chardet and httplib2 work, and you’ll step through the process of releasing your own Python software.</p>

<h1 id="chardet-s-setup-py">chardet&rsquo;s setup.py</h1>

<p>from distutils.core import setup
setup(</p>

<p>name = &ldquo;chardet&rdquo;,</p>

<p>packages = [&ldquo;chardet&rdquo;],</p>

<p>version = &ldquo;1.0.2&rdquo;,</p>

<p>description = &ldquo;Universal encoding detector&rdquo;,</p>

<p>author = &ldquo;Mark Pilgrim&rdquo;,</p>

<p>author_email = &ldquo;mark@diveintomark.org&rdquo;,</p>

<p>url = &ldquo;<a href="http://chardet.feedparser.org/&quot;">http://chardet.feedparser.org/&quot;</a>,</p>

<p>download_url = &ldquo;<a href="http://chardet.feedparser.org/download/python3-chardet-1.0.1.tgz&quot;">http://chardet.feedparser.org/download/python3-chardet-1.0.1.tgz&quot;</a>,</p>

<p>keywords = [&ldquo;encoding&rdquo;, &ldquo;i18n&rdquo;, &ldquo;xml&rdquo;],</p>

<p>classifiers = [</p>

<p>&ldquo;Programming Language :: Python&rdquo;,</p>

<p>&ldquo;Programming Language :: Python :: 3&rdquo;,</p>

<p>&ldquo;Development Status :: 4 - Beta&rdquo;,</p>

<p>&ldquo;Environment :: Other Environment&rdquo;,</p>

<p>&ldquo;Intended Audience :: Developers&rdquo;,</p>

<p>&ldquo;License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)&ldquo;,</p>

<p>&ldquo;Operating System :: OS Independent&rdquo;,</p>

<p>&ldquo;Topic :: Software Development :: Libraries :: Python Modules&rdquo;,</p>

<p>&ldquo;Topic :: Text Processing :: Linguistic&rdquo;,</p>

<p>],</p>

<p>long_description = &ldquo;&rdquo;&rdquo;\
Universal character encoding detector</p>

<p>Detects</p>

<p>-ASCII, UTF-8, UTF-16 (2 variants), UTF-32 (4 variants)</p>

<p>-Big5, GB2312, EUC-TW, HZ-GB-2312, ISO-2022-CN (Traditional and Simplified Chinese)</p>

<p>-EUC-JP, SHIFT_JIS, ISO-2022-JP (Japanese)</p>

<p>-EUC-KR, ISO-2022-KR (Korean)</p>

<p>-KOI8-R, MacCyrillic, IBM855, IBM866, ISO-8859-5, windows-1251 (Cyrillic)
- ISO-8859-2, windows-1250 (Hungarian)</p>

<ul>
<li>ISO-8859-5, windows-1251 (Bulgarian)</li>
<li>windows-1252 (English)</li>
<li>ISO-8859-7, windows-1253 (Greek)</li>
</ul>

<p>-ISO-8859-8, windows-1255 (Visual and Logical Hebrew)
- TIS-620 (Thai)</p>

<p>This version requires Python 3 or later; a Python 2 version is available separately.
&ldquo;&rdquo;&rdquo;
)</p>

<p>. chardet and httplib2 are open source, but there’s no requirement that you release your own Python libraries under any particular license. The process described in this chapter will work for any Python software, regardless of license.
.
16.2. THINGS DISTUTILS CAN’T DO FOR YOU
Releasing your first Python package is a daunting process. (Releasing your second one is a little easier.) Distutils tries to automate as much of it as possible, but there are some things you simply must do yourself.
•   Choose a license. This is a complicated topic, fraught with politics and peril. If you wish to release your
software as open source, I humbly offer five pieces of advice:</p>

<ol>
<li><p>Don’t write your own license.</p></li>

<li><p>Don’t write your own license.</p></li>

<li><p>Don’t write your own license.</p></li>

<li><p>It doesn’t need to be GPL, but it
needs
to
be
GPL-compatible.</p></li>

<li><p>Don’t write your own license.</p></li>
</ol>

<p>•   Classify your software using the PyPI classification system. I’ll explain what this means later in this chapter.</p>

<p>•   Write a “read me” file. Don’t skimp on this. At a minimum, it should give your users an overview of
what your software does and how to install it.</p>

<p>.</p>

<p>16.3. DIRECTORY STRUCTURE
To start packaging your Python software, you need to get your files and directories in order. The httplib2 directory looks like this:
httplib2/ .
|
+&ndash;README.txt .
|
+&ndash;setup.py .
|
+&ndash;httplib2/ .</p>

<p>|
+&ndash;<strong>init</strong>.py
|
+&ndash;iri2uri.py</p>

<ol>
<li><p>Make a root directory to hold everything. Give it the same name as your Python module.</p></li>

<li><p>To accomodate Windows users, your “read me” file should include a .txt extension, and it should use Windows-style carriage returns. Just because you use a fancy text editor that runs from the command line and includes its own macro language, that doesn’t mean you need to make life difficult for your users. (Your users use Notepad. Sad but true.) Even if you’re on Linux or Mac OS X, your fancy text editor undoubtedly has an option to save files with Windows-style carriage returns.</p></li>

<li><p>Your Distutils setup script should be named setup.py unless you have a good reason not to. You do not have a good reason not to.</p></li>

<li><p>If your Python software is a single .py file, you should put it in the root directory along with your “read me” file and your setup script. But httplib2 is not a single .py file; it’s a
multi-file
module. But that’s OK! Just put the httplib2 directory in the root directory, so you have an <strong>init</strong>.py file within an httplib2/ directory within the httplib2/ root directory. That’s not a problem; in fact, it will simplify your packaging process.</p></li>
</ol>

<p>The chardet directory looks slightly different. Like httplib2, it’s a
multi-file
module, so there’s a chardet/ directory within the chardet/ root directory. In addition to the README.txt file, chardet has HTML-formatted documentation in the docs/ directory. The docs/ directory contains several .html and .css files and an images/ subdirectory, which contains several .png and .gif files. (This will be important later.) Also, in keeping with the convention for (L)GPL-licensed software, it has a separate file called COPYING.txt which contains the complete text of the LGPL.
chardet/
|
+&ndash;COPYING.txt
|
+&ndash;setup.py
|
+&ndash;README.txt
|
+&ndash;docs/</p>

<p>|  |<br />
|  +&ndash;index.html<br />
|  |<br />
|  +&ndash;usage.html<br />
|  |<br />
|  +&ndash;images/ &hellip;<br />
|</p>

<p>+&ndash;chardet/
|
+&ndash;<strong>init</strong>.py
|
+&ndash;big5freq.py
|
+&ndash;&hellip;</p>

<p>.</p>

<p>16.4. WRITING YOUR SETUP SCRIPT</p>

<p>The Distutils setup script is a Python script. In theory, it can do anything Python can do. In practice, it should do as little as possible, in as standard a way as possible. Setup scripts should be boring. The more exotic your installation process is, the more exotic your bug reports will be.
The first line of every Distutils setup script is always the same:
from distutils.core import setup</p>

<p>This imports the setup() function, which is the main entry point into Distutils. 95% of all Distutils setup scripts consist of a single call to setup() and nothing else. (I totally just made up that statistic, but if your Distutils setup script is doing more than calling the Distutils setup() function, you should have a good reason. Do you have a good reason? I didn’t think so.)
The setup() function can
take
dozens
of
parameters. For the sanity of everyone involved, you must use named
arguments
for every parameter. This is not merely a convention; it’s a hard requirement. Your setup script will crash if you try to call the setup() function with non-named arguments.
The following named arguments are required:
•   name, the name of the package.</p>

<p>•   version, the version number of the package.</p>

<p>•   author, your full name.</p>

<p>•   author_email, your email address.</p>

<p>•   url, the home page of your project. This can be your PyPI
package page if you don’t have a separate project website.</p>

<p>Although not required, I recommend that you also include the following in your setup script:</p>

<p>•   description, a one-line summary of the project.</p>

<p>•   long_description, a multi-line string in reStructuredText
format. PyPI
converts this to HTML and displays it on your package page.</p>

<p>•   classifiers, a list of specially-formatted strings described in the next section.</p>

<p>. Setup script metadata is defined in PEP
314.
Now let’s look at the chardet setup script. It has all of these required and recommended parameters, plus one I haven’t mentioned yet: packages.
from distutils.core import setup</p>

<p>setup(</p>

<p>name = &lsquo;chardet&rsquo;,</p>

<p>packages = [&lsquo;chardet&rsquo;]
,</p>

<p>version = &lsquo;1.0.2&rsquo;,</p>

<p>description = &lsquo;Universal encoding detector&rsquo;,</p>

<p>author=&lsquo;Mark Pilgrim&rsquo;,</p>

<p>&hellip;</p>

<p>)</p>

<p>The packages parameter highlights an unfortunate vocabulary overlap in the distribution process. We’ve been talking about the “package” as the thing you’re building (and potentially listing in The Python “Package” Index). But that’s not what this packages parameter refers to. It refers to the fact that the chardet module is a
multi-file
module, sometimes known as… a “package.” The packages parameter tells Distutils to include the chardet/ directory, its <strong>init</strong>.py file, and all the other .py files that constitute the chardet module. That’s kind of important; all this happy talk about documentation and metadata is irrelevant if you forget to include the actual code!
.</p>

<p>16.5. CLASSIFYING YOUR PACKAGE
The Python Package Index (“PyPI”) contains thousands of Python libraries. Proper classification metadata will allow people to find yours more easily. PyPI lets you browse
packages
by
classifier. You can even select multiple classifiers to narrow your search. Classifiers are not invisible metadata that you can just ignore!
To classify your software, pass a classifiers parameter to the Distutils setup() function. The classifiers parameter is a list of strings. These strings are not freeform. All classifier strings should come from this
list
on
PyPI.
Classifiers are optional. You can write a Distutils setup script without any classifiers at all. Don’t do that. You should always include at least these classifiers:
•   Programming Language. In particular, you should include both &ldquo;Programming Language :: Python&rdquo; and &ldquo;Programming Language :: Python :: 3&rdquo;. If you do not include these, your package will not show up in this
list
of
Python
3-compatible
libraries, which linked from the sidebar of every single page of pypi.python.org.</p>

<p>•   License. This is the absolute first thing I look for when I’m evaluating third-party libraries. Don’t make me hunt for this vital information. Don’t include more than one license classifier unless your software is explicitly available under multiple licenses. (And don’t release software under multiple licenses unless you’re forced to do so. And don’t force other people to do so. Licensing is enough of a headache; don’t make it worse.)</p>

<p>•   Operating System. If your software only runs on Windows (or Mac OS X, or Linux), I want to know sooner rather than later. If your software runs anywhere without any platform-specific code, use the classifier &ldquo;Operating System :: OS Independent&rdquo;. Multiple Operating System classifiers are only necessary if your software requires specific support for each platform. (This is not common.)</p>

<p>I also recommend that you include the following classifiers:</p>

<p>•   Development Status. Is your software beta quality? Alpha quality? Pre-alpha? Pick one. Be honest.</p>

<p>•   Intended Audience. Who would download your software? The most common choices are Developers, End Users/Desktop, Science/Research, and System Administrators.</p>

<p>•   Framework. If your software is a plugin for a larger Python framework like Django
or Zope, include the appropriate Framework classifier. If not, omit it.</p>

<p>•   Topic. There are a
large
number
of
topics
to
choose
from; choose all that apply.</p>

<p>16.5.1. EXAMPLES OF GOOD PACKAGE CLASSIFIERS
By way of example, here are the classifiers for Django, a production-ready, cross-platform, BSD-licensed web application framework that runs on your web server. (Django is not yet compatible with Python 3, so the Programming Language :: Python :: 3 classifier is not listed.)
Programming Language :: Python</p>

<p>License :: OSI Approved :: BSD License
Operating System :: OS Independent
Development Status :: 5 - Production/Stable
Environment :: Web Environment
Framework :: Django
Intended Audience :: Developers
Topic :: Internet :: WWW/HTTP
Topic :: Internet :: WWW/HTTP :: Dynamic Content
Topic :: Internet :: WWW/HTTP :: WSGI
Topic :: Software Development :: Libraries :: Python Modules</p>

<p>Here are the classifiers for chardet, the character encoding detection library covered in Case
Study:
Porting
chardet to
Python
3. chardet is beta quality, cross-platform, Python 3-compatible, LGPL-licensed, and intended for developers to integrate into their own products.
Programming Language :: Python
Programming Language :: Python :: 3
License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)
Operating System :: OS Independent
Development Status :: 4 - Beta
Environment :: Other Environment
Intended Audience :: Developers
Topic :: Text Processing :: Linguistic
Topic :: Software Development :: Libraries :: Python Modules</p>

<p>And here are the classifiers for httplib2, the library featured in the HTTP
Web
Services
chapter. httplib2 is beta quality, cross-platform, MIT-licensed, and intended for Python developers.
Programming Language :: Python
Programming Language :: Python :: 3
License :: OSI Approved :: MIT License
Operating System :: OS Independent
Development Status :: 4 - Beta
Environment :: Web Environment
Intended Audience :: Developers
Topic :: Internet :: WWW/HTTP
Topic :: Software Development :: Libraries :: Python Modules</p>

<p>16.6. SPECIFYING ADDITIONAL FILES WITH A MANIFEST
By default, Distutils will include the following files in your release package:
• README.txt</p>

<p>• setup.py</p>

<p>• The .py files needed by the multi-file modules listed in the packages parameter</p>

<p>• The individual .py files listed in the py_modules parameter</p>

<p>That will cover all
the
files
in
the
httplib2 project. But for the chardet project, we also want to include the COPYING.txt license file and the entire docs/ directory that contains images and HTML files. To tell Distutils to include these additional files and directories when it builds the chardet release package, you need a manifest file.
A manifest file is a text file called MANIFEST.in. Place it in the project’s root directory, next to README.txt and setup.py. Manifest files are not Python scripts; they are text files that contain a series of “commands” in a Distutils-defined format. Manifest commands allow you to include or exclude specific files and directories.
This is the entire manifest file for the chardet project:
include COPYING.txt .
recursive-include docs *.html *.css *.png *.gif .</p>

<ol>
<li>The first line is self-explanatory: include the COPYING.txt file from the project’s root directory.</li>
<li>The second line is a bit more complicated. The recursive-include command takes a directory name and one or more filenames. The filenames aren’t limited to specific files; they can include wildcards. This line means “See that docs/ directory in the project’s root directory? Look in there (recursively) for .html, .css, .png, and .gif files. I want all of them in my release package.”
All manifest commands preserve the directory structure that you set up in your project directory. That recursive-include command is not going to put a bunch of .html and .png files in the root directory of the release package. It’s going to maintain the existing docs/ directory structure, but only include those files inside that directory that match the given wildcards. (I didn’t mention it earlier, but the chardet documentation is actually written in XML and converted to HTML by a separate script. I don’t want to include the XML files in the release package, just the HTML and the images.)
. Manifest files have their own unique format. See Specifying
the
files
to
distribute
and the
manifest
template
commands
for details.
To reiterate: you only need to create a manifest file if you want to include files that Distutils doesn’t include by default. If you do need a manifest file, it should only include the files and directories that Distutils wouldn’t otherwise find on its own.
16.7. CHECKING YOUR SETUP SCRIPT FOR ERRORS
There’s a lot to keep track of. Distutils comes with a built-in validation command that checks that all the required metadata is present in your setup script. For example, if you forget to include the version parameter, Distutils will remind you.
c:\Users\pilgrim\chardet&gt; c:\python31\python.exe setup.py check
running check
warning: check: missing required meta-data: version</li>
</ol>

<p>Once you include a version parameter (and all the other required bits of metadata), the check command will look like this:
c:\Users\pilgrim\chardet&gt; c:\python31\python.exe setup.py check
running check</p>

<p>.</p>

<p>16.8. CREATING A SOURCE DISTRIBUTION
Distutils supports building multiple types of release packages. At a minimum, you should build a “source distribution” that contains your source code, your Distutils setup script, your “read me” file, and whatever additional
files
you
want
to
include. To build a source distribution, pass the sdist command to your Distutils setup script.
c:\Users\pilgrim\chardet&gt; c:\python31\python.exe setup.py sdist
running sdist
running check
reading manifest template &lsquo;MANIFEST.in&rsquo;
writing manifest file &lsquo;MANIFEST&rsquo;
creating chardet-1.0.2
creating chardet-1.0.2\chardet
creating chardet-1.0.2\docs
creating chardet-1.0.2\docs\images
copying files to chardet-1.0.2&hellip;
copying COPYING -&gt; chardet-1.0.2
copying README.txt -&gt; chardet-1.0.2
copying setup.py -&gt; chardet-1.0.2
copying chardet__init__.py -&gt; chardet-1.0.2\chardet
copying chardet\big5freq.py -&gt; chardet-1.0.2\chardet
&hellip;
copying chardet\universaldetector.py -&gt; chardet-1.0.2\chardet
copying chardet\utf8prober.py -&gt; chardet-1.0.2\chardet
copying docs\faq.html -&gt; chardet-1.0.2\docs
copying docs\history.html -&gt; chardet-1.0.2\docs
copying docs\how-it-works.html -&gt; chardet-1.0.2\docs
copying docs\index.html -&gt; chardet-1.0.2\docs
copying docs\license.html -&gt; chardet-1.0.2\docs
copying docs\supported-encodings.html -&gt; chardet-1.0.2\docs
copying docs\usage.html -&gt; chardet-1.0.2\docs
copying docs\images\caution.png -&gt; chardet-1.0.2\docs\images
copying docs\images\important.png -&gt; chardet-1.0.2\docs\images
copying docs\images\note.png -&gt; chardet-1.0.2\docs\images
copying docs\images\permalink.gif -&gt; chardet-1.0.2\docs\images
copying docs\images\tip.png -&gt; chardet-1.0.2\docs\images
copying docs\images\warning.png -&gt; chardet-1.0.2\docs\images
creating dist
creating &lsquo;dist\chardet-1.0.2.zip&rsquo; and adding &lsquo;chardet-1.0.2&rsquo; to it
adding &lsquo;chardet-1.0.2\COPYING&rsquo;</p>

<p>adding &lsquo;chardet-1.0.2\PKG-INFO&rsquo;</p>

<p>adding &lsquo;chardet-1.0.2\README.txt&rsquo;
adding &lsquo;chardet-1.0.2\setup.py&rsquo;
adding &lsquo;chardet-1.0.2\chardet\big5freq.py&rsquo;
adding &lsquo;chardet-1.0.2\chardet\big5prober.py&rsquo;
&hellip;
adding &lsquo;chardet-1.0.2\chardet\universaldetector.py&rsquo;
adding &lsquo;chardet-1.0.2\chardet\utf8prober.py&rsquo;
adding &lsquo;chardet-1.0.2\chardet__init__.py&rsquo;
adding &lsquo;chardet-1.0.2\docs\faq.html&rsquo;
adding &lsquo;chardet-1.0.2\docs\history.html&rsquo;
adding &lsquo;chardet-1.0.2\docs\how-it-works.html&rsquo;
adding &lsquo;chardet-1.0.2\docs\index.html&rsquo;
adding &lsquo;chardet-1.0.2\docs\license.html&rsquo;
adding &lsquo;chardet-1.0.2\docs\supported-encodings.html&rsquo;
adding &lsquo;chardet-1.0.2\docs\usage.html&rsquo;
adding &lsquo;chardet-1.0.2\docs\images\caution.png&rsquo;
adding &lsquo;chardet-1.0.2\docs\images\important.png&rsquo;
adding &lsquo;chardet-1.0.2\docs\images\note.png&rsquo;
adding &lsquo;chardet-1.0.2\docs\images\permalink.gif&rsquo;
adding &lsquo;chardet-1.0.2\docs\images\tip.png&rsquo;
adding &lsquo;chardet-1.0.2\docs\images\warning.png&rsquo;
removing &lsquo;chardet-1.0.2&rsquo; (and everything under it)</p>

<p>Several things to note here:
•   Distutils noticed the manifest file (MANIFEST.in).</p>

<p>•   Distutils successfully parsed the manifest file and added the additional files we wanted — COPYING.txt and the HTML and image files in the docs/ directory.</p>

<p>•   If you look in your project directory, you’ll see that Distutils created a dist/ directory. Within the dist/ directory the .zip file that you can distribute.</p>

<p>c:\Users\pilgrim\chardet&gt; dir dist
Volume in drive C has no label.
Volume Serial Number is DED5-B4F8</p>

<p>Directory of c:\Users\pilgrim\chardet\dist</p>

<p>07/30/2009 06:29 PM <DIR> .
07/30/2009 06:29 PM <DIR> ..
07/30/2009 06:29 PM 206,440 chardet-1.0.2.zip</p>

<p>1 File(s) 206,440 bytes
2 Dir(s) 61,424,635,904 bytes free</p>

<p>.</p>

<p>16.9. CREATING A GRAPHICAL INSTALLER
In my opinion, every Python library deserves a graphical installer for Windows users. It’s easy to make (even if you don’t run Windows yourself), and Windows users appreciate it.
Distutils can create
a
graphical
Windows
installer
for
you, by passing the bdist_wininst command to your Distutils setup script.
c:\Users\pilgrim\chardet&gt; c:\python31\python.exe setup.py bdist_wininst</p>

<p>running bdist_wininst
running build
running build_py
creating build
creating build\lib
creating build\lib\chardet
copying chardet\big5freq.py -&gt; build\lib\chardet
copying chardet\big5prober.py -&gt; build\lib\chardet
&hellip;
copying chardet\universaldetector.py -&gt; build\lib\chardet
copying chardet\utf8prober.py -&gt; build\lib\chardet
copying chardet__init<strong>.py -&gt; build\lib\chardet
installing to build\bdist.win32\wininst
running install_lib
creating build\bdist.win32
creating build\bdist.win32\wininst
creating build\bdist.win32\wininst\PURELIB
creating build\bdist.win32\wininst\PURELIB\chardet
copying build\lib\chardet\big5freq.py -&gt; build\bdist.win32\wininst\PURELIB\chardet
copying build\lib\chardet\big5prober.py -&gt; build\bdist.win32\wininst\PURELIB\chardet
&hellip;
copying build\lib\chardet\universaldetector.py -&gt; build\bdist.win32\wininst\PURELIB\chardet
copying build\lib\chardet\utf8prober.py -&gt; build\bdist.win32\wininst\PURELIB\chardet
copying build\lib\chardet__init</strong>.py -&gt; build\bdist.win32\wininst\PURELIB\chardet
running install_egg_info
Writing build\bdist.win32\wininst\PURELIB\chardet-1.0.2-py3.1.egg-info
creating &lsquo;c:\users\pilgrim\appdata\local\temp\tmp2f4h7e.zip&rsquo; and adding &lsquo;.&rsquo; to it
adding &lsquo;PURELIB\chardet-1.0.2-py3.1.egg-info&rsquo;
adding &lsquo;PURELIB\chardet\big5freq.py&rsquo;
adding &lsquo;PURELIB\chardet\big5prober.py&rsquo;
&hellip;
adding &lsquo;PURELIB\chardet\universaldetector.py&rsquo;
adding &lsquo;PURELIB\chardet\utf8prober.py&rsquo;</p>

<p>adding &lsquo;PURELIB\chardet__init__.py&rsquo;</p>

<p>removing &lsquo;build\bdist.win32\wininst&rsquo; (and everything under it)
c:\Users\pilgrim\chardet&gt; dir dist
c:\Users\pilgrim\chardet&gt;dir dist</p>

<p>Volume in drive C has no label.
Volume Serial Number is AADE-E29F</p>

<p>Directory of c:\Users\pilgrim\chardet\dist</p>

<p>07/30/2009 10:14 PM <DIR> .
07/30/2009 10:14 PM <DIR> ..
07/30/2009 10:14 PM 371,236 chardet-1.0.2.win32.exe
07/30/2009 06:29 PM 206,440 chardet-1.0.2.zip</p>

<p>2 File(s) 577,676 bytes
2 Dir(s) 61,424,070,656 bytes free</p>

<p>16.9.1. BUILDING INSTALLABLE PACKAGES FOR OTHER OPERATING SYSTEMS
Distutils can help you build
installable
packages
for
Linux
users. In my opinion, this probably isn’t worth your time. If you want your software distributed for Linux, your time would be better spent working with community members who specialize in packaging software for major Linux distributions.
For example, my chardet library is in
the
Debian
GNU/Linux
repositories
(and therefore in
the
Ubuntu
repositories
as well). I had nothing to do with this; the packages just showed up there one day. The Debian community has their
own
policies
for
packaging
Python
libraries, and the Debian python-chardet package is designed to follow these conventions. And since the package lives in Debian’s repositories, Debian users will receive security updates and/or new versions, depending on the system-wide settings they’ve chosen to manage their own computers.
The Linux packages that Distutils builds offer none of these advantages. Your time is better spent elsewhere.
.</p>

<p>16.10. ADDING YOUR SOFTWARE TO THE PYTHON PACKAGE INDEX</p>

<p>Uploading software to the Python Package Index is a three step process.
1. Register yourself</p>

<ol>
<li><p>Register your software</p></li>

<li><p>Upload the packages you created with setup.py sdist and setup.py bdist_*</p></li>
</ol>

<p>To register yourself, go to the
PyPI
user
registration
page. Enter your desired username and password, provide a valid email address, and click the Register button. (If you have a PGP or GPG key, you can also provide that. If you don’t have one or don’t know what that means, don’t worry about it.) Check your email; within a few minutes, you should receive a message from PyPI with a validation link. Click the link to complete the registration process.
Now you need to register your software with PyPI and upload it. You can do this all in one step.
c:\Users\pilgrim\chardet&gt; c:\python31\python.exe setup.py register sdist bdist_wininst upload</p>

<p>running register
We need to know who you are, so please choose either:</p>

<p>1.
 use your existing login,</p>

<p>2.
 register as a new user,</p>

<p>3.
 have the server generate a new password for you (and email it to you), or</p>

<p>4.
 quit</p>

<p>Your selection [default 1]: 1</p>

<p>Username: MarkPilgrim
Password:</p>

<p>Registering chardet to <a href="http://pypi.python.org/pypi">http://pypi.python.org/pypi</a>
Server response (200): OK</p>

<p>running sdist
&hellip; output trimmed for brevity &hellip;</p>

<p>running bdist_wininst
&hellip; output trimmed for brevity &hellip;
running upload
Submitting dist\chardet-1.0.2.zip to <a href="http://pypi.python.org/pypi">http://pypi.python.org/pypi</a>
Server response (200): OK
Submitting dist\chardet-1.0.2.win32.exe to <a href="http://pypi.python.org/pypi">http://pypi.python.org/pypi</a>
Server response (200): OK
I can store your PyPI login so future submissions will be faster.
(the login will be stored in c:\home.pypirc)</p>

<p>Save your login (y/N)?n</p>

<ol>
<li><p>When you release your project for the first time, Distutils will add your software to the Python Package Index and give it its own URL. Every time after that, it will simply update the project metadata with any changes you may have made in your setup.py parameters. Next, it builds a source distribution (sdist) and a Windows installer (bdist_wininst), then uploads them to PyPI (upload).</p></li>

<li><p>Type 1 or just press ENTER to select “use your existing login.”</p></li>

<li><p>Enter the username and password you selected on the the
PyPI
user
registration
page. Distuils will not echo your password; it will not even echo asterisks in place of characters. Just type your password and press ENTER.</p></li>

<li><p>Distutils registers your package with the Python Package Index…</p></li>

<li><p>…builds your source distribution…</p></li>

<li><p>…builds your Windows installer…</p></li>

<li><p>…and uploads them both to the Python Package Index.</p></li>

<li><p>If you want to automate the process of releasing new versions, you need to save your PyPI credentials in a local file. This is completely insecure and completely optional.</p></li>
</ol>

<p>Congratulations, you now have your own page on the Python Package Index! The address is
<a href="http://pypi.python.org/pypi/NAME">http://pypi.python.org/pypi/NAME</a>, where NAME is the string you passed in the name parameter in your
setup.py file.</p>

<p>If you want to release a new version, just update your setup.py with the new version number, then run the same upload command again:
c:\Users\pilgrim\chardet&gt; c:\python31\python.exe setup.py register sdist bdist_wininst upload</p>

<p>.</p>

<p>16.11. THE MANY POSSIBLE FUTURES OF PYTHON PACKAGING
Distutils is not the be-all and end-all of Python packaging, but as of this writing (August 2009), it’s the only
packaging framework that works in Python 3. There are a number of other frameworks for Python 2; some
focus on installation, others on testing and deployment. Some or all of these may end up being ported to
Python 3 in the future.</p>

<p>These frameworks focus on installation:
•   Setuptools</p>

<p>•   Pip</p>

<p>•   Distribute</p>

<p>These focus on testing and deployment:
•  virtualenv<br />
•  zc.buildout<br />
•  Paver</p>

<p>•  Fabric</p>

<p>•  py2exe</p>

<p>.
16.12. FURTHER READING
On Distutils:
• Distributing
Python
Modules
with
Distutils</p>

<p>• Core
Distutils
functionality
lists all the possible arguments to the setup() function</p>

<p>• Distutils
Cookbook</p>

<p>• PEP
370:
Per
user
site-packages directory</p>

<p>• PEP
370
and
“environment
stew”</p>

<p>On other packaging frameworks:</p>

<p>• The
Python
packaging
ecosystem</p>

<p>• On
packaging</p>

<p>• A
few
corrections
to
“On
packaging”</p>

<p>• Why
I
like
Pip</p>

<p>• Python
packaging:
a
few
observations</p>

<p>• Nobody
expects
Python
packaging!</p>

<p>CHAPTER 17. PORTING CODE TO PYTHON 3 WITH</p>

<p>2to3</p>

<p>. Life is pleasant. Death is peaceful. It’s the transition that’s troublesome. .
— Isaac Asimov (attributed)
17.1. DIVING IN
So much has changed between Python 2 and Python 3, there are vanishingly few programs that will run unmodified under both. But don’t despair! To help with this transition, Python 3 comes with a utility script called 2to3, which takes your actual Python 2 source code as input and auto-converts as much as it can to Python 3. Case
study:
porting
chardet to
Python
3
describes how to run the 2to3 script, then shows some things it can’t fix automatically. This appendix documents what it can fix automatically.
17.2. print STATEMENT
In Python 2, print was a statement. Whatever you wanted to print simply followed the print keyword. In Python 3, print() is
a
function. Whatever you want to print, pass it to print() like any other function.</p>

<ol>
<li><p>To print a blank line, call print() without any arguments.</p></li>

<li><p>To print a single value, call print() with one argument.</p></li>

<li><p>To print two values separated by a space, call print() with two arguments.</p></li>

<li><p>This one is a little tricky. In Python 2, if you ended a print statement with a comma, it would print the values separated by spaces, then print a trailing space, then stop without printing a carriage return. (Technically, it’s a little more complicated than that. The print statement in Python 2 used a now-deprecated attribute called softspace. Instead of printing a space, Python 2 would set sys.stdout.softspace to 1. The space character wasn’t really printed until something else got printed on the same line. If the next print statement printed a carriage return, sys.stdout.softspace would be set to 0 and the space would never be printed. You probably never noticed the difference unless your application was sensitive to the presence or absence of trailing whitespace in print-generated output.) In Python 3, the way to do this is to pass end=&rsquo; &lsquo; as a keyword argument to the print() function. The end argument defaults to &lsquo;\n&rsquo; (a carriage return), so overriding it will suppress the carriage return after printing the other arguments.</p></li>

<li><p>In Python 2, you could redirect the output to a pipe — like sys.stderr — by using the &gt;&gt;pipe_name syntax. In Python 3, the way to do this is to pass the pipe in the file keyword argument. The file argument defaults to sys.stdout (standard out), so overriding it will output to a different pipe instead.</p></li>
</ol>

<p>17.3. UNICODE STRING LITERALS
Python 2 had two string types: Unicode strings and non-Unicode strings. Python 3 has one string type: Unicode
strings.</p>

<ol>
<li><p>Unicode string literals are simply converted into string literals, which, in Python 3, are always Unicode.</p></li>

<li><p>Unicode raw strings (in which Python does not auto-escape backslashes) are converted to raw strings. In Python 3, raw strings are always Unicode.</p></li>
</ol>

<p>17.4. unicode() GLOBAL FUNCTION
Python 2 had two global functions to coerce objects into strings: unicode() to coerce them into Unicode strings, and str() to coerce them into non-Unicode strings. Python 3 has only one string type, Unicode
strings, so the str() function is all you need. (The unicode() function no longer exists.)</p>

<p>17.5. long DATA TYPE
Python 2 had separate int and long types for non-floating-point numbers. An int could not be any larger than sys.maxint, which varied by platform. Longs were defined by appending an L to the end of the number, and they could be, well, longer than ints. In Python 3, there
is
only
one
integer
type, called int, which mostly behaves like the long type in Python 2. Since there are no longer two types, there is no need for special syntax to distinguish them.
Further reading: PEP
237:
Unifying
Long
Integers
and
Integers.</p>

<p>Notes</p>

<p>Python 2</p>

<p>.
x = 1000000000000L</p>

<p>.
x = 0xFFFFFFFFFFFFL</p>

<p>.
long(x)</p>

<p>.
type(x) is long</p>

<p>.
isinstance(x, long)</p>

<ol>
<li><p>Base 10 long integer literals become base 10 integer literals.</p></li>

<li><p>Base 16 long integer literals become base 16 integer literals.</p></li>
</ol>

<p>Python 3
x = 1000000000000
x = 0xFFFFFFFFFFFF
int(x)
type(x) is int
isinstance(x, int)</p>

<ol>
<li><p>In Python 3, the old long() function no longer exists, since longs don’t exist. To coerce a variable to an integer, use the int() function.</p></li>

<li><p>To check whether a variable is an integer, get its type and compare it to int, not long.</p></li>

<li><p>You can also use the isinstance() function to check data types; again, use int, not long, to check for integers.</p></li>
</ol>

<p>17.6. &lt;&gt; COMPARISON
Python 2 supported &lt;&gt; as a synonym for !=, the not-equals comparison operator. Python 3 supports the != operator, but not &lt;&gt;.</p>

<ol>
<li><p>A simple comparison.</p></li>

<li><p>A more complex comparison between three values.</p></li>
</ol>

<p>17.7. has_key() DICTIONARY METHOD
In Python 2, dictionaries had a has_key() method to test whether the dictionary had a certain key. In Python 3, this method no longer exists. Instead, you need to use the
in operator.</p>

<ol>
<li><p>The simplest form.</p></li>

<li><p>The in operator takes precedence over the or operator, so there is no need for parentheses around x in a_dictionary or around y in a_dictionary.</p></li>

<li><p>On the other hand, you do need parentheses around x or y here, for the same reason — in takes precedence over or. (Note: this code is completely different from the previous line. Python interprets x or y first, which results in either x (if x is true
in
a
boolean
context) or y. Then it takes that singular value and checks whether it is a key in a_dictionary.)</p></li>

<li><p>The + operator takes precedence over the in operator, so this form technically doesn’t need parentheses around x+y, but 2to3 includes them anyway.</p></li>

<li><p>This form definitely needs parentheses around y in a_dictionary, since the + operator takes precedence over the in operator.</p></li>
</ol>

<p>17.8. DICTIONARY METHODS THAT RETURN LISTS</p>

<p>In Python 2, many dictionary methods returned lists. The most frequently used methods were keys(), items(), and values(). In Python 3, all of these methods return dynamic views. In some contexts, this is not a problem. If the method’s return value is immediately passed to another function that iterates through the entire sequence, it makes no difference whether the actual type is a list or a view. In other contexts, it matters a great deal. If you were expecting a complete list with individually addressable elements, your code</p>

<p>will choke, because views do not support indexing.
Notes  Python 2<br />
.  a_dictionary.keys()<br />
.  a_dictionary.items()<br />
.  a_dictionary.iterkeys()<br />
.  [i for i in a_dictionary.iterkeys()]<br />
.  min(a_dictionary.keys())</p>

<p>Python 3
list(a_dictionary.keys())
list(a_dictionary.items())
iter(a_dictionary.keys())
[i for i in a_dictionary.keys()]</p>

<p>no change
1.  2to3 errs on the side of safety, converting the return value from keys() to a static list with the list() function. This will always work, but it will be less efficient than using a view. You should examine the converted code to see if a list is absolutely necessary, or if a view would do.</p>

<ol>
<li><p>Another view-to-list conversion, with the items() method. 2to3 will do the same thing with the values() method.</p></li>

<li><p>Python 3 does not support the iterkeys() method anymore. Use keys(), and if necessary, convert the view to an iterator with the iter() function.</p></li>

<li><p>2to3 recognizes when the iterkeys() method is used inside a list comprehension, and converts it to the keys() method (without wrapping it in an extra call to iter()). This works because views are iterable.</p></li>

<li><p>2to3 recognizes that the keys() method is immediately passed to a function which iterates through an entire sequence, so there is no need to convert the return value to a list first. The min() function will happily iterate through the view instead. This applies to min(), max(), sum(), list(), tuple(), set(), sorted(), any(), and all().</p></li>
</ol>

<p>17.9. MODULES THAT HAVE BEEN RENAMED OR REORGANIZED
Several modules in the Python Standard Library have been renamed. Several other modules which are related to each other have been combined or reorganized to make their association more logical.
17.9.1. http
In Python 3, several related HTTP modules have been combined into a single package, http.</p>

<ol>
<li><p>The http.client module implements a low-level library that can request HTTP resources and interpret HTTP responses.</p></li>

<li><p>The http.cookies module provides a Pythonic interface to browser cookies that are sent in a Set-Cookie: HTTP header.</p></li>

<li><p>The http.cookiejar module manipulates the actual files on disk that popular web browsers use to store cookies.</p></li>

<li><p>The http.server module provides a basic HTTP server.</p></li>
</ol>

<p>17.9.2. urllib
Python 2 had a rat’s nest of overlapping modules to parse, encode, and fetch URLS. In Python 3, these have all been refactored and combined in a single package, urllib.</p>

<ol>
<li><p>The old urllib module in Python 2 had a variety of functions, including urlopen() for fetching data and splittype(), splithost(), and splituser() for splitting a URL into its constituent parts. These functions have been reorganized more logically within the new urllib package. 2to3 will also change all calls to these functions so they use the new naming scheme.</p></li>

<li><p>The old urllib2 module in Python 2 has been folded into the urllib package in Python 3. All your urllib2 favorites — the build_opener() method, Request objects, and HTTPBasicAuthHandler and friends — are still available.</p></li>

<li><p>The urllib.parse module in Python 3 contains all the parsing functions from the old urlparse module in Python 2.</p></li>

<li><p>The urllib.robotparser module parses robots.txt files.</p></li>

<li><p>The FancyURLopener class, which handles HTTP redirects and other status codes, is still available in the new urllib.request module. The urlencode() function has moved to urllib.parse.</p></li>

<li><p>The Request object is still available in urllib.request, but constants like HTTPError have been moved to urllib.error.</p></li>
</ol>

<p>Did I mention that 2to3 will rewrite your function calls too? For example, if your Python 2 code imports the urllib module and calls urllib.urlopen() to fetch data, 2to3 will fix both the import statement and the function call.
Notes Python 2 Python 3
import urllib</p>

<p>import urllib.request, urllib.parse, urllib.error
print urllib.urlopen(&lsquo;<a href="http://diveintopython3.org/').read(">http://diveintopython3.org/').read(</a>)</p>

<p>print(urllib.request.urlopen(&lsquo;<a href="http://diveintopython3.org/').read()">http://diveintopython3.org/').read()</a>)</p>

<p>17.9.3. dbm
All the various DBM clones are now in a single package, dbm. If you need a specific variant like GNU DBM , you can import the appropriate module within the dbm package.</p>

<p>17.9.4. xmlrpc
XML-RPC is a lightweight method of performing remote RPC calls over HTTP. The XML-RPC client library and several XML-RPC server implementations are now combined in a single package, xmlrpc.</p>

<p>17.9.5. OTHER MODULES</p>

<ol>
<li><p>A common idiom in Python 2 was to try to import cStringIO as StringIO, and if that failed, to import StringIO instead. Do not do this in Python 3; the io module does it for you. It will find the fastest implementation available and use it automatically.</p></li>

<li><p>A similar idiom was used to import the fastest pickle implementation. Do not do this in Python 3; the pickle module does it for you.</p></li>

<li><p>The builtins module contains the global functions, classes, and constants used throughout the Python language. Redefining a function in the builtins module will redefine the global function everywhere. That is exactly as powerful and scary as it sounds.</p></li>

<li><p>The copyreg module adds pickle support for custom types defined in C.</p></li>

<li><p>The queue module implements a multi-producer, multi-consumer queue.</p></li>

<li><p>The socketserver module provides generic base classes for implementing different kinds of socket servers.</p></li>

<li><p>The configparser module parses INI-style configuration files.</p></li>

<li><p>The reprlib module reimplements the built-in repr() function, with additional controls on how long the representations can be before they are truncated.</p></li>

<li><p>The subprocess module allows you to spawn processes, connect to their pipes, and obtain their return codes.</p></li>
</ol>

<p>17.10. RELATIVE IMPORTS WITHIN A PACKAGE
A package is a group of related modules that function as a single entity. In Python 2, when modules within a package need to reference each other, you use import foo or from foo import Bar. The Python 2 interpreter first searches within the current package to find foo.py, and then moves on to the other directories in the Python search path (sys.path). Python 3 works a bit differently. Instead of searching the current package, it goes directly to the Python search path. If you want one module within a package to import another module in the same package, you need to explicitly provide the relative path between the two modules.
Suppose you had this package, with multiple files in the same directory:
chardet/
|
+&ndash;<strong>init</strong>.py
|
+&ndash;constants.py
|
+&ndash;mbcharsetprober.py
|
+&ndash;universaldetector.py</p>

<p>Now suppose that universaldetector.py needs to import the entire constants.py file and one class from mbcharsetprober.py. How do you do it?</p>

<ol>
<li><p>When you need to import an entire module from elsewhere in your package, use the new from . import syntax. The period is actually a relative path from this file (universaldetector.py) to the file you want to import (constants.py). In this case, they are in the same directory, thus the single period. You can also import from the parent directory (from .. import anothermodule) or a subdirectory.</p></li>

<li><p>To import a specific class or function from another module directly into your module’s namespace, prefix the target module with a relative path, minus the trailing slash. In this case, mbcharsetprober.py is in the same directory as universaldetector.py, so the path is a single period. You can also import form the parent directory (from ..anothermodule import AnotherClass) or a subdirectory.</p></li>
</ol>

<p>17.11. next() ITERATOR METHOD
In Python 2, iterators had a next() method which returned the next item in the sequence. That’s still true in Python 3, but there is now also a
global
next() function
that takes an iterator as an argument.</p>

<p>Notes</p>

<p>Python 2</p>

<p>Python 3
.
anIterator.next()</p>

<p>next(anIterator)</p>

<p>.
a_function_that_returns_an_iterator().next()</p>

<p>next(a_function_that_returns_an_iterator())</p>

<p>class A:</p>

<p>class A:
def next(self):</p>

<p>.
def <strong>next</strong>(self):
pass</p>

<p>pass</p>

<p>class A:</p>

<p>.
no change
def next(self, x, y):
pass</p>

<p>next = 42</p>

<p>next = 42
for an_iterator in a_sequence_of_iterators:</p>

<p>.
for an_iterator in a_sequence_of_iterators:
an_iterator.next()</p>

<p>an_iterator.<strong>next</strong>()</p>

<ol>
<li><p>In the simplest case, instead of calling an iterator’s next() method, you now pass the iterator itself to the global next() function.</p></li>

<li><p>If you have a function that returns an iterator, call the function and pass the result to the next() function. (The 2to3 script is smart enough to convert this properly.)</p></li>

<li><p>If you define your own class and mean to use it as an iterator, define the <strong>next</strong>() special method.</p></li>

<li><p>If you define your own class and just happen to have a method named next() that takes one or more arguments, 2to3 will not touch it. This class can not be used as an iterator, because its next() method takes arguments.</p></li>

<li><p>This one is a bit tricky. If you have a local variable named next, then it takes precedence over the new global next() function. In this case, you need to call the iterator’s special <strong>next</strong>() method to get the next item in the sequence. (Alternatively, you could also refactor the code so the local variable wasn’t named next, but 2to3 will not do that for you automatically.)</p></li>
</ol>

<p>17.12. filter() GLOBAL FUNCTION
In Python 2, the filter() function returned a list, the result of filtering a sequence through a function that returned True or False for each item in the sequence. In Python 3, the filter() function returns an iterator, not a list.</p>

<ol>
<li><p>In the most basic case, 2to3 will wrap a call to filter() with a call to list(), which simply iterates through its argument and returns a real list.</p></li>

<li><p>However, if the call to filter() is already wrapped in list(), 2to3 will do nothing, since the fact that filter() is returning an iterator is irrelevant.</p></li>

<li><p>For the special syntax of filter(None, &hellip;), 2to3 will transform the call into a semantically equivalent list comprehension.</p></li>

<li><p>In contexts like for loops, which iterate through the entire sequence anyway, no changes are necessary.</p></li>

<li><p>Again, no changes are necessary, because the list comprehension will iterate through the entire sequence, and it can do that just as well if filter() returns an iterator as if it returns a list.</p></li>
</ol>

<p>17.13. map() GLOBAL FUNCTION
In much the same way as filter(), the map() function now returns an iterator. (In Python 2, it returned a</p>

<p>list.)
Notes Python 2
.
map(a_function, &lsquo;PapayaWhip&rsquo;)</p>

<p>.
map(None, &lsquo;PapayaWhip&rsquo;)</p>

<p>.
map(lambda x: x+1, range(42))</p>

<p>.
for i in map(a_function, a_sequence):</p>

<p>.
[i for i in map(a_function,
a_sequence)]</p>

<p>Python 3
list(map(a_function, &lsquo;PapayaWhip&rsquo;))
list(&lsquo;PapayaWhip&rsquo;)
[x+1 for x in range(42)]</p>

<p>no change no change
1.  As with filter(), in the most basic case, 2to3 will wrap a call to map() with a call to list().</p>

<ol>
<li><p>For the special syntax of map(None, &hellip;), the identity function, 2to3 will convert it to an equivalent call to list().</p></li>

<li><p>If the first argument to map() is a lambda function, 2to3 will convert it to an equivalent list comprehension.</p></li>

<li><p>In contexts like for loops, which iterate through the entire sequence anyway, no changes are necessary.</p></li>

<li><p>Again, no changes are necessary, because the list comprehension will iterate through the entire sequence, and it can do that just as well if map() returns an iterator as if it returns a list.</p></li>
</ol>

<p>17.14. reduce() GLOBAL FUNCTION
In Python 3, the reduce() function has been removed from the global namespace and placed in the functools module.</p>

<p>17.15. apply() GLOBAL FUNCTION
Python 2 had a global function called apply(), which took a function f and a list [a, b, c] and returned f(a, b, c). You can accomplish the same thing by calling the function directly and passing it the list of arguments preceded by an asterisk. In Python 3, the apply() function no longer exists; you must use the asterisk notation.</p>

<ol>
<li><p>In the simplest form, you can call a function with a list of arguments (an actual list like [a, b, c]) by prepending the list with an asterisk (*). This is exactly equivalent to the old apply() function in Python 2.</p></li>

<li><p>In Python 2, the apply() function could actually take three parameters: a function, a list of arguments, and a dictionary of named arguments. In Python 3, you can accomplish the same thing by prepending the list of arguments with an asterisk (*) and the dictionary of named arguments with two asterisks (**).</p></li>

<li><p>The + operator, used here for list concatenation, takes precedence over the * operator, so there is no need for extra parentheses around a_list_of_args + z.</p></li>

<li><p>The 2to3 script is smart enough to convert complex apply() calls, including calling functions within imported modules.</p></li>
</ol>

<p>17.16. intern() GLOBAL FUNCTION
In Python 2, you could call the intern() function on a string to intern it as a performance optimization. In Python 3, the intern() function has been moved to the sys module.</p>

<p>17.17. exec STATEMENT
Just as the
print statement
became a function in Python 3, so too has the exec statement. The exec() function takes a string which contains arbitrary Python code and executes it as if it were just another statement or expression. exec() is like eval(), but even more powerful and evil. The eval() function can only evaluate a single expression, but exec() can execute multiple statements, imports, function declarations — essentially an entire Python program in a string.</p>

<ol>
<li><p>In the simplest form, the 2to3 script simply encloses the code-as-a-string in parentheses, since exec() is now a function instead of a statement.</p></li>

<li><p>The old exec statement could take a namespace, a private environment of globals in which the code-as-a­string would be executed. Python 3 can also do this; just pass the namespace as the second argument to the exec() function.</p></li>

<li><p>Even fancier, the old exec statement could also take a local namespace (like the variables defined within a function). In Python 3, the exec() function can do that too.</p></li>
</ol>

<p>17.18. execfile STATEMENT
Like the old exec statement, the old execfile statement will execute strings as if they were Python code. Where exec took a string, execfile took a filename. In Python 3, the execfile statement has been eliminated. If you really need to take a file of Python code and execute it (but you’re not willing to simply import it), you can accomplish the same thing by opening the file, reading its contents, calling the global compile() function to force the Python interpreter to compile the code, and then call the new exec() function.</p>

<p>17.19. repr LITERALS (BACKTICKS)
In Python 2, there was a special syntax of wrapping any object in backticks (like <code>x</code>) to get a representation of the object. In Python 3, this capability still exists, but you can no longer use backticks to get it. Instead, use the global repr() function.</p>

<ol>
<li><p>Remember, x can be anything — a class, a function, a module, a primitive data type, &amp;c. The repr() function works on everything.</p></li>

<li><p>In Python 2, backticks could be nested, leading to this sort of confusing (but valid) expression. The 2to3 tool is smart enough to convert this into nested calls to repr().</p></li>
</ol>

<p>17.20. try&hellip;except STATEMENT
The syntax for catching
exceptions
has changed slightly between Python 2 and Python 3.</p>

<ol>
<li><p>Instead of a comma after the exception type, Python 3 uses a new keyword, as.</p></li>

<li><p>The as keyword also works for catching multiple types of exceptions at once.</p></li>

<li><p>If you catch an exception but don’t actually care about accessing the exception object itself, the syntax is identical between Python 2 and Python 3.</p></li>

<li><p>Similarly, if you use a fallback to catch all exceptions, the syntax is identical.</p></li>
</ol>

<p>. You should never use a fallback to catch all exceptions when importing modules (or most other times). Doing so will catch things like KeyboardInterrupt (if the user pressed Ctrl-C to interrupt the program) and can make it more difficult to debug errors.
17.21. raise STATEMENT
The syntax for raising
your
own
exceptions
has changed slightly between Python 2 and Python 3.</p>

<ol>
<li><p>In the simplest form, raising an exception without a custom error message, the syntax is unchanged.</p></li>

<li><p>The change becomes noticeable when you want to raise an exception with a custom error message. Python 2 separated the exception class and the message with a comma; Python 3 passes the error message as a parameter.</p></li>

<li><p>Python 2 supported a more complex syntax to raise an exception with a custom traceback (stack trace). You can do this in Python 3 as well, but the syntax is quite different.</p></li>

<li><p>In Python 2, you could raise an exception with no exception class, just an error message. In Python 3, this is no longer possible. 2to3 will warn you that it was unable to fix this automatically.</p></li>
</ol>

<p>17.22. throw METHOD ON GENERATORS
In Python 2, generators have a throw() method. Calling a_generator.throw() raises an exception at the point where the generator was paused, then returns the next value yielded by the generator function. In Python 3, this functionality is still available, but the syntax is slightly different.</p>

<ol>
<li><p>In the simplest form, a generator throws an exception without a custom error message. In this case, the syntax has not changed between Python 2 and Python 3.</p></li>

<li><p>If the generator throws an exception with a custom error message, you need to pass the error string to the exception when you create it.</p></li>

<li><p>Python 2 also supported throwing an exception with only a custom error message. Python 3 does not support this, and the 2to3 script will display a warning telling you that you will need to fix this code manually.</p></li>
</ol>

<p>17.23. xrange() GLOBAL FUNCTION
In Python 2, there were two ways to get a range of numbers: range(), which returned a list, and xrange(), which returned an iterator. In Python 3, range() returns an iterator, and xrange() doesn’t exist.</p>

<ol>
<li><p>In the simplest case, the 2to3 script will simply convert xrange() to range().</p></li>

<li><p>If your Python 2 code used range(), the 2to3 script does not know whether you needed a list, or whether an iterator would do. It errs on the side of caution and coerces the return value into a list by calling the list() function.</p></li>

<li><p>If the xrange() function was inside a list comprehension, the 2to3 script is clever enough not to wrap the range() function with a call to list(). The list comprehension will work just fine with the iterator that the range() function returns.</p></li>

<li><p>Similarly, a for loop will work just fine with an iterator, so there is no need to change anything here.</p></li>

<li><p>The sum() function will also work with an iterator, so 2to3 makes no changes here either. Like dictionary
methods
that
return
views
instead
of
lists, this applies to min(), max(), sum(), list(), tuple(), set(), sorted(), any(), and all().</p></li>
</ol>

<p>17.24. raw_input() AND input() GLOBAL FUNCTIONS
Python 2 had two global functions for asking the user for input on the command line. The first, called input(), expected the user to enter a Python expression (and returned the result). The second, called raw_input(), just returned whatever the user typed. This was wildly confusing for beginners and widely regarded as a “wart” in the language. Python 3 excises this wart by renaming raw_input() to input(), so it works the way everyone naively expects it to work.</p>

<ol>
<li><p>In the simplest form, raw_input() becomes input().</p></li>

<li><p>In Python 2, the raw_input() function could take a prompt as a parameter. This has been retained in Python 3.</p></li>

<li><p>If you actually need to ask the user for a Python expression to evaluate, use the input() function and pass the result to eval().</p></li>
</ol>

<p>17.25. func_* FUNCTION ATTRIBUTES
In Python 2, code within functions can access special attributes about the function itself. In Python 3, these special function attributes have been renamed for consistency with other attributes.</p>

<p>Notes
Python 2
.
a_function.func_name</p>

<p>.
a_function.func_doc</p>

<p>.
a_function.func_defaults</p>

<p>.
a_function.func_dict</p>

<p>.
a_function.func_closure</p>

<p>.
a_function.func_globals</p>

<p>.
a_function.func_code</p>

<p>Python 3
a_function.<strong>name</strong>
a_function.<strong>doc</strong>
a_function.<strong>defaults</strong>
a_function.<strong>dict</strong>
a_function.<strong>closure</strong>
a_function.<strong>globals</strong>
a_function.<strong>code</strong></p>

<ol>
<li><p>The <strong>name</strong> attribute (previously func_name) contains the function’s name.</p></li>

<li><p>The <strong>doc</strong> attribute (previously func_doc) contains the docstring that you defined in the function’s source code.</p></li>

<li><p>The <strong>defaults</strong> attribute (previously func_defaults) is a tuple containing default argument values for those arguments that have default values.</p></li>

<li><p>The <strong>dict</strong> attribute (previously func_dict) is the namespace supporting arbitrary function attributes.</p></li>

<li><p>The <strong>closure</strong> attribute (previously func_closure) is a tuple of cells that contain bindings for the function’s free variables.</p></li>

<li><p>The <strong>globals</strong> attribute (previously func_globals) is a reference to the global namespace of the module in which the function was defined.</p></li>

<li><p>The <strong>code</strong> attribute (previously func_code) is a code object representing the compiled function body.</p></li>
</ol>

<p>17.26. xreadlines() I/O METHOD
In Python 2, file objects had an xreadlines() method which returned an iterator that would read the file one line at a time. This was useful in for loops, among other places. In fact, it was so useful, later versions of Python 2 added the capability to file objects themselves.
In Python 3, the xreadlines() method no longer exists. 2to3 can fix the simple cases, but some edge cases will require manual intervention.</p>

<ol>
<li><p>If you used to call xreadlines() with no arguments, 2to3 will convert it to just the file object. In Python 3, this will accomplish the same thing: read the file one line at a time and execute the body of the for loop.</p></li>

<li><p>If you used to call xreadlines() with an argument (the number of lines to read at a time), 2to3 will not fix</p></li>
</ol>

<p>it, and your code will fail with an AttributeError: &lsquo;_io.TextIOWrapper&rsquo; object has no attribute
&lsquo;xreadlines&rsquo;. You can manually change xreadlines() to readlines() to get it to work in Python 3. (The
readlines() method now returns an iterator, so it is just as efficient as xreadlines() was in Python 2.)
?
17.27. lambda FUNCTIONS THAT TAKE A TUPLE INSTEAD OF MULTIPLE PARAMETERS
In Python 2, you could define anonymous lambda functions which took multiple parameters by defining the function as taking a tuple with a specific number of items. In effect, Python 2 would “unpack” the tuple into named arguments, which you could then reference (by name) within the lambda function. In Python 3, you can still pass a tuple to a lambda function, but the Python interpreter will not unpack the tuple into named arguments. Instead, you will need to reference each argument by its positional index.</p>

<ol>
<li><p>If you had defined a lambda function that took a tuple of one item, in Python 3 that would become a lambda with references to x1[0]. The name x1 is autogenerated by the 2to3 script, based on the named arguments in the original tuple.</p></li>

<li><p>A lambda function with a two-item tuple (x, y) gets converted to x_y with positional arguments x_y[0] and x_y[1].</p></li>

<li><p>The 2to3 script can even handle lambda functions with nested tuples of named arguments. The resulting Python 3 code is a bit unreadable, but it works the same as the old code did in Python 2.</p></li>

<li><p>You can define lambda functions that take multiple arguments. Without parentheses around the arguments, Python 2 just treats it as a lambda function with multiple arguments; within the lambda function, you simply reference the arguments by name, just like any other function. This syntax still works in Python 3.</p></li>
</ol>

<p>17.28. SPECIAL METHOD ATTRIBUTES
In Python 2, class methods can reference the class object in which they are defined, as well as the method object itself. im_self is the class instance object; im_func is the function object; im_class is the class of im_self. In Python 3, these special method attributes have been renamed to follow the naming conventions
of other attributes.
Notes Python 2
aClassInstance.aClassMethod.im_func
aClassInstance.aClassMethod.im_self
aClassInstance.aClassMethod.im_class</p>

<p>Python 3
aClassInstance.aClassMethod.<strong>func</strong>
aClassInstance.aClassMethod.<strong>self</strong>
aClassInstance.aClassMethod.<strong>self</strong>.<strong>class</strong></p>

<p>17.29. <strong>nonzero</strong> SPECIAL METHOD
In Python 2, you could build your own classes that could be used in a boolean context. For example, you could instantiate the class and then use the instance in an if statement. To do this, you defined a special <strong>nonzero</strong>() method which returned True or False, and it was called whenever the instance was used in a boolean context. In Python 3, you can still do this, but the name of the method has changed to <strong>bool</strong>().</p>

<ol>
<li><p>Instead of <strong>nonzero</strong>(), Python 3 calls the <strong>bool</strong>() method when evaluating an instance in a boolean context.</p></li>

<li><p>However, if you have a <strong>nonzero</strong>() method that takes arguments, the 2to3 tool will assume that you were using it for some other purpose, and it will not make any changes.</p></li>
</ol>

<p>17.30. OCTAL LITERALS
The syntax for defining base 8 (octal) numbers has changed slightly between Python 2 and Python 3.</p>

<p>17.31. sys.maxint
Due to the integration
of
the
long and
int types, the sys.maxint constant is no longer accurate. Because the value may still be useful in determining platform-specific capabilities, it has been retained but renamed as sys.maxsize.</p>

<ol>
<li>maxint becomes maxsize.</li>
<li>Any usage of sys.maxint becomes sys.maxsize.
17.32. callable() GLOBAL FUNCTION
In Python 2, you could check whether an object was callable (like a function) with the global callable() function. In Python 3, this global function has been eliminated. To check whether an object is callable, check for the existence of the <strong>call</strong>() special method.</li>
</ol>

<p>17.33. zip() GLOBAL FUNCTION
In Python 2, the global zip() function took any number of sequences and returned a list of tuples. The first tuple contained the first item from each sequence; the second tuple contained the second item from each sequence; and so on. In Python 3, zip() returns an iterator instead of a list.</p>

<ol>
<li><p>In the simplest form, you can get the old behavior of the zip() function by wrapping the return value in a call to list(), which will run through the iterator that zip() returns and return a real list of the results.</p></li>

<li><p>In contexts that already iterate through all the items of a sequence (such as this call to the join() method), the iterator that zip() returns will work just fine. The 2to3 script is smart enough to detect these cases and make no change to your code.</p></li>
</ol>

<p>17.34. StandardError EXCEPTION
In Python 2, StandardError was the base class for all built-in exceptions other than StopIteration, GeneratorExit, KeyboardInterrupt, and SystemExit. In Python 3, StandardError has been eliminated; use Exception instead.</p>

<p>17.35. types MODULE CONSTANTS
The types module contains a variety of constants to help you determine the type of an object. In Python 2, it contained constants for all primitive types like dict and int. In Python 3, these constants have been eliminated; just use the primitive type name instead.</p>

<p>.</p>

<p>types.StringType gets mapped to bytes instead of str because a Python 2 “string”
(not a Unicode string, just a regular string) is really just a sequence of bytes in a particular character encoding.
17.36. isinstance() GLOBAL FUNCTION
The isinstance() function checks whether an object is an instance of a particular class or type. In Python 2, you could pass a tuple of types, and isinstance() would return True if the object was any of those types. In Python 3, you can still do this, but passing the same type twice is deprecated.</p>

<p>17.37. basestring DATATYPE
Python 2 had two string types: Unicode and non-Unicode. But there was also another type, basestring. It was an abstract type, a superclass for both the str and unicode types. It couldn’t be called or instantiated directly, but you could pass it to the global isinstance() function to check whether an object was either a Unicode or non-Unicode string. In Python 3, there is only one string type, so basestring has no reason to exist.</p>

<p>17.38. itertools MODULE
Python 2.3 introduced the itertools module, which defined variants of the global zip(), map(), and filter() functions that returned iterators instead of lists. In Python 3, those global functions return iterators, so those functions in the itertools module have been eliminated. (There are still lots
of
useful
functions
in
the
itertools module, just not these.)</p>

<ol>
<li><p>Instead of itertools.izip(), just use the global zip() function.</p></li>

<li><p>Instead of itertools.imap(), just use map().</p></li>

<li><p>itertools.ifilter() becomes filter().</p></li>

<li><p>The itertools module still exists in Python 3, it just doesn’t have the functions that have migrated to the global namespace. The 2to3 script is smart enough to remove the specific imports that no longer exist, while leaving other imports intact.
17.39. sys.exc_type, sys.exc_value, sys.exc_traceback
Python 2 had three variables in the sys module that you could access while an exception was being handled: sys.exc_type, sys.exc_value, sys.exc_traceback. (Actually, these date all the way back to Python 1.) Ever since Python 1.5, these variables have been deprecated in favor of sys.exc_info(), which is a function that returns a tuple containing those three values. In Python 3, these individual variables have finally gone away; you must use the sys.exc_info() function.</p></li>
</ol>

<p>Notes Python 2 sys.exc_type sys.exc_value sys.exc_traceback</p>

<p>Python 3
sys.exc_info()[0]
sys.exc_info()[1]
sys.exc_info()[2]</p>

<p>17.40. LIST COMPREHENSIONS OVER TUPLES
In Python 2, if you wanted to code a list comprehension that iterated over a tuple, you did not need to put parentheses around the tuple values. In Python 3, explicit parentheses are required.</p>

<p>17.41. os.getcwdu() FUNCTION
Python 2 had a function named os.getcwd(), which returned the current working directory as a (non-Unicode) string. Because modern file systems can handle directory names in any character encoding, Python
2.3 introduced os.getcwdu(). The os.getcwdu() function returned the current working directory as a Unicode string. In Python 3, there is only
one
string
type
(Unicode), so os.getcwd() is all you need.</p>

<p>17.42. METACLASSES
In Python 2, you could create metaclasses either by defining the metaclass argument in the class declaration, or by defining a special class-level <strong>metaclass</strong> attribute. In Python 3, the class-level attribute
has been eliminated.
Notes  Python 2<br />
.  class C(metaclass=PapayaMeta):<br />
pass<br />
.  class Whip:<br />
<strong>metaclass</strong> = PapayaMeta<br />
.  class C(Whipper, Beater):<br />
<strong>metaclass</strong> = PapayaMeta</p>

<p>Python 3
unchanged
class Whip(metaclass=PapayaMeta):</p>

<p>pass
class C(Whipper, Beater, metaclass=PapayaMeta):</p>

<p>pass</p>

<ol>
<li><p>Declaring the metaclass in the class declaration worked in Python 2, and it still works the same in Python 3.</p></li>

<li><p>Declaring the metaclass in a class attribute worked in Python 2, but doesn’t work in Python 3.</p></li>

<li><p>The 2to3 script is smart enough to construct a valid class declaration, even if the class is inherited from one or more base classes.</p></li>
</ol>

<p>17.43. MATTERS OF STYLE
The rest of the “fixes” listed here aren’t really fixes per se. That is, the things they change are matters of style, not substance. They work just as well in Python 3 as they do in Python 2, but the developers of Python have a vested interest in making Python code as uniform as possible. To that end, there is an official</p>

<p>Python
style
guide
which outlines — in excruciating detail — all sorts of nitpicky details that you almost
certainly don’t care about. And given that 2to3 provides such a great infrastructure for converting Python code from one thing to another, the authors took it upon themselves to add a few optional features to improve the readability of your Python programs.</p>

<p>17.43.1. set() LITERALS (EXPLICIT)
In Python 2, the only way to define a literal set in your code was to call set(a_sequence). This still works in Python 3, but a clearer way of doing it is to use the new set literal notation: curly braces. This works for everything except empty sets, because dictionaries also use curly braces, so {} is
an
empty
dictionary,
not
an
empty
set.
. The 2to3 script will not fix set() literals by default. To enable this fix, specify -f
set_literal on the command line when you call 2to3.</p>

<p>17.43.2. buffer() GLOBAL FUNCTION (EXPLICIT)
Python objects implemented in C can export a “buffer interface,” which allows other Python code to directly read and write a block of memory. (That is exactly as powerful and scary as it sounds.) In Python 3, buffer() has been renamed to memoryview(). (It’s a little more complicated than that, but you can almost certainly ignore the differences.)
. The 2to3 script will not fix the buffer() function by default. To enable this fix,
specify -f buffer on the command line when you call 2to3.</p>

<p>17.43.3. WHITESPACE AROUND COMMAS (EXPLICIT)
Despite being draconian about whitespace for indenting and outdenting, Python is actually quite liberal about whitespace in other areas. Within lists, tuples, sets, and dictionaries, whitespace can appear before and after commas with no ill effects. However, the Python style guide states that commas should be preceded by zero spaces and followed by one. Although this is purely an aesthetic issue (the code works either way, in both Python 2 and Python 3), the 2to3 script can optionally fix this for you.
. The 2to3 script will not fix whitespace around commas by default. To enable this fix, specify -f wscomma on the command line when you call 2to3.</p>

<p>17.43.4. COMMON IDIOMS (EXPLICIT)
There were a number of common idioms built up in the Python community. Some, like the while 1: loop, date back to Python 1. (Python didn’t have a true boolean type until version 2.3, so developers used 1 and 0 instead.) Modern Python programmers should train their brains to use modern versions of these idioms instead.
. The 2to3 script will not fix common idioms by default. To enable this fix, specify -f
idioms on the command line when you call 2to3.</p>

<p>while True:</p>

<p>do_stuff()
isinstance(x, T)
isinstance(x, T)
a_list = sorted(a_sequence)
do_stuff(a_list)</p>

<p>while 1:</p>

<p>do_stuff()
type(x) == T
type(x) is T
a_list = list(a_sequence)
a_list.sort()
do_stuff(a_list)</p>

<p>CHAPTER 18. SPECIAL METHOD NAMES</p>

<p>.   My specialty is being right when other people are wrong. .
— George Bernard Shaw
18.1. DIVING IN
Throughout this book, you’ve seen examples of “special methods” — certain “magic” methods that Python invokes when you use certain syntax. Using special methods, your classes can act like sets, like dictionaries, like functions, like iterators, or even like numbers. This appendix serves both as a reference for the special methods we’ve seen already and a brief introduction to some of the more esoteric ones.
18.2. BASICS
If you’ve read the introduction
to
classes, you’ve already seen the most common special method: the <strong>init</strong>() method. The majority of classes I write end up needing some initialization. There are also a few other basic special methods that are especially useful for debugging your custom classes.</p>

<ol>
<li><p>The <strong>init</strong>() method is called after the instance is created. If you want to control the actual creation process, use the
<strong>new</strong>() method.</p></li>

<li><p>By convention, the <strong>repr</strong>() method should return a string that is a valid Python expression.</p></li>

<li><p>The <strong>str</strong>() method is also called when you print(x).</p></li>

<li><p>New in Python 3, since the bytes type was introduced.</p></li>

<li><p>By convention, format_spec should conform to the Format
Specification
Mini-Language. decimal.py in the Python standard library provides its own <strong>format</strong>() method.</p></li>
</ol>

<p>18.3. CLASSES THAT ACT LIKE ITERATORS
In  the
Iterators
chapter, you saw how to build an iterator from the ground up using the <strong>iter</strong>() and
<strong>next</strong>() methods.
Notes You Want…
.  to iterate through a sequence<br />
.  to get the next value from an<br />
iterator<br />
.  to create an iterator in reverse<br />
order</p>

<p>So You Write…
iter(seq)
next(seq)</p>

<p>reversed(seq)</p>

<p>And Python Calls…
seq.<strong>iter</strong>()</p>

<p>seq.<strong>next</strong>()</p>

<p>seq.<strong>reversed</strong>()</p>

<ol>
<li><p>The <strong>iter</strong>() method is called whenever you create a new iterator. It’s a good place to initialize the iterator with initial values.</p></li>

<li><p>The <strong>next</strong>() method is called whenever you retrieve the next value from an iterator.</p></li>

<li><p>The <strong>reversed</strong>() method is uncommon. It takes an existing sequence and returns an iterator that yields the items in the sequence in reverse order, from last to first.</p></li>
</ol>

<p>As you saw in the
Iterators
chapter, a for loop can act on an iterator. In this loop:
for x in seq:
print(x)</p>

<p>Python 3 will call seq.<strong>iter</strong>() to create an iterator, then call the <strong>next</strong>() method on that iterator to get each value of x. When the <strong>next</strong>() method raises a StopIteration exception, the for loop ends gracefully.
18.4. COMPUTED ATTRIBUTES</p>

<ol>
<li><p>If your class defines a <strong>getattribute</strong>() method, Python will call it on every reference to any attribute or method name (except special method names, since that would cause an unpleasant infinite loop).</p></li>

<li><p>If your class defines a <strong>getattr</strong>() method, Python will call it only after looking for the attribute in all the normal places. If an instance x defines an attribute color, x.color will not call x.<strong>getattr</strong>(&lsquo;color&rsquo;); it will simply return the already-defined value of x.color.</p></li>

<li><p>The <strong>setattr</strong>() method is called whenever you assign a value to an attribute.</p></li>

<li><p>The <strong>delattr</strong>() method is called whenever you delete an attribute.</p></li>

<li><p>The <strong>dir</strong>() method is useful if you define a <strong>getattr</strong>() or <strong>getattribute</strong>() method. Normally, calling dir(x) would only list the regular attributes and methods. If your <strong>getattr</strong>() method handles a color attribute dynamically, dir(x) would not list color as one of the available attributes. Overriding the <strong>dir</strong>() method allows you to list color as an available attribute, which is helpful for other people who wish to use your class without digging into the internals of it.</p></li>
</ol>

<p>The distinction between the <strong>getattr</strong>() and <strong>getattribute</strong>() methods is subtle but important. I can explain it with two examples:
class Dynamo:
def <strong>getattr</strong>(self, key):
if key == &lsquo;color&rsquo;: .
return &lsquo;PapayaWhip&rsquo;
else:
raise AttributeError .</p>

<blockquote>
<blockquote>
<blockquote>
<p>dyn = Dynamo()
dyn.color .
&lsquo;PapayaWhip&rsquo;
dyn.color = &lsquo;LemonChiffon&rsquo;
dyn.color .
&lsquo;LemonChiffon&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>The attribute name is passed into the <strong>getattr</strong>() method as a string. If the name is &lsquo;color&rsquo;, the method returns a value. (In this case, it’s just a hard-coded string, but you would normally do some sort of computation and return the result.)</p></li>

<li><p>If the attribute name is unknown, the <strong>getattr</strong>() method needs to raise an AttributeError exception, otherwise your code will silently fail when accessing undefined attributes. (Technically, if the method doesn’t raise an exception or explicitly return a value, it returns None, the Python null value. This means that all attributes not explicitly defined will be None, which is almost certainly not what you want.)</p></li>

<li><p>The dyn instance does not have an attribute named color, so the <strong>getattr</strong>() method is called to provide a computed value.</p></li>

<li><p>After explicitly setting dyn.color, the <strong>getattr</strong>() method will no longer be called to provide a value for dyn.color, because dyn.color is already defined on the instance.</p></li>
</ol>

<p>On the other hand, the <strong>getattribute</strong>() method is absolute and unconditional.
class SuperDynamo:</p>

<p>def <strong>getattribute</strong>(self, key):
if key == &lsquo;color&rsquo;:
return &lsquo;PapayaWhip&rsquo;
else:
raise AttributeError</p>

<blockquote>
<blockquote>
<blockquote>
<p>dyn = SuperDynamo()
dyn.color .
&lsquo;PapayaWhip&rsquo;
dyn.color = &lsquo;LemonChiffon&rsquo;
dyn.color .
&lsquo;PapayaWhip&rsquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ol>
<li><p>The <strong>getattribute</strong>() method is called to provide a value for dyn.color.</p></li>

<li><p>Even after explicitly setting dyn.color, the <strong>getattribute</strong>() method is still called to provide a value for dyn.color. If present, the <strong>getattribute</strong>() method is called unconditionally for every attribute and method lookup, even for attributes that you explicitly set after creating an instance.</p></li>
</ol>

<p>. If your class defines a <strong>getattribute</strong>() method, you probably also want to define a <strong>setattr</strong>() method and coordinate between them to keep track of attribute values. Otherwise, any attributes you set after creating an instance will disappear into a black hole.
You need to be extra careful with the <strong>getattribute</strong>() method, because it is also called when Python looks up a method name on your class.
class Rastan:</p>

<p>def <strong>getattribute</strong>(self, key):
raise AttributeError .
def swim(self):
pass</p>

<blockquote>
<blockquote>
<blockquote>
<p>hero = Rastan()
hero.swim() .</p>
</blockquote>
</blockquote>
</blockquote>

<p>Traceback (most recent call last):
File &ldquo;<stdin>&rdquo;, line 1, in <module>
File &ldquo;<stdin>&rdquo;, line 3, in <strong>getattribute</strong></p>

<p>AttributeError</p>

<ol>
<li><p>This class defines a <strong>getattribute</strong>() method which always raises an AttributeError exception. No attribute or method lookups will succeed.</p></li>

<li><p>When you call hero.swim(), Python looks for a swim() method in the Rastan class. This lookup goes through the <strong>getattribute</strong>() method, because all attribute and method lookups go through the <strong>getattribute</strong>() method. In this case, the <strong>getattribute</strong>() method raises an AttributeError exception, so the method lookup fails, so the method call fails.</p></li>
</ol>

<p>18.5. CLASSES THAT ACT LIKE FUNCTIONS
You can make an instance of a class callable — exactly like a function is callable — by defining the
<strong>call</strong>() method.</p>

<p>The zipfile module
uses this to define a class that can decrypt an encrypted zip file with a given password. The zip decryption algorithm requires you to store state during decryption. Defining the decryptor as a class allows you to maintain this state within a single instance of the decryptor class. The state is initialized in the <strong>init</strong>() method and updated as the file is decrypted. But since the class is also “callable” like a function, you can pass the instance as the first argument of the map() function, like so:</p>

<h1 id="excerpt-from-zipfile-py">excerpt from zipfile.py</h1>

<p>class _ZipDecrypter:</p>

<pre><code>def __init__(self, pwd): 
    self.key0 = 305419896 . 
    self.key1 = 591751049 
    self.key2 = 878082192 
    for p in pwd: 
        self._UpdateKeys(p) 

def __call__(self, c): . 
    assert isinstance(c, int) 
    k = self.key2 | 2 
    c = c ^ (((k * (k^1)) &gt;&gt; 8) &amp; 255) 
    self._UpdateKeys(c) 
    return c 
</code></pre>

<p>.
zd = _ZipDecrypter(pwd) .
bytes = zef_file.read(12)
h = list(map(zd, bytes[0:12])) .</p>

<ol>
<li><p>The _ZipDecryptor class maintains state in the form of three rotating keys, which are later updated in the _UpdateKeys() method (not shown here).</p></li>

<li><p>The class defines a <strong>call</strong>() method, which makes class instances callable like functions. In this case, the <strong>call</strong>() method decrypts a single byte of the zip file, then updates the rotating keys based on the byte that was decrypted.</p></li>

<li><p>zd is an instance of the _ZipDecryptor class. The pwd variable is passed to the <strong>init</strong>() method, where it is stored and used to update the rotating keys for the first time.</p></li>

<li><p>Given the first 12 bytes of a zip file, decrypt them by mapping the bytes to zd, in effect “calling” zd 12 times, which invokes the <strong>call</strong>() method 12 times, which updates its internal state and returns a resulting byte 12 times.</p></li>
</ol>

<p>18.6. CLASSES THAT ACT LIKE SETS
If your class acts as a container for a set of values — that is, if it makes sense to ask whether your class “contains” a value — then it should probably define the following special methods that make it act like a set.</p>

<p>The cgi module
uses these methods in its FieldStorage class, which represents all of the form fields or query parameters submitted to a dynamic web page.</p>

<h1 id="a-script-which-responds-to-http-example-com-search-q-cgi">A script which responds to <a href="http://example.com/search?q=cgi">http://example.com/search?q=cgi</a></h1>

<p>import cgi
fs = cgi.FieldStorage()
if &lsquo;q&rsquo; in fs: .</p>

<p>do_search()</p>

<h1 id="an-excerpt-from-cgi-py-that-explains-how-that-works">An excerpt from cgi.py that explains how that works</h1>

<p>class FieldStorage:
.
.
.</p>

<p>def <strong>contains</strong>(self, key): .
if self.list is None:
raise TypeError(&lsquo;not indexable&rsquo;)
return any(item.name == key for item in self.list) .</p>

<p>def <strong>len</strong>(self): .
return len(self.keys()) .</p>

<ol>
<li><p>Once you create an instance of the cgi.FieldStorage class, you can use the “in” operator to check whether a particular parameter was included in the query string.</p></li>

<li><p>The <strong>contains</strong>() method is the magic that makes this work.</p></li>

<li><p>When you say if &lsquo;q&rsquo; in fs, Python looks for the <strong>contains</strong>() method on the fs object, which is defined in cgi.py. The value &lsquo;q&rsquo; is passed into the <strong>contains</strong>() method as the key argument.</p></li>

<li><p>The same FieldStorage class also supports returning its length, so you can say len(fs) and it will call the <strong>len</strong>() method on the FieldStorage class to return the number of query parameters that it identified.</p></li>

<li><p>The self.keys() method checks whether self.list is None, so the <strong>len</strong> method doesn’t need to duplicate this error checking.</p></li>
</ol>

<p>18.7. CLASSES THAT ACT LIKE DICTIONARIES
Extending the previous section a bit, you can define classes that not only respond to the “in” operator and the len() function, but they act like full-blown dictionaries, returning values based on keys.</p>

<p>The FieldStorage class
from the cgi module
also defines these special methods, which means you can do things like this:</p>

<h1 id="a-script-which-responds-to-http-example-com-search-q-cgi-1">A script which responds to <a href="http://example.com/search?q=cgi">http://example.com/search?q=cgi</a></h1>

<p>import cgi
fs = cgi.FieldStorage()
if &lsquo;q&rsquo; in fs:</p>

<p>do_search(fs[&lsquo;q&rsquo;]) .</p>

<h1 id="an-excerpt-from-cgi-py-that-shows-how-it-works">An excerpt from cgi.py that shows how it works</h1>

<p>class FieldStorage:
.
.
.</p>

<p>def <strong>getitem</strong>(self, key): .
if self.list is None:</p>

<p>raise TypeError(&lsquo;not indexable&rsquo;)
found = []
for item in self.list:</p>

<p>if item.name == key: found.append(item)
if not found:
raise KeyError(key)
if len(found) == 1:
return found[0]
else:
return found</p>

<ol>
<li><p>The fs object is an instance of cgi.FieldStorage, but you can still evaluate expressions like fs[&lsquo;q&rsquo;].</p></li>

<li><p>fs[&lsquo;q&rsquo;] invokes the <strong>getitem</strong>() method with the key parameter set to &lsquo;q&rsquo;. It then looks up in its internally maintained list of query parameters (self.list) for an item whose .name matches the given key.</p></li>
</ol>

<p>18.8. CLASSES THAT ACT LIKE NUMBERS
Using the appropriate special methods, you can define your own classes that act like numbers. That is, you can add them, subtract them, and perform other mathematical operations on them. This is how fractions are implemented — the Fraction class implements these special methods, then you can do things like this:
&gt;&gt;&gt; from fractions import Fraction
&gt;&gt;&gt; x = Fraction(1, 3)
&gt;&gt;&gt; x / 3
Fraction(1, 9)</p>

<p>Here is the comprehensive list of special methods you need to implement a number-like class.
Notes You Want…
addition subtraction multiplication division floor division modulo (remainder) floor division &amp;modulo raise to power left bit-shift right bit-shift bitwise and bitwise xor bitwise or</p>

<p>So You Write… And Python Calls…</p>

<pre><code class="language-python">x+y 
x.__add__(y) 



x-y 
x.__sub__(y) 



x*y 
x.__mul__(y) 



x/y 
x.__truediv__(y) 



x // y 
x.__floordiv__(y) 



x%y 
x.__mod__(y) 



divmod(x, y) 
x.__divmod__(y) 



x ** y 
x.__pow__(y) 



x &lt;&lt; y 
x.__lshift__(y) 



x &gt;&gt; y 
x.__rshift__(y) 



x&amp;y 
x.__and__(y) 



x^y 
x.__xor__(y) 



x|y 
x.__or__(y) 
</code></pre>

<p>That’s all well and good if x is an instance of a class that implements those methods. But what if it doesn’t implement one of them? Or worse, what if it implements it, but it can’t handle certain kinds of arguments? For example:
&gt;&gt;&gt; from fractions import Fraction
&gt;&gt;&gt; x = Fraction(1, 3)
&gt;&gt;&gt; 1 / x
Fraction(3, 1)</p>

<p>This is not a case of taking a Fraction and dividing it by an integer (as in the previous example). That case was straightforward: x/3 calls x.<strong>truediv</strong>(3), and the <strong>truediv</strong>() method of the Fraction class handles all the math. But integers don’t “know” how to do arithmetic operations with fractions. So why does this example work?
There is a second set of arithmetic special methods with reflected operands. Given an arithmetic operation that takes two operands (e.g. x/y), there are two ways to go about it:
1. Tell x to divide itself by y, or</p>

<ol>
<li>Tell y to divide itself into x</li>
</ol>

<p>The set of special methods above take the first approach: given x/y, they provide a way for x to say “I know how to divide myself by y.” The following set of special methods tackle the second approach: they provide a way for y to say “I know how to be the denominator and divide myself into x.”</p>

<p>But wait! There’s more! If you’re doing “in-place” operations, like x /= 3, there are even more special methods you can define.</p>

<p>Note: for the most part, the in-place operation methods are not required. If you don’t define an in-place method for a particular operation, Python will try the methods. For example, to execute the expression x /= y, Python will:
1.  Try calling x.<strong>itruediv</strong>(y). If this method is defined and returns a value other than NotImplemented, we’re done.</p>

<ol>
<li><p>Try calling x.<strong>truediv</strong>(y). If this method is defined and returns a value other than NotImplemented, the old value of x is discarded and replaced with the return value, just as if you had done x=x/y instead.</p></li>

<li><p>Try calling y.<strong>rtruediv</strong>(x). If this method is defined and returns a value other than NotImplemented, the old value of x is discarded and replaced with the return value.</p></li>
</ol>

<p>So you only need to define in-place methods like the <strong>itruediv</strong>() method if you want to do some special optimization for in-place operands. Otherwise Python will essentially reformulate the in-place operand to use a regular operand + a variable assignment.
There are also a few “unary” mathematical operations you can perform on number-like objects by themselves.</p>

<p>18.9. CLASSES THAT CAN BE COMPARED
I broke this section out from the previous one because comparisons are not strictly the purview of numbers. Many datatypes can be compared — strings, lists, even dictionaries. If you’re creating your own class and it makes sense to compare your objects to other objects, you can use the following special methods to implement comparisons.</p>

<p>. If you define a <strong>lt</strong>() method but no <strong>gt</strong>() method, Python will use the <strong>lt</strong>() method with operands swapped. However, Python will not combine methods. For example, if you define a <strong>lt</strong>() method and a <strong>eq</strong>() method and try to test whether x &lt;= y, Python will not call <strong>lt</strong>() and <strong>eq</strong>() in sequence. It will only call the <strong>le</strong>() method.
18.10. CLASSES THAT CAN BE SERIALIZED
Python supports serializing
and
unserializing
arbitrary
objects. (Most Python references call this process “pickling” and “unpickling.”) This can be useful for saving state to a file and restoring it later. All of the native
datatypes
support pickling already. If you create a custom class that you want to be able to pickle, read up on the
pickle
protocol
to see when and how the following special methods are called.</p>

<ul>
<li>To recreate a serialized object, Python needs to create a new object that looks like the serialized object, then set the values of all the attributes on the new object. The <strong>getnewargs</strong>() method controls how the object is created, then the <strong>setstate</strong>() method controls how the attribute values are restored.
18.11. CLASSES THAT CAN BE USED IN A with BLOCK
A with block defines a runtime
context; you “enter” the context when you execute the with statement, and you “exit” the context after you execute the last statement in the block.</li>
</ul>

<p>This is how the with file idiom
works.</p>

<h1 id="excerpt-from-io-py">excerpt from io.py:</h1>

<p>def _checkClosed(self, msg=None):
&ldquo;&lsquo;Internal: raise an ValueError if file is closed
&ldquo;&rsquo;
if self.closed:</p>

<p>raise ValueError(&lsquo;I/O operation on closed file.&rsquo;
if msg is None else msg)</p>

<p>def <strong>enter</strong>(self):<br />
&rdquo;&lsquo;Context management protocol.  Returns self.&ldquo;&rsquo;<br />
self._checkClosed()  .<br />
return self  .<br />
def <strong>exit</strong>(self, *args):<br />
&rdquo;&lsquo;Context management protocol.  Calls close()&ldquo;&rsquo;<br />
self.close()  .</p>

<ol>
<li><p>The file object defines both an <strong>enter</strong>() and an <strong>exit</strong>() method. The <strong>enter</strong>() method checks that the file is open; if it’s not, the _checkClosed() method raises an exception.</p></li>

<li><p>The <strong>enter</strong>() method should almost always return self — this is the object that the with block will use to dispatch properties and methods.</p></li>

<li><p>After the with block, the file object automatically closes. How? In the <strong>exit</strong>() method, it calls self.close().</p></li>
</ol>

<p>. The <strong>exit</strong>() method will always be called, even if an exception is raised inside the with block. In fact, if an exception is raised, the exception information will be passed to the <strong>exit</strong>() method. See With
Statement
Context
Managers
for more details.
For more on context managers, see Closing
Files
Automatically
and Redirecting
Standard
Output.
18.12. REALLY ESOTERIC STUFF</p>

<p>If you know what you’re doing, you can gain almost complete control over how classes are compared, how attributes are defined, and what kinds of classes are considered subclasses of your class.</p>

<ul>
<li>Exactly when Python calls the <strong>del</strong>() special method is
incredibly
complicated. To fully understand it, you need to know how Python
keeps
track
of
objects
in
memory. Here’s a good article on Python
garbage
collection
and
class
destructors. You should also read about weak
references, the weakref module, and probably the gc module
for good measure.
18.13. FURTHER READING
Modules mentioned in this appendix:
• zipfile module</li>
</ul>

<p>• cgi module</p>

<p>• collections module</p>

<p>• math module</p>

<p>• pickle module</p>

<p>• copy module</p>

<p>• abc (“Abstract
Base
Classes”)
module</p>

<p>Other light reading:</p>

<p>• Format
Specification
Mini-Language</p>

<p>• Python
data
model</p>

<p>• Built-in
types</p>

<p>• PEP
357:
Allowing
Any
Object
to
be
Used
for
Slicing</p>

<p>• PEP
3119:
Introducing
Abstract
Base
Classes</p>

<p>CHAPTER 19. WHERE TO GO FROM HERE</p>

<p>. Go forth on your path, as it exists only through your walking. .
— St. Augustine of Hippo (attributed)
19.1. THINGS TO READ
Unfortunately, I can not write cover every facet of Python 3 in this book. Fortunately, there are many wonderful, freely available tutorials available elsewhere.
Decorators:
• Function
Decorators
by Ariel Ortiz</p>

<p>• More
on
Function
Decorators
by Ariel Ortiz</p>

<p>• Charming
Python:
Decorators
make
magic
easy
by David Mertz</p>

<p>• Function
Definitions
in the official Python documentation</p>

<p>Properties:</p>

<p>• The
Python
property builtin
by Adam Gomaa</p>

<p>• Getters/Setters/Fuxors
by Ryan Tomayko</p>

<p>• property() function
in the official Python documentation</p>

<p>• How-To
Guide
For
Descriptors
by Raymond Hettinger</p>

<p>• Charming
Python:
Python
elegance
and
warts,
Part
2
by David Mertz</p>

<p>• Python
Descriptors
by Mark Summerfield</p>

<p>• Invoking
Descriptors
in the official Python documentation</p>

<p>Descriptors: Threading &amp;multiprocessing:
• threading module</p>

<p>• threading —
Manage
concurrent
threads</p>

<p>• multiprocessing module</p>

<p>• multiprocessing —
Manage
processes
like
threads</p>

<p>• Python
threads
and
the
Global
Interpreter
Lock
by Jesse Noller</p>

<p>• Inside
the
Python
GIL
(video)
by David Beazley</p>

<p>Metaclasses:
• Metaclass
programming
in
Python
by David Mertz and Michele Simionato</p>

<p>• Metaclass
programming
in
Python,
Part
2
by David Mertz and Michele Simionato</p>

<p>• Metaclass
programming
in
Python,
Part
3
by David Mertz and Michele Simionato</p>

<p>In addition, Doug Hellman’s Python
Module
of
the
Week
is a fantastic guide to many of the modules in the Python standard library.
19.2. WHERE TO LOOK FOR PYTHON 3-COMPATIBLE CODE
As Python 3 is relatively new, there is a dearth of compatible libraries. Here are some of the places to look for code that works with Python 3.
• Python
Package
Index:
list
of
Python
3
packages</p>

<p>• Python
Cookbook: list of recipes tagged “python3”</p>

<p>• Google
Project Hosting: list of projects tagged “python3”</p>

<p>• SourceForge:
list of projects matching “Python 3”</p>

<p>• GitHub:
list of projects matching “python3” (also, list of projects matching “python 3”)</p>

<p>• BitBucket:
list of projects matching “python3” (and those matching “python 3”)</p>

<p>CHAPTER 20. TROUBLESHOOTING</p>

<p>. Where’s the ANY key? .
— variously attributed</p>

<p>20.1. DIVING IN FIXME
20.2. GETTING TO THE COMMAND LINE
Throughout this book, there are examples of executing Python programs from the command line. Where is the command line?
On Linux, look in your Applications menu for a program called Terminal. (It may be in a submenu like Accessories or System.)
On Mac OS X, there is an application called Terminal in your /Applications/Utilities/ folder. To get there, click on your desktop, open the Go menu, select Go to folder&hellip;, and type /Applications/ Utilities/. Then double-click the Terminal program.
On Windows, click Start, select Run&hellip;, type cmd, and press ENTER.
20.3. RUNNING PYTHON ON THE COMMAND LINE
Once you get
to
the
command
line, you should be able to run the Python interactive shell. On the Linux or Mac OS X command line, type python3 and press ENTER. On the Windows command line, type c:\python31\python and press ENTER. If all goes well, you should see something like this:
you@localhost:~$ python3</p>

<p>Python 3.1 (r31:73572, Jul 28 2009, 06:52:23)
[GCC 4.2.4 (Ubuntu 4.2.4-1ubuntu4)] on linux2
Type &ldquo;help&rdquo;, &ldquo;copyright&rdquo;, &ldquo;credits&rdquo; or &ldquo;license&rdquo; for more information.
&gt;&gt;&gt;</p>

<p>(Type exit() and press ENTER to exit the Python interactive shell and go back to the command line. This works on all platforms.)
If you get a “command not found” error, it probably means you don’t
have
Python
3
installed.
you@localhost:~$ python3
bash: python3: command not found</p>

<p>On the other hand, if you get into a Python interactive shell but the version number is not what you expected, you may have more than one version of Python installed. This happens most often on Linux and Mac OS X systems, where an older version of Python is pre-installed. You can install the latest version without deleting the older version (they will live side-by-side in peace), but you will need to be more specific when you run Python from the command line.
For example, on my home Linux box, I have several versions of Python installed so I can test the Python software that I write. To run a specific version, I can type python3.0, python3.1, or python2.6.
mark@atlantis:~$ python3.0
Python 3.0.1+ (r301:69556, Apr 15 2009, 17:25:52)
[GCC 4.3.3] on linux2
Type &ldquo;help&rdquo;, &ldquo;copyright&rdquo;, &ldquo;credits&rdquo; or &ldquo;license&rdquo; for more information.
&gt;&gt;&gt; exit()
mark@atlantis:~$ python3.1
Python 3.1 (r31:73572, Jul 28 2009, 06:52:23)
[GCC 4.2.4 (Ubuntu 4.2.4-1ubuntu4)] on linux2
Type &ldquo;help&rdquo;, &ldquo;copyright&rdquo;, &ldquo;credits&rdquo; or &ldquo;license&rdquo; for more information.
&gt;&gt;&gt; exit()
mark@atlantis:~$ python2.6
Python 2.6.5 (r265:79063, Apr 16 2010, 13:57:41)
[GCC 4.4.3] on linux2
Type &ldquo;help&rdquo;, &ldquo;copyright&rdquo;, &ldquo;credits&rdquo; or &ldquo;license&rdquo; for more information.
&gt;&gt;&gt; exit()</p>

<p>© 2001–9 Mark
Pilgrim</p>

				</section>
			</article>
		</main>
	</div> 

	

<div class="col-sm-3 col-sm-offset-1 doc-sidebar">
	<div id="sidebar">
	<div class="sidebar-module">
		<div class="sidebar-toc">
			<h4 class="sidebar-heading">Table of Contents</h4>
			<ul>
				<li><strong><a href="#title">DIP3 Notes</a></strong></li>
			</ul>
			<nav id="TableOfContents">
<ul>
<li><a href="#do-something">do something</a></li>
<li><a href="#continue-anyway">continue anyway</a></li>
<li><a href="#continued-from-the-previous-example">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-1">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-2">continued from the previous example</a></li>
<li><a href="#coding-windows-1252">-*- coding: windows-1252 -*­</a></li>
<li><a href="#coding-windows-1252-1">-*- coding: windows-1252 -*­</a></li>
<li><a href="#or-500-800-d-followed-by-0-to-3-cs">or 500-800 (D, followed by 0 to 3 Cs)</a></li>
<li><a href="#or-50-80-l-followed-by-0-to-3-xs">or 50-80 (L, followed by 0 to 3 Xs)</a></li>
<li><a href="#or-5-8-v-followed-by-0-to-3-is">or 5-8 (V, followed by 0 to 3 Is)</a></li>
<li><a href="#don-t-match-beginning-of-string-number-can-start-anywhere">don&rsquo;t match beginning of string, number can start anywhere</a></li>
<li><a href="#roman1-py">roman1.py</a></li>
<li><a href="#roman4-py">roman4.py</a></li>
<li><a href="#e-e">E.E&hellip;.</a></li>
<li><a href="#roman5-py">roman5.py</a></li>
<li><a href="#f-f">F.F&hellip;.</a></li>
<li><a href="#roman6-py">roman6.py</a></li>
<li><a href="#fff">FFF&hellip;&hellip;.</a></li>
<li><a href="#or-500-800-d-followed-by-0-to-3-cs-1">or 500-800 (D, followed by 0 to 3 Cs)</a></li>
<li><a href="#or-50-80-l-followed-by-0-to-3-xs-1">or 50-80 (L, followed by 0 to 3 Xs)</a></li>
<li><a href="#or-5-8-v-followed-by-0-to-3-is-1">or 5-8 (V, followed by 0 to 3 Is)</a></li>
<li><a href="#or-500-800-d-followed-by-0-to-3-cs-2">or 500-800 (D, followed by 0 to 3 Cs)</a></li>
<li><a href="#or-50-80-l-followed-by-0-to-3-xs-2">or 50-80 (L, followed by 0 to 3 Xs)</a></li>
<li><a href="#or-5-8-v-followed-by-0-to-3-is-2">or 5-8 (V, followed by 0 to 3 Is)</a></li>
<li><a href="#this-example-was-created-on-windows-other-platforms-may">This example was created on Windows. Other platforms may</a></li>
<li><a href="#behave-differently-for-reasons-outlined-below">behave differently, for reasons outlined below.</a></li>
<li><a href="#continued-from-the-previous-example-3">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-4">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-5">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-6">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-7">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-8">continued from the previous example</a></li>
<li><a href="#continuing-from-the-previous-example">continuing from the previous example</a></li>
<li><a href="#add-this-to-customserializer-py">add this to customserializer.py</a></li>
<li><a href="#continued-from-previous-example">continued from previous example</a></li>
<li><a href="#continued-from-the-previous-example-9">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-10">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-11">continued from the previous example</a></li>
<li><a href="#not-continued-from-previous-example">NOT continued from previous example!</a></li>
<li><a href="#please-exit-out-of-the-interactive-shell">Please exit out of the interactive shell</a></li>
<li><a href="#and-launch-a-new-one">and launch a new one.</a></li>
<li><a href="#continued-from-the-previous-example-12">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-13">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-14">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-15">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-16">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-17">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-18">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-19">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-20">continued from the previous example</a></li>
<li><a href="#continued-from-the-previous-example-21">continued from the previous example</a></li>
<li><a href="#02110-1301-usa">02110-1301 USA</a></li>
<li><a href="#02110-1301-usa-1">02110-1301 USA</a></li>
<li><a href="#codingstatemachine-py">codingstatemachine.py</a></li>
<li><a href="#for-each-byte-we-get-its-class">for each byte we get its class</a></li>
<li><a href="#if-it-is-first-byte-we-also-get-byte-length">if it is first byte, we also get byte length</a></li>
<li><a href="#utf8prober-py">utf8prober.py</a></li>
<li><a href="#for-each-byte-we-get-its-class-1">for each byte we get its class</a></li>
<li><a href="#if-it-is-first-byte-we-also-get-byte-length-1">if it is first byte, we also get byte length</a></li>
<li><a href="#sbcharsetprober-py">sbcharsetprober.py</a></li>
<li><a href="#latin1prober-py">latin1prober.py</a></li>
<li><a href="#sbcharsetprober-py-1">sbcharsetprober.py</a></li>
<li><a href="#latin1prober-py-1">latin1prober.py</a></li>
<li><a href="#find-out-current-char-s-byte-length">find out current char&rsquo;s byte length</a></li>
<li><a href="#find-out-current-char-s-byte-length-1">find out current char&rsquo;s byte length</a></li>
<li><a href="#return-its-order-if-it-is-hiragana">return its order if it is hiragana</a></li>
<li><a href="#find-out-current-char-s-byte-length-2">find out current char&rsquo;s byte length</a></li>
<li><a href="#return-its-order-if-it-is-hiragana-1">return its order if it is hiragana</a></li>
<li><a href="#chardet-s-setup-py">chardet&rsquo;s setup.py</a></li>
<li><a href="#excerpt-from-zipfile-py">excerpt from zipfile.py</a></li>
<li><a href="#a-script-which-responds-to-http-example-com-search-q-cgi">A script which responds to <a href="http://example.com/search?q=cgi">http://example.com/search?q=cgi</a></a></li>
<li><a href="#an-excerpt-from-cgi-py-that-explains-how-that-works">An excerpt from cgi.py that explains how that works</a></li>
<li><a href="#a-script-which-responds-to-http-example-com-search-q-cgi-1">A script which responds to <a href="http://example.com/search?q=cgi">http://example.com/search?q=cgi</a></a></li>
<li><a href="#an-excerpt-from-cgi-py-that-shows-how-it-works">An excerpt from cgi.py that shows how it works</a></li>
<li><a href="#excerpt-from-io-py">excerpt from io.py:</a></li>
</ul>
</nav>
		</div>
	</div>
	<div class="sidebar-module">
		<h4 class="sidebar-heading">Pages in Categories</h4>
		<ul class="sidebar-category-list">
		
			<li>
				<a href="https://harryho.github.io/categories/code">
					<span class="doc-list-category">Code</span>
				</a>
				<ul>
					<li><a href="/code/lcthw-lectures.4/">LCTHW C Lectures 4</a>
					</li>
				
					<li><a href="/code/lcthw-lectures.1/">LCTHW Lectures 1</a>
					</li>
				
					<li><a href="/code/lcthw-lectures.2/">LCTHW Lectures 2</a>
					</li>
				
					<li><a href="/code/lcthw-lectures.3/">LCTHW Lectures 3</a>
					</li>
				
					<li><a href="/code/csharp-notes-1/">C# Notes -- Part 1</a>
					</li>
				
					<li><a href="/code/csharp-notes-2/">C# Notes -- Part 2</a>
					</li>
				
					<li><a href="/code/javascript-oop/">JavaScript and Object Oriented Programming</a>
					</li>
				
					<li><a href="/code/java-notes-1/">Java Notes, Part-1</a>
					</li>
				
					<li><a href="/code/java-notes-2/">Java Notes, Part-2</a>
					</li>
				
					<li><a href="/code/java-notes-3/">Java Notes, Part-3</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/dev">
					<span class="doc-list-category">Dev</span>
				</a>
				<ul>
					<li><a href="/dev/php-web/">PHP web framework</a>
					</li>
				
					<li><a href="/dev/build-mobile-app/">Build mobile app with web dev skills</a>
					</li>
				
					<li><a href="/dev/python-django/">Python Web framework</a>
					</li>
				
					<li><a href="/dev/php-debug/">Debug PHP with Eclipse PDT and Netbeans</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/info">
					<span class="doc-list-category">Info</span>
				</a>
				<ul>
					<li><a href="/info/create-a-blog-on-github-pages/">Create a blog site on GitHub Pages</a>
					</li>
				
					<li><a href="/info/jira-notes/">JIRA Notes</a>
					</li>
				
					<li><a href="/info/linux-history/">Brief history of Linux</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/os">
					<span class="doc-list-category">Os</span>
				</a>
				<ul>
					<li><a href="/os/linux-notes/">Linux notes</a>
					</li>
				
					<li><a href="/os/ubuntu-server-14/">Ubuntu 14 -- server setup</a>
					</li>
				
					<li><a href="/os/ubuntu-desktop-14/">Ubuntu 14 -- desktop setup &amp; dual boot </a>
					</li>
				
					<li><a href="/os/use-windows-command-hotkey-as-hacker-2/">Use Windows command &amp; hotkey as a hacker - Part 2</a>
					</li>
				
					<li><a href="/os/use-windows-command-hotkey-as-hacker-1/">Use Windows command &amp; hotkey as a hacker - Part 1</a>
					</li>
				
					<li><a href="/os/centos-fedora-desktop/">CentOS 6/7 -- desktop Setup</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/project">
					<span class="doc-list-category">Project</span>
				</a>
				<ul>
					<li><a href="/project/laravel-mvc-starter/">Laravel MVC Starter</a>
					</li>
				
					<li><a href="/project/reetek-vue2-admin/">Reetek Vue 2 Admin Project</a>
					</li>
				
					<li><a href="/project/angularjs-webpack-es6-starter/">Angularjs Webpack ES6 Starter</a>
					</li>
				
					<li><a href="/project/zf2-mvc-starter/">Zendframework 2 MVC Starter</a>
					</li>
				
				</ul>
			</li>
		
		</ul>
	</div>
	<div class="sidebar-module">
		<h4 class="sidebar-heading">Tags</h4>
		<div class="tag-box">
		
			<a class="tag-item" href="https://harryho.github.io/tags/agile">agile</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/angularjs">angularjs</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/c">c</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/centos">centos</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/cmd">cmd</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/git">git</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/hugo">hugo</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/java">java</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/javascript">javascript</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/linux">linux</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/mobile">mobile</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/oo">oo</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/php">php</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/python">python</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/ubuntu">ubuntu</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/webpack">webpack</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/windows">windows</a>
		
		</div>
	</div>
	</div>
</div>

</div> 
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'harryho';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<hr />

<div class="row">
	<div class="col-sm-8">
		<p class="doc-footer-em"><a href="#" onclick="resetSidebarPos()">Back to TOP</a></p>
	</div>
</div>

</div> 

<footer class="doc-footer">
	<p class="doc-footer-em">Browse <strong><a href="https://github.com/harryho/harryho.github.io.git">Repository</a></strong></p>
	<p>Copyright (c) 2015, harryho; All rights reserved.</p>
	<p>Powered by <strong><a href="https://github.com/key-amb/hugo-theme-bootie-docs">Bootie Docs</a></strong> - theme for <a href="http://gohugo.io/">Hugo</a> by <a href="https://github.com/key-amb/">key-amb</a>.</p>
</footer>



<script src="https://harryho.github.io/js/jquery.min.js"></script>
<script src="https://harryho.github.io/js/bootstrap.min.js"></script>

<script src="https://harryho.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://harryho.github.io/js/ie10-viewport-bug-workaround.js"></script>
<script src="https://harryho.github.io/js/bootie-docs.js"></script>
<script>
	console.log( hljs.listLanguages());
</script>
<script id="dsq-count-scr" src="//harryho.disqus.com/count.js" async></script>


</body>
</html>
