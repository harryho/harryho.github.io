<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Hello World</title>
    <link>https://harryho.github.io/tags/java/</link>
    <description>Recent content in Java on Hello World</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2015, harryho; All rights reserved.</copyright>
    <lastBuildDate>Tue, 10 Feb 2015 14:59:31 +1100</lastBuildDate>
    
	<atom:link href="https://harryho.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java Notes - Part 3: Date Time API </title>
      <link>https://harryho.github.io/code/java-notes-3/</link>
      <pubDate>Tue, 10 Feb 2015 14:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/code/java-notes-3/</guid>
      <description>Date-Time API Through the java.time packages, Java 8 provides a comprehensive Date-Time API to work with date, time, and datetime. By default, most of the classes are based on the ISO-8601 standards. The main classes are
 Instant  represents an instant on the timeline and it is suitable for machines, for example, as timestamps for event  LocalDate, LocalTime, LocalDateTime
 represents human readable date, time, and datetime without a time zone.</description>
    </item>
    
    <item>
      <title>Java Notes - Part 4: Lambda API </title>
      <link>https://harryho.github.io/code/java-notes-4/</link>
      <pubDate>Tue, 10 Feb 2015 14:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/code/java-notes-4/</guid>
      <description>Lamda Lambda Best Practices Use Interfaces The most common misstep taken by an over-eager functional programmer is the use of functional interfaces in type signatures. In general, you should avoid using the functional interface types directly and instead provide single-method interfaces as arguments to your methods. These interfaces become a way to create self-documenting code and to provide meaningful type information, as well as leaving open the opportunity for your user to provide an actual Java type.</description>
    </item>
    
    <item>
      <title>Java Notes - Part 2: Currency</title>
      <link>https://harryho.github.io/code/java-notes-2/</link>
      <pubDate>Mon, 08 Jul 2013 14:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/code/java-notes-2/</guid>
      <description>Thread Join  The join method allows one thread to wait for the completion of another. join responds to an interrupt by exiting with an InterruptedException.
 Demo code of thread join
  public class JoinDemo implements Runnable { private Random rand = new Random(System.currentTimeMillis()); public void run() { //simulate some CPU expensive task for (int i = 0; i &amp;lt; 100000000; i++) { rand.nextInt(); } System.out.println(&amp;quot;[&amp;quot; + Thread.</description>
    </item>
    
    <item>
      <title>Java Notes - Part 1</title>
      <link>https://harryho.github.io/code/java-notes-1/</link>
      <pubDate>Sat, 10 Dec 2011 14:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/code/java-notes-1/</guid>
      <description>Prelude  Java notes is the place, which I keep the good practice and solution from my projects and research.
 Refactor constant variables with Enum Enum was a great improvement in Java 1.5. From that more and more developer abandom the interface or abstract class as constant variable container.
Before Java 1.5 you will following coding in many Java program.
// Use interface or abstract class as constant variable container public interface Country { public static final String AU = &amp;quot;Australian&amp;quot;; public static final String UK = &amp;quot;United Kingdom&amp;quot;; public static final String US = &amp;quot;United State&amp;quot;; } public class Util { public static String getLanguageCode(String country) { String languageCode = &amp;quot;en&amp;quot;; switch (country) { case Country.</description>
    </item>
    
  </channel>
</rss>