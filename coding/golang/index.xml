<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Hello World</title>
    <link>/coding/golang/</link>
    <description>Recent content in Golang on Hello World</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/coding/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang Note - 1</title>
      <link>/coding/golang/go-note-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-1/</guid>
      <description>Go Introduction  Golang&amp;rsquo;s popularity is skyrocketing. The thriving of Docker and Kubernetes push the Golang to a higher level.
Go is easy to become functional with and appropriate for junior developers to work on. Also, having a language that encourages readability and comprehension is extremely useful. The mixture of duck typing (via interfaces) and convenience features such as &amp;ldquo;:=&amp;rdquo; for short variable declarations give Go the feel of a dynamically typed language while retaining the positives of a strongly typed one.</description>
    </item>
    
    <item>
      <title>Golang Note - 2</title>
      <link>/coding/golang/go-note-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-2/</guid>
      <description>Map  Maps are a special kind of data structure: an unordered collection of pairs of items, where one element of the pair is the key, and the other element, associated with the key, is the data or the value, hence they are also called associative arrays or dictionaries.
 The key type can be any type for which the operations == and != are defined, like string, int, float.</description>
    </item>
    
    <item>
      <title>Golang Note - 3</title>
      <link>/coding/golang/go-note-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-3/</guid>
      <description>Struct  Go supports user-defined or custom types in the form of alias types or structs. A struct tries to represent a real-world entity with its properties. Structs are composite types, to use when you want to define a type which consist of a number of properties, each having their own type and value, grouping pieces of data together.
 Struct with tags  A field in a struct can, apart from a name and a type, also optionally have a tag: this is a string attached to the field, which could be documentation or some other important label.</description>
    </item>
    
    <item>
      <title>Golang Note - 4</title>
      <link>/coding/golang/go-note-4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-4/</guid>
      <description>IO - Read &amp;amp; Write Read from user input var ( firstName, lastName, s string i int f float32 input = &amp;quot;56.12 / 5212 / Go&amp;quot; format = &amp;quot;%f / %d / %s&amp;quot; ) func main() { fmt.Println(&amp;quot;Please enter your full name: &amp;quot;) fmt.Scanln(&amp;amp;firstName, &amp;amp;lastName) // fmt.Scanf(&amp;quot;%s %s&amp;quot;, &amp;amp;firstName, &amp;amp;lastName) fmt.Printf(&amp;quot;Hi %s %s!\n&amp;quot;, firstName, lastName) // Hi Chris Naegels fmt.Sscanf(input, format, &amp;amp;f, &amp;amp;i, &amp;amp;s) fmt.Println(&amp;quot;From the string we read: &amp;quot;, f, i, s) // ouwtput: From the string we read: 56.</description>
    </item>
    
    <item>
      <title>Golang Note - 5</title>
      <link>/coding/golang/go-note-5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-5/</guid>
      <description>Error handling  Go does not have an exception mechanism, like the try/catch in Java or .NET for instance: you cannot throw exceptions. Instead it has a defer-panic-and-recover mechanism.
 The Go way to handle errors is for functions and methods to return an error object as their only or last return value—or nil if no error occurred—and for calling functions to always check the error they receive.
 Handle the errors and return from the function in which the error occurred with an error message to the user: that way if something does go wrong, your program will continue to function and the user will be notified.</description>
    </item>
    
    <item>
      <title>Golang Note - 6</title>
      <link>/coding/golang/go-note-6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-6/</guid>
      <description>Goroutine  A goroutine is implemented as a function or method (this can also be an anonymous or lambda function) and called (invoked) with the keyword go. This starts the function running in parallel with the current computation but in the same address space and with its own stack.
 Go’s concurrency primitives provide the basis for a good concurrency program design: expressing program structure so as to represent independently executing actions; so Go’s emphasis is not in the 1 st place on parallelism: concurrent programs may or may not be parallel.</description>
    </item>
    
    <item>
      <title>Golang snippets</title>
      <link>/coding/golang/go-note-99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-99/</guid>
      <description>Convenient logging methods Stringer package main import ( &amp;quot;fmt&amp;quot; ) // Animal has a Name and an Age to represent an animal. type Animal struct { Name string Age uint } // String makes Animal satisfy the Stringer interface. func (a Animal) String() string { return fmt.Sprintf(&amp;quot;%v (%d)&amp;quot;, a.Name, a.Age) } func main() { a := Animal{ Name: &amp;quot;Gopher&amp;quot;, Age: 2, } fmt.Println(a) // Gopher (2) }  GoStringer package main import ( &amp;quot;fmt&amp;quot; ) // Address has a City, State and a Country.</description>
    </item>
    
  </channel>
</rss>