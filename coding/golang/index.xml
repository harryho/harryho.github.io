<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Hello World</title>
    <link>/coding/golang/</link>
    <description>Recent content in Golang on Hello World</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/coding/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang Note - 1</title>
      <link>/coding/golang/go-note-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-1/</guid>
      <description>Go Introduction  Golang&amp;rsquo;s popularity is skyrocketing. The thriving of Docker and Kubernetes push the Golang to a higher level.
Go is easy to become functional with and appropriate for junior developers to work on. Also, having a language that encourages readability and comprehension is extremely useful. The mixture of duck typing (via interfaces) and convenience features such as &amp;ldquo;:=&amp;rdquo; for short variable declarations give Go the feel of a dynamically typed language while retaining the positives of a strongly typed one.</description>
    </item>
    
    <item>
      <title>Golang Note - 2</title>
      <link>/coding/golang/go-note-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-2/</guid>
      <description>Map  Maps are a special kind of data structure: an unordered collection of pairs of items, where one element of the pair is the key, and the other element, associated with the key, is the data or the value, hence they are also called associative arrays or dictionaries.
 The key type can be any type for which the operations == and != are defined, like string, int, float.</description>
    </item>
    
    <item>
      <title>Golang Note - 3</title>
      <link>/coding/golang/go-note-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-3/</guid>
      <description>Struct  Go supports user-defined or custom types in the form of alias types or structs. A struct tries to represent a real-world entity with its properties. Structs are composite types, to use when you want to define a type which consist of a number of properties, each having their own type and value, grouping pieces of data together.
 Struct with tags  A field in a struct can, apart from a name and a type, also optionally have a tag: this is a string attached to the field, which could be documentation or some other important label.</description>
    </item>
    
    <item>
      <title>Golang Note - 4</title>
      <link>/coding/golang/go-note-4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-4/</guid>
      <description>IO - Read &amp;amp; Write Read from user input var ( firstName, lastName, s string i int f float32 input = &amp;quot;56.12 / 5212 / Go&amp;quot; format = &amp;quot;%f / %d / %s&amp;quot; ) func main() { fmt.Println(&amp;quot;Please enter your full name: &amp;quot;) fmt.Scanln(&amp;amp;firstName, &amp;amp;lastName) // fmt.Scanf(&amp;quot;%s %s&amp;quot;, &amp;amp;firstName, &amp;amp;lastName) fmt.Printf(&amp;quot;Hi %s %s!\n&amp;quot;, firstName, lastName) // Hi Chris Naegels fmt.Sscanf(input, format, &amp;amp;f, &amp;amp;i, &amp;amp;s) fmt.Println(&amp;quot;From the string we read: &amp;quot;, f, i, s) // ouwtput: From the string we read: 56.</description>
    </item>
    
    <item>
      <title>Golang Note - 5</title>
      <link>/coding/golang/go-note-5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-5/</guid>
      <description>Error handling  Go does not have an exception mechanism, like the try/catch in Java or .NET for instance: you cannot throw exceptions. Instead it has a defer-panic-and-recover mechanism.
 The Go way to handle errors is for functions and methods to return an error object as their only or last return value—or nil if no error occurred—and for calling functions to always check the error they receive.
 Handle the errors and return from the function in which the error occurred with an error message to the user: that way if something does go wrong, your program will continue to function and the user will be notified.</description>
    </item>
    
    <item>
      <title>Golang Note - 6</title>
      <link>/coding/golang/go-note-6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-6/</guid>
      <description>Goroutine  A goroutine is implemented as a function or method (this can also be an anonymous or lambda function) and called (invoked) with the keyword go. This starts the function running in parallel with the current computation but in the same address space and with its own stack.
 Go’s concurrency primitives provide the basis for a good concurrency program design: expressing program structure so as to represent independently executing actions; so Go’s emphasis is not in the 1 st place on parallelism: concurrent programs may or may not be parallel.</description>
    </item>
    
    <item>
      <title>Golang Note - 7</title>
      <link>/coding/golang/go-note-7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-7/</guid>
      <description>Channel directionality  A channel type may be annotated to specify that it may only send or only receive
var send_only chan&amp;lt;- int // channel can only receive data var recv_only &amp;lt;-chan int // channel can only send data  Receive-only channels ( &amp;lt;-chan T ) cannot be closed, because closing a channel is intended as a way for a sender to signal that no more values will be sent to the channel, so it has no meaning for receive-only channels.</description>
    </item>
    
    <item>
      <title>Golang Note - 8</title>
      <link>/coding/golang/go-note-8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-8/</guid>
      <description>Package  Package is a way to structure code: a program is constructed as a “package” (often abbreviated as pkg), which may use facilities from other packages. Every go-file belongs to one (and only one) package (like a library or namespace in other languages). Many different .go files can belong to one package, so the filename(s) and package name are generally not the same.
 The package to which the code-file belongs must be indicated on the first line, e.</description>
    </item>
    
    <item>
      <title>Golang Note - 9</title>
      <link>/coding/golang/go-note-9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-9/</guid>
      <description>Shadowing  Hiding (shadowing) a variable by misusing short declaration.
 Such mistakes occur mostly inside the if-body or for-loop
var remember bool = false if something { remember := true // Wrong. } // use remember func shadow() (err error) { x, err := check1() // x is created; err is assigned to if err != nil { return // err correctly returned } if y, err := check2(x); err !</description>
    </item>
    
    <item>
      <title>Golang Note - 10</title>
      <link>/coding/golang/go-note-10/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-10/</guid>
      <description>Template  Package template implements data-driven templates for generating textual output. Templates are executed by applying them to a data structure. Annotations in the template refer to elements of the data structure (typically a field of a struct or a key in a map) to control execution and derive values to be displayed. Execution of the template walks the structure and sets the cursor, represented by a period &amp;lsquo;.&amp;rsquo; and called &amp;ldquo;dot&amp;rdquo;, to the value at the current location in the structure as execution proceeds.</description>
    </item>
    
    <item>
      <title>Golang Note - 20</title>
      <link>/coding/golang/go-note-20/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-20/</guid>
      <description>Strings Change a character  How to change a character in a string
str:=&amp;quot;hello&amp;quot; c:=[]byte(s) c[0]=’c’ s2:= string(c) // s2 == &amp;quot;cello&amp;quot;   Substring  How to take a part(substring) of a string str
substr := str[n:m]   for-loop  How to loop over a string str with for or for-range:
// gives only the bytes: for i:=0; i &amp;lt; len(str); i++ { … = str[i] } // gives the Unicode characters: for ix, ch := range str { // … }   bytes of str  Number of bytes in a string str</description>
    </item>
    
    <item>
      <title>Golang Note - 21</title>
      <link>/coding/golang/go-note-21/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-21/</guid>
      <description>Goroutines and channels  Performance advice:   A rule of thumb if you use parallelism to gain efficiency over serial computation: the amount of work done inside goroutine has to be much higher than the costs associated with creating goroutines and sending data back and forth between them.
 Using buffered channels  Using buffered channels for performance:
A buffered channel can easily double its throughput, depending on the context the performance gain can be 10x or more.</description>
    </item>
    
    <item>
      <title>Golang Note - 22</title>
      <link>/coding/golang/go-note-22/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-22/</guid>
      <description>Error  How to stop a program when an error occurs:
if err != nil { fmt.Printf(&amp;quot;Program stopping with error %v&amp;quot;, err) os.Exit(1) } // OR : if err != nil { panic(&amp;quot;ERROR occurred: &amp;quot; + err.Error()) }   Performance best practices and advice  Use the initializing declaration form := wherever possible (in functions). Use bytes if possible instead of strings Use slices instead of arrays. Use arrays or slices instead of a map where possible (see ref.</description>
    </item>
    
    <item>
      <title>Golang snippets</title>
      <link>/coding/golang/go-note-99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/golang/go-note-99/</guid>
      <description>Convenient logging methods Stringer package main import ( &amp;quot;fmt&amp;quot; ) // Animal has a Name and an Age to represent an animal. type Animal struct { Name string Age uint } // String makes Animal satisfy the Stringer interface. func (a Animal) String() string { return fmt.Sprintf(&amp;quot;%v (%d)&amp;quot;, a.Name, a.Age) } func main() { a := Animal{ Name: &amp;quot;Gopher&amp;quot;, Age: 2, } fmt.Println(a) // Gopher (2) }  GoStringer package main import ( &amp;quot;fmt&amp;quot; ) // Address has a City, State and a Country.</description>
    </item>
    
  </channel>
</rss>