<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>F# on Hello World</title>
    <link>/coding/f-sharp/</link>
    <description>Recent content in F# on Hello World</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/coding/f-sharp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>F# Overview</title>
      <link>/coding/f-sharp/fsharp-note-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/f-sharp/fsharp-note-1/</guid>
      <description>F#  F# is an open-source, cross-platform, interoperable programming language for writing succinct, robust and performant code. Your focus remains on your problem domain, rather than the details of programming.
 Organizing F# Code The following table shows reference articles related to organizing your F# code.
   Title Description     Namespaces Learn about namespace support in F#. A namespace lets you organize code into areas of related functionality by enabling you to attach a name to a grouping of program elements.</description>
    </item>
    
    <item>
      <title>F# Functions</title>
      <link>/coding/f-sharp/fsharp-note-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/f-sharp/fsharp-note-3/</guid>
      <description>F# Function  Functions are the fundamental unit of program execution in any programming language. As in other languages, an F# function has a name, can have parameters and take arguments, and has a body. F# also supports functional programming constructs such as treating functions as values, using unnamed functions in expressions, composition of functions to form new functions, curried functions, and the implicit definition of functions by way of the partial application of function arguments.</description>
    </item>
    
    <item>
      <title>F# C.U.R.S.</title>
      <link>/coding/f-sharp/fsharp-note-4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/f-sharp/fsharp-note-4/</guid>
      <description>Class Classes are types that represent objects that can have properties, methods, and events.
Syntax // Class definition: type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] = [ class ] [ inherit base-type-name(base-constructor-args) ] [ let-bindings ] [ do-bindings ] member-list ... [ end ] // Mutually recursive class definitions: type [access-modifier] type-name1 ... and [access-modifier] type-name2 ... ...  Constructors The constructor is code that creates an instance of the class type.</description>
    </item>
    
    <item>
      <title>F# Collections 1</title>
      <link>/coding/f-sharp/fsharp-note-5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/f-sharp/fsharp-note-5/</guid>
      <description>Array Arrays are fixed-size, zero-based, mutable collections of consecutive data elements that are all of the same type.
Create array // let array1 = [| 1; 2; 3 |] // Put each element on a separate line, in which case the semicolon separator is optional. let array1 = [| 1 2 3 |] // The type of the array elements is inferred from the literals used and must be consistent.</description>
    </item>
    
    <item>
      <title>F# Collections 2</title>
      <link>/coding/f-sharp/fsharp-note-6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/f-sharp/fsharp-note-6/</guid>
      <description>List A list in F# is an ordered, immutable series of elements of the same type. To perform basic operations on lists, use the functions in the List module.
Creating &amp;amp; appending Creating and Initializing Lists
// --- creating --- let list123 = [ 1; 2; 3 ] // You can also put line breaks between elements, in which case the semicolons are optional. let list123 = [ 1 2 3 ] // Normally, all list elements must be the same type.</description>
    </item>
    
    <item>
      <title>F# Collections 3</title>
      <link>/coding/f-sharp/fsharp-note-7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/f-sharp/fsharp-note-7/</guid>
      <description>Seq A sequence is a logical series of elements all of one type. Sequences are particularly useful when you have a large, ordered collection of data but do not necessarily expect to use all of the elements. Individual sequence elements are computed only as required, so a sequence can provide better performance than a list in situations in which not all the elements are used.
// Sequence that has an increment.</description>
    </item>
    
    <item>
      <title>F# Pattern Matching</title>
      <link>/coding/f-sharp/fsharp-note-8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/f-sharp/fsharp-note-8/</guid>
      <description>Pattern Patterns are rules for transforming input data. They are used throughout F# to compare data with a logical structure or structures, decompose data into constituent parts, or extract information from data in various ways.
   Name Description Example     Constant pattern Any numeric, character, or string literal, an enumeration constant, or a defined literal identifier 1.0, &amp;ldquo;test&amp;rdquo;, 30, Color.Red   Identifier pattern A case value of a discriminated union, an exception label, or an active pattern case Some(x) Failure(msg)   Variable pattern identifier a   as pattern pattern as identifier (a, b) as tuple1   OR pattern pattern1 pattern2   AND pattern pattern1 &amp;amp; pattern2 (a, b) &amp;amp; (_, &amp;ldquo;test&amp;rdquo;)   Cons pattern identifier :: list-identifier h :: t   List pattern [ pattern_1; &amp;hellip; ; pattern_n ] [ a; b; c ]   Array pattern [ pattern_1; .</description>
    </item>
    
    <item>
      <title>F# Active Patterns</title>
      <link>/coding/f-sharp/fsharp-note-9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/f-sharp/fsharp-note-9/</guid>
      <description>Active Patterns Active patterns enable you to define named partitions that subdivide input data, so that you can use these names in a pattern matching expression just as you would for a discriminated union. You can use active patterns to decompose data in a customized manner for each partition.
Syntax // Active pattern of one choice. let (|identifier|) [arguments] valueToMatch = expression // Active Pattern with multiple choices. // Uses a FSharp.</description>
    </item>
    
    <item>
      <title>F# Computations 1</title>
      <link>/coding/f-sharp/fsharp-note-10/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/f-sharp/fsharp-note-10/</guid>
      <description>Computation expressions Computation expressions in F# provide a convenient syntax for writing computations that can be sequenced and combined using control flow constructs and bindings. Depending on the kind of computation expression, they can be thought of as a way to express monads, monoids, monad transformers, and applicative functors. However, unlike other languages (such as do-notation in Haskell), they are not tied to a single abstraction, and do not rely on macros or other forms of metaprogramming to accomplish a convenient and context-sensitive syntax.</description>
    </item>
    
    <item>
      <title>F# Computations 2</title>
      <link>/coding/f-sharp/fsharp-note-11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/f-sharp/fsharp-note-11/</guid>
      <description>Map Common Names: map, fmap, lift, Select
Common Operators: &amp;lt;$&amp;gt; &amp;lt;!&amp;gt;
What it does: Lifts a function into the elevated world
Signature: (a-&amp;gt;b) -&amp;gt; E&amp;lt;a&amp;gt; -&amp;gt; E&amp;lt;b&amp;gt;.
Alternatively with the parameters reversed: E&amp;lt;a&amp;gt; -&amp;gt; (a-&amp;gt;b) -&amp;gt; E&amp;lt;b&amp;gt;
Description “map” is the generic name for something that takes a function in the normal world and transforms it into a corresponding function in the elevated world.
/// map for Options let mapOption f opt = match opt with | None -&amp;gt; None | Some x -&amp;gt; Some (f x) // has type : (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a option -&amp;gt; &#39;b option /// map for Lists let rec mapList f list = match list with | [] -&amp;gt; [] | head::tail -&amp;gt; // new head + new tail (f head) :: (mapList f tail) // has type : (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a list -&amp;gt; &#39;b list  Return Common Names: return, pure, unit, yield, point</description>
    </item>
    
    <item>
      <title>F# Namespace, Module &amp; Import</title>
      <link>/coding/f-sharp/fsharp-note-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/f-sharp/fsharp-note-2/</guid>
      <description>Namespace  A namespace lets you organize code into areas of related functionality by enabling you to attach a name to a grouping of F# program elements. Namespaces are typically top-level elements in F# files.
 Namespaces cannot directly contain values and functions. Instead, values and functions must be included in modules, and modules are included in namespaces. Namespaces can contain types, modules.
namespace [rec] [parent-namespaces.]identifier  Modules  A module is a grouping of F# code, such as values, types, and function values, in an F# program.</description>
    </item>
    
  </channel>
</rss>