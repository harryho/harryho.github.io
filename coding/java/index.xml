<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Hello World</title>
    <link>/coding/java/</link>
    <description>Recent content in Java on Hello World</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/coding/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java Note - 1: Enum</title>
      <link>/coding/java/java-note-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/java/java-note-1/</guid>
      <description>Prerequisites  Java 1.5+
 New type: Enum Enum was a great improvement in Java 1.5. From that more and more developer abandom the interface or abstract class as constant variable container.
Before Java 5 Before Java 1.5 you will following coding in many Java program.
// Use interface or abstract class as constant variable container public interface Country { public static final String AU = &amp;quot;Australian&amp;quot;; public static final String UK = &amp;quot;United Kingdom&amp;quot;; public static final String US = &amp;quot;United State&amp;quot;; } public class Util { public static String getLanguageCode(String country) { String languageCode = &amp;quot;en&amp;quot;; switch (country) { case Country.</description>
    </item>
    
    <item>
      <title>Java Note - 2: Concurrency</title>
      <link>/coding/java/java-note-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/java/java-note-2/</guid>
      <description>Thread Join  The join method allows one thread to wait for the completion of another. join responds to an interrupt by exiting with an InterruptedException.
 Demo code of thread join
public class JoinDemo implements Runnable { private Random rand = new Random(System.currentTimeMillis()); public void run() { //simulate some CPU expensive task for (int i = 0; i &amp;lt; 100000000; i++) { rand.nextInt(); } System.out.println(&amp;quot;[&amp;quot; + Thread.currentThread().getName() + &amp;quot;] finished .</description>
    </item>
    
    <item>
      <title>Java Note - 3: Path and Files</title>
      <link>/coding/java/java-note-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/java/java-note-3/</guid>
      <description>Prerequisites  Java 7+
 Good stuff from not shiny Java 7 If you are planning to refactor your code, please give a second thought. It is time to dump to try these new features. When the Java 7 was released, I was kind of disappointed without lambda, jigsaw as most developers, but when I tried new Path, Files API, I found that is great improvement. The enhancement of this new IO is really useful.</description>
    </item>
    
    <item>
      <title>Java Note - 4: Date Time </title>
      <link>/coding/java/java-note-4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/java/java-note-4/</guid>
      <description>Date-Time API Through the java.time packages, Java 8 provides a comprehensive Date-Time API to work with date, time, and datetime. By default, most of the classes are based on the ISO-8601 standards. The main classes are
 Instant  represents an instant on the timeline and it is suitable for machines, for example, as timestamps for event  LocalDate, LocalTime, LocalDateTime
 represents human readable date, time, and datetime without a time zone.</description>
    </item>
    
    <item>
      <title>Java Note - 5: Lambda </title>
      <link>/coding/java/java-note-5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/java/java-note-5/</guid>
      <description>Lamda Lambda Best Practices Use Interfaces The most common misstep taken by an over-eager functional programmer is the use of functional interfaces in type signatures. In general, you should avoid using the functional interface types directly and instead provide single-method interfaces as arguments to your methods. These interfaces become a way to create self-documenting code and to provide meaningful type information, as well as leaving open the opportunity for your user to provide an actual Java type.</description>
    </item>
    
    <item>
      <title>Java Note - 7: Stream API</title>
      <link>/coding/java/java-note-7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/java/java-note-7/</guid>
      <description>Stream Iterations Collections and Maps Filtering Mapping LambdaCollectionDemo Lambda Collection Map Demo public class LambdaCollectionMapDemo { public static void main(String[] args) { // FunctionalInterface System.out.println(&amp;quot;x + y:&amp;quot; + engine((x, y) -&amp;gt; x + y));// w w w .j av a 2s. c om System.out.println(&amp;quot;x - y:&amp;quot; + engine((x, y) -&amp;gt; x * y)); System.out.println(&amp;quot;x * y:&amp;quot; + engine((x, y) -&amp;gt; x / y)); System.out.println(&amp;quot;x / y:&amp;quot; + engine((x, y) -&amp;gt; x % y)); String[] strArray = new String[] { &amp;quot;abc&amp;quot;, &amp;quot;klm&amp;quot;, &amp;quot;xyz&amp;quot;, &amp;quot;pqr&amp;quot; }; List list = Arrays.</description>
    </item>
    
    <item>
      <title>Java Note - Part 6: Lambda &amp; Collection</title>
      <link>/coding/java/java-note-6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/coding/java/java-note-6/</guid>
      <description>Lambda and Collection Iterations Collections and Maps Filtering Mapping LambdaCollectionDemo Lambda Collection Map Demo public class LambdaCollectionMapDemo { public static void main(String[] args) { // FunctionalInterface System.out.println(&amp;quot;x + y:&amp;quot; + engine((x, y) -&amp;gt; x + y));// w w w .j av a 2s. c om System.out.println(&amp;quot;x - y:&amp;quot; + engine((x, y) -&amp;gt; x * y)); System.out.println(&amp;quot;x * y:&amp;quot; + engine((x, y) -&amp;gt; x / y)); System.out.println(&amp;quot;x / y:&amp;quot; + engine((x, y) -&amp;gt; x % y)); String[] strArray = new String[] { &amp;quot;abc&amp;quot;, &amp;quot;klm&amp;quot;, &amp;quot;xyz&amp;quot;, &amp;quot;pqr&amp;quot; }; List list = Arrays.</description>
    </item>
    
  </channel>
</rss>