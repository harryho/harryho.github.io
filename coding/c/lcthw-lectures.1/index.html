<!DOCTYPE html>
<html>
  <head>
    <title>Hello World</title>
    
      <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="revised" content="2020-09-24T23:39:46 AEST">
<title>C Lecture - 1 :: Hello World</title>
<link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon" />
<link href="/css/font-awesome.min.css" rel="stylesheet">
<link href="/css/nucleus.css" rel="stylesheet">
<link href="/theme-flex/style.css" rel="stylesheet">

<link rel="stylesheet" href="/css/bootstrap.min.css">
<script src="/js/jquery-2.x.min.js"></script>
<script type="text/javascript">
      var baseurl = "\/";
</script>
<meta name="description" content="Exercise 0 ~ 31">



    
  </head>
  <body data-url="/coding/c/lcthw-lectures.1/">
    
      <header>
  <div class="logo">
    
	
  
    <a class="baselink" href="/">Hello World</a>
  


  </div>
  <div class="burger"><a href="javascript:void(0);" style="font-size:15px;">&#9776;</a></div>
  <nav class="shortcuts">
    <div>
      <div class="searchbox">
        <input data-search-input id="search-by" type="text" placeholder="Search...">
      </div>
      <script type="text/javascript" src="/js/lunr.min.js"></script>
      <script type="text/javascript" src="/js/auto-complete.js"></script>
      <link href="/css/auto-complete.css" rel="stylesheet">
      <script type="text/javascript">
        
            var baseurl = "\/";
        
      </script>
      <script type="text/javascript" src="/js/search.js"></script>
    </div>
  </nav>
</header>
<article>
  <aside>
    <ul class="menu">
          <li data-nav-id="/" class="dd-item">
          <a href="/">
            <i class="fa fa-fw fa-home"></i>
          </a>
          </li>
    <li data-nav-id="/projects/" class="dd-item haschildren
        ">
      <div>
      <a href="/projects/">Projects</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/projects/angular-crm/" class="dd-item">
        <div>
          <a href="/projects/angular-crm/">
            Angular 9 CRM Starter Project
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/docker-toolkits/" class="dd-item">
        <div>
          <a href="/projects/docker-toolkits/">
             Docker Kits
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/python-flat-api/" class="dd-item">
        <div>
          <a href="/projects/python-flat-api/">
            FlatApi - Restful API for python dev
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/angular4-crm/" class="dd-item">
        <div>
          <a href="/projects/angular4-crm/">
            Angular 4 CRM Project
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/laravel-mvc-starter/" class="dd-item">
        <div>
          <a href="/projects/laravel-mvc-starter/">
            Laravel MVC Starter
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/react-crm/" class="dd-item">
        <div>
          <a href="/projects/react-crm/">
            React Redux CRM Project
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/vue2-admin/" class="dd-item">
        <div>
          <a href="/projects/vue2-admin/">
            Vue 2 Admin Project
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/vue2-crm/" class="dd-item">
        <div>
          <a href="/projects/vue2-crm/">
            Vue 2 CRM Project
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/angularjs-webpack-es6-starter/" class="dd-item">
        <div>
          <a href="/projects/angularjs-webpack-es6-starter/">
            Angularjs Webpack ES6 Starter
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/zf2-mvc-starter/" class="dd-item">
        <div>
          <a href="/projects/zf2-mvc-starter/">
            Zend Framework 2 MVC Starter
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/kube-cluster/" class="dd-item">
        <div>
          <a href="/projects/kube-cluster/">
            Kubernetes Cluster in 5min
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/" class="dd-item parent haschildren
        ">
      <div>
      <a href="/coding/">Coding</a>
            <i class="fa fa-angle-down fa-lg category-icon"></i>
      </div>
        <ul>
    <li data-nav-id="/coding/c/" class="dd-item parent haschildren
        ">
      <div>
      <a href="/coding/c/">C </a>
            <i class="fa fa-angle-down fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/c/lcthw-lectures.1/" class="dd-item active">
        <div>
          <a href="/coding/c/lcthw-lectures.1/">
            C Lecture - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/c/lcthw-lectures.2/" class="dd-item">
        <div>
          <a href="/coding/c/lcthw-lectures.2/">
            C Lecture - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/c/lcthw-lectures.3/" class="dd-item">
        <div>
          <a href="/coding/c/lcthw-lectures.3/">
            C Lecture - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/c/lcthw-lectures.4/" class="dd-item">
        <div>
          <a href="/coding/c/lcthw-lectures.4/">
            C Lecture - 4
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/c-sharp/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/c-sharp/">C#</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/c-sharp/csharp-note-1/" class="dd-item">
        <div>
          <a href="/coding/c-sharp/csharp-note-1/">
            C# Console App
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/c-sharp/csharp-note-4/" class="dd-item">
        <div>
          <a href="/coding/c-sharp/csharp-note-4/">
             Generic Predicate &amp; Expression
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/c-sharp/csharp-note-2/" class="dd-item">
        <div>
          <a href="/coding/c-sharp/csharp-note-2/">
            Scheduled task with window service
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/c-sharp/csharp-note-3/" class="dd-item">
        <div>
          <a href="/coding/c-sharp/csharp-note-3/">
            Thread &amp; Task
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/db-sql/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/db-sql/">DB &amp; SQL</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/db-sql/mysql-note-2/" class="dd-item">
        <div>
          <a href="/coding/db-sql/mysql-note-2/">
            MySql: DDL
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/db-sql/mysql-note-1/" class="dd-item">
        <div>
          <a href="/coding/db-sql/mysql-note-1/">
            MySql: Getting Started
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/db-sql/mysql-note-5/" class="dd-item">
        <div>
          <a href="/coding/db-sql/mysql-note-5/">
            MySql: JSON
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/db-sql/mysql-note-4/" class="dd-item">
        <div>
          <a href="/coding/db-sql/mysql-note-4/">
            MySql: Schema &amp; Metadata
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/db-sql/mysql-note-3/" class="dd-item">
        <div>
          <a href="/coding/db-sql/mysql-note-3/">
            MySql: SP &amp; Func
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/db-sql/pgsql-note-1/" class="dd-item">
        <div>
          <a href="/coding/db-sql/pgsql-note-1/">
            PostgresQL Note - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/db-sql/mssql-note-1/" class="dd-item">
        <div>
          <a href="/coding/db-sql/mssql-note-1/">
            Sql Server Note - 1
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/golang/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/golang/">Golang</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/golang/go-note-1/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-1/">
            Getting started
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-2/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-2/">
            Map, Function &amp; Closure
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-3/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-3/">
            Struct &amp; Interface
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-4/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-4/">
            IO, Json &amp; XML
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-5/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-5/">
            Error handling
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-6/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-6/">
            Goroutine &amp; Channel - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-7/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-7/">
            Goroutine &amp; Channel - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-8/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-8/">
            Packaging
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-9/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-9/">
            Pitfalls
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-10/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-10/">
            Template
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-20/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-20/">
            Good practice - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-21/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-21/">
            Good practice - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-22/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-22/">
            Good practice - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-99/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-99/">
            Golang snippets
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/java/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/java/">Java</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/java/java-note-1/" class="dd-item">
        <div>
          <a href="/coding/java/java-note-1/">
            Java Note - 1: Enum
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/java/java-note-2/" class="dd-item">
        <div>
          <a href="/coding/java/java-note-2/">
            Java Note - 2: Concurrency
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/java/java-note-3/" class="dd-item">
        <div>
          <a href="/coding/java/java-note-3/">
            Java Note - 3: Path and Files
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/java/java-note-4/" class="dd-item">
        <div>
          <a href="/coding/java/java-note-4/">
            Java Note - 4: Date Time 
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/java/java-note-5/" class="dd-item">
        <div>
          <a href="/coding/java/java-note-5/">
            Java Note - 5: Lambda 
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/js-ts/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/js-ts/">JS &amp; TS </a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/js-ts/js-note-1/" class="dd-item">
        <div>
          <a href="/coding/js-ts/js-note-1/">
            JS &amp; ES Note - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/js-ts/js-note-2/" class="dd-item">
        <div>
          <a href="/coding/js-ts/js-note-2/">
            JS &amp; ES Note - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/js-ts/js-note-3/" class="dd-item">
        <div>
          <a href="/coding/js-ts/js-note-3/">
            JS &amp; ES Note - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/js-ts/js-note-99/" class="dd-item">
        <div>
          <a href="/coding/js-ts/js-note-99/">
            JS &amp; ES snippet
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/js-ts/ts-note-1/" class="dd-item">
        <div>
          <a href="/coding/js-ts/ts-note-1/">
            TS: Basic Types
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/python/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/python/">Python</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/python/python-note-1/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-1/">
            Package &amp; Module
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-2/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-2/">
            Closure &amp; Decorator
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-3/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-3/">
            String &amp; Representation
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-4/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-4/">
            Iteration
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-5/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-5/">
            Inheritance &amp; Polymorphism
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-6/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-6/">
            Collection
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-7/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-7/">
            Exception &amp; Assertion
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-8/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-8/">
            Context
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-9/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-9/">
            ABC
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/rustlang/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/rustlang/">Rustlang</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/rustlang/rust-note-1/" class="dd-item">
        <div>
          <a href="/coding/rustlang/rust-note-1/">
            Data Types &amp; Ownership
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/rustlang/rust-note-2/" class="dd-item">
        <div>
          <a href="/coding/rustlang/rust-note-2/">
            Project, Vector, String &amp; Hashmap
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/rustlang/rust-note-3/" class="dd-item">
        <div>
          <a href="/coding/rustlang/rust-note-3/">
            Error handling
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/rustlang/rust-note-4/" class="dd-item">
        <div>
          <a href="/coding/rustlang/rust-note-4/">
            Generic Type &amp; Trait 
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/shell/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/shell/">Shell</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/shell/bash-note-1/" class="dd-item">
        <div>
          <a href="/coding/shell/bash-note-1/">
            Adv Bash - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/shell/bash-note-2/" class="dd-item">
        <div>
          <a href="/coding/shell/bash-note-2/">
            Adv Bash - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/shell/bash-note-3/" class="dd-item">
        <div>
          <a href="/coding/shell/bash-note-3/">
            Adv Bash - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/shell/cron-note-1/" class="dd-item">
        <div>
          <a href="/coding/shell/cron-note-1/">
            Cron Job Note - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/shell/cron-note-2/" class="dd-item">
        <div>
          <a href="/coding/shell/cron-note-2/">
            Cron Job Note - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/shell/ps-note-1/" class="dd-item">
        <div>
          <a href="/coding/shell/ps-note-1/">
            Powershell Note - 1
          </a>
        </div>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li data-nav-id="/cloud/" class="dd-item haschildren
        ">
      <div>
      <a href="/cloud/">Cloud</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
    <li data-nav-id="/cloud/aws/" class="dd-item haschildren
        ">
      <div>
      <a href="/cloud/aws/">AWS</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/cloud/aws/aws-01-iam/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-01-iam/">
            AWS: IAM
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-02-cli-1/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-02-cli-1/">
            AWS : CLI - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-02-cli-2/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-02-cli-2/">
            AWS : CLI - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-02-cli-3/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-02-cli-3/">
            AWS : CLI - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-03-vpc-1/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-03-vpc-1/">
            AWS: VPC - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-03-vpc-2/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-03-vpc-2/">
            AWS: VPC - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-03-vpc-3/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-03-vpc-3/">
            AWS: VPC - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-03-vpc-4/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-03-vpc-4/">
            AWS: VPC - 4
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-04-s3-1/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-04-s3-1/">
            AWS: S3 - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-04-s3-2/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-04-s3-2/">
            AWS: S3 - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-04-s3-3/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-04-s3-3/">
            AWS: S3 - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-05-ses-sqs-sns-1/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-05-ses-sqs-sns-1/">
            AWS: SQS,SNS,SES - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-05-ses-sqs-sns-2/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-05-ses-sqs-sns-2/">
            AWS: SQS,SNS,SES - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-03-vpc-5/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-03-vpc-5/">
            AWS: VPC - 5
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-11-eks-1/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-11-eks-1/">
            AWS: EKS - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-11-eks-2/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-11-eks-2/">
            AWS: EKS - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-11-eks-3/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-11-eks-3/">
            AWS: EKS - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-11-eks-4/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-11-eks-4/">
            AWS: EKS - 4
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-11-eks-5/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-11-eks-5/">
            AWS: EKS - 5
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-21-rds-1/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-21-rds-1/">
            AWS: RDS - 1
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/cloud/digito/" class="dd-item haschildren
        ">
      <div>
      <a href="/cloud/digito/">Digital Ocean</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/cloud/digito/digito-note-1/" class="dd-item">
        <div>
          <a href="/cloud/digito/digito-note-1/">
            DigitialOcean: Droplet
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/digito/digito-note-2/" class="dd-item">
        <div>
          <a href="/cloud/digito/digito-note-2/">
            DigitialOcean: Get Started
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/digito/digito-note-3/" class="dd-item">
        <div>
          <a href="/cloud/digito/digito-note-3/">
            DigitialOcean: First Web Host
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/digito/digito-note-4/" class="dd-item">
        <div>
          <a href="/cloud/digito/digito-note-4/">
            DigitialOcean: Lets Encrypt
          </a>
        </div>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li data-nav-id="/hacks/" class="dd-item haschildren
        ">
      <div>
      <a href="/hacks/">Hacks</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/hacks/windows-command-1/" class="dd-item">
        <div>
          <a href="/hacks/windows-command-1/">
            Windows cmd &amp; hotkey - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/windows-command-2/" class="dd-item">
        <div>
          <a href="/hacks/windows-command-2/">
            Windows cmd &amp; hotkey - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/windows-command-3/" class="dd-item">
        <div>
          <a href="/hacks/windows-command-3/">
            Windows cmd &amp; hotkey - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/git-notes/" class="dd-item">
        <div>
          <a href="/hacks/git-notes/">
            Git Practices
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/cass-note/" class="dd-item">
        <div>
          <a href="/hacks/cass-note/">
            Cassandra Practices
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/php-debug/" class="dd-item">
        <div>
          <a href="/hacks/php-debug/">
            Debug PHP with Free IDE
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/docker-note/" class="dd-item">
        <div>
          <a href="/hacks/docker-note/">
            Docker Practices
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/qemu-notes/" class="dd-item">
        <div>
          <a href="/hacks/qemu-notes/">
            Qemu &amp; Virtual Machine
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/vbox-notes/" class="dd-item">
        <div>
          <a href="/hacks/vbox-notes/">
            VirtualBox Notes
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/os/" class="dd-item haschildren
        ">
      <div>
      <a href="/os/">OS</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/os/amazon-linux-2/" class="dd-item">
        <div>
          <a href="/os/amazon-linux-2/">
            Amazon Linux 2 
          </a>
        </div>
    </li>
      <li data-nav-id="/os/vpn-strongswam/" class="dd-item">
        <div>
          <a href="/os/vpn-strongswam/">
            VPN StrongSwam setup
          </a>
        </div>
    </li>
      <li data-nav-id="/os/vpn-vyos/" class="dd-item">
        <div>
          <a href="/os/vpn-vyos/">
            VPN VyOS setup
          </a>
        </div>
    </li>
      <li data-nav-id="/os/dual-boot-win10-ubuntu18/" class="dd-item">
        <div>
          <a href="/os/dual-boot-win10-ubuntu18/">
            Dual Boot Windows 10 &amp; Ubuntu 18
          </a>
        </div>
    </li>
      <li data-nav-id="/os/ubuntu-desktop-18/" class="dd-item">
        <div>
          <a href="/os/ubuntu-desktop-18/">
            Ubuntu Desktop 18 LTS note
          </a>
        </div>
    </li>
      <li data-nav-id="/os/raspberrypi-notes/" class="dd-item">
        <div>
          <a href="/os/raspberrypi-notes/">
            Raspberry Pi setup
          </a>
        </div>
    </li>
      <li data-nav-id="/os/lubuntu16-desktop/" class="dd-item">
        <div>
          <a href="/os/lubuntu16-desktop/">
            Lubuntu 16 desktop
          </a>
        </div>
    </li>
      <li data-nav-id="/os/grub-trouble-shooting/" class="dd-item">
        <div>
          <a href="/os/grub-trouble-shooting/">
            Grub Trouble Shooting
          </a>
        </div>
    </li>
      <li data-nav-id="/os/ubuntu-server-16/" class="dd-item">
        <div>
          <a href="/os/ubuntu-server-16/">
            Ubuntu 16 server note
          </a>
        </div>
    </li>
      <li data-nav-id="/os/centos-server-7/" class="dd-item">
        <div>
          <a href="/os/centos-server-7/">
            CentOS 7 Server
          </a>
        </div>
    </li>
      <li data-nav-id="/os/ubuntu-server-14/" class="dd-item">
        <div>
          <a href="/os/ubuntu-server-14/">
            Ubuntu 14 -- server setup
          </a>
        </div>
    </li>
      <li data-nav-id="/os/ubuntu-desktop-14/" class="dd-item">
        <div>
          <a href="/os/ubuntu-desktop-14/">
            Ubuntu 14 -- desktop setup &amp; dual boot 
          </a>
        </div>
    </li>
      <li data-nav-id="/os/ubuntu-desktop-14-extra-tools/" class="dd-item">
        <div>
          <a href="/os/ubuntu-desktop-14-extra-tools/">
            Ubuntu 14 -- desktop, extra tools
          </a>
        </div>
    </li>
      <li data-nav-id="/os/mac-notes/" class="dd-item">
        <div>
          <a href="/os/mac-notes/">
            Macbook Notes
          </a>
        </div>
    </li>
      <li data-nav-id="/os/centos-fedora-desktop/" class="dd-item">
        <div>
          <a href="/os/centos-fedora-desktop/">
            CentOS 6/7 Multi-Boot Setup
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/blogs/" class="dd-item haschildren
        ">
      <div>
      <a href="/blogs/">Blogs</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/blogs/k8s-on-vm/" class="dd-item">
        <div>
          <a href="/blogs/k8s-on-vm/">
            Try Minikube
          </a>
        </div>
    </li>
      <li data-nav-id="/blogs/vue-ng-react/" class="dd-item">
        <div>
          <a href="/blogs/vue-ng-react/">
            Angular vs React vs Vue
          </a>
        </div>
    </li>
      <li data-nav-id="/blogs/create-a-blog-on-github/" class="dd-item">
        <div>
          <a href="/blogs/create-a-blog-on-github/">
            Create a blog site on GitHub Pages
          </a>
        </div>
    </li>
      <li data-nav-id="/blogs/build-mobile-app/" class="dd-item">
        <div>
          <a href="/blogs/build-mobile-app/">
            Build mobile app with web tech
          </a>
        </div>
    </li>
      <li data-nav-id="/blogs/azure-notes/" class="dd-item">
        <div>
          <a href="/blogs/azure-notes/">
            Azure Practices
          </a>
        </div>
    </li>
      <li data-nav-id="/blogs/javascript-oop/" class="dd-item">
        <div>
          <a href="/blogs/javascript-oop/">
            JavaScript and OOP
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/frameworks/" class="dd-item haschildren
        ">
      <div>
      <a href="/frameworks/">Frameworks</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/frameworks/cntk-notes-1/" class="dd-item">
        <div>
          <a href="/frameworks/cntk-notes-1/">
            CNTK Note - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/frameworks/tensorflow-notes-1/" class="dd-item">
        <div>
          <a href="/frameworks/tensorflow-notes-1/">
            Tensorflow Note - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/frameworks/tensorflow-notes-2/" class="dd-item">
        <div>
          <a href="/frameworks/tensorflow-notes-2/">
            Tensorflow Note - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/frameworks/php-web/" class="dd-item">
        <div>
          <a href="/frameworks/php-web/">
            PHP Web Framework
          </a>
        </div>
    </li>
      <li data-nav-id="/frameworks/python-django/" class="dd-item">
        <div>
          <a href="/frameworks/python-django/">
            Python Web Framework
          </a>
        </div>
    </li>
        </ul>
    </li>




    </ul>
    <section>
    </section>
  </aside>
  <section class="page">
    
    <div class="nav-select">
      <center>Navigation : 
        <select onchange="javascript:location.href = this.value;">
          
    <option value="/projects/" >
   Projects</option>
    <option value="/coding/" >
   Coding</option> 
    <option value="/coding/c/" >
  - 
   C </option> 
      <option value="/coding/c/lcthw-lectures.1/"  selected>-- C Lecture - 1</option>
      <option value="/coding/c/lcthw-lectures.2/" >-- C Lecture - 2</option>
      <option value="/coding/c/lcthw-lectures.3/" >-- C Lecture - 3</option>
      <option value="/coding/c/lcthw-lectures.4/" >-- C Lecture - 4</option>
  
    <option value="/coding/c-sharp/" >
  - 
   C#</option>
    <option value="/coding/db-sql/" >
  - 
   DB &amp; SQL</option>
    <option value="/coding/golang/" >
  - 
   Golang</option>
    <option value="/coding/java/" >
  - 
   Java</option>
    <option value="/coding/js-ts/" >
  - 
   JS &amp; TS </option>
    <option value="/coding/python/" >
  - 
   Python</option>
    <option value="/coding/rustlang/" >
  - 
   Rustlang</option>
    <option value="/coding/shell/" >
  - 
   Shell</option>
  
    <option value="/cloud/" >
   Cloud</option>
    <option value="/hacks/" >
   Hacks</option>
    <option value="/os/" >
   OS</option>
    <option value="/blogs/" >
   Blogs</option>
    <option value="/frameworks/" >
   Frameworks</option>



        </select>
      </center>
    </div>


    


    
    
    
<div class="main-page">
    <div class="flex-item main-content">
            <h1>C Lecture - 1</h1>
        

<p>Author: Zed A. Shaw</p>

<p>All content comes from Zed&rsquo;s <a href="https://github.com/zedshaw/learn-c-the-hard-way-lectures.git">Lecture Repository</a> and <a href="https://github.com/zedshaw/liblcthw">Libraries Repository</a>.  All credit goes to Zed.</p>

<h3 id="exercise-0-installing-software">Exercise 0 Installing Software</h3>

<p>The Plan</p>

<ul>
<li>Install software on your system.</li>
<li>Test that it works right.</li>
</ul>

<p>Linux Install</p>

<p>On Debian/Ubuntu use:</p>

<pre><code>$ sudo apt-get install build-essential
</code></pre>

<p>On RedHat/CentOS:</p>

<pre><code>$ sudo yum groupinstall development-tools
</code></pre>

<p>Linux Testing</p>

<p>Test that your C compiler works with:</p>

<pre><code>$ cc --version
</code></pre>

<p>OSX Install</p>

<p>Install <a href="https://developer.apple.com/xcode/">XCode</a>, this will take a while.</p>

<p>OSX Testing</p>

<p>Test that your C compiler works with:</p>

<pre><code>$ cc --version
</code></pre>

<p>Windows Install</p>

<p>Install <a href="http://www.mingw.org/">MinGW</a> or <a href="https://www.cygwin.com/">Cygwin</a> or Use <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a> to run Linux.</p>

<p>Text Editors</p>

<p>You should already have one.
Just don&rsquo;t use an IDE. They aren&rsquo;t very helpful.</p>

<p>End of Lecture 0</p>

<h3 id="exercise-1-dust-off-that-compiler">Exercise 1 Dust Off That Compiler</h3>

<p>The Plan</p>

<ul>
<li>Write your first C program.</li>
<li>Build it.</li>
<li>Break it.</li>
</ul>

<p>The Code</p>

<p>.\ex01\ex1.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

/* This is a comment. */
int main(int argc, char *argv[])
{
    int distance = 100;

    // this is also a comment
    printf(&quot;You are %d miles away.\n&quot;, distance);

    return 0;
}

</code></pre>

<p>.\ex01\ex1_zed.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

/* This is a comment. */
int main(int argc, char *argv[])
{
    int distance = 100;

    // this is also a comment
    printf(&quot;You are %d miles away.\n&quot;);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Let&rsquo;s look at it line-by-line.</p>

<p>Breaking It</p>

<p>This is all crazy magic right now.</p>

<p>Extra Credit</p>

<ul>
<li>Open the <code>ex1</code> file in your text editor and change or delete random parts.
Try running it and see what happens.</li>
<li>Print out five more lines of text or something more complex than &ldquo;hello world.&rdquo;</li>
<li>Run <code>man 3 printf</code> and read about this function and many others.</li>
<li>For each line, write out the symbols you don&rsquo;t understand and
see if you can guess what they mean.  Write a little chart on
paper with your guess so you can check it later to see
if you got it right.</li>
</ul>

<h3 id="exercise-2-using-makefiles-to-build">Exercise 2 Using Makefiles to Build</h3>

<p>The Plan</p>

<ul>
<li>Start with simple make usage.</li>
<li>Set a few important settings.</li>
</ul>

<p>How Make Works</p>

<p>Implied dependencies and ancient lore.</p>

<p>Shell Commands</p>

<pre><code>$ make ex1
## or this one too
$ CFLAGS=&quot;-Wall&quot; make ex1
$ make clean
$ make ex1
</code></pre>

<p>Makefile</p>

<pre><code>CFLAGS=-Wall -g

clean:
    rm -f ex1
</code></pre>

<p>The Analysis</p>

<ul>
<li>Setting options.</li>
<li>Indicating dependencies.</li>
<li>Writing commends to run.</li>
</ul>

<p>Breaking It</p>

<ul>
<li>Watch out for tabs vs. spaces.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Create an <em>all: ex1</em> target that will build <em>ex1</em> with
just the command <em>make</em>.</li>
<li>Read <em>man make</em> to find out more information on how to run it.</li>
<li>Read <em>man cc</em> to find out more information on what the flags <em>-Wall</em> and <em>-g</em> do.</li>
<li>Research <em>Makefiles</em> online and see if you can improve this one.</li>
<li>Find a <em>Makefile</em> in another C project and try to understand
what it&rsquo;s doing.</li>
</ul>

<h3 id="exercise-3-formatted-printing">Exercise 3 Formatted Printing</h3>

<p>The Plan</p>

<ul>
<li>Introduction to <em>printf</em>.</li>
</ul>

<p>The Code</p>

<p>.\ex03\ex3.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int age = 100;
    int height = 72;

    printf(&quot;I am %d years old.\n&quot;, argv);
    printf(&quot;I am %d inches tall.\n&quot;, height);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Take the <em>age</em> variable out of the first <em>printf</em> call, then recompile. You should get a couple of warnings.</li>
<li>Run this new program and it will either crash or print out a really crazy age.</li>
<li>Put the <em>printf</em> back the way it was, and then don&rsquo;t set <em>age</em> to an initial value by changing that line to <em>int age;</em>, and then rebuild it and run it again.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Find as many other ways to break <em>ex3.c</em> as you can.</li>
<li>Run <em>man 3 printf</em> and read about the other <em>%</em> format
characters you can use.  These should look familiar if you used
them in other languages (they come from <em>printf</em>).</li>
<li>Add <em>ex3</em> the <em>all</em> list in your <em>Makefile</em>.  Use this
to <em>make clean all</em> and build all of your exercises thus far.</li>
<li>Add <em>ex3</em> to your <em>clean</em> list in your<em>Makefile</em> as well.
Use <em>make clean</em> to remove it when you need to.</li>
</ul>

<h3 id="exercise-4-using-a-debugger">Exercise 4 Using a Debugger</h3>

<p>The Plan</p>

<ul>
<li>See how GDB works (LLDB on OSX).</li>
<li>Look at memory checkers like Valgrind and AddressSanitizer.</li>
<li>Cover the quick reference.</li>
<li>Debug a program.</li>
</ul>

<p>Using GDB</p>

<p>Using LLDB</p>

<p>Using Valgrind</p>

<p>Using Lint</p>

<p>Using AddressSanitizer</p>

<p>You neeed clang for this.</p>

<p>&ldquo;The Debugger&rdquo;</p>

<p>When I say &ldquo;the debugger&rdquo; in the book I mean to use GDB, but use
every tool you can find that helps.</p>

<h3 id="exercise-5-memorizing-c-operators">Exercise 5 Memorizing C Operators</h3>

<p>The Plan</p>

<ul>
<li>Learn why memorizing works.</li>
<li>Learn how to memorize things.</li>
<li>Review the C operators.</li>
</ul>

<p>Memorization</p>

<ul>
<li>A &ldquo;backdoor&rdquo; hack to learning.</li>
<li>Memorize the operators, then reading is easier.</li>
<li>Works with any language.</li>
</ul>

<p>Memorization Proces</p>

<ul>
<li>Write everything on index cards.</li>
<li>Use Anki, but make your own cards.</li>
<li>Spend 30-60 minutes a day.</li>
<li>Track what you don&rsquo;t know, drill those more.</li>
</ul>

<p>Arithmetic Operators</p>

<pre><code>+    Add
-    Subtract
*    Multiply
/    Divide
%    Modulus
++   Increment
--   Decrement
</code></pre>

<p>Relational Operators</p>

<pre><code>==   Equal
!=   Not equal
&gt;    Greater than
&lt;    Less than
&gt;=   Greater than equal
&lt;=   Less than equal
</code></pre>

<p>Logical Operators</p>

<pre><code>&amp;&amp;   Logical and
||   Logical or
!    Logical not
? :  Logical ternary
</code></pre>

<p>Bitwise Operators</p>

<pre><code>&amp;    Bitwise and
|    Bitwise or
^    Bitwise xor
~    Bitwise ones compliment
&lt;&lt;   Bitwise shift left
&gt;&gt;   Bitwise shift right
</code></pre>

<p>Assignment Operators</p>

<pre><code>=    Assign equal
+=   Assign plus-equal
-=   Assign minus-equal
*=   Assign multiply-equal
/=   Assign divide-equal
%=   Assign modulus-equal
&lt;&lt;=  Assign shift-left-equal
&gt;&gt;=  Assign shift-right-equal
&amp;=   Assign and-equal
^=   Assign xor-equal
|=   Assign or-equal
</code></pre>

<p>Data Operators</p>

<pre><code>sizeof() Get the size of
[]       Array subscript
&amp;        The address of
*        The value of
-&gt;       Structure dereference
.        Structure reference
</code></pre>

<p>Miscellaneous Operators</p>

<pre><code>,         Comma
( )       Parenthesis
{ }       Braces
:         Colon
//        Single-line comment start
/*        Multi-line comment start
*/        Multi-line comment end
</code></pre>

<h3 id="exercise-6-memorizing-c-syntax">Exercise 6 Memorizing C Syntax</h3>

<p>The Plan</p>

<ul>
<li>Memorize the keywords of C.</li>
<li>Memorize the major syntax forms.</li>
</ul>

<p>Execution Keywords
    break     Exit out of a compound statement.
    case      A branch in a switch-statement.
    continue  Continue to the top of a loop.
    do        Start a do-while loop.
    default   Default branch in a switch-statement.
    else      An else branch of an if-statement.
    for       Start a for-loop.
    goto      Jump to a label.
    if        Starts an if-statement.
    return    Return from a function.
    switch    Start a switch-statement.
    while     Start a while-loop.</p>

<p>Type Keywords
    char      Character data type.
    double    A double floating point data type.
    float     A floating point data type.
    int       An integer data type.
    long      A long integer data type.
    short     A short integer data type.
    void      Declare a data type empty.
    union     Start a union-statement.
    struct    Combine variables into a single record.</p>

<p>Data Keywords</p>

<pre><code>auto      Give a local variable a local lifetime.
const     Make a variable unmodifiable.
enum      Define a set of int constants.
extern    Declare an identifier is defined externally.
register  Declare a variable be stored in a CPU register.
signed    A signed modifier for integer data types.
sizeof    Determine the size of data.
static    Preserve variable value after its scope exits.
typedef   Create a new type.
unsigned  An unsigned modifier for integer data types.
volatile  Declare a variable might be modified elsewhere.
</code></pre>

<p>If-Statement</p>

<pre><code>if(TEST) {
    CODE;
} else if(TEST) {
    CODE;
} else {
    CODE;
}
</code></pre>

<p>Switch-Statement</p>

<pre><code>switch (OPERAND) {
    case CONSTANT:
        CODE;
        break;
    default:
        CODE;
}
</code></pre>

<p>While-Loop</p>

<pre><code>while(TEST) {
    CODE;
}
</code></pre>

<p>While with Continue</p>

<pre><code>while(TEST) {
    if(OTHER_TEST) {
        continue;
    }
    CODE;
}
</code></pre>

<p>While with Break</p>

<pre><code>while(TEST) {
    if(OTHER_TEST) {
        break;
    }
    CODE;
}
</code></pre>

<p>Do-While</p>

<pre><code>do {
    CODE;
} while(TEST);
</code></pre>

<p>For-Loop</p>

<pre><code>for(INIT; TEST; POST) {
    CODE;
}
</code></pre>

<ul>
<li><em>continue</em> and <em>break</em> work with <em>for</em></li>
</ul>

<p>Enum</p>

<pre><code>enum { CONST1, CONST2, CONST3 } NAME;
</code></pre>

<p>Goto</p>

<pre><code>if(ERROR_TEST) {
    goto fail;
}

fail:
    CODE;
</code></pre>

<p>Functions</p>

<pre><code>TYPE NAME(ARG1, ARG2, ..) {
    CODE;
    return VALUE;
}
</code></pre>

<p>Typedef</p>

<pre><code>typedef DEFINITION IDENTIFIER;

typedef unsigned char byte;
</code></pre>

<p>Struct</p>

<pre><code>struct NAME {
    ELEMENTS;
} [VARIABLE_NAME];
</code></pre>

<p>Typedef Struct</p>

<pre><code>typedef struct [STRUCT_NAME] {
    ELEMENTS;
} IDENTIFIER;
</code></pre>

<p>Union</p>

<pre><code>union NAME {
    ELEMENTS;
} [VARIABLE_NAME];
</code></pre>

<h3 id="exercise-7-variables-and-types">Exercise 7 Variables and Types</h3>

<p>The Plan</p>

<ul>
<li>Learn some basic variables and types.</li>
<li>int, float, double, char, and strings.</li>
</ul>

<p>The Code</p>

<p>.\ex07\ex7.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int distance = 100;
    float power = 2.345f;
    double super_power = 56789.4532;
    char initial = 'A';
    char first_name[] = &quot;Zed&quot;;
    char last_name[] = &quot;Shaw&quot;;

    first_name[3] = 'Z';

    printf(&quot;You are %d miles away.\n&quot;, distance);
    printf(&quot;You have %f levels of power.\n&quot;, power);
    printf(&quot;You have %f awesome super powers.\n&quot;, super_power);
    printf(&quot;I have an initial %c.\n&quot;, initial);
    printf(&quot;I have a first name %s.\n&quot;, first_name);
    printf(&quot;I have a last name %s.\n&quot;, last_name);
    printf(&quot;My whole name is %s %c. %s.\n&quot;,
            first_name, initial, last_name);

    int bugs = 100;
    double bug_rate = 1.2;

    printf(&quot;You have %d bugs at the imaginary rate of %f.\n&quot;,
            bugs, bug_rate);

    long universe_of_defects = 1L * 1024L * 1024L * 1024L;
    printf(&quot;The entire universe has %ld bugs.\n&quot;, universe_of_defects);

    double expected_bugs = bugs * bug_rate;
    printf(&quot;You are expected to have %f bugs.\n&quot;, expected_bugs);

    double part_of_universe = expected_bugs / universe_of_defects;
    printf(&quot;That is only a %e portion of the universe.\n&quot;,
            part_of_universe);

    // this makes no sense, just a demo of something weird
    char nul_byte = '\0';
    int care_percentage = bugs * nul_byte;
    printf(&quot;Which means you should care %d%%.\n&quot;, care_percentage);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Strings give us so much more fun now!</li>
<li>Crafting bad strings.</li>
<li>Messing with pointers.</li>
<li>Abusing printf.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Make the number you assign to <em>universe_of_defects</em> various
sizes until you get a warning from the compiler.</li>
<li>What do these really huge numbers actually print out?</li>
<li>Change <em>long</em> to <em>unsigned long</em> and try to find
the number that makes it too big.</li>
<li>Go search online to find out what <em>unsigned</em> does.</li>
<li>Try to explain to yourself (before I do in the next exercise)
why you can multiply a <em>char</em> and an <em>int</em>.</li>
</ul>

<h3 id="exercise-8-if-else-if-else">Exercise 8 If, Else-If, Else</h3>

<p>The Plan</p>

<p>Simply learn to use this:</p>

<pre><code>if(TEST) {
    CODE;
} else if(TEST) {
    CODE;
} else {
    CODE;
}
</code></pre>

<p>The Code</p>

<p>.\ex08\ex8.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int i = 0;

    if (argc == 1) {
        printf(&quot;You only have one argument. You suck.\n&quot;);
    } else if (argc &gt; 1 &amp;&amp; argc &lt; 4) {
        printf(&quot;Here's your arguments:\n&quot;);

        for (i = 0; i &lt; argc; i++) {
            printf(&quot;%s &quot;, argv[i]);
        }
        printf(&quot;\n&quot;);
    } else if (argc &gt; 10) {
        printf(&quot;You have too many arguments. You suck.\n&quot;);
    }

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>It kind of just works, but remove the <em>else</em> and change the logic.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>You were briefly introduced to <em>&amp;&amp;</em>, which does an <em>and</em> comparison,
so go research online the different <em>Boolean operators</em>.</li>
<li>Write a few more test cases for this program to see what you can come
up with.</li>
</ul>

<h3 id="exercise-9-while-loop-and-boolean-expressions">Exercise 9 While-Loop and Boolean Expressions</h3>

<p>The Plan</p>

<p>You first loop shall be the <em>while</em>:</p>

<pre><code>while(TEST) {
    CODE;
}
</code></pre>

<p>The Code</p>

<p>.\ex09\ex9.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int i;
    while (i &lt; 25) {
        printf(&quot;%d\n&quot;, i);
        i++;
    }

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Forget to initialize the <em>int i</em>.</li>
<li>Forget to do an i++ and make it run forever.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Make the loop count backward by using <code>i--</code> to start
at 25 and go to 0.</li>
<li>Write a few more complex <code>while-loops</code> using what you know
so far.</li>
</ul>

<h3 id="exercise-10-switch-statements">Exercise 10 Switch Statements</h3>

<p>The Plan</p>

<ul>
<li>Learn about the <em>switch-statement</em> and indirectly jump tables.</li>
<li>Write a program that takes a command line argument.</li>
</ul>

<p>The Code</p>

<p>.\ex10\ex10.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    if (argc != 2) {
        printf(&quot;ERROR: You need one argument.\n&quot;);
        // this is how you abort a program
        return 1;
    }

    int i = 0;
    for (i = 0; argv[1][i] != '\0'; i++) {
        char letter = argv[1][i];

        switch (letter) {
            case 'a':
            case 'A':
                printf(&quot;%d: 'A'\n&quot;, i);
                break;

            case 'e':
            case 'E':
                printf(&quot;%d: 'E'\n&quot;, i);
                break;

            case 'i':
            case 'I':
                printf(&quot;%d: 'I'\n&quot;, i);
                break;

            case 'o':
            case 'O':
                printf(&quot;%d: 'O'\n&quot;, i);
                break;

            case 'u':
            case 'U':
                printf(&quot;%d: 'U'\n&quot;, i);
                break;

            case 'y':
            case 'Y':
                if (i &gt; 2) {
                    // it's only sometimes Y
                    printf(&quot;%d: 'Y'\n&quot;, i);
                }
                break;

            default:
                printf(&quot;%d: %c is not a vowel\n&quot;, i, letter);
        }
    }

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Let&rsquo;s talk about jump tables, in the naive sense.</p>

<p>Breaking It</p>

<ul>
<li>Forget a <em>break</em>, and it&rsquo;ll run two or more blocks of code you don&rsquo;t want it to run.</li>
<li>Forget a <em>default</em>, and it&rsquo;ll silently ignore values you forgot.</li>
<li>Accidentally put a variable into the <em>switch</em> that evaluates to something unexpected, like an <em>int</em>, which becomes weird values.</li>
<li>Use uninitialized values in the <em>switch</em>.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Write another program that uses math on the letter to
convert it to lowercase, and then remove all of the extraneous
uppercase letters in the switch.</li>
<li>Use the <em>&rsquo;,&rsquo;</em> (comma) to initialize <em>letter</em>
in the <em>for-loop</em>.</li>
<li>Make it handle all of the arguments you pass it with
yet another <em>for-loop</em>.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Convert this <em>switch-statement</em> to an <em>if-statement</em>.
Which do you like better?</li>
<li>In the case for &lsquo;Y&rsquo; I have the break outside of the <em>if-statement</em>. What&rsquo;s the impact of this,
and what happens if you move it inside of the <em>if-statement</em>. Prove to yourself that you&rsquo;re right.</li>
</ul>

<h3 id="exercise-11-arrays-and-strings">Exercise 11 Arrays and Strings</h3>

<p>The Plan</p>

<ul>
<li>Learn the similarity between arrays and strings.</li>
<li>Avoid getting pedantic about them.</li>
<li>Learn how C stores strings and processes them.</li>
</ul>

<p>The Code</p>

<p>.\ex11\ex11.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int numbers[4] = { 0 };
    char name[4] = { 'a', 'a', 'a', 'a' };

    // first, print them out raw
    printf(&quot;numbers: %d %d %d %d\n&quot;,
            numbers[0], numbers[1], numbers[2], numbers[3]);

    printf(&quot;name each: %c %c %c %c\n&quot;,
            name[0], name[1], name[2], name[3]);

    printf(&quot;name: %s\n&quot;, name);

    // setup the numbers
    numbers[0] = 1;
    numbers[1] = 2;
    numbers[2] = 3;
    numbers[3] = 4;

    // setup the name
    name[0] = 'Z';
    name[1] = 'e';
    name[2] = 'd';
    name[3] = 'A';

    // then print them out initialized
    printf(&quot;numbers: %d %d %d %d\n&quot;,
            numbers[0], numbers[1], numbers[2], numbers[3]);

    printf(&quot;name each: %c %c %c %c\n&quot;,
            name[0], name[1], name[2], name[3]);

    // print the name like a string
    printf(&quot;name: %s\n&quot;, name);

    // another way to use name
    char *another = &quot;Zed&quot;;

    printf(&quot;another: %s\n&quot;, another);

    printf(&quot;another each: %c %c %c %c\n&quot;,
            another[0], another[1], another[2], another[3]);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<p>So many ways to break this!</p>

<ul>
<li>Get rid of the initializers that set up <em>name</em>.</li>
<li>Accidentally set <em>name[3] = &lsquo;A&rsquo;;</em> so that there&rsquo;s no terminator.</li>
<li>Set the initializer to <em>{&lsquo;a&rsquo;,&lsquo;a&rsquo;,&lsquo;a&rsquo;,&lsquo;a&rsquo;}</em> so that there are too many
&lsquo;a&rsquo; characters and no space for the <em>&lsquo;\0&rsquo;</em> terminator.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Assign the characters into <em>numbers</em>, and then use <em>printf</em>
to print them one character at a time.  What kind of compiler warnings
do you get?</li>
<li>Do the inverse for <em>name</em>, trying to treat it like an array
of <em>int</em> and print it out one <em>int</em> at a time.  What
does the debugger think of that?</li>
<li>In how many other ways can you print this out?</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>If an array of characters is 4 bytes long, and an integer is 4 bytes
long, then can you treat the whole <em>name</em> array like it&rsquo;s just
an integer?  How might you accomplish this crazy hack?</li>
<li>Take out a piece of paper and draw each of these arrays as a
row of boxes. Then do the operations you just did on paper to see
if you get them right.</li>
<li>Convert <em>name</em> to be in the style of <em>another</em> and see
if the code keeps working.</li>
</ul>

<h3 id="exercise-12-sizes-and-arrays">Exercise 12 Sizes and Arrays</h3>

<p>The Plan</p>

<ul>
<li>Learn about <em>sizeof</em> and how it relates to arrays.</li>
</ul>

<p>The Code</p>

<p>.\ex12\ex12.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int areas[] = { 10, 12, 13, 14, 20 };
    char name[] = &quot;Zed&quot;;
    char full_name[] = {
        'Z', 'e', 'd',
        ' ', 'A', '.', ' ',
        'S', 'h', 'a', 'w' 
    };

    // WARNING: On some systems you may have to change the
    // %ld in this code to a %u since it will use unsigned ints
    printf(&quot;The size of an int: %ld\n&quot;, sizeof(int));
    printf(&quot;The size of areas (int[]): %ld\n&quot;, sizeof(areas));
    printf(&quot;The number of ints in areas: %ld\n&quot;,
            sizeof(areas) / sizeof(int));
    printf(&quot;The first area is %d, the 2nd %d.\n&quot;, areas[0], areas[1]);

    printf(&quot;The size of a char: %ld\n&quot;, sizeof(char));
    printf(&quot;The size of name (char[]): %ld\n&quot;, sizeof(name));
    printf(&quot;The number of chars: %ld\n&quot;, sizeof(name) / sizeof(char));

    printf(&quot;The size of full_name (char[]): %ld\n&quot;, sizeof(full_name));
    printf(&quot;The number of chars: %ld\n&quot;,
            sizeof(full_name) / sizeof(char));

    full_name[12] = 'X';

    printf(&quot;name=\&quot;%s\&quot; and full_name=\&quot;%s\&quot;\n&quot;, name, full_name);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Get rid of the <em>&lsquo;\0&rsquo;</em> at the end of <em>full_name</em>
and re-run it.  Run it under the debugger, too.  Now, move the definition
of <em>full_name</em> to the top of <em>main</em> before <em>areas</em>.
Try running it under the debugger a few times and see if you get some
new errors.  In some cases, you might still get lucky and not catch
any errors.</li>
<li>Change it so that instead of <em>areas[0]</em> you try to
print <em>areas[10]</em>.  See what the debugger thinks of that.</li>
<li>Try other ways to break it like this, doing it to <em>name</em> and
<em>full_name</em> too.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Try assigning to elements in the <em>areas</em> array with <em>areas[0] = 100;</em> and similar.</li>
<li>Try assigning to elements of <em>name</em> and <em>full_name</em>.</li>
<li>Try setting one element of <em>areas</em> to a character from <em>name</em>.</li>
<li>Search online for the different sizes used for integers on different
CPUs.</li>
</ul>

<h3 id="exercise-13-for-loops-and-arrays-of-strings">Exercise 13 For-Loops and Arrays of Strings</h3>

<p>The Plan</p>

<p>Learn about this code:</p>

<pre><code>for(INITIALIZER; TEST; INCREMENTER) {
    CODE;
}
</code></pre>

<p>The Code</p>

<p>.\ex13\ex13.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int i = 0;

    // go through each string in argv
    // why am I skipping argv[0]?
    for (i = 0; i &lt; argc; i++) {
        printf(&quot;arg %d: %s\n&quot;, i, argv[i]);
    }

    // let's make our own array of strings
    char *states[] = {
        &quot;California&quot;, &quot;Oregon&quot;,
        &quot;Washington&quot;, &quot;Texas&quot;
    };

    int num_states = 5;

    for (i = 0; i &lt; num_states; i++) {
        printf(&quot;state %d: %s\n&quot;, i, states[i]);
    }

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Take your favorite other language and use it to run this program, but include as many command line arguments as possible.  See if you can bust it
by giving it way too many arguments.</li>
<li>Initialize <em>i</em> to 0 and see what that does.  Do you have to adjust
<em>argc</em> as well, or does it just work?  Why does 0-based indexing work
here?</li>
<li>Set <em>num_states</em> wrong so that it&rsquo;s a higher value and see what
it does.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Figure out what kind of code you can put into the parts of a <em>for-loop</em>.</li>
<li>Look up how to use the comma character (,) to separate multiple
statements in the parts of the <em>for-loop</em>, but between the semicolon characters (;).</li>
<li>Read what a <em>NULL</em> is and try to use it in one of the elements from the
<em>states</em> array to see what it&rsquo;ll print.</li>
<li>See if you can assign an element from the <em>states</em> array to the
<em>argv</em> array before printing both.  Try the inverse.</li>
</ul>

<h3 id="exercise-14-writing-and-using-functions">Exercise 14 Writing and Using Functions</h3>

<p>The Plan</p>

<ul>
<li>Write your very first functions.</li>
</ul>

<p>The Code</p>

<p>.\ex14\ex14.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

// forward declarations
int can_print_it(char ch);
void print_letters(char arg[]);

void print_arguments(int argc, char *argv[])
{
    int i = 0;

    for (i = 0; i &lt; argc; i++) {
        print_letters(argv[i]);
    }
}

void print_letters(char arg[])
{
    int i = 0;

    for (i = 0; arg[i] != '\0'; i++) {
        char ch = arg[i];

        if (can_print_it(ch)) {
            printf(&quot;'%c' == %d &quot;, ch, ch);
        }
    }

    printf(&quot;\n&quot;);
}

int can_print_it(char ch)
{
    return isalpha(ch) || isblank(ch);
}

int main(int argc, char *argv[])
{
    print_arguments(argc+1, argv);
    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Remove the forward declarations to confuse the compiler and cause it to complains about <em>can_print_it</em> and <em>print_letters</em>.</li>
<li>When you call <em>print_arguments</em> inside <em>main</em>, try
adding 1 to <em>argc</em> so that it goes past the end of the
<em>argv</em> array.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Rework these functions so that you have fewer functions.  For example,
do you really need <em>can_print_it</em>?</li>
<li>Have <em>print_arguments</em> figure out how long each argument string
is by using the <em>strlen</em> function, and then pass that length
to <em>print_letters</em>.  Then, rewrite <em>print_letters</em>
so it only processes this fixed length and doesn&rsquo;t rely on the
<em>&lsquo;\0&rsquo;</em> terminator.  You&rsquo;ll need the <em>#include <string.h></em> for this.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Use <em>man</em> to look up information on <em>isalpha</em>
and <em>isblank</em>.  Use other similar functions to
print out only digits or other characters.</li>
<li>Go read about how other people like to format their
functions.  Never use the <em>K&amp;R syntax</em> (it&rsquo;s antiquated and
confusing) but understand what it&rsquo;s doing in case you run
into someone who likes it.</li>
</ul>

<h3 id="exercise-15-pointers-dreaded-pointers">Exercise 15 Pointers, Dreaded Pointers</h3>

<p>The Plan</p>

<ul>
<li>A long video on C pointers.</li>
<li>Lots of demonstration and visuals.</li>
</ul>

<p>The Code</p>

<p>.\ex15\ex15.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    // create two arrays we care about
    int ages[] = { 23, 43, 12, 89, 2 };
    char *names[] = {
        &quot;Alan&quot;, &quot;Frank&quot;,
        &quot;Mary&quot;, &quot;John&quot;, &quot;Lisa&quot;
    };

    // safely get the size of ages
    int count = sizeof(ages) / sizeof(int);
    int i = 0;

    // first way using indexing
    for (i = 0; i &lt; count; i++) {
        printf(&quot;%s has %d years alive.\n&quot;, names[i], ages[i]);
    }

    printf(&quot;---\n&quot;);

    // setup the pointers to the start of the arrays
    int *cur_age = (int *)names;
    char **cur_name = names;

    // second way using pointers
    for (i = 0; i &lt; count; i++) {
        printf(&quot;%s is %d years old.\n&quot;,
                *(cur_name + i), *(cur_age + i));
    }

    printf(&quot;---\n&quot;);

    // third way, pointers are just arrays
    for (i = 0; i &lt; count; i++) {
        printf(&quot;%s is %d years old again.\n&quot;, cur_name[i], cur_age[i]);
    }

    printf(&quot;---\n&quot;);

    // fourth way with pointers in a stupid complex way
    for (cur_name = names, cur_age = ages;
            (cur_age - ages) &lt; count; cur_name++, cur_age++) {
        printf(&quot;%s lived %d years so far.\n&quot;, *cur_name, *cur_age);
    }

    return 0;
}

</code></pre>

<p>The Pointer Lexicon</p>

<pre><code>type *ptr A pointer of type named ptr
*ptr The value of whatever ptr is pointed at
*(ptr + i) The value of (whatever ptr is pointed at plus i)
&amp;thing The address of thing
type *ptr = &amp;thing A pointer of type named ptr set to the address of thing
ptr++ Increment where ptr points
</code></pre>

<p>Pointers Visually</p>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Try to make <em>cur_age</em> point at <em>names</em>.  You&rsquo;ll need to
use a C cast to force it, so go look that up and try to figure it out.</li>
<li>In the final <em>for-loop</em>, try getting the math wrong in weird ways.</li>
<li>Try rewriting the loops so that they start at the end of the arrays and go
to the beginning.  This is harder than it looks.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Rewrite all of the arrays in this program as pointers.</li>
<li>Rewrite all of the pointers as arrays.</li>
<li>Go back to some of the other programs that use arrays and
try to use pointers instead.</li>
<li>Process command line arguments using just pointers similar to how
you did <em>names</em> in this one.</li>
<li>Play with combinations of getting the value of and the address of
things.</li>
<li>Add another <em>for-loop</em> at the end that prints out the
addresses that these pointers are using.  You&rsquo;ll need the <em>%p</em> format
for <em>printf</em>.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Rewrite this program to use a function for each of the ways you&rsquo;re
printing out things.  Try to pass pointers to these functions so that
they work on the data.  Remember you can declare a function to accept
a pointer, but just use it like an array.</li>
<li>Change the <em>for-loops</em> to <em>while-loops</em> and see what
works better for which kind of pointer usage.</li>
</ul>

<h3 id="exercise-16-structs-and-pointers-to-them">Exercise 16 Structs And Pointers To Them</h3>

<p>The Plan</p>

<ul>
<li>Learn to work with <em>structs</em> to structure data and make new types.</li>
<li>Learn to use pointers to work with <em>structs</em> better.</li>
</ul>

<p>The Code</p>

<p>.\ex16\ex16.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct Person {
    char *name;
    int age;
    int height;
    int weight;
};

struct Person *Person_create(char *name, int age, int height,
        int weight)
{
    struct Person *who = malloc(sizeof(struct Person));
    assert(who != NULL);

    who-&gt;name = strdup(name);
    who-&gt;age = age;
    who-&gt;height = height;
    who-&gt;weight = weight;

    return who;
}

void Person_destroy(struct Person *who)
{
    assert(who != NULL);

    free(who-&gt;name);
    free(who);
}

void Person_print(struct Person *who)
{
    printf(&quot;Name: %s\n&quot;, who-&gt;name);
    printf(&quot;\tAge: %d\n&quot;, who-&gt;age);
    printf(&quot;\tHeight: %d\n&quot;, who-&gt;height);
    printf(&quot;\tWeight: %d\n&quot;, who-&gt;weight);
}

int main(int argc, char *argv[])
{
    // make two people structures
    struct Person *joe = Person_create(&quot;Joe Alex&quot;, 32, 64, 140);

    struct Person *frank = Person_create(&quot;Frank Blank&quot;, 20, 72, 180);

    // print them out and where they are in memory
    printf(&quot;Joe is at memory location %p:\n&quot;, joe);
    Person_print(joe);

    printf(&quot;Frank is at memory location %p:\n&quot;, frank);
    Person_print(frank);

    // make everyone age 20 years and print them again
    joe-&gt;age += 20;
    joe-&gt;height -= 2;
    joe-&gt;weight += 40;
    Person_print(joe);

    frank-&gt;age += 20;
    frank-&gt;weight += 20;
    free(frank);
    Person_print(frank);

    // destroy them both so we clean up
    Person_destroy(joe);
    Person_destroy(frank);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Try passing <em>NULL</em> to <em>Person_destroy</em> see what
it does.  If it doesn&rsquo;t abort, then you must not have the
<em>-g</em> option in your Makefile&rsquo;s <em>CFLAGS</em>.</li>
<li>Forget to call <em>Person_destroy</em> at the end, and then run
it under the debugger to see it report that you forgot
to free the memory.  Figure out the options you need to pass
to the debugger to get it to print how you leaked
this memory.</li>
</ul>

<p>Breaking It</p>

<ul>
<li>Forget to free <em>who-&gt;name</em> in <em>Person_destroy</em>
and compare the output.  Again, use the right options to
see how the debugger tells you exactly where you messed
up.</li>
<li>This time, pass <em>NULL</em> to <em>Person_print</em> and
see what the debugger thinks of that. You&rsquo;ll figure out that <em>NULL</em> is a quick way
to crash your program.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>How to create a <em>struct</em> on the <em>stack</em> just like you&rsquo;re making any other variable.</li>
<li>How to initialize it using the <em>x.y</em> (period) character
instead of the <em>x-&gt;y</em> syntax.</li>
<li>How to pass a structure to other functions without using
a pointer.</li>
</ul>

<h3 id="exercise-17-heap-and-stack-memory-allocation">Exercise 17 Heap and Stack Memory Allocation</h3>

<p>The Plan</p>

<ul>
<li>Learn to allocate data on the heap using <em>malloc</em>.</li>
<li>Memory management techniques to avoid leaking.</li>
<li>How the heap differs from the stack, and when to use them.</li>
</ul>

<p>The Code</p>

<p>.\ex17\ex17.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#define MAX_DATA 512
#define MAX_ROWS 100

struct Address {
    int id;
    int set;
    char name[MAX_DATA];
    char email[MAX_DATA];
};

struct Database {
    struct Address rows[MAX_ROWS];
};

struct Connection {
    FILE *file;
    struct Database *db;
};

void die(const char *message)
{
    if (errno) {
        perror(message);
    } else {
        printf(&quot;ERROR: %s\n&quot;, message);
    }

    exit(1);
}

void Address_print(struct Address *addr)
{
    printf(&quot;%d %s %s\n&quot;, addr-&gt;id, addr-&gt;name, addr-&gt;email);
}

void Database_load(struct Connection *conn)
{
    int rc = fread(conn-&gt;db, sizeof(struct Database), 1, conn-&gt;file);
    if (rc != 1)
        die(&quot;Failed to load database.&quot;);
}

struct Connection *Database_open(const char *filename, char mode)
{
    struct Connection *conn = malloc(sizeof(struct Connection));
    if (!conn)
        die(&quot;Memory error&quot;);

    conn-&gt;db = malloc(sizeof(struct Database));
    if (!conn-&gt;db)
        die(&quot;Memory error&quot;);

    if (mode == 'c') {
        conn-&gt;file = fopen(filename, &quot;w&quot;);
    } else {
        conn-&gt;file = fopen(filename, &quot;r+&quot;);

        if (conn-&gt;file) {
            Database_load(conn);
        }
    }

    if (!conn-&gt;file)
        die(&quot;Failed to open the file&quot;);

    return conn;
}

void Database_close(struct Connection *conn)
{
    if (conn) {
        if (conn-&gt;file)
            fclose(conn-&gt;file);
        if (conn-&gt;db)
            free(conn-&gt;db);
        free(conn);
    }
}

void Database_write(struct Connection *conn)
{
    rewind(conn-&gt;file);

    int rc = fwrite(conn-&gt;db, sizeof(struct Database), 1, conn-&gt;file);
    if (rc != 1)
        die(&quot;Failed to write database.&quot;);

    rc = fflush(conn-&gt;file);
    if (rc == -1)
        die(&quot;Cannot flush database.&quot;);
}

void Database_create(struct Connection *conn)
{
    int i = 0;

    for (i = 0; i &lt; MAX_ROWS; i++) {
        // make a prototype to initialize it
        struct Address addr = {.id = i,.set = 0 };
        // then just assign it
        conn-&gt;db-&gt;rows[i] = addr;
    }
}

void Database_set(struct Connection *conn, int id, const char *name,
        const char *email)
{
    struct Address *addr = &amp;conn-&gt;db-&gt;rows[id];
    if (addr-&gt;set)
        die(&quot;Already set, delete it first&quot;);

    addr-&gt;set = 1;
    // WARNING: bug, read the &quot;How To Break It&quot; and fix this
    char *res = strncpy(addr-&gt;name, name, MAX_DATA);
    // demonstrate the strncpy bug
    if (!res)
        die(&quot;Name copy failed&quot;);

    res = strncpy(addr-&gt;email, email, MAX_DATA);
    if (!res)
        die(&quot;Email copy failed&quot;);
}

void Database_get(struct Connection *conn, int id)
{
    struct Address *addr = &amp;conn-&gt;db-&gt;rows[id];

    if (addr-&gt;set) {
        Address_print(addr);
    } else {
        die(&quot;ID is not set&quot;);
    }
}

void Database_delete(struct Connection *conn, int id)
{
    struct Address addr = {.id = id,.set = 0 };
    conn-&gt;db-&gt;rows[id] = addr;
}

void Database_list(struct Connection *conn)
{
    int i = 0;
    struct Database *db = conn-&gt;db;

    for (i = 0; i &lt; MAX_ROWS; i++) {
        struct Address *cur = &amp;db-&gt;rows[i];

        if (cur-&gt;set) {
            Address_print(cur);
        }
    }
}

int main(int argc, char *argv[])
{
    if (argc &lt; 3)
        die(&quot;USAGE: ex17 &lt;dbfile&gt; &lt;action&gt; [action params]&quot;);

    char *filename = argv[1];
    char action = argv[2][0];
    struct Connection *conn = Database_open(filename, action);
    int id = 0;

    if (argc &gt; 3) id = atoi(argv[3]);
    if (id &gt;= MAX_ROWS) die(&quot;There's not that many records.&quot;);

    switch (action) {
        case 'c':
            Database_create(conn);
            Database_write(conn);
            break;

        case 'g':
            if (argc != 4)
                die(&quot;Need an id to get&quot;);

            Database_get(conn, id);
            break;

        case 's':
            if (argc != 6)
                die(&quot;Need id, name, email to set&quot;);

            Database_set(conn, id, argv[4], argv[5]);
            Database_write(conn);
            break;

        case 'd':
            if (argc != 4)
                die(&quot;Need id to delete&quot;);

            Database_delete(conn, id);
            Database_write(conn);
            break;

        case 'l':
            Database_list(conn);
            break;
        default:
            die(&quot;Invalid action: c=create, g=get, s=set, d=del, l=list&quot;);
    }

    Database_close(conn);

    return 0;
}

</code></pre>

<pre><code class="language-bash">$ make ex1. cc -Wall ­g ex17.c -o ex1. 
$ ./ex17 db.dat c 
$ ./ex17 db.dat s 1 zed zed@zedshaw.com 
$ ./ex17 db.dat s 2 frank frank@zedshaw.com$ 
$ ./ex17 db.dat s 3 joe joe@zedshaw.com 
$ 
$ ./ex17 db.dat l 
1 zed zed@zedshaw.com 
2 frank frank@zedshaw.com 
3 joe joe@zedshaw.com 

$ ./ex17 db.dat d 3 
$ ./ex17 db.dat l 
1 zed zed@zedshaw.com 
2 frank frank@zedshaw.com 

$ ./ex17 db.dat g 2 
2 frank frank@zedshaw.com 
</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>The classic way is to remove some of the safety checks so that you can
pass in arbitrary data. For example, remove the check on line 160
that prevents you from passing in any record number.</li>
<li>You can also try corrupting the data file.  Open it in any editor and
change random bytes, and then close it.</li>
<li>You could also find ways to pass bad arguments to the program when it&rsquo;s
run. For example, getting the file and action backwards will make it create
a file named after the action, and then do an action based on the first
character.</li>
</ul>

<p>Breaking It</p>

<ul>
<li>There&rsquo;s a bug in this program because <em>strncpy</em> is poorly
designed.  Go read about <em>strncpy</em> and try to find out what happens
when the <em>name</em> or <em>address</em> you give is <em>greater</em> than
512 bytes.  Fix this by simply forcing the last character to <em>&lsquo;\0&rsquo;</em>
so that it&rsquo;s always set no matter what (which is what strncpy should do).</li>
<li>In the extra credit, I have you augment the program to create arbitrary
size databases.  Try to see what the biggest database is before you
cause the program to die due to lack of memory from <em>malloc</em>.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>The <em>die</em> function needs to be augmented to let you pass the <em>conn</em>
variable, so it can close it and clean up.</li>
<li>Change the code to accept parameters for <em>MAX_DATA</em> and <em>MAX_ROWS</em>, store them in the <em>Database</em> struct, and write that to the file, thus creating
a database that can be arbitrarily sized.</li>
<li>Add more operations you can do with the database, like <em>find</em>.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Read about how C does it&rsquo;s struct packing, and then try to see why your
file is the size it is.  See if you can calculate a new size after adding
more fields.</li>
<li>Add some more fields to <em>Address</em> and make them searchable.</li>
<li>Write a shell script that will do your testing automatically for you
by running commands in the right order.  Hint: Use <em>set -e</em> at the
top of a <em>bash</em> to make it abort the whole script if any command
has an error.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Try reworking the program to use a single global for the database connection.
How does this new version of the program compare to the other one?</li>
<li>Go research stack data structure and write one in your favorite language,
then try to do it in C.</li>
</ul>

<h3 id="exercise-18-pointers-to-functions">Exercise 18 Pointers to Functions</h3>

<p>The Plan</p>

<ul>
<li>Advanced topic of pointers to functions.</li>
<li>These are very useful but not encountered too often.</li>
</ul>

<p>The Code</p>

<p>.\ex18\ex18.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

/** Our old friend die from ex17. */
void die(const char *message)
{
    if (errno) {
        perror(message);
    } else {
        printf(&quot;ERROR: %s\n&quot;, message);
    }

    exit(1);
}

// a typedef creates a fake type, in this
// case for a function pointer
typedef int (*compare_cb) (int a, int b);

/**
 * A classic bubble sort function that uses the 
 * compare_cb to do the sorting. 
 */
int *bubble_sort(int *numbers, int count, compare_cb cmp)
{
    int temp = 0;
    int i = 0;
    int j = 0;
    int *target = malloc(count * sizeof(int));

    if (!target)
        die(&quot;Memory error.&quot;);

    memcpy(target, numbers, count * sizeof(int));

    for (i = 0; i &lt; count; i++) {
        for (j = 0; j &lt; count - 1; j++) {
            if (cmp(target[j], target[j + 1]) &gt; 0) {
                temp = target[j + 1];
                target[j + 1] = target[j];
                target[j] = temp;
            }
        }
    }

    return target;
}

int sorted_order(int a, int b)
{
    return a - b;
}

int reverse_order(int a, int b)
{
    return b - a;
}

int strange_order(int a, int b)
{
    if (a == 0 || b == 0) {
        return 0;
    } else {
        return a % b;
    }
}

/** 
 * Used to test that we are sorting things correctly
 * by doing the sort and printing it out.
 */
void test_sorting(int *numbers, int count, compare_cb cmp)
{
    int i = 0;
    int *sorted = bubble_sort(numbers, count, cmp);

    if (!sorted)
        die(&quot;Failed to sort as requested.&quot;);

    for (i = 0; i &lt; count; i++) {
        printf(&quot;%d &quot;, sorted[i]);
    }
    printf(&quot;\n&quot;);

    free(sorted);
}

void destroy(compare_cb cmp)
{
    int i = 0;

    unsigned char *data = (unsigned char *)cmp;

    for(i = 0; i &lt; 1; i++) {
        data[i] = i;
    }

    printf(&quot;\n&quot;);
}

void dump(compare_cb cmp)
{
    int i = 0;

    unsigned char *data = (unsigned char *)cmp;

    for(i = 0; i &lt; 25; i++) {
        printf(&quot;%02x:&quot;, data[i]);
    }

    printf(&quot;\n&quot;);
}

int main(int argc, char *argv[])
{
    if (argc &lt; 2) die(&quot;USAGE: ex18 4 3 1 5 6&quot;);

    int count = argc - 1;
    int i = 0;
    char **inputs = argv + 1;

    int *numbers = malloc(count * sizeof(int));
    if (!numbers) die(&quot;Memory error.&quot;);

    for (i = 0; i &lt; count; i++) {
        numbers[i] = atoi(inputs[i]);
    }

    test_sorting(numbers, count, sorted_order);
    test_sorting(numbers, count, reverse_order);
    test_sorting(numbers, count, strange_order);

    free(numbers);

    printf(&quot;SORTED:&quot;);
    dump(sorted_order);

    destroy(sorted_order);

    printf(&quot;SORTED:&quot;);
    dump(sorted_order);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<p>Let&rsquo;s hack your computer with this code:</p>

<pre><code>unsigned char *data = (unsigned char *)cmp;

for(i = 0; i &lt; 25; i++) {
    printf(&quot;%02x:&quot;, data[i]);
}

printf(&quot;\n&quot;);
</code></pre>

<p>You&rsquo;ll see how the bytes of code that make up your program can also be data.</p>

<p>Extra Credit</p>

<ul>
<li>Get a hex editor and open up <em>ex18</em>, and then find the sequence
of hex digits that start a function to see if you can find the function
in the raw program.</li>
<li>Find other random things in your hex editor and change them.  Rerun your
program and see what happens.  Strings you find are the easiest
things to change.</li>
<li>Pass in the wrong function for the <em>compare_cb</em> and see what
the C compiler complains about.</li>
<li>Pass in NULL and watch your program seriously bite it.  Then, run
the debugger and see what that reports.</li>
<li>Write another sorting algorithm, then change <em>test_sorting</em> so
that it takes <em>both</em> an arbitrary sort function and the sort function&rsquo;s
callback comparison.  Use it to test both of your algorithms.</li>
</ul>

<h3 id="exercise-19-zed-s-awesome-debug-macros">Exercise 19 Zed&rsquo;s Awesome Debug Macros</h3>

<p>The Plan</p>

<ul>
<li>Learn about the macros that vastly improve my code quality.</li>
<li>Find out why they help you out.</li>
<li>Explore some advanced C Pre-Processor (CPP) macro magic code generation tricks.</li>
</ul>

<p>The Code</p>

<p>.\ex19\ex19.c</p>

<pre><code class="language-c">
#include &quot;dbg.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void test_debug()
{
    // notice you don't need the \n
    debug(&quot;I have Brown Hair.&quot;);

    // passing in arguments like printf
    debug(&quot;I am %d years old.&quot;, 37);
}

void test_log_err()
{
    log_err(&quot;I believe everything is broken.&quot;);
    log_err(&quot;There are %d problems in %s.&quot;, 0, &quot;space&quot;);
}

void test_log_warn()
{
    log_warn(&quot;You can safely ignore this.&quot;);
    log_warn(&quot;Maybe consider looking at: %s.&quot;, &quot;/etc/passwd&quot;);
}

void test_log_info()
{
    log_info(&quot;Well I did something mundane.&quot;);
    log_info(&quot;It happened %f times today.&quot;, 1.3f);
}

int test_check(char *file_name)
{
    FILE *input = NULL;
    char *block = NULL;

    block = malloc(100);
    check_mem(block);        // should work

    input = fopen(file_name, &quot;r&quot;);
    check(input, &quot;Failed to open %s.&quot;, file_name);

    free(block);
    fclose(input);
    return 0;

error:
    if (block) free(block);
    if (input) fclose(input);
    return -1;
}

int test_sentinel(int code)
{
    char *temp = malloc(100);
    check_mem(temp);

    switch (code) {
        case 1:
            log_info(&quot;It worked.&quot;);
            break;
        default:
            sentinel(&quot;I shouldn't run.&quot;);
    }

    free(temp);
    return 0;

error:
    if (temp)
        free(temp);
    return -1;
}

int test_check_mem()
{
    char *test = NULL;
    check_mem(test);

    free(test);
    return 1;

error:
    return -1;
}

int test_check_debug()
{
    int i = 0;
    check_debug(i != 0, &quot;Oops, I was 0.&quot;);

    return 0;
error:
    return -1;
}

int main(int argc, char *argv[])
{
    check(argc == 2, &quot;Need an argument.&quot;);

    test_debug();
    test_log_err();
    test_log_warn();
    test_log_info();

    check(test_check(&quot;ex20.c&quot;) == 0, &quot;failed with ex20.c&quot;);
    check(test_check(argv[1]) == -1, &quot;failed with argv&quot;);
    check(test_sentinel(1) == 0, &quot;test_sentinel failed.&quot;);
    check(test_sentinel(100) == -1, &quot;test_sentinel failed.&quot;);
    check(test_check_mem() == -1, &quot;test_check_mem failed.&quot;);
    check(test_check_debug() == -1, &quot;test_check_debug failed.&quot;);

    return 0;

error:
    return 1;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<p>These macros are designed on purpose to prevent you from doing this:</p>

<pre><code>if(blah) debug(&quot;This is a thing&quot;);
else debug (&quot;This is another thing&quot;);
</code></pre>

<p>Extra Credit</p>

<ul>
<li>Put <code>#define NDEBUG</code> at the top of the file and check that all
of the debug messages go away.</li>
<li>Undo that line, and add <code>-DNDEBUG</code> to <code>CFLAGS</code> at the
top of the <code>Makefile</code>, and then recompile to see the same thing.</li>
<li>Modify the logging so that it includes the function name, as well
as the <code>file:line</code>.</li>
</ul>

<h3 id="exercise-20-advanced-debugging-techniques">Exercise 20 Advanced Debugging Techniques</h3>

<p>The Plan</p>

<p>Demonstrate more advanced debugging techniques and tools.</p>

<p>The Demonstration</p>

<p>Extra Credit</p>

<ul>
<li>Find a graphical debugger and compare using it to raw <code>gdb</code>.
These are useful when the program you&rsquo;re looking at is local, but they
are pointless if you have to debug a program on a server.</li>
<li>You can enable core dumps on your OS, and when a program crashes,
you&rsquo;ll get a core file.  This core file is like a postmortem of
the program that you can load up to see what happened right at the crash
and what caused it.  Change <code>ex31.c</code> so that it crashes
after a few iterations, then try to get a core dump and analyze it.</li>
</ul>

<h3 id="exercise-21-advanced-data-types-and-flow-control">Exercise 21 Advanced Data Types and Flow Control</h3>

<p>The Plan</p>

<ul>
<li>Learn about the basic types and keywords for them.</li>
<li>Cover all the keywords for modifying those types.</li>
<li>Review fixed exact size types.</li>
<li>Learn all the different operators on those types.</li>
</ul>

<p>This is mostly a review!</p>

<p>Available Data Types</p>

<pre><code>int    Stores a regular integer, defaulting to 32 bits in size.
double Holds a large floating point number.
float  Holds a smaller floating point number.
char   Holds a single 1 byte character.
void   Indicates &quot;no type&quot;.
enum   Enumerated types, which work as and convert to integers.
</code></pre>

<p>Type Modifiers</p>

<pre><code>unsigned  Non-negative numbers.
signed    Gives you negative and positive numbers.
long      Bigger number.
short     Smaller number.
</code></pre>

<p>Type Qualifiers</p>

<pre><code>const     Constant.
volatile  Compiler can't trust it.
register  Put it in a CPU register.
</code></pre>

<p>Type Conversion</p>

<p>C type promotion order:</p>

<ul>
<li>long double</li>
<li>double</li>
<li>float</li>
<li>int (but only char and short int);</li>
<li>long</li>
</ul>

<p>When in doubt, parens it out!</p>

<p>Exact Size Types</p>

<p>If you need exact sizes use these:</p>

<pre><code>int8_t   8-bit signed integer
uint8_t  8-bit unsigned integer
int16_t  16-bit signed integer
uint16_t 16-bit unsigned integer
int32_t  32-bit signed integer
uint32_t 32-bit unsigned integer
int64_t  64-bit signed integer
uint64_t 64-bit unsigned integer
</code></pre>

<p>Getting Sizes</p>

<p>Refer to the book as there&rsquo;s a large number of
macros to help you get size information for types.</p>

<p>Examples:</p>

<pre><code>int_least32_t  int that holds at least 32 bits.
uint_fast32_t  unsigned fastest int for 32 bits.
intptr_t       signed int that can hold a pointer.
PTRDIFF_MAX    maximum value of ptrdiff_t
SIZE_MAX       maximum value of a size_t
</code></pre>

<p>Available Operators</p>

<p>This section is a review of what you memorized already
to make sure you know everything.</p>

<p>Memorize these again to be sure you have them.</p>

<p>Extra Credit</p>

<ul>
<li>Read stdint.h or a description of it, and write out all the
available size identifiers.</li>
<li>Go through each item here and write out what it does in code.  Research it online so you know you got it right.</li>
<li>Get this information memorized by making flash cards and spending 15
minutes a day practicing it.</li>
<li>Create a program that prints out examples of each type, and confirm that your
research is right.</li>
</ul>

<h3 id="exercise-22-the-stack-scope-and-globals">Exercise 22 The Stack, Scope, and Globals</h3>

<p>The Plan</p>

<ul>
<li>Start to learn about scope.</li>
<li>Stack vs. global.</li>
<li>Scope levels inside a function.</li>
<li>The <em>extern</em> keyword.</li>
</ul>

<p>The Code</p>

<p>.\ex22\ex22.h</p>

<pre><code class="language-c">#ifndef _ex22_h
#define _ex22_h

struct State {
    int the_size;
    int the_age;
};

// gets and sets an internal static variable in ex22.c
int get_age(struct State *state);
void set_age(struct State *state, int age);

// updates a static variable that's inside update_ratio
double update_ratio(double ratio);

void print_size();

#endif

</code></pre>

<p>.\ex22\ex22.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;ex22.h&quot;
#include &quot;dbg.h&quot;

int get_age(struct State *state)
{
    return state-&gt;the_age;
}

void set_age(struct State *state, int age)
{
   state-&gt;the_age = age; 
}

double update_ratio(double new_ratio)
{
    static double ratio = 1.0;

    double old_ratio = ratio;
    ratio = new_ratio;

    return old_ratio;
}

void print_size()
{
    log_info(&quot;I think size is: %d&quot;, THE_SIZE);
}

</code></pre>

<p>.\ex22\ex22_main.c</p>

<pre><code class="language-c">#include &quot;ex22.h&quot;
#include &quot;dbg.h&quot;

const char *MY_NAME = &quot;Zed A. Shaw&quot;;

void scope_demo(int count)
{
    log_info(&quot;count is: %d&quot;, count);

    if (count &gt; 10) {
        int numbers = 100;    // BAD! BUGS!

        log_info(&quot;count in this scope is %d&quot;, numbers);
    }

    log_info(&quot;count is at exit: %d&quot;, count);

    count = 3000;

    log_info(&quot;count after assign: %d&quot;, count);
}

int main(int argc, char *argv[])
{
    // test out THE_AGE accessors
    log_info(&quot;My name: %s, age: %d&quot;, MY_NAME, get_age());

    set_age(100);

    log_info(&quot;My age is now: %d&quot;, get_age());

    // test out THE_SIZE extern
    log_info(&quot;THE_SIZE is: %d&quot;, THE_SIZE);
    print_size();

    THE_SIZE = 9;

    log_info(&quot;THE SIZE is now: %d&quot;, THE_SIZE);
    print_size();

    // test the ratio function static
    log_info(&quot;Ratio at first: %f&quot;, update_ratio(2.0));
    log_info(&quot;Ratio again: %f&quot;, update_ratio(10.0));
    log_info(&quot;Ratio once more: %f&quot;, update_ratio(300.0));

    // test the scope demo
    int count = 4;
    scope_demo(count);
    scope_demo(count * 20);

    log_info(&quot;count after calling scope_demo: %d&quot;, count);

    return 0;
}

</code></pre>

<p>This exercises requires two files:</p>

<pre><code>* ex22.c
* ex22_main.c
</code></pre>

<p>The Analysis</p>

<p>Fixing It</p>

<p>Instead of breaking this one I&rsquo;m going to fix it.</p>

<ul>
<li>Do not shadow a variable like <em>count</em> on ex22_main.c:11.</li>
<li>Avoid using too many globals.</li>
<li>When in doubt, put it on the heap (malloc).</li>
<li>Don&rsquo;t use function static variables like I did in ex22.c:update_ratio.</li>
<li>Avoid reusing function parameters.</li>
</ul>

<p>Breaking It</p>

<ul>
<li>Try to directly access variables in <code>ex22.c</code> from <code>ex22_main.c</code>
that you think you can&rsquo;t.  For example, can you get at <code>ratio</code>
inside <code>update_ratio</code>? What if you had a pointer to it?</li>
<li>Ditch the <code>extern</code> declaration in <code>ex22.h</code> to see what
errors or warnings you get.</li>
<li>Add <code>static</code> or <code>const</code> specifiers to different variables,
and then try to change them.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Research the concept of pass by value verses pass by reference.  Write an
example of both.</li>
<li>Use pointers to gain access to things you shouldn&rsquo;t have access to.</li>
<li>Use your debugger to see what this kind of access looks like when you
do it wrong.</li>
<li>Write a recursive function that causes a stack overflow.  Don&rsquo;t know
what a recursive function is?  Try calling <code>scope_demo</code> at the
bottom of <code>scope_demo</code> itself so that it loops.</li>
<li>Rewrite the <code>Makefile</code> so that it can build this.</li>
</ul>

<h3 id="exercise-23-meet-duff-s-device">Exercise 23 Meet Duff&rsquo;s Device</h3>

<p>The Plan</p>

<p>Learn the most evil awesome hack ever:</p>

<p>Duff&rsquo;s Device</p>

<p>The Code</p>

<p>.\ex23\ex23.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;dbg.h&quot;

int normal_copy(char *from, char *to, int count)
{
    int i = 0;

    for (i = 0; i &lt; count; i++) {
        to[i] = from[i];
    }

    return i;
}

int duffs_device(char *from, char *to, int count)
{
    {
        int n = (count + 7) / 8;

        switch (count % 8) {
            case 0:
                do {
                    *to++ = *from++;
                    case 7:
                    *to++ = *from++;
                    case 6:
                    *to++ = *from++;
                    case 5:
                    *to++ = *from++;
                    case 4:
                    *to++ = *from++;
                    case 3:
                    *to++ = *from++;
                    case 2:
                    *to++ = *from++;
                    case 1:
                    *to++ = *from++;
                } while (--n &gt; 0);
        }
    }

    return count;
}

int zeds_device(char *from, char *to, int count)
{
    {
        int n = (count + 7) / 8;
        debug(&quot;n starts: %d, count: %d, count%%8: %d&quot;, 
                n, count, count % 8);

        switch (count % 8) {
            case 0:
again:    *to++ = *from++;

            case 7:
          *to++ = *from++;
            case 6:
          *to++ = *from++;
            case 5:
          *to++ = *from++;
            case 4:
          *to++ = *from++;
            case 3:
          *to++ = *from++;
            case 2:
          *to++ = *from++;
            case 1:
          *to++ = *from++;
          debug(&quot;last case: n=%d&quot;, n);
          if (--n &gt; 0) {
              debug(&quot;going again: n=%d&quot;, n);
              goto again;
          }
        }
    }

    return count;
}

int valid_copy(char *data, int count, char expects)
{
    int i = 0;
    for (i = 0; i &lt; count; i++) {
        if (data[i] != expects) {
            log_err(&quot;[%d] %c != %c&quot;, i, data[i], expects);
            return 0;
        }
    }

    return 1;
}

int main(int argc, char *argv[])
{
    char from[1003] = { 'a' };
    char to[1003] = { 'c' };
    int rc = 0;

    // setup the from to have some stuff
    memset(from, 'x', 1003);
    // set it to a failure mode
    memset(to, 'y', 1003);
    check(valid_copy(to, 1003, 'y'), &quot;Not initialized right.&quot;);

    // use normal copy to 
    rc = normal_copy(from, to, 1003);
    check(rc == 1003, &quot;Normal copy failed: %d&quot;, rc);
    check(valid_copy(to, 1003, 'x'), &quot;Normal copy failed.&quot;);

    // reset
    memset(to, 'y', 1003);

    // duffs version
    rc = duffs_device(from, to, 1003);
    check(rc == 1003, &quot;Duff's device failed: %d&quot;, rc);
    check(valid_copy(to, 1003, 'x'), &quot;Duff's device failed copy.&quot;);

    // reset
    memset(to, 'y', 1003);

    // my version
    rc = zeds_device(from, to, 1003);
    check(rc == 1003, &quot;Zed's device failed: %d&quot;, rc);
    check(valid_copy(to, 1003, 'x'), &quot;Zed's device failed copy.&quot;);

    return 0;
error:
    return 1;
}

</code></pre>

<p>Remember that this is <em>bad</em> code.
It&rsquo;s very interesting though, so struggle with it.</p>

<p>The Analysis</p>

<p>Before you continue, try to figure out what this does.
Consider it a debugging problem.</p>

<p>Clues</p>

<ul>
<li>Print this code out so that you can write on some paper.</li>
<li>Write each of the variables in a table as they
look when they get initialized right before the <code>switch-statement</code>.</li>
<li>Follow the logic to the switch, then do the jump to the right case.</li>
<li>Update the variables, including the <code>to</code>, <code>from</code>, and the
arrays they point at.</li>
</ul>

<p>Clues</p>

<ul>
<li>When you get to the <code>while</code> part or my <code>goto</code> alternative,
check your variables, and then follow the logic either back to the
top of the <code>do-while</code> or to where the <code>again</code> label is
located.</li>
<li>Follow through this manual tracing, updating the variables, until
you&rsquo;re sure you see how this flows.</li>
</ul>

<p>Pause!</p>

<p>I will then show you the solution so pause if you do
<em>NOT</em> want to see it yet.</p>

<p>Solving It</p>

<p>Watch me walk through how this works to see if it matches what you did.</p>

<p>Extra Credit</p>

<ul>
<li>Never use this again.</li>
<li>Go look at the Wikipedia entry for Duff&rsquo;s device and see if you can
spot the error.  Read the article, compare it to the version I have here, and try to understand why the Wikipedia code won&rsquo;t work for you
but worked for Tom Duff.</li>
<li>Create a set of macros that lets you create any length of device like this.
For example, what if you wanted to have 32 case statements and didn&rsquo;t want
to write out all of them? Can you do a macro that lays down eight at a time?</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Change the <code>main</code> to conduct some speed tests to see which one is
really the fastest.</li>
<li>Read about <code>memcpy</code>, <code>memmove</code>, and <code>memset</code>, and also compare
their speed.</li>
<li>Never use this again!</li>
</ul>

<h3 id="exercise-24-input-output-files">Exercise 24 Input, Output, Files</h3>

<p>The Plan</p>

<ul>
<li>Learn the basics of working with files in C.</li>
<li>Get an initial list of the &ldquo;f-functions&rdquo;.</li>
</ul>

<p>The Code</p>

<p>.\ex24\ex24.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;dbg.h&quot;

#define MAX_DATA 100

typedef enum EyeColor {
    BLUE_EYES, GREEN_EYES, BROWN_EYES,
    BLACK_EYES, OTHER_EYES
} EyeColor;

const char *EYE_COLOR_NAMES[] = {
    &quot;Blue&quot;, &quot;Green&quot;, &quot;Brown&quot;, &quot;Black&quot;, &quot;Other&quot;
};

typedef struct Person {
    int age;
    char first_name[MAX_DATA];
    char last_name[MAX_DATA];
    EyeColor eyes;
    float income;
} Person;

int main(int argc, char *argv[])
{
    Person you = {.age = 0 };
    int i = 0;
    char *in = NULL;

    printf(&quot;What's your First Name? &quot;);
    in = fgets(you.first_name, MAX_DATA - 1, stdin);
    check(in != NULL, &quot;Failed to read first name.&quot;);

    printf(&quot;What's your Last Name? &quot;);
    in = fgets(you.last_name, MAX_DATA - 1, stdin);
    check(in != NULL, &quot;Failed to read last name.&quot;);

    printf(&quot;How old are you? &quot;);
    int rc = fscanf(stdin, &quot;%d&quot;, &amp;you.age);
    check(rc &gt; 0, &quot;You have to enter a number.&quot;);

    printf(&quot;What color are your eyes:\n&quot;);
    for (i = 0; i &lt;= OTHER_EYES; i++) {
        printf(&quot;%d) %s\n&quot;, i + 1, EYE_COLOR_NAMES[i]);
    }
    printf(&quot;&gt; &quot;);

    int eyes = -1;
    rc = fscanf(stdin, &quot;%d&quot;, &amp;eyes);
    check(rc &gt; 0, &quot;You have to enter a number.&quot;);

    you.eyes = eyes - 1;
    check(you.eyes &lt;= OTHER_EYES
            &amp;&amp; you.eyes &gt;= 0, &quot;Do it right, that's not an option.&quot;);

    printf(&quot;How much do you make an hour? &quot;);
    rc = fscanf(stdin, &quot;%f&quot;, &amp;you.income);
    check(rc &gt; 0, &quot;Enter a floating point number.&quot;);

    printf(&quot;----- RESULTS -----\n&quot;);

    printf(&quot;First Name: %s&quot;, you.first_name);
    printf(&quot;Last Name: %s&quot;, you.last_name);
    printf(&quot;Age: %d\n&quot;, you.age);
    printf(&quot;Eyes: %s\n&quot;, EYE_COLOR_NAMES[you.eyes]);
    printf(&quot;Income: %f\n&quot;, you.income);

    return 0;
error:

    return -1;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Trying out <em>fgets</em> and the problems with <em>gets</em>.</li>
<li>Feed it <em>/dev/urandom</em> to give it garbage.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Rewrite this to not use <code>fscanf</code> at all.  You&rsquo;ll need to use
functions like <code>atoi</code> to convert the input strings to numbers.</li>
<li>Change this to use plain <code>scanf</code> instead of <code>fscanf</code> to
see what the difference is.</li>
<li>Fix it so that their input names get stripped of the trailing newline
characters and any whites pace.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Use <code>scanf</code> to write a function that reads one character at a time
and files in the names but doesn&rsquo;t go past the end.  Make this function
generic so it can take a size for the string, but just make sure you end
the string with <code>'\0'</code> no matter what.</li>
</ul>

<h3 id="exercise-25-variable-argument-functions">Exercise 25 Variable Argument Functions</h3>

<p>The Plan</p>

<ul>
<li>Use variable argument functions.</li>
<li>Write our own simple version of <em>scanf</em>.</li>
</ul>

<p>The Code</p>

<p>.\ex25\ex25.c</p>

<pre><code class="language-c">
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &quot;dbg.h&quot;

#define MAX_DATA 100

int read_string(char **out_string, int max_buffer)
{
    *out_string = calloc(1, max_buffer + 1);
    check_mem(*out_string);

    char *result = fgets(*out_string, max_buffer, stdin);
    check(result != NULL, &quot;Input error.&quot;);

    return 0;

error:
    if (*out_string) free(*out_string);
    *out_string = NULL;
    return -1;
}

int read_int(int *out_int)
{
    char *input = NULL;
    int rc = read_string(&amp;input, MAX_DATA);
    check(rc == 0, &quot;Failed to read number.&quot;);

    *out_int = atoi(input);

    free(input);
    return 0;

error:
    if (input) free(input);
    return -1;
}

int read_scan(const char *fmt, ...)
{
    int i = 0;
    int rc = 0;
    int *out_int = NULL;
    char *out_char = NULL;
    char **out_string = NULL;
    int max_buffer = 0;

    va_list argp;
    va_start(argp, fmt);

    for (i = 0; fmt[i] != '\0'; i++) {
        if (fmt[i] == '%') {
            i++;
            switch (fmt[i]) {
                case '\0':
                    sentinel(&quot;Invalid format, you ended with %%.&quot;);
                    break;

                case 'd':
                    out_int = va_arg(argp, int *);
                    rc = read_int(out_int);
                    check(rc == 0, &quot;Failed to read int.&quot;);
                    break;

                case 'c':
                    out_char = va_arg(argp, char *);
                    *out_char = fgetc(stdin);
                    break;

                case 's':
                    max_buffer = va_arg(argp, int);
                    out_string = va_arg(argp, char **);
                    rc = read_string(out_string, max_buffer);
                    check(rc == 0, &quot;Failed to read string.&quot;);
                    break;

                default:
                    sentinel(&quot;Invalid format.&quot;);
            }
        } else {
            fgetc(stdin);
        }

        check(!feof(stdin) &amp;&amp; !ferror(stdin), &quot;Input error.&quot;);
    }

    va_end(argp);
    return 0;

error:
    va_end(argp);
    return -1;
}

int main(int argc, char *argv[])
{
    char *first_name = NULL;
    char initial = ' ';
    char *last_name = NULL;
    int age = 0;

    printf(&quot;What's your first name? &quot;);
    int rc = read_scan(&quot;%s&quot;, MAX_DATA, &amp;first_name);
    check(rc == 0, &quot;Failed first name.&quot;);

    printf(&quot;What's your initial? &quot;);
    rc = read_scan(&quot;%c\n&quot;, &amp;initial);
    check(rc == 0, &quot;Failed initial.&quot;);

    printf(&quot;What's your last name? &quot;);
    rc = read_scan(&quot;%s&quot;, MAX_DATA, &amp;last_name);
    check(rc == 0, &quot;Failed last name.&quot;);

    printf(&quot;How old are you? &quot;);
    rc = read_scan(&quot;%d&quot;, &amp;age);

    printf(&quot;---- RESULTS ----\n&quot;);
    printf(&quot;First Name: %s&quot;, first_name);
    printf(&quot;Initial: '%c'\n&quot;, initial);
    printf(&quot;Last Name: %s&quot;, last_name);
    printf(&quot;Age: %d\n&quot;, age);

    free(first_name);
    free(last_name);
    return 0;
error:
    return -1;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Change the code so that you forget to pass in the initial size for &lsquo;%s&rsquo; formats.</li>
<li>Give it more data than <code>MAX_DATA</code>, and then see how omitting <code>calloc</code> in <code>read_string</code> changes how it works.</li>
<li>There&rsquo;s a problem where fgets eats the newlines, so try to fix that using
<code>fgetc</code> but leave out the <code>\0</code> that ends the string.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Make double and triple sure that you know what each of the <code>out_</code>
variables are doing.  Most importantly, you should know what is <code>out_string</code> is and how it&rsquo;s
a pointer to a pointer, , so that you understand when you&rsquo;re setting the pointer versus the
contents is important.  Break down each of the</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Write a similar function to <code>printf</code> that uses the varargs system,
and rewrite <code>main</code> to use it.</li>
<li>As usual, read the man page on all of this so that you know what it does
on your platform.  Some platforms will use macros, others will use
functions, and some will have these do nothing.  It all depends on the
compiler and the platform you use.</li>
</ul>

<h3 id="exercise-26-project-logfind">Exercise 26 Project logfind</h3>

<p>The Plan</p>

<p>Attempt your first project!</p>

<p>logfind</p>

<p>How Projects Work</p>

<p>The projects in this book are designed to make you apply
what you know so far to something &ldquo;real world&rdquo;.</p>

<ol>
<li>I will tell you when to <em>pause</em> so you can try to solve it yourself.</li>
<li>You will be given the challenge.  Pause!</li>
<li>You will be given clues. Pause!</li>
<li>Finally the solution.</li>
<li>Then I try to break my own solution.</li>
</ol>

<p>The Code</p>

<p>logfind.1</p>

<p>.\ex26\logfind.1\logfind.c</p>

<pre><code class="language-c">#include &quot;dbg.h&quot;

int main(int argc, char *argv[])
{
    check(argc &gt; 2, &quot;USAGE: logfind word word word&quot;);

    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex26\logfind.1\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind test test test

</code></pre>

<p>logfind.2</p>

<p>.\ex26\logfind.2\logfind.c</p>

<pre><code class="language-c">#include &quot;dbg.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

const size_t MAX_LINE = 1024;

int scan_file(const char *filename, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &quot;r&quot;);
    char *found = NULL;
    int i = 0;

    check_mem(line);
    check(file, &quot;Failed to open file: %s&quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL &amp;&amp; found == NULL) {
        for(i = 0; i &lt; search_len &amp;&amp; found == NULL; i++) {
            found = strcasestr(line, search_for[i]);
            if(found) {
                printf(&quot;%s\n&quot;, filename);
            }
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int main(int argc, char *argv[])
{
    check(argc &gt; 1, &quot;USAGE: logfind word word word&quot;);

    scan_file(&quot;logfind.c&quot;, argc, argv);

    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex26\logfind.2\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind error

clean:
    rm -f logfind

</code></pre>

<p>logfind.3</p>

<p>.\ex26\logfind.3\logfind.c</p>

<pre><code class="language-c">#include &quot;dbg.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;glob.h&gt;

const size_t MAX_LINE = 1024;

int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&quot;.logfind&quot;, &quot;r&quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &quot;Invalid glob_t given.&quot;);
    check_mem(line);
    check(file, &quot;Failed to open .logfind. Make that first.&quot;);

    rc = glob(&quot;*.h&quot;, glob_flags, NULL, pglob);
    check(rc == 0, &quot;Failed to glob.&quot;);
    rc = glob(&quot;*.c&quot;, glob_flags | GLOB_APPEND, NULL, pglob);
    check(rc == 0, &quot;Failed to glob.&quot;);

    for(i = 0; i &lt; pglob-&gt;gl_pathc; i++) {
        debug(&quot;Matched file: %s&quot;, pglob-&gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int scan_file(const char *filename, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &quot;r&quot;);
    char *found = NULL;
    int i = 0;

    check_mem(line);
    check(file, &quot;Failed to open file: %s&quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL &amp;&amp; found == NULL) {
        for(i = 0; i &lt; search_len &amp;&amp; found == NULL; i++) {
            found = strcasestr(line, search_for[i]);
            if(found) {
                printf(&quot;%s\n&quot;, filename);
            }
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int main(int argc, char *argv[])
{
    int i = 0;
    glob_t files_found;
    check(argc &gt; 1, &quot;USAGE: logfind word word word&quot;);

    check(list_files(&amp;files_found) == 0, &quot;Failed to list files.&quot;);

    for(i = 0; i &lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], argc, argv);
    }

    globfree(&amp;files_found);
    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex26\logfind.3\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind error

clean:
    rm -f logfind

</code></pre>

<p>logfind.4</p>

<p>.\ex26\logfind.4\logfind.c</p>

<pre><code class="language-c">#define NDEBUG
#include &quot;dbg.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;glob.h&gt;

const size_t MAX_LINE = 1024;

int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&quot;.logfind&quot;, &quot;r&quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &quot;Invalid glob_t given.&quot;);
    check_mem(line);
    check(file, &quot;Failed to open .logfind. Make that first.&quot;);

    while(fgets(line, MAX_LINE-1, file) != NULL) {
        line[strlen(line) - 1] = '\0'; // drop the \n ending
        debug(&quot;Globbing %s&quot;, line);

        rc = glob(line, glob_flags, NULL, pglob);
        check(rc == 0 || rc == GLOB_NOMATCH, &quot;Failed to glob.&quot;);

        // dumb work around to a stupid design in glob
        if(glob_flags == GLOB_TILDE) glob_flags |= GLOB_APPEND;
    }

    for(i = 0; i &lt; pglob-&gt;gl_pathc; i++) {
        debug(&quot;Matched file: %s&quot;, pglob-&gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int scan_file(const char *filename, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &quot;r&quot;);
    char *found = NULL;
    int i = 0;

    check_mem(line);
    check(file, &quot;Failed to open file: %s&quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL &amp;&amp; found == NULL) {
        for(i = 0; i &lt; search_len &amp;&amp; found == NULL; i++) {
            found = strcasestr(line, search_for[i]);
            if(found) {
                printf(&quot;%s\n&quot;, filename);
            }
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int main(int argc, char *argv[])
{
    int i = 0;
    glob_t files_found;
    check(argc &gt; 1, &quot;USAGE: logfind word word word&quot;);

    check(list_files(&amp;files_found) == 0, &quot;Failed to list files.&quot;);

    for(i = 0; i &lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], argc, argv);
    }

    globfree(&amp;files_found);
    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex26\logfind.4\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind MAX_LINE

clean:
    rm -f logfind

</code></pre>

<p>logfind.5</p>

<p>.\ex26\logfind.5\logfind.c</p>

<pre><code class="language-c">#define NDEBUG
#include &quot;dbg.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;glob.h&gt;

const size_t MAX_LINE = 1024;

int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&quot;.logfind&quot;, &quot;r&quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &quot;Invalid glob_t given.&quot;);
    check_mem(line);
    check(file, &quot;Failed to open .logfind. Make that first.&quot;);

    while(fgets(line, MAX_LINE-1, file) != NULL) {
        line[strlen(line) - 1] = '\0'; // drop the \n ending
        debug(&quot;Globbing %s&quot;, line);

        rc = glob(line, glob_flags, NULL, pglob);
        check(rc == 0 || rc == GLOB_NOMATCH, &quot;Failed to glob.&quot;);

        // dumb work around to a stupid design in glob
        if(glob_flags == GLOB_TILDE) glob_flags |= GLOB_APPEND;
    }

    for(i = 0; i &lt; pglob-&gt;gl_pathc; i++) {
        debug(&quot;Matched file: %s&quot;, pglob-&gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int found_it(int use_or, int found_count, int search_len)
{
    debug(&quot;use_or: %d, found_count: %d, search_len: %d&quot;, use_or, found_count, search_len);

    if(use_or &amp;&amp; found_count &gt; 0) {
        return 1;
    } else if(!use_or &amp;&amp; found_count == search_len) {
        return 1;
    } else {
        return 0;
    }
}

int scan_file(const char *filename, int use_or, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &quot;r&quot;);
    int found_count = 0;
    int i = 0;

    check_mem(line);
    check(file, &quot;Failed to open file: %s&quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL)
    {
        for(i = 0; i &lt; search_len; i++) {
            if(strcasestr(line, search_for[i]) != NULL) {
                debug(&quot;file: %s, line: %s, search: %s&quot;, filename, line, search_for[i]);
                found_count++;
            }
        }

        if(found_it(use_or, found_count, search_len)) {
            printf(&quot;%s\n&quot;, filename);
            break;
        } else {
            found_count = 0;
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int parse_args(int *use_or, int *argc, char **argv[]) 
{
    (*argc)--;
    (*argv)++;

    if(strcmp((*argv)[0], &quot;-o&quot;) == 0) {
        *use_or = 1;
        (*argc)--; // skip the -o
        (*argv)++;
        check(*argc &gt; 1, &quot;You need words after -o.&quot;);
    } else {
        use_or = 0;
    }

    return 0;
error:
    return -1;
}

int main(int argc, char *argv[])
{
    int i = 0;
    int use_or = 0;
    glob_t files_found;

    check(argc &gt; 1, &quot;USAGE: logfind [-o] words&quot;);

    check(parse_args(&amp;use_or, &amp;argc, &amp;argv) == 0, &quot;USAGE: logfind [-o] words&quot;);

    check(list_files(&amp;files_found) == 0, &quot;Failed to list files.&quot;);

    for(i = 0; i &lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], use_or, argc, argv);
    }

    globfree(&amp;files_found);
    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex26\logfind.5\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind MAX_LINE
    ./logfind error MAX LINE
    ./logfind -o error MAX LINE

clean:
    rm -f logfind

</code></pre>

<p>If you ever get super stuck, you can visit:</p>

<p>To get all of the code for this book.</p>

<p>The Challenge</p>

<p>I want a tool called <code>logfind</code> that let&rsquo;s me search through log files for
text.  This tool is a specialized version of another tool called <code>grep</code>, but
designed only for log files on a system.</p>

<p>The Challenge</p>

<ul>
<li>This tool takes any sequence of words and assumes I mean &ldquo;and&rdquo; for them.  So <code>logfind zedshaw smart guy</code> will find all files that have <code>zedshaw</code> <em>and</em> <code>smart</code> <em>and</em> <code>guy</code> in them.</li>
<li>It takes an optional argument of <code>-o</code> if the parameters are meant to be <em>or</em> logic.</li>
<li>It loads the list of allowed log files from <code>~/.logfind</code>.</li>
</ul>

<p>The Challenge</p>

<ul>
<li>The list of file names can be anything that the <code>glob</code> function allows.  Refer to <code>man 3 glob</code> to see how this works.  I suggest starting with just a flat list of exact files, and then add <code>glob</code> functionality.</li>
<li>You should output the matching lines as you scan, and try to match them as fast as possible.</li>
</ul>

<p>Demo</p>

<p>Here is a demo of me using the one I wrote.</p>

<p>Pause!</p>

<p>Now it&rsquo;s time for you to attempt to solve it from just this idea.</p>

<p>The Clues</p>

<ul>
<li>Remember to solve it a piece at a time.</li>
<li>Start with just getting the arguments.</li>
<li>Then figure out how to open files and just open the ones in this directory.</li>
<li>Then figure out how to read the files.</li>
<li>Then find out how to find the arguments in the files.</li>
<li>Then figure out how glob works.</li>
<li>Then use glob to find the files and open them.</li>
</ul>

<p>It helps to do each of these in <em>main()</em> then &ldquo;carve&rdquo; them out into their
own functions.</p>

<p>Pause!</p>

<p>The Solution</p>

<p>Breaking It</p>

<h3 id="exercise-27-creative-and-defensive-programming">Exercise 27 Creative and Defensive Programming</h3>

<p>logfind.5</p>

<p>.\ex27\logfind.5\logfind.c</p>

<pre><code class="language-c">#define NDEBUG
#include &quot;dbg.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;glob.h&gt;
#include &lt;assert.h&gt;

const size_t MAX_LINE = 1024;

int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&quot;.logfind&quot;, &quot;r&quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &quot;Invalid glob_t given.&quot;);
    check_mem(line);
    check(file, &quot;Failed to open .logfind. Make that first.&quot;);

    while(fgets(line, MAX_LINE-1, file) != NULL) {
        size_t line_length = strnlen(line, MAX_LINE - 1);
        assert(line_length &lt; MAX_LINE &amp;&amp; &quot;Got a line length too long.&quot;);

        line[line_length] = '\0'; // drop the \n ending
        debug(&quot;Globbing %s&quot;, line);

        rc = glob(line, glob_flags, NULL, pglob);
        check(rc == 0 || rc == GLOB_NOMATCH, &quot;Failed to glob.&quot;);

        // dumb work around to a stupid design in glob
        if(glob_flags == GLOB_TILDE) glob_flags |= GLOB_APPEND;
    }

    for(i = 0; i &lt; pglob-&gt;gl_pathc; i++) {
        debug(&quot;Matched file: %s&quot;, pglob-&gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int found_it(int use_or, int found_count, int search_len)
{
    debug(&quot;use_or: %d, found_count: %d, search_len: %d&quot;, use_or, found_count, search_len);

    if(use_or &amp;&amp; found_count &gt; 0) {
        return 1;
    } else if(!use_or &amp;&amp; found_count == search_len) {
        return 1;
    } else {
        return 0;
    }
}

int scan_file(const char *filename, int use_or, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &quot;r&quot;);
    int found_count = 0;
    int i = 0;

    check_mem(line);
    check(file, &quot;Failed to open file: %s&quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL)
    {
        for(i = 0; i &lt; search_len; i++) {
            if(strcasestr(line, search_for[i]) != NULL) {
                debug(&quot;file: %s, line: %s, search: %s&quot;, filename, line, search_for[i]);
                found_count++;
            }
        }

        if(found_it(use_or, found_count, search_len)) {
            printf(&quot;%s\n&quot;, filename);
            break;
        } else {
            found_count = 0;
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int parse_args(int *use_or, int *argc, char **argv[]) 
{
    (*argc)--;
    (*argv)++;

    if(strcmp((*argv)[0], &quot;-o&quot;) == 0) {
        *use_or = 1;
        (*argc)--; // skip the -o
        (*argv)++;
        check(*argc &gt; 1, &quot;You need words after -o.&quot;);
    } else {
        *use_or = 0;
    }

    return 0;
error:
    return -1;
}

int main(int argc, char *argv[])
{
    int i = 0;
    int use_or = 1;
    glob_t files_found;

    check(argc &gt; 1, &quot;USAGE: logfind [-o] words&quot;);

    check(parse_args(&amp;use_or, &amp;argc, &amp;argv) == 0, &quot;USAGE: logfind [-o] words&quot;);

    check(list_files(&amp;files_found) == 0, &quot;Failed to list files.&quot;);

    for(i = 0; i &lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], use_or, argc, argv);
    }

    globfree(&amp;files_found);
    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex27\logfind.5\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind MAX_LINE
    ./logfind error MAX LINE
    ./logfind -o error MAX LINE

clean:
    rm -f logfind

</code></pre>

<p>logfind.5</p>

<p>.\ex27\logfind.5\logfind.c</p>

<pre><code class="language-c">#define NDEBUG
#include &quot;dbg.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;glob.h&gt;
#include &lt;assert.h&gt;

const size_t MAX_LINE = 1024;

int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&quot;.logfind&quot;, &quot;r&quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &quot;Invalid glob_t given.&quot;);
    check_mem(line);
    check(file, &quot;Failed to open .logfind. Make that first.&quot;);

    while(fgets(line, MAX_LINE-1, file) != NULL) {
        size_t line_length = strnlen(line, MAX_LINE - 1);
        assert(line_length &lt; MAX_LINE &amp;&amp; &quot;Got a line length too long.&quot;);

        line[line_length] = '\0'; // drop the \n ending
        debug(&quot;Globbing %s&quot;, line);

        rc = glob(line, glob_flags, NULL, pglob);
        check(rc == 0 || rc == GLOB_NOMATCH, &quot;Failed to glob.&quot;);

        // dumb work around to a stupid design in glob
        if(glob_flags == GLOB_TILDE) glob_flags |= GLOB_APPEND;
    }

    for(i = 0; i &lt; pglob-&gt;gl_pathc; i++) {
        debug(&quot;Matched file: %s&quot;, pglob-&gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int found_it(int use_or, int found_count, int search_len)
{
    debug(&quot;use_or: %d, found_count: %d, search_len: %d&quot;, use_or, found_count, search_len);

    if(use_or &amp;&amp; found_count &gt; 0) {
        return 1;
    } else if(!use_or &amp;&amp; found_count == search_len) {
        return 1;
    } else {
        return 0;
    }
}

int scan_file(const char *filename, int use_or, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &quot;r&quot;);
    int found_count = 0;
    int i = 0;

    check_mem(line);
    check(file, &quot;Failed to open file: %s&quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL)
    {
        for(i = 0; i &lt; search_len; i++) {
            if(strcasestr(line, search_for[i]) != NULL) {
                debug(&quot;file: %s, line: %s, search: %s&quot;, filename, line, search_for[i]);
                found_count++;
            }
        }

        if(found_it(use_or, found_count, search_len)) {
            printf(&quot;%s\n&quot;, filename);
            break;
        } else {
            found_count = 0;
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int parse_args(int *use_or, int *argc, char **argv[]) 
{
    (*argc)--;
    (*argv)++;

    if(strcmp((*argv)[0], &quot;-o&quot;) == 0) {
        *use_or = 1;
        (*argc)--; // skip the -o
        (*argv)++;
        check(*argc &gt; 1, &quot;You need words after -o.&quot;);
    } else {
        *use_or = 0;
    }

    return 0;
error:
    return -1;
}

int main(int argc, char *argv[])
{
    int i = 0;
    int use_or = 1;
    glob_t files_found;

    check(argc &gt; 1, &quot;USAGE: logfind [-o] words&quot;);

    check(parse_args(&amp;use_or, &amp;argc, &amp;argv) == 0, &quot;USAGE: logfind [-o] words&quot;);

    check(list_files(&amp;files_found) == 0, &quot;Failed to list files.&quot;);

    for(i = 0; i &lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], use_or, argc, argv);
    }

    globfree(&amp;files_found);
    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex27\logfind.5\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind MAX_LINE
    ./logfind error MAX LINE
    ./logfind -o error MAX LINE

clean:
    rm -f logfind

</code></pre>

<p>Read The Book</p>

<p>This video is a demonstration of the concepts in the book.</p>

<p>Go read the book.</p>

<p>Demonstration</p>

<p>I will demonstrate each of the following:</p>

<ul>
<li>Fail early and openly.</li>
<li>Document assumptions.</li>
<li>Prevention over documentation.</li>
<li>Automate everything.</li>
<li>Simplify and clarify.</li>
<li>Question authority.</li>
</ul>

<p>Fail Early and Openly</p>

<p>Document Assumptions</p>

<p>Prevention over Documentation</p>

<p>Automate Everything</p>

<p>Simplify and Clarify</p>

<p>Question Authority</p>

<p>Bonus: Assume Nothing</p>

<h3 id="exercise-28-intermediate-makefiles">Exercise 28 Intermediate Makefiles</h3>

<p>The Plan</p>

<ul>
<li>Learn how to create a project skeleton to make starting easier.</li>
<li>Learn more advanced GNU make tricks.</li>
</ul>

<p>The Skeleton</p>

<p>.\ex28\c-skeleton</p>

<p>.\ex28\c-skeleton\src\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex28\c-skeleton\src\libex29.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &quot;dbg.h&quot;

int print_a_message(const char *msg)
{
    printf(&quot;A STRING: %s\n&quot;, msg);

    return 0;
}

int uppercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, toupper(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int lowercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, tolower(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int fail_on_purpose(const char *msg)
{
    return 1;
} 

</code></pre>

<p>.\ex28\c-skeleton\tests\libex29_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;dlfcn.h&gt;

typedef int (*lib_function) (const char *data);
char *lib_file = &quot;build/libYOUR_LIBRARY.so&quot;;
void *lib = NULL;

int check_function(const char *func_to_run, const char *data,
        int expected)
{
    lib_function func = dlsym(lib, func_to_run);
    check(func != NULL,
            &quot;Did not find %s function in the library %s: %s&quot;, func_to_run,
            lib_file, dlerror());

    int rc = func(data);
    check(rc == expected, &quot;Function %s return %d for data: %s&quot;,
            func_to_run, rc, data);

    return 1;
error:
    return 0;
}

char *test_dlopen()
{
    lib = dlopen(lib_file, RTLD_NOW);
    mu_assert(lib != NULL, &quot;Failed to open the library to test.&quot;);

    return NULL;
}

char *test_functions()
{
    mu_assert(check_function(&quot;print_a_message&quot;, &quot;Hello&quot;, 0),
            &quot;print_a_message failed.&quot;);
    mu_assert(check_function(&quot;uppercase&quot;, &quot;Hello&quot;, 0),
            &quot;uppercase failed.&quot;);
    mu_assert(check_function(&quot;lowercase&quot;, &quot;Hello&quot;, 0),
            &quot;lowercase failed.&quot;);

    return NULL;
}

char *test_failures()
{
    mu_assert(check_function(&quot;fail_on_purpose&quot;, &quot;Hello&quot;, 1),
            &quot;fail_on_purpose should fail.&quot;);

    return NULL;
}

char *test_dlclose()
{
    int rc = dlclose(lib);
    mu_assert(rc == 0, &quot;Failed to close lib.&quot;);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dlopen);
    mu_run_test(test_functions);
    mu_run_test(test_failures);
    mu_run_test(test_dlclose);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>The video is probably easier to follow than the book.
Watch me do this.</p>

<p>Using The Skeleton</p>

<p>.\ex28\c-skeleton</p>

<p>.\ex28\c-skeleton\src\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex28\c-skeleton\src\libex29.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &quot;dbg.h&quot;

int print_a_message(const char *msg)
{
    printf(&quot;A STRING: %s\n&quot;, msg);

    return 0;
}

int uppercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, toupper(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int lowercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, tolower(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int fail_on_purpose(const char *msg)
{
    return 1;
} 

</code></pre>

<p>.\ex28\c-skeleton\tests\libex29_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;dlfcn.h&gt;

typedef int (*lib_function) (const char *data);
char *lib_file = &quot;build/libYOUR_LIBRARY.so&quot;;
void *lib = NULL;

int check_function(const char *func_to_run, const char *data,
        int expected)
{
    lib_function func = dlsym(lib, func_to_run);
    check(func != NULL,
            &quot;Did not find %s function in the library %s: %s&quot;, func_to_run,
            lib_file, dlerror());

    int rc = func(data);
    check(rc == expected, &quot;Function %s return %d for data: %s&quot;,
            func_to_run, rc, data);

    return 1;
error:
    return 0;
}

char *test_dlopen()
{
    lib = dlopen(lib_file, RTLD_NOW);
    mu_assert(lib != NULL, &quot;Failed to open the library to test.&quot;);

    return NULL;
}

char *test_functions()
{
    mu_assert(check_function(&quot;print_a_message&quot;, &quot;Hello&quot;, 0),
            &quot;print_a_message failed.&quot;);
    mu_assert(check_function(&quot;uppercase&quot;, &quot;Hello&quot;, 0),
            &quot;uppercase failed.&quot;);
    mu_assert(check_function(&quot;lowercase&quot;, &quot;Hello&quot;, 0),
            &quot;lowercase failed.&quot;);

    return NULL;
}

char *test_failures()
{
    mu_assert(check_function(&quot;fail_on_purpose&quot;, &quot;Hello&quot;, 1),
            &quot;fail_on_purpose should fail.&quot;);

    return NULL;
}

char *test_dlclose()
{
    int rc = dlclose(lib);
    mu_assert(rc == 0, &quot;Failed to close lib.&quot;);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dlopen);
    mu_run_test(test_functions);
    mu_run_test(test_failures);
    mu_run_test(test_dlclose);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>Now I&rsquo;ll use the skeleton to start a simple project for the next exercise.</p>

<p>The Analysis</p>

<p>Let&rsquo;s look at Makefile in depth.</p>

<p>Extra Credit</p>

<h3 id="exercise-29-libraries-and-linking">Exercise 29 Libraries and Linking</h3>

<p>The Plan</p>

<ul>
<li>Learn about libraries and how to link against them.</li>
<li>Learn how to load a dynamic library from inside C.</li>
</ul>

<p>The Code</p>

<p>.\ex29\ex29.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;dbg.h&quot;
#include &lt;dlfcn.h&gt;

typedef int (*lib_function) (const char *data);

int main(int argc, char *argv[])
{
    int rc = 0;
    check(argc == 4, &quot;USAGE: ex29 libex29.so function data&quot;);

    char *lib_file = argv[1];
    char *func_to_run = argv[2];
    char *data = argv[3];

    void *lib = dlopen(lib_file, RTLD_NOW);
    check(lib != NULL, &quot;Failed to open the library %s: %s&quot;, lib_file,
            dlerror());

    lib_function func = dlsym(lib, func_to_run);
    check(func != NULL,
            &quot;Did not find %s function in the library %s: %s&quot;, func_to_run,
            lib_file, dlerror());

    rc = func(data);
    check(rc == 0, &quot;Function %s return %d for data: %s&quot;, func_to_run,
            rc, data);

    rc = dlclose(lib);
    check(rc == 0, &quot;Failed to close %s&quot;, lib_file);

    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex29\libex29.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &quot;dbg.h&quot;

int print_a_message(const char *msg)
{
    printf(&quot;A STRING: %s\n&quot;, msg);

    return 0;
}

int uppercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, toupper(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int lowercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, tolower(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int fail_on_purpose(const char *msg)
{
    return 1;
} 

</code></pre>

<p>I&rsquo;ll use the project I started from the previous exercise.
This covers some of the extra credit.</p>

<p>The Analysis</p>

<p>This analysis might take a while, but be sure you know Exercise 28 well.</p>

<p>Breaking It</p>

<ul>
<li>Wreck the libex29.so file.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Were you paying attention to the bad code I have in the <code>libex29.c</code> functions?
Do you see how, even though I use a for-loop they still check for <code>'\0'</code>
endings?  Fix this so that the functions always take a length for the
string to work with inside the function.</li>
<li>Read the <code>man dlopen</code> documentation and read about all of the
related functions.  Try some of the other options to <code>dlopen</code>
beside <code>RTLD_NOW</code>.</li>
</ul>

<h3 id="exercise-30-automated-testing">Exercise 30 Automated Testing</h3>

<p>The Plan</p>

<p>Continue the Exercise 28-29 project and add automated tests to it.</p>

<p>Why Automate Tests</p>

<p>You are a programmer.
Your job is automating.</p>

<p>EVERYTHING</p>

<p>The Code</p>

<p>.\ex30\ex30.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;

char *test_dlopen(int stuff)
{
    return NULL;
}

char *test_functions()
{

    return NULL;
}

char *test_failures()
{

    return NULL;
}

char *test_dlclose()
{

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dlopen);
    mu_run_test(test_functions);
    mu_run_test(test_failures);
    mu_run_test(test_dlclose);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>Adding It To libex29</p>

<p>Breaking It</p>

<ul>
<li>Making tests fail first is useful.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>This works but it&rsquo;s probably a bit messy.  Clean the <code>c-skeleton</code>
directory up so that it has all of these files, but remove any of the code
related to Exercise 29.  You should be able to copy this directory
over and kick-start new projects without much editing.</li>
<li>Study the <code>runtests.sh</code>, and then go read about <code>bash</code> syntax
so you know what it does.  Do you think you could write a C version of this
script?</li>
</ul>

<h3 id="exercise-31-common-undefined-behavior">Exercise 31 Common Undefined Behavior</h3>

<p>The Plan</p>

<p>Review the issues around Undefined and Unspecified Behavior (UB).</p>

<p>Read The Book</p>

<p>The book lists many of the UB and discusses why they are important to know
about.</p>

<p>The Code</p>

<p>.\ex31\ex31.c</p>

<pre><code class="language-c">#include &lt;unistd.h&gt;

int main(int argc, char *argv[])
{
    int i = 0;

    while (i &lt; 100) {
        usleep(3000);
    }

    return 0;
}

</code></pre>

<p>There is no code for this exercise, just a quick discussion for the book.</p>

<p>Undefined Behavior</p>

<ul>
<li>Compiler writers can do whatever they want.</li>
<li>This means even <em>nothing</em>, which will ruin you silently.</li>
<li>It&rsquo;s best to avoid it.</li>
</ul>

<p>Unspecified Behavior</p>

<ul>
<li>For practical purposes unspecified is the same as undefined.</li>
</ul>

<p>Handy Tools</p>

<ul>
<li>Clang&rsquo;s UB helpful flags.</li>
<li>Lint tools and static analyzers.</li>
</ul>

<p>Extra Credit</p>

<p>Spend a day reading through as much of the UB as you can and find examples of each.  Expect lots of frustration and failure when you do this.</p>

    </div>

    <div class="toc toc-fixed" >
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#exercise-0-installing-software">Exercise 0 Installing Software</a></li>
<li><a href="#exercise-1-dust-off-that-compiler">Exercise 1 Dust Off That Compiler</a></li>
<li><a href="#exercise-2-using-makefiles-to-build">Exercise 2 Using Makefiles to Build</a></li>
<li><a href="#exercise-3-formatted-printing">Exercise 3 Formatted Printing</a></li>
<li><a href="#exercise-4-using-a-debugger">Exercise 4 Using a Debugger</a></li>
<li><a href="#exercise-5-memorizing-c-operators">Exercise 5 Memorizing C Operators</a></li>
<li><a href="#exercise-6-memorizing-c-syntax">Exercise 6 Memorizing C Syntax</a></li>
<li><a href="#exercise-7-variables-and-types">Exercise 7 Variables and Types</a></li>
<li><a href="#exercise-8-if-else-if-else">Exercise 8 If, Else-If, Else</a></li>
<li><a href="#exercise-9-while-loop-and-boolean-expressions">Exercise 9 While-Loop and Boolean Expressions</a></li>
<li><a href="#exercise-10-switch-statements">Exercise 10 Switch Statements</a></li>
<li><a href="#exercise-11-arrays-and-strings">Exercise 11 Arrays and Strings</a></li>
<li><a href="#exercise-12-sizes-and-arrays">Exercise 12 Sizes and Arrays</a></li>
<li><a href="#exercise-13-for-loops-and-arrays-of-strings">Exercise 13 For-Loops and Arrays of Strings</a></li>
<li><a href="#exercise-14-writing-and-using-functions">Exercise 14 Writing and Using Functions</a></li>
<li><a href="#exercise-15-pointers-dreaded-pointers">Exercise 15 Pointers, Dreaded Pointers</a></li>
<li><a href="#exercise-16-structs-and-pointers-to-them">Exercise 16 Structs And Pointers To Them</a></li>
<li><a href="#exercise-17-heap-and-stack-memory-allocation">Exercise 17 Heap and Stack Memory Allocation</a></li>
<li><a href="#exercise-18-pointers-to-functions">Exercise 18 Pointers to Functions</a></li>
<li><a href="#exercise-19-zed-s-awesome-debug-macros">Exercise 19 Zed&rsquo;s Awesome Debug Macros</a></li>
<li><a href="#exercise-20-advanced-debugging-techniques">Exercise 20 Advanced Debugging Techniques</a></li>
<li><a href="#exercise-21-advanced-data-types-and-flow-control">Exercise 21 Advanced Data Types and Flow Control</a></li>
<li><a href="#exercise-22-the-stack-scope-and-globals">Exercise 22 The Stack, Scope, and Globals</a></li>
<li><a href="#exercise-23-meet-duff-s-device">Exercise 23 Meet Duff&rsquo;s Device</a></li>
<li><a href="#exercise-24-input-output-files">Exercise 24 Input, Output, Files</a></li>
<li><a href="#exercise-25-variable-argument-functions">Exercise 25 Variable Argument Functions</a></li>
<li><a href="#exercise-26-project-logfind">Exercise 26 Project logfind</a></li>
<li><a href="#exercise-27-creative-and-defensive-programming">Exercise 27 Creative and Defensive Programming</a></li>
<li><a href="#exercise-28-intermediate-makefiles">Exercise 28 Intermediate Makefiles</a></li>
<li><a href="#exercise-29-libraries-and-linking">Exercise 29 Libraries and Linking</a></li>
<li><a href="#exercise-30-automated-testing">Exercise 30 Automated Testing</a></li>
<li><a href="#exercise-31-common-undefined-behavior">Exercise 31 Common Undefined Behavior</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>

</div>

    
    
        <div class="chevrons">
    <div id="navigation">
<a class="nav nav-prev" href="/coding/c/" title="C "> <i class="fa fa-chevron-left"></i><label>C </label></a>
    <a class="nav nav-next" href="/coding/c/lcthw-lectures.2/" title="C Lecture - 2" style="margin-right: 0px;"><label>C Lecture - 2</label><i class="fa fa-chevron-right"></i></a></div>
  </div>

  </section>
</article>

<footer>

<div class="footline">
    

    

    

    
  </div>


	<div>


  
    
  



	</div>
</footer>

<script src="/js/clipboard.min.js"></script>

<link href="/css/featherlight.min.css" rel="stylesheet">
<script src="/js/featherlight.min.js"></script>


<link href="/css/github.css" rel="stylesheet">
<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<script src="/theme-flex/script.js"></script>


    

    
    

    
  </body>
</html>