<!DOCTYPE html>
<html>
  <head>
    <title>Hello World</title>
    
      <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="revised" content="2022-07-14T00:45:59 AEST">
<title>C Lecture - 2 :: Hello World</title>
<link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon" />
<link href="/css/font-awesome.min.css" rel="stylesheet">
<link href="/css/nucleus.css" rel="stylesheet">
<link href="/theme-flex/style.css" rel="stylesheet">

<link rel="stylesheet" href="/css/bootstrap.min.css">
<script src="/js/jquery-2.x.min.js"></script>
<script type="text/javascript">
      var baseurl = "\/";
</script>
<meta name="description" content="Exercise 32 ~ 40">



    
  </head>
  <body data-url="/coding/c/lcthw-lectures.2/">
    
      <header>
  <div class="logo">
    
	
  
    <a class="baselink" href="/">Hello World</a>
  


  </div>
  <div class="burger"><a href="javascript:void(0);" style="font-size:15px;">&#9776;</a></div>
  <nav class="shortcuts">
    <div>
      <div class="searchbox">
        <input data-search-input id="search-by" type="text" placeholder="Search...">
      </div>
      <script type="text/javascript" src="/js/lunr.min.js"></script>
      <script type="text/javascript" src="/js/auto-complete.js"></script>
      <link href="/css/auto-complete.css" rel="stylesheet">
      <script type="text/javascript">
        
            var baseurl = "\/";
        
      </script>
      <script type="text/javascript" src="/js/search.js"></script>
    </div>
  </nav>
</header>
<article>
  <aside>
    <ul class="menu">
          <li data-nav-id="/" class="dd-item">
          <a href="/">
            <i class="fa fa-fw fa-home"></i>
          </a>
          </li>
    <li data-nav-id="/projects/" class="dd-item haschildren
        ">
      <div>
      <a href="/projects/">Projects</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/projects/angular-crm/" class="dd-item">
        <div>
          <a href="/projects/angular-crm/">
            Angular 9 CRM Starter Project
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/docker-toolkits/" class="dd-item">
        <div>
          <a href="/projects/docker-toolkits/">
             Docker Kits
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/python-flat-api/" class="dd-item">
        <div>
          <a href="/projects/python-flat-api/">
            FlatApi - Restful API for python dev
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/angular4-crm/" class="dd-item">
        <div>
          <a href="/projects/angular4-crm/">
            Angular 4 CRM Project
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/laravel-mvc-starter/" class="dd-item">
        <div>
          <a href="/projects/laravel-mvc-starter/">
            Laravel MVC Starter
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/react-crm/" class="dd-item">
        <div>
          <a href="/projects/react-crm/">
            React Redux CRM Project
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/vue2-admin/" class="dd-item">
        <div>
          <a href="/projects/vue2-admin/">
            Vue 2 Admin Project
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/vue2-crm/" class="dd-item">
        <div>
          <a href="/projects/vue2-crm/">
            Vue 2 CRM Project
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/angularjs-webpack-es6-starter/" class="dd-item">
        <div>
          <a href="/projects/angularjs-webpack-es6-starter/">
            Angularjs Webpack ES6 Starter
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/zf2-mvc-starter/" class="dd-item">
        <div>
          <a href="/projects/zf2-mvc-starter/">
            Zend Framework 2 MVC Starter
          </a>
        </div>
    </li>
      <li data-nav-id="/projects/kube-cluster/" class="dd-item">
        <div>
          <a href="/projects/kube-cluster/">
            Kubernetes Cluster in 5min
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/" class="dd-item parent haschildren
        ">
      <div>
      <a href="/coding/">Coding</a>
            <i class="fa fa-angle-down fa-lg category-icon"></i>
      </div>
        <ul>
    <li data-nav-id="/coding/c/" class="dd-item parent haschildren
        ">
      <div>
      <a href="/coding/c/">C </a>
            <i class="fa fa-angle-down fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/c/lcthw-lectures.1/" class="dd-item">
        <div>
          <a href="/coding/c/lcthw-lectures.1/">
            C Lecture - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/c/lcthw-lectures.2/" class="dd-item active">
        <div>
          <a href="/coding/c/lcthw-lectures.2/">
            C Lecture - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/c/lcthw-lectures.3/" class="dd-item">
        <div>
          <a href="/coding/c/lcthw-lectures.3/">
            C Lecture - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/c/lcthw-lectures.4/" class="dd-item">
        <div>
          <a href="/coding/c/lcthw-lectures.4/">
            C Lecture - 4
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/c-sharp/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/c-sharp/">C#</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/c-sharp/csharp-note-1/" class="dd-item">
        <div>
          <a href="/coding/c-sharp/csharp-note-1/">
            C# Console App
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/c-sharp/csharp-note-4/" class="dd-item">
        <div>
          <a href="/coding/c-sharp/csharp-note-4/">
             Generic Predicate &amp; Expression
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/c-sharp/csharp-note-2/" class="dd-item">
        <div>
          <a href="/coding/c-sharp/csharp-note-2/">
            Scheduled task with window service
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/c-sharp/csharp-note-3/" class="dd-item">
        <div>
          <a href="/coding/c-sharp/csharp-note-3/">
            Thread &amp; Task
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/db-sql/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/db-sql/">DB &amp; SQL</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/db-sql/mysql-note-2/" class="dd-item">
        <div>
          <a href="/coding/db-sql/mysql-note-2/">
            MySql: DDL &amp; DML
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/db-sql/mysql-note-1/" class="dd-item">
        <div>
          <a href="/coding/db-sql/mysql-note-1/">
            MySql: Getting Started
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/db-sql/mysql-note-5/" class="dd-item">
        <div>
          <a href="/coding/db-sql/mysql-note-5/">
            MySql: JSON
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/db-sql/mysql-note-3/" class="dd-item">
        <div>
          <a href="/coding/db-sql/mysql-note-3/">
            MySql: SP &amp; Func
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/db-sql/mysql-note-4/" class="dd-item">
        <div>
          <a href="/coding/db-sql/mysql-note-4/">
            MySql: Schema &amp; Metadata
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/db-sql/pgsql-note-1/" class="dd-item">
        <div>
          <a href="/coding/db-sql/pgsql-note-1/">
            PostgresQL Note - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/db-sql/mssql-note-1/" class="dd-item">
        <div>
          <a href="/coding/db-sql/mssql-note-1/">
            Sql Server Note - 1
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/f-sharp/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/f-sharp/">F#</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/f-sharp/fsharp-note-1/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-1/">
            F# Overview
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-3/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-3/">
            F# Functions
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-4/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-4/">
            F# C.U.R.S.
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-5/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-5/">
            F# Collections 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-6/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-6/">
            F# Collections 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-7/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-7/">
            F# Collections 3
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-8/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-8/">
            F# Pattern Matching
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-9/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-9/">
            F# Active Patterns
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-10/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-10/">
            F# Computations 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-11/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-11/">
            F# Computations 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-12/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-12/">
            F# Async
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-14/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-14/">
            F# Lazy
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-13/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-13/">
            F# Task
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/f-sharp/fsharp-note-2/" class="dd-item">
        <div>
          <a href="/coding/f-sharp/fsharp-note-2/">
            F# Namespace, Module &amp; Import
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/golang/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/golang/">Golang</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/golang/go-note-1/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-1/">
            Getting started
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-2/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-2/">
            Map, Function &amp; Closure
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-3/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-3/">
            Struct &amp; Interface
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-4/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-4/">
            IO, Json &amp; XML
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-5/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-5/">
            Error handling
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-6/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-6/">
            Goroutine &amp; Channel - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-7/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-7/">
            Goroutine &amp; Channel - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-8/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-8/">
            Packaging
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-9/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-9/">
            Pitfalls
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-10/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-10/">
            Template
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-20/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-20/">
            Good practice - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-21/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-21/">
            Good practice - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-22/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-22/">
            Good practice - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/golang/go-note-99/" class="dd-item">
        <div>
          <a href="/coding/golang/go-note-99/">
            Golang snippets
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/js-ts/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/js-ts/">JS &amp; TS </a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/js-ts/js-note-1/" class="dd-item">
        <div>
          <a href="/coding/js-ts/js-note-1/">
            JS &amp; ES Note - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/js-ts/js-note-2/" class="dd-item">
        <div>
          <a href="/coding/js-ts/js-note-2/">
            JS &amp; ES Note - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/js-ts/js-note-3/" class="dd-item">
        <div>
          <a href="/coding/js-ts/js-note-3/">
            JS &amp; ES Note - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/js-ts/js-note-99/" class="dd-item">
        <div>
          <a href="/coding/js-ts/js-note-99/">
            JS &amp; ES snippet
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/js-ts/ts-note-1/" class="dd-item">
        <div>
          <a href="/coding/js-ts/ts-note-1/">
            TS: Basic Types
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/java/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/java/">Java</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/java/java-note-1/" class="dd-item">
        <div>
          <a href="/coding/java/java-note-1/">
            Java Note - 1: Enum
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/java/java-note-2/" class="dd-item">
        <div>
          <a href="/coding/java/java-note-2/">
            Java Note - 2: Concurrency
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/java/java-note-3/" class="dd-item">
        <div>
          <a href="/coding/java/java-note-3/">
            Java Note - 3: Path and Files
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/java/java-note-4/" class="dd-item">
        <div>
          <a href="/coding/java/java-note-4/">
            Java Note - 4: Date Time 
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/java/java-note-5/" class="dd-item">
        <div>
          <a href="/coding/java/java-note-5/">
            Java Note - 5: Lambda 
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/python/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/python/">Python</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/python/python-note-1/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-1/">
            Package &amp; Module
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-2/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-2/">
            Closure &amp; Decorator
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-3/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-3/">
            String &amp; Representation
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-4/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-4/">
            Iteration
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-5/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-5/">
            Inheritance &amp; Polymorphism
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-6/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-6/">
            Collection
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-7/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-7/">
            Exception &amp; Assertion
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-8/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-8/">
            Context
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/python/python-note-9/" class="dd-item">
        <div>
          <a href="/coding/python/python-note-9/">
            ABC
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/rustlang/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/rustlang/">Rustlang</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/rustlang/rust-note-1/" class="dd-item">
        <div>
          <a href="/coding/rustlang/rust-note-1/">
            Data Types &amp; Ownership
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/rustlang/rust-note-2/" class="dd-item">
        <div>
          <a href="/coding/rustlang/rust-note-2/">
            Project, Vector, String &amp; Hashmap
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/rustlang/rust-note-3/" class="dd-item">
        <div>
          <a href="/coding/rustlang/rust-note-3/">
            Error handling
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/rustlang/rust-note-4/" class="dd-item">
        <div>
          <a href="/coding/rustlang/rust-note-4/">
            Generic Type &amp; Trait 
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/coding/shell/" class="dd-item haschildren
        ">
      <div>
      <a href="/coding/shell/">Shell</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/coding/shell/bash-note-1/" class="dd-item">
        <div>
          <a href="/coding/shell/bash-note-1/">
            Adv Bash - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/shell/bash-note-2/" class="dd-item">
        <div>
          <a href="/coding/shell/bash-note-2/">
            Adv Bash - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/shell/bash-note-3/" class="dd-item">
        <div>
          <a href="/coding/shell/bash-note-3/">
            Adv Bash - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/shell/cron-note-1/" class="dd-item">
        <div>
          <a href="/coding/shell/cron-note-1/">
            Cron Job Note - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/shell/cron-note-2/" class="dd-item">
        <div>
          <a href="/coding/shell/cron-note-2/">
            Cron Job Note - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/coding/shell/ps-note-1/" class="dd-item">
        <div>
          <a href="/coding/shell/ps-note-1/">
            Powershell Note - 1
          </a>
        </div>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li data-nav-id="/cloud/" class="dd-item haschildren
        ">
      <div>
      <a href="/cloud/">Cloud</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
    <li data-nav-id="/cloud/azure/" class="dd-item haschildren
        ">
      <div>
      <a href="/cloud/azure/">Azure</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/cloud/azure/az-01-caf-01/" class="dd-item">
        <div>
          <a href="/cloud/azure/az-01-caf-01/">
            Azure: CAF - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/azure/az-01-caf-02/" class="dd-item">
        <div>
          <a href="/cloud/azure/az-01-caf-02/">
            Azure: CAF - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/azure/az-01-caf-03/" class="dd-item">
        <div>
          <a href="/cloud/azure/az-01-caf-03/">
            Azure: CAF - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/azure/az-02-rbac-01/" class="dd-item">
        <div>
          <a href="/cloud/azure/az-02-rbac-01/">
            Azure: RBAC - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/azure/az-02-rbac-02/" class="dd-item">
        <div>
          <a href="/cloud/azure/az-02-rbac-02/">
            Azure: RBAC - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/azure/az-02-rbac-03/" class="dd-item">
        <div>
          <a href="/cloud/azure/az-02-rbac-03/">
            Azure: RBAC - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/azure/az-03-app-01/" class="dd-item">
        <div>
          <a href="/cloud/azure/az-03-app-01/">
            Azure: App - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/azure/az-04-cli-01/" class="dd-item">
        <div>
          <a href="/cloud/azure/az-04-cli-01/">
            Azure: CLI - 1
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/cloud/aws/" class="dd-item haschildren
        ">
      <div>
      <a href="/cloud/aws/">AWS</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/cloud/aws/aws-01-iam/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-01-iam/">
            AWS: IAM
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-02-cli-1/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-02-cli-1/">
            AWS : CLI - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-02-cli-2/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-02-cli-2/">
            AWS : CLI - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-02-cli-3/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-02-cli-3/">
            AWS : CLI - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-03-vpc-1/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-03-vpc-1/">
            AWS: VPC - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-03-vpc-2/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-03-vpc-2/">
            AWS: VPC - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-03-vpc-3/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-03-vpc-3/">
            AWS: VPC - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-03-vpc-4/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-03-vpc-4/">
            AWS: VPC - 4
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-03-vpc-5/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-03-vpc-5/">
            AWS: VPC - 5
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-04-s3-1/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-04-s3-1/">
            AWS: S3 - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-04-s3-2/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-04-s3-2/">
            AWS: S3 - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-04-s3-3/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-04-s3-3/">
            AWS: S3 - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-05-ses-sqs-sns-1/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-05-ses-sqs-sns-1/">
            AWS: SQS,SNS,SES - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-05-ses-sqs-sns-2/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-05-ses-sqs-sns-2/">
            AWS: SQS,SNS,SES - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-11-eks-1/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-11-eks-1/">
            AWS: EKS - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-11-eks-2/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-11-eks-2/">
            AWS: EKS - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-11-eks-3/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-11-eks-3/">
            AWS: EKS - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-11-eks-4/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-11-eks-4/">
            AWS: EKS - 4
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-11-eks-5/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-11-eks-5/">
            AWS: EKS - 5
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/aws/aws-21-rds-1/" class="dd-item">
        <div>
          <a href="/cloud/aws/aws-21-rds-1/">
            AWS: RDS - 1
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/cloud/digito/" class="dd-item haschildren
        ">
      <div>
      <a href="/cloud/digito/">Digital Ocean</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/cloud/digito/digito-note-1/" class="dd-item">
        <div>
          <a href="/cloud/digito/digito-note-1/">
            DigitialOcean: Droplet
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/digito/digito-note-2/" class="dd-item">
        <div>
          <a href="/cloud/digito/digito-note-2/">
            DigitialOcean: Get Started
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/digito/digito-note-3/" class="dd-item">
        <div>
          <a href="/cloud/digito/digito-note-3/">
            DigitialOcean: First Web Host
          </a>
        </div>
    </li>
      <li data-nav-id="/cloud/digito/digito-note-4/" class="dd-item">
        <div>
          <a href="/cloud/digito/digito-note-4/">
            DigitialOcean: Lets Encrypt
          </a>
        </div>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li data-nav-id="/hacks/" class="dd-item haschildren
        ">
      <div>
      <a href="/hacks/">Hacks</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/hacks/windows-command-1/" class="dd-item">
        <div>
          <a href="/hacks/windows-command-1/">
            Windows cmd &amp; hotkey - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/windows-command-2/" class="dd-item">
        <div>
          <a href="/hacks/windows-command-2/">
            Windows cmd &amp; hotkey - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/windows-command-3/" class="dd-item">
        <div>
          <a href="/hacks/windows-command-3/">
            Windows cmd &amp; hotkey - 3
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/sftp-pgp/" class="dd-item">
        <div>
          <a href="/hacks/sftp-pgp/">
            SFTP &amp; GPG 
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/git-notes/" class="dd-item">
        <div>
          <a href="/hacks/git-notes/">
            Git Practices
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/cass-note/" class="dd-item">
        <div>
          <a href="/hacks/cass-note/">
            Cassandra Practices
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/php-debug/" class="dd-item">
        <div>
          <a href="/hacks/php-debug/">
            Debug PHP with Free IDE
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/docker-note/" class="dd-item">
        <div>
          <a href="/hacks/docker-note/">
            Docker Practices
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/qemu-notes/" class="dd-item">
        <div>
          <a href="/hacks/qemu-notes/">
            Qemu &amp; Virtual Machine
          </a>
        </div>
    </li>
      <li data-nav-id="/hacks/vbox-notes/" class="dd-item">
        <div>
          <a href="/hacks/vbox-notes/">
            VirtualBox Notes
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/management/" class="dd-item haschildren
        ">
      <div>
      <a href="/management/">Management</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/management/cmmi/" class="dd-item">
        <div>
          <a href="/management/cmmi/">
            CMMI
          </a>
        </div>
    </li>
      <li data-nav-id="/management/cmmi_v2/" class="dd-item">
        <div>
          <a href="/management/cmmi_v2/">
            CMMI 2.0
          </a>
        </div>
    </li>
      <li data-nav-id="/management/cobit_5/" class="dd-item">
        <div>
          <a href="/management/cobit_5/">
            COBIT 5
          </a>
        </div>
    </li>
      <li data-nav-id="/management/scrum_vs_kanban/" class="dd-item">
        <div>
          <a href="/management/scrum_vs_kanban/">
            Scrum VS Kanban
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/os/" class="dd-item haschildren
        ">
      <div>
      <a href="/os/">OS</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/os/ubuntu-desktop-20/" class="dd-item">
        <div>
          <a href="/os/ubuntu-desktop-20/">
            Ubuntu Desktop 20 LTS note
          </a>
        </div>
    </li>
      <li data-nav-id="/os/amazon-linux-2/" class="dd-item">
        <div>
          <a href="/os/amazon-linux-2/">
            Amazon Linux 2 
          </a>
        </div>
    </li>
      <li data-nav-id="/os/vpn-strongswam/" class="dd-item">
        <div>
          <a href="/os/vpn-strongswam/">
            VPN StrongSwam setup
          </a>
        </div>
    </li>
      <li data-nav-id="/os/vpn-vyos/" class="dd-item">
        <div>
          <a href="/os/vpn-vyos/">
            VPN VyOS setup
          </a>
        </div>
    </li>
      <li data-nav-id="/os/dual-boot-win10-ubuntu18/" class="dd-item">
        <div>
          <a href="/os/dual-boot-win10-ubuntu18/">
            Dual Boot Windows 10 &amp; Ubuntu 18
          </a>
        </div>
    </li>
      <li data-nav-id="/os/ubuntu-desktop-18/" class="dd-item">
        <div>
          <a href="/os/ubuntu-desktop-18/">
            Ubuntu Desktop 18 LTS note
          </a>
        </div>
    </li>
      <li data-nav-id="/os/raspberrypi-notes/" class="dd-item">
        <div>
          <a href="/os/raspberrypi-notes/">
            Raspberry Pi setup
          </a>
        </div>
    </li>
      <li data-nav-id="/os/lubuntu16-desktop/" class="dd-item">
        <div>
          <a href="/os/lubuntu16-desktop/">
            Lubuntu 16 desktop
          </a>
        </div>
    </li>
      <li data-nav-id="/os/grub-trouble-shooting/" class="dd-item">
        <div>
          <a href="/os/grub-trouble-shooting/">
            Grub Trouble Shooting
          </a>
        </div>
    </li>
      <li data-nav-id="/os/ubuntu-server-16/" class="dd-item">
        <div>
          <a href="/os/ubuntu-server-16/">
            Ubuntu 16 server note
          </a>
        </div>
    </li>
      <li data-nav-id="/os/centos-server-7/" class="dd-item">
        <div>
          <a href="/os/centos-server-7/">
            CentOS 7 Server
          </a>
        </div>
    </li>
      <li data-nav-id="/os/ubuntu-server-14/" class="dd-item">
        <div>
          <a href="/os/ubuntu-server-14/">
            Ubuntu 14 -- server setup
          </a>
        </div>
    </li>
      <li data-nav-id="/os/ubuntu-desktop-14/" class="dd-item">
        <div>
          <a href="/os/ubuntu-desktop-14/">
            Ubuntu 14 -- desktop setup &amp; dual boot 
          </a>
        </div>
    </li>
      <li data-nav-id="/os/ubuntu-desktop-14-extra-tools/" class="dd-item">
        <div>
          <a href="/os/ubuntu-desktop-14-extra-tools/">
            Ubuntu 14 -- desktop, extra tools
          </a>
        </div>
    </li>
      <li data-nav-id="/os/mac-intel64/" class="dd-item">
        <div>
          <a href="/os/mac-intel64/">
            Macbook Notes - Intel X64
          </a>
        </div>
    </li>
      <li data-nav-id="/os/centos-fedora-desktop/" class="dd-item">
        <div>
          <a href="/os/centos-fedora-desktop/">
            CentOS 6/7 Multi-Boot Setup
          </a>
        </div>
    </li>
      <li data-nav-id="/os/powershell-7/" class="dd-item">
        <div>
          <a href="/os/powershell-7/">
            PowerShell 7
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/blogs/" class="dd-item haschildren
        ">
      <div>
      <a href="/blogs/">Blogs</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/blogs/k8s-on-vm/" class="dd-item">
        <div>
          <a href="/blogs/k8s-on-vm/">
            Try Minikube
          </a>
        </div>
    </li>
      <li data-nav-id="/blogs/vue-ng-react/" class="dd-item">
        <div>
          <a href="/blogs/vue-ng-react/">
            Angular vs React vs Vue
          </a>
        </div>
    </li>
      <li data-nav-id="/blogs/create-a-blog-on-github/" class="dd-item">
        <div>
          <a href="/blogs/create-a-blog-on-github/">
            Create a blog site on GitHub Pages
          </a>
        </div>
    </li>
      <li data-nav-id="/blogs/build-mobile-app/" class="dd-item">
        <div>
          <a href="/blogs/build-mobile-app/">
            Build mobile app with web tech
          </a>
        </div>
    </li>
      <li data-nav-id="/blogs/azure-notes/" class="dd-item">
        <div>
          <a href="/blogs/azure-notes/">
            Azure Practices
          </a>
        </div>
    </li>
      <li data-nav-id="/blogs/javascript-oop/" class="dd-item">
        <div>
          <a href="/blogs/javascript-oop/">
            JavaScript and OOP
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/frameworks/" class="dd-item haschildren
        ">
      <div>
      <a href="/frameworks/">Frameworks</a><i class="fa fa-angle-right fa-lg category-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/frameworks/cntk-notes-1/" class="dd-item">
        <div>
          <a href="/frameworks/cntk-notes-1/">
            CNTK Note - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/frameworks/tensorflow-notes-1/" class="dd-item">
        <div>
          <a href="/frameworks/tensorflow-notes-1/">
            Tensorflow Note - 1
          </a>
        </div>
    </li>
      <li data-nav-id="/frameworks/tensorflow-notes-2/" class="dd-item">
        <div>
          <a href="/frameworks/tensorflow-notes-2/">
            Tensorflow Note - 2
          </a>
        </div>
    </li>
      <li data-nav-id="/frameworks/php-web/" class="dd-item">
        <div>
          <a href="/frameworks/php-web/">
            PHP Web Framework
          </a>
        </div>
    </li>
      <li data-nav-id="/frameworks/python-django/" class="dd-item">
        <div>
          <a href="/frameworks/python-django/">
            Python Web Framework
          </a>
        </div>
    </li>
        </ul>
    </li>




    </ul>
    <section>
    </section>
  </aside>
  <section class="page">
    
    <div class="nav-select">
      <center>Navigation : 
        <select onchange="javascript:location.href = this.value;">
          
    <option value="/projects/" >
   Projects</option>
    <option value="/coding/" >
   Coding</option> 
    <option value="/coding/c/" >
  - 
   C </option> 
      <option value="/coding/c/lcthw-lectures.1/" >-- C Lecture - 1</option>
      <option value="/coding/c/lcthw-lectures.2/"  selected>-- C Lecture - 2</option>
      <option value="/coding/c/lcthw-lectures.3/" >-- C Lecture - 3</option>
      <option value="/coding/c/lcthw-lectures.4/" >-- C Lecture - 4</option>
  
    <option value="/coding/c-sharp/" >
  - 
   C#</option>
    <option value="/coding/db-sql/" >
  - 
   DB &amp; SQL</option>
    <option value="/coding/f-sharp/" >
  - 
   F#</option>
    <option value="/coding/golang/" >
  - 
   Golang</option>
    <option value="/coding/js-ts/" >
  - 
   JS &amp; TS </option>
    <option value="/coding/java/" >
  - 
   Java</option>
    <option value="/coding/python/" >
  - 
   Python</option>
    <option value="/coding/rustlang/" >
  - 
   Rustlang</option>
    <option value="/coding/shell/" >
  - 
   Shell</option>
  
    <option value="/cloud/" >
   Cloud</option>
    <option value="/hacks/" >
   Hacks</option>
    <option value="/management/" >
   Management</option>
    <option value="/os/" >
   OS</option>
    <option value="/blogs/" >
   Blogs</option>
    <option value="/frameworks/" >
   Frameworks</option>



        </select>
      </center>
    </div>


    


    
    
    
<div class="main-page">
    <div class="flex-item main-content">
            <h1>C Lecture - 2</h1>
        

<p>Author: Zed A. Shaw</p>

<p>All content comes from Zed&rsquo;s <a href="https://github.com/zedshaw/learn-c-the-hard-way-lectures.git">Lecture Repository</a> and <a href="https://github.com/zedshaw/liblcthw">Libraries Repository</a>.  All credit goes to Zed.</p>

<h3 id="exercise-32-double-linked-lists">Exercise 32 Double Linked Lists</h3>

<p>The Plan</p>

<p>Learn about your very first data structure:</p>

<p>Double Linked Lists</p>

<p>Creating A liblcthw Project</p>

<p>We&rsquo;ll need a project for the rest of the book called <em>liblcthw</em>.</p>

<p>Algorithms and Data Structures</p>

<p>A big step in going from amateur to professional is learning
about data structures and algorithms.</p>

<p>A double linked list is the easiest one.</p>

<p>Double Linked Lists Visually</p>

<p>I&rsquo;ll quickly draw some diagrams to show you how they work.</p>

<p>Automated Testing Demo</p>

<p>You can enter the code just fine, but watch me write
the test.</p>

<p>Code Reviews</p>

<p>.\ex32\list.h</p>

<pre><code class="language-c">#ifndef lcthw_List_h
#define lcthw_List_h

#include &lt;stdlib.h&gt;

struct ListNode;

typedef struct ListNode {
    struct ListNode *next;
    struct ListNode *prev;
    void *value;
} ListNode;

typedef struct List {
    int count;
    ListNode *first;
    ListNode *last;
} List;

List *List_create();
void List_destroy(List * list);
void List_clear(List * list);
void List_clear_destroy(List * list);

#define List_count(A) ((A)-&gt;count)
#define List_first(A) ((A)-&gt;first != NULL ? (A)-&gt;first-&gt;value : NULL)
#define List_last(A) ((A)-&gt;last != NULL ? (A)-&gt;last-&gt;value : NULL)

void List_push(List * list, void *value);
void *List_pop(List * list);

void List_unshift(List * list, void *value);
void *List_shift(List * list);

void *List_remove(List * list, ListNode * node);

#define LIST_FOREACH(L, S, M, V) ListNode *_node = NULL;\
                                                   ListNode *V = NULL;\
for(V = _node = L-&gt;S; _node != NULL; V = _node = _node-&gt;M)

#endif

</code></pre>

<p>.\ex32\list.c</p>

<pre><code class="language-c">#include &lt;lcthw/list.h&gt;
#include &lt;lcthw/dbg.h&gt;

List *List_create()
{
    return calloc(1, sizeof(List));
}

void List_destroy(List * list)
{
    LIST_FOREACH(list, first, next, cur) {
        if (cur-&gt;prev) {
            free(cur-&gt;prev);
        }
    }

    free(list-&gt;last);
    free(list);
}

void List_clear(List * list)
{
    LIST_FOREACH(list, first, next, cur) {
        free(cur-&gt;value);
    }
}

void List_clear_destroy(List * list)
{
    List_clear(list);
    List_destroy(list);
}

void List_push(List * list, void *value)
{
    ListNode *node = calloc(1, sizeof(ListNode));
    check_mem(node);

    node-&gt;value = value;

    if (list-&gt;last == NULL) {
        list-&gt;first = node;
        list-&gt;last = node;
    } else {
        list-&gt;last-&gt;next = node;
        node-&gt;prev = list-&gt;last;
        list-&gt;last = node;
    }

    list-&gt;count++;

error:
    return;
}

void *List_pop(List * list)
{
    ListNode *node = list-&gt;last;
    return node != NULL ? List_remove(list, node) : NULL;
}

void List_unshift(List * list, void *value)
{
    ListNode *node = calloc(1, sizeof(ListNode));
    check_mem(node);

    node-&gt;value = value;

    if (list-&gt;first == NULL) {
        list-&gt;first = node;
        list-&gt;last = node;
    } else {
        node-&gt;next = list-&gt;first;
        list-&gt;first-&gt;prev = node;
        list-&gt;first = node;
    }

    list-&gt;count++;

error:
    return;
}

void *List_shift(List * list)
{
    ListNode *node = list-&gt;first;
    return node != NULL ? List_remove(list, node) : NULL;
}

void *List_remove(List * list, ListNode * node)
{
    void *result = NULL;

    check(list-&gt;first &amp;&amp; list-&gt;last, &quot;List is empty.&quot;);
    check(node, &quot;node can't be NULL&quot;);

    if (node == list-&gt;first &amp;&amp; node == list-&gt;last) {
        list-&gt;first = NULL;
        list-&gt;last = NULL;
    } else if (node == list-&gt;first) {
        list-&gt;first = node-&gt;next;
        check(list-&gt;first != NULL,
                &quot;Invalid list, somehow got a first that is NULL.&quot;);
        list-&gt;first-&gt;prev = NULL;
    } else if (node == list-&gt;last) {
        list-&gt;last = node-&gt;prev;
        check(list-&gt;last != NULL,
                &quot;Invalid list, somehow got a next that is NULL.&quot;);
        list-&gt;last-&gt;next = NULL;
    } else {
        ListNode *after = node-&gt;next;
        ListNode *before = node-&gt;prev;
        after-&gt;prev = before;
        before-&gt;next = after;
    }

    list-&gt;count--;
    result = node-&gt;value;
    free(node);

error:
    return result;
}

</code></pre>

<p>.\ex32\list_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;lcthw/list.h&gt;
#include &lt;assert.h&gt;

static List *list = NULL;
char *test1 = &quot;test1 data&quot;;
char *test2 = &quot;test2 data&quot;;
char *test3 = &quot;test3 data&quot;;

char *test_create()
{
    list = List_create();
    mu_assert(list != NULL, &quot;Failed to create list.&quot;);

    return NULL;
}

char *test_destroy()
{
    List_clear_destroy(list);

    return NULL;

}

char *test_push_pop()
{
    List_push(list, test1);
    mu_assert(List_last(list) == test1, &quot;Wrong last value.&quot;);

    List_push(list, test2);
    mu_assert(List_last(list) == test2, &quot;Wrong last value&quot;);

    List_push(list, test3);
    mu_assert(List_last(list) == test3, &quot;Wrong last value.&quot;);
    mu_assert(List_count(list) == 3, &quot;Wrong count on push.&quot;);

    char *val = List_pop(list);
    mu_assert(val == test3, &quot;Wrong value on pop.&quot;);

    val = List_pop(list);
    mu_assert(val == test2, &quot;Wrong value on pop.&quot;);

    val = List_pop(list);
    mu_assert(val == test1, &quot;Wrong value on pop.&quot;);
    mu_assert(List_count(list) == 0, &quot;Wrong count after pop.&quot;);

    return NULL;
}

char *test_unshift()
{
    List_unshift(list, test1);
    mu_assert(List_first(list) == test1, &quot;Wrong first value.&quot;);

    List_unshift(list, test2);
    mu_assert(List_first(list) == test2, &quot;Wrong first value&quot;);

    List_unshift(list, test3);
    mu_assert(List_first(list) == test3, &quot;Wrong last value.&quot;);
    mu_assert(List_count(list) == 3, &quot;Wrong count on unshift.&quot;);

    return NULL;
}

char *test_remove()
{
    // we only need to test the middle remove case since push/shift 
    // already tests the other cases

    char *val = List_remove(list, list-&gt;first-&gt;next);
    mu_assert(val == test2, &quot;Wrong removed element.&quot;);
    mu_assert(List_count(list) == 2, &quot;Wrong count after remove.&quot;);
    mu_assert(List_first(list) == test3, &quot;Wrong first after remove.&quot;);
    mu_assert(List_last(list) == test1, &quot;Wrong last after remove.&quot;);

    return NULL;
}

char *test_shift()
{
    mu_assert(List_count(list) != 0, &quot;Wrong count before shift.&quot;);

    char *val = List_shift(list);
    mu_assert(val == test3, &quot;Wrong value on shift.&quot;);

    val = List_shift(list);
    mu_assert(val == test1, &quot;Wrong value on shift.&quot;);
    mu_assert(List_count(list) == 0, &quot;Wrong count after shift.&quot;);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_create);
    mu_run_test(test_push_pop);
    mu_run_test(test_unshift);
    mu_run_test(test_remove);
    mu_run_test(test_shift);
    mu_run_test(test_destroy);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>Later videos will demonstrate how to code review to make code solid.</p>

<p>Improving It</p>

<ul>
<li>You can make <code>List_clear_destroy</code> more efficient by using
<code>LIST_FOREACH</code> and doing both <code>free</code> calls inside one
loop.</li>
<li>You can add asserts for preconditions so that the program isn&rsquo;t given a <code>NULL</code>
value for the <code>List *list</code> parameters.</li>
</ul>

<p>Improving It</p>

<ul>
<li>You can add invariants that check that the list&rsquo;s contents are always correct,
such as <code>count</code> is never <code>&lt; 0</code>, and if <code>count &gt; 0</code>, then <code>first</code> isn&rsquo;t NULL.</li>
<li>You can add documentation to the header file in the form of comments before
each struct, function, and macro that describes what it does.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Research doubly vs. singly linked lists and when one is preferred over
the other.</li>
<li>Research the limitations of a doubly linked list.  For example, while they
are efficient for inserting and deleting elements, they are very slow for
iterating over them all.</li>
<li>What operations are missing that you can imagine needing?  Some examples
are copying, joining, and splitting.  Implement these operations and write the
unit tests for them.</li>
</ul>

<h3 id="exercise-33-linked-list-algorithms">Exercise 33 Linked List Algorithms</h3>

<p>The Plan</p>

<p>Learn two sorting algorithms for double linked lists.</p>

<p>Watch how to conduct a simple code review.</p>

<p>The Code</p>

<p>.\ex33\list_algos.h</p>

<pre><code class="language-c">#ifndef lcthw_List_algos_h
#define lcthw_List_algos_h

#include &lt;lcthw/list.h&gt;

typedef int (*List_compare) (const void *a, const void *b);

int List_bubble_sort(List * list, List_compare cmp);

List *List_merge_sort(List * list, List_compare cmp);

#endif

</code></pre>

<p>.\ex33\list_algos.c</p>

<pre><code class="language-c">#include &lt;lcthw/list_algos.h&gt;
#include &lt;lcthw/dbg.h&gt;

inline void ListNode_swap(ListNode * a, ListNode * b)
{
    void *temp = a-&gt;value;
    a-&gt;value = b-&gt;value;
    b-&gt;value = temp;
}

int List_bubble_sort(List * list, List_compare cmp)
{
    int sorted = 1;

    if (List_count(list) &lt;= 1) {
        return 0;        // already sorted
    }

    do {
        sorted = 1;
        LIST_FOREACH(list, first, next, cur) {
            if (cur-&gt;next) {
                if (cmp(cur-&gt;value, cur-&gt;next-&gt;value) &gt; 0) {
                    ListNode_swap(cur, cur-&gt;next);
                    sorted = 0;
                }
            }
        }
    } while (!sorted);

    return 0;
}

inline List *List_merge(List * left, List * right, List_compare cmp)
{
    List *result = List_create();
    void *val = NULL;

    while (List_count(left) &gt; 0 || List_count(right) &gt; 0) {
        if (List_count(left) &gt; 0 &amp;&amp; List_count(right) &gt; 0) {
            if (cmp(List_first(left), List_first(right)) &lt;= 0) {
                val = List_shift(left);
            } else {
                val = List_shift(right);
            }

            List_push(result, val);
        } else if (List_count(left) &gt; 0) {
            val = List_shift(left);
            List_push(result, val);
        } else if (List_count(right) &gt; 0) {
            val = List_shift(right);
            List_push(result, val);
        }
    }

    return result;
}

List *List_merge_sort(List * list, List_compare cmp)
{
    List *result = NULL;

    if (List_count(list) &lt;= 1) {
        return list;
    }

    List *left = List_create();
    List *right = List_create();
    int middle = List_count(list) / 2;

    LIST_FOREACH(list, first, next, cur) {
        if (middle &gt; 0) {
            List_push(left, cur-&gt;value);
        } else {
            List_push(right, cur-&gt;value);
        }

        middle--;
    }

    List *sort_left = List_merge_sort(left, cmp);
    List *sort_right = List_merge_sort(right, cmp);

    if (sort_left != left)
        List_destroy(left);
    if (sort_right != right)
        List_destroy(right);

    result = List_merge(sort_left, sort_right, cmp);

    List_destroy(sort_left);
    List_destroy(sort_right);

    return result;
}

</code></pre>

<p>.\ex33\list_algos_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;lcthw/list_algos.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;

char *values[] = { &quot;XXXX&quot;, &quot;1234&quot;, &quot;abcd&quot;, &quot;xjvef&quot;, &quot;NDSS&quot; };

#define NUM_VALUES 5

List *create_words()
{
    int i = 0;
    List *words = List_create();

    for (i = 0; i &lt; NUM_VALUES; i++) {
        List_push(words, values[i]);
    }

    return words;
}

int is_sorted(List * words)
{
    LIST_FOREACH(words, first, next, cur) {
        if (cur-&gt;next &amp;&amp; strcmp(cur-&gt;value, cur-&gt;next-&gt;value) &gt; 0) {
            debug(&quot;%s %s&quot;, (char *)cur-&gt;value,
                    (char *)cur-&gt;next-&gt;value);
            return 0;
        }
    }

    return 1;
}

char *test_bubble_sort()
{
    List *words = create_words();

    // should work on a list that needs sorting
    int rc = List_bubble_sort(words, (List_compare) strcmp);
    mu_assert(rc == 0, &quot;Bubble sort failed.&quot;);
    mu_assert(is_sorted(words),
            &quot;Words are not sorted after bubble sort.&quot;);

    // should work on an already sorted list
    rc = List_bubble_sort(words, (List_compare) strcmp);
    mu_assert(rc == 0, &quot;Bubble sort of already sorted failed.&quot;);
    mu_assert(is_sorted(words),
            &quot;Words should be sort if already bubble sorted.&quot;);

    List_destroy(words);

    // should work on an empty list
    words = List_create(words);
    rc = List_bubble_sort(words, (List_compare) strcmp);
    mu_assert(rc == 0, &quot;Bubble sort failed on empty list.&quot;);
    mu_assert(is_sorted(words), &quot;Words should be sorted if empty.&quot;);

    List_destroy(words);

    return NULL;
}

char *test_merge_sort()
{
    List *words = create_words();

    // should work on a list that needs sorting
    List *res = List_merge_sort(words, (List_compare) strcmp);
    mu_assert(is_sorted(res), &quot;Words are not sorted after merge sort.&quot;);

    List *res2 = List_merge_sort(res, (List_compare) strcmp);
    mu_assert(is_sorted(res),
            &quot;Should still be sorted after merge sort.&quot;);
    List_destroy(res2);
    List_destroy(res);

    List_destroy(words);
    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_bubble_sort);
    mu_run_test(test_merge_sort);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>You should be able to create this and figure out how it works.</p>

<p>I will assume you&rsquo;ve done that, and now to code review.</p>

<p>Bubble Sort</p>

<p>Code review of bubble sort.</p>

<p>Start with the unit test and move from there.</p>

<p>Merge Sort</p>

<p>Code review of merge sort.</p>

<p>Improving It</p>

<ul>
<li>The merge sort does a crazy amount of copying and creating lists, so find ways to reduce this.</li>
<li>The bubble sort description in Wikipedia mentions a few optimizations. Try to implement them.</li>
<li>Can you use the <code>List_split</code> and <code>List_join</code> (if you implemented them) to improve merge sort?</li>
<li>Go through of all the defensive programming checks and improve the robustness of
this implementation, protecting against bad <code>NULL</code> pointers, and then create
an optional debug level invariant that works like <code>is_sorted</code> does
after a sort.</li>
</ul>

<p>Breaking It</p>

<ul>
<li>Overload the data structure to hit the worst case time complexity.</li>
<li>Give it a bad data structure.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Create a unit test that compares the performance of the two algorithms.  You&rsquo;ll want to look at <code>man 3 time</code> for a basic timer function,
and run enough iterations to at least have a few seconds of samples.</li>
<li>Play with the amount of data in the lists that need to be sorted and see if that changes your timing.</li>
<li>Find a way to simulate filling different sized random lists, measuring how long they take. Then, graph the result to see how it compares to the
description of the algorithm.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Try to explain why sorting linked lists is a really bad idea.</li>
<li>Implement a <code>List_insert_sorted</code> that will take a given value, and using the <code>List_compare</code>, insert the element at the
right position so that the list is always sorted.  How does using this method compare to sorting a list after you&rsquo;ve built it?</li>
<li>Try implementing the bottom-up merge sort described on the Wikipedia page.  The code there is already C, so it should be easy to
recreate, but try to understand how it&rsquo;s working compared to the slower one I have here.</li>
</ul>

<h3 id="exercise-34-dynamic-array">Exercise 34 Dynamic Array</h3>

<p>The Plan</p>

<p>Learn about dynamic arrays, a very useful datastructure.</p>

<p>Code Review</p>

<p>.\ex34\darray.h</p>

<pre><code class="language-c">#ifndef _DArray_h
#define _DArray_h
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;lcthw/dbg.h&gt;

typedef struct DArray {
    int end;
    int max;
    size_t element_size;
    size_t expand_rate;
    void **contents;
} DArray;

DArray *DArray_create(size_t element_size, size_t initial_max);

void DArray_destroy(DArray * array);

void DArray_clear(DArray * array);

int DArray_expand(DArray * array);

int DArray_contract(DArray * array);

int DArray_push(DArray * array, void *el);

void *DArray_pop(DArray * array);

void DArray_clear_destroy(DArray * array);

#define DArray_last(A) ((A)-&gt;contents[(A)-&gt;end - 1])
#define DArray_first(A) ((A)-&gt;contents[0])
#define DArray_end(A) ((A)-&gt;end)
#define DArray_count(A) DArray_end(A)
#define DArray_max(A) ((A)-&gt;max)

#define DEFAULT_EXPAND_RATE 300

static inline void DArray_set(DArray * array, int i, void *el)
{
    check(i &lt; array-&gt;max, &quot;darray attempt to set past max&quot;);
    if (i &gt; array-&gt;end)
        array-&gt;end = i;
    array-&gt;contents[i] = el;
error:
    return;
}

static inline void *DArray_get(DArray * array, int i)
{
    check(i &lt; array-&gt;max, &quot;darray attempt to get past max&quot;);
    return array-&gt;contents[i];
error:
    return NULL;
}

static inline void *DArray_remove(DArray * array, int i)
{
    void *el = array-&gt;contents[i];

    array-&gt;contents[i] = NULL;

    return el;
}

static inline void *DArray_new(DArray * array)
{
    check(array-&gt;element_size &gt; 0,
            &quot;Can't use DArray_new on 0 size darrays.&quot;);

    return calloc(1, array-&gt;element_size);

error:
    return NULL;
}

#define DArray_free(E) free((E))

#endif

</code></pre>

<p>.\ex34\darray.c</p>

<pre><code class="language-c">#include &lt;lcthw/darray.h&gt;
#include &lt;assert.h&gt;

DArray *DArray_create(size_t element_size, size_t initial_max)
{
    DArray *array = malloc(sizeof(DArray));
    check_mem(array);
    array-&gt;max = initial_max;
    check(array-&gt;max &gt; 0, &quot;You must set an initial_max &gt; 0.&quot;);

    array-&gt;contents = calloc(initial_max, sizeof(void *));
    check_mem(array-&gt;contents);

    array-&gt;end = 0;
    array-&gt;element_size = element_size;
    array-&gt;expand_rate = DEFAULT_EXPAND_RATE;

    return array;

error:
    if (array)
        free(array);
    return NULL;
}

void DArray_clear(DArray * array)
{
    int i = 0;
    if (array-&gt;element_size &gt; 0) {
        for (i = 0; i &lt; array-&gt;max; i++) {
            if (array-&gt;contents[i] != NULL) {
                free(array-&gt;contents[i]);
            }
        }
    }
}

static inline int DArray_resize(DArray * array, size_t newsize)
{
    array-&gt;max = newsize;
    check(array-&gt;max &gt; 0, &quot;The newsize must be &gt; 0.&quot;);

    void *contents = realloc(
            array-&gt;contents, array-&gt;max * sizeof(void *));
    // check contents and assume realloc doesn't harm the original on error

    check_mem(contents);

    array-&gt;contents = contents;

    return 0;
error:
    return -1;
}

int DArray_expand(DArray * array)
{
    size_t old_max = array-&gt;max;
    check(DArray_resize(array, array-&gt;max + array-&gt;expand_rate) == 0,
            &quot;Failed to expand array to new size: %d&quot;,
            array-&gt;max + (int)array-&gt;expand_rate);

    memset(array-&gt;contents + old_max, 0, array-&gt;expand_rate + 1);
    return 0;

error:
    return -1;
}

int DArray_contract(DArray * array)
{
    int new_size = array-&gt;end &lt; (int)array-&gt;expand_rate ? 
            (int)array-&gt;expand_rate : array-&gt;end;

    return DArray_resize(array, new_size + 1);
}

void DArray_destroy(DArray * array)
{
    if (array) {
        if (array-&gt;contents)
            free(array-&gt;contents);
        free(array);
    }
}

void DArray_clear_destroy(DArray * array)
{
    DArray_clear(array);
    DArray_destroy(array);
}

int DArray_push(DArray * array, void *el)
{
    array-&gt;contents[array-&gt;end] = el;
    array-&gt;end++;

    if (DArray_end(array) &gt;= DArray_max(array)) {
        return DArray_expand(array);
    } else {
        return 0;
    }
}

void *DArray_pop(DArray * array)
{
    check(array-&gt;end - 1 &gt;= 0, &quot;Attempt to pop from empty array.&quot;);

    void *el = DArray_remove(array, array-&gt;end - 1);
    array-&gt;end--;

    if (DArray_end(array) &gt; (int)array-&gt;expand_rate
            &amp;&amp; DArray_end(array) % array-&gt;expand_rate) {
        DArray_contract(array);
    }

    return el;
error:
    return NULL;
}

</code></pre>

<p>.\ex34\darray_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;lcthw/darray.h&gt;

static DArray *array = NULL;
static int *val1 = NULL;
static int *val2 = NULL;

char *test_create()
{
    array = DArray_create(sizeof(int), 100);
    mu_assert(array != NULL, &quot;DArray_create failed.&quot;);
    mu_assert(array-&gt;contents != NULL, &quot;contents are wrong in darray&quot;);
    mu_assert(array-&gt;end == 0, &quot;end isn't at the right spot&quot;);
    mu_assert(array-&gt;element_size == sizeof(int),
            &quot;element size is wrong.&quot;);
    mu_assert(array-&gt;max == 100, &quot;wrong max length on initial size&quot;);

    return NULL;
}

char *test_destroy()
{
    DArray_destroy(array);

    return NULL;
}

char *test_new()
{
    val1 = DArray_new(array);
    mu_assert(val1 != NULL, &quot;failed to make a new element&quot;);

    val2 = DArray_new(array);
    mu_assert(val2 != NULL, &quot;failed to make a new element&quot;);

    return NULL;
}

char *test_set()
{
    DArray_set(array, 0, val1);
    DArray_set(array, 1, val2);

    return NULL;
}

char *test_get()
{
    mu_assert(DArray_get(array, 0) == val1, &quot;Wrong first value.&quot;);
    mu_assert(DArray_get(array, 1) == val2, &quot;Wrong second value.&quot;);

    return NULL;
}

char *test_remove()
{
    int *val_check = DArray_remove(array, 0);
    mu_assert(val_check != NULL, &quot;Should not get NULL.&quot;);
    mu_assert(*val_check == *val1, &quot;Should get the first value.&quot;);
    mu_assert(DArray_get(array, 0) == NULL, &quot;Should be gone.&quot;);
    DArray_free(val_check);

    val_check = DArray_remove(array, 1);
    mu_assert(val_check != NULL, &quot;Should not get NULL.&quot;);
    mu_assert(*val_check == *val2, &quot;Should get the first value.&quot;);
    mu_assert(DArray_get(array, 1) == NULL, &quot;Should be gone.&quot;);
    DArray_free(val_check);

    return NULL;
}

char *test_expand_contract()
{
    int old_max = array-&gt;max;
    DArray_expand(array);
    mu_assert((unsigned int)array-&gt;max == old_max + array-&gt;expand_rate,
            &quot;Wrong size after expand.&quot;);

    DArray_contract(array);
    mu_assert((unsigned int)array-&gt;max == array-&gt;expand_rate + 1,
            &quot;Should stay at the expand_rate at least.&quot;);

    DArray_contract(array);
    mu_assert((unsigned int)array-&gt;max == array-&gt;expand_rate + 1,
            &quot;Should stay at the expand_rate at least.&quot;);

    return NULL;
}

char *test_push_pop()
{
    int i = 0;
    for (i = 0; i &lt; 1000; i++) {
        int *val = DArray_new(array);
        *val = i * 333;
        DArray_push(array, val);
    }

    mu_assert(array-&gt;max == 1201, &quot;Wrong max size.&quot;);

    for (i = 999; i &gt;= 0; i--) {
        int *val = DArray_pop(array);
        mu_assert(val != NULL, &quot;Shouldn't get a NULL.&quot;);
        mu_assert(*val == i * 333, &quot;Wrong value.&quot;);
        DArray_free(val);
    }

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_create);
    mu_run_test(test_new);
    mu_run_test(test_set);
    mu_run_test(test_get);
    mu_run_test(test_remove);
    mu_run_test(test_expand_contract);
    mu_run_test(test_push_pop);
    mu_run_test(test_destroy);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>Starting with the header file to implement, then the test, then the implementation.</p>

<p>The Analysis</p>

<p>DArray Advantages</p>

<ul>
<li>Iteration:  You can just use a basic for-loop and <code>DArray_count</code>
with <code>DArray_get</code>, and you&rsquo;re done.  No special macros needed, and
it&rsquo;s faster because you aren&rsquo;t walking through pointers.</li>
<li>Indexing:  You can use <code>DArray_get</code> and <code>DArray_set</code> to
access any element at random, but with a <code>List</code> you have to go
through N elements to get to N+1.</li>
<li>Destroying:  You can just free the struct and the <code>contents</code> in
two operations.  A <code>List</code> requires a series of <code>free</code> calls
and walking every element.</li>
</ul>

<p>DArray Advantages</p>

<ul>
<li>Cloning: You can also clone it in just two operations (plus whatever
it&rsquo;s storing) by copying the struct and <code>contents</code>.  A list
again requires walking through the whole thing and copying every <code>ListNode</code>
plus its value.</li>
<li>Sorting: As you saw, <code>List</code> is horrible if you need to keep the
data sorted.  A <code>DArray</code> opens up a whole class of great sorting
algorithms, because now you can access elements randomly.</li>
<li>Large Data: If you need to keep around a lot of data, then a <code>DArray</code>
wins since its base, <code>contents</code>, takes up less memory than the same
number of <code>ListNode</code> structs.</li>
</ul>

<p>DArray Disadvantages</p>

<ul>
<li>Insert and remove on the front (what I called shift).  A <code>DArray</code>
needs special treatment to be able to do this efficiently, and usually it
has to do some copying.</li>
<li>Splitting or joining:  A <code>List</code> can just copy some pointers and
it&rsquo;s done, but with a <code>DArray</code>, you have copy all of the
arrays involved.</li>
</ul>

<p>DArray Disadvantages</p>

<ul>
<li>Small Data. If you only need to store a few elements, then typically the
storage will be less in a <code>List</code> than a generic <code>DArray</code>. This is because
the <code>DArray</code> needs to expand the backing store to accommodate future
inserts, while a <code>List</code> only makes what it needs.</li>
</ul>

<p>Breaking It</p>

<ul>
<li>Forget to check the return value from malloc and then use the buffer.</li>
<li>Getting the end and start count of the buffer wrong.  Easy to do an off-by-one here.</li>
<li>Exploit the insert and delete costs to cause a denial of service.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Improve the unit tests to cover more of the operations, and test them
using a for-loop to ensure that they work.</li>
<li>Research what it would take to implement bubble sort and merge sort
for DArray, but don&rsquo;t do it yet.  I&rsquo;ll be implementing DArray algorithms
next, so you&rsquo;ll do this then.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Write some performance tests for common operations and compare them
to the same operations in <code>List</code>.  You did some of this already, but this
time, write a unit test that repeatedly does the operation in question, and
then in the main runner, do the timing.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Look at how the <code>DArray_expand</code> is implemented using a constant increase (size + 300).
Typically, dynamic arrays are implemented with a multiplicative increase (size * 2), but I&rsquo;ve
found this to cost needless memory for no real performance gain.  Test my assertion
and see when you&rsquo;d want a multiplicative increase instead of a constant increase.</li>
</ul>

<h3 id="exercise-35-sorting-and-searching">Exercise 35 Sorting and Searching</h3>

<p>The Plan</p>

<ul>
<li>Make a simple DArray sorting library using existing functions.</li>
<li>Implement a new structure and algorithm called a &ldquo;Radix Map&rdquo;.</li>
<li>Create a binary search algorithm for the RadixMap.</li>
</ul>

<p>The DArray Code</p>

<p>.\ex35\darray_algos.h</p>

<pre><code class="language-c">#ifndef darray_algos_h
#define darray_algos_h

#include &lt;lcthw/darray.h&gt;

typedef int (*DArray_compare) (const void *a, const void *b);

int DArray_qsort(DArray * array, DArray_compare cmp);

int DArray_heapsort(DArray * array, DArray_compare cmp);

int DArray_mergesort(DArray * array, DArray_compare cmp);

#endif

</code></pre>

<p>.\ex35\darray_algos.c</p>

<pre><code class="language-c">#include &lt;lcthw/darray_algos.h&gt;
#include &lt;stdlib.h&gt;

int DArray_qsort(DArray * array, DArray_compare cmp)
{
    qsort(array-&gt;contents, DArray_count(array), sizeof(void *), cmp);
    return 0;
}

int DArray_heapsort(DArray * array, DArray_compare cmp)
{
    return heapsort(array-&gt;contents, DArray_count(array),
            sizeof(void *), cmp);
}

int DArray_mergesort(DArray * array, DArray_compare cmp)
{
    return mergesort(array-&gt;contents, DArray_count(array),
            sizeof(void *), cmp);
}

</code></pre>

<p>.\ex35\darray_algos_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;lcthw/darray_algos.h&gt;

int testcmp(char **a, char **b)
{
    return strcmp(*a, *b);
}

DArray *create_words()
{
    DArray *result = DArray_create(0, 5);
    char *words[] = { &quot;asdfasfd&quot;,
        &quot;werwar&quot;, &quot;13234&quot;, &quot;asdfasfd&quot;, &quot;oioj&quot; };
    int i = 0;

    for (i = 0; i &lt; 5; i++) {
        DArray_push(result, words[i]);
    }

    return result;
}

int is_sorted(DArray * array)
{
    int i = 0;

    for (i = 0; i &lt; DArray_count(array) - 1; i++) {
        if (strcmp(DArray_get(array, i), DArray_get(array, i + 1)) &gt; 0) {
            return 0;
        }
    }

    return 1;
}

char *run_sort_test(int (*func) (DArray *, DArray_compare),
        const char *name)
{
    DArray *words = create_words();
    mu_assert(!is_sorted(words), &quot;Words should start not sorted.&quot;);

    debug(&quot;--- Testing %s sorting algorithm&quot;, name);
    int rc = func(words, (DArray_compare) testcmp);
    mu_assert(rc == 0, &quot;sort failed&quot;);
    mu_assert(is_sorted(words), &quot;didn't sort it&quot;);

    DArray_destroy(words);

    return NULL;
}

char *test_qsort()
{
    return run_sort_test(DArray_qsort, &quot;qsort&quot;);
}

char *test_heapsort()
{
    return run_sort_test(DArray_heapsort, &quot;heapsort&quot;);
}

char *test_mergesort()
{
    return run_sort_test(DArray_mergesort, &quot;mergesort&quot;);
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_qsort);
    mu_run_test(test_heapsort);
    mu_run_test(test_mergesort);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>Continuing the code review method with a part of DArray.</p>

<p>The RadixMap Code</p>

<p>.\ex35\radixmap.h</p>

<pre><code class="language-c">#ifndef _radixmap_h
#include &lt;stdint.h&gt;

typedef union RMElement {
    uint64_t raw;
    struct {
        uint32_t key;
        uint32_t value;
    } data;
} RMElement;

typedef struct RadixMap {
    size_t max;
    size_t end;
    uint32_t counter;
    RMElement *contents;
    RMElement *temp;
} RadixMap;

RadixMap *RadixMap_create(size_t max);

void RadixMap_destroy(RadixMap * map);

void RadixMap_sort(RadixMap * map);

RMElement *RadixMap_find(RadixMap * map, uint32_t key);

int RadixMap_add(RadixMap * map, uint32_t key, uint32_t value);

int RadixMap_delete(RadixMap * map, RMElement * el);

#endif

</code></pre>

<p>.\ex35\radixmap.c</p>

<pre><code class="language-c">/*
 * Based on code by Andre Reinald then heavily modified by Zed A. Shaw.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;lcthw/radixmap.h&gt;
#include &lt;lcthw/dbg.h&gt;

RadixMap *RadixMap_create(size_t max)
{
    RadixMap *map = calloc(sizeof(RadixMap), 1);
    check_mem(map);

    map-&gt;contents = calloc(sizeof(RMElement), max + 1);
    check_mem(map-&gt;contents);

    map-&gt;temp = calloc(sizeof(RMElement), max + 1);
    check_mem(map-&gt;temp);

    map-&gt;max = max;
    map-&gt;end = 0;

    return map;
error:
    return NULL;
}

void RadixMap_destroy(RadixMap * map)
{
    if (map) {
        free(map-&gt;contents);
        free(map-&gt;temp);
        free(map);
    }
}

#define ByteOf(x,y) (((uint8_t *)x)[(y)])

static inline void radix_sort(short offset, uint64_t max,
        uint64_t * source, uint64_t * dest)
{
    uint64_t count[256] = { 0 };
    uint64_t *cp = NULL;
    uint64_t *sp = NULL;
    uint64_t *end = NULL;
    uint64_t s = 0;
    uint64_t c = 0;

    // count occurences of every byte value
    for (sp = source, end = source + max; sp &lt; end; sp++) {
        count[ByteOf(sp, offset)]++;
    }

    // transform count into index by summing
    // elements and storing into same array
    for (s = 0, cp = count, end = count + 256; cp &lt; end; cp++) {
        c = *cp;
        *cp = s;
        s += c;
    }

    // fill dest with the right values in the right place
    for (sp = source, end = source + max; sp &lt; end; sp++) {
        cp = count + ByteOf(sp, offset);
        dest[*cp] = *sp;
        ++(*cp);
    }
}

void RadixMap_sort(RadixMap * map)
{
    uint64_t *source = &amp;map-&gt;contents[0].raw;
    uint64_t *temp = &amp;map-&gt;temp[0].raw;

    radix_sort(0, map-&gt;end, source, temp);
    radix_sort(1, map-&gt;end, temp, source);
    radix_sort(2, map-&gt;end, source, temp);
    radix_sort(3, map-&gt;end, temp, source);
}

RMElement *RadixMap_find(RadixMap * map, uint32_t to_find)
{
    int low = 0;
    int high = map-&gt;end - 1;
    RMElement *data = map-&gt;contents;

    while (low &lt;= high) {
        int middle = low + (high - low) / 2;
        uint32_t key = data[middle].data.key;

        if (to_find &lt; key) {
            high = middle - 1;
        } else if (to_find &gt; key) {
            low = middle + 1;
        } else {
            return &amp;data[middle];
        }
    }

    return NULL;
}

int RadixMap_add(RadixMap * map, uint32_t key, uint32_t value)
{
    check(key &lt; UINT32_MAX, &quot;Key can't be equal to UINT32_MAX.&quot;);

    RMElement element = {.data = {.key = key,.value = value} };
    check(map-&gt;end + 1 &lt; map-&gt;max, &quot;RadixMap is full.&quot;);

    map-&gt;contents[map-&gt;end++] = element;

    RadixMap_sort(map);

    return 0;

error:
    return -1;
}

int RadixMap_delete(RadixMap * map, RMElement * el)
{
    check(map-&gt;end &gt; 0, &quot;There is nothing to delete.&quot;);
    check(el != NULL, &quot;Can't delete a NULL element.&quot;);

    el-&gt;data.key = UINT32_MAX;

    if (map-&gt;end &gt; 1) {
        // don't bother resorting a map of 1 length
        RadixMap_sort(map);
    }

    map-&gt;end--;

    return 0;
error:
    return -1;
}

</code></pre>

<p>.\ex35\radixmap_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;lcthw/radixmap.h&gt;
#include &lt;time.h&gt;

static int make_random(RadixMap * map)
{
    size_t i = 0;

    for (i = 0; i &lt; map-&gt;max - 1; i++) {
        uint32_t key = (uint32_t) (rand() | (rand() &lt;&lt; 16));
        check(RadixMap_add(map, key, i) == 0, &quot;Failed to add key %u.&quot;,
                key);
    }

    return i;

error:
    return 0;
}

static int check_order(RadixMap * map)
{
    RMElement d1, d2;
    unsigned int i = 0;

    // only signal errors if any (should not be)
    for (i = 0; map-&gt;end &gt; 0 &amp;&amp; i &lt; map-&gt;end - 1; i++) {
        d1 = map-&gt;contents[i];
        d2 = map-&gt;contents[i + 1];

        if (d1.data.key &gt; d2.data.key) {
            debug(&quot;FAIL:i=%u, key: %u, value: %u, equals max? %d\n&quot;, i,
                    d1.data.key, d1.data.value,
                    d2.data.key == UINT32_MAX);
            return 0;
        }
    }

    return 1;
}

static int test_search(RadixMap * map)
{
    unsigned i = 0;
    RMElement *d = NULL;
    RMElement *found = NULL;

    for (i = map-&gt;end / 2; i &lt; map-&gt;end; i++) {
        d = &amp;map-&gt;contents[i];
        found = RadixMap_find(map, d-&gt;data.key);
        check(found != NULL, &quot;Didn't find %u at %u.&quot;, d-&gt;data.key, i);
        check(found-&gt;data.key == d-&gt;data.key,
                &quot;Got the wrong result: %p:%u looking for %u at %u&quot;, found,
                found-&gt;data.key, d-&gt;data.key, i);
    }

    return 1;
error:
    return 0;
}

// test for big number of elements
static char *test_operations()
{
    size_t N = 200;

    RadixMap *map = RadixMap_create(N);
    mu_assert(map != NULL, &quot;Failed to make the map.&quot;);
    mu_assert(make_random(map), &quot;Didn't make a random fake radix map.&quot;);

    RadixMap_sort(map);
    mu_assert(check_order(map),
            &quot;Failed to properly sort the RadixMap.&quot;);

    mu_assert(test_search(map), &quot;Failed the search test.&quot;);
    mu_assert(check_order(map),
            &quot;RadixMap didn't stay sorted after search.&quot;);

    while (map-&gt;end &gt; 0) {
        RMElement *el = RadixMap_find(map,
                map-&gt;contents[map-&gt;end / 2].data.key);
        mu_assert(el != NULL, &quot;Should get a result.&quot;);

        size_t old_end = map-&gt;end;

        mu_assert(RadixMap_delete(map, el) == 0, &quot;Didn't delete it.&quot;);
        mu_assert(old_end - 1 == map-&gt;end, &quot;Wrong size after delete.&quot;);

        // test that the end is now the old value,
        // but uint32 max so it trails off
        mu_assert(check_order(map),
                &quot;RadixMap didn't stay sorted after delete.&quot;);
    }

    RadixMap_destroy(map);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();
    srand(time(NULL));

    mu_run_test(test_operations);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>Code review this code next.</p>

<p>The Binary Search Code</p>

<p>Finally, code review of the BSTree code.</p>

<p>Improving It</p>

<ul>
<li>Use a binary search to find the minimum position for the
new element, then only sort from there to the end.  You find the
minimum, put the new element on the end, and then just sort from
the minimum on.   This will cut your sort space down
considerably most of the time.</li>
<li>Keep track of the biggest key currently being used, and then only
sort enough digits to handle that key.  You can also keep track
of the smallest number, and then only sort the digits necessary
for the range.  To do this, you&rsquo;ll have to start caring about
CPU integer ordering (endianness).</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Implement quicksort, heapsort, and merge sort and then provide a <em>#define</em>
that lets you pick between the two, or create a second set of functions
you can call.  Use the technique I taught you to read the Wikipedia page
for the algorithm, and then implement it with the psuedo-code.</li>
<li>Compare the performance of your optimizations to the original implementations.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Use these sorting functions to create a <em>DArray_sort_add</em> that
adds elements to the <em>DArray</em> but sorts the array after.</li>
<li>Write a <em>DArray_find</em> that uses the binary search algorithm from
<em>RadixMap_find</em> and the <em>DArray_compare</em> to find elements
in a sorted <em>DArray</em>.</li>
</ul>

<h3 id="exercise-36-safer-strings">Exercise 36 Safer Strings</h3>

<p>.\ex36\ex36.c</p>

<pre><code class="language-c">void copy(char to[], char from[])
{
    int i = 0;

    // while loop will not end if from isn't '\0' terminated
    while ((to[i] = from[i]) != '\0') {
        ++i;
    }
}

int safercopy(int from_len, char *from, int to_len, char *to)
{
    int i = 0;
    int max = from_len &gt; to_len - 1 ? to_len - 1 : from_len;

    // to_len must have at least 1 byte
    if (from_len &lt; 0 || to_len &lt;= 0)
        return -1;

    for (i = 0; i &lt; max; i++) {
        to[i] = from[i];
    }

    to[to_len - 1] = '\0';

    return i;
}

</code></pre>

<p>.\ex36\ex36.c</p>

<pre><code class="language-c">void copy(char to[], char from[])
{
    int i = 0;

    // while loop will not end if from isn't '\0' terminated
    while ((to[i] = from[i]) != '\0') {
        ++i;
    }
}

int safercopy(int from_len, char *from, int to_len, char *to)
{
    int i = 0;
    int max = from_len &gt; to_len - 1 ? to_len - 1 : from_len;

    // to_len must have at least 1 byte
    if (from_len &lt; 0 || to_len &lt;= 0)
        return -1;

    for (i = 0; i &lt; max; i++) {
        to[i] = from[i];
    }

    to[to_len - 1] = '\0';

    return i;
}

</code></pre>

<p>The Plan</p>

<p>Learn about an alternative string implementation to avoid most C string problems.</p>

<p>C Strings Suck</p>

<p>It is impossible to safely process strings in C.</p>

<p>The bstrling Library</p>

<p>An alternative is a library that provides alternative APIs for working with
C strings.</p>

<p>The Common Functions</p>

<pre><code>bfromcstr    Create a bstring from a C style constant.
blk2bstr     Do the same thing, but give the length of the buffer.
bstrcpy      Copy a bstring.
bassign      Set one bstring to another.
bassigncstr  Set a bstring to a C string's contents.
bassignblk   Set a bstring to a C string but give the length.
bdestroy     Destroy a bstring.
bconcat      Concatenate one bstring onto another.
bstricmp     Compare two bstrings returning the same result as strcmp.
biseq        Tests if two bstrings are equal.
</code></pre>

<p>The Common Functions</p>

<pre><code>binstr       Tells if one bstring is in another.
bfindreplace Find one bstring in another, then replace it with a third.
bsplit       Split a bstring into a bstrList.
bformat      Do a format string, which is super handy.
blength      Get the length of a bstring.
bdata        Get the data from a bstring.
bchar        Get a char from a bstring.
</code></pre>

<p>Extra Credit</p>

<p>There is only one extra credit and that&rsquo;s to write a <em>tests/bstr_tests.c</em> file that
tests all of these functions.  The bstrlib comes with a test that you can reference it if needed.</p>

<h3 id="exercise-37-hashmaps">Exercise 37 Hashmaps</h3>

<p>The Plan</p>

<p>Implement a Hashmap in C.
In Python these are called Dictionaries.</p>

<p>Hashmaps Visually</p>

<p>Hashmaps are very intuitive once you know how a DArray works.
It&rsquo;s all about the hashing function used.</p>

<p>Code Review</p>

<p>.\ex37\hashmap.h</p>

<pre><code class="language-c">#ifndef _lcthw_Hashmap_h
#define _lcthw_Hashmap_h

#include &lt;stdint.h&gt;
#include &lt;lcthw/darray.h&gt;

#define DEFAULT_NUMBER_OF_BUCKETS 100

typedef int (*Hashmap_compare) (void *a, void *b);
typedef uint32_t(*Hashmap_hash) (void *key);

typedef struct Hashmap {
    DArray *buckets;
    Hashmap_compare compare;
    Hashmap_hash hash;
} Hashmap;

typedef struct HashmapNode {
    void *key;
    void *data;
    uint32_t hash;
} HashmapNode;

typedef int (*Hashmap_traverse_cb) (HashmapNode * node);

Hashmap *Hashmap_create(Hashmap_compare compare, Hashmap_hash);
void Hashmap_destroy(Hashmap * map);

int Hashmap_set(Hashmap * map, void *key, void *data);
void *Hashmap_get(Hashmap * map, void *key);

int Hashmap_traverse(Hashmap * map, Hashmap_traverse_cb traverse_cb);

void *Hashmap_delete(Hashmap * map, void *key);

#endif

</code></pre>

<p>.\ex37\hashmap.c</p>

<pre><code class="language-c">#undef NDEBUG
#include &lt;stdint.h&gt;
#include &lt;lcthw/hashmap.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;lcthw/bstrlib.h&gt;

static int default_compare(void *a, void *b)
{
    return bstrcmp((bstring) a, (bstring) b);
}

/** 
 * Simple Bob Jenkins's hash algorithm taken from the
 * wikipedia description.
 */
static uint32_t default_hash(void *a)
{
    size_t len = blength((bstring) a);
    char *key = bdata((bstring) a);
    uint32_t hash = 0;
    uint32_t i = 0;

    for (hash = i = 0; i &lt; len; ++i) {
        hash += key[i];
        hash += (hash &lt;&lt; 10);
        hash ^= (hash &gt;&gt; 6);
    }

    hash += (hash &lt;&lt; 3);
    hash ^= (hash &gt;&gt; 11);
    hash += (hash &lt;&lt; 15);

    return hash;
}

Hashmap *Hashmap_create(Hashmap_compare compare, Hashmap_hash hash)
{
    Hashmap *map = calloc(1, sizeof(Hashmap));
    check_mem(map);

    map-&gt;compare = compare == NULL ? default_compare : compare;
    map-&gt;hash = hash == NULL ? default_hash : hash;
    map-&gt;buckets = DArray_create(
            sizeof(DArray *), DEFAULT_NUMBER_OF_BUCKETS);
    map-&gt;buckets-&gt;end = map-&gt;buckets-&gt;max;    // fake out expanding it
    check_mem(map-&gt;buckets);

    return map;

error:
    if (map) {
        Hashmap_destroy(map);
    }

    return NULL;
}

void Hashmap_destroy(Hashmap * map)
{
    int i = 0;
    int j = 0;

    if (map) {
        if (map-&gt;buckets) {
            for (i = 0; i &lt; DArray_count(map-&gt;buckets); i++) {
                DArray *bucket = DArray_get(map-&gt;buckets, i);
                if (bucket) {
                    for (j = 0; j &lt; DArray_count(bucket); j++) {
                        free(DArray_get(bucket, j));
                    }
                    DArray_destroy(bucket);
                }
            }
            DArray_destroy(map-&gt;buckets);
        }

        free(map);
    }
}

static inline HashmapNode *Hashmap_node_create(int hash, void *key,
        void *data)
{
    HashmapNode *node = calloc(1, sizeof(HashmapNode));
    check_mem(node);

    node-&gt;key = key;
    node-&gt;data = data;
    node-&gt;hash = hash;

    return node;

error:
    return NULL;
}

static inline DArray *Hashmap_find_bucket(Hashmap * map, void *key,
        int create,
        uint32_t * hash_out)
{
    uint32_t hash = map-&gt;hash(key);
    int bucket_n = hash % DEFAULT_NUMBER_OF_BUCKETS;
    check(bucket_n &gt;= 0, &quot;Invalid bucket found: %d&quot;, bucket_n);
    // store it for the return so the caller can use it
    *hash_out = hash;

    DArray *bucket = DArray_get(map-&gt;buckets, bucket_n);

    if (!bucket &amp;&amp; create) {
        // new bucket, set it up
        bucket = DArray_create(
                sizeof(void *), DEFAULT_NUMBER_OF_BUCKETS);
        check_mem(bucket);
        DArray_set(map-&gt;buckets, bucket_n, bucket);
    }

    return bucket;

error:
    return NULL;
}

int Hashmap_set(Hashmap * map, void *key, void *data)
{
    uint32_t hash = 0;
    DArray *bucket = Hashmap_find_bucket(map, key, 1, &amp;hash);
    check(bucket, &quot;Error can't create bucket.&quot;);

    HashmapNode *node = Hashmap_node_create(hash, key, data);
    check_mem(node);

    DArray_push(bucket, node);

    return 0;

error:
    return -1;
}

static inline int Hashmap_get_node(Hashmap * map, uint32_t hash,
        DArray * bucket, void *key)
{
    int i = 0;

    for (i = 0; i &lt; DArray_end(bucket); i++) {
        debug(&quot;TRY: %d&quot;, i);
        HashmapNode *node = DArray_get(bucket, i);
        if (node-&gt;hash == hash &amp;&amp; map-&gt;compare(node-&gt;key, key) == 0) {
            return i;
        }
    }

    return -1;
}

void *Hashmap_get(Hashmap * map, void *key)
{
    uint32_t hash = 0;
    DArray *bucket = Hashmap_find_bucket(map, key, 0, &amp;hash);
    if (!bucket) return NULL;

    int i = Hashmap_get_node(map, hash, bucket, key);
    if (i == -1) return NULL;

    HashmapNode *node = DArray_get(bucket, i);
    check(node != NULL,
            &quot;Failed to get node from bucket when it should exist.&quot;);

    return node-&gt;data;

error:            // fallthrough
    return NULL;
}

int Hashmap_traverse(Hashmap * map, Hashmap_traverse_cb traverse_cb)
{
    int i = 0;
    int j = 0;
    int rc = 0;

    for (i = 0; i &lt; DArray_count(map-&gt;buckets); i++) {
        DArray *bucket = DArray_get(map-&gt;buckets, i);
        if (bucket) {
            for (j = 0; j &lt; DArray_count(bucket); j++) {
                HashmapNode *node = DArray_get(bucket, j);
                rc = traverse_cb(node);
                if (rc != 0)
                    return rc;
            }
        }
    }

    return 0;
}

void *Hashmap_delete(Hashmap * map, void *key)
{
    uint32_t hash = 0;
    DArray *bucket = Hashmap_find_bucket(map, key, 0, &amp;hash);
    if (!bucket)
        return NULL;

    int i = Hashmap_get_node(map, hash, bucket, key);
    if (i == -1)
        return NULL;

    HashmapNode *node = DArray_get(bucket, i);
    void *data = node-&gt;data;
    free(node);

    HashmapNode *ending = DArray_pop(bucket);

    if (ending != node) {
        // alright looks like it's not the last one, swap it
        DArray_set(bucket, i, ending);
    }

    return data;
}

</code></pre>

<p>Conducting a review of Hashmap by following the test.</p>

<p>Improving It</p>

<ul>
<li>You can use a sort on each bucket so that they&rsquo;re always sorted.
This increases your insert time but decreases your find time, because
you can then use a binary search to find each node.  Right now,
it&rsquo;s looping through all of the nodes in a bucket just to find one.</li>
<li>You can dynamically size the number of buckets, or let the caller
specify the number for each <em>Hashmap</em> created.</li>
<li>You can use a better <em>default_hash</em>.  There are tons of them.</li>
</ul>

<p>Improving It</p>

<ul>
<li>This (and nearly every <em>Hashmap</em>) is vulnerable to someone picking
keys that will fill only one bucket, and then tricking your program
into processing them.  This then makes your program run slower because
it changes from processing a <em>Hashmap</em> to effectively processing
a single <em>DArray</em>.  If you sort the nodes in the bucket, this
helps, but you can also use better hashing functions, and for
the really paranoid programmer, add a random salt so that keys can&rsquo;t be predicted.</li>
</ul>

<p>Improving It</p>

<ul>
<li>You could have it delete buckets that are empty of nodes to save space,
or put empty buckets into a cache so you can save on time lost creating and destroying
them.</li>
<li>Right now, it just adds elements even if they already exist.  Write an
alternative set method that only adds an element if it isn&rsquo;t set already.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Research the <em>Hashmap</em> implementation in your favorite programming language to see what features it has.</li>
<li>Find out what the major disadvantages of a <em>Hashmap</em> are and how to avoid them.  For example, it doesn&rsquo;t preserve order without special changes, nor does it work when you need to find things based on parts
of keys.</li>
<li>Write a unit test that demonstrates the defect of filling a <em>Hashmap</em> with keys that land
in the same bucket, then test how this impacts performance.  A good way to do this is to just reduce
the number of buckets to something stupid, like five.</li>
</ul>

<h3 id="exercise-38-hashmap-algorithms">Exercise 38 Hashmap Algorithms</h3>

<p>The Plan</p>

<p>Learn three different string hashing algorithms and make them dynamically available
to the Hashmap.</p>

<p>Code Review</p>

<p>.\ex38\hashmap_algos.h</p>

<pre><code class="language-c">#ifndef hashmap_algos_h
#define hashmap_algos_h

#include &lt;stdint.h&gt;

uint32_t Hashmap_fnv1a_hash(void *data);

uint32_t Hashmap_adler32_hash(void *data);

uint32_t Hashmap_djb_hash(void *data);

#endif

</code></pre>

<p>.\ex38\hashmap_algos.c</p>

<pre><code class="language-c">#include &lt;lcthw/hashmap_algos.h&gt;
#include &lt;lcthw/bstrlib.h&gt;

// settings taken from
// http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param
const uint32_t FNV_PRIME = 16777619;
const uint32_t FNV_OFFSET_BASIS = 2166136261;

uint32_t Hashmap_fnv1a_hash(void *data)
{
    bstring s = (bstring) data;
    uint32_t hash = FNV_OFFSET_BASIS;
    int i = 0;

    for (i = 0; i &lt; blength(s); i++) {
        hash ^= bchare(s, i, 0);
        hash *= FNV_PRIME;
    }

    return hash;
}

const int MOD_ADLER = 65521;

uint32_t Hashmap_adler32_hash(void *data)
{
    bstring s = (bstring) data;
    uint32_t a = 1, b = 0;
    int i = 0;

    for (i = 0; i &lt; blength(s); i++) {
        a = (a + bchare(s, i, 0)) % MOD_ADLER;
        b = (b + a) % MOD_ADLER;
    }

    return (b &lt;&lt; 16) | a;
}

uint32_t Hashmap_djb_hash(void *data)
{
    bstring s = (bstring) data;
    uint32_t hash = 5381;
    int i = 0;

    for (i = 0; i &lt; blength(s); i++) {
        hash = ((hash &lt;&lt; 5) + hash) + bchare(s, i, 0);    /* hash * 33 + c */
    }

    return hash;
}

</code></pre>

<p>The default is the Jenkin&rsquo;s hash.</p>

<p>You added the FNV1a, Adler32, and DJB hashing algorithms.</p>

<p>Review the code for FNV1a vs. DJB.</p>

<p>Breaking It</p>

<p>In this exercise you will attempt to write the worst hashing function that can
pass for a real one.  Try to make one that either looks complicated but
statistically is way off, or is a discrete change to an existing one that is a
bad change.</p>

<p>Extra Credit</p>

<ul>
<li>Take the <code>default_hash</code> out of the <code>hashmap.c</code>, make it
one of the algorithms in <code>hashmap_algos.c</code>, and then make all
of the tests work again.</li>
<li>Add the <code>default_hash</code> to the <code>hashmap_algos_tests.c</code>
test and compare its statistics to the other hash functions.</li>
<li>Find a few more hash functions and add them, too. You can never have too
many hash functions!</li>
</ul>

<h3 id="exercise-39-string-algorithms">Exercise 39 String Algorithms</h3>

<p>The Plan</p>

<p>Develop a formal code review procedure.</p>

<p>The Code</p>

<p>.\ex39\string_algos.h</p>

<pre><code class="language-c">#ifndef string_algos_h
#define string_algos_h

#include &lt;lcthw/bstrlib.h&gt;
#include &lt;lcthw/darray.h&gt;

typedef struct StringScanner {
    bstring in;
    const unsigned char *haystack;
    ssize_t hlen;
    const unsigned char *needle;
    ssize_t nlen;
    size_t skip_chars[UCHAR_MAX + 1];
} StringScanner;

int String_find(bstring in, bstring what);

StringScanner *StringScanner_create(bstring in);

int StringScanner_scan(StringScanner * scan, bstring tofind);

void StringScanner_destroy(StringScanner * scan);

#endif

</code></pre>

<p>.\ex39\string_algos.c</p>

<pre><code class="language-c">#include &lt;lcthw/string_algos.h&gt;
#include &lt;limits.h&gt;

static inline void String_setup_skip_chars(size_t * skip_chars,
        const unsigned char *needle,
        ssize_t nlen)
{
    size_t i = 0;
    size_t last = nlen - 1;

    for (i = 0; i &lt; UCHAR_MAX + 1; i++) {
        skip_chars[i] = nlen;
    }

    for (i = 0; i &lt; last; i++) {
        skip_chars[needle[i]] = last - i;
    }
}

static inline const unsigned char *String_base_search(const unsigned
        char *haystack,
        ssize_t hlen,
        const unsigned
        char *needle,
        ssize_t nlen,
        size_t *
        skip_chars)
{
    size_t i = 0;
    size_t last = nlen - 1;

    assert(haystack != NULL &amp;&amp; &quot;Given bad haystack to search.&quot;);
    assert(needle != NULL &amp;&amp; &quot;Given bad needle to search for.&quot;);

    check(nlen &gt; 0, &quot;nlen can't be &lt;= 0&quot;);
    check(hlen &gt; 0, &quot;hlen can't be &lt;= 0&quot;);

    while (hlen &gt;= nlen) {
        for (i = last; haystack[i] == needle[i]; i--) {
            if (i == 0) {
                return haystack;
            }
        }

        hlen -= skip_chars[haystack[last]];
        haystack += skip_chars[haystack[last]];
    }

error:            // fallthrough
    return NULL;
}

int String_find(bstring in, bstring what)
{
    const unsigned char *found = NULL;

    const unsigned char *haystack = (const unsigned char *)bdata(in);
    ssize_t hlen = blength(in);
    const unsigned char *needle = (const unsigned char *)bdata(what);
    ssize_t nlen = blength(what);
    size_t skip_chars[UCHAR_MAX + 1] = { 0 };

    String_setup_skip_chars(skip_chars, needle, nlen);

    found = String_base_search(haystack, hlen,
                 needle, nlen, skip_chars);

    return found != NULL ? found - haystack : -1;
}

StringScanner *StringScanner_create(bstring in)
{
    StringScanner *scan = calloc(1, sizeof(StringScanner));
    check_mem(scan);

    scan-&gt;in = in;
    scan-&gt;haystack = (const unsigned char *)bdata(in);
    scan-&gt;hlen = blength(in);

    assert(scan != NULL &amp;&amp; &quot;fuck&quot;);
    return scan;

error:
    free(scan);
    return NULL;
}

static inline void StringScanner_set_needle(StringScanner * scan,
        bstring tofind)
{
    scan-&gt;needle = (const unsigned char *)bdata(tofind);
    scan-&gt;nlen = blength(tofind);

    String_setup_skip_chars(scan-&gt;skip_chars, scan-&gt;needle, scan-&gt;nlen);
}

static inline void StringScanner_reset(StringScanner * scan)
{
    scan-&gt;haystack = (const unsigned char *)bdata(scan-&gt;in);
    scan-&gt;hlen = blength(scan-&gt;in);
}

int StringScanner_scan(StringScanner * scan, bstring tofind)
{
    const unsigned char *found = NULL;
    ssize_t found_at = 0;

    if (scan-&gt;hlen &lt;= 0) {
        StringScanner_reset(scan);
        return -1;
    }

    if ((const unsigned char *)bdata(tofind) != scan-&gt;needle) {
        StringScanner_set_needle(scan, tofind);
    }

    found = String_base_search(scan-&gt;haystack, scan-&gt;hlen,
            scan-&gt;needle, scan-&gt;nlen,
            scan-&gt;skip_chars);

    if (found) {
        found_at = found - (const unsigned char *)bdata(scan-&gt;in);
        scan-&gt;haystack = found + scan-&gt;nlen;
        scan-&gt;hlen -= found_at - scan-&gt;nlen;
    } else {
        // done, reset the setup
        StringScanner_reset(scan);
        found_at = -1;
    }

    return found_at;
}

void StringScanner_destroy(StringScanner * scan)
{
    if (scan) {
        free(scan);
    }
}

</code></pre>

<p>.\ex39\string_algos_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;lcthw/string_algos.h&gt;
#include &lt;lcthw/bstrlib.h&gt;
#include &lt;time.h&gt;

struct tagbstring IN_STR = bsStatic(
        &quot;I have ALPHA beta ALPHA and oranges ALPHA&quot;);
struct tagbstring ALPHA = bsStatic(&quot;ALPHA&quot;);
const int TEST_TIME = 1;

char *test_find_and_scan()
{
    StringScanner *scan = StringScanner_create(&amp;IN_STR);
    mu_assert(scan != NULL, &quot;Failed to make the scanner.&quot;);

    int find_i = String_find(&amp;IN_STR, &amp;ALPHA);
    mu_assert(find_i &gt; 0, &quot;Failed to find 'ALPHA' in test string.&quot;);

    int scan_i = StringScanner_scan(scan, &amp;ALPHA);
    mu_assert(scan_i &gt; 0, &quot;Failed to find 'ALPHA' with scan.&quot;);
    mu_assert(scan_i == find_i, &quot;find and scan don't match&quot;);

    scan_i = StringScanner_scan(scan, &amp;ALPHA);
    mu_assert(scan_i &gt; find_i,
            &quot;should find another ALPHA after the first&quot;);

    scan_i = StringScanner_scan(scan, &amp;ALPHA);
    mu_assert(scan_i &gt; find_i,
            &quot;should find another ALPHA after the first&quot;);

    mu_assert(StringScanner_scan(scan, &amp;ALPHA) == -1,
            &quot;shouldn't find it&quot;);

    StringScanner_destroy(scan);

    return NULL;
}

char *test_binstr_performance()
{
    int i = 0;
    int found_at = 0;
    unsigned long find_count = 0;
    time_t elapsed = 0;
    time_t start = time(NULL);

    do {
        for (i = 0; i &lt; 1000; i++) {
            found_at = binstr(&amp;IN_STR, 0, &amp;ALPHA);
            mu_assert(found_at != BSTR_ERR, &quot;Failed to find!&quot;);
            find_count++;
        }

        elapsed = time(NULL) - start;
    } while (elapsed &lt;= TEST_TIME);

    debug(&quot;BINSTR COUNT: %lu, END TIME: %d, OPS: %f&quot;,
            find_count, (int)elapsed, (double)find_count / elapsed);
    return NULL;
}

char *test_find_performance()
{
    int i = 0;
    int found_at = 0;
    unsigned long find_count = 0;
    time_t elapsed = 0;
    time_t start = time(NULL);

    do {
        for (i = 0; i &lt; 1000; i++) {
            found_at = String_find(&amp;IN_STR, &amp;ALPHA);
            find_count++;
        }

        elapsed = time(NULL) - start;
    } while (elapsed &lt;= TEST_TIME);

    debug(&quot;FIND COUNT: %lu, END TIME: %d, OPS: %f&quot;,
            find_count, (int)elapsed, (double)find_count / elapsed);

    return NULL;
}

char *test_scan_performance()
{
    int i = 0;
    int found_at = 0;
    unsigned long find_count = 0;
    time_t elapsed = 0;
    StringScanner *scan = StringScanner_create(&amp;IN_STR);

    time_t start = time(NULL);

    do {
        for (i = 0; i &lt; 1000; i++) {
            found_at = 0;

            do {
                found_at = StringScanner_scan(scan, &amp;ALPHA);
                find_count++;
            } while (found_at != -1);
        }

        elapsed = time(NULL) - start;
    } while (elapsed &lt;= TEST_TIME);

    debug(&quot;SCAN COUNT: %lu, END TIME: %d, OPS: %f&quot;,
            find_count, (int)elapsed, (double)find_count / elapsed);

    StringScanner_destroy(scan);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_find_and_scan);

    // this is an idiom for commenting out sections of code
#if 0
    mu_run_test(test_scan_performance);
    mu_run_test(test_find_performance);
    mu_run_test(test_binstr_performance);
#endif

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>The code is easy to implement so should be no problem for you
at this point.  Focus on getting the unit test right.</p>

<p>Code Review Process</p>

<ol>
<li>Start at the entry point for a piece of code that has changed.</li>
<li>For each function, confirm that its calling parameters are correct.</li>
<li>Enter that function, and confirm each line&rsquo;s correctness.</li>
<li>When you encounter a function, repeat up to #2 until you go no further.</li>
<li>As you exit functions, confirm the return values and their usage.</li>
<li>Continue until you are back where you started at the entry point.</li>
<li>Do a diff on your changes, and confirm any missed calls to changed functions.</li>
</ol>

<p>Code Review Key Points</p>

<ol>
<li>Check your pointer dereferences and defend against NULL.</li>
<li>Check if-statements and while loops for exiting.</li>
<li>Check return values are going to be valid.</li>
<li>Check that memory allocated is freed and other resources freed.</li>
<li>Confirm all system call parameters are correct with man pages.</li>
</ol>

<p>Record Your Code Review</p>

<p>I want <em>you</em> to try to record yourself coding and reviewing your
code.  What do you learn from this experience?</p>

<p>What if you kept track of the number of mistakes you found in
your code reviews and analyzed the data?</p>

<p>Extra Credit</p>

<ul>
<li>See if you can make the <code>Scan_find</code> faster.  Why is my implementation
here slow?</li>
<li>Try some different scan times and see if you get different numbers.
What impact does the length of time that you run the test have on
the <code>scan</code> times?  What can you say about that result?</li>
<li>Alter the unit test so that it runs each function for a short burst
in the beginning to clear out any warm up period, and then start the
timing portion.  Does that change the dependence on the length of time
the test runs?  Does it change how many operations per second are possible?</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Make the unit test randomize the strings to find and then measure
the performance you get.  One way to do this is to use the <code>bsplit</code>
function from <code>bstrlib.h</code> to split the <code>IN_STR</code> on
spaces.  Then, you can use the <code>bstrList</code> struct that you get to access each
string it returns.  This will also teach you how to use <code>bstrList</code>
operations for string processing.</li>
<li>Try some runs with the tests in different orders to see if you get different
results.</li>
</ul>

<h3 id="exercise-40-binary-search-trees">Exercise 40 Binary Search Trees</h3>

<p>The Plan</p>

<p>Implement a Binary Search Tree, a competitor to the Hashmap.</p>

<p>Binary Search Trees Visually</p>

<p>The Code</p>

<p>.\ex40\bstree.h</p>

<pre><code class="language-c">#ifndef _lcthw_BSTree_h
#define _lcthw_BSTree_h

typedef int (*BSTree_compare) (void *a, void *b);

typedef struct BSTreeNode {
    void *key;
    void *data;

    struct BSTreeNode *left;
    struct BSTreeNode *right;
    struct BSTreeNode *parent;
} BSTreeNode;

typedef struct BSTree {
    int count;
    BSTree_compare compare;
    BSTreeNode *root;
} BSTree;

typedef int (*BSTree_traverse_cb) (BSTreeNode * node);

BSTree *BSTree_create(BSTree_compare compare);
void BSTree_destroy(BSTree * map);

int BSTree_set(BSTree * map, void *key, void *data);
void *BSTree_get(BSTree * map, void *key);

int BSTree_traverse(BSTree * map, BSTree_traverse_cb traverse_cb);

void *BSTree_delete(BSTree * map, void *key);

#endif

</code></pre>

<p>.\ex40\bstree.c</p>

<pre><code class="language-c">#include &lt;lcthw/dbg.h&gt;
#include &lt;lcthw/bstree.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;lcthw/bstrlib.h&gt;

static int default_compare(void *a, void *b)
{
    return bstrcmp((bstring) a, (bstring) b);
}

BSTree *BSTree_create(BSTree_compare compare)
{
    BSTree *map = calloc(1, sizeof(BSTree));
    check_mem(map);

    map-&gt;compare = compare == NULL ? default_compare : compare;

    return map;

error:
    if (map) {
        BSTree_destroy(map);
    }
    return NULL;
}

static int BSTree_destroy_cb(BSTreeNode * node)
{
    free(node);
    return 0;
}

void BSTree_destroy(BSTree * map)
{
    if (map) {
        BSTree_traverse(map, BSTree_destroy_cb);
        free(map);
    }
}

static inline BSTreeNode *BSTreeNode_create(BSTreeNode * parent,
        void *key, void *data)
{
    BSTreeNode *node = calloc(1, sizeof(BSTreeNode));
    check_mem(node);

    node-&gt;key = key;
    node-&gt;data = data;
    node-&gt;parent = parent;
    return node;

error:
    return NULL;
}

static inline void BSTree_setnode(BSTree * map, BSTreeNode * node,
        void *key, void *data)
{
    int cmp = map-&gt;compare(node-&gt;key, key);

    if (cmp &lt;= 0) {
        if (node-&gt;left) {
            BSTree_setnode(map, node-&gt;left, key, data);
        } else {
            node-&gt;left = BSTreeNode_create(node, key, data);
        }
    } else {
        if (node-&gt;right) {
            BSTree_setnode(map, node-&gt;right, key, data);
        } else {
            node-&gt;right = BSTreeNode_create(node, key, data);
        }
    }
}

int BSTree_set(BSTree * map, void *key, void *data)
{
    if (map-&gt;root == NULL) {
        // first so just make it and get out
        map-&gt;root = BSTreeNode_create(NULL, key, data);
        check_mem(map-&gt;root);
    } else {
        BSTree_setnode(map, map-&gt;root, key, data);
    }

    return 0;
error:
    return -1;
}

static inline BSTreeNode *BSTree_getnode(BSTree * map,
        BSTreeNode * node, void *key)
{
    int cmp = map-&gt;compare(node-&gt;key, key);

    if (cmp == 0) {
        return node;
    } else if (cmp &lt; 0) {
        if (node-&gt;left) {
            return BSTree_getnode(map, node-&gt;left, key);
        } else {
            return NULL;
        }
    } else {
        if (node-&gt;right) {
            return BSTree_getnode(map, node-&gt;right, key);
        } else {
            return NULL;
        }
    }
}

void *BSTree_get(BSTree * map, void *key)
{
    if (map-&gt;root == NULL) {
        return NULL;
    } else {
        BSTreeNode *node = BSTree_getnode(map, map-&gt;root, key);
        return node == NULL ? NULL : node-&gt;data;
    }
}

static inline int BSTree_traverse_nodes(BSTreeNode * node,
        BSTree_traverse_cb traverse_cb)
{
    int rc = 0;

    if (node-&gt;left) {
        rc = BSTree_traverse_nodes(node-&gt;left, traverse_cb);
        if (rc != 0)
            return rc;
    }

    if (node-&gt;right) {
        rc = BSTree_traverse_nodes(node-&gt;right, traverse_cb);
        if (rc != 0)
            return rc;
    }

    return traverse_cb(node);
}

int BSTree_traverse(BSTree * map, BSTree_traverse_cb traverse_cb)
{
    if (map-&gt;root) {
        return BSTree_traverse_nodes(map-&gt;root, traverse_cb);
    }

    return 0;
}

static inline BSTreeNode *BSTree_find_min(BSTreeNode * node)
{
    while (node-&gt;left) {
        node = node-&gt;left;
    }

    return node;
}

static inline void BSTree_replace_node_in_parent(BSTree * map,
        BSTreeNode * node,
        BSTreeNode * new_value)
{
    if (node-&gt;parent) {
        if (node == node-&gt;parent-&gt;left) {
            node-&gt;parent-&gt;left = new_value;
        } else {
            node-&gt;parent-&gt;right = new_value;
        }
    } else {
        // this is the root so gotta change it
        map-&gt;root = new_value;
    }

    if (new_value) {
        new_value-&gt;parent = node-&gt;parent;
    }
}

static inline void BSTree_swap(BSTreeNode * a, BSTreeNode * b)
{
    void *temp = NULL;
    temp = b-&gt;key;
    b-&gt;key = a-&gt;key;
    a-&gt;key = temp;
    temp = b-&gt;data;
    b-&gt;data = a-&gt;data;
    a-&gt;data = temp;
}

static inline BSTreeNode *BSTree_node_delete(BSTree * map,
        BSTreeNode * node,
        void *key)
{
    int cmp = map-&gt;compare(node-&gt;key, key);

    if (cmp &lt; 0) {
        if (node-&gt;left) {
            return BSTree_node_delete(map, node-&gt;left, key);
        } else {
            // not found
            return NULL;
        }
    } else if (cmp &gt; 0) {
        if (node-&gt;right) {
            return BSTree_node_delete(map, node-&gt;right, key);
        } else {
            // not found
            return NULL;
        }
    } else {
        if (node-&gt;left &amp;&amp; node-&gt;right) {
            // swap this node for the smallest node that is bigger than us
            BSTreeNode *successor = BSTree_find_min(node-&gt;right);
            BSTree_swap(successor, node);

            // this leaves the old successor with possibly a right child
            // so replace it with that right child
            BSTree_replace_node_in_parent(map, successor,
                    successor-&gt;right);

            // finally it's swapped, so return successor instead of node
            return successor;
        } else if (node-&gt;left) {
            BSTree_replace_node_in_parent(map, node, node-&gt;left);
        } else if (node-&gt;right) {
            BSTree_replace_node_in_parent(map, node, node-&gt;right);
        } else {
            BSTree_replace_node_in_parent(map, node, NULL);
        }

        return node;
    }
}

void *BSTree_delete(BSTree * map, void *key)
{
    void *data = NULL;

    if (map-&gt;root) {
        BSTreeNode *node = BSTree_node_delete(map, map-&gt;root, key);

        if (node) {
            data = node-&gt;data;
            free(node);
        }
    }

    return data;
}

</code></pre>

<p>.\ex40\bstree_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;lcthw/bstree.h&gt;
#include &lt;assert.h&gt;
#include &lt;lcthw/bstrlib.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

BSTree *map = NULL;
static int traverse_called = 0;
struct tagbstring test1 = bsStatic(&quot;test data 1&quot;);
struct tagbstring test2 = bsStatic(&quot;test data 2&quot;);
struct tagbstring test3 = bsStatic(&quot;xest data 3&quot;);
struct tagbstring expect1 = bsStatic(&quot;THE VALUE 1&quot;);
struct tagbstring expect2 = bsStatic(&quot;THE VALUE 2&quot;);
struct tagbstring expect3 = bsStatic(&quot;THE VALUE 3&quot;);

static int traverse_good_cb(BSTreeNode * node)
{
    debug(&quot;KEY: %s&quot;, bdata((bstring) node-&gt;key));
    traverse_called++;
    return 0;
}

static int traverse_fail_cb(BSTreeNode * node)
{
    debug(&quot;KEY: %s&quot;, bdata((bstring) node-&gt;key));
    traverse_called++;

    if (traverse_called == 2) {
        return 1;
    } else {
        return 0;
    }
}

char *test_create()
{
    map = BSTree_create(NULL);
    mu_assert(map != NULL, &quot;Failed to create map.&quot;);

    return NULL;
}

char *test_destroy()
{
    BSTree_destroy(map);

    return NULL;
}

char *test_get_set()
{
    int rc = BSTree_set(map, &amp;test1, &amp;expect1);
    mu_assert(rc == 0, &quot;Failed to set &amp;test1&quot;);
    bstring result = BSTree_get(map, &amp;test1);
    mu_assert(result == &amp;expect1, &quot;Wrong value for test1.&quot;);

    rc = BSTree_set(map, &amp;test2, &amp;expect2);
    mu_assert(rc == 0, &quot;Failed to set test2&quot;);
    result = BSTree_get(map, &amp;test2);
    mu_assert(result == &amp;expect2, &quot;Wrong value for test2.&quot;);

    rc = BSTree_set(map, &amp;test3, &amp;expect3);
    mu_assert(rc == 0, &quot;Failed to set test3&quot;);
    result = BSTree_get(map, &amp;test3);
    mu_assert(result == &amp;expect3, &quot;Wrong value for test3.&quot;);

    return NULL;
}

char *test_traverse()
{
    int rc = BSTree_traverse(map, traverse_good_cb);
    mu_assert(rc == 0, &quot;Failed to traverse.&quot;);
    mu_assert(traverse_called == 3, &quot;Wrong count traverse.&quot;);

    traverse_called = 0;
    rc = BSTree_traverse(map, traverse_fail_cb);
    mu_assert(rc == 1, &quot;Failed to traverse.&quot;);
    mu_assert(traverse_called == 2, &quot;Wrong count traverse for fail.&quot;);

    return NULL;
}

char *test_delete()
{
    bstring deleted = (bstring) BSTree_delete(map, &amp;test1);
    mu_assert(deleted != NULL, &quot;Got NULL on delete.&quot;);
    mu_assert(deleted == &amp;expect1, &quot;Should get test1&quot;);
    bstring result = BSTree_get(map, &amp;test1);
    mu_assert(result == NULL, &quot;Should delete.&quot;);

    deleted = (bstring) BSTree_delete(map, &amp;test1);
    mu_assert(deleted == NULL, &quot;Should get NULL on delete&quot;);

    deleted = (bstring) BSTree_delete(map, &amp;test2);
    mu_assert(deleted != NULL, &quot;Got NULL on delete.&quot;);
    mu_assert(deleted == &amp;expect2, &quot;Should get test2&quot;);
    result = BSTree_get(map, &amp;test2);
    mu_assert(result == NULL, &quot;Should delete.&quot;);

    deleted = (bstring) BSTree_delete(map, &amp;test3);
    mu_assert(deleted != NULL, &quot;Got NULL on delete.&quot;);
    mu_assert(deleted == &amp;expect3, &quot;Should get test3&quot;);
    result = BSTree_get(map, &amp;test3);
    mu_assert(result == NULL, &quot;Should delete.&quot;);

    // test deleting non-existent stuff
    deleted = (bstring) BSTree_delete(map, &amp;test3);
    mu_assert(deleted == NULL, &quot;Should get NULL&quot;);

    return NULL;
}

char *test_fuzzing()
{
    BSTree *store = BSTree_create(NULL);
    int i = 0;
    int j = 0;
    bstring numbers[100] = { NULL };
    bstring data[100] = { NULL };
    srand((unsigned int)time(NULL));

    for (i = 0; i &lt; 100; i++) {
        int num = rand();
        numbers[i] = bformat(&quot;%d&quot;, num);
        data[i] = bformat(&quot;data %d&quot;, num);
        BSTree_set(store, numbers[i], data[i]);
    }

    for (i = 0; i &lt; 100; i++) {
        bstring value = BSTree_delete(store, numbers[i]);
        mu_assert(value == data[i],
                &quot;Failed to delete the right number.&quot;);

        mu_assert(BSTree_delete(store, numbers[i]) == NULL,
                &quot;Should get nothing.&quot;);

        for (j = i + 1; j &lt; 99 - i; j++) {
            bstring value = BSTree_get(store, numbers[j]);
            mu_assert(value == data[j],
                    &quot;Failed to get the right number.&quot;);
        }

        bdestroy(value);
        bdestroy(numbers[i]);
    }

    BSTree_destroy(store);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_create);
    mu_run_test(test_get_set);
    mu_run_test(test_traverse);
    mu_run_test(test_delete);
    mu_run_test(test_destroy);
    mu_run_test(test_fuzzing);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>There&rsquo;s nothing new in the code, but make sure you read the book carefully.</p>

<p>Code Review</p>

<p>.\ex40\bstree.h</p>

<pre><code class="language-c">#ifndef _lcthw_BSTree_h
#define _lcthw_BSTree_h

typedef int (*BSTree_compare) (void *a, void *b);

typedef struct BSTreeNode {
    void *key;
    void *data;

    struct BSTreeNode *left;
    struct BSTreeNode *right;
    struct BSTreeNode *parent;
} BSTreeNode;

typedef struct BSTree {
    int count;
    BSTree_compare compare;
    BSTreeNode *root;
} BSTree;

typedef int (*BSTree_traverse_cb) (BSTreeNode * node);

BSTree *BSTree_create(BSTree_compare compare);
void BSTree_destroy(BSTree * map);

int BSTree_set(BSTree * map, void *key, void *data);
void *BSTree_get(BSTree * map, void *key);

int BSTree_traverse(BSTree * map, BSTree_traverse_cb traverse_cb);

void *BSTree_delete(BSTree * map, void *key);

#endif

</code></pre>

<p>.\ex40\bstree.c</p>

<pre><code class="language-c">#include &lt;lcthw/dbg.h&gt;
#include &lt;lcthw/bstree.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;lcthw/bstrlib.h&gt;

static int default_compare(void *a, void *b)
{
    return bstrcmp((bstring) a, (bstring) b);
}

BSTree *BSTree_create(BSTree_compare compare)
{
    BSTree *map = calloc(1, sizeof(BSTree));
    check_mem(map);

    map-&gt;compare = compare == NULL ? default_compare : compare;

    return map;

error:
    if (map) {
        BSTree_destroy(map);
    }
    return NULL;
}

static int BSTree_destroy_cb(BSTreeNode * node)
{
    free(node);
    return 0;
}

void BSTree_destroy(BSTree * map)
{
    if (map) {
        BSTree_traverse(map, BSTree_destroy_cb);
        free(map);
    }
}

static inline BSTreeNode *BSTreeNode_create(BSTreeNode * parent,
        void *key, void *data)
{
    BSTreeNode *node = calloc(1, sizeof(BSTreeNode));
    check_mem(node);

    node-&gt;key = key;
    node-&gt;data = data;
    node-&gt;parent = parent;
    return node;

error:
    return NULL;
}

static inline void BSTree_setnode(BSTree * map, BSTreeNode * node,
        void *key, void *data)
{
    int cmp = map-&gt;compare(node-&gt;key, key);

    if (cmp &lt;= 0) {
        if (node-&gt;left) {
            BSTree_setnode(map, node-&gt;left, key, data);
        } else {
            node-&gt;left = BSTreeNode_create(node, key, data);
        }
    } else {
        if (node-&gt;right) {
            BSTree_setnode(map, node-&gt;right, key, data);
        } else {
            node-&gt;right = BSTreeNode_create(node, key, data);
        }
    }
}

int BSTree_set(BSTree * map, void *key, void *data)
{
    if (map-&gt;root == NULL) {
        // first so just make it and get out
        map-&gt;root = BSTreeNode_create(NULL, key, data);
        check_mem(map-&gt;root);
    } else {
        BSTree_setnode(map, map-&gt;root, key, data);
    }

    return 0;
error:
    return -1;
}

static inline BSTreeNode *BSTree_getnode(BSTree * map,
        BSTreeNode * node, void *key)
{
    int cmp = map-&gt;compare(node-&gt;key, key);

    if (cmp == 0) {
        return node;
    } else if (cmp &lt; 0) {
        if (node-&gt;left) {
            return BSTree_getnode(map, node-&gt;left, key);
        } else {
            return NULL;
        }
    } else {
        if (node-&gt;right) {
            return BSTree_getnode(map, node-&gt;right, key);
        } else {
            return NULL;
        }
    }
}

void *BSTree_get(BSTree * map, void *key)
{
    if (map-&gt;root == NULL) {
        return NULL;
    } else {
        BSTreeNode *node = BSTree_getnode(map, map-&gt;root, key);
        return node == NULL ? NULL : node-&gt;data;
    }
}

static inline int BSTree_traverse_nodes(BSTreeNode * node,
        BSTree_traverse_cb traverse_cb)
{
    int rc = 0;

    if (node-&gt;left) {
        rc = BSTree_traverse_nodes(node-&gt;left, traverse_cb);
        if (rc != 0)
            return rc;
    }

    if (node-&gt;right) {
        rc = BSTree_traverse_nodes(node-&gt;right, traverse_cb);
        if (rc != 0)
            return rc;
    }

    return traverse_cb(node);
}

int BSTree_traverse(BSTree * map, BSTree_traverse_cb traverse_cb)
{
    if (map-&gt;root) {
        return BSTree_traverse_nodes(map-&gt;root, traverse_cb);
    }

    return 0;
}

static inline BSTreeNode *BSTree_find_min(BSTreeNode * node)
{
    while (node-&gt;left) {
        node = node-&gt;left;
    }

    return node;
}

static inline void BSTree_replace_node_in_parent(BSTree * map,
        BSTreeNode * node,
        BSTreeNode * new_value)
{
    if (node-&gt;parent) {
        if (node == node-&gt;parent-&gt;left) {
            node-&gt;parent-&gt;left = new_value;
        } else {
            node-&gt;parent-&gt;right = new_value;
        }
    } else {
        // this is the root so gotta change it
        map-&gt;root = new_value;
    }

    if (new_value) {
        new_value-&gt;parent = node-&gt;parent;
    }
}

static inline void BSTree_swap(BSTreeNode * a, BSTreeNode * b)
{
    void *temp = NULL;
    temp = b-&gt;key;
    b-&gt;key = a-&gt;key;
    a-&gt;key = temp;
    temp = b-&gt;data;
    b-&gt;data = a-&gt;data;
    a-&gt;data = temp;
}

static inline BSTreeNode *BSTree_node_delete(BSTree * map,
        BSTreeNode * node,
        void *key)
{
    int cmp = map-&gt;compare(node-&gt;key, key);

    if (cmp &lt; 0) {
        if (node-&gt;left) {
            return BSTree_node_delete(map, node-&gt;left, key);
        } else {
            // not found
            return NULL;
        }
    } else if (cmp &gt; 0) {
        if (node-&gt;right) {
            return BSTree_node_delete(map, node-&gt;right, key);
        } else {
            // not found
            return NULL;
        }
    } else {
        if (node-&gt;left &amp;&amp; node-&gt;right) {
            // swap this node for the smallest node that is bigger than us
            BSTreeNode *successor = BSTree_find_min(node-&gt;right);
            BSTree_swap(successor, node);

            // this leaves the old successor with possibly a right child
            // so replace it with that right child
            BSTree_replace_node_in_parent(map, successor,
                    successor-&gt;right);

            // finally it's swapped, so return successor instead of node
            return successor;
        } else if (node-&gt;left) {
            BSTree_replace_node_in_parent(map, node, node-&gt;left);
        } else if (node-&gt;right) {
            BSTree_replace_node_in_parent(map, node, node-&gt;right);
        } else {
            BSTree_replace_node_in_parent(map, node, NULL);
        }

        return node;
    }
}

void *BSTree_delete(BSTree * map, void *key)
{
    void *data = NULL;

    if (map-&gt;root) {
        BSTreeNode *node = BSTree_node_delete(map, map-&gt;root, key);

        if (node) {
            data = node-&gt;data;
            free(node);
        }
    }

    return data;
}

</code></pre>

<p>.\ex40\bstree_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;lcthw/bstree.h&gt;
#include &lt;assert.h&gt;
#include &lt;lcthw/bstrlib.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

BSTree *map = NULL;
static int traverse_called = 0;
struct tagbstring test1 = bsStatic(&quot;test data 1&quot;);
struct tagbstring test2 = bsStatic(&quot;test data 2&quot;);
struct tagbstring test3 = bsStatic(&quot;xest data 3&quot;);
struct tagbstring expect1 = bsStatic(&quot;THE VALUE 1&quot;);
struct tagbstring expect2 = bsStatic(&quot;THE VALUE 2&quot;);
struct tagbstring expect3 = bsStatic(&quot;THE VALUE 3&quot;);

static int traverse_good_cb(BSTreeNode * node)
{
    debug(&quot;KEY: %s&quot;, bdata((bstring) node-&gt;key));
    traverse_called++;
    return 0;
}

static int traverse_fail_cb(BSTreeNode * node)
{
    debug(&quot;KEY: %s&quot;, bdata((bstring) node-&gt;key));
    traverse_called++;

    if (traverse_called == 2) {
        return 1;
    } else {
        return 0;
    }
}

char *test_create()
{
    map = BSTree_create(NULL);
    mu_assert(map != NULL, &quot;Failed to create map.&quot;);

    return NULL;
}

char *test_destroy()
{
    BSTree_destroy(map);

    return NULL;
}

char *test_get_set()
{
    int rc = BSTree_set(map, &amp;test1, &amp;expect1);
    mu_assert(rc == 0, &quot;Failed to set &amp;test1&quot;);
    bstring result = BSTree_get(map, &amp;test1);
    mu_assert(result == &amp;expect1, &quot;Wrong value for test1.&quot;);

    rc = BSTree_set(map, &amp;test2, &amp;expect2);
    mu_assert(rc == 0, &quot;Failed to set test2&quot;);
    result = BSTree_get(map, &amp;test2);
    mu_assert(result == &amp;expect2, &quot;Wrong value for test2.&quot;);

    rc = BSTree_set(map, &amp;test3, &amp;expect3);
    mu_assert(rc == 0, &quot;Failed to set test3&quot;);
    result = BSTree_get(map, &amp;test3);
    mu_assert(result == &amp;expect3, &quot;Wrong value for test3.&quot;);

    return NULL;
}

char *test_traverse()
{
    int rc = BSTree_traverse(map, traverse_good_cb);
    mu_assert(rc == 0, &quot;Failed to traverse.&quot;);
    mu_assert(traverse_called == 3, &quot;Wrong count traverse.&quot;);

    traverse_called = 0;
    rc = BSTree_traverse(map, traverse_fail_cb);
    mu_assert(rc == 1, &quot;Failed to traverse.&quot;);
    mu_assert(traverse_called == 2, &quot;Wrong count traverse for fail.&quot;);

    return NULL;
}

char *test_delete()
{
    bstring deleted = (bstring) BSTree_delete(map, &amp;test1);
    mu_assert(deleted != NULL, &quot;Got NULL on delete.&quot;);
    mu_assert(deleted == &amp;expect1, &quot;Should get test1&quot;);
    bstring result = BSTree_get(map, &amp;test1);
    mu_assert(result == NULL, &quot;Should delete.&quot;);

    deleted = (bstring) BSTree_delete(map, &amp;test1);
    mu_assert(deleted == NULL, &quot;Should get NULL on delete&quot;);

    deleted = (bstring) BSTree_delete(map, &amp;test2);
    mu_assert(deleted != NULL, &quot;Got NULL on delete.&quot;);
    mu_assert(deleted == &amp;expect2, &quot;Should get test2&quot;);
    result = BSTree_get(map, &amp;test2);
    mu_assert(result == NULL, &quot;Should delete.&quot;);

    deleted = (bstring) BSTree_delete(map, &amp;test3);
    mu_assert(deleted != NULL, &quot;Got NULL on delete.&quot;);
    mu_assert(deleted == &amp;expect3, &quot;Should get test3&quot;);
    result = BSTree_get(map, &amp;test3);
    mu_assert(result == NULL, &quot;Should delete.&quot;);

    // test deleting non-existent stuff
    deleted = (bstring) BSTree_delete(map, &amp;test3);
    mu_assert(deleted == NULL, &quot;Should get NULL&quot;);

    return NULL;
}

char *test_fuzzing()
{
    BSTree *store = BSTree_create(NULL);
    int i = 0;
    int j = 0;
    bstring numbers[100] = { NULL };
    bstring data[100] = { NULL };
    srand((unsigned int)time(NULL));

    for (i = 0; i &lt; 100; i++) {
        int num = rand();
        numbers[i] = bformat(&quot;%d&quot;, num);
        data[i] = bformat(&quot;data %d&quot;, num);
        BSTree_set(store, numbers[i], data[i]);
    }

    for (i = 0; i &lt; 100; i++) {
        bstring value = BSTree_delete(store, numbers[i]);
        mu_assert(value == data[i],
                &quot;Failed to delete the right number.&quot;);

        mu_assert(BSTree_delete(store, numbers[i]) == NULL,
                &quot;Should get nothing.&quot;);

        for (j = i + 1; j &lt; 99 - i; j++) {
            bstring value = BSTree_get(store, numbers[j]);
            mu_assert(value == data[j],
                    &quot;Failed to get the right number.&quot;);
        }

        bdestroy(value);
        bdestroy(numbers[i]);
    }

    BSTree_destroy(store);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_create);
    mu_run_test(test_get_set);
    mu_run_test(test_traverse);
    mu_run_test(test_delete);
    mu_run_test(test_destroy);
    mu_run_test(test_fuzzing);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>I&rsquo;ll walk through the implementation and compare it to Hashmaps for features.</p>

<p>Improving It</p>

<ul>
<li>As usual, you should go through all of the defensive programming checks and add
*assert*s for conditions that shouldn&rsquo;t happen.  For example, you shouldn&rsquo;t be getting <em>NULL</em> values for the recursion functions, so assert that.</li>
<li>The traverse function walks through the tree in order by traversing left, then right,
and then the current node.  You can create traverse functions for the reverse order, as well.</li>
</ul>

<p>Improving It</p>

<ul>
<li>It does a full string compare on every node, but I could use the <em>Hashmap</em>
hashing functions to speed this up.  I could hash the keys, and then keep the hash in
the <em>BSTreeNode</em>.  Then, in each of the set up functions, I can hash the
key ahead of time, and pass it down to the recursive function.  Using this hash, I can
then compare each node much quicker in a way that&rsquo;s similar to what I do in <em>Hashmap</em>.</li>
</ul>

<p>Breaking It</p>

<p>A big flaw in this is the use of recursion.  An attacker could choose data to cause a stack overflow.</p>

<p>Extra Credit</p>

<ul>
<li>There&rsquo;s an alternative way to do this data structure without using recursion.  The Wikipedia
page shows alternatives that don&rsquo;t use recursion but do the same thing.  Why would this
be better or worse?</li>
<li>Read up on all of the different but similar trees you can find. There are AVL trees (named after Georgy Adelson-Velsky and E.M. Landis), red-black trees,
and some non-tree structures like skip lists.</li>
</ul>

    </div>

    <div class="toc toc-fixed" >
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#exercise-32-double-linked-lists">Exercise 32 Double Linked Lists</a></li>
<li><a href="#exercise-33-linked-list-algorithms">Exercise 33 Linked List Algorithms</a></li>
<li><a href="#exercise-34-dynamic-array">Exercise 34 Dynamic Array</a></li>
<li><a href="#exercise-35-sorting-and-searching">Exercise 35 Sorting and Searching</a></li>
<li><a href="#exercise-36-safer-strings">Exercise 36 Safer Strings</a></li>
<li><a href="#exercise-37-hashmaps">Exercise 37 Hashmaps</a></li>
<li><a href="#exercise-38-hashmap-algorithms">Exercise 38 Hashmap Algorithms</a></li>
<li><a href="#exercise-39-string-algorithms">Exercise 39 String Algorithms</a></li>
<li><a href="#exercise-40-binary-search-trees">Exercise 40 Binary Search Trees</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>

</div>

    
    
        <div class="chevrons">
    <div id="navigation">
<a class="nav nav-prev" href="/coding/c/lcthw-lectures.1/" title="C Lecture - 1"> <i class="fa fa-chevron-left"></i><label>C Lecture - 1</label></a>
    <a class="nav nav-next" href="/coding/c/lcthw-lectures.3/" title="C Lecture - 3" style="margin-right: 0px;"><label>C Lecture - 3</label><i class="fa fa-chevron-right"></i></a></div>
  </div>

  </section>
</article>

<footer>

<div class="footline">
    

    

    

    
  </div>


	<div>


  
    
  



	</div>
</footer>

<script src="/js/clipboard.min.js"></script>

<link href="/css/featherlight.min.css" rel="stylesheet">
<script src="/js/featherlight.min.js"></script>


<link href="/css/github.css" rel="stylesheet">
<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<script src="/theme-flex/script.js"></script>


    

    
    

    
  </body>
</html>