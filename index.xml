<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hello World</title>
    <link>https://harryho.github.io/</link>
    <description>Recent content on Hello World</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2015, harryho; All rights reserved.</copyright>
    <lastBuildDate>Thu, 16 Feb 2017 11:47:59 +1100</lastBuildDate>
    <atom:link href="https://harryho.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>_dummy</title>
      <link>https://harryho.github.io/index/_dummy/</link>
      <pubDate>Thu, 16 Feb 2017 11:47:59 +1100</pubDate>
      
      <guid>https://harryho.github.io/index/_dummy/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Create a blog site on GitHub Pages</title>
      <link>https://harryho.github.io/dev/create-a-blog-on-github-pages/</link>
      <pubDate>Wed, 15 Feb 2017 14:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/dev/create-a-blog-on-github-pages/</guid>
      <description>

&lt;p&gt;&lt;em&gt;After I setup a blog site with Hugo on my ubuntu machine, I decided to use it to create a blog to GitHub pages on my windows machine, since I use Windows machine as workstation. If you use Unix-style system, I pretty sure you can follow the &lt;a href=&#34;https://gohugo.io/overview/quickstart/&#34;&gt;Hugo Quick Start&lt;/a&gt; and &lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog&#34;&gt;Hosting on GitHub Pages&lt;/a&gt; to create a blog to GitHub pages within 5 mins, but when I try to do the same on Windows machine, it took me over 30 mins. I hope this blog can help someone want to do sth similar within Windows environment.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;assumptions:677eca8a58bb006b7a1c0100cb6acd91&#34;&gt;Assumptions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;You already have &lt;em&gt;Hugo&lt;/em&gt; on your computer. If not, please follow the instruction to &lt;a href=&#34;https://gohugo.io/tutorials/installing-on-windows&#34;&gt;install hugo on Windows&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You will have two repositories &lt;code&gt;blog-hugo&lt;/code&gt; and &lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; repositories to hold your hugo content and blog site respectively.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;blog-hugo&lt;/code&gt; repository will host actual Hugo’s blog content.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;username&amp;gt;.github.io repository&lt;/code&gt; repository will host the static website.&lt;/li&gt;
&lt;li&gt;Your &lt;em&gt;Hugo&lt;/em&gt; blog folder will be &amp;ldquo;C:\git\blog-hugo&amp;rdquo; in this example.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Your blog site will finally sit in C driver and map to repositories as follow&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:\&amp;gt;
|--git 
    |--blog-hugo (https://github.com/&amp;lt;yourname&amp;gt;/blog-hugo.git
        |--archetypes
        |--content
        |--data
        |--layouts
        |--public (https://github.com/&amp;lt;yourname&amp;gt;/&amp;lt;yourname&amp;gt;.github.io.git)
        |--themes
        |--


&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;create-a-blog-site-on-github-pages:677eca8a58bb006b7a1c0100cb6acd91&#34;&gt;Create a blog site on GitHub pages&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Create on GitHub blog-hugo and &lt;username&gt;.github.io repositories  repository via GitHub website&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clone blog-hugo via Windows command prompt&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;c:\&amp;gt;
c:\&amp;gt;cd git
c:\git&amp;gt;git clone &amp;lt;&amp;lt;your-project&amp;gt;-hugo-url&amp;gt; &amp;amp;&amp;amp; cd &amp;lt;your-project&amp;gt;-hugo
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create hugo site and setup the theme you like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:\git&amp;gt;hugo new site blog-hugo
C:\git&amp;gt;hugo server -t &amp;lt;yourtheme&amp;gt; -D
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clean up the &lt;code&gt;public&lt;/code&gt; folder&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set submodule inside the blog-hugo and map to folder &lt;code&gt;public&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:\&amp;gt;cd git
C:\git&amp;gt;rm -rf public
C:\git&amp;gt;git submodule add -b master https://github.com/&amp;lt;username&amp;gt;/&amp;lt;username&amp;gt;.github.io.git public
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Deploy the blog site to GitHub page with the script &lt;code&gt;deploy.bat&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;deploy.bat &amp;quot;Your optional commit message&amp;quot;&lt;/code&gt; will commit the changes to &lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;. You can use and tailor the script below as your &lt;code&gt;deploy.bat&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;@echo OFF


echo  Deploying updates to GitHub...


REM Build the project. 
hugo -t &amp;lt;yourtheme&amp;gt; -D


REM Go To Public folder
cd public


REM Add changes to git.
git add -A


REM Commit changes.
set msg=&amp;quot;rebuilding site %date%&amp;quot;
if  NOT &amp;quot;%1&amp;quot;==&amp;quot;&amp;quot;    set msg=%1
git commit -m &#39;%msg%&#39;


REM Push source and build repos.
git push origin master


REM Come Back
cd ..
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You might want to commit the changes to &lt;code&gt;blog-hugo&lt;/code&gt; repository. Please don&amp;rsquo;t forget to add &lt;code&gt;public&lt;/code&gt; into the &lt;code&gt;.gitignore&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JIRA Notes</title>
      <link>https://harryho.github.io/dev/jira-notes/</link>
      <pubDate>Wed, 11 Jan 2017 11:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/dev/jira-notes/</guid>
      <description>

&lt;h2 id=&#34;what-is-jira:2a6d8c948f7a3ac4f8e6148a080bba99&#34;&gt;What is JIRA&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Jira is a proprietary issue tracking product, developed by Atlassian. It provides bug tracking, issue tracking, and project management functions. Although normally styled JIRA, the product name is not an acronym, but a truncation of Gojira, the Japanese name for Godzilla,[6] itself a reference to Jira&amp;rsquo;s main competitor, Bugzilla. It has been developed since 2002.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;how-to-work-with-client-within-jira:2a6d8c948f7a3ac4f8e6148a080bba99&#34;&gt;How to work with client within JIRA&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The instruction below is only for the client who has independent JIRA instance. Here I am not going to discuss how to cooperate with multiple clients and projects on the same JIRA instance. IMO, the strategy for that would be case by case.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;assumption:2a6d8c948f7a3ac4f8e6148a080bba99&#34;&gt;Assumption&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Your client&amp;rsquo;s business name is ABC. You help them to manage their JIRA. You are the administrator of JIRA instance.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You have created a project for client, named &lt;strong&gt;ABC IT Project&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You want to allow the client to access this project on JIRA, but you want to avoid client&amp;rsquo;s unintented update to mess up the project management.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;requirement-of-permission-control:2a6d8c948f7a3ac4f8e6148a080bba99&#34;&gt;Requirement of permission control&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;In Agile practice, product owner should attend the&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;change-default-permission-scheme:2a6d8c948f7a3ac4f8e6148a080bba99&#34;&gt;Change default permission scheme&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Default permission scheme is the built-in scheme, which you cannot delete it, but you can change it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Choose &lt;code&gt;Isssues&lt;/code&gt; &amp;gt; &lt;code&gt;Permission schemes&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Change all permissions from &lt;code&gt;Project Access - Any logged in user&lt;/code&gt; to &lt;code&gt;Project role - Administrator&lt;/code&gt; except the following items.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;View Development Tools&lt;/li&gt;
&lt;li&gt;View Read-Only Workflow&lt;/li&gt;
&lt;li&gt;Assignable User&lt;/li&gt;
&lt;li&gt;Delete Own Comments&lt;/li&gt;
&lt;li&gt;Edit Own Comments&lt;/li&gt;
&lt;li&gt;Delete Own Attachments&lt;/li&gt;
&lt;li&gt;Delete Own Worklogs&lt;/li&gt;
&lt;li&gt;Edit Own Worklogs&lt;/li&gt;
&lt;li&gt;Work On Issues&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Copy the default permission scheme and rename it to &lt;code&gt;&amp;lt;client_business_name&amp;gt; Permission Scheme&lt;/code&gt;. In this case it would be &lt;code&gt;ABC Permission Scheme&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create a new group named &lt;strong&gt;ABC Group&lt;/strong&gt;,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Update &lt;code&gt;ABC Permission Scheme&lt;/code&gt; by granting &lt;code&gt;ABC Group&lt;/code&gt; to some items.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Browse Projects&lt;/li&gt;
&lt;li&gt;Create Issues&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Update the permission scheme of the project &lt;code&gt;ABC IT Project&lt;/code&gt; from to &lt;code&gt;ABC Permission Scheme&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;change-user-s-group:2a6d8c948f7a3ac4f8e6148a080bba99&#34;&gt;Change user&amp;rsquo;s group&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Choose &lt;code&gt;User management&lt;/code&gt; &amp;gt; &lt;code&gt;User&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add the ABC&amp;rsquo;s user to group &lt;code&gt;ABC Group&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Remove the user from default &lt;code&gt;jira-software-user&lt;/code&gt; and make sure the checkbox &lt;code&gt;Access JIRA Software&lt;/code&gt; is selected.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;time-tracking-and-estimation:2a6d8c948f7a3ac4f8e6148a080bba99&#34;&gt;Time Tracking and Estimation&lt;/h2&gt;

&lt;h3 id=&#34;enable-time-tracking:2a6d8c948f7a3ac4f8e6148a080bba99&#34;&gt;Enable Time Tracking&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Choose &lt;code&gt;Issues&lt;/code&gt; &amp;gt; &lt;code&gt;Time Tracking&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Enable the &lt;code&gt;Time Tracking&lt;/code&gt; if it is inactive.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Choose &lt;code&gt;Boards&lt;/code&gt; &amp;gt; &lt;code&gt;View All Boards&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Choose &lt;code&gt;Board Settings&lt;/code&gt; of the board&lt;/li&gt;
&lt;li&gt;Choose &lt;code&gt;Estimation&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Choose &lt;code&gt;Remaining Estimate and Time Spent&lt;/code&gt; as Time Tracking&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Laravel MVC Starter</title>
      <link>https://harryho.github.io/project/laravel-mvc-starter/</link>
      <pubDate>Wed, 07 Dec 2016 16:56:21 +1100</pubDate>
      
      <guid>https://harryho.github.io/project/laravel-mvc-starter/</guid>
      <description>

&lt;p&gt;This starter is the starting point of laravel 5 MVC project. This application is meant to be used as a starting place for those looking to get their feet wet with laravel.&lt;/p&gt;

&lt;h2 id=&#34;overview-of-project:5b20d0cd6fb65fb438e7331895e741aa&#34;&gt;Overview of project&lt;/h2&gt;

&lt;h2 id=&#34;bdd-business-domain-design:5b20d0cd6fb65fb438e7331895e741aa&#34;&gt;BDD ( Business domain design)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;+-------+ 0...*     0...* +--------+ 1     0...* +---------+ 
| tag   | --------------- |  post  | ----- ----- | comment |
+-------+                 +--------+             +---------+           
                               | 1...*
                               |
                               | 0...*
                          +--------+ 
                          |  like  |
                          +--------+

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;structure-of-starter:5b20d0cd6fb65fb438e7331895e741aa&#34;&gt;Structure of starter&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;\path\to\lara-mvc-starter
+---app                 &amp;lt;-// Customized PHP application code
|   +---Console
|   +---Exceptions
|   +---Http
|   |   +---Controllers
|   |   |   \---Auth
|   |   \---Middleware
|   \---Providers
+---bootstrap          &amp;lt;-// bootstrap the framework and configure autoloading
|   \---cache
+---config              &amp;lt;-// application configuration
+---database            &amp;lt;-// database migration files
|   +---factories
|   +---migrations
|   \---seeds
+---public               &amp;lt;-// Distributed website folder including Style sheet
+---resources            &amp;lt;-// View files, Javascripts, localization setting
|   +---assets
|   +---lang
|   \---views
|       +---admin
|       +---blog
|       +---errors
|       +---layouts
|       +---other
|       +---partials
|       \---vendor
|           \---pagination
+---routes              &amp;lt;-// Route definitions and setting
+---storage             &amp;lt;-//Blade templates, file based sessions, file caches
|   +---app
|   |   \---public
|   +---framework
|   |   +---cache
|   |   +---sessions
|   |   \---views
|   \---logs
+---tests
\---vendor            &amp;lt;-// Laravel framework

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;screenshots:5b20d0cd6fb65fb438e7331895e741aa&#34;&gt;Screenshots&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://harryho.github.io/img/lara-mvc-starter.png&#34; alt=&#34;laravel-mvc-starter&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;browse-repository-https-github-com-harryho-lara-mvc-starter-git:5b20d0cd6fb65fb438e7331895e741aa&#34;&gt;Browse &lt;a href=&#34;https://github.com/harryho/lara-mvc-starter.git&#34;&gt;Repository&lt;/a&gt;&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Reetek Vue 2 Admin Project</title>
      <link>https://harryho.github.io/project/reetek-vue2-admin/</link>
      <pubDate>Wed, 07 Dec 2016 16:56:21 +1100</pubDate>
      
      <guid>https://harryho.github.io/project/reetek-vue2-admin/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Vue2Admin&lt;/strong&gt; is a fully responsive admin template that is inspired by &lt;a href=&#34;https://almsaeedstudio.com&#34;&gt;AdminLTE&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This template is built-in with Vue 2 at the start.&lt;/li&gt;
&lt;li&gt;It include Vue Resource, Vuex as well.&lt;/li&gt;
&lt;li&gt;The plugins for this project are loaded with script loader.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;structure-of-reetek-vue2admin:83c4792209a733fdf1eebf9d4f2568c5&#34;&gt;Structure of Reetek Vue2Admin&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;path\to\vue2admin
+---build              &amp;lt;-// webpack files
+---config             &amp;lt;-// configuration of dev or prod environment
+---screenshots
+---src                &amp;lt;-// vue components 
|   +---components
|   |   +---charts
|   |   +---dashboard
|   |   +---forms
|   |   +---mailbox
|   |   +---misc
|   |   +---pages
|   |   +---tables
|   |   +---ui
|   |   \---widget
|   \---filters
+---static              &amp;lt;-// css, dump data, fonts, image files and plugins
|   +---css
|   +---data
|   +---fonts
|   +---img
|   |   +---credit
|   |   \---stock
|   \---js
|       \---plugins         &amp;lt;-// plugins for admin dashboard 
|           +---AdminLTE
|           +---bootstrap
|           +---bootstrap-slider
|           +---bootstrap-wysihtml5
|           +---chartjs
|           +---ckeditor
|           + ...
\---test
    +---e2e
    \---unit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;screenshots:83c4792209a733fdf1eebf9d4f2568c5&#34;&gt;Screenshots&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://harryho.github.io/img/vue2admin_screenshot1_sm.png&#34; alt=&#34;Screenshot1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://harryho.github.io/img/vue2admin_screenshot2_sm.png&#34; alt=&#34;Screenshot2&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;browse-repository-https-github-com-harryho-vue2admin-git:83c4792209a733fdf1eebf9d4f2568c5&#34;&gt;Browse &lt;a href=&#34;https://github.com/harryho/vue2admin.git&#34;&gt;Repository&lt;/a&gt;&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Tensorflow Notes, Part 1</title>
      <link>https://harryho.github.io/dev/tensorflow-notes-1/</link>
      <pubDate>Wed, 07 Dec 2016 16:56:21 +1100</pubDate>
      
      <guid>https://harryho.github.io/dev/tensorflow-notes-1/</guid>
      <description>

&lt;h3 id=&#34;assumption:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Assumption&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;You are using Ubuntu 16&lt;/li&gt;
&lt;li&gt;Your machine has Nvidia GPU card installed&lt;/li&gt;
&lt;li&gt;If you are using Ubuntu 14, the installation of CUDA and cuDNN will be a bit different. Please check Google&amp;rsquo;s instructions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;install-python3-and-pip3:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Install python3 and pip3&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://harryho.github.io/os/ubuntu-server-14&#34;&gt;Please find instructions here&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;install-virtualenv-via-pip3:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Install virtualenv via pip3&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pip3 install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-two-tensorflow-virtualenvs:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Create two tensorflow virtualenvs.&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mkdir ~/.envs
virtualenv --system-site-packages ~/.envs/tf  # CPU only
virtualenv --system-site-packages ~/.envs/tfgpu   # GPU enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;install-tensorflow-for-different-virtualenvs:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Install tensorflow for different virtualenvs&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;source ~/.envs/tf/bin/activate
source ~/.envs/tfgpu/bin/activate

pip3 install tensorflow # CPU only
pip3 install tensorflow-gpu # GPU enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;install-cuda-and-cudnn-for-tensorflow-gpu:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Install CUDA and cuDNN for tensorflow-gpu&lt;/h3&gt;

&lt;h4 id=&#34;use-following-command-to-check-you-gpu-information:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Use following command to check you GPU information&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;lspic -nn | grep &#39;\[03&#39; ]
lshw -numeric -C display

# GPU info sample
# NVIDIA Corporation GM107M [GeForce GTX 850M]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;download-and-install-nvidia-driver-based-on-above-gpu-info-http-www-geforce-com-drivers:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Download and install Nvidia driver based on above GPU info &lt;a href=&#34;http://www.geforce.com/drivers&#34;&gt;http://www.geforce.com/drivers&lt;/a&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;chmod +x NVIDIA-Linux-xxxx.run
sudo ./NVIDIA-Linux-xxxx.run   
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;download-and-install-cuda-from-nvidia-https-developer-nvidia-com-cuda-downloads:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Download and install  CUDA from NVIDIA &lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt;https://developer.nvidia.com/cuda-downloads&lt;/a&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sudo dpkg -i cuda-repo-xxxxx.deb
sudo apt-get udpate
sudo apt-get install cuda
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;setup-cuda-home:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Setup CUDA_HOME&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# CUDA
export CUDA_HOME=/usr/local/cuda-8.0 
export LD_LIBRARY_PATH=${CUDA_HOME}/lib64 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;download-and-install-cudnn-for-cuda-https-developer-nvidia-com-cudnn:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Download and install cuDNN for CUDA &lt;a href=&#34;https://developer.nvidia.com/cudnn&#34;&gt;https://developer.nvidia.com/cudnn&lt;/a&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# extra the cuDNN tar ball
tar -xvf cudnn-8.0
cd cuda 
sudo cp lib64/* /usr/local/cuda-8.0/lib64
sudo cp include/* /usr/local/cuda-8.0/include
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;use-sample-code-to-test-tensorflow:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Use sample code to test Tensorflow&lt;/h3&gt;

&lt;h4 id=&#34;save-code-below-to-file-test-py:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Save code below to file test.py&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np
import tensorflow as tf

# Model parameters
W = tf.Variable([.3], tf.float32)
b = tf.Variable([-.3], tf.float32)
# Model input and output
x = tf.placeholder(tf.float32)
linear_model = W * x + b
y = tf.placeholder(tf.float32)
# loss
loss = tf.reduce_sum(tf.square(linear_model - y)) # sum of the squares
# optimizer
optimizer = tf.train.GradientDescentOptimizer(0.01)
train = optimizer.minimize(loss)
# training data
x_train = [1,2,3,4]
y_train = [0,-1,-2,-3]
# training loop
init = tf.global_variables_initializer()
sess = tf.Session()
sess.run(init) # reset values to wrong
for i in range(1000):
sess.run(train, {x:x_train, y:y_train})

# evaluate training accuracy
curr_W, curr_b, curr_loss  = sess.run([W, b, loss], {x:x_train, y:y_train})
print(&amp;quot;W: %s b: %s loss: %s&amp;quot;%(curr_W, curr_b, curr_loss))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;test-with-tensorflow-gpu-gpu-enabled:dcc7d6c7e6d56cb7c25ea39a679187b7&#34;&gt;Test with tensorflow-gpu (GPU enabled)&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;source ~/.envs/tfgpu/bin/activate
python3 test.py

# You will probably see the result as follow 
# ....
# name: GeForce GTX 850M
# major: 5 minor: 0 memoryClockRate (GHz) 0.9015
# pciBusID 0000:0a:00.0
# Total memory: 3.95GiB
# Free memory: 3.58GiB
# 2017-04-25 10:25:59.640621: I tensorflow/core/common_runtime/gpu/gpu_device.cc:908] DMA: 0 
# 2017-04-25 10:25:59.640626: I tensorflow/core/common_runtime/gpu/gpu_device.cc:918] 0:   Y 
# 2017-04-25 10:25:59.640640: I tensorflow/core/common_runtime/gpu/gpu_device.cc:977] Creating TensorFlow device (/gpu:0) -&amp;gt; (device: 0, name: GeForce GTX 850M, pci # bus id: 0000:0a:00.0)
# W: [-0.9999969] b: [ 0.99999082] loss: 5.69997e-11
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Angularjs Webpack ES6 Starter</title>
      <link>https://harryho.github.io/project/angularjs-webpack-es6-starter/</link>
      <pubDate>Tue, 15 Nov 2016 16:56:21 +1100</pubDate>
      
      <guid>https://harryho.github.io/project/angularjs-webpack-es6-starter/</guid>
      <description>

&lt;p&gt;This starter was inspired by another similar angular webpack starter repository. It simply includes font-awesome, bootstrap for the people who don&amp;rsquo;t want to use boostrap-webpack, font-awesome-webpack. I find it saves us so much effort to create prototype, since we don&amp;rsquo;t need spectacular UI.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This starter uses angular 1.5 for someone want to build component.&lt;/li&gt;
&lt;li&gt;This repo followes mvc patterns instead of component pattern.&lt;/li&gt;
&lt;li&gt;ES6, and ES7 support with babel.&lt;/li&gt;
&lt;li&gt;Development server with live reload.&lt;/li&gt;
&lt;li&gt;Production builds with cache busting.&lt;/li&gt;
&lt;li&gt;Testing environment using karma to run tests and jasmine as the framework.&lt;/li&gt;
&lt;li&gt;Code coverage when tests are run.&lt;/li&gt;
&lt;li&gt;Include font-awesome without font-awesome-loader.&lt;/li&gt;
&lt;li&gt;Include Bootstrap 3 without bootstrap-loader.&lt;/li&gt;
&lt;li&gt;No gulp and no grunt, just npm scripts.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;structure-of-starter:75a64a1b122f2df3746e065b2ed5b945&#34;&gt;Structure of starter&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
\path\to\angularjs-webpack-es6-starter
|   .babelrc                                    &amp;lt;-// default setting es2015.
|   karma.conf.js                               &amp;lt;-// tests and report setup 
|   webpack.config.js                           &amp;lt;-// webpack config
\---src
    |   tests.webpack.js
    |   
    +---app
    |   |   app.html                            &amp;lt;-// app view
    |   |   app.js                              &amp;lt;-// app module
    |   |   app.routes.js                       &amp;lt;-// app route to manage all routes 
    |   |   app.runner.js                       &amp;lt;-// app runner for state change enhancement  
    |   |   app.spec.js                         &amp;lt;-// app spec file for testing 
    |   |   
    |   +---common                              &amp;lt;-// common module for whole app
    |   |   |   common.js
    |   |   |   common.spec.js
    |   |   +---directives                      &amp;lt;-// common directives for whole app
    |   |   |       appUiDirectives.js
    |   |   |       appUiDirectives.spec.js
    |   |   |       commonDirectives.js
    |   |   |       commonDirectives.spec.js
    |   |   +---services                        &amp;lt;-// common views for whole app
    |   |   |       ApiService.js
    |   |   |       ApiService.spec.js
    |   |   |       UtilService.js
    |   |   |       UtilService.spec.js
    |   |   \---views                           &amp;lt;-// contains common views
    |   |           footer-view.html
    |   |           header-view.html
    |   |           sidebar-view.html
    |   |           topbar-view.html
    |   \---main                                &amp;lt;-// built-in fonts, css, images 
    |       \---dashboard
    |           +---controllers
    |           |       dashboardController.js
    |           |       dashboardController.spec.js
    |           \---views
    |                   dashboard-view.html
    |                   
    +---public                                  &amp;lt;-// built-in fonts, css, images 
    |   |   index.html
    |   +---fonts
    |   |   +--- ...
    |   \---img
    |       +--- favicon.ico
    \---style                                  &amp;lt;-// css files including customized css
           
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;browse-repository-https-github-com-harryho-angularjs-webpack-es6-starter-git:75a64a1b122f2df3746e065b2ed5b945&#34;&gt;Browse &lt;a href=&#34;https://github.com/harryho/angularjs-webpack-es6-starter.git&#34;&gt;Repository&lt;/a&gt;&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>Git Notes</title>
      <link>https://harryho.github.io/dev/git-notes/</link>
      <pubDate>Thu, 11 Aug 2016 11:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/dev/git-notes/</guid>
      <description>&lt;p&gt;Create a new branch with git and manage branches&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Create the branch on your local machine and switch in this branch :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b [name_of_your_new_branch]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Push the branch on github :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ git push origin [name_of_your_new_branch]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When you want to commit something in your branch, be sure to be in your branch.&lt;/p&gt;

&lt;p&gt;You can see all branches created by using :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which will show :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* approval_messages
  master
  master_clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add a new remote for your branch :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote add [name_of_your_remote]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Push changes from your commit into your branch :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push [name_of_your_new_remote] [name_of_your_branch]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update your branch when the original branch from official repository has been updated :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch [name_of_your_remote]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you need to apply to merge changes, if your branch is derivated from develop you need to do :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge [name_of_your_remote]/develop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Delete a branch on your local filesystem :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch -d [name_of_your_new_branch]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To force the deletion of local branch on your filesystem :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch -D [name_of_your_new_branch]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Delete the branch on github :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin :[name_of_your_new_branch]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compare two branch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff [name_of_branch1]..[name_of_branch2]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Branch merge&lt;/p&gt;

&lt;p&gt;Example&lt;/p&gt;

&lt;p&gt;Fast-Forward Merge&lt;/p&gt;

&lt;p&gt;Our first example demonstrates a fast-forward merge. The code below creates a new branch, adds two commits to it, then integrates it into the main line with a fast-forward merge.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Start a new feature
git checkout -b new-feature master
# Edit some files
git add &amp;lt;file&amp;gt;
git commit -m &amp;quot;Start a feature&amp;quot;
# Edit some files
git add &amp;lt;file&amp;gt;
git commit -m &amp;quot;Finish a feature&amp;quot;
# Merge in the new-feature branch
git checkout master
git merge new-feature
git branch -d new-feature
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a common workflow for short-lived topic branches that are used more as an isolated development than an organizational tool for longer-running features.&lt;/p&gt;

&lt;p&gt;Also note that Git should not complain about the git branch -d, since new-feature is now accessible from the master branch.&lt;/p&gt;

&lt;p&gt;3-Way Merge&lt;/p&gt;

&lt;p&gt;The next example is very similar, but requires a 3-way merge because master progresses while the feature is in-progress. This is a common scenario for large features or when several developers are working on a project simultaneously.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Start a new feature
git checkout -b new-feature master
# Edit some files
git add &amp;lt;file&amp;gt;
git commit -m &amp;quot;Start a feature&amp;quot;
# Edit some files
git add &amp;lt;file&amp;gt;
git commit -m &amp;quot;Finish a feature&amp;quot;
# Develop the master branch
git checkout master
# Edit some files
git add &amp;lt;file&amp;gt;
git commit -m &amp;quot;Make some super-stable changes to master&amp;quot;
# Merge in the new-feature branch
git merge new-feature
git branch -d new-feature
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PHP web framework</title>
      <link>https://harryho.github.io/dev/php-web/</link>
      <pubDate>Thu, 11 Aug 2016 11:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/dev/php-web/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Here we are going to explore some PHP web frameworks.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;php-development-environment-setup:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;PHP development environment setup&lt;/h1&gt;

&lt;h2 id=&#34;install-php-5-6-x:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Install PHP 5.6.x&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Please find the instruction from &lt;a href=&#34;https://harryho.github.io/#php&#34;&gt;home page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;composer:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Composer&lt;/h2&gt;

&lt;h3 id=&#34;linux:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Linux&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;curl -s https://getcomposer.org/installer | php --&lt;/code&gt; to install composer on Linux&lt;/li&gt;
&lt;li&gt;use &amp;lsquo;composer -v &amp;rsquo; to verify.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;windows:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Windows&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Download the &lt;a href=&#34;https://getcomposer.org/download/&#34;&gt;composer&lt;/a&gt; and install php on your PC&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;composer -v&lt;/code&gt; to verify the composer is ready.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;zendframework:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Zendframework&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Zend Framework is a collection of 60+ packages for professional PHP development. It can be used to develop web applications and services using PHP 5.6+, and provides 100% object-oriented code using a broad spectrum of language features.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;zendframework-2-x:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Zendframework 2.x&lt;/h2&gt;

&lt;h3 id=&#34;create-zendframework-2-project-from-scratch:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Create Zendframework 2 project from scratch&lt;/h3&gt;

&lt;h4 id=&#34;clone-zendframework-skeleton-project-as-new-project:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;* Clone Zendframework skeleton project as new project.&lt;/h4&gt;

&lt;h4 id=&#34;install-zendframework-with-composer:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;* Install zendframework with composer&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    cd  /path/to/newproject
    git clone git://github.com/zendframework/ZendSkeletonApplication.git
    cd ZendSkeletonApplication
    php composer.phar self-update
    php composer.phar install
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;start-app-with-php-built-in-server:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;* Start app with php built-in server&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Linux&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;php -S 0.0.0.0:8080 -t public/ public/index.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;php -S 0.0.0.0:8080 -t public public/index.php
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;use-apache-server:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;* Use apache server&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-apache&#34;&gt; &amp;lt;VirtualHost *:80&amp;gt;
     ServerName zf2-tutorial.localhost
     DocumentRoot /path/to/newproject/ZendSkeletonApplication/public
     SetEnv APPLICATION_ENV &amp;quot;development&amp;quot;
     &amp;lt;Directory /path/to/newproject/ZendSkeletonApplication/public&amp;gt;
         DirectoryIndex index.php
         AllowOverride All
         Require all granted
     &amp;lt;/Directory&amp;gt;
 &amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;use-zf2-mvc-starter-project:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Use Zf2-MVC-Starter project&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Please find the project introduction &lt;a href=&#34;https://harryho.github.io/project/zf2-mvc-starter/&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;laravel:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Laravel&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Laravel is a free, open-source PHP web framework, created by Taylor Otwell and intended for the development of web applications following the model–view–controller (MVC) architectural pattern. Some of the features of Laravel are a modular packaging system with a dedicated dependency manager, different ways for accessing relational databases, utilities that aid in application deployment and maintenance, and its orientation toward syntactic sugar.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;laravel-5-x:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Laravel 5.x&lt;/h2&gt;

&lt;h3 id=&#34;install-laravel-global:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Install laravel global&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Use `composer global laravel/installer`
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enable-the-mbs-string-extension:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Enable the &lt;code&gt;mbs-string&lt;/code&gt; extension&lt;/h3&gt;

&lt;h4 id=&#34;update-php-ini-config:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;update &lt;code&gt;php.ini&lt;/code&gt; config&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Open &lt;code&gt;php.ini&lt;/code&gt; with notepad&lt;/li&gt;
&lt;li&gt;Change &lt;code&gt;;extension=php_mbstring.dll&lt;/code&gt; to &lt;code&gt;extension=php_mbstring.dll&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;create-new-project-from-scratch:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Create new project from scratch&lt;/h3&gt;

&lt;h4 id=&#34;create-new-project:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Create new project&lt;/h4&gt;

&lt;h4 id=&#34;migrate-database-and-seed-dummy-data:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Migrate database and seed dummy data&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Create data model&lt;/li&gt;
&lt;li&gt;Following is the sample code
```php
&amp;lt;?php&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;namespace App;
use Illuminate\Database\Eloquent\Model;&lt;/p&gt;

&lt;p&gt;class Article extends Model
{
    protected $fillable = [&amp;lsquo;title&amp;rsquo;, &amp;lsquo;content&amp;rsquo;];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function getTitleAttribute($value) {
    return strtoupper($value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* Use artisan to create the table 

```bash

php artisan migrate -VVV 

# Use following command to seek dump or initial data
php artisan db:seed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;troubleshooting:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Troubleshooting&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Fix the error of Specified key was too long&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use Illuminate\Support\Facades\Schema;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        //
        Schema::defaultStringLength(191);
    }

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        //
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;use-lavarel-mvc-starter-project:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Use Lavarel MVC Starter project&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;* Please find the project introduction [here](/project/lara-mvc-starter/). 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;use-laravel-rest-starter-project:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Use Laravel Rest Starter project&lt;/h3&gt;

&lt;h2 id=&#34;prestashop:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;PrestaShop&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;PrestaShop is a free, open source e-commerce solution. The software is published under the Open Software License (OSL). It is written in the PHP programming language with support for the MySQL database management system.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;prestashop-1-5-4:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Prestashop 1.5.4&lt;/h2&gt;

&lt;h3 id=&#34;download-the-zip-file-from-download-page-https-www-prestashop-com-en-developers-versions:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Download the zip file from &lt;a href=&#34;https://www.prestashop.com/en/developers-versions&#34;&gt;download page&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;install-prestashop:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Install Prestashop&lt;/h3&gt;

&lt;p&gt;There is a instruction page inside the zip file. You can follow the instructions to complete the installation. There is no EasyPHP, Wamp, XAMPP, or any similar AMP (Apache+MySQL+PHP) package installed on my PC, but I have PHP, Apache, MySQL installed. Actually EasyPHP, Wamp are just the bundle of PHP development tools, which include PHP, Apache, MySQL. I don&amp;rsquo;t want to install too many duplicate softwares and packages on my PC, so I prefer to install Prestashop with what I have on my PC. Which strategy is up to you.&lt;/p&gt;

&lt;h3 id=&#34;install-prestashop-with-amp-package:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Install Prestashop with AMP package&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Follow the instruction page within zip file.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;install-prestashop-without-amp-package:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Install Prestashop without AMP package&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Unzip file to &lt;code&gt;path\to\prestashop_workspace&lt;/code&gt;. Your folder structure will look like this.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;path\to\prestashop_workspace
\---prestashop
    +---admin 
    +---cache 
    +---classes  
    +---config 
    +---controllers 
    +---css
    +---docs
    +---download
    +---img 
    +---install    
    +---js   
    +---localization
    +---log
    +---mails
    +---modules  
    +---override
    +---pdf
    +---themes
    +---tools 
    +---translations
    +---upload
    \---webservice
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Start your MySQL or check the status of MySQL&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use your MySQL client tool to connect to your MySQL server.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Launch installer page with php server&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Start a command prompt&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /path/to/prestashop_workspace
php -S 0.0.0.0:1234 -t prestashop
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Open the link &lt;code&gt;http://localhost:1234/install/index.php&lt;/code&gt; with browser, then you can start installation process.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Choose language and click &lt;code&gt;Next&lt;/code&gt;, and then select the checkbox &amp;ldquo;I agree bah lah bah lah &amp;hellip;. &amp;rdquo; and click &lt;code&gt;Next&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If there is an error &lt;code&gt;GD Library is not installed&lt;/code&gt; prompt, you just need to enable the library on &lt;code&gt;php.ini&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DO NOT close your browser.&lt;/li&gt;
&lt;li&gt;Stop the php server by &lt;code&gt;Ctrl + C&lt;/code&gt; in the command prompt.&lt;/li&gt;
&lt;li&gt;Use notepad to open the file &lt;code&gt;php.ini&lt;/code&gt; under the &lt;code&gt;\path\to\php&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Uncomment the config &lt;code&gt;;extension=php_gd2.dll&lt;/code&gt; =&amp;gt; &lt;code&gt;extension=php_gd2.dll&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Start the php server again&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Click the &lt;code&gt;Refresh this settings&lt;/code&gt;, and click &lt;code&gt;Next&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Fill the login user and password. If your MySQL port is not 3306, please attach your port to the server address input field. Click &lt;code&gt;Test your database connection&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you got error &lt;code&gt;prestashop database not found&lt;/code&gt;, you need to create a database on mysql server.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I simply create a new database immediately with one command line&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE prestashop CHAR SET utf8 COLLATE &#39;utf8_unicode_ci&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Test the connection again. You will get the green light&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Click &lt;code&gt;Next&lt;/code&gt; and you can start to setup your store informaiton, such as, store name, admin account, etc. Then click &lt;code&gt;Next&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Setup your sample store. Click &lt;code&gt;Next&lt;/code&gt;. Then the installer will help you finish the initialization.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After the store setup, you can access the website by clicking &lt;code&gt;Font site&lt;/code&gt;, but you can not access back office, as known as admin panel.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Don&amp;rsquo;t panic. It is easy to fix. Stop the php server by clicking &lt;code&gt;Ctrl+C&lt;/code&gt;, and delete the folder &lt;code&gt;install&lt;/code&gt; under the root, and then start the server again. Open the folder with prestashop, you will find something interesting. The original folder &lt;code&gt;admin&lt;/code&gt; under &lt;code&gt;prestashop&lt;/code&gt; has been renamed to &lt;code&gt;adminXXXX&lt;/code&gt;. X is a number. It is Prestashop special trick to secure your admin folder. Now you need to use this new name as path to acces back office. Your new back office link will be &lt;code&gt;http://localhost:1234/adminXXXX&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Open the new link in browser and type in your admin id and password. Now you can start managing your Prestashop site. Enjoy it.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;forgot-admin-s-password:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Forgot admin&amp;rsquo;s password&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Forgot admin&amp;rsquo;s password or somehow you have to reset password and you cannot get admin&amp;rsquo;s password from previous adminstrator. For such case, there is a simple way to update admin&amp;rsquo;s password from database.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tailor the SQL below. Then you should be able to use new password to login.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UPDATE ps_employee SET passwd = MD5(&#39;&amp;lt;_COOKIE_KEY_&amp;gt;password&#39;) 
WHERE ps_employee.id_employee = &amp;lt;ID_EMPLOYEE&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;troubleshooting-1:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Troubleshooting&lt;/h3&gt;

&lt;h4 id=&#34;innodb-error:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;InnoDB error&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Error : InnoDB is not supported by your MySQL server&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;You got error because Prestashop 1.5 is not working properly with MySQL 5.4 and later.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Update files &lt;code&gt;DbPDO.php&lt;/code&gt; , &lt;code&gt;MySQL.php&lt;/code&gt; and &lt;code&gt;DbMySQLi.php&lt;/code&gt; as follow.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;    // $sql = &#39;SHOW VARIABLES WHERE Variable_name = \&#39;have_innodb\&#39;&#39;;
    $sql = &amp;quot;SELECT SUPPORT FROM INFORMATION_SCHEMA.ENGINES WHERE ENGINE LIKE &#39;INNO%&#39;&amp;quot;;

    ...
    
    // if (!$row || strtolower($row[&#39;Value&#39;]) != &#39;yes&#39;)
    if (!$row || strtolower($row[&#39;Value&#39;]) === &#39;no&#39;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Restart the server and the proble will be fixed.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;cors:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;CORS&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Enable module header in &lt;code&gt;httpd.conf&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add header settings&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-apache&#34;&gt;Header always set Access-Control-Max-Age &amp;quot;1000&amp;quot;
Header always set Access-Control-Allow-Headers &amp;quot;X-Requested-With, Content-Type, Origin, Authorization, Accept, Client-Security-Token, Accept-Encoding&amp;quot;
Header always set Access-Control-Allow-Methods &amp;quot;POST, GET, OPTIONS, DELETE, PUT&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;too-big-header-file:9c95d1586cd4a8e32b4eac2909854bcf&#34;&gt;Too big header file&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Add this to your &lt;code&gt;http {}&lt;/code&gt; of the nginx.conf file normally located at &lt;code&gt;/etc/nginx/nginx.conf&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;proxy_buffer_size   128k;
proxy_buffers   4 256k;
proxy_busy_buffers_size   256k;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Then add this to your php location block, this will be located in your vhost file look for the block that begins with &lt;code&gt;location ~ .php$ {&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;fastcgi_buffer_size 128k;
fastcgi_buffers 4 256k;
fastcgi_busy_buffers_size 256k;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Build mobile app with web dev skills</title>
      <link>https://harryho.github.io/dev/build-mobile-app/</link>
      <pubDate>Sun, 10 Jul 2016 14:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/dev/build-mobile-app/</guid>
      <description>

&lt;h2 id=&#34;what-is-mobile-app:7763377c79f2909e623417a662d8bab1&#34;&gt;What is mobile app&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;A mobile application, basically, is a computer generated program designed and developed to run on iPhone, Android Smartphone, and many other mobile devices. In a nutshell, there are three types of apps&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Native apps&lt;/strong&gt; are specific to a given mobile platform (iOS or Android) using the development tools and language that the respective platform. Usaully it looks and performs the best.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;HTML5 apps&lt;/strong&gt; use standard web technologies—typically HTML5, JavaScript and CSS. This write-once-run-anywhere approach to mobile development creates cross-platform mobile applications that work on multiple devices.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Hybrid apps&lt;/strong&gt; make it possible to embed HTML5 apps inside a thin native container, combining the good parts of &lt;strong&gt;Native app&lt;/strong&gt; and &lt;strong&gt;HTML5 app&lt;/strong&gt; elements.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;mobile-app-development:7763377c79f2909e623417a662d8bab1&#34;&gt;Mobile app development&lt;/h2&gt;

&lt;p&gt;According above breif history we can image the mobile developer community has become asfragmented as the market. Mobile software developers work with different programming environments, different tools, and different programming languages.&lt;/p&gt;

&lt;p&gt;After a few years of improvement, we can see some &lt;strong&gt;Hybrid app&lt;/strong&gt; based framework becomes more and more popular and shining. &lt;code&gt;ionic&lt;/code&gt;, &lt;code&gt;nativescript&lt;/code&gt; and &lt;code&gt;react native&lt;/code&gt; are most promising frameworks which we should really look into.&lt;/p&gt;

&lt;h2 id=&#34;introduction-of-ionic-developement:7763377c79f2909e623417a662d8bab1&#34;&gt;Introduction of ionic developement&lt;/h2&gt;

&lt;h3 id=&#34;assumption:7763377c79f2909e623417a662d8bab1&#34;&gt;Assumption&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Here we just introduce ionic 1.x. When I started investigating the &lt;code&gt;ionic&lt;/code&gt;, the &lt;code&gt;ionic 2&lt;/code&gt; just came out for a while. &lt;code&gt;ionic 2&lt;/code&gt; study is on my todo list.&lt;/li&gt;
&lt;li&gt;You are familiar with web technologies, such as, HTML5, CSS, JavaScript, and you should have experience of nodejs and relevant skills.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;getting-started:7763377c79f2909e623417a662d8bab1&#34;&gt;Getting started&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;install ionic 1.x&lt;/li&gt;
&lt;li&gt;setup ionic and create new project &lt;code&gt;demoApp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;ionic start demoApp slidemenu
cd demoApp
ionic platform add android 
ionic build android 
ionic emulate android 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;install-packages:7763377c79f2909e623417a662d8bab1&#34;&gt;Install packages&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;npm install&lt;/code&gt; to install packages&lt;/li&gt;
&lt;li&gt;Folllowing is the &lt;code&gt;package.json&lt;/code&gt;. You can tailor it on your own.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;ionic-project&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;An Ionic project&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;gulp&amp;quot;: &amp;quot;^3.5.6&amp;quot;,
    &amp;quot;gulp-sass&amp;quot;: &amp;quot;^2.0.4&amp;quot;,
    &amp;quot;gulp-concat&amp;quot;: &amp;quot;^2.2.0&amp;quot;,
    &amp;quot;gulp-minify-css&amp;quot;: &amp;quot;^0.3.0&amp;quot;,
    &amp;quot;gulp-rename&amp;quot;: &amp;quot;^1.2.0&amp;quot;
  },
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;bower&amp;quot;: &amp;quot;^1.3.3&amp;quot;,
    &amp;quot;gulp-util&amp;quot;: &amp;quot;^2.2.14&amp;quot;,
    &amp;quot;shelljs&amp;quot;: &amp;quot;^0.3.0&amp;quot;
  },
  &amp;quot;cordovaPlugins&amp;quot;: [
    &amp;quot;cordova-plugin-device&amp;quot;,
    &amp;quot;cordova-plugin-console&amp;quot;,
    &amp;quot;cordova-plugin-whitelist&amp;quot;,
    &amp;quot;cordova-plugin-splashscreen&amp;quot;,
    &amp;quot;cordova-plugin-statusbar&amp;quot;,
    &amp;quot;ionic-plugin-keyboard&amp;quot;
  ],
  &amp;quot;cordovaPlatforms&amp;quot;: []
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;debug:7763377c79f2909e623417a662d8bab1&#34;&gt;Debug&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Browser is the best option for ionic mobile development debug tools&lt;/li&gt;
&lt;li&gt;Use Telerik AppBuilder to debug&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;test-on-emulator-or-device:7763377c79f2909e623417a662d8bab1&#34;&gt;Test on emulator or device&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Android&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Download and install &lt;a href=&#34;https://developer.android.com/studio/index.html#downloads&#34;&gt;Android SDK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Download install at least one sdk platform.&lt;/li&gt;
&lt;li&gt;ionic only support Android 4.1.x or later, so you are better to install any sdk platform version 18+.&lt;/li&gt;
&lt;li&gt;install x86 or x86_64 image for windows environment&lt;/li&gt;
&lt;li&gt;install Extra plugins: Google USB driver, X86 Emulator Accelerator&lt;/li&gt;
&lt;li&gt;Create AVD for your mobile app testing&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iPhone&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Install AppBuilder on Visual Studio&lt;/li&gt;
&lt;li&gt;Install Genymotion&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;troubleshooting:7763377c79f2909e623417a662d8bab1&#34;&gt;Troubleshooting&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Android emulator accelerator error due to version is too low to support the system image&lt;/li&gt;
&lt;li&gt;uninstall old version intel HAXM&lt;/li&gt;

&lt;li&gt;&lt;p&gt;install new version manually from &lt;code&gt;&amp;lt;Android_SDK_Location&amp;gt;\extras\intel\Hardware_Accelerated_Execution_Manager&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If app is not working on emulator, check cordova plugins or manually install cordova plugins&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ionic plugins list&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ionic plugins add XXXXX&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>DIP3 Notes</title>
      <link>https://harryho.github.io/cache/python/dip3-notes/</link>
      <pubDate>Sun, 10 Apr 2016 14:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/cache/python/dip3-notes/</guid>
      <description>

&lt;p&gt;This document was created with Prince, a great way of getting web content onto paper.&lt;/p&gt;

&lt;p&gt;CHAPTER -1. WHAT’S NEW IN “DIVE INTO PYTHON 3”&lt;/p&gt;

&lt;p&gt;. Isn’t this where we came in? .
— Pink Floyd, The Wall
-1.1. A.K.A. “THE MINUS LEVEL”&lt;/p&gt;

&lt;p&gt;Are you already a Python programmer? Did you read the original “Dive Into Python”? Did you buy it on paper? (If so, thanks!) Are you ready to take the plunge into Python 3? … If so, read on. (If none of that is true, you’d be better off starting at the beginning.) Python 3 comes with a script called 2to3. Learn it. Love it. Use it. Porting Code to Python 3 with 2to3 is a reference of all the things that the 2to3 tool can fix automatically. Since a lot of those things are syntax changes, it’s a good starting point to learn about a lot of the syntax changes in Python 3. (print is now a function, &lt;code&gt;x&lt;/code&gt; doesn’t work, &amp;amp;c.)&lt;/p&gt;

&lt;p&gt;Case Study:
Porting chardet to Python 3 documents my (ultimately successful) effort to port a non-trivial library from Python 2 to Python 3. It may help you; it may not. There’s a fairly steep learning curve, since you need to kind of understand the library first, so you can understand why it broke and how I fixed it. A lot of the breakage centers around strings. Speaking of which… Strings. Whew. Where to start. Python 2 had “strings” and “Unicode strings.” Python 3 has “bytes” and “strings.” That is, all strings are now Unicode strings, and if you want to deal with a bag of bytes, you use the new bytes type. Python 3 will never implicitly convert between strings and bytes, so if you’re not sure which one you have at any given moment, your code will almost certainly break. Read the Strings chapter for more details.&lt;/p&gt;

&lt;p&gt;Bytes vs. strings comes up again and again throughout the book.&lt;/p&gt;

&lt;p&gt;• In Files, you’ll learn the difference between reading files in “binary” and “text” mode. Reading (and writing!) files in text mode requires an encoding parameter. Some text file methods count characters, but other methods count bytes. If your code assumes that one character == one byte, it will break on multi-byte characters.&lt;/p&gt;

&lt;p&gt;• In HTTP Web Services, the httplib2 module fetches headers and data over HTTP. HTTP headers are returned as strings, but the HTTP body is returned as bytes.&lt;/p&gt;

&lt;p&gt;• In Serializing Python Objects, you’ll learn why the pickle module in Python 3 defines a new data format that is backwardly incompatible with Python 2. (Hint: it’s because of bytes and strings.) Also, Python 3 supports serializing objects to and from JSON, which doesn’t even have a bytes type. I’ll show you how to hack around that.&lt;/p&gt;

&lt;p&gt;• In Case study: porting chardet to Python 3, it’s just a bloody mess of bytes and strings everywhere.&lt;/p&gt;

&lt;p&gt;Even if you don’t care about Unicode (oh but you will), you’ll want to read about string formatting in Python 3, which is completely different from Python 2. Iterators are everywhere in Python 3, and I understand them a lot better than I did five years ago when I wrote “Dive Into Python”. You need to understand them too, because lots of functions that used to return lists in Python 2 will now return iterators in Python 3. At a minimum, you should read the second half of the Iterators chapter and the second half of the Advanced Iterators chapter. By popular request, I’ve added an appendix on Special Method Names, which is kind of like the Python docs “Data Model” chapter but with more snark. When I was writing “Dive Into Python”, all of the available XML libraries sucked. Then Fredrik Lundh wrote ElementTree, which doesn’t suck at all. The Python gods wisely incorporated ElementTree into the standard library, and now it forms the basis for my new XML chapter. The old ways of parsing XML are still around, but you should avoid them, because they suck! Also new in Python — not in the language but in the community — is the emergence of code repositories like The Python Package Index (PyPI). Python comes with utilities to package your code in standard formats and distribute those packages on PyPI. Read Packaging Python Libraries for details.&lt;/p&gt;

&lt;p&gt;CHAPTER 0. INSTALLING PYTHON&lt;/p&gt;

&lt;p&gt;. Tempora mutantur nos et mutamur in illis. (Times change, and we change with them.) .
— ancient Roman proverb&lt;/p&gt;

&lt;p&gt;0.1. DIVING IN
Before you can start programming in Python 3, you need to install it. Or do you?&lt;/p&gt;

&lt;p&gt;0.2. WHICH PYTHON IS RIGHT FOR YOU?&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re using an account on a hosted server, your ISP may have already installed Python 3. If you’re running Linux at home, you may already have Python 3, too. Most popular GNU/Linux distributions come with Python 2 in the default installation; a small but growing number of distributions also include Python 3. Mac OS X includes a command-line version of Python 2, but as of this writing it does not include Python 3. Microsoft Windows does not come with any version of Python. But don’t despair! You can point-and-click your way through installing Python, regardless of what operating system you have.&lt;/p&gt;

&lt;p&gt;The easiest way to check for Python 3 on your Linux or Mac OS X system is from the command line. Once you’re at a command line prompt, just type python3 (all lowercase, no spaces), press ENTER, and see what happens. On my home Linux system, Python 3.1 is already installed, and this command gets me into the Python interactive shell.
mark@atlantis:~$ python3
Python 3.1 (r31:73572, Jul 28 2009, 06:52:23)
[GCC 4.2.4 (Ubuntu 4.2.4-1ubuntu4)] on linux2
Type &amp;ldquo;help&amp;rdquo;, &amp;ldquo;copyright&amp;rdquo;, &amp;ldquo;credits&amp;rdquo; or &amp;ldquo;license&amp;rdquo; for more information.
&amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;(Type exit() and press ENTER to exit the Python interactive shell.)
My web
hosting
provider
also runs Linux and provides command-line access, but my server does not have Python 3 installed. (Boo!)
mark@manganese:~$ python3
bash: python3: command not found&lt;/p&gt;

&lt;p&gt;So back to the question that started this section, “Which Python is right for you?” Whichever one runs on the computer you already have.
[Read on for Windows instructions, or skip to Installing on Mac OS X, Installing on Ubuntu Linux, or Installing on Other Platforms.]&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;0.3. INSTALLING ON MICROSOFT WINDOWS
Windows comes in two architectures these days: 32-bit and 64-bit. Of course, there are lots of different versions of Windows — XP, Vista, Windows 7 — but Python runs on all of them. The more important distinction is 32-bit v. 64-bit. If you have no idea what architecture you’re running, it’s probably 32-bit.
Visit python.org/download/ and download the appropriate Python 3 Windows installer for your
architecture. Your choices will look something like this:&lt;/p&gt;

&lt;p&gt;• Python 3.1 Windows installer (Windows binary — does not include source)&lt;/p&gt;

&lt;p&gt;• Python 3.1 Windows AMD64 installer (Windows AMD64 binary — does not include source)&lt;/p&gt;

&lt;p&gt;I don’t want to include direct download links here, because minor updates of Python happen all the time and I don’t want to be responsible for you missing important updates. You should always install the most recent version of Python 3.x unless you have some esoteric reason not to.&lt;/p&gt;

&lt;p&gt;Once your download is complete, double-click the .msi file. Windows will pop up a security alert, since you’re about to be running executable code. The official Python installer is digitally signed by the Python Software Foundation, the non-profit corporation that oversees Python development. Don’t accept imitations! Click the Run button to launch the Python 3 installer.&lt;/p&gt;

&lt;p&gt;The first question the installer will ask you is whether you want to install Python 3 for all users or just for you. The default choice is “install for all users,” which is the best choice unless you have a good reason to choose otherwise. (One possible reason why you would want to “install just for me” is that you are installing Python on your company’s computer and you don’t have administrative rights on your Windows account. But then,   why are you installing Python without permission from your company’s Windows administrator? Don’t get me in trouble here!)&lt;/p&gt;

&lt;p&gt;Click the Next button to accept your choice of installation type.
Next, the installer will prompt you to choose a destination directory. The default for all versions of Python 3.1.x is C:\Python31\, which should work well for most users unless you have a specific reason to change it. If you maintain a separate drive letter for installing applications, you can browse to it using the embedded controls, or simply type the pathname in the box below. You are not limited to installing Python on the C: drive; you can install it on any drive, in any folder.&lt;/p&gt;

&lt;p&gt;Click the Next button to accept your choice of destination directory.&lt;/p&gt;

&lt;p&gt;The next page looks complicated, but it’s not really. Like many installers, you have the option not to install every single component of Python 3. If disk space is especially tight, you can exclude certain components.&lt;/p&gt;

&lt;p&gt;. Register Extensions allows you to double-click Python scripts (.py files) and run them. Recommended but not required. (This option doesn’t require any disk space, so there is little point in excluding it.)&lt;/p&gt;

&lt;p&gt;. Tcl/Tk is the graphics library used by the Python Shell, which you will use throughout this book. I strongly recommend keeping this option.&lt;/p&gt;

&lt;p&gt;. Documentation installs a help file that contains much of the information on docs.python.org. Recommended if you are on dialup or have limited Internet access.&lt;/p&gt;

&lt;p&gt;. Utility Scripts includes the 2to3.py script which you’ll learn about later in this book. Required if you want to learn about migrating existing Python 2 code to Python 3. If you have no existing Python 2 code, you can skip this option.&lt;/p&gt;

&lt;p&gt;. Test Suite is a collection of scripts used to test the Python interpreter itself. We will not use it in this book, nor have I ever used it in the course of programming in Python. Completely optional.&lt;/p&gt;

&lt;p&gt;If you’re unsure how much disk space you have, click the Disk Usage button. The installer will list your drive letters, compute how much space is available on each drive, and calculate how much would be left after installation.
Click the OK button to return to the “Customizing Python” page.&lt;/p&gt;

&lt;p&gt;If you decide to exclude an option, select the drop-down button before the option and select “Entire feature will be unavailable.” For example, excluding the test suite will save you a whopping 7908KB of disk space.
Click the Next button to accept your choice of options.&lt;/p&gt;

&lt;p&gt;The installer will copy all the necessary files to your chosen destination directory. (This happens so quickly, I had to try it three times to even get a screenshot of it!)&lt;/p&gt;

&lt;p&gt;Click the Finish button to exit the installer.&lt;/p&gt;

&lt;p&gt;Start menu, there should be a new item called Python 3.1. Within that, there is a program called IDLE. Select this item to run the interactive Python Shell.
[Skip to using the Python Shell]&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;0.4. INSTALLING ON MAC OS X
All modern Macintosh computers use the Intel chip (like most Windows PCs). Older Macs used PowerPC chips. You don’t need to understand the difference, because there’s just one Mac Python installer for all Macs.
Visit python.org/download/ and download the Mac installer. It will be called something like Python 3.1 Mac Installer Disk Image, although the version number may vary. Be sure to download version 3.x, not 2.x.&lt;/p&gt;

&lt;p&gt;Your browser should automatically mount the disk image and open a Finder window to show you the contents. (If this doesn’t happen, you’ll need to find the disk image in your downloads folder and double-click to mount it. It will be named something like python-3.1.dmg.) The disk image contains a number of text files (Build.txt, License.txt, ReadMe.txt), and the actual installer package, Python.mpkg.
Double-click the Python.mpkg installer package to launch the Mac Python installer.&lt;/p&gt;

&lt;p&gt;Click the
Continue&lt;/p&gt;

&lt;p&gt;button to move along.&lt;/p&gt;

&lt;p&gt;upgrade.
Apple no
longer provides security updates for your operating system, and your computer is probably at risk if you
ever go online. Also, you can’t run Python 3.&lt;/p&gt;

&lt;p&gt;Click the Continue button to advance.&lt;/p&gt;

&lt;p&gt;Python has had a number of owners and sponsors throughout its history, each of which has left its mark on the software license. But the end result is this: Python is open source, and you may use it on any platform, for any purpose, without fee or obligation of reciprocity.
Click the Continue button once again.&lt;/p&gt;

&lt;p&gt;source, you are really “agreeing” that the license is granting you additional rights, rather than taking them away.
Click the Agree button to continue.&lt;/p&gt;

&lt;p&gt;In truth, I have never had the need to change the install location.
From this screen, you can also customize the installation to exclude certain features. If you want to do this, click the Customize button; otherwise click the Install button.&lt;/p&gt;

&lt;p&gt;Framework. This is the guts of Python, and is both selected and disabled because it must be installed.&lt;/p&gt;

&lt;p&gt;. GUI Applications includes IDLE, the graphical Python Shell which you will use throughout this book. I strongly recommend keeping this option selected.&lt;/p&gt;

&lt;p&gt;. UNIX command-line tools includes the command-line python3 application. I strongly recommend keeping this option, too.&lt;/p&gt;

&lt;p&gt;. Python Documentation contains much of the information on docs.python.org. Recommended if you are on dialup or have limited Internet access.&lt;/p&gt;

&lt;p&gt;. Shell profile updater controls whether to update your shell profile (used in Terminal.app) to ensure that this version of Python is on the search path of your shell. You probably don’t need to change this.&lt;/p&gt;

&lt;p&gt;. Fix system Python should not be changed. (It tells your Mac to use Python 3 as the default Python for all scripts, including built-in system scripts from Apple. This would be very bad, since most of those scripts are written for Python 2, and they would fail to run properly under Python 3.)&lt;/p&gt;

&lt;p&gt;Click the Install button to continue.&lt;/p&gt;

&lt;p&gt;administrative password. There is no way to install Mac Python without administrator privileges. Click the OK button to begin the installation.&lt;/p&gt;

&lt;p&gt;Click the Close button to exit the installer.
Assuming you didn’t change the install location, you can find the newly installed files in the Python 3.1 folder within your /Applications folder. The most important piece is IDLE, the graphical Python Shell.
Double-click IDLE to launch the Python Shell.&lt;/p&gt;

&lt;p&gt;The Python Shell is where you will spend most of your time exploring Python. Examples throughout this book will assume that you can find your way into the Python Shell.
[Skip to using the Python Shell]&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;0.5. INSTALLING ON UBUNTU LINUX
Modern Linux distributions are backed by vast repositories of precompiled applications, ready to install. The exact details vary by distribution. In Ubuntu Linux, the easiest way to install Python 3 is through the Add/ Remove application in your Applications menu.&lt;/p&gt;

&lt;p&gt;When you first launch the Add/Remove application, it will show you a list of preselected applications in different categories. Some are already installed; most are not. Because the repository contains over 10,000 applications, there are different filters you can apply to see small parts of the repository. The default filter is “Canonical-maintained applications,” which is a small subset of the total number of applications that are officially supported by Canonical, the company that creates and maintains Ubuntu Linux.&lt;/p&gt;

&lt;p&gt;Python 3 is not maintained by Canonical, so the first step is to drop down this filter menu and select “All
Open Source applications.”&lt;/p&gt;

&lt;p&gt;Once you’ve widened the filter to include all open source applications, use the Search box immediately after the filter menu to search for Python 3.&lt;/p&gt;

&lt;p&gt;Now the list of applications narrows to just those matching Python 3. You’re going to check two packages. The first is Python (v3.0). This contains the Python interpreter itself.&lt;/p&gt;

&lt;p&gt;The second package you want is immediately above: IDLE (using Python-3.0). This is a graphical Python Shell that you will use throughout this book.
After you’ve checked those two packages, click the Apply Changes button to continue.&lt;/p&gt;

&lt;p&gt;Python-3.0) and Python (v3.0).
Click the Apply button to continue.
The package manager will show you a progress meter while it downloads the necessary packages from Canonical’s Internet repository.&lt;/p&gt;

&lt;p&gt;Once the packages are downloaded, the package manager will automatically begin installing them.&lt;/p&gt;

&lt;p&gt;Python Shell, or
click the Close button to exit the package manager.&lt;/p&gt;

&lt;p&gt;You can always relaunch the Python Shell by going to your Applications menu, then the Programming
submenu, and selecting IDLE.&lt;/p&gt;

&lt;p&gt;Python Shell is where you will spend most of your time exploring Python. Examples throughout this book will assume that you can find your way into the Python Shell.
[Skip to using the Python Shell]&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;0.6. INSTALLING ON OTHER PLATFORMS&lt;/p&gt;

&lt;p&gt;Python 3 is available on a number of different platforms. In particular, it is available in virtually every Linux, BSD, and Solaris-based distribution. For example, RedHat Linux uses the yum package manager. FreeBSD has its ports
and
packages
collection, SUSE has zypper, and Solaris has pkgadd. A quick web search for Python 3 + your operating system should tell you whether a Python 3 package is available, and if so, how to install it.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;0.7. USING THE PYTHON SHELL
The Python Shell is where you can explore Python syntax, get interactive help on commands, and debug short programs. The graphical Python Shell (named IDLE) also contains a decent text editor that supports Python syntax coloring and integrates with the Python Shell. If you don’t already have a favorite text editor, you should give IDLE a try.
First things first. The Python Shell itself is an amazing interactive playground. Throughout this book, you’ll see examples like this:
&amp;gt;&amp;gt;&amp;gt; 1 + 1
2&lt;/p&gt;

&lt;p&gt;The three angle brackets, &amp;gt;&amp;gt;&amp;gt;, denote the Python Shell prompt. Don’t type that part. That’s just to let you know that this example is meant to be followed in the Python Shell.
1+1 is the part you type. You can type any valid Python expression or command in the Python Shell. Don’t be shy; it won’t bite! The worst that will happen is you’ll get an error message. Commands get executed immediately (once you press ENTER); expressions get evaluated immediately, and the Python Shell prints out the result.
2 is the result of evaluating this expression. As it happens, 1+1 is a valid Python expression. The result, of course, is 2.
Let’s try another one.
&amp;gt;&amp;gt;&amp;gt; print(&amp;lsquo;Hello world!&amp;rsquo;)
Hello world!&lt;/p&gt;

&lt;p&gt;Pretty simple, no? But there’s lots more you can do in the Python shell. If you ever get stuck — you can’t remember a command, or you can’t remember the proper arguments to pass a certain function — you can get interactive help in the Python Shell. Just type help and press ENTER.
&amp;gt;&amp;gt;&amp;gt; help
Type help() for interactive help, or help(object) for help about object.&lt;/p&gt;

&lt;p&gt;There are two modes of help. You can get help about a single object, which just prints out the documentation and returns you to the Python Shell prompt. You can also enter help mode, where instead of evaluating Python expressions, you just type keywords or command names and it will print out whatever it knows about that command.
To enter the interactive help mode, type help() and press ENTER.
&amp;gt;&amp;gt;&amp;gt; help()
Welcome to Python 3.0! This is the online help utility.&lt;/p&gt;

&lt;p&gt;If this is your first time using Python, you should definitely check out
the tutorial on the Internet at &lt;a href=&#34;http://docs.python.org/tutorial/&#34;&gt;http://docs.python.org/tutorial/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules. To quit this help utility and
return to the interpreter, just type &amp;ldquo;quit&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;To get a list of available modules, keywords, or topics, type &amp;ldquo;modules&amp;rdquo;,
&amp;ldquo;keywords&amp;rdquo;, or &amp;ldquo;topics&amp;rdquo;. Each module also comes with a one-line summary
of what it does; to list the modules whose summaries contain a given word
such as &amp;ldquo;spam&amp;rdquo;, type &amp;ldquo;modules spam&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;help&amp;gt;&lt;/p&gt;

&lt;p&gt;Note how the prompt changes from &amp;gt;&amp;gt;&amp;gt; to help&amp;gt;. This reminds you that you’re in the interactive help mode. Now you can enter any keyword, command, module name, function name — pretty much anything Python understands — and read documentation on it.
help&amp;gt; print . Help on built-in function print in module builtins:
print(&amp;hellip;)
print(value, &amp;hellip;, sep=&amp;rsquo; &amp;lsquo;, end=&amp;rsquo;\n&amp;rsquo;, file=sys.stdout)&lt;/p&gt;

&lt;p&gt;Prints the values to a stream, or to sys.stdout by default.
Optional keyword arguments:
file: a file-like object (stream); defaults to the current sys.stdout.
sep: string inserted between values, default a space.
end: string appended after the last value, default a newline.&lt;/p&gt;

&lt;p&gt;help&amp;gt; PapayaWhip . no Python documentation found for &amp;lsquo;PapayaWhip&amp;rsquo;
help&amp;gt; quit  .
You are now leaving help and returning to the Python interpreter.
If you want to ask for help on a particular object directly from the
interpreter, you can type &amp;ldquo;help(object)&amp;rdquo;. Executing &amp;ldquo;help(&amp;lsquo;string&amp;rsquo;)&amp;rdquo;
has the same effect as typing a particular string at the help&amp;gt; prompt.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;. 
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;To get documentation on the print() function, just type print and press ENTER. The interactive help mode will display something akin to a man page: the function name, a brief synopsis, the function’s arguments and their default values, and so on. If the documentation seems opaque to you, don’t panic. You’ll learn more about all these concepts in the next few chapters.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Of course, the interactive help mode doesn’t know everything. If you type something that isn’t a Python command, module, function, or other built-in keyword, the interactive help mode will just shrug its virtual shoulders.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To quit the interactive help mode, type quit and press ENTER.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The prompt changes back to &amp;gt;&amp;gt;&amp;gt; to signal that you’ve left the interactive help mode and returned to the Python Shell.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;IDLE, the graphical Python Shell, also includes a Python-aware text editor.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;0.8. PYTHON EDITORS AND IDES
IDLE is not the only game in town when it comes to writing programs in Python. While it’s useful to get started with learning the language itself, many developers prefer other text editors or Integrated Development Environments (IDEs). I won’t cover them here, but the Python community maintains a
list
of
Python-aware
editors
that covers a wide range of supported platforms and software licenses.
You might also want to check out the list
of
Python-aware
IDEs, although few of them support Python 3 yet. One that does is PyDev, a plugin for Eclipse
that turns Eclipse into a full-fledged Python IDE. Both Eclipse and PyDev are cross-platform and open source.
On the commercial front, there is ActiveState’s Komodo
IDE. It has per-user licensing, but students can get a discount, and a free time-limited trial version is available.
I’ve been programming in Python for nine years, and I edit my Python programs in GNU
Emacs
and debug them in the command-line Python Shell. There’s no right or wrong way to develop in Python. Find a way that works for you!
CHAPTER 1. YOUR FIRST PYTHON PROGRAM&lt;/p&gt;

&lt;p&gt;. Don’t bury your burden in saintly silence. You have a problem? Great. Rejoice, dive in, and investigate. .
— Ven. Henepola Gunaratana&lt;/p&gt;

&lt;p&gt;1.1. DIVING IN
Convention dictates that I should bore you with the fundamental building blocks of programming, so we can slowly work up to building something useful. Let’s skip all that. Here is a complete, working Python program. It probably makes absolutely no sense to you. Don’t worry about that, because you’re going to dissect it line by line. But read through it first and see what, if anything, you can make of it.
SUFFIXES = {1000: [&amp;lsquo;KB&amp;rsquo;, &amp;lsquo;MB&amp;rsquo;, &amp;lsquo;GB&amp;rsquo;, &amp;lsquo;TB&amp;rsquo;, &amp;lsquo;PB&amp;rsquo;, &amp;lsquo;EB&amp;rsquo;, &amp;lsquo;ZB&amp;rsquo;, &amp;lsquo;YB&amp;rsquo;],&lt;/p&gt;

&lt;p&gt;1024: [&amp;lsquo;KiB&amp;rsquo;, &amp;lsquo;MiB&amp;rsquo;, &amp;lsquo;GiB&amp;rsquo;, &amp;lsquo;TiB&amp;rsquo;, &amp;lsquo;PiB&amp;rsquo;, &amp;lsquo;EiB&amp;rsquo;, &amp;lsquo;ZiB&amp;rsquo;, &amp;lsquo;YiB&amp;rsquo;]}&lt;/p&gt;

&lt;p&gt;def approximate_size(size, a_kilobyte_is_1024_bytes=True):
&amp;ldquo;&amp;lsquo;Convert a file size to human-readable form.&lt;/p&gt;

&lt;p&gt;Keyword arguments:
size &amp;ndash; file size in bytes
a_kilobyte_is_1024_bytes &amp;ndash; if True (default), use multiples of 1024&lt;/p&gt;

&lt;p&gt;if False, use multiples of 1000&lt;/p&gt;

&lt;p&gt;Returns: string&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;rsquo;
if size &amp;lt; 0:
raise ValueError(&amp;lsquo;number must be non-negative&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;multiple = 1024 if a_kilobyte_is_1024_bytes else 1000&lt;/p&gt;

&lt;p&gt;for suffix in SUFFIXES[multiple]:
size /= multiple
if size &amp;lt; multiple:&lt;/p&gt;

&lt;p&gt;return &amp;lsquo;{0:.1f} {1}&amp;lsquo;.format(size, suffix)&lt;/p&gt;

&lt;p&gt;raise ValueError(&amp;lsquo;number too large&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == &amp;lsquo;&lt;strong&gt;main&lt;/strong&gt;&amp;lsquo;:
print(approximate_size(1000000000000, False))
print(approximate_size(1000000000000))&lt;/p&gt;

&lt;p&gt;Now let’s run this program on the command line. On Windows, it will look something like this:
c:\home\diveintopython3\examples&amp;gt; c:\python31\python.exe humansize.py&lt;/p&gt;

&lt;p&gt;1.0 TB&lt;/p&gt;

&lt;p&gt;931.3 GiB&lt;/p&gt;

&lt;p&gt;On Mac OS X or Linux, it would look something like this:
you@localhost:~/diveintopython3/examples$ python3 humansize.py&lt;/p&gt;

&lt;p&gt;1.0 TB&lt;/p&gt;

&lt;p&gt;931.3 GiB&lt;/p&gt;

&lt;p&gt;What just happened? You executed your first Python program. You called the Python interpreter on the command line, and you passed the name of the script you wanted Python to execute. The script defines a single function, the approximate_size() function, which takes an exact file size in bytes and calculates a “pretty” (but approximate) size. (You’ve probably seen this in Windows Explorer, or the Mac OS X Finder, or Nautilus or Dolphin or Thunar on Linux. If you display a folder of documents as a multi-column list, it will display a table with the document icon, the document name, the size, type, last-modified date, and so on. If the folder contains a 1093-byte file named TODO, your file manager won’t display TODO 1093 bytes; it’ll say something like TODO 1 KB instead. That’s what the approximate_size() function does.)
Look at the bottom of the script, and you’ll see two calls to print(approximate_size(arguments)). These are function calls — first calling the approximate_size() function and passing a number of arguments, then taking the return value and passing it straight on to the print() function. The print() function is built-in; you’ll never see an explicit declaration of it. You can just use it, anytime, anywhere. (There are lots of built-in functions, and lots more functions that are separated into modules. Patience, grasshopper.)
So why does running the script on the command line give you the same output every time? We’ll get to that. First, let’s look at that approximate_size() function.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;1.2. DECLARING FUNCTIONS&lt;/p&gt;

&lt;p&gt;Python has functions like most other languages, but it does not have separate header files like C++ or interface/implementation sections like Pascal. When you need a function, just declare it, like this:
def approximate_size(size, a_kilobyte_is_1024_bytes=True):&lt;/p&gt;

&lt;p&gt;The keyword def starts the function declaration, followed by the function name, followed by the
arguments in parentheses. Multiple arguments are separated with commas.
Also note that the function doesn’t define a return datatype. Python functions do not specify the datatype of their return value; they don’t even specify whether or not they return a value. (In fact, every Python function returns a value; if the function ever executes a return statement, it will return that value, otherwise it will return None, the Python null value.)
. In some languages, functions (that return a value) start with function, and subroutines&lt;/p&gt;

&lt;p&gt;(that do not return a value) start with sub.
There are no subroutines in Python. Everything is a function, all functions return a
value (even if it’s None), and all functions start with def.&lt;/p&gt;

&lt;p&gt;The approximate_size() function takes the two arguments — size and a_kilobyte_is_1024_bytes — but neither argument specifies a datatype. In Python, variables are never explicitly typed. Python figures out what type a variable is and keeps track of it internally.
. In Java and other statically-typed languages, you must specify the datatype of the function return value and each function argument. In Python, you never explicitly specify the datatype of anything. Based on what value you assign, Python keeps track of the datatype internally.
1.2.1. OPTIONAL AND NAMED ARGUMENTS&lt;/p&gt;

&lt;p&gt;Python allows function arguments to have default values; if the function is called without the argument, the argument gets its default value. Furthermore, arguments can be specified in any order by using named arguments.
Let’s take another look at that approximate_size() function declaration:
def approximate_size(size, a_kilobyte_is_1024_bytes=True):&lt;/p&gt;

&lt;p&gt;The second argument, a_kilobyte_is_1024_bytes, specifies a default value of True. This means the argument is optional; you can call the function without it, and Python will act as if you had called it with True as a second parameter.
Now look at the bottom of the script:
if &lt;strong&gt;name&lt;/strong&gt; == &amp;lsquo;&lt;strong&gt;main&lt;/strong&gt;&amp;lsquo;:
print(approximate_size(1000000000000, False)) .
print(approximate_size(1000000000000)) .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This calls the approximate_size() function with two arguments. Within the approximate_size() function, a_kilobyte_is_1024_bytes will be False, since you explicitly passed False as the second argument.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This calls the approximate_size() function with only one argument. But that’s OK, because the second argument is optional! Since the caller doesn’t specify, the second argument defaults to True, as defined by the function declaration.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can also pass values into a function by name.
&amp;gt;&amp;gt;&amp;gt; from humansize import approximate_size
&amp;gt;&amp;gt;&amp;gt; approximate_size(4000, a_kilobyte_is_1024_bytes=False) .
&amp;lsquo;4.0 KB&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; approximate_size(size=4000, a_kilobyte_is_1024_bytes=False) .
&amp;lsquo;4.0 KB&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; approximate_size(a_kilobyte_is_1024_bytes=False, size=4000) .
&amp;lsquo;4.0 KB&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; approximate_size(a_kilobyte_is_1024_bytes=False, 4000) .&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1
SyntaxError: non-keyword arg after keyword arg&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;approximate_size(size=4000, False)  .
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1
SyntaxError: non-keyword arg after keyword arg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This calls the approximate_size() function with 4000 for the first argument (size) and False for the argument named a_kilobyte_is_1024_bytes. (That happens to be the second argument, but doesn’t matter, as you’ll see in a minute.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This calls the approximate_size() function with 4000 for the argument named size and False for the argument named a_kilobyte_is_1024_bytes. (These named arguments happen to be in the same order as the arguments are listed in the function declaration, but that doesn’t matter either.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This calls the approximate_size() function with False for the argument named a_kilobyte_is_1024_bytes and 4000 for the argument named size. (See? I told you the order didn’t matter.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This call fails, because you have a named argument followed by an unnamed (positional) argument, and that never works. Reading the argument list from left to right, once you have a single named argument, the rest of the arguments must also be named.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This call fails too, for the same reason as the previous call. Is that surprising? After all, you passed 4000 for the argument named size, then “obviously” that False value was meant for the a_kilobyte_is_1024_bytes argument. But Python doesn’t work that way. As soon as you have a named argument, all arguments to the right of that need to be named arguments, too.
.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1.3. WRITING READABLE CODE&lt;/p&gt;

&lt;p&gt;I won’t bore you with a long finger-wagging speech about the importance of documenting your code. Just know that code is written once but read many times, and the most important audience for your code is yourself, six months after writing it (i.e. after you’ve forgotten everything but need to fix something). Python makes it easy to write readable code, so take advantage of it. You’ll thank me in six months.
1.3.1. DOCUMENTATION STRINGS&lt;/p&gt;

&lt;p&gt;You can document a Python function by giving it a documentation string (docstring for short). In this program, the approximate_size() function has a docstring:
def approximate_size(size, a_kilobyte_is_1024_bytes=True):
&amp;ldquo;&amp;lsquo;Convert a file size to human-readable form.&lt;/p&gt;

&lt;p&gt;Keyword arguments:&lt;/p&gt;

&lt;p&gt;size &amp;ndash; file size in bytes&lt;/p&gt;

&lt;p&gt;a_kilobyte_is_1024_bytes &amp;ndash; if True (default), use multiples of 1024&lt;/p&gt;

&lt;p&gt;if False, use multiples of 1000&lt;/p&gt;

&lt;p&gt;Returns: string&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;Triple quotes signify a multi-line string. Everything between the start and end quotes is part of a single string, including carriage returns, leading white space, and other quote characters. You can use them anywhere, but you’ll see them most often used when defining a docstring.
.&lt;/p&gt;

&lt;p&gt;Triple quotes are also an easy way to define a string with both single and double quotes, like qq/&amp;hellip;/ in Perl 5.&lt;/p&gt;

&lt;p&gt;Everything between the triple quotes is the function’s docstring, which documents what the function does. A docstring, if it exists, must be the first thing defined in a function (that is, on the next line after the function declaration). You don’t technically need to give your function a docstring, but you always should. I know you’ve heard this in every programming class you’ve ever taken, but Python gives you an added incentive: the docstring is available at runtime as an attribute of the function.&lt;/p&gt;

&lt;p&gt;. Many Python IDEs use the docstring to provide context-sensitive documentation, so that when you type a function name, its docstring appears as a tooltip. This can be incredibly helpful, but it’s only as good as the docstrings you write.&lt;/p&gt;

&lt;p&gt;1.4. THE import SEARCH PATH
Before this goes any further, I want to briefly mention the library search path. Python looks in several places when you try to import a module. Specifically, it looks in all the directories defined in sys.path. This is just a list, and you can easily view it or modify it with standard list methods. (You’ll learn more about lists in Native
Datatypes.)
&amp;gt;&amp;gt;&amp;gt; import sys .
&amp;gt;&amp;gt;&amp;gt; sys.path .
[&amp;ldquo;,&lt;/p&gt;

&lt;p&gt;&amp;rsquo;/usr/lib/python31.zip&amp;rsquo;,
&amp;lsquo;/usr/lib/python3.1&amp;rsquo;,
&amp;lsquo;/usr/lib/python3.1/plat-linux2@EXTRAMACHDEPPATH@&amp;rsquo;,
&amp;lsquo;/usr/lib/python3.1/lib-dynload&amp;rsquo;,
&amp;lsquo;/usr/lib/python3.1/dist-packages&amp;rsquo;,
&amp;lsquo;/usr/local/lib/python3.1/dist-packages&amp;rsquo;]&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;sys .
&lt;module &#39;sys&#39; (built-in)&gt;
sys.path.insert(0, &amp;lsquo;/home/mark/diveintopython3/examples&amp;rsquo;) .
sys.path .
[&amp;lsquo;/home/mark/diveintopython3/examples&amp;rsquo;,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;rdquo;,
&amp;lsquo;/usr/lib/python31.zip&amp;rsquo;,
&amp;lsquo;/usr/lib/python3.1&amp;rsquo;,
&amp;lsquo;/usr/lib/python3.1/plat-linux2@EXTRAMACHDEPPATH@&amp;rsquo;,
&amp;lsquo;/usr/lib/python3.1/lib-dynload&amp;rsquo;,
&amp;lsquo;/usr/lib/python3.1/dist-packages&amp;rsquo;,
&amp;lsquo;/usr/local/lib/python3.1/dist-packages&amp;rsquo;]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Importing the sys module makes all of its functions and attributes available.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sys.path is a list of directory names that constitute the current search path. (Yours will look different, depending on your operating system, what version of Python you’re running, and where it was originally installed.) Python will look through these directories (in this order) for a .py file whose name matches what you’re trying to import.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Actually, I lied; the truth is more complicated than that, because not all modules are stored as .py files. Some are built-in modules; they are actually baked right into Python itself. Built-in modules behave just like regular modules, but their Python source code is not available, because they are not written in Python! (Like Python itself, these built-in modules are written in C.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can add a new directory to Python’s search path at runtime by adding the directory name to sys.path, and then Python will look in that directory as well, whenever you try to import a module. The effect lasts as long as Python is running.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;By using sys.path.insert(0, new_path), you inserted a new directory as the first item of the sys.path list, and therefore at the beginning of Python’s search path. This is almost always what you want. In case of naming conflicts (for example, if Python ships with version 2 of a particular library but you want to use version 3), this ensures that your modules will be found and used instead of the modules that came with Python.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.
1.5. EVERYTHING IS AN OBJECT
In case you missed it, I just said that Python functions have attributes, and that those attributes are available at runtime. A function, like everything else in Python, is an object.
Run the interactive Python shell and follow along:
&amp;gt;&amp;gt;&amp;gt; import humansize .
&amp;gt;&amp;gt;&amp;gt; print(humansize.approximate_size(4096, True)) .&lt;/p&gt;

&lt;p&gt;4.0 KiB
&amp;gt;&amp;gt;&amp;gt; print(humansize.approximate_size.&lt;strong&gt;doc&lt;/strong&gt;) .
Convert a file size to human-readable form.&lt;/p&gt;

&lt;p&gt;Keyword arguments:
size &amp;ndash; file size in bytes
a_kilobyte_is_1024_bytes &amp;ndash; if True (default), use multiples of 1024&lt;/p&gt;

&lt;p&gt;if False, use multiples of 1000&lt;/p&gt;

&lt;p&gt;Returns: string&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The first line imports the humansize program as a module — a chunk of code that you can use interactively, or from a larger Python program. Once you import a module, you can reference any of its public functions, classes, or attributes. Modules can do this to access functionality in other modules, and you can do it in the&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Python interactive shell too. This is an important concept, and you’ll see a lot more of it throughout this book.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;When you want to use functions defined in imported modules, you need to include the module name. So you can’t just say approximate_size; it must be humansize.approximate_size. If you’ve used classes in Java, this should feel vaguely familiar.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instead of calling the function as you would expect to, you asked for one of the function’s attributes, &lt;strong&gt;doc&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. import in Python is like require in Perl. Once you import a Python module, you access its functions with module.function; once you require a Perl module, you access its functions with module::function.
1.5.1. WHAT’S AN OBJECT?&lt;/p&gt;

&lt;p&gt;Everything in Python is an object, and everything can have attributes and methods. All functions have a built-in attribute &lt;strong&gt;doc&lt;/strong&gt;, which returns the docstring defined in the function’s source code. The sys module is an object which has (among other things) an attribute called path. And so forth.
Still, this doesn’t answer the more fundamental question: what is an object? Different programming languages define “object” in different ways. In some, it means that all objects must have attributes and methods; in others, it means that all objects are subclassable. In Python, the definition is looser. Some objects have neither attributes nor methods, but they could. Not all objects are subclassable. But everything is an object in the sense that it can be assigned to a variable or passed as an argument to a function.&lt;/p&gt;

&lt;p&gt;You may have heard the term “first-class object” in other programming contexts. In Python, functions are first-class objects. You can pass a function as an argument to another function. Modules are first-class objects. You can pass an entire module as an argument to a function. Classes are first-class objects, and individual instances of a class are also first-class objects.&lt;/p&gt;

&lt;p&gt;This is important, so I’m going to repeat it in case you missed it the first few times: everything in Python is an object. Strings are objects. Lists are objects. Functions are objects. Classes are objects. Class instances are objects. Even modules are objects.&lt;/p&gt;

&lt;p&gt;.
1.6. INDENTING CODE
Python functions have no explicit begin or end, and no curly braces to mark where the function code starts and stops. The only delimiter is a colon (:) and the indentation of the code itself.
def approximate_size(size, a_kilobyte_is_1024_bytes=True): .
if size &amp;lt; 0: .
raise ValueError(&amp;lsquo;number must be non-negative&amp;rsquo;) .
.&lt;/p&gt;

&lt;p&gt;multiple = 1024 if a_kilobyte_is_1024_bytes else 1000&lt;/p&gt;

&lt;p&gt;for suffix in SUFFIXES[multiple]: .
size /= multiple
if size &amp;lt; multiple:&lt;/p&gt;

&lt;p&gt;return &amp;lsquo;{0:.1f} {1}&amp;lsquo;.format(size, suffix)&lt;/p&gt;

&lt;p&gt;raise ValueError(&amp;lsquo;number too large&amp;rsquo;)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Code blocks are defined by their indentation. By “code block,” I mean functions, if statements, for loops, while loops, and so forth. Indenting starts a block and unindenting ends it. There are no explicit braces, brackets, or keywords. This means that whitespace is significant, and must be consistent. In this example, the function code is indented four spaces. It doesn’t need to be four spaces, it just needs to be consistent. The first line that is not indented marks the end of the function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In Python, an if statement is followed by a code block. If the if expression evaluates to true, the indented block is executed, otherwise it falls to the else block (if any). Note the lack of parentheses around the expression.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This line is inside the if code block. This raise statement will raise an exception (of type ValueError), but only if size &amp;lt; 0.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is not the end of the function. Completely blank lines don’t count. They can make the code more readable, but they don’t count as code block delimiters. The function continues on the next line.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The for loop also marks the start of a code block. Code blocks can contain multiple lines, as long as they are all indented the same amount. This for loop has three lines of code in it. There is no other special syntax for multi-line code blocks. Just indent and get on with your life.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After some initial protests and several snide analogies to Fortran, you will make peace with this and start seeing its benefits. One major benefit is that all Python programs look similar, since indentation is a language requirement and not a matter of style. This makes it easier to read and understand other people’s Python code.
. Python uses carriage returns to separate statements and a colon and indentation to separate code blocks. C++ and Java use semicolons to separate statements and curly braces to separate code blocks.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;1.7. EXCEPTIONS
Exceptions are everywhere in Python. Virtually every module in the standard Python library uses them, and Python itself will raise them in a lot of different circumstances. You’ll see them repeatedly throughout this book.
What is an exception? Usually it’s an error, an indication that something went wrong. (Not all exceptions are errors, but never mind that for now.) Some programming languages encourage the use of error return codes, which you check. Python encourages the use of exceptions, which you handle.
When an error occurs in the Python Shell, it prints out some details about the exception and how it happened, and that’s that. This is called an unhandled exception. When the exception was raised, there was no code to explicitly notice it and deal with it, so it bubbled its way back up to the top level of the Python Shell, which spits out some debugging information and calls it a day. In the shell, that&amp;rsquo;s no big deal, but if that happened while your actual Python program was running, the entire program would come to a screeching halt if nothing handles the exception. Maybe that’s what you want, maybe it isn’t.
. Unlike Java, Python functions don’t declare which exceptions they might raise. It’s up to you to determine what possible exceptions you need to catch.
An exception doesn’t need to result in a complete program crash, though. Exceptions can be handled. Sometimes an exception is really because you have a bug in your code (like accessing a variable that doesn’t exist), but sometimes an exception is something you can anticipate. If you’re opening a file, it might not exist. If you’re importing a module, it might not be installed. If you’re connecting to a database, it might be unavailable, or you might not have the correct security credentials to access it. If you know a line of code may raise an exception, you should handle the exception using a try&amp;hellip;except block.
. Python uses try&amp;hellip;except blocks to handle exceptions, and the raise statement to
generate them. Java and C++ use try&amp;hellip;catch blocks to handle exceptions, and the
throw statement to generate them.&lt;/p&gt;

&lt;p&gt;The approximate_size() function raises exceptions in two different cases: if the given size is larger than the function is designed to handle, or if it’s less than zero.
if size &amp;lt; 0:
raise ValueError(&amp;lsquo;number must be non-negative&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;The syntax for raising an exception is simple enough. Use the raise statement, followed by the exception name, and an optional human-readable string for debugging purposes. The syntax is reminiscent of calling a function. (In reality, exceptions are implemented as classes, and this raise statement is actually creating an instance of the ValueError class and passing the string &amp;lsquo;number must be non-negative&amp;rsquo; to its initialization method. But we’re
getting
ahead
of
ourselves!)
. You don’t need to handle an exception in the function that raises it. If one function
doesn’t handle it, the exception is passed to the calling function, then that function’s
calling function, and so on “up the stack.” If the exception is never handled, your
program will crash, Python will print a “traceback” to standard error, and that’s the&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;try&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;ry&lt;/dt&gt;
&lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;import chardet&lt;/p&gt;

&lt;p&gt;except
ImportError:&lt;/p&gt;

&lt;p&gt;chardet = None&lt;/p&gt;

&lt;p&gt;Later, you can check for the presence of the chardet module with a simple if statement:
if chardet:&lt;/p&gt;

&lt;h1 id=&#34;do-something:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;do something&lt;/h1&gt;

&lt;p&gt;else:&lt;/p&gt;

&lt;h1 id=&#34;continue-anyway:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continue anyway&lt;/h1&gt;

&lt;p&gt;Another common use of the ImportError exception is when two modules implement a common API, but one is more desirable than the other. (Maybe it’s faster, or it uses less memory.) You can try to import one module but fall back to a different module if the first import fails. For example, the
XML
chapter
talks about two modules that implement a common API, called the ElementTree API. The first, lxml, is a third-party module that you need to download and install yourself. The second, xml.etree.ElementTree, is slower but is part of the Python 3 standard library.
try:&lt;/p&gt;

&lt;p&gt;from lxml import etree
except ImportError:
import xml.etree.ElementTree as etree&lt;/p&gt;

&lt;p&gt;By the end of this try..except block, you have imported some module and named it etree. Since both modules implement a common API, the rest of your code doesn’t need to keep checking which module got imported. And since the module that did get imported is always called etree, the rest of your code doesn’t need to be littered with if statements to call differently-named modules.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;1.8. UNBOUND VARIABLES
Take another look at this line of code from the approximate_size() function:
multiple = 1024 if a_kilobyte_is_1024_bytes else 1000&lt;/p&gt;

&lt;p&gt;You never declare the variable multiple, you just assign a value to it. That’s OK, because Python lets you do that. What Python will not let you do is reference a variable that has never been assigned a value. Trying to do so will raise a NameError exception.
&amp;gt;&amp;gt;&amp;gt; x&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
NameError: name &amp;lsquo;x&amp;rsquo; is not defined&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;x = 1
x&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;You will thank Python for this one day.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;1.9. EVERYTHING IS CASE-SENSITIVE&lt;/p&gt;

&lt;p&gt;All names in Python are case-sensitive: variable names, function names, class names, module names, exception names. If you can get it, set it, call it, construct it, import it, or raise it, it’s case-sensitive.
&amp;gt;&amp;gt;&amp;gt; an_integer = 1
&amp;gt;&amp;gt;&amp;gt; an_integer&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;AN_INTEGER&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;NameError: name &amp;lsquo;AN_INTEGER&amp;rsquo; is not defined&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;An_Integer&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;NameError: name &amp;lsquo;An_Integer&amp;rsquo; is not defined&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;an_inteGer&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;NameError: name &amp;lsquo;an_inteGer&amp;rsquo; is not defined&lt;/p&gt;

&lt;p&gt;And so on.
.&lt;/p&gt;

&lt;p&gt;1.10. RUNNING SCRIPTS
Python modules are objects and have several useful attributes. You can use this to easily test your modules
as you write them, by including a special block of code that executes when you run the Python file on the command line. Take the last few lines of humansize.py:
if &lt;strong&gt;name&lt;/strong&gt; == &amp;lsquo;&lt;strong&gt;main&lt;/strong&gt;&amp;lsquo;:&lt;/p&gt;

&lt;p&gt;print(approximate_size(1000000000000, False))
print(approximate_size(1000000000000))&lt;/p&gt;

&lt;p&gt;. Like C, Python uses == for comparison and = for assignment. Unlike C, Python does not support in-line assignment, so there’s no chance of accidentally assigning the value you thought you were comparing.
So what makes this if statement special? Well, modules are objects, and all modules have a built-in attribute &lt;strong&gt;name&lt;/strong&gt;. A module’s &lt;strong&gt;name&lt;/strong&gt; depends on how you’re using the module. If you import the module, then &lt;strong&gt;name&lt;/strong&gt; is the module’s filename, without a directory path or file extension.
&amp;gt;&amp;gt;&amp;gt; import humansize
&amp;gt;&amp;gt;&amp;gt; humansize.&lt;strong&gt;name&lt;/strong&gt;
&amp;lsquo;humansize&amp;rsquo;&lt;/p&gt;

&lt;p&gt;But you can also run the module directly as a standalone program, in which case &lt;strong&gt;name&lt;/strong&gt; will be a special default value, &lt;strong&gt;main&lt;/strong&gt;. Python will evaluate this if statement, find a true expression, and execute the if code block. In this case, to print two values.&lt;br /&gt;
c:\home\diveintopython3&amp;gt; c:\python31\python.exe humansize.py 1.0 TB 931.3 GiB&lt;br /&gt;
And that’s your first Python program!&lt;br /&gt;
.&lt;br /&gt;
1.11. FURTHER READING&lt;br /&gt;
• • • •  PEP
257: Docstring Conventions explains what distinguishes a good docstring from a great docstring. Python Tutorial: Documentation Strings also touches on the subject. PEP 8: Style Guide for Python Code discusses good indentation style. Python Reference Manual explains what it means to say that everything in Python is an object, because some people are pedants and like to discuss that sort of thing at great length.&lt;/p&gt;

&lt;p&gt;CHAPTER 2. NATIVE DATATYPES&lt;/p&gt;

&lt;p&gt;.   Wonder is the foundation of all philosophy, inquiry its progress, ignorance its end. .
— Michel de Montaigne&lt;/p&gt;

&lt;p&gt;2.1. DIVING IN&lt;/p&gt;

&lt;p&gt;Datatypes. Set aside your first Python program for just a minute, and let’s talk about datatypes. In Python, every value has a
datatype, but you don’t need to declare the datatype of variables. How does that work? Based on each variable’s original assignment, Python figures out what type it is and keeps tracks of that internally.
Python has many native datatypes. Here are the important ones:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Booleans are either True or False.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Numbers can be integers (1 and 2), floats (1.1 and 1.2), fractions (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; and &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;), or even complex
numbers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Strings are sequences of Unicode characters, e.g. an HTML document.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bytes and byte arrays, e.g. a JPEG image file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lists are ordered sequences of values.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tuples are ordered, immutable sequences of values.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sets are unordered bags of values.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dictionaries are unordered bags of key-value pairs.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Of course, there are more types than these. Everything is an object in Python, so there are types like module, function, class, method, file, and even compiled code. You’ve already seen some of these: modules have names, functions have docstrings, &amp;amp;c. You’ll learn about classes in Classes &amp;amp;Iterators, and about files in Files.
Strings and bytes are important enough — and complicated enough — that they get their own chapter. Let’s look at the others first.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;2.2. BOOLEANS
Booleans are either true or false. Python has two constants, cleverly named True and False, which can be used to assign boolean values directly. Expressions can also evaluate to a boolean value. In certain places (like if statements), Python expects an expression to evaluate to a boolean value. These places are called boolean contexts. You can use virtually any expression in a boolean context, and Python will try to determine its truth value. Different datatypes have different rules about which values are true or false in a boolean context. (This will make more sense once you see some concrete examples later in this chapter.)
For example, take this snippet from humansize.py:
if size &amp;lt; 0:&lt;/p&gt;

&lt;p&gt;raise ValueError(&amp;lsquo;number must be non-negative&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;size is an integer, 0 is an integer, and &amp;lt; is a numerical operator. The result of the expression size &amp;lt; 0 is always a boolean. You can test this yourself in the Python interactive shell:
&amp;gt;&amp;gt;&amp;gt; size = 1&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;size &amp;lt; 0
False
size = 0
size &amp;lt; 0
False
size = -1
size &amp;lt; 0
True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Due to some legacy issues left over from Python 2, booleans can be treated as numbers. True is 1; False is 0.
&amp;gt;&amp;gt;&amp;gt; True + True
2
&amp;gt;&amp;gt;&amp;gt; True - False
1
&amp;gt;&amp;gt;&amp;gt; True * False
0
&amp;gt;&amp;gt;&amp;gt; True / False&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
ZeroDivisionError: int division or modulo by zero&lt;/p&gt;

&lt;p&gt;Ew, ew, ew! Don’t do that. Forget I even mentioned it.
.&lt;/p&gt;

&lt;p&gt;2.3. NUMBERS
Numbers are awesome. There are so many to choose from. Python supports both integers and floating point numbers. There’s no type declaration to distinguish them; Python tells them apart by the presence or absence of a decimal point.
&amp;gt;&amp;gt;&amp;gt; type(1) .
&lt;class &#39;int&#39;&gt;
&amp;gt;&amp;gt;&amp;gt; isinstance(1, int) .
True
&amp;gt;&amp;gt;&amp;gt; 1 + 1 .
2
&amp;gt;&amp;gt;&amp;gt; 1 + 1.0 .
2.0
&amp;gt;&amp;gt;&amp;gt; type(2.0)
&lt;class &#39;float&#39;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You can use the type() function to check the type of any value or variable. As you might expect, 1 is an int.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Similarly, you can use the isinstance() function to check whether a value or variable is of a given type.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Adding an int to an int yields an int.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Adding an int to a float yields a float. Python coerces the int into a float to perform the addition, then returns a float as the result.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.3.1. COERCING INTEGERS TO FLOATS AND VICE-VERSA
As you just saw, some operators (like addition) will coerce integers to floating point numbers as needed. You can also coerce them by yourself.
&amp;gt;&amp;gt;&amp;gt; float(2) .
2.0
&amp;gt;&amp;gt;&amp;gt; int(2.0) .
2
&amp;gt;&amp;gt;&amp;gt; int(2.5) .
2
&amp;gt;&amp;gt;&amp;gt; int(-2.5) .
-2
&amp;gt;&amp;gt;&amp;gt; 1.12345678901234567890 .
1.1234567890123457
&amp;gt;&amp;gt;&amp;gt; type(1000000000000000) .
&lt;class &#39;int&#39;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You can explicitly coerce an int to a float by calling the float() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unsurprisingly, you can also coerce a float to an int by calling int().&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The int() function will truncate, not round.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The int() function truncates negative numbers towards 0. It’s a true truncate function, not a floor function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Floating point numbers are accurate to 15 decimal places.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integers can be arbitrarily large.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. Python 2 had separate types for int and long. The int datatype was limited by sys.maxint, which varied by platform but was usually 232-1. Python 3 has just one integer type, which behaves mostly like the old long type from Python 2. See PEP
237
for details.&lt;/p&gt;

&lt;p&gt;2.3.2. COMMON NUMERICAL OPERATIONS
You can do all kinds of things with numbers.
&amp;gt;&amp;gt;&amp;gt; 11 / 2 .
5.5
&amp;gt;&amp;gt;&amp;gt; 11 // 2 .
5
&amp;gt;&amp;gt;&amp;gt; -11 // 2 .
-6
&amp;gt;&amp;gt;&amp;gt; 11.0 // 2 .
5.0
&amp;gt;&amp;gt;&amp;gt; 11 ** 2 .
121
&amp;gt;&amp;gt;&amp;gt; 11 % 2 .
1&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The / operator performs floating point division. It returns a float even if both the numerator and denominator are ints.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The // operator performs a quirky kind of integer division. When the result is positive, you can think of it as truncating (not rounding) to 0 decimal places, but be careful with that.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When integer-dividing negative numbers, the // operator rounds “up” to the nearest integer. Mathematically speaking, it’s rounding “down” since -6 is less than -5, but it could trip you up if you were expecting it to truncate to -5.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The // operator doesn’t always return an integer. If either the numerator or denominator is a float, it will still round to the nearest integer, but the actual return value will be a float.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The ** operator means “raised to the power of.” 112 is 121.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The % operator gives the remainder after performing integer division. 11 divided by 2 is 5 with a remainder of 1, so the result here is 1.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. In Python 2, the / operator usually meant integer division, but you could make it behave like floating point division by including a special directive in your code. In Python 3, the / operator always means floating point division. See PEP
238
for details.&lt;/p&gt;

&lt;p&gt;2.3.3. FRACTIONS&lt;/p&gt;

&lt;p&gt;Python isn’t limited to integers and floating point numbers. It can also do all the fancy math you learned in high school and promptly forgot about.
&amp;gt;&amp;gt;&amp;gt; import fractions .
&amp;gt;&amp;gt;&amp;gt; x = fractions.Fraction(1, 3) .
&amp;gt;&amp;gt;&amp;gt; x
Fraction(1, 3)
&amp;gt;&amp;gt;&amp;gt; x * 2 .
Fraction(2, 3)
&amp;gt;&amp;gt;&amp;gt; fractions.Fraction(6, 4) .
Fraction(3, 2)
&amp;gt;&amp;gt;&amp;gt; fractions.Fraction(0, 0) .&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
File &amp;ldquo;fractions.py&amp;rdquo;, line 96, in &lt;strong&gt;new&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;raise ZeroDivisionError(&amp;lsquo;Fraction(%s, 0)&amp;rsquo; % numerator)
ZeroDivisionError: Fraction(0, 0)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To start using fractions, import the fractions module.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To define a fraction, create a Fraction object and pass in the numerator and denominator.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can perform all the usual mathematical operations with fractions. Operations return a new Fraction object. 2 * (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;) = (&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The Fraction object will automatically reduce fractions. (&lt;sup&gt;6&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;) = (&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python has the good sense not to create a fraction with a zero denominator.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.3.4. TRIGONOMETRY
You can also do basic trigonometry in Python.
&amp;gt;&amp;gt;&amp;gt; import math
&amp;gt;&amp;gt;&amp;gt; math.pi .
3.1415926535897931
&amp;gt;&amp;gt;&amp;gt; math.sin(math.pi / 2) .
1.0
&amp;gt;&amp;gt;&amp;gt; math.tan(math.pi / 4) .
0.99999999999999989&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The math module has a constant for p, the ratio of a circle’s circumference to its diameter.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The math module has all the basic trigonometric functions, including sin(), cos(), tan(), and variants like asin().&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Note, however, that Python does not have infinite precision. tan(p / 4) should return 1.0, not 0.99999999999999989.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.3.5. NUMBERS IN A BOOLEAN CONTEXT
You can use numbers in
a
boolean
context, such as an
if statement. Zero values are false, and non-zero values&lt;/p&gt;

&lt;p&gt;are true.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;def is_it_true(anything): .
&amp;hellip; if anything:
&amp;hellip; print(&amp;ldquo;yes, it&amp;rsquo;s true&amp;rdquo;)
&amp;hellip; else:
&amp;hellip; print(&amp;ldquo;no, it&amp;rsquo;s false&amp;rdquo;)
&amp;hellip;
is_it_true(1) .
yes, it&amp;rsquo;s true
is_it_true(-1)
yes, it&amp;rsquo;s true
is_it_true(0)
no, it&amp;rsquo;s false
is_it_true(0.1) .
yes, it&amp;rsquo;s true
is_it_true(0.0)
no, it&amp;rsquo;s false
import fractions
is_it_true(fractions.Fraction(1, 2)) .
yes, it&amp;rsquo;s true
is_it_true(fractions.Fraction(0, 1))
no, it&amp;rsquo;s false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Did you know you can define your own functions in the Python interactive shell? Just press ENTER at the end of each line, and ENTER on a blank line to finish.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In a boolean context, non-zero integers are true; 0 is false.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Non-zero floating point numbers are true; 0.0 is false. Be careful with this one! If there’s the slightest rounding error (not impossible, as you saw in the previous section) then Python will be testing 0.0000000000001 instead of 0 and will return True.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Fractions can also be used in a boolean context. Fraction(0, n) is false for all values of n. All other fractions are true.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;2.4. LISTS
Lists are Python’s workhorse datatype. When I say “list,” you might be thinking “array whose size I have to declare in advance, that can only contain items of the same type, &amp;amp;c.” Don’t think that. Lists are much cooler than that.
.
A list in Python is like an array in Perl 5. In Perl 5, variables that store arrays always start with the @ character; in Python, variables can be named anything, and Python keeps track of the datatype internally.&lt;/p&gt;

&lt;p&gt;.
A list in Python is much more than an array in Java (although it can be used as one if that’s really all you want out of life). A better analogy would be to the ArrayList class, which can hold arbitrary objects and can expand dynamically as new items are added.&lt;/p&gt;

&lt;p&gt;2.4.1. CREATING A LIST
Creating a list is easy: use square brackets to wrap a comma-separated list of values.
&amp;gt;&amp;gt;&amp;gt; a_list = [&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, &amp;lsquo;z&amp;rsquo;, &amp;lsquo;example&amp;rsquo;]  .&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; a_list&lt;br /&gt;
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, &amp;lsquo;z&amp;rsquo;, &amp;lsquo;example&amp;rsquo;]&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; a_list[0]  .&lt;br /&gt;
&amp;lsquo;a&amp;rsquo;&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; a_list[4]  .&lt;br /&gt;
&amp;lsquo;example&amp;rsquo;&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; a_list[-1]  .&lt;br /&gt;
&amp;lsquo;example&amp;rsquo;&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; a_list[-3]  .&lt;br /&gt;
&amp;lsquo;mpilgrim&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;First, you define a list of five items. Note that they retain their original order. This is not an accident. A list is an ordered set of items.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A list can be used like a zero-based array. The first item of any non-empty list is always a_list[0].&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The last item of this five-item list is a_list[4], because lists are always zero-based.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A negative index accesses items from the end of the list counting backwards. The last item of any non-empty list is always a_list[-1].&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the negative index is confusing to you, think of it this way: a_list[-n] == a_list[len(a_list) -n]. So in this list, a_list[-3] == a_list[5 -3] == a_list[2].&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.4.2. SLICING A LIST
Once you’ve defined a list, you can get any part of it as
a new list. This is called slicing the list.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_list
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, &amp;lsquo;z&amp;rsquo;, &amp;lsquo;example&amp;rsquo;]
a_list[1:3] .
[&amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;]
a_list[1:-1] .
[&amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, &amp;lsquo;z&amp;rsquo;]
a_list[0:3] .
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;]
a_list[:3] .
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;]
a_list[3:] .
[&amp;lsquo;z&amp;rsquo;, &amp;lsquo;example&amp;rsquo;]
a_list[:] .
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, &amp;lsquo;z&amp;rsquo;, &amp;lsquo;example&amp;rsquo;]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You can get a part of a list, called a “slice”, by specifying two indices. The return value is a new list containing all the items of the list, in order, starting with the first slice index (in this case a_list[1]), up to but not including the second slice index (in this case a_list[3]).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Slicing works if one or both of the slice indices is negative. If it helps, you can think of it this way: reading the list from left to right, the first slice index specifies the first item you want, and the second slice index specifies the first item you don’t want. The return value is everything in between.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lists are zero-based, so a_list[0:3] returns the first three items of the list, starting at a_list[0], up to but not including a_list[3].&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the left slice index is 0, you can leave it out, and 0 is implied. So a_list[:3] is the same as a_list[0:3], because the starting 0 is implied.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Similarly, if the right slice index is the length of the list, you can leave it out. So a_list[3:] is the same as a_list[3:5], because this list has five items. There is a pleasing symmetry here. In this five-item list, a_list[:3] returns the first 3 items, and a_list[3:] returns the last two items. In fact, a_list[:n] will always return the first n items, and a_list[n:] will return the rest, regardless of the length of the list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If both slice indices are left out, all items of the list are included. But this is not the same as the original a_list variable. It is a new list that happens to have all the same items. a_list[:] is shorthand for making a complete copy of a list.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.4.3. ADDING ITEMS TO A LIST
There are four ways to add items to a list.
&amp;gt;&amp;gt;&amp;gt; a_list = [&amp;lsquo;a&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; a_list = a_list + [2.0, 3] .
&amp;gt;&amp;gt;&amp;gt; a_list .
[&amp;lsquo;a&amp;rsquo;, 2.0, 3]
&amp;gt;&amp;gt;&amp;gt; a_list.append(True) .
&amp;gt;&amp;gt;&amp;gt; a_list
[&amp;lsquo;a&amp;rsquo;, 2.0, 3, True]
&amp;gt;&amp;gt;&amp;gt; a_list.extend([&amp;lsquo;four&amp;rsquo;, &amp;lsquo;O&amp;rsquo;]) .
&amp;gt;&amp;gt;&amp;gt; a_list
[&amp;lsquo;a&amp;rsquo;, 2.0, 3, True, &amp;lsquo;four&amp;rsquo;, &amp;lsquo;O&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; a_list.insert(0, &amp;lsquo;O&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; a_list
[&amp;lsquo;O&amp;rsquo;, &amp;lsquo;a&amp;rsquo;, 2.0, 3, True, &amp;lsquo;four&amp;rsquo;, &amp;lsquo;O&amp;rsquo;]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The + operator concatenates lists to create a new list. A list can contain any number of items; there is no size limit (other than available memory). However, if memory is a concern, you should be aware that list concatenation creates a second list in memory. In this case, that new list is immediately assigned to the existing variable a_list. So this line of code is really a two-step process — concatenation then assignment — which can (temporarily) consume a lot of memory when you’re dealing with large lists.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A list can contain items of any datatype, and the items in a single list don’t all need to be the same type. Here we have a list containing a string, a floating point number, and an integer.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The append() method adds a single item to the end of the list. (Now we have four different datatypes in the list!)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lists are implemented as classes. “Creating” a list is really instantiating a class. As such, a list has methods that operate on it. The extend() method takes one argument, a list, and appends each of the items of the argument to the original list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The insert() method inserts a single item into a list. The first argument is the index of the first item in the list that will get bumped out of position. List items do not need to be unique; for example, there are now two separate items with the value &amp;lsquo;O&amp;rsquo;: the first item, a_list[0], and the last item, a_list[6].&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. a_list.insert(0, value) is like the unshift() function in Perl. It adds an item to the beginning of the list, and all the other items have their positional index bumped up to make room.
Let’s look closer at the difference between append() and extend().
&amp;gt;&amp;gt;&amp;gt; a_list = [&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;c&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; a_list.extend([&amp;rsquo;d&amp;rsquo;, &amp;lsquo;e&amp;rsquo;, &amp;lsquo;f&amp;rsquo;]) .
&amp;gt;&amp;gt;&amp;gt; a_list
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;c&amp;rsquo;, &amp;rsquo;d&amp;rsquo;, &amp;lsquo;e&amp;rsquo;, &amp;lsquo;f&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; len(a_list) .
6
&amp;gt;&amp;gt;&amp;gt; a_list[-1]
&amp;lsquo;f&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_list.append([&amp;lsquo;g&amp;rsquo;, &amp;lsquo;h&amp;rsquo;, &amp;lsquo;i&amp;rsquo;]) .
&amp;gt;&amp;gt;&amp;gt; a_list
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;c&amp;rsquo;, &amp;rsquo;d&amp;rsquo;, &amp;lsquo;e&amp;rsquo;, &amp;lsquo;f&amp;rsquo;, [&amp;lsquo;g&amp;rsquo;, &amp;lsquo;h&amp;rsquo;, &amp;lsquo;i&amp;rsquo;]]
&amp;gt;&amp;gt;&amp;gt; len(a_list) .
7
&amp;gt;&amp;gt;&amp;gt; a_list[-1]
[&amp;lsquo;g&amp;rsquo;, &amp;lsquo;h&amp;rsquo;, &amp;lsquo;i&amp;rsquo;]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The extend() method takes a single argument, which is always a list, and adds each of the items of that list to a_list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you start with a list of three items and extend it with a list of another three items, you end up with a list of six items.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;On the other hand, the append() method takes a single argument, which can be any datatype. Here, you’re calling the append() method with a list of three items.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you start with a list of six items and append a list onto it, you end up with&amp;hellip; a list of seven items. Why seven? Because the last item (which you just appended) is itself a list. Lists can contain any type of data, including other lists. That may be what you want, or it may not. But it’s what you asked for, and it’s what you got.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.4.4. SEARCHING FOR VALUES IN A LIST&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_list = [&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;new&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, &amp;lsquo;new&amp;rsquo;]&lt;/p&gt;

&lt;p&gt;a_list.count(&amp;lsquo;new&amp;rsquo;) .
2&lt;/p&gt;

&lt;p&gt;&amp;lsquo;new&amp;rsquo; in a_list .
True&lt;/p&gt;

&lt;p&gt;&amp;lsquo;c&amp;rsquo; in a_list&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;False&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_list.index(&amp;lsquo;mpilgrim&amp;rsquo;) .
3&lt;/p&gt;

&lt;p&gt;a_list.index(&amp;lsquo;new&amp;rsquo;) .
2&lt;/p&gt;

&lt;p&gt;a_list.index(&amp;lsquo;c&amp;rsquo;) .
Traceback (innermost last):&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;File &amp;ldquo;&lt;interactive input&gt;&amp;rdquo;, line 1, in ?&lt;/p&gt;

&lt;p&gt;ValueError: list.index(x): x not in list&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;As you might expect, the count() method returns the number of occurrences of a specific value in a list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If all you want to know is whether a value is in the list or not, the in operator is slightly faster than using the count() method. The in operator always returns True or False; it will not tell you how many times the value appears in the list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Neither the in operator nor the count() method will tell you where in the list a value appears. If you need to know where in the list a value is, call the index() method. By default it will search the entire list, although you can specify an optional second argument of the (0-based) index to start from, and even an optional third argument of the (0-based) index to stop searching.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The index() method finds the first occurrence of a value in the list. In this case, &amp;lsquo;new&amp;rsquo; occurs twice in the list, in a_list[2] and a_list[4], but the index() method will return only the index of the first occurrence.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As you might not expect, if the value is not found in the list, the index() method will raise an exception.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Wait, what? That’s right: the index() method raises an exception if it doesn’t find the value in the list. This is notably different from most languages, which will return some invalid index (like -1). While this may seem annoying at first, I think you will come to appreciate it. It means your program will crash at the source of the problem instead of failing strangely and silently later. Remember, -1 is
a
valid
list
index. If the index() method returned -1, that could lead to some not-so-fun debugging sessions!&lt;/p&gt;

&lt;p&gt;2.4.5. REMOVING ITEMS FROM A LIST
Lists can expand and contract automatically. You’ve seen the expansion part. There are several different ways to
remove items from a list as well.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_list = [&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;new&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, &amp;lsquo;new&amp;rsquo;]
a_list[1]
&amp;lsquo;b&amp;rsquo;
del a_list[1] .
a_list
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;new&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, &amp;lsquo;new&amp;rsquo;]
a_list[1] .
&amp;lsquo;new&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You can use the del statement to delete a specific item from a list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Accessing index 1 after deleting index 1 does not result in an error. All items after the deleted item shift their positional index to “fill the gap” created by deleting the item.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Don’t know the positional index? Not a problem; you can remove items by value instead.
&amp;gt;&amp;gt;&amp;gt; a_list.remove(&amp;lsquo;new&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; a_list
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, &amp;lsquo;new&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; a_list.remove(&amp;lsquo;new&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; a_list
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; a_list.remove(&amp;lsquo;new&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
ValueError: list.remove(x): x not in list&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You can also remove an item from a list with the remove() method. The remove() method takes a value and removes the first occurrence of that value from the list. Again, all items after the deleted item will have their positional indices bumped down to “fill the gap.” Lists never have gaps.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can call the remove() method as often as you like, but it will raise an exception if you try to remove a value that isn’t in the list.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.4.6. REMOVING ITEMS FROM A LIST: BONUS ROUND
Another interesting list method is pop(). The pop() method is yet another way to remove
items
from
a
list, but with a twist.
&amp;gt;&amp;gt;&amp;gt; a_list = [&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;new&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;]&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_list.pop() .
&amp;lsquo;mpilgrim&amp;rsquo;
a_list
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;new&amp;rsquo;]
a_list.pop(1) .
&amp;lsquo;b&amp;rsquo;
a_list
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;new&amp;rsquo;]
a_list.pop()
&amp;lsquo;new&amp;rsquo;
a_list.pop()
&amp;lsquo;a&amp;rsquo;
a_list.pop() .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
IndexError: pop from empty list&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;When called without arguments, the pop() list method removes the last item in the list and returns the value it removed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can pop arbitrary items from a list. Just pass a positional index to the pop() method. It will remove that item, shift all the items after it to “fill the gap,” and return the value it removed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Calling pop() on an empty list raises an exception.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. Calling the pop() list method without an argument is like the pop() function in Perl. It removes the last item from the list and returns the value of the removed item. Perl has another function, shift(), which removes the first item and returns its value; in Python, this is equivalent to a_list.pop(0).&lt;/p&gt;

&lt;p&gt;2.4.7. LISTS IN A BOOLEAN CONTEXT&lt;/p&gt;

&lt;p&gt;You can also use a list in a
boolean
context, such as an if statement.
&amp;gt;&amp;gt;&amp;gt;  def is_it_true(anything):&lt;br /&gt;
&amp;hellip;  if anything:&lt;br /&gt;
&amp;hellip;  print(&amp;ldquo;yes, it&amp;rsquo;s true&amp;rdquo;)&lt;br /&gt;
&amp;hellip;  else:&lt;br /&gt;
&amp;hellip;  print(&amp;ldquo;no, it&amp;rsquo;s false&amp;rdquo;)&lt;br /&gt;
&amp;hellip;&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt;  is_it_true([])  .&lt;/p&gt;

&lt;p&gt;no, it&amp;rsquo;s false &amp;gt;&amp;gt;&amp;gt; is_it_true([&amp;lsquo;a&amp;rsquo;]) . yes, it&amp;rsquo;s true &amp;gt;&amp;gt;&amp;gt; is_it_true([False]) .&lt;/p&gt;

&lt;p&gt;yes, it&amp;rsquo;s true&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In a boolean context, an empty list is false.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any list with at least one item is true.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any list with at least one item is true. The value of the items is irrelevant.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.
2.5. TUPLES
A tuple is an immutable list. A tuple can not be changed in any way once it is created.
&amp;gt;&amp;gt;&amp;gt; a_tuple = (&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;mpilgrim&amp;rdquo;, &amp;ldquo;z&amp;rdquo;, &amp;ldquo;example&amp;rdquo;) .
&amp;gt;&amp;gt;&amp;gt; a_tuple
(&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, &amp;lsquo;z&amp;rsquo;, &amp;lsquo;example&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; a_tuple[0] .
&amp;lsquo;a&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_tuple[-1] .
&amp;lsquo;example&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_tuple[1:3] .
(&amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A tuple is defined in the same way as a list, except that the whole set of elements is enclosed in parentheses instead of square brackets.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The elements of a tuple have a defined order, just like a list. Tuple indices are zero-based, just like a list, so the first element of a non-empty tuple is always a_tuple[0].&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Negative indices count from the end of the tuple, just like a list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Slicing works too, just like a list. When you slice a list, you get a new list; when you slice a tuple, you get a new tuple.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The major difference between tuples and lists is that tuples can not be changed. In technical terms, tuples are immutable. In practical terms, they have no methods that would allow you to change them. Lists have methods like append(), extend(), insert(), remove(), and pop(). Tuples have none of these methods. You can slice a tuple (because that creates a new tuple), and you can check whether a tuple contains a particular value (because that doesn’t change the tuple), and… that’s about it.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_tuple&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;(&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, &amp;lsquo;z&amp;rsquo;, &amp;lsquo;example&amp;rsquo;)&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_tuple.append(&amp;ldquo;new&amp;rdquo;)   .
Traceback (innermost last):&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;File &amp;ldquo;&lt;interactive input&gt;&amp;rdquo;, line 1, in ?&lt;/p&gt;

&lt;p&gt;AttributeError: &amp;lsquo;tuple&amp;rsquo; object has no attribute &amp;lsquo;append&amp;rsquo;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_tuple.remove(&amp;ldquo;z&amp;rdquo;)     .
Traceback (innermost last):&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;File &amp;ldquo;&lt;interactive input&gt;&amp;rdquo;, line 1, in ?&lt;/p&gt;

&lt;p&gt;AttributeError: &amp;lsquo;tuple&amp;rsquo; object has no attribute &amp;lsquo;remove&amp;rsquo;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_tuple.index(&amp;ldquo;example&amp;rdquo;) .
4&lt;/p&gt;

&lt;p&gt;&amp;ldquo;z&amp;rdquo; in a_tuple  .
True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You can’t add elements to a tuple. Tuples have no append() or extend() method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can’t remove elements from a tuple. Tuples have no remove() or pop() method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can find elements in a tuple, since this doesn’t change the tuple.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can also use the in operator to check if an element exists in the tuple.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So what are tuples good for?
•   Tuples are faster than lists. If you’re defining a constant set of values and all you’re ever going to do with it is iterate through it, use a tuple instead of a list.&lt;/p&gt;

&lt;p&gt;•   It makes your code safer if you “write-protect” data that doesn’t need to be changed. Using a tuple instead of a list is like having an implied assert statement that shows this data is constant, and that special thought (and a specific function) is required to override that.&lt;/p&gt;

&lt;p&gt;•   Some tuples can be used as dictionary keys (specifically, tuples that contain immutable values like strings,
numbers, and other tuples). Lists can never be used as dictionary keys, because lists are not immutable.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;Tuples can be converted into lists, and vice-versa. The built-in tuple() function takes a list and returns a tuple with the same elements, and the list() function takes a tuple and returns a list. In effect, tuple() freezes a list, and list() thaws a tuple.
2.5.1. TUPLES IN A BOOLEAN CONTEXT
You can use tuples in a
boolean
context, such as an if statement.
&amp;gt;&amp;gt;&amp;gt; def is_it_true(anything):
&amp;hellip; if anything:
&amp;hellip; print(&amp;ldquo;yes, it&amp;rsquo;s true&amp;rdquo;)
&amp;hellip; else:
&amp;hellip; print(&amp;ldquo;no, it&amp;rsquo;s false&amp;rdquo;)
&amp;hellip;
&amp;gt;&amp;gt;&amp;gt; is_it_true(()) .
no, it&amp;rsquo;s false
&amp;gt;&amp;gt;&amp;gt; is_it_true((&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;)) .
yes, it&amp;rsquo;s true
&amp;gt;&amp;gt;&amp;gt; is_it_true((False,)) .
yes, it&amp;rsquo;s true
&amp;gt;&amp;gt;&amp;gt; type((False)) .
&lt;class &#39;bool&#39;&gt;
&amp;gt;&amp;gt;&amp;gt; type((False,))
&lt;class &#39;tuple&#39;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In a boolean context, an empty tuple is false.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any tuple with at least one item is true.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any tuple with at least one item is true. The value of the items is irrelevant. But what’s that comma doing there?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To create a tuple of one item, you need a comma after the value. Without the comma, Python just assumes you have an extra pair of parentheses, which is harmless, but it doesn’t create a tuple.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.5.2. ASSIGNING MULTIPLE VALUES AT ONCE&lt;/p&gt;

&lt;p&gt;Here’s a cool programming shortcut: in Python, you can use a tuple to assign multiple values at once.
&amp;gt;&amp;gt;&amp;gt; v = (&amp;lsquo;a&amp;rsquo;, 2, True)
&amp;gt;&amp;gt;&amp;gt; (x, y, z) = v .
&amp;gt;&amp;gt;&amp;gt; x
&amp;lsquo;a&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; y
2
&amp;gt;&amp;gt;&amp;gt; z
True&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;v is a tuple of three elements, and (x, y, z) is a tuple of three variables. Assigning one to the other assigns each of the values of v to each of the variables, in order.
This has all kinds of uses. Suppose you want to assign names to a range of values. You can use the built-in range() function with multi-variable assignment to quickly assign consecutive values.
&amp;gt;&amp;gt;&amp;gt; (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7) . &amp;gt;&amp;gt;&amp;gt; MONDAY . 0 &amp;gt;&amp;gt;&amp;gt; TUESDAY 1 &amp;gt;&amp;gt;&amp;gt; SUNDAY 6&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The built-in range() function constructs a sequence of integers. (Technically, the range() function returns an iterator, not a list or a tuple, but you’ll learn about that distinction later.) MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY are the variables you’re defining. (This example came from the calendar module, a fun little module that prints calendars, like the UNIX program cal. The calendar module defines integer constants for days of the week.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now each variable has its value: MONDAY is 0, TUESDAY is 1, and so forth.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can also use multi-variable assignment to build functions that return multiple values, simply by returning a tuple of all the values. The caller can treat it as a single tuple, or it can assign the values to individual variables. Many standard Python libraries do this, including the os module, which you&amp;rsquo;ll learn about in the
next
chapter.&lt;/p&gt;

&lt;p&gt;.
2.6. SETS
A set is an unordered “bag” of unique values. A single set can contain values of any immutable datatype. Once you have two sets, you can do standard set operations like union, intersection, and set difference.
2.6.1. CREATING A SET
First things first. Creating a set is easy.
&amp;gt;&amp;gt;&amp;gt; a_set = {1} .
&amp;gt;&amp;gt;&amp;gt; a_set
{1}
&amp;gt;&amp;gt;&amp;gt; type(a_set) .
&lt;class &#39;set&#39;&gt;
&amp;gt;&amp;gt;&amp;gt; a_set = {1, 2} .
&amp;gt;&amp;gt;&amp;gt; a_set
{1, 2}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To create a set with one value, put the value in curly brackets ({}).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sets are actually implemented as classes, but don’t worry about that for now.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To create a set with multiple values, separate the values with commas and wrap it all up with curly brackets.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can also create a set out of a list.
&amp;gt;&amp;gt;&amp;gt; a_list = [&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, True, False, 42]
&amp;gt;&amp;gt;&amp;gt; a_set = set(a_list) .
&amp;gt;&amp;gt;&amp;gt; a_set .
{&amp;lsquo;a&amp;rsquo;, False, &amp;lsquo;b&amp;rsquo;, True, &amp;lsquo;mpilgrim&amp;rsquo;, 42}
&amp;gt;&amp;gt;&amp;gt; a_list .
[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;mpilgrim&amp;rsquo;, True, False, 42]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To create a set from a list, use the set() function. (Pedants who know about how sets are implemented will point out that this is not really calling a function, but instantiating a class. I promise you will learn the difference later in this book. For now, just know that set() acts like a function, and it returns a set.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As I mentioned earlier, a single set can contain values of any datatype. And, as I mentioned earlier, sets are unordered. This set does not remember the original order of the list that was used to create it. If you were to add items to this set, it would not remember the order in which you added them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The original list is unchanged.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Don’t have any values yet? Not a problem. You can create an empty set.
&amp;gt;&amp;gt;&amp;gt; a_set = set() .
&amp;gt;&amp;gt;&amp;gt; a_set .
set()
&amp;gt;&amp;gt;&amp;gt; type(a_set) .
&lt;class &#39;set&#39;&gt;
&amp;gt;&amp;gt;&amp;gt; len(a_set) .
0
&amp;gt;&amp;gt;&amp;gt; not_sure = {} .
&amp;gt;&amp;gt;&amp;gt; type(not_sure)
&lt;class &#39;dict&#39;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To create an empty set, call set() with no arguments.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The printed representation of an empty set looks a bit strange. Were you expecting {}, perhaps? That would denote an empty dictionary, not an empty set. You’ll learn about dictionaries later in this chapter.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Despite the strange printed representation, this is a set…&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;…and this set has no members.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Due to historical quirks carried over from Python 2, you can not create an empty set with two curly&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;brackets. This actually creates an empty dictionary, not an empty set.&lt;/p&gt;

&lt;p&gt;2.6.2. MODIFYING A SET
There are two different ways to add values to an existing set: the add() method, and the update() method.
&amp;gt;&amp;gt;&amp;gt; a_set = {1, 2}
&amp;gt;&amp;gt;&amp;gt; a_set.add(4) .
&amp;gt;&amp;gt;&amp;gt; a_set
{1, 2, 4}
&amp;gt;&amp;gt;&amp;gt; len(a_set) .
3
&amp;gt;&amp;gt;&amp;gt; a_set.add(1) .
&amp;gt;&amp;gt;&amp;gt; a_set
{1, 2, 4}
&amp;gt;&amp;gt;&amp;gt; len(a_set) .
3&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The add() method takes a single argument, which can be any datatype, and adds the given value to the set.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This set now has 3 members.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sets are bags of unique values. If you try to add a value that already exists in the set, it will do nothing. It won’t raise an error; it’s just a no-op.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This set still has 3 members.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_set = {1, 2, 3}&lt;/p&gt;

&lt;p&gt;a_set
{1, 2, 3}
a_set.update({2, 4, 6}) .
a_set .
{1, 2, 3, 4, 6}
a_set.update({3, 6, 9}, {1, 2, 3, 5, 8, 13}) .
a_set
{1, 2, 3, 4, 5, 6, 8, 9, 13}
a_set.update([10, 20, 30]) .
a_set
{1, 2, 3, 4, 5, 6, 8, 9, 10, 13, 20, 30}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The update() method takes one argument, a set, and adds all its members to the original set. It’s as if you called the add() method with each member of the set.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Duplicate values are ignored, since sets can not contain duplicates.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can actually call the update() method with any number of arguments. When called with two sets, the update() method adds all the members of each set to the original set (dropping duplicates).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The update() method can take objects of a number of different datatypes, including lists. When called with a list, the update() method adds all the items of the list to the original set.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.6.3. REMOVING ITEMS FROM A SET
There are three ways to remove individual values from a set. The first two, discard() and remove(), have one subtle difference.
&amp;gt;&amp;gt;&amp;gt; a_set = {1, 3, 6, 10, 15, 21, 28, 36, 45}&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_set
{1, 3, 36, 6, 10, 45, 15, 21, 28}
a_set.discard(10) .
a_set
{1, 3, 36, 6, 45, 15, 21, 28}
a_set.discard(10) .
a_set
{1, 3, 36, 6, 45, 15, 21, 28}
a_set.remove(21) .
a_set
{1, 3, 36, 6, 45, 15, 28}
a_set.remove(21) .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
KeyError: 21&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The discard() method takes a single value as an argument and removes that value from the set.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you call the discard() method with a value that doesn’t exist in the set, it does nothing. No error; it’s just a no-op.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The remove() method also takes a single value as an argument, and it also removes that value from the set.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Here’s the difference: if the value doesn’t exist in the set, the remove() method raises a KeyError exception.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Like lists, sets have a pop() method.
&amp;gt;&amp;gt;&amp;gt; a_set = {1, 3, 6, 10, 15, 21, 28, 36, 45}&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_set.pop()     .
1&lt;/p&gt;

&lt;p&gt;a_set.pop()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;3&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_set.pop()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;36&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_set&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;{6, 10, 45, 15, 21, 28}&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_set.clear()   .
a_set&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;set()&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_set.pop()     .
Traceback (most recent call last):&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;KeyError: &amp;lsquo;pop from an empty set&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The pop() method removes a single value from a set and returns the value. However, since sets are unordered, there is no “last” value in a set, so there is no way to control which value gets removed. It is completely arbitrary.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The clear() method removes all values from a set, leaving you with an empty set. This is equivalent to a_set = set(), which would create a new empty set and overwrite the previous value of the a_set variable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Attempting to pop a value from an empty set will raise a KeyError exception.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.6.4. COMMON SET OPERATIONS
Python’s set type supports several common set operations.
&amp;gt;&amp;gt;&amp;gt; a_set = {2, 4, 5, 9, 12, 21, 30, 51, 76, 127, 195}
&amp;gt;&amp;gt;&amp;gt; 30 in a_set .
True
&amp;gt;&amp;gt;&amp;gt; 31 in a_set
False
&amp;gt;&amp;gt;&amp;gt; b_set = {1, 2, 3, 5, 6, 8, 9, 12, 15, 17, 18, 21}
&amp;gt;&amp;gt;&amp;gt; a_set.union(b_set) .
{1, 2, 195, 4, 5, 6, 8, 12, 76, 15, 17, 18, 3, 21, 30, 51, 9, 127}
&amp;gt;&amp;gt;&amp;gt; a_set.intersection(b_set) .
{9, 2, 12, 5, 21}
&amp;gt;&amp;gt;&amp;gt; a_set.difference(b_set) .
{195, 4, 76, 51, 30, 127}
&amp;gt;&amp;gt;&amp;gt; a_set.symmetric_difference(b_set) .
{1, 3, 4, 6, 8, 76, 15, 17, 18, 195, 127, 30, 51}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To test whether a value is a member of a set, use the in operator. This works the same as lists.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The union() method returns a new set containing all the elements that are in either set.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The intersection() method returns a new set containing all the elements that are in both sets.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The difference() method returns a new set containing all the elements that are in a_set but not b_set.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The symmetric_difference() method returns a new set containing all the elements that are in exactly one of the sets.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Three of these methods are symmetric.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;b_set.symmetric_difference(a_set) .
{3, 1, 195, 4, 6, 8, 76, 15, 17, 18, 51, 30, 127}
b_set.symmetric_difference(a_set) == a_set.symmetric_difference(b_set) .
True
b_set.union(a_set) == a_set.union(b_set) .
True
b_set.intersection(a_set) == a_set.intersection(b_set) .
True
b_set.difference(a_set) == a_set.difference(b_set) .
False&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The symmetric difference of a_set from b_set looks different than the symmetric difference of b_set from a_set, but remember, sets are unordered. Any two sets that contain all the same values (with none left over) are considered equal.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And that’s exactly what happens here. Don’t be fooled by the Python Shell’s printed representation of these sets. They contain the same values, so they are equal.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The union of two sets is also symmetric.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The intersection of two sets is also symmetric.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The difference of two sets is not symmetric. That makes sense; it’s analogous to subtracting one number from another. The order of the operands matters.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Finally, there are a few questions you can ask of sets.
&amp;gt;&amp;gt;&amp;gt; a_set = {1, 2, 3}
&amp;gt;&amp;gt;&amp;gt; b_set = {1, 2, 3, 4}
&amp;gt;&amp;gt;&amp;gt; a_set.issubset(b_set) .
True
&amp;gt;&amp;gt;&amp;gt; b_set.issuperset(a_set) .
True
&amp;gt;&amp;gt;&amp;gt; a_set.add(5) .
&amp;gt;&amp;gt;&amp;gt; a_set.issubset(b_set)
False
&amp;gt;&amp;gt;&amp;gt; b_set.issuperset(a_set)
False&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;a_set is a subset of b_set — all the members of a_set are also members of b_set.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asking the same question in reverse, b_set is a superset of a_set, because all the members of a_set are also members of b_set.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As soon as you add a value to a_set that is not in b_set, both tests return False.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.6.5. SETS IN A BOOLEAN CONTEXT
You can use sets in a
boolean
context, such as an if statement.
&amp;gt;&amp;gt;&amp;gt; def is_it_true(anything):
&amp;hellip; if anything:
&amp;hellip; print(&amp;ldquo;yes, it&amp;rsquo;s true&amp;rdquo;)
&amp;hellip; else:
&amp;hellip; print(&amp;ldquo;no, it&amp;rsquo;s false&amp;rdquo;)
&amp;hellip;
&amp;gt;&amp;gt;&amp;gt; is_it_true(set()) .
no, it&amp;rsquo;s false
&amp;gt;&amp;gt;&amp;gt; is_it_true({&amp;lsquo;a&amp;rsquo;}) .
yes, it&amp;rsquo;s true
&amp;gt;&amp;gt;&amp;gt; is_it_true({False}) .
yes, it&amp;rsquo;s true&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In a boolean context, an empty set is false.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any set with at least one item is true.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any set with at least one item is true. The value of the items is irrelevant.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.
2.7. DICTIONARIES
A dictionary is an unordered set of key-value pairs. When you add a key to a dictionary, you must also add a value for that key. (You can always change the value later.) Python dictionaries are optimized for retrieving the value when you know the key, but not the other way around.
. A dictionary in Python is like a hash in Perl 5. In Perl 5, variables that store hashes always start with a % character. In Python, variables can be named anything, and Python keeps track of the datatype internally.
2.7.1. CREATING A DICTIONARY
Creating a dictionary is easy. The syntax is similar to sets, but instead of values, you have key-value pairs. Once you have a dictionary, you can look up values by their key.
&amp;gt;&amp;gt;&amp;gt; a_dict = {&amp;lsquo;server&amp;rsquo;: &amp;lsquo;db.diveintopython3.org&amp;rsquo;, &amp;lsquo;database&amp;rsquo;: &amp;lsquo;mysql&amp;rsquo;} .
&amp;gt;&amp;gt;&amp;gt; a_dict
{&amp;lsquo;server&amp;rsquo;: &amp;lsquo;db.diveintopython3.org&amp;rsquo;, &amp;lsquo;database&amp;rsquo;: &amp;lsquo;mysql&amp;rsquo;}
&amp;gt;&amp;gt;&amp;gt; a_dict[&amp;lsquo;server&amp;rsquo;] .
&amp;lsquo;db.diveintopython3.org&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_dict[&amp;lsquo;database&amp;rsquo;] .
&amp;lsquo;mysql&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_dict[&amp;lsquo;db.diveintopython3.org&amp;rsquo;] .&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
KeyError: &amp;lsquo;db.diveintopython3.org&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;First, you create a new dictionary with two items and assign it to the variable a_dict. Each item is a key-value pair, and the whole set of items is enclosed in curly braces.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lsquo;server&amp;rsquo; is a key, and its associated value, referenced by a_dict[&amp;lsquo;server&amp;rsquo;], is &amp;lsquo;db.diveintopython3.org&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lsquo;database&amp;rsquo; is a key, and its associated value, referenced by a_dict[&amp;lsquo;database&amp;rsquo;], is &amp;lsquo;mysql&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can get values by key, but you can’t get keys by value. So a_dict[&amp;lsquo;server&amp;rsquo;] is &amp;lsquo;db.diveintopython3.org&amp;rsquo;, but a_dict[&amp;lsquo;db.diveintopython3.org&amp;rsquo;] raises an exception, because &amp;lsquo;db.diveintopython3.org&amp;rsquo; is not a key.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.7.2. MODIFYING A DICTIONARY
Dictionaries do not have any predefined size limit. You can add new key-value pairs to a dictionary at any time, or you can modify the value of an existing key. Continuing from the previous example:
&amp;gt;&amp;gt;&amp;gt; a_dict&lt;/p&gt;

&lt;p&gt;{&amp;lsquo;server&amp;rsquo;: &amp;lsquo;db.diveintopython3.org&amp;rsquo;, &amp;lsquo;database&amp;rsquo;: &amp;lsquo;mysql&amp;rsquo;}
&amp;gt;&amp;gt;&amp;gt; a_dict[&amp;lsquo;database&amp;rsquo;] = &amp;lsquo;blog&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; a_dict
{&amp;lsquo;server&amp;rsquo;: &amp;lsquo;db.diveintopython3.org&amp;rsquo;, &amp;lsquo;database&amp;rsquo;: &amp;lsquo;blog&amp;rsquo;}
&amp;gt;&amp;gt;&amp;gt; a_dict[&amp;lsquo;user&amp;rsquo;] = &amp;lsquo;mark&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; a_dict .
{&amp;lsquo;server&amp;rsquo;: &amp;lsquo;db.diveintopython3.org&amp;rsquo;, &amp;lsquo;user&amp;rsquo;: &amp;lsquo;mark&amp;rsquo;, &amp;lsquo;database&amp;rsquo;: &amp;lsquo;blog&amp;rsquo;}
&amp;gt;&amp;gt;&amp;gt; a_dict[&amp;lsquo;user&amp;rsquo;] = &amp;lsquo;dora&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; a_dict
{&amp;lsquo;server&amp;rsquo;: &amp;lsquo;db.diveintopython3.org&amp;rsquo;, &amp;lsquo;user&amp;rsquo;: &amp;lsquo;dora&amp;rsquo;, &amp;lsquo;database&amp;rsquo;: &amp;lsquo;blog&amp;rsquo;}
&amp;gt;&amp;gt;&amp;gt; a_dict[&amp;lsquo;User&amp;rsquo;] = &amp;lsquo;mark&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; a_dict
{&amp;lsquo;User&amp;rsquo;: &amp;lsquo;mark&amp;rsquo;, &amp;lsquo;server&amp;rsquo;: &amp;lsquo;db.diveintopython3.org&amp;rsquo;, &amp;lsquo;user&amp;rsquo;: &amp;lsquo;dora&amp;rsquo;, &amp;lsquo;database&amp;rsquo;: &amp;lsquo;blog&amp;rsquo;}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You can not have duplicate keys in a dictionary. Assigning a value to an existing key will wipe out the old value.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can add new key-value pairs at any time. This syntax is identical to modifying existing values.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The new dictionary item (key &amp;lsquo;user&amp;rsquo;, value &amp;lsquo;mark&amp;rsquo;) appears to be in the middle. In fact, it was just a coincidence that the items appeared to be in order in the first example; it is just as much a coincidence that they appear to be out of order now.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Assigning a value to an existing dictionary key simply replaces the old value with the new one.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Will this change the value of the user key back to &amp;ldquo;mark&amp;rdquo;? No! Look at the key closely — that’s a capital U in &amp;ldquo;User&amp;rdquo;. Dictionary keys are case-sensitive, so this statement is creating a new key-value pair, not overwriting an existing one. It may look similar to you, but as far as Python is concerned, it’s completely different.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.7.3. MIXED-VALUE DICTIONARIES
Dictionaries aren’t just for strings. Dictionary values can be any datatype, including integers, booleans, arbitrary objects, or even other dictionaries. And within a single dictionary, the values don’t all need to be the same type; you can mix and match as needed. Dictionary keys are more restricted, but they can be strings, integers, and a few other types. You can also mix and match key datatypes within a dictionary.
In fact, you’ve already seen a dictionary with non-string keys and values, in your
first
Python
program.
SUFFIXES = {1000: [&amp;lsquo;KB&amp;rsquo;, &amp;lsquo;MB&amp;rsquo;, &amp;lsquo;GB&amp;rsquo;, &amp;lsquo;TB&amp;rsquo;, &amp;lsquo;PB&amp;rsquo;, &amp;lsquo;EB&amp;rsquo;, &amp;lsquo;ZB&amp;rsquo;, &amp;lsquo;YB&amp;rsquo;],
1024: [&amp;lsquo;KiB&amp;rsquo;, &amp;lsquo;MiB&amp;rsquo;, &amp;lsquo;GiB&amp;rsquo;, &amp;lsquo;TiB&amp;rsquo;, &amp;lsquo;PiB&amp;rsquo;, &amp;lsquo;EiB&amp;rsquo;, &amp;lsquo;ZiB&amp;rsquo;, &amp;lsquo;YiB&amp;rsquo;]}&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s tear that apart in the interactive shell.
&amp;gt;&amp;gt;&amp;gt; SUFFIXES = {1000: [&amp;lsquo;KB&amp;rsquo;, &amp;lsquo;MB&amp;rsquo;, &amp;lsquo;GB&amp;rsquo;, &amp;lsquo;TB&amp;rsquo;, &amp;lsquo;PB&amp;rsquo;, &amp;lsquo;EB&amp;rsquo;, &amp;lsquo;ZB&amp;rsquo;, &amp;lsquo;YB&amp;rsquo;],
&amp;hellip; 1024: [&amp;lsquo;KiB&amp;rsquo;, &amp;lsquo;MiB&amp;rsquo;, &amp;lsquo;GiB&amp;rsquo;, &amp;lsquo;TiB&amp;rsquo;, &amp;lsquo;PiB&amp;rsquo;, &amp;lsquo;EiB&amp;rsquo;, &amp;lsquo;ZiB&amp;rsquo;, &amp;lsquo;YiB&amp;rsquo;]}
&amp;gt;&amp;gt;&amp;gt; len(SUFFIXES) .
2
&amp;gt;&amp;gt;&amp;gt; 1000 in SUFFIXES .
True
&amp;gt;&amp;gt;&amp;gt; SUFFIXES[1000] .
[&amp;lsquo;KB&amp;rsquo;, &amp;lsquo;MB&amp;rsquo;, &amp;lsquo;GB&amp;rsquo;, &amp;lsquo;TB&amp;rsquo;, &amp;lsquo;PB&amp;rsquo;, &amp;lsquo;EB&amp;rsquo;, &amp;lsquo;ZB&amp;rsquo;, &amp;lsquo;YB&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; SUFFIXES[1024] .
[&amp;lsquo;KiB&amp;rsquo;, &amp;lsquo;MiB&amp;rsquo;, &amp;lsquo;GiB&amp;rsquo;, &amp;lsquo;TiB&amp;rsquo;, &amp;lsquo;PiB&amp;rsquo;, &amp;lsquo;EiB&amp;rsquo;, &amp;lsquo;ZiB&amp;rsquo;, &amp;lsquo;YiB&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; SUFFIXES[1000][3] .
&amp;lsquo;TB&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Like lists
and sets, the len() function gives you the number of keys in a dictionary.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And like lists and sets, you can use the in operator to test whether a specific key is defined in a dictionary.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1000 is a key in the SUFFIXES dictionary; its value is a list of eight items (eight strings, to be precise).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Similarly, 1024 is a key in the SUFFIXES dictionary; its value is also a list of eight items.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Since SUFFIXES[1000] is a list, you can address individual items in the list by their 0-based index.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.7.4. DICTIONARIES IN A BOOLEAN CONTEXT&lt;/p&gt;

&lt;p&gt;You can also use a dictionary in a
boolean
context, such as an if statement.
&amp;gt;&amp;gt;&amp;gt; def is_it_true(anything):
&amp;hellip; if anything:
&amp;hellip; print(&amp;ldquo;yes, it&amp;rsquo;s true&amp;rdquo;)
&amp;hellip; else:
&amp;hellip; print(&amp;ldquo;no, it&amp;rsquo;s false&amp;rdquo;)
&amp;hellip;
&amp;gt;&amp;gt;&amp;gt; is_it_true({}) .
no, it&amp;rsquo;s false
&amp;gt;&amp;gt;&amp;gt; is_it_true({&amp;lsquo;a&amp;rsquo;: 1}) .
yes, it&amp;rsquo;s true&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In a boolean context, an empty dictionary is false.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any dictionary with at least one key-value pair is true.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;2.8. None
None is a special constant in Python. It is a null value. None is not the same as False. None is not 0. None is not an empty string. Comparing None to anything other than None will always return False.
None is the only null value. It has its own datatype (NoneType). You can assign None to any variable, but you can not create other NoneType objects. All variables whose value is None are equal to each other.
&amp;gt;&amp;gt;&amp;gt; type(None)&lt;/p&gt;

&lt;p&gt;&lt;class &#39;NoneType&#39;&gt;
&amp;gt;&amp;gt;&amp;gt; None == False
False
&amp;gt;&amp;gt;&amp;gt; None == 0
False
&amp;gt;&amp;gt;&amp;gt; None == &amp;ldquo;
False
&amp;gt;&amp;gt;&amp;gt; None == None
True
&amp;gt;&amp;gt;&amp;gt; x = None
&amp;gt;&amp;gt;&amp;gt; x == None
True
&amp;gt;&amp;gt;&amp;gt; y = None
&amp;gt;&amp;gt;&amp;gt; x == y
True&lt;/p&gt;

&lt;p&gt;2.8.1. None IN A BOOLEAN CONTEXT
In a
boolean
context, None is false and not None is true.
&amp;gt;&amp;gt;&amp;gt; def is_it_true(anything):&lt;/p&gt;

&lt;p&gt;&amp;hellip;  if anything:&lt;br /&gt;
&amp;hellip;  print(&amp;ldquo;yes, it&amp;rsquo;s true&amp;rdquo;)&lt;br /&gt;
&amp;hellip;  else:&lt;br /&gt;
&amp;hellip;  print(&amp;ldquo;no, it&amp;rsquo;s false&amp;rdquo;)&lt;br /&gt;
&amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;is_it_true(None)
no, it&amp;rsquo;s false
is_it_true(not None)
yes, it&amp;rsquo;s true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;2.9. FURTHER READING
• Boolean
operations&lt;/p&gt;

&lt;p&gt;• Numeric
types&lt;/p&gt;

&lt;p&gt;• Sequence
types&lt;/p&gt;

&lt;p&gt;• Set
types&lt;/p&gt;

&lt;p&gt;• Mapping
types&lt;/p&gt;

&lt;p&gt;• fractions module&lt;/p&gt;

&lt;p&gt;• math module&lt;/p&gt;

&lt;p&gt;• PEP
237:
Unifying
Long
Integers
and
Integers&lt;/p&gt;

&lt;p&gt;• PEP
238:
Changing
the
Division
Operator&lt;/p&gt;

&lt;p&gt;CHAPTER 3. COMPREHENSIONS&lt;/p&gt;

&lt;p&gt;. Our imagination is stretched to the utmost, not, as in fiction, to imagine things which are not really there, but just to comprehend those things which are. .
— Richard Feynman&lt;/p&gt;

&lt;p&gt;3.1. DIVING IN
Every programming language has that one feature, a complicated thing intentionally made simple. If you’re coming from another language, you could easily miss it, because your old language didn’t make that thing simple (because it was busy making something else simple instead). This chapter will teach you about list comprehensions, dictionary comprehensions, and set comprehensions: three related concepts centered around one very powerful technique. But first, I want to take a little detour into two modules that will help you navigate your local file system.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;3.2. WORKING WITH FILES AND DIRECTORIES
Python 3 comes with a module called os, which stands for “operating system.” The os module
contains a plethora of functions to get information on — and in some cases, to manipulate — local directories, files, processes, and environment variables. Python does its best to offer a unified API across all
supported
operating
systems
so your programs can run on any computer with as little platform-specific code as possible.
3.2.1. THE CURRENT WORKING DIRECTORY&lt;/p&gt;

&lt;p&gt;When you’re just getting started with Python, you’re going to spend a lot of time in the
Python
Shell. Throughout this book, you will see examples that go like this:
1. Import one of the modules in the examples folder&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Call a function in that module&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Explain the result&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you don’t know about the current working directory,
step 1 will probably fail with an ImportError. Why?
Because Python will look for the example module in the&lt;/p&gt;

&lt;p&gt;import
search
path, but it won’t find it because the
examples folder isn’t one of the directories in the
search path. To get past this, you can do one of two
things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Add the examples folder to the import search path&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Change the current working directory to the examples folder&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The current working directory is an invisible property that Python holds in memory at all times. There is always a current working directory, whether you’re in the Python Shell, running your own Python script from the command line, or running a Python CGI script on a web server somewhere.&lt;/p&gt;

&lt;p&gt;The os module contains two functions to deal with the current working directory.
&amp;gt;&amp;gt;&amp;gt; import os .
&amp;gt;&amp;gt;&amp;gt; print(os.getcwd()) .
C:\Python31
&amp;gt;&amp;gt;&amp;gt; os.chdir(&amp;lsquo;/Users/pilgrim/diveintopython3/examples&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; print(os.getcwd()) .
C:\Users\pilgrim\diveintopython3\examples&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The os module comes with Python; you can import it anytime, anywhere.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use the os.getcwd() function to get the current working directory. When you run the graphical Python Shell, the current working directory starts as the directory where the Python Shell executable is. On Windows, this depends on where you installed Python; the default directory is c:\Python31. If you run the Python Shell from the command line, the current working directory starts as the directory you were in when you ran python3.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use the os.chdir() function to change the current working directory.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When I called the os.chdir() function, I used a Linux-style pathname (forward slashes, no drive letter) even though I’m on Windows. This is one of the places where Python tries to paper over the differences between operating systems.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.2.2. WORKING WITH FILENAMES AND DIRECTORY NAMES
While we’re on the subject of directories, I want to point out the os.path module. os.path contains
functions for manipulating filenames and directory names.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import os&lt;/p&gt;

&lt;p&gt;print(os.path.join(&amp;lsquo;/Users/pilgrim/diveintopython3/examples/&amp;rsquo;, &amp;lsquo;humansize.py&amp;rsquo;))
/Users/pilgrim/diveintopython3/examples/humansize.py&lt;/p&gt;

&lt;p&gt;print(os.path.join(&amp;lsquo;/Users/pilgrim/diveintopython3/examples&amp;rsquo;, &amp;lsquo;humansize.py&amp;rsquo;))
/Users/pilgrim/diveintopython3/examples\humansize.py&lt;/p&gt;

&lt;p&gt;print(os.path.expanduser(&amp;rsquo;~&amp;lsquo;))
c:\Users\pilgrim&lt;/p&gt;

&lt;p&gt;print(os.path.join(os.path.expanduser(&amp;rsquo;~&amp;lsquo;), &amp;lsquo;diveintopython3&amp;rsquo;, &amp;lsquo;examples&amp;rsquo;, &amp;lsquo;humansize.py&amp;rsquo;))
c:\Users\pilgrim\diveintopython3\examples\humansize.py&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The os.path.join() function constructs a pathname out of one or more partial pathnames. In this case, it simply concatenates strings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In this slightly less trivial case, calling the os.path.join() function will add an extra slash to the pathname before joining it to the filename. It’s a backslash instead of a forward slash, because I constructed this example on Windows. If you replicate this example on Linux or Mac OS X, you’ll see a forward slash instead. Don’t fuss with slashes; always use os.path.join() and let Python do the right thing.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The os.path.expanduser() function will expand a pathname that uses ~ to represent the current user’s home directory. This works on any platform where users have a home directory, including Linux, Mac OS X, and Windows. The returned path does not have a trailing slash, but the os.path.join() function doesn’t mind.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Combining these techniques, you can easily construct pathnames for directories and files in the user’s home directory. The os.path.join() function can take any number of arguments. I was overjoyed when I discovered this, since addSlashIfNecessary() is one of the stupid little functions I always need to write when building up my toolbox in a new language. Do not write this stupid little function in Python; smart people have already taken care of it for you.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;os.path also contains functions to split full pathnames, directory names, and filenames into their constituent parts.
&amp;gt;&amp;gt;&amp;gt; pathname = &amp;lsquo;/Users/pilgrim/diveintopython3/examples/humansize.py&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; os.path.split(pathname) .
(&amp;lsquo;/Users/pilgrim/diveintopython3/examples&amp;rsquo;, &amp;lsquo;humansize.py&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; (dirname, filename) = os.path.split(pathname) .
&amp;gt;&amp;gt;&amp;gt; dirname .
&amp;lsquo;/Users/pilgrim/diveintopython3/examples&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; filename .
&amp;lsquo;humansize.py&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; (shortname, extension) = os.path.splitext(filename) .
&amp;gt;&amp;gt;&amp;gt; shortname
&amp;lsquo;humansize&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; extension
&amp;lsquo;.py&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The split function splits a full pathname and returns a tuple containing the path and filename.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Remember when I said you could use multi-variable
assignment
to return multiple values from a function? The os.path.split() function does exactly that. You assign the return value of the split function into a tuple of two variables. Each variable receives the value of the corresponding element of the returned tuple.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The first variable, dirname, receives the value of the first element of the tuple returned from the os.path.split() function, the file path.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The second variable, filename, receives the value of the second element of the tuple returned from the os.path.split() function, the filename.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;os.path also contains the os.path.splitext() function, which splits a filename and returns a tuple containing the filename and the file extension. You use the same technique to assign each of them to separate variables.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.2.3. LISTING DIRECTORIES
The glob module is another tool in the Python standard library. It’s an easy way to get the contents of a directory programmatically, and it uses the sort of wildcards that you may already be familiar with from working on the command line.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;os.chdir(&amp;lsquo;/Users/pilgrim/diveintopython3/&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;import glob
glob.glob(&amp;lsquo;examples/*.xml&amp;rsquo;) .
[&amp;lsquo;examples\feed-broken.xml&amp;rsquo;,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;lsquo;examples\feed-ns0.xml&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;examples\feed.xml&amp;rsquo;]&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;os.chdir(&amp;lsquo;examples/&amp;rsquo;)   .
glob.glob(&amp;rsquo;&lt;em&gt;test&lt;/em&gt;.py&amp;rsquo;)  .
[&amp;lsquo;alphameticstest.py&amp;rsquo;,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;lsquo;pluraltest1.py&amp;rsquo;,
&amp;lsquo;pluraltest2.py&amp;rsquo;,
&amp;lsquo;pluraltest3.py&amp;rsquo;,
&amp;lsquo;pluraltest4.py&amp;rsquo;,
&amp;lsquo;pluraltest5.py&amp;rsquo;,
&amp;lsquo;pluraltest6.py&amp;rsquo;,
&amp;lsquo;romantest1.py&amp;rsquo;,
&amp;lsquo;romantest10.py&amp;rsquo;,
&amp;lsquo;romantest2.py&amp;rsquo;,
&amp;lsquo;romantest3.py&amp;rsquo;,
&amp;lsquo;romantest4.py&amp;rsquo;,
&amp;lsquo;romantest5.py&amp;rsquo;,
&amp;lsquo;romantest6.py&amp;rsquo;,
&amp;lsquo;romantest7.py&amp;rsquo;,
&amp;lsquo;romantest8.py&amp;rsquo;,
&amp;lsquo;romantest9.py&amp;rsquo;]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The glob module takes a wildcard and returns the path of all files and directories matching the wildcard. In this example, the wildcard is a directory path plus “*.xml”, which will match all .xml files in the examples subdirectory.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now change the current working directory to the examples subdirectory. The os.chdir() function can take relative pathnames.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can include multiple wildcards in your glob pattern. This example finds all the files in the current working directory that end in a .py extension and contain the word test anywhere in their filename.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.2.4. GETTING FILE METADATA&lt;/p&gt;

&lt;p&gt;Every modern file system stores metadata about each file: creation date, last-modified date, file size, and so on. Python provides a single API to access this metadata. You don’t need to open the file; all you need is the filename.
&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; print(os.getcwd()) .
c:\Users\pilgrim\diveintopython3\examples
&amp;gt;&amp;gt;&amp;gt; metadata = os.stat(&amp;lsquo;feed.xml&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; metadata.st_mtime .
1247520344.9537716
&amp;gt;&amp;gt;&amp;gt; import time .
&amp;gt;&amp;gt;&amp;gt; time.localtime(metadata.st_mtime) .
time.struct_time(tm_year=2009, tm_mon=7, tm_mday=13, tm_hour=17,&lt;/p&gt;

&lt;p&gt;tm_min=25, tm_sec=44, tm_wday=0, tm_yday=194, tm_isdst=1)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The current working directory is the examples folder.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;feed.xml is a file in the examples folder. Calling the os.stat() function returns an object that contains several different types of metadata about the file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;st_mtime is the modification time, but it’s in a format that isn’t terribly useful. (Technically, it’s the number of seconds since the Epoch, which is defined as the first second of January 1st, 1970. Seriously.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The time module is part of the Python standard library. It contains functions to convert between different time representations, format time values into strings, and fiddle with timezones.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The time.localtime() function converts a time value from seconds-since-the-Epoch (from the st_mtime property returned from the os.stat() function) into a more useful structure of year, month, day, hour, minute, second, and so on. This file was last modified on July 13, 2009, at around 5:25 PM.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-2:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;metadata.st_size .
3070
import humansize
humansize.approximate_size(metadata.st_size) .
&amp;lsquo;3.0 KiB&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The os.stat() function also returns the size of a file, in the st_size property. The file feed.xml is 3070 bytes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can pass the st_size property to the approximate_size() function.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.2.5. CONSTRUCTING ABSOLUTE PATHNAMES
In the
previous
section, the glob.glob() function returned a list of relative pathnames. The first example had pathnames like &amp;lsquo;examples\feed.xml&amp;rsquo;, and the second example had even shorter relative pathnames like &amp;lsquo;romantest1.py&amp;rsquo;. As long as you stay in the same current working directory, these relative pathnames will work for opening files or getting file metadata. But if you want to construct an absolute pathname — i.e. one that includes all the directory names back to the root directory or drive letter — then you’ll need the os.path.realpath() function.
&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; print(os.getcwd())
c:\Users\pilgrim\diveintopython3\examples
&amp;gt;&amp;gt;&amp;gt; print(os.path.realpath(&amp;lsquo;feed.xml&amp;rsquo;))
c:\Users\pilgrim\diveintopython3\examples\feed.xml&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;3.3. LIST COMPREHENSIONS&lt;/p&gt;

&lt;p&gt;A list comprehension provides a compact way of mapping a list into another list by applying a function to
each of the elements of the list.
&amp;gt;&amp;gt;&amp;gt; a_list = [1, 9, 8, 4]&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;[elem * 2 for elem in a_list] .
[2, 18, 16, 8]
a_list .
[1, 9, 8, 4]
a_list = [elem * 2 for elem in a_list] .
a_list
[2, 18, 16, 8]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To make sense of this, look at it from right to left. a_list is the list you’re mapping. The Python interpreter loops through a_list one element at a time, temporarily assigning the value of each element to the variable elem. Python then applies the function elem * 2 and appends that result to the returned list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A list comprehension creates a new list; it does not change the original list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It is safe to assign the result of a list comprehension to the variable that you’re mapping. Python constructs the new list in memory, and when the list comprehension is complete, it assigns the result to the original variable.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can use any Python expression in a list comprehension, including the functions in the os module for manipulating files and directories.
&amp;gt;&amp;gt;&amp;gt; import os, glob
&amp;gt;&amp;gt;&amp;gt; glob.glob(&amp;rsquo;&lt;em&gt;.xml&amp;rsquo;) .
[&amp;lsquo;feed-broken.xml&amp;rsquo;, &amp;lsquo;feed-ns0.xml&amp;rsquo;, &amp;lsquo;feed.xml&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; [os.path.realpath(f) for f in glob.glob(&amp;rsquo;&lt;/em&gt;.xml&amp;rsquo;)] .
[&amp;lsquo;c:\Users\pilgrim\diveintopython3\examples\feed-broken.xml&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;c:\Users\pilgrim\diveintopython3\examples\feed-ns0.xml&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;c:\Users\pilgrim\diveintopython3\examples\feed.xml&amp;rsquo;]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This returns a list of all the .xml files in the current working directory.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This list comprehension takes that list of .xml files and transforms it into a list of full pathnames.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;List comprehensions can also filter items, producing a result that can be smaller than the original list.
&amp;gt;&amp;gt;&amp;gt; import os, glob
&amp;gt;&amp;gt;&amp;gt; [f for f in glob.glob(&amp;rsquo;*.py&amp;rsquo;) if os.stat(f).st_size &amp;gt; 6000] .
[&amp;lsquo;pluraltest6.py&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;romantest10.py&amp;rsquo;,
&amp;lsquo;romantest6.py&amp;rsquo;,
&amp;lsquo;romantest7.py&amp;rsquo;,
&amp;lsquo;romantest8.py&amp;rsquo;,
&amp;lsquo;romantest9.py&amp;rsquo;]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;To filter a list, you can include an if clause at the end of the list comprehension. The expression after the if keyword will be evaluated for each item in the list. If the expression evaluates to True, the item will be included in the output. This list comprehension looks at the list of all .py files in the current directory, and the if expression filters that list by testing whether the size of each file is greater than 6000 bytes. There are six such files, so the list comprehension returns a list of six filenames.
All the examples of list comprehensions so far have featured simple expressions — multiply a number by a constant, call a single function, or simply return the original list item (after filtering). But there’s no limit to how complex a list comprehension can be.
&amp;gt;&amp;gt;&amp;gt; import os, glob
&amp;gt;&amp;gt;&amp;gt; [(os.stat(f).st_size, os.path.realpath(f)) for f in glob.glob(&amp;rsquo;*.xml&amp;rsquo;)] .
[(3074, &amp;lsquo;c:\Users\pilgrim\diveintopython3\examples\feed-broken.xml&amp;rsquo;),&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(3386, &amp;lsquo;c:\Users\pilgrim\diveintopython3\examples\feed-ns0.xml&amp;rsquo;),&lt;/p&gt;

&lt;p&gt;(3070, &amp;lsquo;c:\Users\pilgrim\diveintopython3\examples\feed.xml&amp;rsquo;)] &amp;gt;&amp;gt;&amp;gt; import humansize &amp;gt;&amp;gt;&amp;gt; [(humansize.approximate_size(os.stat(f).st_size), f) for f in glob.glob(&amp;rsquo;*.xml&amp;rsquo;)] . [(&amp;lsquo;3.0 KiB&amp;rsquo;, &amp;lsquo;feed-broken.xml&amp;rsquo;),
(&amp;lsquo;3.3 KiB&amp;rsquo;, &amp;lsquo;feed-ns0.xml&amp;rsquo;),
(&amp;lsquo;3.0 KiB&amp;rsquo;, &amp;lsquo;feed.xml&amp;rsquo;)]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This list comprehension finds all the .xml files in the current working directory, gets the size of each file (by calling the os.stat() function), and constructs a tuple of the file size and the absolute path of each file (by calling the os.path.realpath() function).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This comprehension builds on the previous one to call the approximate_size() function
with the file size of each .xml file.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;3.4. DICTIONARY COMPREHENSIONS
A dictionary comprehension is like a list comprehension, but it constructs a dictionary instead of a list.
&amp;gt;&amp;gt;&amp;gt; import os, glob
&amp;gt;&amp;gt;&amp;gt; metadata = [(f, os.stat(f)) for f in glob.glob(&amp;rsquo;&lt;em&gt;test&lt;/em&gt;.py&amp;rsquo;)] .
&amp;gt;&amp;gt;&amp;gt; metadata[0] .
(&amp;lsquo;alphameticstest.py&amp;rsquo;, nt.stat_result(st_mode=33206, st_ino=0, st_dev=0,&lt;/p&gt;

&lt;p&gt;st_nlink=0, st_uid=0, st_gid=0, st_size=2509, st_atime=1247520344,&lt;/p&gt;

&lt;p&gt;st_mtime=1247520344, st_ctime=1247520344))
&amp;gt;&amp;gt;&amp;gt; metadata_dict = {f:os.stat(f) for f in glob.glob(&amp;rsquo;&lt;em&gt;test&lt;/em&gt;.py&amp;rsquo;)} .
&amp;gt;&amp;gt;&amp;gt; type(metadata_dict) .
&lt;class &#39;dict&#39;&gt;
&amp;gt;&amp;gt;&amp;gt; list(metadata_dict.keys()) .
[&amp;lsquo;romantest8.py&amp;rsquo;, &amp;lsquo;pluraltest1.py&amp;rsquo;, &amp;lsquo;pluraltest2.py&amp;rsquo;, &amp;lsquo;pluraltest5.py&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;pluraltest6.py&amp;rsquo;, &amp;lsquo;romantest7.py&amp;rsquo;, &amp;lsquo;romantest10.py&amp;rsquo;, &amp;lsquo;romantest4.py&amp;rsquo;,
&amp;lsquo;romantest9.py&amp;rsquo;, &amp;lsquo;pluraltest3.py&amp;rsquo;, &amp;lsquo;romantest1.py&amp;rsquo;, &amp;lsquo;romantest2.py&amp;rsquo;,
&amp;lsquo;romantest3.py&amp;rsquo;, &amp;lsquo;romantest5.py&amp;rsquo;, &amp;lsquo;romantest6.py&amp;rsquo;, &amp;lsquo;alphameticstest.py&amp;rsquo;,
&amp;lsquo;pluraltest4.py&amp;rsquo;]&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;metadata_dict[&amp;lsquo;alphameticstest.py&amp;rsquo;].st_size .
2509&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This is not a dictionary comprehension; it’s a list
comprehension. It finds all .py files with test in their name, then constructs a tuple of the filename and the file metadata (from calling the os.stat() function).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Each item of the resulting list is a tuple.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is a dictionary comprehension. The syntax is similar to a list comprehension, with two differences. First, it is enclosed in curly braces instead of square brackets. Second, instead of a single expression for each item, it contains two expressions separated by a colon. The expression before the colon (f in this example) is the dictionary key; the expression after the colon (os.stat(f) in this example) is the value.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A dictionary comprehension returns a dictionary.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The keys of this particular dictionary are simply the filenames returned from the call to glob.glob(&amp;rsquo;&lt;em&gt;test&lt;/em&gt;.py&amp;rsquo;).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The value associated with each key is the return value from the os.stat() function. That means we can “look up” a file by name in this dictionary to get its file metadata. One of the pieces of metadata is st_size, the file size. The file alphameticstest.py is 2509 bytes long.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Like list comprehensions, you can include an if clause in a dictionary comprehension to filter the input sequence based on an expression which is evaluated with each item.
&amp;gt;&amp;gt;&amp;gt; import os, glob, humansize
&amp;gt;&amp;gt;&amp;gt; metadata_dict = {f:os.stat(f) for f in glob.glob(&amp;rsquo;*&amp;lsquo;)} .
&amp;gt;&amp;gt;&amp;gt; humansize_dict = {os.path.splitext(f)[0]:humansize.approximate_size(meta.st_size) \
&amp;hellip; for f, meta in metadata_dict.items() if meta.st_size &amp;gt; 6000} .
&amp;gt;&amp;gt;&amp;gt; list(humansize_dict.keys()) .
[&amp;lsquo;romantest9&amp;rsquo;, &amp;lsquo;romantest8&amp;rsquo;, &amp;lsquo;romantest7&amp;rsquo;, &amp;lsquo;romantest6&amp;rsquo;, &amp;lsquo;romantest10&amp;rsquo;, &amp;lsquo;pluraltest6&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; humansize_dict[&amp;lsquo;romantest9&amp;rsquo;] .
&amp;lsquo;6.5 KiB&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This dictionary comprehension constructs a list of all the files in the current working directory (glob.glob(&amp;rsquo;*&amp;lsquo;)), gets the file metadata for each file (os.stat(f)), and constructs a dictionary whose keys are filenames and whose values are the metadata for each file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This dictionary comprehension builds on the previous comprehension, filters out files smaller than 6000 bytes (if meta.st_size &amp;gt; 6000), and uses that filtered list to construct a dictionary whose keys are the filename minus the extension (os.path.splitext(f)[0]) and whose values are the approximate size of each file (humansize.approximate_size(meta.st_size)).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As you saw in a previous example, there are six such files, thus there are six items in this dictionary.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The value of each key is the string returned from the approximate_size() function.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.4.1. OTHER FUN STUFF TO DO WITH DICTIONARY COMPREHENSIONS
Here’s a trick with dictionary comprehensions that might be useful someday: swapping the keys and values of a dictionary.
&amp;gt;&amp;gt;&amp;gt; a_dict = {&amp;lsquo;a&amp;rsquo;: 1, &amp;lsquo;b&amp;rsquo;: 2, &amp;lsquo;c&amp;rsquo;: 3}
&amp;gt;&amp;gt;&amp;gt; {value:key for key, value in a_dict.items()}&lt;/p&gt;

&lt;p&gt;{1: &amp;lsquo;a&amp;rsquo;, 2: &amp;lsquo;b&amp;rsquo;, 3: &amp;lsquo;c&amp;rsquo;}&lt;/p&gt;

&lt;p&gt;Of course, this only works if the values of the dictionary are immutable, like strings or tuples. If you try this with a dictionary that contains lists, it will fail most spectacularly.
&amp;gt;&amp;gt;&amp;gt; a_dict = {&amp;lsquo;a&amp;rsquo;: [1, 2, 3], &amp;lsquo;b&amp;rsquo;: 4, &amp;lsquo;c&amp;rsquo;: 5}&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;{value:key for key, value in a_dict.items()}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;dictcomp&gt;&lt;/p&gt;

&lt;p&gt;TypeError: unhashable type: &amp;lsquo;list&amp;rsquo;&lt;/p&gt;

&lt;p&gt;.
3.5. SET COMPREHENSIONS
Not to be left out, sets have their own comprehension syntax as well. It is remarkably similar to the syntax for dictionary comprehensions. The only difference is that sets just have values instead of key:value pairs.
&amp;gt;&amp;gt;&amp;gt; a_set = set(range(10))
&amp;gt;&amp;gt;&amp;gt; a_set
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
&amp;gt;&amp;gt;&amp;gt; {x ** 2 for x in a_set} .
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}
&amp;gt;&amp;gt;&amp;gt; {x for x in a_set if x % 2 == 0} .
{0, 8, 2, 4, 6}
&amp;gt;&amp;gt;&amp;gt; {2**x for x in range(10)} .
{32, 1, 2, 4, 8, 64, 128, 256, 16, 512}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Set comprehensions can take a set as input. This set comprehension calculates the squares of the set of numbers from 0 to 9.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Like list comprehensions and dictionary comprehensions, set comprehensions can contain an if clause to filter each item before returning it in the result set.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set comprehensions do not need to take a set as input; they can take any sequence.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;3.6. FURTHER READING
• os module
• os —
Portable
access
to
operating
system
specific
features
• os.path module
• os.path —
Platform-independent
manipulation
of
file
names&lt;/p&gt;

&lt;p&gt;• glob module&lt;/p&gt;

&lt;p&gt;• glob —
Filename
pattern
matching&lt;/p&gt;

&lt;p&gt;• time module&lt;/p&gt;

&lt;p&gt;• time —
Functions
for
manipulating
clock
time&lt;/p&gt;

&lt;p&gt;• List
comprehensions&lt;/p&gt;

&lt;p&gt;• Nested
list
comprehensions&lt;/p&gt;

&lt;p&gt;• Looping
techniques&lt;/p&gt;

&lt;p&gt;CHAPTER 4. STRINGS&lt;/p&gt;

&lt;p&gt;. I’m telling you this ’cause you’re one of my friends.
My alphabet starts where your alphabet ends! .
— Dr. Seuss, On Beyond Zebra!&lt;/p&gt;

&lt;p&gt;4.1. SOME BORING STUFF YOU NEED TO UNDERSTAND BEFORE YOU CAN DIVE IN
Few people think about it, but text is incredibly complicated. Start with the alphabet. The people of Bougainville
have the smallest alphabet in the world; their Rotokas
alphabet
is composed of only 12 letters: A, E, G, I, K, O, P, R, S, T, U, and V. On the other end of the spectrum, languages like Chinese, Japanese, and Korean have thousands of characters. English, of course, has 26 letters — 52 if you count uppercase and lowercase separately — plus a handful of !@#$%&amp;amp; punctuation marks.&lt;/p&gt;

&lt;p&gt;When you talk about “text,” you’re probably thinking of “characters and symbols on my computer screen.” But computers don’t deal in characters and symbols; they deal in bits and bytes. Every piece of text you’ve ever seen on a computer screen is actually stored in a particular character encoding. Very roughly speaking, the character encoding provides a mapping between the stuff you see on your screen and the stuff your computer actually stores in memory and on disk. There are many different character encodings, some optimized for particular languages like Russian or Chinese or English, and others that can be used for multiple languages.&lt;/p&gt;

&lt;p&gt;In reality, it’s more complicated than that. Many characters are common to multiple encodings, but each encoding may use a different sequence of bytes to actually store those characters in memory or on disk. So you can think of the character encoding as a kind of decryption key. Whenever someone gives you a sequence of bytes — a file, a web page, whatever — and claims it’s “text,” you need to know what character encoding they used so you can decode the bytes into characters. If they give you the wrong key or no key at all, you’re left with the unenviable task of cracking the code yourself. Chances are you’ll get it wrong, and the result will be gibberish.&lt;/p&gt;

&lt;p&gt;Surely you’ve seen web pages like this, with strange question-mark-like characters where apostrophes should be. That usually means the page author didn’t declare their character encoding correctly, your browser was left guessing, and the result was a mix of expected and unexpected characters. In English it’s merely annoying; in other languages, the result can be completely unreadable.
There are character encodings for each major language in the world. Since each language is different, and memory and disk space have historically been expensive, each character encoding is optimized for a particular language. By that, I mean each encoding using the same numbers (0–255) to represent that language’s characters. For instance, you’re probably familiar with the ASCII encoding, which stores English characters as numbers ranging from 0 to 127. (65 is capital “A”, 97 is lowercase “a”, &amp;amp;c.) English has a very simple alphabet, so it can be completely expressed in less than 128 numbers. For those of you who can count in base 2, that’s 7 out of the 8 bits in a byte.&lt;/p&gt;

&lt;p&gt;Western European languages like French, Spanish, and German have more letters than English. Or, more precisely, they have letters combined with various diacritical marks, like the ñ character in Spanish. The most common encoding for these languages is CP-1252, also called “windows-1252” because it is widely used on Microsoft Windows. The CP-1252 encoding shares characters with ASCII in the 0–127 range, but then extends into the 128–255 range for characters like n-with-a-tilde-over-it (241), u-with-two-dots-over-it (252), &amp;amp;c. It’s still a single-byte encoding, though; the highest possible number, 255, still fits in one byte.
Then there are languages like Chinese, Japanese, and Korean, which have so many characters that they require multiple-byte character sets. That is, each “character” is represented by a two-byte number from 0–65535. But different multi-byte encodings still share the same problem as different single-byte encodings, namely that they each use the same numbers to mean different things. It’s just that the range of numbers is broader, because there are many more characters to represent.
That was mostly OK in a non-networked world, where “text” was something you typed yourself and occasionally printed. There wasn’t much “plain text”. Source code was ASCII, and everyone else used word processors, which defined their own (non-text) formats that tracked character encoding information along with rich styling, &amp;amp;c. People read these documents with the same word processing program as the original author, so everything worked, more or less.
Now think about the rise of global networks like email and the web. Lots of “plain text” flying around the globe, being authored on one computer, transmitted through a second computer, and received and displayed by a third computer. Computers can only see numbers, but the numbers could mean different things. Oh no! What to do? Well, systems had to be designed to carry encoding information along with every piece of “plain text.” Remember, it’s the decryption key that maps computer-readable numbers to human-readable characters. A missing decryption key means garbled text, gibberish, or worse.
Now think about trying to store multiple pieces of text in the same place, like in the same database table that holds all the email you’ve ever received. You still need to store the character encoding alongside each piece of text so you can display it properly. Think that’s hard? Try searching your email database, which means converting between multiple encodings on the fly. Doesn’t that sound fun?
Now think about the possibility of multilingual documents, where characters from several languages are next to each other in the same document. (Hint: programs that tried to do this typically used escape codes to switch “modes.” Poof, you’re in Russian koi8-r mode, so 241 means .; poof, now you’re in Mac Greek mode, so 241 means ..) And of course you’ll want to search those documents, too.
Now cry a lot, because everything you thought you knew about strings is wrong, and there ain’t no such thing as “plain text.”
.&lt;/p&gt;

&lt;p&gt;4.2. UNICODE
Enter Unicode.
Unicode is a system designed to represent every character from every language. Unicode represents each letter, character, or ideograph as a 4-byte number. Each number represents a unique character used in at least one of the world’s languages. (Not all the numbers are used, but more than 65535 of them are, so 2 bytes wouldn’t be sufficient.) Characters that are used in multiple languages generally have the same number, unless there is a good etymological reason not to. Regardless, there is exactly 1 number per character, and exactly 1 character per number. Every number always means just one thing; there are no “modes” to keep track of. U+0041 is always &amp;lsquo;A&amp;rsquo;, even if your language doesn’t have an &amp;lsquo;A&amp;rsquo; in it.
On the face of it, this seems like a great idea. One encoding to rule them all. Multiple languages per document. No more “mode switching” to switch between encodings mid-stream. But right away, the obvious question should leap out at you. Four bytes? For every single character. That seems awfully wasteful, especially for languages like English and Spanish, which need less than one byte (256 numbers) to express every possible character. In fact, it’s wasteful even for ideograph-based languages (like Chinese), which never need more than two bytes per character.
There is a Unicode encoding that uses four bytes per character. It’s called UTF-32, because 32 bits = 4 bytes. UTF-32 is a straightforward encoding; it takes each Unicode character (a 4-byte number) and represents the character with that same number. This has some advantages, the most important being that you can find the Nth character of a string in constant time, because the Nth character starts at the 4×Nth byte. It also has several disadvantages, the most obvious being that it takes four freaking bytes to store every freaking character.
Even though there are a lot of Unicode characters, it turns out that most people will never use anything beyond the first 65535. Thus, there is another Unicode encoding, called UTF-16 (because 16 bits = 2 bytes). UTF-16 encodes every character from 0–65535 as two bytes, then uses some dirty hacks if you actually need to represent the rarely-used “astral plane” Unicode characters beyond 65535. Most obvious advantage: UTF-16 is twice as space-efficient as UTF-32, because every character requires only two bytes to store instead of four bytes (except for the ones that don’t). And you can still easily find the Nth character of a string in constant time, if you assume that the string doesn’t include any astral plane characters, which is a good assumption right up until the moment that it’s not.
But there are also non-obvious disadvantages to both UTF-32 and UTF-16. Different computer systems store individual bytes in different ways. That means that the character U+4E2D could be stored in UTF-16 as either 4E 2D or 2D 4E, depending on whether the system is big-endian or little-endian. (For UTF-32, there are even more possible byte orderings.) As long as your documents never leave your computer, you’re safe — different applications on the same computer will all use the same byte order. But the minute you want to transfer documents between systems, perhaps on a world wide web of some sort, you’re going to need a way to indicate which order your bytes are stored. Otherwise, the receiving system has no way of knowing whether the two-byte sequence 4E 2D means U+4E2D or U+2D4E.
To solve this problem, the multi-byte Unicode encodings define a “Byte Order Mark,” which is a special non-printable character that you can include at the beginning of your document to indicate what order your bytes are in. For UTF-16, the Byte Order Mark is U+FEFF. If you receive a UTF-16 document that starts with the bytes FF FE, you know the byte ordering is one way; if it starts with FE FF, you know the byte ordering is reversed.
Still, UTF-16 isn’t exactly ideal, especially if you’re dealing with a lot of ASCII characters. If you think about it, even a Chinese web page is going to contain a lot of ASCII characters — all the elements and attributes surrounding the printable Chinese characters. Being able to find the Nth character in constant time is nice, but there’s still the nagging problem of those astral plane characters, which mean that you can’t guarantee that every character is exactly two bytes, so you can’t really find the Nth character in constant time unless you maintain a separate index. And boy, there sure is a lot of ASCII text in the world…
Other people pondered these questions, and they came up with a solution:
UTF-8&lt;/p&gt;

&lt;p&gt;UTF-8 is a variable-length encoding system for Unicode. That is, different characters take up a different number of bytes. For ASCII characters (A-Z, &amp;amp;c.) UTF-8 uses just one byte per character. In fact, it uses the exact same bytes; the first 128 characters (0–127) in UTF-8 are indistinguishable from ASCII. “Extended Latin” characters like ñ and ö end up taking two bytes. (The bytes are not simply the Unicode code point like they would be in UTF-16; there is some serious bit-twiddling involved.) Chinese characters like. end up taking three bytes. The rarely-used “astral plane” characters take four bytes.
Disadvantages: because each character can take a different number of bytes, finding the Nth character is an O(N) operation — that is, the longer the string, the longer it takes to find a specific character. Also, there is bit-twiddling involved to encode characters into bytes and decode bytes into characters.
Advantages: super-efficient encoding of common ASCII characters. No worse than UTF-16 for extended Latin characters. Better than UTF-32 for Chinese characters. Also (and you’ll have to trust me on this, because I’m not going to show you the math), due to the exact nature of the bit twiddling, there are no byte-ordering issues. A document encoded in UTF-8 uses the exact same stream of bytes on any computer.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;4.3. DIVING IN
In Python 3, all strings are sequences of Unicode characters. There is no such thing as a Python string encoded in UTF-8, or a Python string encoded as CP-1252. “Is this string UTF-8?” is an invalid question. UTF-8 is a way of encoding characters as a sequence of bytes. If you want to take a string and turn it into a sequence of bytes in a particular character encoding, Python 3 can help you with that. If you want to take a sequence of bytes and turn it into a string, Python 3 can help you with that too. Bytes are not characters; bytes are bytes. Characters are an abstraction. A string is a sequence of those abstractions.
&amp;gt;&amp;gt;&amp;gt; s = &amp;lsquo;.. Python&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; len(s) .
9
&amp;gt;&amp;gt;&amp;gt; s[0] .
&amp;lsquo;.&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; s + &amp;lsquo; 3&amp;rsquo; .
&amp;lsquo;.. Python 3&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;To create a string, enclose it in quotes. Python strings can be defined with either single quotes (&amp;lsquo;) or double quotes (&amp;ldquo;).&lt;/li&gt;
&lt;li&gt;The built-in len() function returns the length of the string, i.e. the number of characters. This is the same function you use to find
the
length
of
a
list,
tuple,
set,
or
dictionary. A string is like a tuple of characters.&lt;/li&gt;
&lt;li&gt;Just like getting individual items out of a list, you can get individual characters out of a string using index notation.&lt;/li&gt;
&lt;li&gt;Just like lists, you can concatenate strings using the + operator.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;4.4. FORMATTING STRINGS
Let’s take another look at humansize.py:&lt;/p&gt;

&lt;p&gt;SUFFIXES = {1000: [&amp;lsquo;KB&amp;rsquo;, &amp;lsquo;MB&amp;rsquo;, &amp;lsquo;GB&amp;rsquo;, &amp;lsquo;TB&amp;rsquo;, &amp;lsquo;PB&amp;rsquo;, &amp;lsquo;EB&amp;rsquo;, &amp;lsquo;ZB&amp;rsquo;, &amp;lsquo;YB&amp;rsquo;], . 1024: [&amp;lsquo;KiB&amp;rsquo;, &amp;lsquo;MiB&amp;rsquo;, &amp;lsquo;GiB&amp;rsquo;, &amp;lsquo;TiB&amp;rsquo;, &amp;lsquo;PiB&amp;rsquo;, &amp;lsquo;EiB&amp;rsquo;, &amp;lsquo;ZiB&amp;rsquo;, &amp;lsquo;YiB&amp;rsquo;]}
def approximate_size(size, a_kilobyte_is_1024_bytes=True): &amp;ldquo;&amp;lsquo;Convert a file size to human-readable form. .
Keyword arguments:
size &amp;ndash; file size in bytes
a_kilobyte_is_1024_bytes &amp;ndash; if True (default), use multiples of 1024&lt;/p&gt;

&lt;p&gt;if False, use multiples of 1000&lt;/p&gt;

&lt;p&gt;Returns: string&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;rsquo; . if size &amp;lt; 0: raise ValueError(&amp;lsquo;number must be non-negative&amp;rsquo;) .
multiple = 1024 if a_kilobyte_is_1024_bytes else 1000&lt;/p&gt;

&lt;p&gt;for suffix in SUFFIXES[multiple]:
size /= multiple
if size &amp;lt; multiple:&lt;/p&gt;

&lt;p&gt;return &amp;lsquo;{0:.1f} {1}&amp;lsquo;.format(size, suffix)   .
raise ValueError(&amp;lsquo;number too large&amp;rsquo;)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&amp;lsquo;KB&amp;rsquo;, &amp;lsquo;MB&amp;rsquo;, &amp;lsquo;GB&amp;rsquo;… those are each strings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function docstrings are strings. This docstring spans multiple lines, so it uses three-in-a-row quotes to start and end the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;These three-in-a-row quotes end the docstring.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There’s another string, being passed to the exception as a human-readable error message.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There’s a… whoa, what the heck is that?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Python 3 supports formatting values into strings. Although this can include very complicated expressions, the most basic usage is to insert a value into a string with a single placeholder.
&amp;gt;&amp;gt;&amp;gt; username = &amp;lsquo;mark&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; password = &amp;lsquo;PapayaWhip&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; &amp;ldquo;{0}&amp;rsquo;s password is {1}&amp;rdquo;.format(username, password) .
&amp;ldquo;mark&amp;rsquo;s password is PapayaWhip&amp;rdquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;No, my password is not really PapayaWhip.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There’s a lot going on here. First, that’s a method call on a string literal. Strings are objects, and objects have methods. Second, the whole expression evaluates to a string. Third, {0} and {1} are replacement fields, which are replaced by the arguments passed to the format() method.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;4.4.1. COMPOUND FIELD NAMES
The previous example shows the simplest case, where the replacement fields are simply integers. Integer replacement fields are treated as positional indices into the argument list of the format() method. That means that {0} is replaced by the first argument (username in this case), {1} is replaced by the second argument (password), &amp;amp;c. You can have as many positional indices as you have arguments, and you can have as many arguments as you want. But replacement fields are much more powerful than that.
&amp;gt;&amp;gt;&amp;gt; import humansize
&amp;gt;&amp;gt;&amp;gt; si_suffixes = humansize.SUFFIXES[1000] .
&amp;gt;&amp;gt;&amp;gt; si_suffixes
[&amp;lsquo;KB&amp;rsquo;, &amp;lsquo;MB&amp;rsquo;, &amp;lsquo;GB&amp;rsquo;, &amp;lsquo;TB&amp;rsquo;, &amp;lsquo;PB&amp;rsquo;, &amp;lsquo;EB&amp;rsquo;, &amp;lsquo;ZB&amp;rsquo;, &amp;lsquo;YB&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; &amp;lsquo;1000{0[0]} = 1{0[1]}&amp;lsquo;.format(si_suffixes) .
&amp;lsquo;1000KB = 1MB&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Rather than calling any function in the humansize module, you’re just grabbing one of the data structures it defines: the list of “SI” (powers-of-1000) suffixes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This looks complicated, but it’s not. {0} would refer to the first argument passed to the format() method, si_suffixes. But si_suffixes is a list. So {0[0]} refers to the first item of the list which is the first argument passed to the format() method: &amp;lsquo;KB&amp;rsquo;. Meanwhile, {0[1]} refers to the second item of the same list: &amp;lsquo;MB&amp;rsquo;. Everything outside the curly braces — including 1000, the equals sign, and the spaces — is untouched. The final result is the string &amp;lsquo;1000KB = 1MB&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What this example shows is that format specifiers can access items and properties of data structures using (almost) Python syntax. This is called compound field names. The following compound field names “just work”:
•   Passing a list, and accessing an item of the list by index (as in the previous example)&lt;/p&gt;

&lt;p&gt;•   Passing a dictionary, and accessing a value of the dictionary by key&lt;/p&gt;

&lt;p&gt;•   Passing a module, and accessing its variables and functions by name&lt;/p&gt;

&lt;p&gt;•   Passing a class instance, and accessing its properties and methods by name&lt;/p&gt;

&lt;p&gt;•   Any combination of the above&lt;/p&gt;

&lt;p&gt;Just to blow your mind, here’s an example that
combines all of the above:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import humansize
import sys&lt;/p&gt;

&lt;p&gt;&amp;lsquo;1MB = 1000{0.modules[humansize].SUFFIXES[1000][0]}&amp;lsquo;.format(sys)
&amp;lsquo;1MB = 1000KB&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here’s how it works:
•   The sys module holds information about the currently running Python instance. Since you just imported it, you can pass the sys module itself as an argument to the format() method. So the replacement field {0} refers to the sys module.&lt;/p&gt;

&lt;p&gt;•   sys.modules is a dictionary of all the modules that have been imported in this Python instance. The keys are the module names as strings; the values are the module objects themselves. So the replacement field {0.modules} refers to the dictionary of imported modules.&lt;/p&gt;

&lt;p&gt;•   sys.modules[&amp;lsquo;humansize&amp;rsquo;] is the humansize module which you just imported. The replacement field {0.modules[humansize]} refers to the humansize module. Note the slight difference in syntax here. In real Python code, the keys of the sys.modules dictionary are strings; to refer to them, you need to put quotes around the module name (e.g. &amp;lsquo;humansize&amp;rsquo;). But within a replacement field, you skip the quotes around the dictionary key name (e.g. humansize). To quote PEP
3101:
Advanced
String
Formatting, “The rules for parsing an item key are very simple. If it starts with a digit, then it is treated as a number, otherwise it is used as a string.”&lt;/p&gt;

&lt;p&gt;•   sys.modules[&amp;lsquo;humansize&amp;rsquo;].SUFFIXES is the dictionary defined at the top of the humansize module. The replacement field {0.modules[humansize].SUFFIXES} refers to that dictionary.&lt;/p&gt;

&lt;p&gt;•   sys.modules[&amp;lsquo;humansize&amp;rsquo;].SUFFIXES[1000] is a list of SI suffixes: [&amp;lsquo;KB&amp;rsquo;, &amp;lsquo;MB&amp;rsquo;, &amp;lsquo;GB&amp;rsquo;, &amp;lsquo;TB&amp;rsquo;, &amp;lsquo;PB&amp;rsquo;, &amp;lsquo;EB&amp;rsquo;, &amp;lsquo;ZB&amp;rsquo;, &amp;lsquo;YB&amp;rsquo;]. So the replacement field {0.modules[humansize].SUFFIXES[1000]} refers to that list.
•   sys.modules[&amp;lsquo;humansize&amp;rsquo;].SUFFIXES[1000][0] is the first item of the list of SI suffixes: &amp;lsquo;KB&amp;rsquo;. Therefore, the complete replacement field {0.modules[humansize].SUFFIXES[1000][0]} is replaced by the two-character string KB.&lt;/p&gt;

&lt;p&gt;4.4.2. FORMAT SPECIFIERS
But wait! There’s more! Let’s take another look at that strange line of code from humansize.py:
if size &amp;lt; multiple:
return &amp;lsquo;{0:.1f} {1}&amp;lsquo;.format(size, suffix)&lt;/p&gt;

&lt;p&gt;{1} is replaced with the second argument passed to the format() method, which is suffix. But what is {0:.1f}? It’s two things: {0}, which you recognize, and :.1f, which you don’t. The second half (including and after the colon) defines the format specifier, which further refines how the replaced variable should be formatted.
. Format specifiers allow you to munge the replacement text in a variety of useful ways, like the printf() function in C. You can add zero-or space-padding, align strings, control decimal precision, and even convert numbers to hexadecimal.
Within a replacement field, a colon (:) marks the start of the format specifier. The format specifier “.1” means “round to the nearest tenth” (i.e. display only one digit after the decimal point). The format specifier “f” means “fixed-point number” (as opposed to exponential notation or some other decimal representation). Thus, given a size of 698.24 and suffix of &amp;lsquo;GB&amp;rsquo;, the formatted string would be &amp;lsquo;698.2 GB&amp;rsquo;, because
698.24 gets rounded to one decimal place, then the suffix is appended after the number.
&amp;gt;&amp;gt;&amp;gt; &amp;lsquo;{0:.1f} {1}&amp;lsquo;.format(698.24, &amp;lsquo;GB&amp;rsquo;)
&amp;lsquo;698.2 GB&amp;rsquo;&lt;/p&gt;

&lt;p&gt;For all the gory details on format specifiers, consult the Format
Specification
Mini-Language
in the official Python documentation.
.&lt;/p&gt;

&lt;p&gt;4.5. OTHER COMMON STRING METHODS
Besides formatting, strings can do a number of other useful tricks.
&amp;gt;&amp;gt;&amp;gt; s = &amp;ldquo;&amp;lsquo;Finished files are the re-.
&amp;hellip; sult of years of scientif­&amp;hellip; ic study combined with the
&amp;hellip; experience of years.&amp;ldquo;&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; s.splitlines() .
[&amp;lsquo;Finished files are the re-&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;sult of years of scientif-&amp;rsquo;,
&amp;lsquo;ic study combined with the&amp;rsquo;,
&amp;lsquo;experience of years.&amp;rsquo;]&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;print(s.lower()) .
finished files are the re­sult of years of scientif­ic study combined with the
experience of years.
s.lower().count(&amp;lsquo;f&amp;rsquo;) .
6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You can input multiline strings in the Python interactive shell. Once you start a multiline string with triple quotation marks, just hit ENTER and the interactive shell will prompt you to continue the string. Typing the closing triple quotation marks ends the string, and the next ENTER will execute the command (in this case, assigning the string to s).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The splitlines() method takes one multiline string and returns a list of strings, one for each line of the original. Note that the carriage returns at the end of each line are not included.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The lower() method converts the entire string to lowercase. (Similarly, the upper() method converts a string to uppercase.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The count() method counts the number of occurrences of a substring. Yes, there really are six “f”s in that sentence!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here’s another common case. Let’s say you have a list of key-value pairs in the form key1=value1&amp;amp;key2=value2, and you want to split them up and make a dictionary of the form {key1: value1, key2: value2}.
&amp;gt;&amp;gt;&amp;gt; query = &amp;lsquo;user=pilgrim&amp;amp;database=master&amp;amp;password=PapayaWhip&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_list = query.split(&amp;rsquo;&amp;amp;&amp;lsquo;) .
&amp;gt;&amp;gt;&amp;gt; a_list
[&amp;lsquo;user=pilgrim&amp;rsquo;, &amp;lsquo;database=master&amp;rsquo;, &amp;lsquo;password=PapayaWhip&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; a_list_of_lists = [v.split(&amp;lsquo;=&amp;rsquo;, 1) for v in a_list if &amp;lsquo;=&amp;rsquo; in v] .
&amp;gt;&amp;gt;&amp;gt; a_list_of_lists
[[&amp;lsquo;user&amp;rsquo;, &amp;lsquo;pilgrim&amp;rsquo;], [&amp;lsquo;database&amp;rsquo;, &amp;lsquo;master&amp;rsquo;], [&amp;lsquo;password&amp;rsquo;, &amp;lsquo;PapayaWhip&amp;rsquo;]]
&amp;gt;&amp;gt;&amp;gt; a_dict = dict(a_list_of_lists) .
&amp;gt;&amp;gt;&amp;gt; a_dict
{&amp;lsquo;password&amp;rsquo;: &amp;lsquo;PapayaWhip&amp;rsquo;, &amp;lsquo;user&amp;rsquo;: &amp;lsquo;pilgrim&amp;rsquo;, &amp;lsquo;database&amp;rsquo;: &amp;lsquo;master&amp;rsquo;}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The split() string method has one required argument, a delimiter. The method splits a string into a list of strings based on the delimiter. Here, the delimiter is an ampersand character, but it could be anything.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now we have a list of strings, each with a key, followed by an equals sign, followed by a value. We can use a list
comprehension
to iterate over the entire list and split each string into two strings based on the first equals sign. The optional second argument to the split() method is the number of times you want to split. 1 means “only split once,” so the split() method will return a two-item list. (In theory, a value could contain an equals sign too. If you just used &amp;lsquo;key=value=foo&amp;rsquo;.split(&amp;lsquo;=&amp;rsquo;), you would end up with a three-item list [&amp;lsquo;key&amp;rsquo;, &amp;lsquo;value&amp;rsquo;, &amp;lsquo;foo&amp;rsquo;].)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, Python can turn that list-of-lists into a dictionary simply by passing it to the dict() function.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. The previous example looks a lot like parsing query parameters in a URL, but real-life URL parsing is actually more complicated than this. If you’re dealing with URL query parameters, you’re better off using the urllib.parse.parse_qs() function, which handles some non-obvious edge cases.
4.5.1. SLICING A STRING
Once you’ve defined a string, you can get any part of it as a new string. This is called slicing the string. Slicing strings works exactly the same as slicing
lists, which makes sense, because strings are just sequences of characters.
&amp;gt;&amp;gt;&amp;gt; a_string = &amp;lsquo;My alphabet starts where your alphabet ends.&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_string[3:11] .
&amp;lsquo;alphabet&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_string[3:-3] .
&amp;lsquo;alphabet starts where your alphabet en&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_string[0:2] .
&amp;lsquo;My&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_string[:18] .
&amp;lsquo;My alphabet starts&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_string[18:] .
&amp;lsquo; where your alphabet ends.&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You can get a part of a string, called a “slice”, by specifying two indices. The return value is a new string containing all the characters of the string, in order, starting with the first slice index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Like slicing lists, you can use negative indices to slice strings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Strings are zero-based, so a_string[0:2] returns the first two items of the string, starting at a_string[0], up to but not including a_string[2].&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the left slice index is 0, you can leave it out, and 0 is implied. So a_string[:18] is the same as a_string[0:18], because the starting 0 is implied.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Similarly, if the right slice index is the length of the string, you can leave it out. So a_string[18:] is the same as a_string[18:44], because this string has 44 characters. There is a pleasing symmetry here. In this 44-character string, a_string[:18] returns the first 18 characters, and a_string[18:] returns everything but the first 18 characters. In fact, a_string[:n] will always return the first n characters, and a_string[n:] will return the rest, regardless of the length of the string.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;4.6. STRINGS VS. BYTES
Bytes are bytes; characters are an abstraction. An immutable sequence of Unicode characters is called a string. An immutable sequence of numbers-between-0-and-255 is called a bytes object.
&amp;gt;&amp;gt;&amp;gt; by = b&amp;rsquo;abcd\x65&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; by
b&amp;rsquo;abcde&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; type(by) .
&lt;class &#39;bytes&#39;&gt;
&amp;gt;&amp;gt;&amp;gt; len(by) .
5
&amp;gt;&amp;gt;&amp;gt; by += b&amp;rsquo;\xff&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; by
b&amp;rsquo;abcde\xff&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; len(by) .
6
&amp;gt;&amp;gt;&amp;gt; by[0] .
97
&amp;gt;&amp;gt;&amp;gt; by[0] = 102 .&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
TypeError: &amp;lsquo;bytes&amp;rsquo; object does not support item assignment&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To define a bytes object, use the b&amp;rdquo; “byte literal” syntax. Each byte within the byte literal can be an ASCII character or an encoded hexadecimal number from \x00 to \xff (0–255).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The type of a bytes object is bytes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Just like lists and strings, you can get the length of a bytes object with the built-in len() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Just like lists and strings, you can use the + operator to concatenate bytes objects. The result is a new bytes object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Concatenating a 5-byte bytes object and a 1-byte bytes object gives you a 6-byte bytes object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Just like lists and strings, you can use index notation to get individual bytes in a bytes object. The items of a string are strings; the items of a bytes object are integers. Specifically, integers between 0–255.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A bytes object is immutable; you can not assign individual bytes. If you need to change individual bytes, you can either use string
slicing
and concatenation operators (which work the same as strings), or you can convert the bytes object into a bytearray object.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;by = b&amp;rsquo;abcd\x65&amp;rsquo;
barr = bytearray(by) .
barr
bytearray(b&amp;rsquo;abcde&amp;rsquo;)
len(barr) .
5
barr[0] = 102 .
barr
bytearray(b&amp;rsquo;fbcde&amp;rsquo;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To convert a bytes object into a mutable bytearray object, use the built-in bytearray() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;All the methods and operations you can do on a bytes object, you can do on a bytearray object too.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The one difference is that, with the bytearray object, you can assign individual bytes using index notation. The assigned value must be an integer between 0–255.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The one thing you can never do is mix bytes and strings.
&amp;gt;&amp;gt;&amp;gt; by = b&amp;rsquo;d&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; s = &amp;lsquo;abcde&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; by + s .&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
TypeError: can&amp;rsquo;t concat bytes to str&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;s.count(by)     .
Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
TypeError: Can&amp;rsquo;t convert &amp;lsquo;bytes&amp;rsquo; object to str implicitly&lt;/p&gt;

&lt;p&gt;s.count(by.decode(&amp;lsquo;ascii&amp;rsquo;)) .
1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You can’t concatenate bytes and strings. They are two different data types.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can’t count the occurrences of bytes in a string, because there are no bytes in a string. A string is a sequence of characters. Perhaps you meant “count the occurrences of the string that you would get after&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;decoding this sequence of bytes in a particular character encoding”? Well then, you’ll need to say that explicitly. Python 3 won’t implicitly convert bytes to strings or strings to bytes.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;By an amazing coincidence, this line of code says “count the occurrences of the string that you would get after decoding this sequence of bytes in this particular character encoding.”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And here is the link between strings and bytes: bytes objects have a decode() method that takes a character encoding and returns a string, and strings have an encode() method that takes a character encoding and returns a bytes object. In the previous example, the decoding was relatively straightforward — converting a sequence of bytes in the ASCII encoding into a string of characters. But the same process works with any encoding that supports the characters of the string — even legacy (non-Unicode) encodings.
&amp;gt;&amp;gt;&amp;gt; a_string = &amp;lsquo;.. Python&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; len(a_string)
9
&amp;gt;&amp;gt;&amp;gt; by = a_string.encode(&amp;lsquo;utf-8&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; by
b&amp;rsquo;\xe6\xb7\xb1\xe5\x85\xa5 Python&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; len(by)
13
&amp;gt;&amp;gt;&amp;gt; by = a_string.encode(&amp;lsquo;gb18030&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; by
b&amp;rsquo;\xc9\xee\xc8\xeb Python&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; len(by)
11
&amp;gt;&amp;gt;&amp;gt; by = a_string.encode(&amp;lsquo;big5&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; by
b&amp;rsquo;\xb2`\xa4J Python&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; len(by)
11
&amp;gt;&amp;gt;&amp;gt; roundtrip = by.decode(&amp;lsquo;big5&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; roundtrip
&amp;lsquo;.. Python&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_string == roundtrip
True&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;This is a string. It has nine characters.&lt;/li&gt;
&lt;li&gt;Thisisa bytes object. It has 13 bytes. It is the sequence of bytes you get when you take a_string and encode it in UTF-8.&lt;/li&gt;
&lt;li&gt;Thisisa bytes object. It has 11 bytes. It is the sequence of bytes you get when you take a_string and encode it in GB18030.&lt;/li&gt;
&lt;li&gt;Thisisa bytes object. It has 11 bytes. It is an entirely different sequence of bytes that you get when you take a_string and encode it in Big5.&lt;/li&gt;
&lt;li&gt;This is a string. It has nine characters. It is the sequence of characters you get when you take by and decode it using the Big5 encoding algorithm. It is identical to the original string.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;4.7. POSTSCRIPT: CHARACTER ENCODING OF PYTHON SOURCE CODE
Python 3 assumes that your source code — i.e. each .py file — is encoded in UTF-8.
. In Python 2, the default encoding for .py files was ASCII. In Python 3, the
default
encoding
is
UTF-8.
If you would like to use a different encoding within your Python code, you can put an encoding declaration on the first line of each file. This declaration defines a .py file to be windows-1252:&lt;/p&gt;

&lt;h1 id=&#34;coding-windows-1252:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;-*- coding: windows-1252 -*­&lt;/h1&gt;

&lt;p&gt;Technically, the character encoding override can also be on the second line, if the first line is a UNIX-like hash-bang command.
#!/usr/bin/python3&lt;/p&gt;

&lt;h1 id=&#34;coding-windows-1252-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;-*- coding: windows-1252 -*­&lt;/h1&gt;

&lt;p&gt;For more information, consult PEP
263:
Defining
Python
Source
Code
Encodings.
.&lt;/p&gt;

&lt;p&gt;4.8. FURTHER READING
On Unicode in Python:
• Python
Unicode
HOWTO&lt;/p&gt;

&lt;p&gt;•  What’s
New
In
Python
3:
Text
vs.
Data
Instead
Of
Unicode
vs.
8-bit&lt;/p&gt;

&lt;p&gt;•  PEP  261
explains
how
Python
handles
astral
characters
outside
of
the
Basic
Multilingual
Plane
(i.e. characters&lt;/p&gt;

&lt;p&gt;whose ordinal value is greater than 65535)&lt;br /&gt;
On Unicode in general:&lt;br /&gt;
•  The
Absolute
Minimum
Every
Software
Developer
Absolutely,
Positively
Must
Know
About
Unicode
and&lt;/p&gt;

&lt;p&gt;Character
Sets
(No
Excuses!)&lt;/p&gt;

&lt;p&gt;•  On
the
Goodness
of
Unicode&lt;/p&gt;

&lt;p&gt;•  On
Character
Strings&lt;/p&gt;

&lt;p&gt;•  Characters
vs.
Bytes&lt;/p&gt;

&lt;p&gt;On character encoding in other formats:&lt;br /&gt;
•  Character
encoding
in
XML&lt;/p&gt;

&lt;p&gt;•  Character
encoding
in
HTML&lt;/p&gt;

&lt;p&gt;On strings and string formatting:&lt;br /&gt;
•  string —
Common
string
operations&lt;/p&gt;

&lt;p&gt;•  Format
String
Syntax&lt;/p&gt;

&lt;p&gt;•  Format
Specification
Mini-Language&lt;/p&gt;

&lt;p&gt;•  PEP
3101:
Advanced
String
Formatting&lt;/p&gt;

&lt;p&gt;CHAPTER 5. REGULAR EXPRESSIONS&lt;/p&gt;

&lt;p&gt;. Some people, when confronted with a problem, think “I know, I’ll use regular expressions.” Now they have two problems. .
— Jamie Zawinski&lt;/p&gt;

&lt;p&gt;5.1. DIVING IN
Getting a small bit of text out of a large block of text is a challenge. In Python, strings have methods for searching and replacing: index(), find(), split(), count(), replace(), &amp;amp;c. But these methods are limited to the simplest of cases. For example, the index() method looks for a single, hard-coded substring, and the search is always case-sensitive. To do case-insensitive searches of a string s, you must call s.lower() or s.upper() and make sure your search strings are the appropriate case to match. The replace() and split() methods have the same limitations.
If your goal can be accomplished with string methods, you should use them. They’re fast and simple and easy to read, and there’s a lot to be said for fast, simple, readable code. But if you find yourself using a lot of different string functions with if statements to handle special cases, or if you’re chaining calls to split() and join() to slice-and-dice your strings, you may need to move up to regular expressions.
Regular expressions are a powerful and (mostly) standardized way of searching, replacing, and parsing text with complex patterns of characters. Although the regular expression syntax is tight and unlike normal code, the result can end up being more readable than a hand-rolled solution that uses a long chain of string functions. There are even ways of embedding comments within regular expressions, so you can include fine-grained documentation within them.
. If you’ve used regular expressions in other languages (like Perl, JavaScript, or PHP),
Python’s syntax will be very familiar. Read the summary of the re module
to get an
overview of the available functions and their arguments.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;5.2. CASE STUDY: STREET ADDRESSES
This series of examples was inspired by a real-life problem I had in my day job several years ago, when I needed to scrub and standardize street addresses exported from a legacy system before importing them into a newer system. (See, I don’t just make this stuff up; it’s actually useful.) This example shows how I approached the problem.
&amp;gt;&amp;gt;&amp;gt; s = &amp;lsquo;100 NORTH MAIN ROAD&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; s.replace(&amp;lsquo;ROAD&amp;rsquo;, &amp;lsquo;RD.&amp;rsquo;) .
&amp;lsquo;100 NORTH MAIN RD.&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; s = &amp;lsquo;100 NORTH BROAD ROAD&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; s.replace(&amp;lsquo;ROAD&amp;rsquo;, &amp;lsquo;RD.&amp;rsquo;) .
&amp;lsquo;100 NORTH BRD. RD.&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; s[:-4] + s[-4:].replace(&amp;lsquo;ROAD&amp;rsquo;, &amp;lsquo;RD.&amp;rsquo;) .
&amp;lsquo;100 NORTH BROAD RD.&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; import re .
&amp;gt;&amp;gt;&amp;gt; re.sub(&amp;lsquo;ROAD$&amp;rsquo;, &amp;lsquo;RD.&amp;rsquo;, s) .
&amp;lsquo;100 NORTH BROAD RD.&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;My goal is to standardize a street address so that &amp;lsquo;ROAD&amp;rsquo; is always abbreviated as &amp;lsquo;RD.&amp;rsquo;. At first glance, I thought this was simple enough that I could just use the string method replace(). After all, all the data was already uppercase, so case mismatches would not be a problem. And the search string, &amp;lsquo;ROAD&amp;rsquo;, was a constant. And in this deceptively simple example, s.replace() does indeed work.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Life, unfortunately, is full of counterexamples, and I quickly discovered this one. The problem here is that &amp;lsquo;ROAD&amp;rsquo; appears twice in the address, once as part of the street name &amp;lsquo;BROAD&amp;rsquo; and once as its own word. The replace() method sees these two occurrences and blindly replaces both of them; meanwhile, I see my addresses getting destroyed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To solve the problem of addresses with more than one &amp;lsquo;ROAD&amp;rsquo; substring, you could resort to something like this: only search and replace &amp;lsquo;ROAD&amp;rsquo; in the last four characters of the address (s[-4:]), and leave the string alone (s[:-4]). But you can see that this is already getting unwieldy. For example, the pattern is dependent on the length of the string you’re replacing. (If you were replacing &amp;lsquo;STREET&amp;rsquo; with &amp;lsquo;ST.&amp;rsquo;, you would need to&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;use s[:-6] and s[-6:].replace(&amp;hellip;).) Would you like to come back in six months and debug this? I know I wouldn’t.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It’s time to move up to regular expressions. In Python, all functionality related to regular expressions is contained in the re module.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Take a look at the first parameter: &amp;lsquo;ROAD$&amp;rsquo;. This is a simple regular expression that matches &amp;lsquo;ROAD&amp;rsquo; only when it occurs at the end of a string. The $ means “end of the string.” (There is a corresponding character, the caret ^, which means “beginning of the string.”) Using the re.sub() function, you search the string s for the regular expression &amp;lsquo;ROAD$&amp;rsquo; and replace it with &amp;lsquo;RD.&amp;rsquo;. This matches the ROAD at the end of the string s, but does not match the ROAD that’s part of the word BROAD, because that’s in the middle of s.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Continuing with my story of scrubbing addresses, I soon
discovered that the previous example, matching &amp;lsquo;ROAD&amp;rsquo;
at the end of the address, was not good enough,
because not all addresses included a street designation
at all. Some addresses simply ended with the street
name. I got away with it most of the time, but if the
street name was &amp;lsquo;BROAD&amp;rsquo;, then the regular expression
would match &amp;lsquo;ROAD&amp;rsquo; at the end of the string as part of
the word &amp;lsquo;BROAD&amp;rsquo;, which is not what I wanted.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;s = &amp;lsquo;100 BROAD&amp;rsquo;
re.sub(&amp;lsquo;ROAD$&amp;rsquo;, &amp;lsquo;RD.&amp;rsquo;, s)
&amp;lsquo;100 BRD.&amp;rsquo;
re.sub(&amp;rsquo;\bROAD$&amp;lsquo;, &amp;lsquo;RD.&amp;rsquo;, s) .
&amp;lsquo;100 BROAD&amp;rsquo;
re.sub(r&amp;rsquo;\bROAD$&amp;lsquo;, &amp;lsquo;RD.&amp;rsquo;, s) .
&amp;lsquo;100 BROAD&amp;rsquo;
s = &amp;lsquo;100 BROAD ROAD APT. 3&amp;rsquo;
re.sub(r&amp;rsquo;\bROAD$&amp;lsquo;, &amp;lsquo;RD.&amp;rsquo;, s) .
&amp;lsquo;100 BROAD ROAD APT. 3&amp;rsquo;
re.sub(r&amp;rsquo;\bROAD\b&amp;rsquo;, &amp;lsquo;RD.&amp;rsquo;, s) .
&amp;lsquo;100 BROAD RD. APT 3&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What I really wanted was to match &amp;lsquo;ROAD&amp;rsquo; when it was at the end of the string and it was its own word (and not a part of some larger word). To express this in a regular expression, you use \b, which means “a word boundary must occur right here.” In Python, this is complicated by the fact that the &amp;lsquo;\&amp;rsquo; character in a string must itself be escaped. This is sometimes referred to as the backslash plague, and it is one reason why regular expressions are easier in Perl than in Python. On the down side, Perl mixes regular expressions with other syntax, so if you have a bug, it may be hard to tell whether it’s a bug in syntax or a bug in your regular expression.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To work around the backslash plague, you can use what is called a raw string, by prefixing the string with the letter r. This tells Python that nothing in this string should be escaped; &amp;lsquo;\t&amp;rsquo; is a tab character, but r&amp;rsquo;\t&amp;rsquo; is really the backslash character \ followed by the letter t. I recommend always using raw strings when dealing with regular expressions; otherwise, things get too confusing too quickly (and regular expressions are confusing enough already).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;sigh&lt;/em&gt; Unfortunately, I soon found more cases that contradicted my logic. In this case, the street address contained the word &amp;lsquo;ROAD&amp;rsquo; as a whole word by itself, but it wasn’t at the end, because the address had an apartment number after the street designation. Because &amp;lsquo;ROAD&amp;rsquo; isn’t at the very end of the string, it doesn’t match, so the entire call to re.sub() ends up replacing nothing at all, and you get the original string back, which is not what you want.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To solve this problem, I removed the $ character and added another \b. Now the regular expression reads “match &amp;lsquo;ROAD&amp;rsquo; when it’s a whole word by itself anywhere in the string,” whether at the end, the beginning, or somewhere in the middle.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;5.3. CASE STUDY: ROMAN NUMERALS
You’ve most likely seen Roman numerals, even if you didn’t recognize them. You may have seen them in copyrights of old movies and television shows (“Copyright MCMXLVI” instead of “Copyright 1946”), or on the dedication walls of libraries or universities (“established MDCCCLXXXVIII” instead of “established 1888”). You may also have seen them in outlines and bibliographical references. It’s a system of representing numbers that really does date back to the ancient Roman empire (hence the name).
In Roman numerals, there are seven characters that are repeated and combined in various ways to represent numbers.
•   I=1&lt;/p&gt;

&lt;p&gt;•   V=5&lt;/p&gt;

&lt;p&gt;•   X = 10&lt;/p&gt;

&lt;p&gt;•   L = 50&lt;/p&gt;

&lt;p&gt;•   C = 100&lt;/p&gt;

&lt;p&gt;•   D = 500&lt;/p&gt;

&lt;p&gt;•   M = 1000&lt;/p&gt;

&lt;p&gt;The following are some general rules for constructing Roman numerals:
•   Sometimes characters are additive. I is 1, II is 2, and III is 3. VI is 6 (literally, “5 and 1”), VII is 7, and VIII is 8.&lt;/p&gt;

&lt;p&gt;•   The tens characters (I, X, C, and M) can be repeated up to three times. At 4, you need to subtract from the next highest fives character. You can&amp;rsquo;t represent 4 as IIII; instead, it is represented as IV (“1 less than 5”). 40 is written as XL (“10 less than 50”), 41 as XLI, 42 as XLII, 43 as XLIII, and then 44 as XLIV (“10 less than 50, then 1 less than 5”).&lt;/p&gt;

&lt;p&gt;•   Sometimes characters are… the opposite of additive. By putting certain characters before others, you subtract from the final value. For example, at 9, you need to subtract from the next highest tens character: 8 is VIII, but 9 is IX (“1 less than 10”), not VIIII (since the I character can not be repeated four times). 90 is XC, 900 is CM.&lt;/p&gt;

&lt;p&gt;•   The fives characters can not be repeated. 10 is always represented as X, never as VV. 100 is always C, never LL.&lt;/p&gt;

&lt;p&gt;•   Roman numerals are read left to right, so the order of characters matters very much. DC is 600; CD is a completely different number (400,“100 less than 500”). CI is 101; IC is not even a valid Roman numeral (because you can&amp;rsquo;t subtract 1 directly from 100; you would need to write it as XCIX,“10 less than 100, then 1 less than 10”).&lt;/p&gt;

&lt;p&gt;5.3.1. CHECKING FOR THOUSANDS&lt;/p&gt;

&lt;p&gt;What would it take to validate that an arbitrary string is a valid Roman numeral? Let’s take it one digit at a time. Since Roman numerals are always written highest to lowest, let’s start with the highest: the thousands place. For numbers 1000 and higher, the thousands are represented by a series of M characters.
&amp;gt;&amp;gt;&amp;gt; import re
&amp;gt;&amp;gt;&amp;gt; pattern = &amp;lsquo;^M?M?M?$&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;rsquo;M&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0106FB58&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MM&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0106C290&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MMM&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0106AA38&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MMMM&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;ldquo;) .
&amp;lt;_sre.SRE_Match object at 0106F4A8&amp;gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This pattern has three parts. ^ matches what follows only at the beginning of the string. If this were not specified, the pattern would match no matter where the M characters were, which is not what you want. You want to make sure that the M characters, if they’re there, are at the beginning of the string. M? optionally matches a single M character. Since this is repeated three times, you’re matching anywhere from zero to three M characters in a row. And $ matches the end of the string. When combined with the ^ character at the beginning, this means that the pattern must match the entire string, with no other characters before or after the M characters.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The essence of the re module is the search() function, that takes a regular expression (pattern) and a string (&amp;rsquo;M&amp;rsquo;) to try to match against the regular expression. If a match is found, search() returns an object which has various methods to describe the match; if no match is found, search() returns None, the Python null value. All you care about at the moment is whether the pattern matches, which you can tell by just looking at the return value of search(). &amp;rsquo;M&amp;rsquo; matches this regular expression, because the first optional M matches and the second and third optional M characters are ignored.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lsquo;MM&amp;rsquo; matches because the first and second optional M characters match and the third M is ignored.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lsquo;MMM&amp;rsquo; matches because all three M characters match.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lsquo;MMMM&amp;rsquo; does not match. All three M characters match, but then the regular expression insists on the string ending (because of the $ character), and the string doesn’t end yet (because of the fourth M). So search() returns None.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Interestingly, an empty string also matches this regular expression, since all the M characters are optional.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;5.3.2. CHECKING FOR HUNDREDS
The hundreds place is more difficult than the thousands,
because there are several mutually exclusive ways it
could be expressed, depending on its value.&lt;/p&gt;

&lt;p&gt;• 100 = C&lt;/p&gt;

&lt;p&gt;• 200 = CC&lt;/p&gt;

&lt;p&gt;• 300 = CCC&lt;/p&gt;

&lt;p&gt;• 400 = CD&lt;/p&gt;

&lt;p&gt;• 500 = D&lt;/p&gt;

&lt;p&gt;• 600 = DC&lt;/p&gt;

&lt;p&gt;• 700 = DCC&lt;/p&gt;

&lt;p&gt;• 800 = DCCC&lt;/p&gt;

&lt;p&gt;• 900 = CM&lt;/p&gt;

&lt;p&gt;So there are four possible patterns:&lt;/p&gt;

&lt;p&gt;• CM&lt;/p&gt;

&lt;p&gt;• CD&lt;/p&gt;

&lt;p&gt;• Zero to three C characters (zero if the hundreds place is 0)&lt;/p&gt;

&lt;p&gt;• D, followed by zero to three C characters&lt;/p&gt;

&lt;p&gt;• an optional D, followed by zero to three C characters&lt;/p&gt;

&lt;p&gt;The last two patterns can be combined:
This example shows how to validate the hundreds place of a Roman numeral.
&amp;gt;&amp;gt;&amp;gt; import re
&amp;gt;&amp;gt;&amp;gt; pattern = &amp;lsquo;^M?M?M?(CM|CD|D?C?C?C?)$&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MCM&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 01070390&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MD&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 01073A50&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MMMCCC&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 010748A8&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MCMC&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;ldquo;) .
&amp;lt;_sre.SRE_Match object at 01071D98&amp;gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This pattern starts out the same as the previous one, checking for the beginning of the string (^), then the thousands place (M?M?M?). Then it has the new part, in parentheses, which defines a set of three mutually exclusive patterns, separated by vertical bars: CM, CD, and D?C?C?C? (which is an optional D followed by zero to three optional C characters). The regular expression parser checks for each of these patterns in order (from left to right), takes the first one that matches, and ignores the rest.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lsquo;MCM&amp;rsquo; matches because the first M matches, the second and third M characters are ignored, and the CM matches (so the CD and D?C?C?C? patterns are never even considered). MCM is the Roman numeral representation of 1900.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lsquo;MD&amp;rsquo; matches because the first M matches, the second and third M characters are ignored, and the D?C?C?C? pattern matches D (each of the three C characters are optional and are ignored). MD is the Roman numeral representation of 1500.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lsquo;MMMCCC&amp;rsquo; matches because all three M characters match, and the D?C?C?C? pattern matches CCC (the D is optional and is ignored). MMMCCC is the Roman numeral representation of 3300.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lsquo;MCMC&amp;rsquo; does not match. The first M matches, the second and third M characters are ignored, and the CM matches, but then the $ does not match because you’re not at the end of the string yet (you still have an unmatched C character). The C does not match as part of the D?C?C?C? pattern, because the mutually exclusive CM pattern has already matched.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Interestingly, an empty string still matches this pattern, because all the M characters are optional and ignored, and the empty string matches the D?C?C?C? pattern where all the characters are optional and ignored.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Whew! See how quickly regular expressions can get nasty? And you’ve only covered the thousands and hundreds places of Roman numerals. But if you followed all that, the tens and ones places are easy, because they’re exactly the same pattern. But let’s look at another way to express the pattern.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;5.4. USING THE {n,m} SYNTAX
In the previous section, you were dealing with a pattern where the same character could be repeated up to
three times. There is another way to express this in regular expressions, which some people find more readable. First look at the method we already used in the previous example.
&amp;gt;&amp;gt;&amp;gt; import re &amp;gt;&amp;gt;&amp;gt; pattern = &amp;lsquo;^M?M?M?$&amp;rsquo; &amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;rsquo;M&amp;rsquo;) . &amp;lt;_sre.SRE_Match object at 0x008EE090&amp;gt; &amp;gt;&amp;gt;&amp;gt; pattern = &amp;lsquo;^M?M?M?$&amp;rsquo; &amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MM&amp;rsquo;) . &amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt; &amp;gt;&amp;gt;&amp;gt; pattern = &amp;lsquo;^M?M?M?$&amp;rsquo; &amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MMM&amp;rsquo;) . &amp;lt;_sre.SRE_Match object at 0x008EE090&amp;gt; &amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MMMM&amp;rsquo;) .&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This matches the start of the string, and then the first optional M, but not the second and third M (but that’s okay because they’re optional), and then the end of the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, and then the first and second optional M, but not the third M (but that’s okay because it’s optional), and then the end of the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, and then all three optional M, and then the end of the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, and then all three optional M, but then does not match the end of the string (because there is still one unmatched M), so the pattern does not match and returns None.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;pattern = &amp;lsquo;^M{0,3}$&amp;rsquo; .
re.search(pattern, &amp;rsquo;M&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt;
re.search(pattern, &amp;lsquo;MM&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x008EE090&amp;gt;
re.search(pattern, &amp;lsquo;MMM&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x008EEDA8&amp;gt;
re.search(pattern, &amp;lsquo;MMMM&amp;rsquo;) .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This pattern says: “Match the start of the string, then anywhere from zero to three M characters, then the end of the string.” The 0 and 3 can be any numbers; if you want to match at least one but no more than three M characters, you could say M{1,3}.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, then one M out of a possible three, then the end of the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, then two M out of a possible three, then the end of the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, then three M out of a possible three, then the end of the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, then three M out of a possible three, but then does not match the end of the string. The regular expression allows for up to only three M characters before the end of the string, but you have four, so the pattern does not match and returns None.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;5.4.1. CHECKING FOR TENS AND ONES
Now let’s expand the Roman numeral regular expression to cover the tens and ones place. This example shows the check for tens.
&amp;gt;&amp;gt;&amp;gt; pattern = &amp;lsquo;^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)$&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MCMXL&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MCML&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MCMLX&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MCMLXXX&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MCMLXXXX&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This matches the start of the string, then the first optional M, then CM, then XL, then the end of the string. Remember, the (A|B|C) syntax means “match exactly one of A, B, or C”. You match XL, so you ignore the XC and L?X?X?X? choices, and then move on to the end of the string. MCMXL is the Roman numeral representation of 1940.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, then the first optional M, then CM, then L?X?X?X?. Of the L?X?X?X?, it matches the L and skips all three optional X characters. Then you move to the end of the string. MCML is the Roman numeral representation of 1950.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, then the first optional M, then CM, then the optional L and the first optional X, skips the second and third optional X, then the end of the string. MCMLX is the Roman numeral representation of 1960.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, then the first optional M, then CM, then the optional L and all three optional X characters, then the end of the string. MCMLXXX is the Roman numeral representation of 1980.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, then the first optional M, then CM, then the optional L and all three optional X characters, then fails to match the end of the string because there is still one more X unaccounted for. So the entire pattern fails to match, and returns None. MCMLXXXX is not a valid Roman numeral.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The expression for the ones place follows the same pattern. I’ll spare you the details and show you the end result.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;pattern = &amp;lsquo;^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;So what does that look like using this alternate {n,m} syntax? This example shows the new syntax.
&amp;gt;&amp;gt;&amp;gt; pattern = &amp;lsquo;^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MDLV&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MMDCLXVI&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;MMMDCCCLXXXVIII&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(pattern, &amp;lsquo;I&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This matches the start of the string, then one of a possible three M characters, then D?C{0,3}. Of that, it matches the optional D and zero of three possible C characters. Moving on, it matches L?X{0,3} by matching the optional L and zero of three possible X characters. Then it matches V?I{0,3} by matching the optional V and zero of three possible I characters, and finally the end of the string. MDLV is the Roman numeral representation of 1555.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, then two of a possible three M characters, then the D?C{0,3} with a D and one of three possible C characters; then L?X{0,3} with an L and one of three possible X characters; then V?I{0,3} with a V and one of three possible I characters; then the end of the string. MMDCLXVI is the Roman numeral representation of 2666.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, then three out of three M characters, then D?C{0,3} with a D and three out of three C characters; then L?X{0,3} with an L and three out of three X characters; then V?I{0,3} with a V and three out of three I characters; then the end of the string. MMMDCCCLXXXVIII is the Roman numeral representation of 3888, and it’s the longest Roman numeral you can write without extended syntax.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Watch closely. (I feel like a magician. “Watch closely, kids, I’m going to pull a rabbit out of my hat.”) This matches the start of the string, then zero out of three M, then matches D?C{0,3} by skipping the optional D and matching zero out of three C, then matches L?X{0,3} by skipping the optional L and matching zero out of three X, then matches V?I{0,3} by skipping the optional V and matching one out of three I. Then the end of the string. Whoa.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you followed all that and understood it on the first try, you’re doing better than I did. Now imagine trying to understand someone else’s regular expressions, in the middle of a critical function of a large program. Or even imagine coming back to your own regular expressions a few months later. I’ve done it, and it’s not a pretty sight.
Now let’s explore an alternate syntax that can help keep your expressions maintainable.
.&lt;/p&gt;

&lt;p&gt;5.5. VERBOSE REGULAR EXPRESSIONS&lt;/p&gt;

&lt;p&gt;So far you’ve just been dealing with what I’ll call “compact” regular expressions. As you’ve seen, they are difficult to read, and even if you figure out what one does, that’s no guarantee that you’ll be able to understand it six months later. What you really need is inline documentation.
Python allows you to do this with something called verbose regular expressions. A verbose regular expression is different from a compact regular expression in two ways:
•   Whitespace is ignored. Spaces, tabs, and carriage returns are not matched as spaces, tabs, and carriage returns. They’re not matched at all. (If you want to match a space in a verbose regular expression, you’ll need to escape it by putting a backslash in front of it.)&lt;/p&gt;

&lt;p&gt;•   Comments are ignored. A comment in a verbose regular expression is just like a comment in Python code: it starts with a # character and goes until the end of the line. In this case it’s a comment within a multi-line string instead of within your source code, but it works the same way.&lt;/p&gt;

&lt;p&gt;This will be more clear with an example. Let’s revisit the compact regular expression you’ve been working with, and make it a verbose regular expression. This example shows how.
&amp;gt;&amp;gt;&amp;gt;     pattern = &amp;ldquo;&amp;rsquo;
^ # beginning of string
M{0,3} # thousands - 0 to 3 Ms
(CM|CD|D?C{0,3}) # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),&lt;/p&gt;

&lt;h1 id=&#34;or-500-800-d-followed-by-0-to-3-cs:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;or 500-800 (D, followed by 0 to 3 Cs)&lt;/h1&gt;

&lt;p&gt;(XC|XL|L?X{0,3}) # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),&lt;/p&gt;

&lt;h1 id=&#34;or-50-80-l-followed-by-0-to-3-xs:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;or 50-80 (L, followed by 0 to 3 Xs)&lt;/h1&gt;

&lt;p&gt;(IX|IV|V?I{0,3}) # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),&lt;/p&gt;

&lt;h1 id=&#34;or-5-8-v-followed-by-0-to-3-is:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;or 5-8 (V, followed by 0 to 3 Is)&lt;/h1&gt;

&lt;p&gt;$ # end of string
&amp;ldquo;&amp;rsquo;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;re.search(pattern, &amp;rsquo;M&amp;rsquo;, re.VERBOSE) .
&amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt;
re.search(pattern, &amp;lsquo;MCMLXXXIX&amp;rsquo;, re.VERBOSE) .
&amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt;
re.search(pattern, &amp;lsquo;MMMDCCCLXXXVIII&amp;rsquo;, re.VERBOSE) .
&amp;lt;_sre.SRE_Match object at 0x008EEB48&amp;gt;
re.search(pattern, &amp;rsquo;M&amp;rsquo;) .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The most important thing to remember when using verbose regular expressions is that you need to pass an extra argument when working with them: re.VERBOSE is a constant defined in the re module that signals that the pattern should be treated as a verbose regular expression. As you can see, this pattern has quite a bit of whitespace (all of which is ignored), and several comments (all of which are ignored). Once you ignore the whitespace and the comments, this is exactly the same regular expression as you saw in the previous section, but it’s a lot more readable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, then one of a possible three M, then CM, then L and three of a possible three X, then IX, then the end of the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This matches the start of the string, then three of a possible three M, then D and three of a possible three C, then L and three of a possible three X, then V and three of a possible three I, then the end of the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This does not match. Why? Because it doesn’t have the re.VERBOSE flag, so the re.search function is treating the pattern as a compact regular expression, with significant whitespace and literal hash marks. Python can’t auto-detect whether a regular expression is verbose or not. Python assumes every regular expression is compact unless you explicitly state that it is verbose.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;5.6. CASE STUDY: PARSING PHONE NUMBERS
So far you’ve concentrated on matching whole patterns. Either the pattern matches, or it doesn’t. But regular
expressions are much more powerful than that. When a regular expression does match, you can pick out specific pieces of it. You can find out what matched where.
This example came from another real-world problem I encountered, again from a previous day job. The problem: parsing an American phone number. The client wanted to be able to enter the number free-form (in a single field), but then wanted to store the area code, trunk, number, and optionally an extension separately in the company’s database. I scoured the Web and found many examples of regular expressions that purported to do this, but none of them were permissive enough.
Here are the phone numbers I needed to be able to accept:&lt;/p&gt;

&lt;p&gt;• 800-555-1212 • 800 555 1212 • 800.555.1212 • (800) 555-1212 • 1-800-555-1212 • 800-555-1212-1234 • 800-555-1212x1234 • 800-555-1212 ext. 1234 • work 1-(800) 555.1212 #1234
Quite a variety! In each of these cases, I need to know that the area code was 800, the trunk was 555, and the rest of the phone number was 1212. For those with an extension, I need to know that the extension was 1234.
Let’s work through developing a solution for phone number parsing. This example shows the first step.
&amp;gt;&amp;gt;&amp;gt; phonePattern = re.compile(r&amp;rsquo;^(\d{3})-(\d{3})-(\d{4})$&amp;lsquo;) .
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;800-555-1212&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;800-555-1212-1234&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;800-555-1212-1234&amp;rsquo;).groups() .&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
AttributeError: &amp;lsquo;NoneType&amp;rsquo; object has no attribute &amp;lsquo;groups&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Always read regular expressions from left to right. This one matches the beginning of the string, and then (\d{3}). What’s \d{3}? Well, \d means “any numeric digit” (0 through 9). The {3} means “match exactly three numeric digits”; it’s a variation on the {n,m} syntax you saw earlier. Putting it all in parentheses means “match exactly three numeric digits, and then remember them as a group that I can ask for later”. Then match a literal hyphen. Then match another group of exactly three digits. Then another literal hyphen. Then another group of exactly four digits. Then match the end of the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To get access to the groups that the regular expression parser remembered along the way, use the groups() method on the object that the search() method returns. It will return a tuple of however many groups were defined in the regular expression. In this case, you defined three groups, one with three digits, one with three digits, and one with four digits.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This regular expression is not the final answer, because it doesn’t handle a phone number with an extension on the end. For that, you’ll need to expand the regular expression.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And this is why you should never “chain” the search() and groups() methods in production code. If the search() method returns no matches, it returns None, not a regular expression match object. Calling None.groups() raises a perfectly obvious exception: None doesn’t have a groups() method. (Of course, it’s slightly less obvious when you get this exception from deep within your code. Yes, I speak from experience here.)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;phonePattern = re.compile(r&amp;rsquo;^(\d{3})-(\d{3})-(\d{4})-(\d+)$&amp;lsquo;) .
phonePattern.search(&amp;lsquo;800-555-1212-1234&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;lsquo;1234&amp;rsquo;)
phonePattern.search(&amp;lsquo;800 555 1212 1234&amp;rsquo;) .&lt;/p&gt;

&lt;p&gt;phonePattern.search(&amp;lsquo;800-555-1212&amp;rsquo;) .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This regular expression is almost identical to the previous one. Just as before, you match the beginning of the string, then a remembered group of three digits, then a hyphen, then a remembered group of three digits, then a hyphen, then a remembered group of four digits. What’s new is that you then match another hyphen, and a remembered group of one or more digits, then the end of the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The groups() method now returns a tuple of four elements, since the regular expression now defines four groups to remember.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unfortunately, this regular expression is not the final answer either, because it assumes that the different parts of the phone number are separated by hyphens. What if they’re separated by spaces, or commas, or dots? You need a more general solution to match several different types of separators.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Oops! Not only does this regular expression not do everything you want, it’s actually a step backwards, because now you can’t parse phone numbers without an extension. That’s not what you wanted at all; if the extension is there, you want to know what it is, but if it’s not there, you still want to know what the different parts of the main number are.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The next example shows the regular expression to handle separators between the different parts of the phone number.
&amp;gt;&amp;gt;&amp;gt; phonePattern = re.compile(r&amp;rsquo;^(\d{3})\D+(\d{3})\D+(\d{4})\D+(\d+)$&amp;lsquo;) .
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;800 555 1212 1234&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;lsquo;1234&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;800-555-1212-1234&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;lsquo;1234&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;80055512121234&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;800-555-1212&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Hang on to your hat. You’re matching the beginning of the string, then a group of three digits, then \D+. What the heck is that? Well, \D matches any character except a numeric digit, and + means “1 or more”. So \D+ matches one or more characters that are not digits. This is what you’re using instead of a literal hyphen, to try to match different separators.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using \D+ instead of -means you can now match phone numbers where the parts are separated by spaces instead of hyphens.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Of course, phone numbers separated by hyphens still work too.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unfortunately, this is still not the final answer, because it assumes that there is a separator at all. What if the phone number is entered without any spaces or hyphens at all?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Oops! This still hasn’t fixed the problem of requiring extensions. Now you have two problems, but you can solve both of them with the same technique.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The next example shows the regular expression for handling phone numbers without separators.
&amp;gt;&amp;gt;&amp;gt; phonePattern = re.compile(r&amp;rsquo;^(\d{3})\D&lt;em&gt;(\d{3})\D&lt;/em&gt;(\d{4})\D&lt;em&gt;(\d&lt;/em&gt;)$&amp;lsquo;) .
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;80055512121234&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;lsquo;1234&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;800.555.1212 x1234&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;lsquo;1234&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;800-555-1212&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;ldquo;)
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;(800)5551212 x1234&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The only change you’ve made since that last step is changing all the + to &lt;em&gt;. Instead of \D+ between the parts of the phone number, you now match on \D&lt;/em&gt;. Remember that + means “1 or more”? Well, * means “zero or more”. So now you should be able to parse phone numbers even when there is no separator character at all.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lo and behold, it actually works. Why? You matched the beginning of the string, then a remembered group of three digits (800), then zero non-numeric characters, then a remembered group of three digits (555), then zero non-numeric characters, then a remembered group of four digits (1212), then zero non-numeric characters, then a remembered group of an arbitrary number of digits (1234), then the end of the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Other variations work now too: dots instead of hyphens, and both a space and an x before the extension.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, you’ve solved the other long-standing problem: extensions are optional again. If no extension is found, the groups() method still returns a tuple of four elements, but the fourth element is just an empty string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I hate to be the bearer of bad news, but you’re not finished yet. What’s the problem here? There’s an extra character before the area code, but the regular expression assumes that the area code is the first thing at the beginning of the string. No problem, you can use the same technique of “zero or more non-numeric characters” to skip over the leading characters before the area code.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The next example shows how to handle leading characters in phone numbers.
&amp;gt;&amp;gt;&amp;gt; phonePattern = re.compile(r&amp;rsquo;^\D&lt;em&gt;(\d{3})\D&lt;/em&gt;(\d{3})\D&lt;em&gt;(\d{4})\D&lt;/em&gt;(\d*)$&amp;lsquo;) .
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;(800)5551212 ext. 1234&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;lsquo;1234&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;800-555-1212&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;ldquo;)
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;work 1-(800) 555.1212 #1234&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This is the same as in the previous example, except now you’re matching \D*, zero or more non-numeric characters, before the first remembered group (the area code). Notice that you’re not remembering these non-numeric characters (they’re not in parentheses). If you find them, you’ll just skip over them and then start remembering the area code whenever you get to it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can successfully parse the phone number, even with the leading left parenthesis before the area code. (The right parenthesis after the area code is already handled; it’s treated as a non-numeric separator and matched by the \D* after the first remembered group.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Just a sanity check to make sure you haven’t broken anything that used to work. Since the leading characters are entirely optional, this matches the beginning of the string, then zero non-numeric characters, then a remembered group of three digits (800), then one non-numeric character (the hyphen), then a remembered group of three digits (555), then one non-numeric character (the hyphen), then a remembered group of four digits (1212), then zero non-numeric characters, then a remembered group of zero digits, then the end of the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is where regular expressions make me want to gouge my eyes out with a blunt object. Why doesn’t this phone number match? Because there’s a 1 before the area code, but you assumed that all the leading characters before the area code were non-numeric characters (\D*). Aargh.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s back up for a second. So far the regular expressions have all matched from the beginning of the string. But now you see that there may be an indeterminate amount of stuff at the beginning of the string that you want to ignore. Rather than trying to match it all just so you can skip over it, let’s take a different approach: don’t explicitly match the beginning of the string at all. This approach is shown in the next example.
&amp;gt;&amp;gt;&amp;gt; phonePattern = re.compile(r&amp;rsquo;(\d{3})\D&lt;em&gt;(\d{3})\D&lt;/em&gt;(\d{4})\D&lt;em&gt;(\d&lt;/em&gt;)$&amp;lsquo;) .
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;work 1-(800) 555.1212 #1234&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;lsquo;1234&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;800-555-1212&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;ldquo;)
&amp;gt;&amp;gt;&amp;gt; phonePattern.search(&amp;lsquo;80055512121234&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;lsquo;1234&amp;rsquo;)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Note the lack of ^ in this regular expression. You are not matching the beginning of the string anymore. There’s nothing that says you need to match the entire input with your regular expression. The regular expression engine will do the hard work of figuring out where the input string starts to match, and go from there.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now you can successfully parse a phone number that includes leading characters and a leading digit, plus any number of any kind of separators around each part of the phone number.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sanity check. This still works.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That still works too.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;See how quickly a regular expression can get out of control? Take a quick glance at any of the previous iterations. Can you tell the difference between one and the next?
While you still understand the final answer (and it is the final answer; if you’ve discovered a case it doesn’t handle, I don’t want to know about it), let’s write it out as a verbose regular expression, before you forget why you made the choices you made.
&amp;gt;&amp;gt;&amp;gt; phonePattern = re.compile(r&amp;rdquo;&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;don-t-match-beginning-of-string-number-can-start-anywhere:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;don&amp;rsquo;t match beginning of string, number can start anywhere&lt;/h1&gt;

&lt;p&gt;(\d{3}) # area code is 3 digits (e.g. &amp;lsquo;800&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;\D* # optional separator is any number of non-digits&lt;/p&gt;

&lt;p&gt;(\d{3}) # trunk is 3 digits (e.g. &amp;lsquo;555&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;\D* # optional separator&lt;/p&gt;

&lt;p&gt;(\d{4}) # rest of number is 4 digits (e.g. &amp;lsquo;1212&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;\D* # optional separator&lt;/p&gt;

&lt;p&gt;(\d*) # extension is optional and can be any number of digits&lt;/p&gt;

&lt;p&gt;$ # end of string&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;lsquo;, re.VERBOSE)&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;phonePattern.search(&amp;lsquo;work 1-(800) 555.1212 #1234&amp;rsquo;).groups() .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;lsquo;1234&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;phonePattern.search(&amp;lsquo;800-555-1212&amp;rsquo;)     .
(&amp;lsquo;800&amp;rsquo;, &amp;lsquo;555&amp;rsquo;, &amp;lsquo;1212&amp;rsquo;, &amp;ldquo;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Other than being spread out over multiple lines, this is exactly the same regular expression as the last step, so it’s no surprise that it parses the same inputs.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Final sanity check. Yes, this still works. You’re done.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.
5.7. SUMMARY
This is just the tiniest tip of the iceberg of what regular expressions can do. In other words, even though you’re completely overwhelmed by them now, believe me, you ain’t seen nothing yet.
You should now be familiar with the following techniques:
•   ^ matches the beginning of a string.&lt;/p&gt;

&lt;p&gt;•   $ matches the end of a string.&lt;/p&gt;

&lt;p&gt;•   \b matches a word boundary.&lt;/p&gt;

&lt;p&gt;•   \d matches any numeric digit.&lt;/p&gt;

&lt;p&gt;•   \D matches any non-numeric character.&lt;/p&gt;

&lt;p&gt;•   x? matches an optional x character (in other words, it matches an x zero or one times).&lt;/p&gt;

&lt;p&gt;•   x* matches x zero or more times.&lt;/p&gt;

&lt;p&gt;•   x+ matches x one or more times.&lt;/p&gt;

&lt;p&gt;•   x{n,m} matches an x character at least n times, but not more than m times.&lt;/p&gt;

&lt;p&gt;•   (a|b|c) matches exactly one of a, b or c.&lt;/p&gt;

&lt;p&gt;•   (x) in general is a remembered group. You can get the value of what matched by using the groups() method of the object returned by re.search.&lt;/p&gt;

&lt;p&gt;Regular expressions are extremely powerful, but they are not the correct solution for every problem. You should learn enough about them to know when they are appropriate, when they will solve your problems, and when they will cause more problems than they solve.
CHAPTER 6. CLOSURES &amp;amp; GENERATORS&lt;/p&gt;

&lt;p&gt;.   My spelling is Wobbly. It’s good spelling but it Wobbles, and the letters get in the wrong places. .
—   Winnie-the-Pooh&lt;/p&gt;

&lt;p&gt;6.1. DIVING IN
Having grown up the son of a librarian and an English major, I have always been fascinated by languages. Not programming languages. Well yes, programming languages, but also natural languages. Take English. English is a schizophrenic language that borrows words from German, French, Spanish, and Latin (to name a few). Actually, “borrows” is the wrong word; “pillages” is more like it. Or perhaps “assimilates” — like the Borg. Yes, I like that.
We are the Borg. Your linguistic and etymological distinctiveness will be added to our own.
Resistance is futile.&lt;/p&gt;

&lt;p&gt;In this chapter, you’re going to learn about plural nouns. Also, functions that return other functions, advanced regular expressions, and generators. But first, let’s talk about how to make plural nouns. (If you haven’t read the
chapter
on
regular
expressions, now would be a good time. This chapter assumes you understand the basics of regular expressions, and it quickly descends into more advanced uses.)
If you grew up in an English-speaking country or learned English in a formal school setting, you’re probably familiar with the basic rules:
•   If a word ends in S, X, or Z, add ES. Bass becomes basses, fax becomes faxes, and waltz becomes waltzes.&lt;/p&gt;

&lt;p&gt;•   If a word ends in a noisy H, add ES; if it ends in a silent H, just add S. What’s a noisy H? One that gets combined with other letters to make a sound that you can hear. So coach becomes coaches and rash becomes rashes, because you can hear the CH and SH sounds when you say them. But cheetah becomes cheetahs, because the H is silent.&lt;/p&gt;

&lt;p&gt;•   If a word ends in Y that sounds like I, change the Y to IES; if the Y is combined with a vowel to sound like something else, just add S. So vacancy becomes vacancies, but day becomes days.&lt;/p&gt;

&lt;p&gt;•   If all else fails, just add S and hope for the best.&lt;/p&gt;

&lt;p&gt;(I know, there are a lot of exceptions. Man becomes men and woman becomes women, but human becomes humans. Mouse becomes mice and louse becomes lice, but house becomes houses. Knife becomes knives and wife becomes wives, but lowlife becomes lowlifes. And don’t even get me started on words that are their own plural, like sheep, deer, and haiku.)
Other languages, of course, are completely different.
Let’s design a Python library that automatically pluralizes English nouns. We’ll start with just these four rules, but keep in mind that you’ll inevitably need to add more.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;6.2. I KNOW, LET’S USE REGULAR EXPRESSIONS!
So you’re looking at words, which, at least in English, means you’re looking at strings of characters. You have rules that say you need to find different combinations of characters, then do different things to them. This sounds like a job for regular expressions!
import re&lt;/p&gt;

&lt;p&gt;def plural(noun):
if re.search(&amp;rsquo;[sxz]$&amp;lsquo;, noun): .
return re.sub(&amp;lsquo;$&amp;rsquo;, &amp;lsquo;es&amp;rsquo;, noun) .
elif re.search(&amp;rsquo;[^aeioudgkprt]h$&amp;lsquo;, noun):
return re.sub(&amp;lsquo;$&amp;rsquo;, &amp;lsquo;es&amp;rsquo;, noun)
elif re.search(&amp;rsquo;[^aeiou]y$&amp;lsquo;, noun):
return re.sub(&amp;lsquo;y$&amp;rsquo;, &amp;lsquo;ies&amp;rsquo;, noun)
else:
return noun + &amp;rsquo;s&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This is a regular expression, but it uses a syntax you didn’t see in Regular Expressions. The square brackets mean “match exactly one of these characters.” So [sxz] means “s, or x, or z”, but only one of them. The $ should be familiar; it matches the end of string. Combined, this regular expression tests whether noun ends with s, x, or z.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This re.sub() function performs regular expression-based string substitutions.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s look at regular expression substitutions in more detail.
&amp;gt;&amp;gt;&amp;gt; import re
&amp;gt;&amp;gt;&amp;gt; re.search(&amp;rsquo;[abc]&amp;lsquo;, &amp;lsquo;Mark&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x001C1FA8&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.sub(&amp;rsquo;[abc]&amp;lsquo;, &amp;lsquo;o&amp;rsquo;, &amp;lsquo;Mark&amp;rsquo;) .
&amp;lsquo;Mork&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; re.sub(&amp;rsquo;[abc]&amp;lsquo;, &amp;lsquo;o&amp;rsquo;, &amp;lsquo;rock&amp;rsquo;) .
&amp;lsquo;rook&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; re.sub(&amp;rsquo;[abc]&amp;lsquo;, &amp;lsquo;o&amp;rsquo;, &amp;lsquo;caps&amp;rsquo;) .
&amp;lsquo;oops&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Does the string Mark contain a, b, or c? Yes, it contains a.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;OK, now find a, b, or c, and replace it with o. Mark becomes Mork.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The same function turns rock into rook.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You might think this would turn caps into oaps, but it doesn’t. re.sub replaces all of the matches, not just&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;the first one. So this regular expression turns caps into oops, because both the c and the a get turned into o.
And now, back to the plural() function…
def plural(noun):
if re.search(&amp;rsquo;[sxz]$&amp;lsquo;, noun):
return re.sub(&amp;lsquo;$&amp;rsquo;, &amp;lsquo;es&amp;rsquo;, noun) .
elif re.search(&amp;rsquo;[^aeioudgkprt]h$&amp;lsquo;, noun): .
return re.sub(&amp;lsquo;$&amp;rsquo;, &amp;lsquo;es&amp;rsquo;, noun)
elif re.search(&amp;rsquo;[^aeiou]y$&amp;lsquo;, noun): .
return re.sub(&amp;lsquo;y$&amp;rsquo;, &amp;lsquo;ies&amp;rsquo;, noun)
else:
return noun + &amp;rsquo;s&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Here, you’re replacing the end of the string (matched by $) with the string es. In other words, adding es to the string. You could accomplish the same thing with string concatenation, for example noun + &amp;lsquo;es&amp;rsquo;, but I chose to use regular expressions for each rule, for reasons that will become clear later in the chapter.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Look closely, this is another new variation. The ^ as the first character inside the square brackets means something special: negation. [^abc] means “any single character except a, b, or c”. So [^aeioudgkprt] means any character except a, e, i, o, u, d, g, k, p, r, or t. Then that character needs to be followed by h, followed by end of string. You’re looking for words that end in H where the H can be heard.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Same pattern here: match words that end in Y, where the character before the Y is not a, e, i, o, or u. You’re looking for words that end in Y that sounds like I.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s look at negation regular expressions in more detail.
&amp;gt;&amp;gt;&amp;gt; import re
&amp;gt;&amp;gt;&amp;gt; re.search(&amp;rsquo;[^aeiou]y$&amp;lsquo;, &amp;lsquo;vacancy&amp;rsquo;) .
&amp;lt;_sre.SRE_Match object at 0x001C1FA8&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(&amp;rsquo;[^aeiou]y$&amp;lsquo;, &amp;lsquo;boy&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(&amp;rsquo;[^aeiou]y$&amp;lsquo;, &amp;lsquo;day&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; re.search(&amp;rsquo;[^aeiou]y$&amp;lsquo;, &amp;lsquo;pita&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;vacancy matches this regular expression, because it ends in cy, and c is not a, e, i, o, or u.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;boy does not match, because it ends in oy, and you specifically said that the character before the y could not be o. day does not match, because it ends in ay.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pita does not match, because it does not end in y.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;re.sub(&amp;lsquo;y$&amp;rsquo;, &amp;lsquo;ies&amp;rsquo;, &amp;lsquo;vacancy&amp;rsquo;) .
&amp;lsquo;vacancies&amp;rsquo;
re.sub(&amp;lsquo;y$&amp;rsquo;, &amp;lsquo;ies&amp;rsquo;, &amp;lsquo;agency&amp;rsquo;)
&amp;lsquo;agencies&amp;rsquo;
re.sub(&amp;lsquo;([^aeiou])y$&amp;lsquo;, r&amp;rsquo;\1ies&amp;rsquo;, &amp;lsquo;vacancy&amp;rsquo;) .
&amp;lsquo;vacancies&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This regular expression turns vacancy into vacancies and agency into agencies, which is what you wanted. Note that it would also turn boy into boies, but that will never happen in the function because you did that re.search first to find out whether you should do this re.sub.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Just in passing, I want to point out that it is possible to combine these two regular expressions (one to find out if the rule applies, and another to actually apply it) into a single regular expression. Here’s what that would look like. Most of it should look familiar: you’re using a remembered group, which you learned in Case
study:
Parsing
Phone
Numbers. The group is used to remember the character before the letter y. Then in the substitution string, you use a new syntax, \1, which means “hey, that first group you remembered? put it right here.” In this case, you remember the c before the y; when you do the substitution, you substitute c in place of c, and ies in place of y. (If you have more than one remembered group, you can use \2 and \3 and so on.)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Regular expression substitutions are extremely powerful, and the \1 syntax makes them even more powerful.
But combining the entire operation into one regular expression is also much harder to read, and it doesn’t directly map to the way you first described the pluralizing rules. You originally laid out rules like “if the word ends in S, X, or Z, then add ES”. If you look at this function, you have two lines of code that say “if the word ends in S, X, or Z, then add ES”. It doesn’t get much more direct than that.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;6.3. A LIST OF FUNCTIONS
Now you’re going to add a level of abstraction. You started by defining a list of rules: if this, do that, otherwise go to the next rule. Let’s temporarily complicate part of the program so you can simplify another part.
import re&lt;/p&gt;

&lt;p&gt;def match_sxz(noun):
return re.search(&amp;rsquo;[sxz]$&amp;lsquo;, noun)&lt;/p&gt;

&lt;p&gt;def apply_sxz(noun):
return re.sub(&amp;lsquo;$&amp;rsquo;, &amp;lsquo;es&amp;rsquo;, noun)&lt;/p&gt;

&lt;p&gt;def match_h(noun):
return re.search(&amp;rsquo;[^aeioudgkprt]h$&amp;lsquo;, noun)&lt;/p&gt;

&lt;p&gt;def apply_h(noun):
return re.sub(&amp;lsquo;$&amp;rsquo;, &amp;lsquo;es&amp;rsquo;, noun)&lt;/p&gt;

&lt;p&gt;def match_y(noun): . return re.search(&amp;rsquo;[^aeiou]y$&amp;lsquo;, noun)
def apply_y(noun): . return re.sub(&amp;lsquo;y$&amp;rsquo;, &amp;lsquo;ies&amp;rsquo;, noun)
def match_default(noun):
return True&lt;/p&gt;

&lt;p&gt;def apply_default(noun):
return noun + &amp;rsquo;s&amp;rsquo;&lt;/p&gt;

&lt;p&gt;rules = ((match_sxz, apply_sxz), . (match_h, apply_h), (match_y, apply_y), (match_default, apply_default) )&lt;/p&gt;

&lt;p&gt;def plural(noun): for matches_rule, apply_rule in rules: .
if matches_rule(noun):&lt;/p&gt;

&lt;p&gt;return apply_rule(noun)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Now, each match rule is its own function which returns the results of calling the re.search() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Each apply rule is also its own function which calls the re.sub() function to apply the appropriate pluralization rule.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instead of having one function (plural()) with multiple rules, you have the rules data structure, which is a sequence of pairs of functions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Since the rules have been broken out into a separate data structure, the new plural() function can be reduced to a few lines of code. Using a for loop, you can pull out the match and apply rules two at a time (one match, one apply) from the rules structure. On the first iteration of the for loop, matches_rule will get match_sxz, and apply_rule will get apply_sxz. On the second iteration (assuming you get that far), matches_rule will be assigned match_h, and apply_rule will be assigned apply_h. The function is guaranteed to return something eventually, because the final match rule (match_default) simply returns True, meaning the corresponding apply rule (apply_default) will always be applied.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The reason this technique works is that everything
in&lt;/p&gt;

&lt;p&gt;Python
is
an
object, including functions. The rules data
structure contains functions — not names of functions,
but actual function objects. When they get assigned in
the for loop, then matches_rule and apply_rule are
actual functions that you can call. On the first iteration
of the for loop, this is equivalent to calling
matches_sxz(noun), and if it returns a match, calling
apply_sxz(noun).&lt;/p&gt;

&lt;p&gt;If this additional level of abstraction is confusing, try
unrolling the function to see the equivalence. The entire
for loop is equivalent to the following:&lt;/p&gt;

&lt;p&gt;def plural(noun):&lt;/p&gt;

&lt;p&gt;if match_sxz(noun):
return apply_sxz(noun)&lt;/p&gt;

&lt;p&gt;if match_h(noun):
return apply_h(noun)&lt;/p&gt;

&lt;p&gt;if match_y(noun):
return apply_y(noun)&lt;/p&gt;

&lt;p&gt;if match_default(noun):
return apply_default(noun)&lt;/p&gt;

&lt;p&gt;The benefit here is that the plural() function is now simplified. It takes a sequence of rules, defined
elsewhere, and iterates through them in a generic fashion.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Get a match rule&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Does it match? Then call the apply rule and return the result.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No match? Go to step 1.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The rules could be defined anywhere, in any way. The plural() function doesn’t care.
Now, was adding this level of abstraction worth it? Well, not yet. Let’s consider what it would take to add a new rule to the function. In the first example, it would require adding an if statement to the plural() function. In this second example, it would require adding two functions, match_foo() and apply_foo(), and then updating the rules sequence to specify where in the order the new match and apply functions should be called relative to the other rules.
But this is really just a stepping stone to the next section. Let’s move on…
.&lt;/p&gt;

&lt;p&gt;6.4. A LIST OF PATTERNS
Defining separate named functions for each match and apply rule isn’t really necessary. You never call them directly; you add them to the rules sequence and call them through there. Furthermore, each function follows one of two patterns. All the match functions call re.search(), and all the apply functions call re.sub(). Let’s factor out the patterns so that defining new rules can be easier.
import re&lt;/p&gt;

&lt;p&gt;def build_match_and_apply_functions(pattern, search, replace):
def matches_rule(word): .
return re.search(pattern, word)
def apply_rule(word): .
return re.sub(search, replace, word)
return (matches_rule, apply_rule) .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;build_match_and_apply_functions() is a function that builds other functions dynamically. It takes pattern, search and replace, then defines a matches_rule() function which calls re.search() with the pattern that was passed to the build_match_and_apply_functions() function, and the word that was passed to the matches_rule() function you’re building. Whoa.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Building the apply function works the same way. The apply function is a function that takes one parameter, and calls re.sub() with the search and replace parameters that were passed to the build_match_and_apply_functions() function, and the word that was passed to the apply_rule() function you’re building. This technique of using the values of outside parameters within a dynamic function is called closures. You’re essentially defining constants within the apply function you’re building: it takes one parameter (word), but it then acts on that plus two other values (search and replace) which were set when you defined the apply function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, the build_match_and_apply_functions() function returns a tuple of two values: the two functions you just created. The constants you defined within those functions (pattern within the matches_rule() function, and search and replace within the apply_rule() function) stay with those functions, even after you return from build_match_and_apply_functions(). That’s insanely cool.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If this is incredibly confusing (and it should be, this is weird stuff), it may become clearer when you see how to use it.
patterns = \    .
(
(&amp;rsquo;[sxz]$&amp;lsquo;, &amp;lsquo;$&amp;rsquo;, &amp;lsquo;es&amp;rsquo;),
(&amp;rsquo;[^aeioudgkprt]h$&amp;lsquo;, &amp;lsquo;$&amp;rsquo;, &amp;lsquo;es&amp;rsquo;),
(&amp;lsquo;(qu|[^aeiou])y$&amp;lsquo;, &amp;lsquo;y$&amp;rsquo;, &amp;lsquo;ies&amp;rsquo;),
(&amp;lsquo;$&amp;rsquo;, &amp;lsquo;$&amp;rsquo;, &amp;rsquo;s&amp;rsquo;) .&lt;/p&gt;

&lt;p&gt;)
rules = [build_match_and_apply_functions(pattern, search, replace) .
for (pattern, search, replace) in patterns]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Our pluralization “rules” are now defined as a tuple of tuples of strings (not functions). The first string in each group is the regular expression pattern that you would use in re.search() to see if this rule matches. The second and third strings in each group are the search and replace expressions you would use in re.sub() to actually apply the rule to turn a noun into its plural.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There’s a slight change here, in the fallback rule. In the previous example, the match_default() function simply returned True, meaning that if none of the more specific rules matched, the code would simply add an s to the end of the given word. This example does something functionally equivalent. The final regular expression asks whether the word has an end ($ matches the end of a string). Of course, every string has an end, even an empty string, so this expression always matches. Thus, it serves the same purpose as the match_default() function that always returned True: it ensures that if no more specific rule matches, the code adds an s to the end of the given word.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This line is magic. It takes the sequence of strings in patterns and turns them into a sequence of functions. How? By “mapping” the strings to the build_match_and_apply_functions() function. That is, it takes each triplet of strings and calls the build_match_and_apply_functions() function with those three strings as arguments. The build_match_and_apply_functions() function returns a tuple of two functions. This means that rules ends up being functionally equivalent to the previous example: a list of tuples, where each tuple is a pair of functions. The first function is the match function that calls re.search(), and the second function is the apply function that calls re.sub().&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Rounding out this version of the script is the main entry point, the plural() function.
def plural(noun): for matches_rule, apply_rule in rules: . if matches_rule(noun): return apply_rule(noun)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Since the rules list is the same as the previous example (really, it is), it should come as no surprise that the plural() function hasn’t changed at all. It’s completely generic; it takes a list of rule functions and calls them in order. It doesn’t care how the rules are defined. In the previous example, they were defined as separate named functions. Now they are built dynamically by mapping the output of the build_match_and_apply_functions() function onto a list of raw strings. It doesn’t matter; the plural() function still works the same way.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;6.5. A FILE OF PATTERNS
You’ve factored out all the duplicate code and added enough abstractions so that the pluralization rules are defined in a list of strings. The next logical step is to take these strings and put them in a separate file, where they can be maintained separately from the code that uses them.
First, let’s create a text file that contains the rules you want. No fancy data structures, just whitespace-delimited strings in three columns. Let’s call it plural4-rules.txt.
[sxz]$  $  es&lt;br /&gt;
[^aeioudgkprt]h$  $  es&lt;br /&gt;
[^aeiou]y$  y$  ies&lt;br /&gt;
$  $  s&lt;/p&gt;

&lt;p&gt;Now let’s see how you can use this rules file.
import re&lt;/p&gt;

&lt;p&gt;def build_match_and_apply_functions(pattern, search, replace): .
def matches_rule(word):
return re.search(pattern, word)
def apply_rule(word):
return re.sub(search, replace, word)
return (matches_rule, apply_rule)&lt;/p&gt;

&lt;p&gt;rules = []
with open(&amp;lsquo;plural4-rules.txt&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as pattern_file: .&lt;/p&gt;

&lt;p&gt;for line in pattern_file: . pattern, search, replace = line.split(None, 3) . rules.append(build_match_and_apply_functions( .
pattern, search, replace))&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The build_match_and_apply_functions() function has not changed. You’re still using closures to build two functions dynamically that use variables defined in the outer function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The global open() function opens a file and returns a file object. In this case, the file we’re opening contains the pattern strings for pluralizing nouns. The with statement creates what’s called a context: when the with block ends, Python will automatically close the file, even if an exception is raised inside the with block. You’ll learn more about with blocks and file objects in the Files
chapter.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The for line in &lt;fileobject&gt; idiom reads data from the open file, one line at a time, and assigns the text to the line variable. You’ll learn more about reading from files in the Files
chapter.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Each line in the file really has three values, but they’re separated by whitespace (tabs or spaces, it makes no difference). To split it out, use the split() string method. The first argument to the split() method is None, which means “split on any whitespace (tabs or spaces, it makes no difference).” The second argument is 3, which means “split on whitespace 3 times, then leave the rest of the line alone.” A line like [sxz]$ $ es will be broken up into the list [&amp;rsquo;[sxz]$&amp;lsquo;, &amp;lsquo;$&amp;rsquo;, &amp;lsquo;es&amp;rsquo;], which means that pattern will get &amp;lsquo;[sxz]$&amp;lsquo;, search will get &amp;lsquo;$&amp;rsquo;, and replace will get &amp;lsquo;es&amp;rsquo;. That’s a lot of power in one little line of code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, you pass pattern, search, and replace to the build_match_and_apply_functions() function, which returns a tuple of functions. You append this tuple to the rules list, and rules ends up storing the list of match and apply functions that the plural() function expects.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The improvement here is that you’ve completely separated the pluralization rules into an external file, so it can be maintained separately from the code that uses it. Code is code, data is data, and life is good.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;6.6. GENERATORS
Wouldn’t it be grand to have a generic plural() function that parses the rules file? Get rules, check for a match, apply appropriate transformation, go to next rule. That’s all the plural() function has to do, and that’s all the plural() function should do.
def rules(rules_filename):&lt;/p&gt;

&lt;p&gt;with open(rules_filename, encoding=&amp;lsquo;utf-8&amp;rsquo;) as pattern_file:&lt;/p&gt;

&lt;p&gt;for line in pattern_file:&lt;/p&gt;

&lt;p&gt;pattern, search, replace = line.split(None, 3)&lt;/p&gt;

&lt;p&gt;yield build_match_and_apply_functions(pattern, search, replace)&lt;/p&gt;

&lt;p&gt;def plural(noun, rules_filename=&amp;lsquo;plural5-rules.txt&amp;rsquo;):
for matches_rule, apply_rule in rules(rules_filename):
if matches_rule(noun):
return apply_rule(noun)
raise ValueError(&amp;lsquo;no matching rule for {0}&amp;rsquo;.format(noun))&lt;/p&gt;

&lt;p&gt;How the heck does that work? Let’s look at an interactive example first.
&amp;gt;&amp;gt;&amp;gt; def make_counter(x):
&amp;hellip; print(&amp;lsquo;entering make_counter&amp;rsquo;)
&amp;hellip; while True:
&amp;hellip; yield x .
&amp;hellip; print(&amp;lsquo;incrementing x&amp;rsquo;)
&amp;hellip; x = x + 1
&amp;hellip;
&amp;gt;&amp;gt;&amp;gt; counter = make_counter(2) .
&amp;gt;&amp;gt;&amp;gt; counter .
&lt;generator object at 0x001C9C10&gt;
&amp;gt;&amp;gt;&amp;gt; next(counter) .
entering make_counter
2
&amp;gt;&amp;gt;&amp;gt; next(counter) .
incrementing x
3
&amp;gt;&amp;gt;&amp;gt; next(counter) .
incrementing x
4&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The presence of the yield keyword in make_counter means that this is not a normal function. It is a special kind of function which generates values one at a time. You can think of it as a resumable function. Calling it will return a generator that can be used to generate successive values of x.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To create an instance of the make_counter generator, just call it like any other function. Note that this does not actually execute the function code. You can tell this because the first line of the make_counter() function calls print(), but nothing has been printed yet.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The make_counter() function returns a generator object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The next() function takes a generator object and returns its next value. The first time you call next() with the counter generator, it executes the code in make_counter() up to the first yield statement, then returns the value that was yielded. In this case, that will be 2, because you originally created the generator by calling make_counter(2).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Repeatedly calling next() with the same generator object resumes exactly where it left off and continues until it hits the next yield statement. All variables, local state, &amp;amp;c. are saved on yield and restored on next(). The next line of code waiting to be executed calls print(), which prints incrementing x. After&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;that, the statement x=x+1. Then it loops through the while loop again, and the first thing it hits is the statement yield x, which saves the state of everything and returns the current value of x (now 3).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
The second time you call next(counter), you do all the same things again, but this time x is now 4.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since make_counter sets up an infinite loop, you could theoretically do this forever, and it would just keep incrementing x and spitting out values. But let’s look at more productive uses of generators instead.
6.6.1. A FIBONACCI GENERATOR
def fib(max):
a, b = 0, 1 .
while a &amp;lt; max:&lt;/p&gt;

&lt;p&gt;yield a .
a, b = b, a + b .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The Fibonacci sequence is a sequence of numbers where each number is the sum of the two numbers before it. It starts with 0 and 1, goes up slowly at first, then more and more rapidly. To start the sequence, you need two variables: a starts at 0, and b starts at 1.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;a is the current number in the sequence, so yield it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;b is the next number in the sequence, so assign that to a, but also calculate the next value (a+b) and assign that to b for later use. Note that this happens in parallel; if a is 3 and b is 5, then a, b = b, a + b will set a to 5 (the previous value of b) and b to 8 (the sum of the previous values of a and b).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So you have a function that spits out successive
Fibonacci numbers. Sure, you could do that with
recursion, but this way is easier to read. Also, it works well with for loops.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;from fibonacci import fib&lt;/p&gt;

&lt;p&gt;for n in fib(1000): .
&amp;hellip; print(n, end=&amp;rsquo; &amp;lsquo;) .
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
list(fib(1000)) .
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You can use a generator like fib() in a for loop directly. The for loop will automatically call the next() function to get values from the fib() generator and assign them to the for loop index variable (n).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Each time through the for loop, n gets a new value from the yield statement in fib(), and all you have to do is print it out. Once fib() runs out of numbers (a becomes bigger than max, which in this case is 1000), then the for loop exits gracefully.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is a useful idiom: pass a generator to the list() function, and it will iterate through the entire generator (just like the for loop in the previous example) and return a list of all the values.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;6.6.2. A PLURAL RULE GENERATOR
Let’s go back to plural5.py and see how this version of the plural() function works.
def rules(rules_filename):&lt;/p&gt;

&lt;p&gt;with open(rules_filename, encoding=&amp;lsquo;utf-8&amp;rsquo;) as pattern_file:&lt;/p&gt;

&lt;p&gt;for line in pattern_file:&lt;/p&gt;

&lt;p&gt;pattern, search, replace = line.split(None, 3)  .
yield build_match_and_apply_functions(pattern, search, replace) .
def plural(noun, rules_filename=&amp;lsquo;plural5-rules.txt&amp;rsquo;): for matches_rule, apply_rule in rules(rules_filename): . if matches_rule(noun): return apply_rule(noun) raise ValueError(&amp;lsquo;no matching rule for {0}&amp;rsquo;.format(noun))
1.  No magic here. Remember that the lines of the rules file have three values separated by whitespace, so you use line.split(None, 3) to get the three “columns” and assign them to three local variables.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;And then you yield. What do you yield? Two functions, built dynamically with your old friend, build_match_and_apply_functions(), which is identical to the previous examples. In other words, rules() is a generator that spits out match and apply functions on demand.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Since rules() is a generator, you can use it directly in a for loop. The first time through the for loop, you will call the rules() function, which will open the pattern file, read the first line, dynamically build a match function and an apply function from the patterns on that line, and yield the dynamically built functions. The second time through the for loop, you will pick up exactly where you left off in rules() (which was in the middle of the for line in pattern_file loop). The first thing it will do is read the next line of the file (which is still open), dynamically build another match and apply function based on the patterns on that line in the file, and yield the two functions.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What have you gained over stage 4? Startup time. In stage 4, when you imported the plural4 module, it read the entire patterns file and built a list of all the possible rules, before you could even think about calling the plural() function. With generators, you can do everything lazily: you read the first rule and create functions and try them, and if that works you don’t ever read the rest of the file or create any other functions.
What have you lost? Performance! Every time you call the plural() function, the rules() generator starts over from the beginning — which means re-opening the patterns file and reading from the beginning, one line at a time.
What if you could have the best of both worlds: minimal startup cost (don’t execute any code on import), and maximum performance (don’t build the same functions over and over again). Oh, and you still want to keep the rules in a separate file (because code is code and data is data), just as long as you never have to read the same line twice.
To do that, you’ll need to build your own iterator. But before you do that, you need to learn about Python classes.
.&lt;/p&gt;

&lt;p&gt;6.7. FURTHER READING
• PEP
255:
Simple
Generators&lt;/p&gt;

&lt;p&gt;• Understanding
Python’s
“with”
statement&lt;/p&gt;

&lt;p&gt;• Closures
in
Python&lt;/p&gt;

&lt;p&gt;• Fibonacci
numbers&lt;/p&gt;

&lt;p&gt;• English
Irregular
Plural
Nouns&lt;/p&gt;

&lt;p&gt;CHAPTER 7. CLASSES &amp;amp; ITERATORS&lt;/p&gt;

&lt;p&gt;. East is East, and West is West, and never the twain shall meet. .
— Rudyard Kipling&lt;/p&gt;

&lt;p&gt;7.1. DIVING IN
Iterators are the “secret sauce” of Python 3. They’re everywhere, underlying everything, always just out of sight. Comprehensions
are just a simple form of iterators. Generators are just a simple form of iterators.A function that yields values is a nice, compact way of building an iterator without building an iterator. Let me show you what I mean by that.
Remember the
Fibonacci
generator? Here it is as a built-from-scratch iterator:
class Fib:&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;lsquo;iterator that yields numbers in the Fibonacci sequence&amp;rdquo;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;init&lt;/strong&gt;(self, max):
self.max = max&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;iter&lt;/strong&gt;(self):
self.a = 0
self.b = 1
return self&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;next&lt;/strong&gt;(self):
fib = self.a
if fib &amp;gt; self.max:&lt;/p&gt;

&lt;p&gt;raise StopIteration
self.a, self.b = self.b, self.a + self.b
return fib&lt;/p&gt;

&lt;p&gt;Let’s take that one line at a time.
class Fib:&lt;/p&gt;

&lt;p&gt;class? What’s a class?&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;7.2. DEFINING CLASSES
Python is fully object-oriented: you can define your own classes, inherit from your own or built-in classes, and instantiate the classes you’ve defined.
Defining a class in Python is simple. As with functions, there is no separate interface definition. Just define the class and start coding. A Python class starts with the reserved word class, followed by the class name. Technically, that’s all that’s required, since a class doesn’t need to inherit from any other class.
class PapayaWhip: .
pass .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The name of this class is PapayaWhip, and it doesn’t inherit from any other class. Class names are usually capitalized, EachWordLikeThis, but this is only a convention, not a requirement.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You probably guessed this, but everything in a class is indented, just like the code within a function, if statement, for loop, or any other block of code. The first line not indented is outside the class.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This PapayaWhip class doesn’t define any methods or attributes, but syntactically, there needs to be something in the definition, thus the pass statement. This is a Python reserved word that just means “move along, nothing to see here”. It’s a statement that does nothing, and it’s a good placeholder when you’re stubbing out functions or classes.
. The pass statement in Python is like a empty set of curly braces ({}) in Java or C.
Many classes are inherited from other classes, but this one is not. Many classes define methods, but this one does not. There is nothing that a Python class absolutely must have, other than a name. In particular, C++ programmers may find it odd that Python classes don’t have explicit constructors and destructors. Although it’s not required, Python classes can have something similar to a constructor: the &lt;strong&gt;init&lt;/strong&gt;() method.
7.2.1. THE &lt;strong&gt;init&lt;/strong&gt;() METHOD
This example shows the initialization of the Fib class using the &lt;strong&gt;init&lt;/strong&gt; method.
class Fib:
&amp;ldquo;&amp;lsquo;iterator that yields numbers in the Fibonacci sequence&amp;rdquo;&amp;rsquo; .&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;init&lt;/strong&gt;(self, max):    .
1.  Classes can (and should) have docstrings too, just like modules and functions.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;strong&gt;init&lt;/strong&gt;() method is called immediately after an instance of the class is created. It would be tempting — but technically incorrect — to call this the “constructor” of the class. It’s tempting, because it looks like a C++ constructor (by convention, the &lt;strong&gt;init&lt;/strong&gt;() method is the first method defined for the class), acts like one (it’s the first piece of code executed in a newly created instance of the class), and even sounds like one. Incorrect, because the object has already been constructed by the time the &lt;strong&gt;init&lt;/strong&gt;() method is called, and you already have a valid reference to the new instance of the class.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The first argument of every class method, including the &lt;strong&gt;init&lt;/strong&gt;() method, is always a reference to the current instance of the class. By convention, this argument is named self. This argument fills the role of the reserved word this in C++ or Java, but self is not a reserved word in Python, merely a naming convention. Nonetheless, please don’t call it anything but self; this is a very strong convention.
In the &lt;strong&gt;init&lt;/strong&gt;() method, self refers to the newly created object; in other class methods, it refers to the instance whose method was called. Although you need to specify self explicitly when defining the method, you do not specify it when calling the method; Python will add it for you automatically.&lt;/p&gt;

&lt;p&gt;.
7.3. INSTANTIATING CLASSES
Instantiating classes in Python is straightforward. To instantiate a class, simply call the class as if it were a function, passing the arguments that the &lt;strong&gt;init&lt;/strong&gt;() method requires. The return value will be the newly created object.
&amp;gt;&amp;gt;&amp;gt; import fibonacci2&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;fib = fibonacci2.Fib(100) .
fib .
&lt;fibonacci2.Fib object at 0x00DB8810&gt;
fib.&lt;strong&gt;class&lt;/strong&gt; .
&lt;class &#39;fibonacci2.Fib&#39;&gt;
fib.&lt;strong&gt;doc&lt;/strong&gt; .
&amp;lsquo;iterator that yields numbers in the Fibonacci sequence&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You are creating an instance of the Fib class (defined in the fibonacci2 module) and assigning the newly created instance to the variable fib. You are passing one parameter, 100, which will end up as the max argument in Fib’s &lt;strong&gt;init&lt;/strong&gt;() method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fib is now an instance of the Fib class.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Every class instance has a built-in attribute, &lt;strong&gt;class&lt;/strong&gt;, which is the object’s class. Java programmers may be familiar with the Class class, which contains methods like getName() and getSuperclass() to get metadata information about an object. In Python, this kind of metadata is available through attributes, but the idea is the same.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can access the instance’s docstring just as with a function or a module. All instances of a class share the same docstring.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. In Python, simply call a class as if it were a function to create a new instance of the class. There is no explicit new operator like there is in C++ or Java.
.&lt;/p&gt;

&lt;p&gt;7.4. INSTANCE VARIABLES
On to the next line:
class Fib:&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;init&lt;/strong&gt;(self, max):
self.max = max .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;What is self.max? It’s an instance variable. It is completely separate from max, which was passed into the &lt;strong&gt;init&lt;/strong&gt;() method as an argument. self.max is “global” to the instance. That means that you can access it from other methods.
class Fib:
def &lt;strong&gt;init&lt;/strong&gt;(self, max):&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;self.max = max .
.
.
.
def &lt;strong&gt;next&lt;/strong&gt;(self):&lt;/p&gt;

&lt;p&gt;fib = self.a
if fib &amp;gt; self.max: .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;self.max is defined in the &lt;strong&gt;init&lt;/strong&gt;() method…&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;…and referenced in the &lt;strong&gt;next&lt;/strong&gt;() method.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Instance variables are specific to one instance of a class. For example, if you create two Fib instances with different maximum values, they will each remember their own values.
&amp;gt;&amp;gt;&amp;gt; import fibonacci2
&amp;gt;&amp;gt;&amp;gt; fib1 = fibonacci2.Fib(100)
&amp;gt;&amp;gt;&amp;gt; fib2 = fibonacci2.Fib(200)
&amp;gt;&amp;gt;&amp;gt; fib1.max
100
&amp;gt;&amp;gt;&amp;gt; fib2.max
200&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;7.5. A FIBONACCI ITERATOR&lt;/p&gt;

&lt;p&gt;Now you’re ready to learn how to build an iterator. An iterator is just a class that defines an &lt;strong&gt;iter&lt;/strong&gt;() method.
class Fib: .
def &lt;strong&gt;init&lt;/strong&gt;(self, max): .
self.max = max&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;iter&lt;/strong&gt;(self): .
self.a = 0
self.b = 1
return self&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;next&lt;/strong&gt;(self): .
fib = self.a
if fib &amp;gt; self.max:&lt;/p&gt;

&lt;p&gt;raise StopIteration .
self.a, self.b = self.b, self.a + self.b
return fib .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To build an iterator from scratch, Fib needs to be a class, not a function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;“Calling” Fib(max) is really creating an instance of this class and calling its &lt;strong&gt;init&lt;/strong&gt;() method with max. The &lt;strong&gt;init&lt;/strong&gt;() method saves the maximum value as an instance variable so other methods can refer to it later.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;iter&lt;/strong&gt;() method is called whenever someone calls iter(fib). (As you’ll see in a minute, a for loop will call this automatically, but you can also call it yourself manually.) After performing beginning-of-iteration initialization (in this case, resetting self.a and self.b, our two counters), the &lt;strong&gt;iter&lt;/strong&gt;() method can return any object that implements a &lt;strong&gt;next&lt;/strong&gt;() method. In this case (and in most cases), &lt;strong&gt;iter&lt;/strong&gt;() simply returns self, since this class implements its own &lt;strong&gt;next&lt;/strong&gt;() method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;next&lt;/strong&gt;() method is called whenever someone calls next() on an iterator of an instance of a class.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That will make more sense in a minute.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;When the &lt;strong&gt;next&lt;/strong&gt;() method raises a StopIteration exception, this signals to the caller that the iteration is exhausted. Unlike most exceptions, this is not an error; it’s a normal condition that just means that the iterator has no more values to generate. If the caller is a for loop, it will notice this StopIteration exception and gracefully exit the loop. (In other words, it will swallow the exception.) This little bit of magic is actually the key to using iterators in for loops.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To spit out the next value, an iterator’s &lt;strong&gt;next&lt;/strong&gt;() method simply returns the value. Do not use yield here; that’s a bit of syntactic sugar that only applies when you’re using generators. Here you’re creating your own iterator from scratch; use return instead.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thoroughly confused yet? Excellent. Let’s see how to call this iterator:
&amp;gt;&amp;gt;&amp;gt; from fibonacci2 import Fib
&amp;gt;&amp;gt;&amp;gt; for n in Fib(1000):
&amp;hellip; print(n, end=&amp;rsquo; &amp;lsquo;)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987&lt;/p&gt;

&lt;p&gt;Why, it’s exactly the same! Byte for byte identical to how you called Fibonacci-as-a-generator
(modulo one capital letter). But how?
There’s a bit of magic involved in for loops. Here’s what happens:
•   The for loop calls Fib(1000), as shown. This returns an instance of the Fib class. Call this fib_inst.&lt;/p&gt;

&lt;p&gt;•   Secretly, and quite cleverly, the for loop calls iter(fib_inst), which returns an iterator object. Call this fib_iter. In this case, fib_iter == fib_inst, because the &lt;strong&gt;iter&lt;/strong&gt;() method returns self, but the for loop doesn’t know (or care) about that.&lt;/p&gt;

&lt;p&gt;•   To “loop through” the iterator, the for loop calls next(fib_iter), which calls the &lt;strong&gt;next&lt;/strong&gt;() method on the fib_iter object, which does the next-Fibonacci-number calculations and returns a value. The for loop takes this value and assigns it to n, then executes the body of the for loop for that value of n.&lt;/p&gt;

&lt;p&gt;•   How does the for loop know when to stop? I’m glad you asked! When next(fib_iter) raises a StopIteration exception, the for loop will swallow the exception and gracefully exit. (Any other exception will pass through and be raised as usual.) And where have you seen a StopIteration exception? In the &lt;strong&gt;next&lt;/strong&gt;() method, of course!&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;7.6. A PLURAL RULE ITERATOR
Now it’s time for the finale. Let’s rewrite the plural
rules
generator
as an iterator.&lt;/p&gt;

&lt;p&gt;class LazyRules:&lt;/p&gt;

&lt;p&gt;rules_filename = &amp;lsquo;plural6-rules.txt&amp;rsquo;&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;init&lt;/strong&gt;(self):
self.pattern_file = open(self.rules_filename, encoding=&amp;lsquo;utf-8&amp;rsquo;)
self.cache = []&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;iter&lt;/strong&gt;(self):
self.cache_index = 0
return self&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;next&lt;/strong&gt;(self):
self.cache_index += 1
if len(self.cache) &amp;gt;= self.cache_index:&lt;/p&gt;

&lt;p&gt;return self.cache[self.cache_index - 1]&lt;/p&gt;

&lt;p&gt;if self.pattern_file.closed:
raise StopIteration&lt;/p&gt;

&lt;p&gt;line = self.pattern_file.readline()&lt;/p&gt;

&lt;p&gt;if not line:
self.pattern_file.close()
raise StopIteration&lt;/p&gt;

&lt;p&gt;pattern, search, replace = line.split(None, 3)
funcs = build_match_and_apply_functions(&lt;/p&gt;

&lt;p&gt;pattern, search, replace)
self.cache.append(funcs)
return funcs&lt;/p&gt;

&lt;p&gt;rules = LazyRules()&lt;/p&gt;

&lt;p&gt;So this is a class that implements &lt;strong&gt;iter&lt;/strong&gt;() and &lt;strong&gt;next&lt;/strong&gt;(), so it can be used as an iterator. Then, you instantiate the class and assign it to rules. This happens just once, on import.
Let’s take the class one bite at a time.
class LazyRules:
rules_filename = &amp;lsquo;plural6-rules.txt&amp;rsquo;&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;init&lt;/strong&gt;(self): self.pattern_file = open(self.rules_filename, encoding=&amp;lsquo;utf-8&amp;rsquo;) . self.cache = [] .
1.  When we instantiate the LazyRules class, open the pattern file but don’t read anything from it. (That comes later.)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;After opening the patterns file, initialize the cache. You’ll use this cache later (in the &lt;strong&gt;next&lt;/strong&gt;() method) as you read lines from the pattern file.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Before we continue, let’s take a closer look at rules_filename. It’s not defined within the &lt;strong&gt;iter&lt;/strong&gt;() method. In fact, it’s not defined within any method. It’s defined at the class level. It’s a class variable, and although you can access it just like an instance variable (self.rules_filename), it is shared across all instances of the LazyRules class.
&amp;gt;&amp;gt;&amp;gt; import plural6
&amp;gt;&amp;gt;&amp;gt; r1 = plural6.LazyRules()
&amp;gt;&amp;gt;&amp;gt; r2 = plural6.LazyRules()
&amp;gt;&amp;gt;&amp;gt; r1.rules_filename .
&amp;lsquo;plural6-rules.txt&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; r2.rules_filename
&amp;lsquo;plural6-rules.txt&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; r2.rules_filename = &amp;lsquo;r2-override.txt&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; r2.rules_filename
&amp;lsquo;r2-override.txt&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; r1.rules_filename
&amp;lsquo;plural6-rules.txt&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; r2.&lt;strong&gt;class&lt;/strong&gt;.rules_filename .
&amp;lsquo;plural6-rules.txt&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; r2.&lt;strong&gt;class&lt;/strong&gt;.rules_filename = &amp;lsquo;papayawhip.txt&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; r1.rules_filename
&amp;lsquo;papayawhip.txt&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; r2.rules_filename .
&amp;lsquo;r2-overridetxt&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Each instance of the class inherits the rules_filename attribute with the value defined by the class.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Changing the attribute’s value in one instance does not affect other instances…&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;…nor does it change the class attribute. You can access the class attribute (as opposed to an individual instance’s attribute) by using the special &lt;strong&gt;class&lt;/strong&gt; attribute to access the class itself.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you change the class attribute, all instances that are still inheriting that value (like r1 here) will be affected.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instances that have overridden that attribute (like r2 here) will not be affected.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And now back to our show.
def &lt;strong&gt;iter&lt;/strong&gt;(self): .
self.cache_index = 0
return self .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;strong&gt;iter&lt;/strong&gt;() method will be called every time someone — say, a for loop — calls iter(rules).&lt;/li&gt;
&lt;li&gt;The one thing that every &lt;strong&gt;iter&lt;/strong&gt;() method must do is return an iterator. In this case, it returns self, which signals that this class defines a &lt;strong&gt;next&lt;/strong&gt;() method which will take care of returning values throughout the iteration.
def &lt;strong&gt;next&lt;/strong&gt;(self): .
.
.
.
pattern, search, replace = line.split(None, 3)
funcs = build_match_and_apply_functions( .&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;pattern, search, replace) self.cache.append(funcs) . return funcs
1.  The &lt;strong&gt;next&lt;/strong&gt;() method gets called whenever someone — say, a for loop — calls next(rules). This method will only make sense if we start at the end and work backwards. So let’s do that.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The last part of this function should look familiar, at least. The build_match_and_apply_functions() function hasn’t changed; it’s the same as it ever was.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The only difference is that, before returning the match and apply functions (which are stored in the tuple funcs), we’re going to save them in self.cache.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Moving backwards…
def &lt;strong&gt;next&lt;/strong&gt;(self):
.
.
.
line = self.pattern_file.readline() .
if not line: .&lt;/p&gt;

&lt;p&gt;self.pattern_file.close()
raise StopIteration .
.
.
.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A bit of advanced file trickery here. The readline() method (note: singular, not the plural readlines()) reads exactly one line from an open file. Specifically, the next line. (File objects are iterators too! It’s iterators all the way down…)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If there was a line for readline() to read, line will not be an empty string. Even if the file contained a blank line, line would end up as the one-character string &amp;lsquo;\n&amp;rsquo; (a carriage return). If line is really an empty string, that means there are no more lines to read from the file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When we reach the end of the file, we should close the file and raise the magic StopIteration exception. Remember, we got to this point because we needed a match and apply function for the next rule. The next rule comes from the next line of the file… but there is no next line! Therefore, we have no value to return. The iteration is over. (. The party’s over… .)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Moving backwards all the way to the start of the &lt;strong&gt;next&lt;/strong&gt;() method…
def &lt;strong&gt;next&lt;/strong&gt;(self):
self.cache_index += 1
if len(self.cache) &amp;gt;= self.cache_index:&lt;/p&gt;

&lt;p&gt;return self.cache[self.cache_index - 1] .
if self.pattern_file.closed:
raise StopIteration .
.
.
.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;self.cache will be a list of the functions we need to match and apply individual rules. (At least that should sound familiar!) self.cache_index keeps track of which cached item we should return next. If we haven’t exhausted the cache yet (i.e. if the length of self.cache is greater than self.cache_index), then we have a cache hit! Hooray! We can return the match and apply functions from the cache instead of building them from scratch.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;On the other hand, if we don’t get a hit from the cache, and the file object has been closed (which could happen, further down the method, as you saw in the previous code snippet), then there’s nothing more we can do. If the file is closed, it means we’ve exhausted it — we’ve already read through every line from the pattern file, and we’ve already built and cached the match and apply functions for each pattern. The file is exhausted; the cache is exhausted; I’m exhausted. Wait, what? Hang in there, we’re almost done.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Putting it all together, here’s what happens when:
•   When the module is imported, it creates a single instance of the LazyRules class, called rules, which opens the pattern file but does not read from it.&lt;/p&gt;

&lt;p&gt;•   When asked for the first match and apply function, it checks its cache but finds the cache is empty. So it reads a single line from the pattern file, builds the match and apply functions from those patterns, and caches them.&lt;/p&gt;

&lt;p&gt;•   Let’s say, for the sake of argument, that the very first rule matched. If so, no further match and apply
functions are built, and no further lines are read from the pattern file.&lt;/p&gt;

&lt;p&gt;•   Furthermore, for the sake of argument, suppose that the caller calls the plural() function again to pluralize a different word. The for loop in the plural() function will call iter(rules), which will reset the cache index but will not reset the open file object.&lt;/p&gt;

&lt;p&gt;•   The first time through, the for loop will ask for a value from rules, which will invoke its &lt;strong&gt;next&lt;/strong&gt;() method. This time, however, the cache is primed with a single pair of match and apply functions, corresponding to the patterns in the first line of the pattern file. Since they were built and cached in the course of pluralizing the previous word, they’re retrieved from the cache. The cache index increments, and the open file is never touched.&lt;/p&gt;

&lt;p&gt;•   Let’s say, for the sake of argument, that the first rule does not match this time around. So the for loop comes around again and asks for another value from rules. This invokes the &lt;strong&gt;next&lt;/strong&gt;() method a second time. This time, the cache is exhausted — it only contained one item, and we’re asking for a second — so the &lt;strong&gt;next&lt;/strong&gt;() method continues. It reads another line from the open file, builds match and apply functions out of the patterns, and caches them.&lt;/p&gt;

&lt;p&gt;•   This read-build-and-cache process will continue as long as the rules being read from the pattern file don’t match the word we’re trying to pluralize. If we do find a matching rule before the end of the file, we simply use it and stop, with the file still open. The file pointer will stay wherever we stopped reading, waiting for the next readline() command. In the meantime, the cache now has more items in it, and if we start all over again trying to pluralize a new word, each of those items in the cache will be tried before reading the next line from the pattern file.&lt;/p&gt;

&lt;p&gt;We have achieved pluralization nirvana.
1.  Minimal startup cost. The only thing that happens on import is instantiating a single class and opening a file (but not reading from it).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Maximum performance. The previous example would read through the file and build functions dynamically every time you wanted to pluralize a word. This version will cache functions as soon as they’re built, and in the worst case, it will only read through the pattern file once, no matter how many words you pluralize.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Separation of code and data. All the patterns are stored in a separate file. Code is code, and data is data, and never the twain shall meet.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. Is this really nirvana? Well, yes and no. Here’s something to consider with the LazyRules example: the pattern file is opened (during &lt;strong&gt;init&lt;/strong&gt;()), and it remains open until the final rule is reached. Python will eventually close the file when it exits, or after the last instantiation of the LazyRules class is destroyed, but still, that could be a long time. If this class is part of a long-running Python process, the Python interpreter may never exit, and the LazyRules object may never get destroyed.
There are ways around this. Instead of opening the file during &lt;strong&gt;init&lt;/strong&gt;() and leaving it open while you read rules one line at a time, you could open the file, read all the rules, and immediately close the file. Or you could open the file, read one rule, save the file position with the tell() method, close the file, and later re-open it and use the seek() method
to continue reading where you left off. Or you could not worry about it and just leave the file open, like this example code does. Programming is design, and design is all about trade-offs and constraints. Leaving a file open too long might be a problem; making your code more complicated might be a problem. Which one is the bigger problem depends on your development team, your application, and your runtime environment.&lt;/p&gt;

&lt;p&gt;.
7.7. FURTHER READING
•   Iterator
types&lt;/p&gt;

&lt;p&gt;•   PEP
234:
Iterators&lt;/p&gt;

&lt;p&gt;• PEP
255:
Simple
Generators&lt;/p&gt;

&lt;p&gt;• Generator
Tricks
for
Systems
Programmers&lt;/p&gt;

&lt;p&gt;CHAPTER 8. ADVANCED ITERATORS&lt;/p&gt;

&lt;p&gt;. Great fleas have little fleas upon their backs to bite ’em, And little fleas have lesser fleas, and so ad infinitum. .
— Augustus De Morgan&lt;/p&gt;

&lt;p&gt;8.1. DIVING IN
Just as regular
expressions
put strings
on steroids, the itertools module puts iterators
on steroids. But first, I want to show you a classic puzzle.
HAWAII + IDAHO + IOWA + OHIO == STATES
510199 + 98153 + 9301 + 3593 == 621246&lt;/p&gt;

&lt;p&gt;H = 5
A = 1
W = 0
I = 9
D = 8
O = 3
S = 6
T = 2
E = 4&lt;/p&gt;

&lt;p&gt;Puzzles like this are called cryptarithms or alphametics. The letters spell out actual words, but if you replace each letter with a digit from 0–9, it also “spells” an arithmetic equation. The trick is to figure out which letter maps to each digit. All the occurrences of each letter must map to the same digit, no digit can be repeated, and no “word” can start with the digit 0.
In this chapter, we’ll dive into an incredible Python program originally written by Raymond Hettinger. This program solves alphametic puzzles in just 14 lines of code.&lt;/p&gt;

&lt;p&gt;import re&lt;/p&gt;

&lt;p&gt;import itertools&lt;/p&gt;

&lt;p&gt;def solve(puzzle):
words = re.findall(&amp;rsquo;[A-Z]+&amp;lsquo;, puzzle.upper())
unique_characters = set(&amp;ldquo;.join(words))
assert len(unique_characters) &amp;lt;= 10, &amp;lsquo;Too many letters&amp;rsquo;
first_letters = {word[0] for word in words}
n = len(first_letters)
sorted_characters = &amp;ldquo;.join(first_letters) + &lt;/p&gt;

&lt;p&gt;&amp;rdquo;.join(unique_characters - first_letters)
characters = tuple(ord&amp;copy; for c in sorted_characters)
digits = tuple(ord&amp;copy; for c in &amp;lsquo;0123456789&amp;rsquo;)
zero = digits[0]
for guess in itertools.permutations(digits, len(characters)):&lt;/p&gt;

&lt;p&gt;if zero not in guess[:n]:
equation = puzzle.translate(dict(zip(characters, guess)))
if eval(equation):&lt;/p&gt;

&lt;p&gt;return equation&lt;/p&gt;

&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == &amp;lsquo;&lt;strong&gt;main&lt;/strong&gt;&amp;lsquo;:
import sys
for puzzle in sys.argv[1:]:&lt;/p&gt;

&lt;p&gt;print(puzzle)
solution = solve(puzzle)
if solution:&lt;/p&gt;

&lt;p&gt;print(solution)&lt;/p&gt;

&lt;p&gt;You can run the program from the command line. On Linux, it would look like this. (These may take some time, depending on the speed of your computer, and there is no progress bar. Just be patient!)
you@localhost:~/diveintopython3/examples$ python3 alphametics.py &amp;ldquo;HAWAII + IDAHO + IOWA + OHIO == STATES&amp;rdquo;
HAWAII + IDAHO + IOWA + OHIO = STATES
510199 + 98153 + 9301 + 3593 == 621246
you@localhost:~/diveintopython3/examples$ python3 alphametics.py &amp;ldquo;I + LOVE + YOU == DORA&amp;rdquo;
I + LOVE + YOU == DORA
1 + 2784 + 975 == 3760
you@localhost:~/diveintopython3/examples$ python3 alphametics.py &amp;ldquo;SEND + MORE == MONEY&amp;rdquo;
SEND + MORE == MONEY
9567 + 1085 == 10652&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;8.2. FINDING ALL OCCURRENCES OF A PATTERN
The first thing this alphametics solver does is find all the letters (A–Z) in the puzzle.
&amp;gt;&amp;gt;&amp;gt; import re
&amp;gt;&amp;gt;&amp;gt; re.findall(&amp;rsquo;[0-9]+&amp;lsquo;, &amp;lsquo;16 2-by-4s in rows of 8&amp;rsquo;) .
[&amp;lsquo;16&amp;rsquo;, &amp;lsquo;2&amp;rsquo;, &amp;lsquo;4&amp;rsquo;, &amp;lsquo;8&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; re.findall(&amp;rsquo;[A-Z]+&amp;lsquo;, &amp;lsquo;SEND + MORE == MONEY&amp;rsquo;) .
[&amp;lsquo;SEND&amp;rsquo;, &amp;lsquo;MORE&amp;rsquo;, &amp;lsquo;MONEY&amp;rsquo;]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The re module is Python’s implementation of regular
expressions. It has a nifty function called findall() which takes a regular expression pattern and a string, and finds all occurrences of the pattern within the string. In this case, the pattern matches sequences of numbers. The findall() function returns a list of all the substrings that matched the pattern.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Here the regular expression pattern matches sequences of letters. Again, the return value is a list, and each item in the list is a string that matched the regular expression pattern.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here’s another example that will stretch your brain a little.
&amp;gt;&amp;gt;&amp;gt; re.findall(&amp;rsquo; s.*? s&amp;rsquo;, &amp;ldquo;The sixth sick sheikh&amp;rsquo;s sixth sheep&amp;rsquo;s sick.&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;[&amp;rsquo; sixth s&amp;rsquo;, &amp;ldquo; sheikh&amp;rsquo;s s&amp;rdquo;, &amp;ldquo; sheep&amp;rsquo;s s&amp;rdquo;]&lt;/p&gt;

&lt;p&gt;Surprised? The regular expression looks for a space, an
s, and then the shortest possible series of any character
(.*?), then a space, then another s. Well, looking at
that input string, I see five matches:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The sixth
s
ick sheikh&amp;rsquo;s sixth sheep&amp;rsquo;s sick.&lt;/li&gt;
&lt;li&gt;The sixth sick
s
heikh&amp;rsquo;s sixth sheep&amp;rsquo;s sick.&lt;/li&gt;
&lt;li&gt;The sixth sick sheikh&amp;rsquo;s
s
ixth sheep&amp;rsquo;s sick.&lt;/li&gt;
&lt;li&gt;The sixth sick sheikh&amp;rsquo;s sixth
s
heep&amp;rsquo;s sick.&lt;/li&gt;
&lt;li&gt;The sixth sick sheikh&amp;rsquo;s sixth sheep&amp;rsquo;s
s
ick.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;But the re.findall() function only returned three
matches. Specifically, it returned the first, the third, and
the fifth. Why is that? Because it doesn’t return
overlapping matches. The first match overlaps with the
second, so the first is returned and the second is
skipped. Then the third overlaps with the fourth, so the
third is returned and the fourth is skipped. Finally, the
fifth is returned. Three matches, not five.&lt;/p&gt;

&lt;p&gt;This has nothing to do with the alphametics solver; I just thought it was interesting.
.&lt;/p&gt;

&lt;p&gt;8.3. FINDING THE UNIQUE ITEMS IN A SEQUENCE
Sets
make it trivial to find the unique items in a sequence.
&amp;gt;&amp;gt;&amp;gt; a_list = [&amp;lsquo;The&amp;rsquo;, &amp;lsquo;sixth&amp;rsquo;, &amp;lsquo;sick&amp;rsquo;, &amp;ldquo;sheik&amp;rsquo;s&amp;rdquo;, &amp;lsquo;sixth&amp;rsquo;, &amp;ldquo;sheep&amp;rsquo;s&amp;rdquo;, &amp;lsquo;sick&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; set(a_list) .
{&amp;lsquo;sixth&amp;rsquo;, &amp;lsquo;The&amp;rsquo;, &amp;ldquo;sheep&amp;rsquo;s&amp;rdquo;, &amp;lsquo;sick&amp;rsquo;, &amp;ldquo;sheik&amp;rsquo;s&amp;rdquo;}
&amp;gt;&amp;gt;&amp;gt; a_string = &amp;lsquo;EAST IS EAST&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; set(a_string) .
{&amp;lsquo;A&amp;rsquo;, &amp;lsquo; &amp;lsquo;, &amp;lsquo;E&amp;rsquo;, &amp;lsquo;I&amp;rsquo;, &amp;rsquo;S&amp;rsquo;, &amp;rsquo;T&amp;rsquo;}
&amp;gt;&amp;gt;&amp;gt; words = [&amp;lsquo;SEND&amp;rsquo;, &amp;lsquo;MORE&amp;rsquo;, &amp;lsquo;MONEY&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; &amp;ldquo;.join(words) .
&amp;lsquo;SENDMOREMONEY&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; set(&amp;ldquo;.join(words)) .
{&amp;lsquo;E&amp;rsquo;, &amp;rsquo;D&amp;rsquo;, &amp;rsquo;M&amp;rsquo;, &amp;lsquo;O&amp;rsquo;, &amp;lsquo;N&amp;rsquo;, &amp;rsquo;S&amp;rsquo;, &amp;lsquo;R&amp;rsquo;, &amp;lsquo;Y&amp;rsquo;}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Given a list of several strings, the set() function will return a set of unique strings from the list. This makes sense if you think of it like a for loop. Take the first item from the list, put it in the set. Second. Third. Fourth. Fifth — wait, that’s in the set already, so it only gets listed once, because Python sets don’t allow duplicates. Sixth. Seventh — again, a duplicate, so it only gets listed once. The end result? All the unique items in the original list, without any duplicates. The original list doesn’t even need to be sorted first.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The same technique works with strings, since a string is just a sequence of characters.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given a list of strings, &amp;ldquo;.join(a_list) concatenates all the strings together into one.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So, given a list of strings, this line of code returns all the unique characters across all the strings, with no duplicates.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The alphametics solver uses this technique to build a set of all the unique characters in the puzzle.
unique_characters = set(&amp;ldquo;.join(words))&lt;/p&gt;

&lt;p&gt;This list is later used to assign digits to characters as the solver iterates through the possible solutions.
.&lt;/p&gt;

&lt;p&gt;8.4. MAKING ASSERTIONS
Like many programming languages, Python has an assert statement. Here’s how it works.
&amp;gt;&amp;gt;&amp;gt; assert 1 + 1 == 2 .
&amp;gt;&amp;gt;&amp;gt; assert 1 + 1 == 3 .&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
AssertionError&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;assert 2 + 2 == 5, &amp;ldquo;Only for very large values of 2&amp;rdquo; .
Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
AssertionError: Only for very large values of 2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The assert statement is followed by any valid Python expression. In this case, the expression 1 + 1 == 2 evaluates to True, so the assert statement does nothing.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;However, if the Python expression evaluates to False, the assert statement will raise an AssertionError.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can also include a human-readable message that is printed if the AssertionError is raised.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Therefore, this line of code:
assert len(unique_characters) &amp;lt;= 10, &amp;lsquo;Too many letters&amp;rsquo;&lt;/p&gt;

&lt;p&gt;…is equivalent to this:
if len(unique_characters) &amp;gt; 10:
raise AssertionError(&amp;lsquo;Too many letters&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;The alphametics solver uses this exact assert statement to bail out early if the puzzle contains more than ten unique letters. Since each letter is assigned a unique digit, and there are only ten digits, a puzzle with more than ten unique letters can not possibly have a solution.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;8.5. GENERATOR EXPRESSIONS&lt;/p&gt;

&lt;p&gt;A generator expression is like a generator
function
without the function.
&amp;gt;&amp;gt;&amp;gt; unique_characters = {&amp;lsquo;E&amp;rsquo;, &amp;rsquo;D&amp;rsquo;, &amp;rsquo;M&amp;rsquo;, &amp;lsquo;O&amp;rsquo;, &amp;lsquo;N&amp;rsquo;, &amp;rsquo;S&amp;rsquo;, &amp;lsquo;R&amp;rsquo;, &amp;lsquo;Y&amp;rsquo;}
&amp;gt;&amp;gt;&amp;gt; gen = (ord&amp;copy; for c in unique_characters) .
&amp;gt;&amp;gt;&amp;gt; gen .
&lt;generator object &lt;genexpr&gt; at 0x00BADC10&amp;gt;
&amp;gt;&amp;gt;&amp;gt; next(gen) .
69
&amp;gt;&amp;gt;&amp;gt; next(gen)
68
&amp;gt;&amp;gt;&amp;gt; tuple(ord&amp;copy; for c in unique_characters) .
(69, 68, 77, 79, 78, 83, 82, 89)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A generator expression is like an anonymous function that yields values. The expression itself looks like a list
comprehension, but it’s wrapped in parentheses instead of square brackets.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The generator expression returns… an iterator.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Calling next(gen) returns the next value from the iterator.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you like, you can iterate through all the possible values and return a tuple, list, or set, by passing the generator expression to tuple(), list(), or set(). In these cases, you don’t need an extra set of parentheses — just pass the “bare” expression ord&amp;copy; for c in unique_characters to the tuple() function, and Python figures out that it’s a generator expression.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. Using a generator expression instead of a list comprehension can save both CPU and RAM. If you’re building an list just to throw it away (e.g. passing it to tuple() or set()), use a generator expression instead!
Here’s another way to accomplish the same thing, using a generator
function:
def ord_map(a_string):
for c in a_string:
yield ord&amp;copy;&lt;/p&gt;

&lt;p&gt;gen = ord_map(unique_characters)&lt;/p&gt;

&lt;p&gt;The generator expression is more compact but functionally equivalent.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;8.6. CALCULATING PERMUTATIONS… THE LAZY WAY!
First of all, what the heck are permutations? Permutations are a mathematical concept. (There are actually several definitions, depending on what kind of math you’re doing. Here I’m talking about combinatorics, but if that doesn’t mean anything to you, don’t worry about it. As always, Wikipedia
is
your
friend.)
The idea is that you take a list of things (could be numbers, could be letters, could be dancing bears) and find all the possible ways to split them up into smaller lists. All the smaller lists have the same size, which can be as small as 1 and as large as the total number of items. Oh, and nothing can be repeated. Mathematicians say things like “let’s find the permutations of 3 different items taken 2 at a time,” which means you have a sequence of 3 items and you want to find all the possible ordered pairs.
&amp;gt;&amp;gt;&amp;gt; import itertools .
&amp;gt;&amp;gt;&amp;gt; perms = itertools.permutations([1, 2, 3], 2) .
&amp;gt;&amp;gt;&amp;gt; next(perms) .
(1, 2)
&amp;gt;&amp;gt;&amp;gt; next(perms)
(1, 3)
&amp;gt;&amp;gt;&amp;gt; next(perms)
(2, 1) .
&amp;gt;&amp;gt;&amp;gt; next(perms)
(2, 3)
&amp;gt;&amp;gt;&amp;gt; next(perms)
(3, 1)
&amp;gt;&amp;gt;&amp;gt; next(perms)
(3, 2)
&amp;gt;&amp;gt;&amp;gt; next(perms) .&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
StopIteration&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The itertools module has all kinds of fun stuff in it, including a permutations() function that does all the hard work of finding permutations.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The permutations() function takes a sequence (here a list of three integers) and a number, which is the number of items you want in each smaller group. The function returns an iterator, which you can use in a for loop or any old place that iterates. Here I’ll step through the iterator manually to show all the values.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The first permutation of [1, 2, 3] taken 2 at a time is (1, 2).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Note that permutations are ordered: (2, 1) is different than (1, 2).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That’s it! Those are all the permutations of [1, 2, 3] taken 2 at a time. Pairs like (1, 1) and (2, 2) never show up, because they contain repeats so they aren’t valid permutations. When there are no more permutations, the iterator raises a StopIteration exception.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The permutations() function doesn’t have to take a
list. It can take any sequence — even a string.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import itertools&lt;/p&gt;

&lt;p&gt;perms = itertools.permutations(&amp;lsquo;ABC&amp;rsquo;, 3) .
next(perms)
(&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;C&amp;rsquo;) .
next(perms)
(&amp;lsquo;A&amp;rsquo;, &amp;lsquo;C&amp;rsquo;, &amp;lsquo;B&amp;rsquo;)
next(perms)
(&amp;lsquo;B&amp;rsquo;, &amp;lsquo;A&amp;rsquo;, &amp;lsquo;C&amp;rsquo;)
next(perms)
(&amp;lsquo;B&amp;rsquo;, &amp;lsquo;C&amp;rsquo;, &amp;lsquo;A&amp;rsquo;)
next(perms)
(&amp;lsquo;C&amp;rsquo;, &amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;)
next(perms)
(&amp;lsquo;C&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;A&amp;rsquo;)
next(perms)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
StopIteration&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;list(itertools.permutations(&amp;lsquo;ABC&amp;rsquo;, 3)) .
[(&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;C&amp;rsquo;), (&amp;lsquo;A&amp;rsquo;, &amp;lsquo;C&amp;rsquo;, &amp;lsquo;B&amp;rsquo;),
(&amp;lsquo;B&amp;rsquo;, &amp;lsquo;A&amp;rsquo;, &amp;lsquo;C&amp;rsquo;), (&amp;lsquo;B&amp;rsquo;, &amp;lsquo;C&amp;rsquo;, &amp;lsquo;A&amp;rsquo;),
(&amp;lsquo;C&amp;rsquo;, &amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;), (&amp;lsquo;C&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;A&amp;rsquo;)]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A string is just a sequence of characters. For the purposes of finding permutations, the string &amp;lsquo;ABC&amp;rsquo; is equivalent to the list [&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;C&amp;rsquo;].&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The first permutation of the 3 items [&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;C&amp;rsquo;], taken 3 at a time, is (&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;C&amp;rsquo;). There are five other permutations — the same three characters in every conceivable order.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Since the permutations() function always returns an iterator, an easy way to debug permutations is to pass that iterator to the built-in list() function to see all the permutations immediately.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;8.7. OTHER FUN STUFF IN THE itertools MODULE&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import itertools
list(itertools.product(&amp;lsquo;ABC&amp;rsquo;, &amp;lsquo;123&amp;rsquo;)) .
[(&amp;lsquo;A&amp;rsquo;, &amp;lsquo;1&amp;rsquo;), (&amp;lsquo;A&amp;rsquo;, &amp;lsquo;2&amp;rsquo;), (&amp;lsquo;A&amp;rsquo;, &amp;lsquo;3&amp;rsquo;),&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;(&amp;lsquo;B&amp;rsquo;, &amp;lsquo;1&amp;rsquo;), (&amp;lsquo;B&amp;rsquo;, &amp;lsquo;2&amp;rsquo;), (&amp;lsquo;B&amp;rsquo;, &amp;lsquo;3&amp;rsquo;),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;C&amp;rsquo;, &amp;lsquo;1&amp;rsquo;), (&amp;lsquo;C&amp;rsquo;, &amp;lsquo;2&amp;rsquo;), (&amp;lsquo;C&amp;rsquo;, &amp;lsquo;3&amp;rsquo;)]
&amp;gt;&amp;gt;&amp;gt; list(itertools.combinations(&amp;lsquo;ABC&amp;rsquo;, 2)) .
[(&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;), (&amp;lsquo;A&amp;rsquo;, &amp;lsquo;C&amp;rsquo;), (&amp;lsquo;B&amp;rsquo;, &amp;lsquo;C&amp;rsquo;)]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The itertools.product() function returns an iterator containing the Cartesian product of two sequences.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The itertools.combinations() function returns an iterator containing all the possible combinations of the given sequence of the given length. This is like the itertools.permutations() function, except combinations don’t include items that are duplicates of other items in a different order. So itertools.permutations(&amp;lsquo;ABC&amp;rsquo;, 2) will return both (&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;) and (&amp;lsquo;B&amp;rsquo;, &amp;lsquo;A&amp;rsquo;) (among others), but itertools.combinations(&amp;lsquo;ABC&amp;rsquo;, 2) will not return (&amp;lsquo;B&amp;rsquo;, &amp;lsquo;A&amp;rsquo;) because it is a duplicate of (&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;) in a different order.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;names = list(open(&amp;lsquo;examples/favorite-people.txt&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;)) .
names
[&amp;lsquo;Dora\n&amp;rsquo;, &amp;lsquo;Ethan\n&amp;rsquo;, &amp;lsquo;Wesley\n&amp;rsquo;, &amp;lsquo;John\n&amp;rsquo;, &amp;lsquo;Anne\n&amp;rsquo;,
&amp;lsquo;Mike\n&amp;rsquo;, &amp;lsquo;Chris\n&amp;rsquo;, &amp;lsquo;Sarah\n&amp;rsquo;, &amp;lsquo;Alex\n&amp;rsquo;, &amp;lsquo;Lizzie\n&amp;rsquo;]
names = [name.rstrip() for name in names] .
names
[&amp;lsquo;Dora&amp;rsquo;, &amp;lsquo;Ethan&amp;rsquo;, &amp;lsquo;Wesley&amp;rsquo;, &amp;lsquo;John&amp;rsquo;, &amp;lsquo;Anne&amp;rsquo;,
&amp;lsquo;Mike&amp;rsquo;, &amp;lsquo;Chris&amp;rsquo;, &amp;lsquo;Sarah&amp;rsquo;, &amp;lsquo;Alex&amp;rsquo;, &amp;lsquo;Lizzie&amp;rsquo;]
names = sorted(names) .
names
[&amp;lsquo;Alex&amp;rsquo;, &amp;lsquo;Anne&amp;rsquo;, &amp;lsquo;Chris&amp;rsquo;, &amp;lsquo;Dora&amp;rsquo;, &amp;lsquo;Ethan&amp;rsquo;,
&amp;lsquo;John&amp;rsquo;, &amp;lsquo;Lizzie&amp;rsquo;, &amp;lsquo;Mike&amp;rsquo;, &amp;lsquo;Sarah&amp;rsquo;, &amp;lsquo;Wesley&amp;rsquo;]
names = sorted(names, key=len) .
names
[&amp;lsquo;Alex&amp;rsquo;, &amp;lsquo;Anne&amp;rsquo;, &amp;lsquo;Dora&amp;rsquo;, &amp;lsquo;John&amp;rsquo;, &amp;lsquo;Mike&amp;rsquo;,
&amp;lsquo;Chris&amp;rsquo;, &amp;lsquo;Ethan&amp;rsquo;, &amp;lsquo;Sarah&amp;rsquo;, &amp;lsquo;Lizzie&amp;rsquo;, &amp;lsquo;Wesley&amp;rsquo;]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This idiom returns a list of the lines in a text file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unfortunately (for this example), the list(open(filename)) idiom also includes the carriage returns at the end of each line. This list comprehension uses the rstrip() string method to strip trailing whitespace from each line. (Strings also have an lstrip() method to strip leading whitespace, and a strip() method which strips both.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The sorted() function takes a list and returns it sorted. By default, it sorts alphabetically.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;But the sorted() function can also take a function as the key parameter, and it sorts by that key. In this case, the sort function is len(), so it sorts by len(each item). Shorter names come first, then longer, then longest.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What does this have to do with the itertools module? I’m glad you asked.
…continuing from the previous interactive shell…&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import itertools
groups = itertools.groupby(names, len) .
groups
&lt;itertools.groupby object at 0x00BB20C0&gt;
list(groups)
[(4, &lt;itertools._grouper object at 0x00BA8BF0&gt;),&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;(5, &lt;itertools._grouper object at 0x00BB4050&gt;),&lt;/p&gt;

&lt;p&gt;(6, &lt;itertools._grouper object at 0x00BB4030&gt;)]
&amp;gt;&amp;gt;&amp;gt; groups = itertools.groupby(names, len) .
&amp;gt;&amp;gt;&amp;gt; for name_length, name_iter in groups: .
&amp;hellip; print(&amp;lsquo;Names with {0:d} letters:&amp;lsquo;.format(name_length))
&amp;hellip; for name in name_iter:
&amp;hellip; print(name)
&amp;hellip;&lt;/p&gt;

&lt;p&gt;Names with 4 letters:
Alex
Anne
Dora
John
Mike
Names with 5 letters:
Chris
Ethan
Sarah
Names with 6 letters:
Lizzie
Wesley&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The itertools.groupby() function takes a sequence and a key function, and returns an iterator that generates pairs. Each pair contains the result of key_function(each item) and another iterator containing all the items that shared that key result.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Calling the list() function “exhausted” the iterator, i.e. you’ve already generated every item in the iterator to make the list. There’s no “reset” button on an iterator; you can’t just start over once you’ve exhausted&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;it. If you want to loop through it again (say, in the upcoming for loop), you need to call
itertools.groupby() again to create a new iterator.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;In this example, given a list of names already sorted by length, itertools.groupby(names, len) will put all the 4-letter names in one iterator, all the 5-letter names in another iterator, and so on. The groupby() function is completely generic; it could group strings by first letter, numbers by their number of factors, or any other key function you can think of.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. The itertools.groupby() function only works if the input sequence is already sorted by the grouping function. In the example above, you grouped a list of names by the len() function. That only worked because the input list was already sorted by length.
Are you watching closely?
&amp;gt;&amp;gt;&amp;gt; list(range(0, 3))
[0, 1, 2]
&amp;gt;&amp;gt;&amp;gt; list(range(10, 13))
[10, 11, 12]
&amp;gt;&amp;gt;&amp;gt; list(itertools.chain(range(0, 3), range(10, 13))) .
[0, 1, 2, 10, 11, 12]
&amp;gt;&amp;gt;&amp;gt; list(zip(range(0, 3), range(10, 13))) .
[(0, 10), (1, 11), (2, 12)]
&amp;gt;&amp;gt;&amp;gt; list(zip(range(0, 3), range(10, 14))) .
[(0, 10), (1, 11), (2, 12)]
&amp;gt;&amp;gt;&amp;gt; list(itertools.zip_longest(range(0, 3), range(10, 14))) .
[(0, 10), (1, 11), (2, 12), (None, 13)]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The itertools.chain() function takes two iterators and returns an iterator that contains all the items from the first iterator, followed by all the items from the second iterator. (Actually, it can take any number of iterators, and it chains them all in the order they were passed to the function.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The zip() function does something prosaic that turns out to be extremely useful: it takes any number of sequences and returns an iterator which returns tuples of the first items of each sequence, then the second items of each, then the third, and so on.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The zip() function stops at the end of the shortest sequence. range(10, 14) has 4 items (10, 11, 12, and 13), but range(0, 3) only has 3, so the zip() function returns an iterator of 3 items.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;On the other hand, the itertools.zip_longest() function stops at the end of the longest sequence, inserting None values for items past the end of the shorter sequences.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OK, that was all very interesting, but how does it relate to the alphametics solver? Here’s how:
&amp;gt;&amp;gt;&amp;gt; characters = (&amp;rsquo;S&amp;rsquo;, &amp;rsquo;M&amp;rsquo;, &amp;lsquo;E&amp;rsquo;, &amp;rsquo;D&amp;rsquo;, &amp;lsquo;O&amp;rsquo;, &amp;lsquo;N&amp;rsquo;, &amp;lsquo;R&amp;rsquo;, &amp;lsquo;Y&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; guess = (&amp;lsquo;1&amp;rsquo;, &amp;lsquo;2&amp;rsquo;, &amp;lsquo;0&amp;rsquo;, &amp;lsquo;3&amp;rsquo;, &amp;lsquo;4&amp;rsquo;, &amp;lsquo;5&amp;rsquo;, &amp;lsquo;6&amp;rsquo;, &amp;lsquo;7&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; tuple(zip(characters, guess)) .
((&amp;rsquo;S&amp;rsquo;, &amp;lsquo;1&amp;rsquo;), (&amp;rsquo;M&amp;rsquo;, &amp;lsquo;2&amp;rsquo;), (&amp;lsquo;E&amp;rsquo;, &amp;lsquo;0&amp;rsquo;), (&amp;rsquo;D&amp;rsquo;, &amp;lsquo;3&amp;rsquo;),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;O&amp;rsquo;, &amp;lsquo;4&amp;rsquo;), (&amp;lsquo;N&amp;rsquo;, &amp;lsquo;5&amp;rsquo;), (&amp;lsquo;R&amp;rsquo;, &amp;lsquo;6&amp;rsquo;), (&amp;lsquo;Y&amp;rsquo;, &amp;lsquo;7&amp;rsquo;))
&amp;gt;&amp;gt;&amp;gt; dict(zip(characters, guess)) .
{&amp;lsquo;E&amp;rsquo;: &amp;lsquo;0&amp;rsquo;, &amp;rsquo;D&amp;rsquo;: &amp;lsquo;3&amp;rsquo;, &amp;rsquo;M&amp;rsquo;: &amp;lsquo;2&amp;rsquo;, &amp;lsquo;O&amp;rsquo;: &amp;lsquo;4&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;N&amp;rsquo;: &amp;lsquo;5&amp;rsquo;, &amp;rsquo;S&amp;rsquo;: &amp;lsquo;1&amp;rsquo;, &amp;lsquo;R&amp;rsquo;: &amp;lsquo;6&amp;rsquo;, &amp;lsquo;Y&amp;rsquo;: &amp;lsquo;7&amp;rsquo;}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Given a list of letters and a list of digits (each represented here as 1-character strings), the zip function will create a pairing of letters and digits, in order.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why is that cool? Because that data structure happens to be exactly the right structure to pass to the dict() function to create a dictionary that uses letters as keys and their associated digits as values. (This isn’t the only way to do it, of course. You could use a dictionary
comprehension
to create the dictionary directly.) Although the printed representation of the dictionary lists the pairs in a different order (dictionaries have no “order” per se), you can see that each letter is associated with the digit, based on the ordering of the original characters and guess sequences.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The alphametics solver uses this technique to create a dictionary that maps letters in the puzzle to digits in the solution, for each possible solution.
characters = tuple(ord&amp;copy; for c in sorted_characters)&lt;/p&gt;

&lt;p&gt;digits = tuple(ord&amp;copy; for c in &amp;lsquo;0123456789&amp;rsquo;)
&amp;hellip;
for guess in itertools.permutations(digits, len(characters)):&lt;/p&gt;

&lt;p&gt;&amp;hellip;
equation = puzzle.translate(dict(zip(characters, guess)))&lt;/p&gt;

&lt;p&gt;But what is this translate() method? Ah, now you’re getting to the really fun part.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;8.8. A NEW KIND OF STRING MANIPULATION
Python strings have many methods. You learned about some of those methods in the
Strings
chapter: lower(), count(), and format(). Now I want to introduce you to a powerful but little-known string manipulation technique: the translate() method.
&amp;gt;&amp;gt;&amp;gt; translation_table = {ord(&amp;lsquo;A&amp;rsquo;): ord(&amp;lsquo;O&amp;rsquo;)} .
&amp;gt;&amp;gt;&amp;gt; translation_table .
{65: 79}
&amp;gt;&amp;gt;&amp;gt; &amp;lsquo;MARK&amp;rsquo;.translate(translation_table) .
&amp;lsquo;MORK&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;String translation starts with a translation table, which is just a dictionary that maps one character to another. Actually, “character” is incorrect — the translation table really maps one byte to another.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Remember, bytes in Python 3 are integers. The ord() function returns the ASCII value of a character, which, in the case of A–Z, is always a byte from 65 to 90.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The translate() method on a string takes a translation table and runs the string through it. That is, it replaces all occurrences of the keys of the translation table with the corresponding values. In this case, “translating” MARK to MORK.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What does this have to do with solving alphametic puzzles? As it turns out, everything.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;characters = tuple(ord&amp;copy; for c in &amp;lsquo;SMEDONRY&amp;rsquo;) .
characters
(83, 77, 69, 68, 79, 78, 82, 89)
guess = tuple(ord&amp;copy; for c in &amp;lsquo;91570682&amp;rsquo;) .
guess
(57, 49, 53, 55, 48, 54, 56, 50)
translation_table = dict(zip(characters, guess)) .
translation_table&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;{68: 55, 69: 53, 77: 49, 78: 54, 79: 48, 82: 56, 83: 57, 89: 50}
&amp;gt;&amp;gt;&amp;gt; &amp;lsquo;SEND + MORE == MONEY&amp;rsquo;.translate(translation_table) .
&amp;lsquo;9567 + 1085 == 10652&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Using a generator
expression, we quickly compute the byte values for each character in a string. characters is an example of the value of sorted_characters in the alphametics.solve() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using another generator expression, we quickly compute the byte values for each digit in this string. The result, guess, is of the form returned
by
the
itertools.permutations() function
in the alphametics.solve() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This translation table is generated by zipping
characters and
guess together
and building a dictionary from the resulting sequence of pairs. This is exactly what the alphametics.solve() function does inside the for loop.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, we pass this translation table to the translate() method of the original puzzle string. This converts each letter in the string to the corresponding digit (based on the letters in characters and the digits in guess). The result is a valid Python expression, as a string.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s pretty impressive. But what can you do with a string that happens to be a valid Python expression?&lt;/p&gt;

&lt;p&gt;.
8.9. EVALUATING ARBITRARY STRINGS AS PYTHON EXPRESSIONS
This is the final piece of the puzzle (or rather, the final piece of the puzzle solver). After all that fancy string manipulation, we’re left with a string like &amp;lsquo;9567 + 1085 == 10652&amp;rsquo;. But that’s a string, and what good is a string? Enter eval(), the universal Python evaluation tool.
&amp;gt;&amp;gt;&amp;gt; eval(&amp;lsquo;1 + 1 == 2&amp;rsquo;)
True
&amp;gt;&amp;gt;&amp;gt; eval(&amp;lsquo;1 + 1 == 3&amp;rsquo;)
False
&amp;gt;&amp;gt;&amp;gt; eval(&amp;lsquo;9567 + 1085 == 10652&amp;rsquo;)
True&lt;/p&gt;

&lt;p&gt;But wait, there’s more! The eval() function isn’t limited to boolean expressions. It can handle any Python expression and returns any datatype.
&amp;gt;&amp;gt;&amp;gt; eval(&amp;lsquo;&amp;ldquo;A&amp;rdquo; + &amp;ldquo;B&amp;rdquo;&amp;rsquo;)
&amp;lsquo;AB&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; eval(&amp;lsquo;&amp;ldquo;MARK&amp;rdquo;.translate({65: 79})&amp;lsquo;)
&amp;lsquo;MORK&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; eval(&amp;lsquo;&amp;ldquo;AAAAA&amp;rdquo;.count(&amp;ldquo;A&amp;rdquo;)&amp;rsquo;)
5
&amp;gt;&amp;gt;&amp;gt; eval(&amp;rsquo;[&amp;rdquo;*&amp;ldquo;] * 5&amp;rsquo;)
[&amp;rsquo;&lt;em&gt;&amp;rsquo;, &amp;lsquo;&lt;/em&gt;&amp;rsquo;, &amp;lsquo;&lt;em&gt;&amp;rsquo;, &amp;lsquo;&lt;/em&gt;&amp;rsquo;, &amp;lsquo;*&amp;lsquo;]&lt;/p&gt;

&lt;p&gt;But wait, that’s not all!
&amp;gt;&amp;gt;&amp;gt; x = 5
&amp;gt;&amp;gt;&amp;gt; eval(&amp;ldquo;x * 5&amp;rdquo;) .
25
&amp;gt;&amp;gt;&amp;gt; eval(&amp;ldquo;pow(x, 2)&amp;rdquo;) .
25
&amp;gt;&amp;gt;&amp;gt; import math
&amp;gt;&amp;gt;&amp;gt; eval(&amp;ldquo;math.sqrt(x)&amp;rdquo;) .
2.2360679774997898&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The expression that eval() takes can reference global variables defined outside the eval(). If called within a function, it can reference local variables too.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And functions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And modules.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hey, wait a minute…
&amp;gt;&amp;gt;&amp;gt; import subprocess
&amp;gt;&amp;gt;&amp;gt; eval(&amp;ldquo;subprocess.getoutput(&amp;lsquo;ls ~&amp;lsquo;)&amp;ldquo;) .
&amp;lsquo;Desktop Library Pictures &lt;/p&gt;

&lt;p&gt;Documents Movies Public \
Music Sites&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; eval(&amp;ldquo;subprocess.getoutput(&amp;lsquo;rm /some/random/file&amp;rsquo;)&amp;rdquo;) .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The subprocess module allows you to run arbitrary shell commands and get the result as a Python string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Arbitrary shell commands can have permanent consequences.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It’s even worse than that, because there’s a global &lt;strong&gt;import&lt;/strong&gt;() function that takes a module name as a string, imports the module, and returns a reference to it. Combined with the power of eval(), you can construct a single expression that will wipe out all your files:
&amp;gt;&amp;gt;&amp;gt; eval(&amp;rdquo;&lt;strong&gt;import&lt;/strong&gt;(&amp;lsquo;subprocess&amp;rsquo;).getoutput(&amp;lsquo;rm /some/random/file&amp;rsquo;)&amp;ldquo;) .
1.  Now imagine the output of &amp;lsquo;rm -rf ~&amp;lsquo;. Actually there wouldn’t be any output, but you wouldn’t have any files left either.&lt;/p&gt;

&lt;p&gt;eval() is
EVIL&lt;/p&gt;

&lt;p&gt;Well, the evil part is evaluating arbitrary expressions from untrusted sources. You should only use eval() on trusted input. Of course, the trick is figuring out what’s “trusted.” But here’s something I know for certain: you should NOT take this alphametics solver and put it on the internet as a fun little web service. Don’t make the mistake of thinking, “Gosh, the function does a lot of string manipulation before getting a string to evaluate; I can’t imagine how someone could exploit that.” Someone WILL figure out how to sneak nasty executable code past all that string manipulation (stranger
things
have
happened), and then you can kiss your server goodbye.
But surely there’s some way to evaluate expressions safely? To put eval() in a sandbox where it can’t access or harm the outside world? Well, yes and no.
&amp;gt;&amp;gt;&amp;gt; x = 5
&amp;gt;&amp;gt;&amp;gt; eval(&amp;ldquo;x * 5&amp;rdquo;, {}, {}) .&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
File &amp;ldquo;&lt;string&gt;&amp;rdquo;, line 1, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;NameError: name &amp;lsquo;x&amp;rsquo; is not defined&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;eval(&amp;ldquo;x * 5&amp;rdquo;, {&amp;ldquo;x&amp;rdquo;: x}, {}) .
import math
eval(&amp;ldquo;math.sqrt(x)&amp;rdquo;, {&amp;ldquo;x&amp;rdquo;: x}, {}) .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
File &amp;ldquo;&lt;string&gt;&amp;rdquo;, line 1, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;NameError: name &amp;lsquo;math&amp;rsquo; is not defined&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The second and third parameters passed to the eval() function act as the global and local namespaces for evaluating the expression. In this case, they are both empty, which means that when the string &amp;ldquo;x * 5&amp;rdquo; is evaluated, there is no reference to x in either the global or local namespace, so eval() throws an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can selectively include specific values in the global namespace by listing them individually. Then those — and only those — variables will be available during evaluation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Even though you just imported the math module, you didn’t include it in the namespace passed to the eval() function, so the evaluation failed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Gee, that was easy. Lemme make an alphametics web service now!
&amp;gt;&amp;gt;&amp;gt; eval(&amp;ldquo;pow(5, 2)&amp;rdquo;, {}, {}) .
25
&amp;gt;&amp;gt;&amp;gt; eval(&amp;rdquo;&lt;strong&gt;import&lt;/strong&gt;(&amp;lsquo;math&amp;rsquo;).sqrt(5)&amp;ldquo;, {}, {}) .
2.2360679774997898&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Even though you’ve passed empty dictionaries for the global and local namespaces, all of Python’s built-in functions are still available during evaluation. So pow(5, 2) works, because 5 and 2 are literals, and pow() is a built-in function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unfortunately (and if you don’t see why it’s unfortunate, read on), the &lt;strong&gt;import&lt;/strong&gt;() function is also a built-in function, so it works too.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Yeah, that means you can still do nasty things, even if you explicitly set the global and local namespaces to empty dictionaries when calling eval():
&amp;gt;&amp;gt;&amp;gt; eval(&amp;rdquo;&lt;strong&gt;import&lt;/strong&gt;(&amp;lsquo;subprocess&amp;rsquo;).getoutput(&amp;lsquo;rm /some/random/file&amp;rsquo;)&amp;ldquo;, {}, {})&lt;/p&gt;

&lt;p&gt;Oops. I’m glad I didn’t make that alphametics web service. Is there any way to use eval() safely? Well, yes and no.
&amp;gt;&amp;gt;&amp;gt; eval(&amp;rdquo;&lt;strong&gt;import&lt;/strong&gt;(&amp;lsquo;math&amp;rsquo;).sqrt(5)&amp;ldquo;,
&amp;hellip; {&amp;rdquo;&lt;strong&gt;builtins&lt;/strong&gt;&amp;ldquo;:None}, {}) .&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
File &amp;ldquo;&lt;string&gt;&amp;rdquo;, line 1, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;NameError: name &amp;lsquo;&lt;strong&gt;import&lt;/strong&gt;&amp;rsquo; is not defined&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;eval(&amp;rdquo;&lt;strong&gt;import&lt;/strong&gt;(&amp;lsquo;subprocess&amp;rsquo;).getoutput(&amp;lsquo;rm -rf /&amp;rsquo;)&amp;ldquo;,
&amp;hellip; {&amp;rdquo;&lt;strong&gt;builtins&lt;/strong&gt;&amp;ldquo;:None}, {}) .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
File &amp;ldquo;&lt;string&gt;&amp;rdquo;, line 1, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;NameError: name &amp;lsquo;&lt;strong&gt;import&lt;/strong&gt;&amp;rsquo; is not defined&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;To evaluate untrusted expressions safely, you need to define a global namespace dictionary that maps &amp;ldquo;&lt;strong&gt;builtins&lt;/strong&gt;&amp;rdquo; to None, the Python null value. Internally, the “built-in” functions are contained within a&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;pseudo-module called &amp;ldquo;&lt;strong&gt;builtins&lt;/strong&gt;&amp;rdquo;. This pseudo-module (i.e. the set of built-in functions) is made
available to evaluated expressions unless you explicitly override it.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Be sure you’ve overridden &lt;strong&gt;builtins&lt;/strong&gt;. Not &lt;strong&gt;builtin&lt;/strong&gt;, &lt;strong&gt;built-ins&lt;/strong&gt;, or some other variation that will work just fine but expose you to catastrophic risks.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So  eval() is safe now? Well, yes and no.
&amp;gt;&amp;gt;&amp;gt; eval(&amp;ldquo;2 ** 2147483647&amp;rdquo;,
&amp;hellip; {&amp;rdquo;&lt;strong&gt;builtins&lt;/strong&gt;&amp;ldquo;:None}, {}) .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Even without access to &lt;strong&gt;builtins&lt;/strong&gt;, you can still launch a denial-of-service attack. For example, trying to raise 2 to the 2147483647th power will spike your server’s CPU utilization to 100% for quite some time. (If you’re trying this in the interactive shell, press Ctrl-C a few times to break out of it.) Technically this expression will return a value eventually, but in the meantime your server will be doing a whole lot of nothing.
In the end, it is possible to safely evaluate untrusted Python expressions, for some definition of “safe” that turns out not to be terribly useful in real life. It’s fine if you’re just playing around, and it’s fine if you only ever pass it trusted input. But anything else is just asking for trouble.
.
8.10. PUTTING IT ALL TOGETHER
To recap: this program solves alphametic puzzles by brute force, i.e. through an exhaustive search of all possible solutions. To do this, it…&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finds
all
the
letters
in
the
puzzle
with the re.findall() function&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Find
all
the
unique letters
in
the
puzzle
with sets and the set() function&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Checks
if
there
are
more
than&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unique
letters
(meaning the puzzle is definitely unsolvable) with an assert statement&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Converts the letters to their ASCII equivalents with a generator object&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Calculates
all
the
possible
solutions
with the itertools.permutations() function&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Converts
each
possible
solution
to
a
Python
expression
with the translate() string method&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tests
each
possible
solution
by
evaluating
the
Python
expression
with the eval() function&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Returns the first solution that evaluates to True&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;…in just 14 lines of code.
.&lt;/p&gt;

&lt;p&gt;8.11. FURTHER READING
• itertools module&lt;/p&gt;

&lt;p&gt;• itertools —
Iterator
functions
for
efficient
looping&lt;/p&gt;

&lt;p&gt;• Watch
Raymond
Hettinger’s
“Easy
AI
with
Python”
talk
at PyCon 2009&lt;/p&gt;

&lt;p&gt;• Recipe
576615:
Alphametics
solver, Raymond Hettinger’s original alphametics solver for Python 2&lt;/p&gt;

&lt;p&gt;• More
of
Raymond
Hettinger’s
recipes
in the ActiveState Code repository&lt;/p&gt;

&lt;p&gt;• Alphametics
on
Wikipedia&lt;/p&gt;

&lt;p&gt;• Alphametics
Index, including lots
of
puzzles
and a
generator
to
make
your
own&lt;/p&gt;

&lt;p&gt;Many thanks to Raymond Hettinger for agreeing to relicense his code so I could port it to Python 3 and use it as the basis for this chapter.
CHAPTER 9. UNIT TESTING&lt;/p&gt;

&lt;p&gt;. Certitude is not the test of certainty. We have been cocksure of many things that were not so. .
—   Oliver Wendell Holmes, Jr.
9.1. (NOT) DIVING IN
Kids today. So spoiled by these fast computers and fancy “dynamic” languages. Write first, ship second, debug third (if ever). In my day, we had discipline. Discipline, I say! We had to write programs by hand, on paper, and feed them to the computer on punchcards. And we liked it!
In this chapter, you’re going to write and debug a set of utility functions to convert to and from Roman numerals. You saw the mechanics of constructing and validating Roman numerals in “Case
study:
roman
numerals”. Now step back and consider what it would take to expand that into a two-way utility.
The
rules
for
Roman
numerals
lead to a number of interesting observations:
1.  There is only one correct way to represent a particular number as a Roman numeral.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The converse is also true: if a string of characters is a valid Roman numeral, it represents only one number (that is, it can only be interpreted one way).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There is a limited range of numbers that can be expressed as Roman numerals, specifically 1 through 3999. The Romans did have several ways of expressing larger numbers, for instance by having a bar over a numeral to represent that its normal value should be multiplied by 1000. For the purposes of this chapter, let’s stipulate that Roman numerals go from 1 to 3999.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There is no way to represent 0 in Roman numerals.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There is no way to represent negative numbers in Roman numerals.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There is no way to represent fractions or non-integer numbers in Roman numerals.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s start mapping out what a roman.py module should do. It will have two main functions, to_roman() and
from_roman(). The to_roman() function should take an integer from 1 to 3999 and return the Roman
numeral representation as a string…&lt;/p&gt;

&lt;p&gt;Stop right there. Now let’s do something a little unexpected: write a test case that checks whether the to_roman() function does what you want it to. You read that right: you’re going to write code that tests code that you haven’t written yet.
This is called test-driven development, or TDD. The set of two conversion functions — to_roman(), and later from_roman() — can be written and tested as a unit, separate from any larger program that imports them. Python has a framework for unit testing, the appropriately-named unittest module.
Unit testing is an important part of an overall testing-centric development strategy. If you write unit tests, it is important to write them early and to keep them updated as code and requirements change. Many people advocate writing tests before they write the code they’re testing, and that’s the style I’m going to demonstrate in this chapter. But unit tests are beneficial no matter when you write them.
•   Before writing code, writing unit tests forces you to detail your requirements in a useful fashion.&lt;/p&gt;

&lt;p&gt;•   While writing code, unit tests keep you from over-coding. When all the test cases pass, the function is complete.&lt;/p&gt;

&lt;p&gt;•   When refactoring code, they can help prove that the new version behaves the same way as the old version.&lt;/p&gt;

&lt;p&gt;•   When maintaining code, having tests will help you cover your ass when someone comes screaming that your latest change broke their old code. (“But sir, all the unit tests passed when I checked it in&amp;hellip;”)&lt;/p&gt;

&lt;p&gt;•   When writing code in a team, having a comprehensive test suite dramatically decreases the chances that your code will break someone else’s code, because you can run their unit tests first. (I’ve seen this sort of thing in code sprints. A team breaks up the assignment, everybody takes the specs for their task, writes unit tests for it, then shares their unit tests with the rest of the team. That way, nobody goes off too far into developing code that doesn’t play well with others.)&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;9.2. A SINGLE QUESTION
A test case answers a single question about the code it is testing. A test case should be able to&amp;hellip;
•   &amp;hellip;run completely by itself, without any human input. Unit testing is about automation.&lt;/p&gt;

&lt;p&gt;•   &amp;hellip;determine by itself whether the function it is testing has passed or failed, without a human interpreting the results.&lt;/p&gt;

&lt;p&gt;•   &amp;hellip;run in isolation, separate from any other test cases (even if they test the same functions). Each test case is&lt;/p&gt;

&lt;p&gt;an island.
Given that, let’s build a test case for the first requirement:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The to_roman() function should return the Roman numeral representation for all integers 1 to 3999.
It is not immediately obvious how this code does… well, anything. It defines a class which has no &lt;strong&gt;init&lt;/strong&gt;() method. The class does have another method, but it is never called. The entire script has a &lt;strong&gt;main&lt;/strong&gt; block, but it doesn’t reference the class or its method. But it does do something, I promise.
import roman1
import unittest&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;class KnownValues(unittest.TestCase): . known_values = ( (1, &amp;lsquo;I&amp;rsquo;),
(2, &amp;lsquo;II&amp;rsquo;),
(3, &amp;lsquo;III&amp;rsquo;),
(4, &amp;lsquo;IV&amp;rsquo;),
(5, &amp;lsquo;V&amp;rsquo;),
(6, &amp;lsquo;VI&amp;rsquo;),
(7, &amp;lsquo;VII&amp;rsquo;),
(8, &amp;lsquo;VIII&amp;rsquo;),
(9, &amp;lsquo;IX&amp;rsquo;),
(10, &amp;lsquo;X&amp;rsquo;),
(50, &amp;lsquo;L&amp;rsquo;),
(100, &amp;lsquo;C&amp;rsquo;),
(500, &amp;rsquo;D&amp;rsquo;),
(1000, &amp;rsquo;M&amp;rsquo;),
(31, &amp;lsquo;XXXI&amp;rsquo;),
(148, &amp;lsquo;CXLVIII&amp;rsquo;),
(294, &amp;lsquo;CCXCIV&amp;rsquo;),
(312, &amp;lsquo;CCCXII&amp;rsquo;),
(421, &amp;lsquo;CDXXI&amp;rsquo;),
(528, &amp;lsquo;DXXVIII&amp;rsquo;),
(621, &amp;lsquo;DCXXI&amp;rsquo;),
(782, &amp;lsquo;DCCLXXXII&amp;rsquo;),
(870, &amp;lsquo;DCCCLXX&amp;rsquo;),
(941, &amp;lsquo;CMXLI&amp;rsquo;),
(1043, &amp;lsquo;MXLIII&amp;rsquo;),
(1110, &amp;lsquo;MCX&amp;rsquo;),
(1226, &amp;lsquo;MCCXXVI&amp;rsquo;),
(1301, &amp;lsquo;MCCCI&amp;rsquo;),
(1485, &amp;lsquo;MCDLXXXV&amp;rsquo;),
(1509, &amp;lsquo;MDIX&amp;rsquo;),&lt;/p&gt;

&lt;p&gt;(1607, &amp;lsquo;MDCVII&amp;rsquo;),&lt;/p&gt;

&lt;p&gt;(1754, &amp;lsquo;MDCCLIV&amp;rsquo;), (1832, &amp;lsquo;MDCCCXXXII&amp;rsquo;), (1993, &amp;lsquo;MCMXCIII&amp;rsquo;), (2074, &amp;lsquo;MMLXXIV&amp;rsquo;), (2152, &amp;lsquo;MMCLII&amp;rsquo;), (2212, &amp;lsquo;MMCCXII&amp;rsquo;), (2343, &amp;lsquo;MMCCCXLIII&amp;rsquo;), (2499, &amp;lsquo;MMCDXCIX&amp;rsquo;), (2574, &amp;lsquo;MMDLXXIV&amp;rsquo;), (2646, &amp;lsquo;MMDCXLVI&amp;rsquo;), (2723, &amp;lsquo;MMDCCXXIII&amp;rsquo;), (2892, &amp;lsquo;MMDCCCXCII&amp;rsquo;), (2975, &amp;lsquo;MMCMLXXV&amp;rsquo;), (3051, &amp;lsquo;MMMLI&amp;rsquo;), (3185, &amp;lsquo;MMMCLXXXV&amp;rsquo;), (3250, &amp;lsquo;MMMCCL&amp;rsquo;), (3313, &amp;lsquo;MMMCCCXIII&amp;rsquo;), (3408, &amp;lsquo;MMMCDVIII&amp;rsquo;), (3501, &amp;lsquo;MMMDI&amp;rsquo;), (3610, &amp;lsquo;MMMDCX&amp;rsquo;), (3743, &amp;lsquo;MMMDCCXLIII&amp;rsquo;), (3844, &amp;lsquo;MMMDCCCXLIV&amp;rsquo;), (3888, &amp;lsquo;MMMDCCCLXXXVIII&amp;rsquo;), (3940, &amp;lsquo;MMMCMXL&amp;rsquo;), (3999, &amp;lsquo;MMMCMXCIX&amp;rsquo;)) .
def test_to_roman_known_values(self): .
&amp;ldquo;&amp;lsquo;to_roman should give known result with known input&amp;rdquo;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;for integer, numeral in self.known_values:&lt;/p&gt;

&lt;p&gt;result = roman1.to_roman(integer) .
self.assertEqual(numeral, result) .
if &lt;strong&gt;name&lt;/strong&gt; == &amp;lsquo;&lt;strong&gt;main&lt;/strong&gt;&amp;lsquo;:&lt;/p&gt;

&lt;p&gt;unittest.main()&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To write a test case, first subclass the TestCase class of the unittest module. This class provides many useful methods which you can use in your test case to test specific conditions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is a list of integer/numeral pairs that I verified manually. It includes the lowest ten numbers, the highest number, every number that translates to a single-character Roman numeral, and a random sampling of other valid numbers. You don’t need to test every possible input, but you should try to test all the obvious edge cases.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Every individual test is its own method. A test method takes no parameters, returns no value, and must have a name beginning with the four letters test. If a test method exits normally without raising an exception, the test is considered passed; if the method raises an exception, the test is considered failed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Here you call the actual to_roman() function. (Well, the function hasn’t been written yet, but once it is, this is the line that will call it.) Notice that you have now defined the API for the to_roman() function: it must take an integer (the number to convert) and return a string (the Roman numeral representation). If the API is different than that, this test is considered failed. Also notice that you are not trapping any exceptions when you call to_roman(). This is intentional. to_roman() shouldn’t raise an exception when you call it with valid input, and these input values are all valid. If to_roman() raises an exception, this test is considered failed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Assuming the to_roman() function was defined correctly, called correctly, completed successfully, and returned a value, the last step is to check whether it returned the right value. This is a common question, and the TestCase class provides a method, assertEqual, to check whether two values are equal. If the result returned from to_roman() (result) does not match the known value you were expecting (numeral), assertEqual will raise an exception and the test will fail. If the two values are equal, assertEqual will do nothing. If every value returned from to_roman() matches the known value you expect, assertEqual never raises an exception, so test_to_roman_known_values eventually exits normally, which means to_roman() has passed this test.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Once you have a test case, you can start coding the to_roman() function. First, you should stub it out as an empty function and make sure the tests fail. If the tests succeed before you’ve written any code, your tests aren’t testing your code at all! Unit testing is a dance: tests lead, code follows. Write a test that fails, then code until it passes.&lt;/p&gt;

&lt;h1 id=&#34;roman1-py:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;roman1.py&lt;/h1&gt;

&lt;p&gt;def to_roman(n):
&amp;ldquo;&amp;lsquo;convert integer to Roman numeral&amp;rdquo;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;pass    .
1.  At this stage, you want to define the API of the to_roman() function, but you don’t want to code it yet. (Your test needs to fail first.) To stub it out, use the Python reserved word pass, which does precisely nothing.
Execute romantest1.py on the command line to run the test. If you call it with the -v command-line option, it will give more verbose output so you can see exactly what’s going on as each test case runs. With any luck, your output should look like this:
you@localhost:~/diveintopython3/examples$ python3 romantest1.py -v
test_to_roman_known_values (&lt;strong&gt;main&lt;/strong&gt;.KnownValues) .
to_roman should give known result with known input &amp;hellip; FAIL .&lt;/p&gt;

&lt;p&gt;======================================================================
FAIL: to_roman should give known result with known input&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest1.py&amp;rdquo;, line 73, in test_to_roman_known_values
self.assertEqual(numeral, result)
AssertionError: &amp;lsquo;I&amp;rsquo; != None .&lt;/p&gt;

&lt;p&gt;Ran 1 test in 0.016s    .
FAILED (failures=1)     .
1.  Running the script runs unittest.main(), which runs each test case. Each test case is a method within a class in romantest.py. There is no required organization of these test classes; they can each contain a single test method, or you can have one class that contains multiple test methods. The only requirement is that each test class must inherit from unittest.TestCase.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;For each test case, the unittest module will print out the docstring of the method and whether that test passed or failed. As expected, this test case fails.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For each failed test case, unittest displays the trace information showing exactly what happened. In this case, the call to assertEqual() raised an AssertionError because it was expecting to_roman(1) to return &amp;lsquo;I&amp;rsquo;, but it didn’t. (Since there was no explicit return statement, the function returned None, the Python null value.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After the detail of each test, unittest displays a summary of how many tests were performed and how long it took.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Overall, the test run failed because at least one test case did not pass. When a test case doesn’t pass, unittest distinguishes between failures and errors. A failure is a call to an assertXYZ method, like assertEqual or assertRaises, that fails because the asserted condition is not true or the expected exception was not raised. An error is any other sort of exception raised in the code you’re testing or the unit test case itself.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now, finally, you can write the to_roman() function.
roman_numeral_map = ((&amp;rsquo;M&amp;rsquo;, 1000),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;CM&amp;rsquo;, 900),&lt;/p&gt;

&lt;p&gt;(&amp;rsquo;D&amp;rsquo;, 500),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;CD&amp;rsquo;, 400),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;C&amp;rsquo;, 100),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;XC&amp;rsquo;, 90),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;L&amp;rsquo;, 50),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;XL&amp;rsquo;, 40),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;X&amp;rsquo;, 10),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;IX&amp;rsquo;, 9),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;V&amp;rsquo;, 5),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;IV&amp;rsquo;, 4),&lt;/p&gt;

&lt;p&gt;(&amp;lsquo;I&amp;rsquo;, 1))   .
def to_roman(n):&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;lsquo;convert integer to Roman numeral&amp;rdquo;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;result = &amp;ldquo;&lt;/p&gt;

&lt;p&gt;for numeral, integer in roman_numeral_map:&lt;/p&gt;

&lt;p&gt;while n &amp;gt;= integer:     .
result += numeral&lt;/p&gt;

&lt;p&gt;n -= integer&lt;/p&gt;

&lt;p&gt;return result&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;roman_numeral_map is a tuple of tuples which defines three things: the character representations of the most basic Roman numerals; the order of the Roman numerals (in descending value order, from M all the way down to I); the value of each Roman numeral. Each inner tuple is a pair of (numeral, value). It’s not just single-character Roman numerals; it also defines two-character pairs like CM (“one hundred less than one thousand”). This makes the to_roman() function code simpler.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Here’s where the rich data structure of roman_numeral_map pays off, because you don’t need any special logic to handle the subtraction rule. To convert to Roman numerals, simply iterate through roman_numeral_map looking for the largest integer value less than or equal to the input. Once found, add&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;the Roman numeral representation to the end of the output, subtract the corresponding integer value from the input, lather, rinse, repeat.
If you’re still not clear how the to_roman() function works, add a print() call to the end of the while loop:
while n &amp;gt;= integer:
result += numeral
n -= integer
print(&amp;lsquo;subtracting {0} from input, adding {1} to output&amp;rsquo;.format(integer, numeral))&lt;/p&gt;

&lt;p&gt;With the debug print() statements, the output looks like this:
&amp;gt;&amp;gt;&amp;gt; import roman1
&amp;gt;&amp;gt;&amp;gt; roman1.to_roman(1424)
subtracting 1000 from input, adding M to output
subtracting 400 from input, adding CD to output
subtracting 10 from input, adding X to output
subtracting 10 from input, adding X to output
subtracting 4 from input, adding IV to output
&amp;lsquo;MCDXXIV&amp;rsquo;&lt;/p&gt;

&lt;p&gt;So the to_roman() function appears to work, at least in this manual spot check. But will it pass the test case you wrote?
you@localhost:~/diveintopython3/examples$ python3 romantest1.py -v
test_to_roman_known_values (&lt;strong&gt;main&lt;/strong&gt;.KnownValues)
to_roman should give known result with known input &amp;hellip; ok .&lt;/p&gt;

&lt;p&gt;Ran 1 test in 0.016s&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hooray! The to_roman() function passes the “known values” test case. It’s not comprehensive, but it does put the function through its paces with a variety of inputs, including inputs that produce every single-character Roman numeral, the largest possible input (3999), and the input that produces the longest possible Roman numeral (3888). At this point, you can be reasonably confident that the function works for any good input value you could throw at it.
“Good” input? Hmm. What about bad input?
.
9.3. “HALT AND CATCH FIRE”
It is not enough to test that functions succeed when
given good input; you must also test that they fail when&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;given bad input. And not just any sort of failure; they must fail in the way you expect.
&amp;gt;&amp;gt;&amp;gt; import roman1
&amp;gt;&amp;gt;&amp;gt; roman1.to_roman(4000)
&amp;lsquo;MMMM&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; roman1.to_roman(5000)
&amp;lsquo;MMMMM&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; roman1.to_roman(9000) .
&amp;lsquo;MMMMMMMMM&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;That’s definitely not what you wanted — that’s not even a valid Roman numeral! In fact, each of these numbers is outside the range of acceptable input, but the function&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;returns a bogus value anyway. Silently returning bad values is baaaaaaad; if a program is going to fail, it is far better if it fails quickly and noisily. “Halt and catch fire,” as the saying goes. The Pythonic way to halt and catch fire is to raise an exception.
The question to ask yourself is, “How can I express this as a testable requirement?” How’s this for starters:
The to_roman() function should raise an
OutOfRangeError when given an integer greater
than 3999.&lt;/p&gt;

&lt;p&gt;What would that test look like?
class ToRomanBadInput(unittest.TestCase):&lt;/p&gt;

&lt;p&gt;def test_too_large(self): . &amp;ldquo;&amp;lsquo;to_roman should fail with large input&amp;rdquo;&amp;rsquo; self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000) .
1.  Like the previous test case, you create a class that inherits from unittest.TestCase. You can have more than one test per class (as you’ll see later in this chapter), but I chose to create a new class here because this test is something different than the last one. We’ll keep all the good input tests together in one class, and all the bad input tests together in another.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Like the previous test case, the test itself is a method of the class, with a name starting with test.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The unittest.TestCase class provides the assertRaises method, which takes the following arguments: the exception you’re expecting, the function you’re testing, and the arguments you’re passing to that function. (If the function you’re testing takes more than one argument, pass them all to assertRaises, in order, and it will pass them right along to the function you’re testing.)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pay close attention to this last line of code. Instead of calling to_roman() directly and manually checking that it raises a particular exception (by wrapping it in a
try&amp;hellip;except block), the assertRaises method has encapsulated all of that for us. All you do is tell it what exception you’re expecting (roman2.OutOfRangeError), the function (to_roman()), and the function’s arguments (4000). The assertRaises method takes care of calling to_roman() and checking that it raises roman2.OutOfRangeError.&lt;/p&gt;

&lt;p&gt;Also note that you’re passing the to_roman() function itself as an argument; you’re not calling it, and you’re not passing the name of it as a string. Have I mentioned recently how handy it is that everything
in
Python
is
an
object?
So what happens when you run the test suite with this new test?
you@localhost:~/diveintopython3/examples$ python3 romantest2.py -v
test_to_roman_known_values (&lt;strong&gt;main&lt;/strong&gt;.KnownValues)
to_roman should give known result with known input &amp;hellip; ok
test_too_large (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with large input &amp;hellip; ERROR .&lt;/p&gt;

&lt;p&gt;======================================================================
ERROR: to_roman should fail with large input&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest2.py&amp;rdquo;, line 78, in test_too_large
self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
AttributeError: &amp;lsquo;module&amp;rsquo; object has no attribute &amp;lsquo;OutOfRangeError&amp;rsquo; .&lt;/p&gt;

&lt;p&gt;Ran 2 tests in 0.000s&lt;/p&gt;

&lt;p&gt;FAILED (errors=1)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You should have expected this to fail (since you haven’t written any code to pass it yet), but&amp;hellip; it didn’t actually “fail,” it had an “error” instead. This is a subtle but important distinction. A unit test actually has three return values: pass, fail, and error. Pass, of course, means that the test passed — the code did what you expected. “Fail” is what the previous test case did (until you wrote code to make it pass) — it executed the code but the result was not what you expected. “Error” means that the code didn’t even execute properly.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why didn’t the code execute properly? The traceback tells all. The module you’re testing doesn’t have an exception called OutOfRangeError. Remember, you passed this exception to the assertRaises() method, because it’s the exception you want the function to raise given an out-of-range input. But the exception&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;doesn’t exist, so the call to the assertRaises() method failed. It never got a chance to test the
to_roman() function; it didn’t get that far.&lt;/p&gt;

&lt;p&gt;To solve this problem, you need to define the OutOfRangeError exception in roman2.py.
class OutOfRangeError(ValueError): .
pass .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Exceptions are classes. An “out of range” error is a kind of value error — the argument value is out of its acceptable range. So this exception inherits from the built-in ValueError exception. This is not strictly necessary (it could just inherit from the base Exception class), but it feels right.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exceptions don’t actually do anything, but you need at least one line of code to make a class. Calling pass does precisely nothing, but it’s a line of Python code, so that makes it a class.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now run the test suite again.
you@localhost:~/diveintopython3/examples$ python3 romantest2.py -v
test_to_roman_known_values (&lt;strong&gt;main&lt;/strong&gt;.KnownValues)
to_roman should give known result with known input &amp;hellip; ok
test_too_large (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with large input &amp;hellip; FAIL .&lt;/p&gt;

&lt;p&gt;======================================================================
FAIL: to_roman should fail with large input&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest2.py&amp;rdquo;, line 78, in test_too_large
self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
AssertionError: OutOfRangeError not raised by to_roman .&lt;/p&gt;

&lt;p&gt;Ran 2 tests in 0.016s&lt;/p&gt;

&lt;p&gt;FAILED (failures=1)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The new test is still not passing, but it’s not returning an error either. Instead, the test is failing. That’s progress! It means the call to the assertRaises() method succeeded this time, and the unit test framework actually tested the to_roman() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Of course, the to_roman() function isn’t raising the OutOfRangeError exception you just defined, because you haven’t told it to do that yet. That’s excellent news! It means this is a valid test case — it fails before you write the code to make it pass.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now you can write the code to make this test pass.
def to_roman(n):
&amp;ldquo;&amp;lsquo;convert integer to Roman numeral&amp;rdquo;&amp;rsquo;
if n &amp;gt; 3999:&lt;/p&gt;

&lt;p&gt;raise OutOfRangeError(&amp;lsquo;number out of range (must be less than 4000)&amp;rsquo;) .
result = &amp;ldquo;
for numeral, integer in roman_numeral_map:&lt;/p&gt;

&lt;p&gt;while n &amp;gt;= integer:
result += numeral
n -= integer&lt;/p&gt;

&lt;p&gt;return result&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;This is straightforward: if the given input (n) is greater than 3999, raise an OutOfRangeError exception. The unit test does not check the human-readable string that accompanies the exception, although you could write another test that did check it (but watch out for internationalization issues for strings that vary by the user’s language or environment).
Does this make the test pass? Let’s find out.
you@localhost:~/diveintopython3/examples$ python3 romantest2.py -v&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;test_to_roman_known_values (&lt;strong&gt;main&lt;/strong&gt;.KnownValues)
to_roman should give known result with known input &amp;hellip; ok
test_too_large (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with large input &amp;hellip; ok .&lt;/p&gt;

&lt;p&gt;Ran 2 tests in 0.000s&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hooray! Both tests pass. Because you worked iteratively, bouncing back and forth between testing and coding, you can be sure that the two lines of code you just wrote were the cause of that one test going from “fail” to “pass.” That kind of confidence doesn’t come cheap, but it will pay for itself over the lifetime of your code.
.
9.4. MORE HALTING, MORE FIRE
Along with testing numbers that are too large, you need to test numbers that are too small. As we
noted
in
our
functional
requirements, Roman numerals cannot express 0 or negative numbers.
&amp;gt;&amp;gt;&amp;gt; import roman2
&amp;gt;&amp;gt;&amp;gt; roman2.to_roman(0)
&amp;ldquo;
&amp;gt;&amp;gt;&amp;gt; roman2.to_roman(-1)
&amp;ldquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Well that’s not good. Let’s add tests for each of these conditions.
class ToRomanBadInput(unittest.TestCase):&lt;/p&gt;

&lt;p&gt;def test_too_large(self): &amp;ldquo;&amp;lsquo;to_roman should fail with large input&amp;rdquo;&amp;rsquo; self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 4000) .
def test_zero(self): &amp;ldquo;&amp;lsquo;to_roman should fail with 0 input&amp;rdquo;&amp;rsquo; self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 0) .
def test_negative(self): &amp;ldquo;&amp;lsquo;to_roman should fail with negative input&amp;rdquo;&amp;rsquo; self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, -1) .
1.  The test_too_large() method has not changed since the previous step. I’m including it here to show where the new code fits.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Here’s a new test: the test_zero() method. Like the test_too_large() method, it tells the assertRaises() method defined in unittest.TestCase to call our to_roman() function with a parameter of 0, and check that it raises the appropriate exception, OutOfRangeError.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The test_negative() method is almost identical, except it passes -1 to the to_roman() function. If either of these new tests does not raise an OutOfRangeError (either because the function returns an actual value, or because it raises some other exception), the test is considered failed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now check that the tests fail:
you@localhost:~/diveintopython3/examples$ python3 romantest3.py -v
test_to_roman_known_values (&lt;strong&gt;main&lt;/strong&gt;.KnownValues)
to_roman should give known result with known input &amp;hellip; ok
test_negative (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with negative input &amp;hellip; FAIL
test_too_large (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with large input &amp;hellip; ok
test_zero (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with 0 input &amp;hellip; FAIL&lt;/p&gt;

&lt;p&gt;======================================================================
FAIL: to_roman should fail with negative input&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest3.py&amp;rdquo;, line 86, in test_negative
self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, -1)
AssertionError: OutOfRangeError not raised by to_roman&lt;/p&gt;

&lt;p&gt;======================================================================
FAIL: to_roman should fail with 0 input&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest3.py&amp;rdquo;, line 82, in test_zero
self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 0)
AssertionError: OutOfRangeError not raised by to_roman&lt;/p&gt;

&lt;p&gt;Ran 4 tests in 0.000s&lt;/p&gt;

&lt;p&gt;FAILED (failures=2)&lt;/p&gt;

&lt;p&gt;Excellent. Both tests failed, as expected. Now let’s switch over to the code and see what we can do to make them pass.
def to_roman(n):&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;lsquo;convert integer to Roman numeral&amp;rdquo;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;if not (0 &amp;lt; n &amp;lt; 4000): . raise OutOfRangeError(&amp;lsquo;number out of range (must be 1..3999)&amp;rsquo;) .
result = &amp;ldquo;
for numeral, integer in roman_numeral_map:&lt;/p&gt;

&lt;p&gt;while n &amp;gt;= integer:
result += numeral
n -= integer&lt;/p&gt;

&lt;p&gt;return result&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This is a nice Pythonic shortcut: multiple comparisons at once. This is equivalent to if not ((0 &amp;lt; n) and (n &amp;lt; 4000)), but it’s much easier to read. This one line of code should catch inputs that are too large, negative, or zero.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you change your conditions, make sure to update your human-readable error strings to match. The unittest framework won’t care, but it’ll make it difficult to do manual debugging if your code is throwing incorrectly-described exceptions.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I could show you a whole series of unrelated examples to show that the multiple-comparisons-at-once shortcut works, but instead I’ll just run the unit tests and prove it.
you@localhost:~/diveintopython3/examples$ python3 romantest3.py -v
test_to_roman_known_values (&lt;strong&gt;main&lt;/strong&gt;.KnownValues)
to_roman should give known result with known input &amp;hellip; ok
test_negative (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with negative input &amp;hellip; ok
test_too_large (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with large input &amp;hellip; ok
test_zero (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with 0 input &amp;hellip; ok&lt;/p&gt;

&lt;p&gt;Ran 4 tests in 0.016s&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;.
9.5. AND ONE MORE THING…
There was one more functional
requirement
for converting numbers to Roman numerals: dealing with non-integers.
&amp;gt;&amp;gt;&amp;gt; import roman3
&amp;gt;&amp;gt;&amp;gt; roman3.to_roman(0.5) .
&amp;ldquo;
&amp;gt;&amp;gt;&amp;gt; roman3.to_roman(1.0) .
&amp;lsquo;I&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Oh, that’s bad.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Oh, that’s even worse. Both of these cases should raise an exception. Instead, they give bogus results.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Testing for non-integers is not difficult. First, define a NotIntegerError exception.&lt;/p&gt;

&lt;h1 id=&#34;roman4-py:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;roman4.py&lt;/h1&gt;

&lt;p&gt;class OutOfRangeError(ValueError): pass
class NotIntegerError(ValueError): pass&lt;/p&gt;

&lt;p&gt;Next, write a test case that checks for the NotIntegerError exception.
class ToRomanBadInput(unittest.TestCase):
.
.
.
def test_non_integer(self):&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;lsquo;to_roman should fail with non-integer input&amp;rdquo;&amp;rsquo;
self.assertRaises(roman4.NotIntegerError, roman4.to_roman, 0.5)&lt;/p&gt;

&lt;p&gt;Now check that the test fails properly.
you@localhost:~/diveintopython3/examples$ python3 romantest4.py -v&lt;/p&gt;

&lt;p&gt;test_to_roman_known_values (&lt;strong&gt;main&lt;/strong&gt;.KnownValues)
to_roman should give known result with known input &amp;hellip; ok
test_negative (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with negative input &amp;hellip; ok
test_non_integer (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with non-integer input &amp;hellip; FAIL
test_too_large (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with large input &amp;hellip; ok
test_zero (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with 0 input &amp;hellip; ok&lt;/p&gt;

&lt;p&gt;======================================================================
FAIL: to_roman should fail with non-integer input&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest4.py&amp;rdquo;, line 90, in test_non_integer
self.assertRaises(roman4.NotIntegerError, roman4.to_roman, 0.5)
AssertionError: NotIntegerError not raised by to_roman&lt;/p&gt;

&lt;p&gt;Ran 5 tests in 0.000s&lt;/p&gt;

&lt;p&gt;FAILED (failures=1)&lt;/p&gt;

&lt;p&gt;Write the code that makes the test pass.
def to_roman(n):
&amp;ldquo;&amp;lsquo;convert integer to Roman numeral&amp;rdquo;&amp;rsquo;
if not (0 &amp;lt; n &amp;lt; 4000):&lt;/p&gt;

&lt;p&gt;raise OutOfRangeError(&amp;lsquo;number out of range (must be 1..3999)&amp;rsquo;) if not isinstance(n, int): . raise NotIntegerError(&amp;lsquo;non-integers can not be converted&amp;rsquo;) .
result = &amp;ldquo;
for numeral, integer in roman_numeral_map:&lt;/p&gt;

&lt;p&gt;while n &amp;gt;= integer:
result += numeral
n -= integer&lt;/p&gt;

&lt;p&gt;return result&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The built-in isinstance() function tests whether a variable is a particular type (or, technically, any descendant type).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the argument n is not an int, raise our newly minted NotIntegerError exception.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Finally, check that the code does indeed make the test pass.
you@localhost:~/diveintopython3/examples$ python3 romantest4.py -v&lt;/p&gt;

&lt;p&gt;test_to_roman_known_values (&lt;strong&gt;main&lt;/strong&gt;.KnownValues)
to_roman should give known result with known input &amp;hellip; ok
test_negative (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with negative input &amp;hellip; ok
test_non_integer (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with non-integer input &amp;hellip; ok
test_too_large (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with large input &amp;hellip; ok
test_zero (&lt;strong&gt;main&lt;/strong&gt;.ToRomanBadInput)
to_roman should fail with 0 input &amp;hellip; ok&lt;/p&gt;

&lt;p&gt;Ran 5 tests in 0.000s&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;The to_roman() function passes all of its tests, and I can’t think of any more tests, so it’s time to move on to from_roman().
.&lt;/p&gt;

&lt;p&gt;9.6. A PLEASING SYMMETRY
Converting a string from a Roman numeral to an integer sounds more difficult than converting an integer to a Roman numeral. Certainly there is the issue of validation. It’s easy to check if an integer is greater than 0, but a bit harder to check whether a string is a valid Roman numeral. But we already constructed a
regular
expression
to
check
for
Roman
numerals, so that part is done.
That leaves the problem of converting the string itself. As we’ll see in a minute, thanks to the rich data structure we defined to map individual Roman numerals to integer values, the nitty-gritty of the from_roman() function is as straightforward as the to_roman() function.
But first, the tests. We’ll need a “known values” test to spot-check for accuracy. Our test suite already contains a
mapping
of
known
values; let’s reuse that.
def test_from_roman_known_values(self):
&amp;ldquo;&amp;lsquo;from_roman should give known result with known input&amp;rdquo;&amp;rsquo;
for integer, numeral in self.known_values:&lt;/p&gt;

&lt;p&gt;result = roman5.from_roman(numeral)
self.assertEqual(integer, result)&lt;/p&gt;

&lt;p&gt;There’s a pleasing symmetry here. The to_roman() and from_roman() functions are inverses of each other. The first converts integers to specially-formatted strings, the second converts specially-formated strings to integers. In theory, we should be able to “round-trip” a number by passing to the to_roman() function to get a string, then passing that string to the from_roman() function to get an integer, and end up with the same number.
n = from_roman(to_roman(n)) for all values of n&lt;/p&gt;

&lt;p&gt;In this case, “all values” means any number between 1..3999, since that is the valid range of inputs to the to_roman() function. We can express this symmetry in a test case that runs through all the values 1..3999, calls to_roman(), calls from_roman(), and checks that the output is the same as the original input.
class RoundtripCheck(unittest.TestCase):&lt;/p&gt;

&lt;p&gt;def test_roundtrip(self):
&amp;ldquo;&amp;lsquo;from_roman(to_roman(n))==n for all n&amp;rdquo;&amp;rsquo;
for integer in range(1, 4000):&lt;/p&gt;

&lt;p&gt;numeral = roman5.to_roman(integer)
result = roman5.from_roman(numeral)
self.assertEqual(integer, result)&lt;/p&gt;

&lt;p&gt;These new tests won’t even fail yet. We haven’t defined a from_roman() function at all, so they’ll just raise errors.
you@localhost:~/diveintopython3/examples$ python3 romantest5.py&lt;/p&gt;

&lt;h1 id=&#34;e-e:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;E.E&amp;hellip;.&lt;/h1&gt;

&lt;p&gt;ERROR: test_from_roman_known_values (&lt;strong&gt;main&lt;/strong&gt;.KnownValues)
from_roman should give known result with known input&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest5.py&amp;rdquo;, line 78, in test_from_roman_known_values
result = roman5.from_roman(numeral)
AttributeError: &amp;lsquo;module&amp;rsquo; object has no attribute &amp;lsquo;from_roman&amp;rsquo;&lt;/p&gt;

&lt;p&gt;======================================================================
ERROR: test_roundtrip (&lt;strong&gt;main&lt;/strong&gt;.RoundtripCheck)
from_roman(to_roman(n))==n for all n&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest5.py&amp;rdquo;, line 103, in test_roundtrip
result = roman5.from_roman(numeral)
AttributeError: &amp;lsquo;module&amp;rsquo; object has no attribute &amp;lsquo;from_roman&amp;rsquo;&lt;/p&gt;

&lt;p&gt;Ran 7 tests in 0.019s&lt;/p&gt;

&lt;p&gt;FAILED (errors=2)&lt;/p&gt;

&lt;p&gt;A quick stub function will solve that problem.&lt;/p&gt;

&lt;h1 id=&#34;roman5-py:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;roman5.py&lt;/h1&gt;

&lt;p&gt;def from_roman(s):
&amp;ldquo;&amp;lsquo;convert Roman numeral to integer&amp;rdquo;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;(Hey, did you notice that? I defined a function with nothing but a docstring. That’s legal Python. In fact, some programmers swear by it. “Don’t stub; document!”)
Now the test cases will actually fail.
you@localhost:~/diveintopython3/examples$ python3 romantest5.py&lt;/p&gt;

&lt;h1 id=&#34;f-f:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;F.F&amp;hellip;.&lt;/h1&gt;

&lt;p&gt;FAIL: test_from_roman_known_values (&lt;strong&gt;main&lt;/strong&gt;.KnownValues)
from_roman should give known result with known input&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest5.py&amp;rdquo;, line 79, in test_from_roman_known_values
self.assertEqual(integer, result)
AssertionError: 1 != None&lt;/p&gt;

&lt;p&gt;======================================================================
FAIL: test_roundtrip (&lt;strong&gt;main&lt;/strong&gt;.RoundtripCheck)
from_roman(to_roman(n))==n for all n&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest5.py&amp;rdquo;, line 104, in test_roundtrip
self.assertEqual(integer, result)
AssertionError: 1 != None&lt;/p&gt;

&lt;p&gt;Ran 7 tests in 0.002s&lt;/p&gt;

&lt;p&gt;FAILED (failures=2)&lt;/p&gt;

&lt;p&gt;Now it’s time to write the from_roman() function.
def from_roman(s):
&amp;ldquo;&amp;rdquo;&amp;ldquo;convert Roman numeral to integer&amp;rdquo;&amp;ldquo;&amp;rdquo;
result = 0
index = 0
for numeral, integer in roman_numeral_map:&lt;/p&gt;

&lt;p&gt;while s[index:index+len(numeral)] == numeral: . result += integer index += len(numeral)
return result&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The pattern here is the same as the to_roman() function. You iterate through your Roman numeral data structure (a tuple of tuples), but instead of matching the highest integer values as often as possible, you match the “highest” Roman numeral character strings as often as possible.
If you&amp;rsquo;re not clear how from_roman() works, add a print statement to the end of the while loop:
def from_roman(s):
&amp;ldquo;&amp;rdquo;&amp;ldquo;convert Roman numeral to integer&amp;rdquo;&amp;ldquo;&amp;rdquo;
result = 0
index = 0
for numeral, integer in roman_numeral_map:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;while s[index:index+len(numeral)] == numeral:
result += integer
index += len(numeral)
print(&amp;lsquo;found&amp;rsquo;, numeral, &amp;lsquo;of length&amp;rsquo;, len(numeral), &amp;lsquo;, adding&amp;rsquo;, integer)&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import roman5&lt;/p&gt;

&lt;p&gt;roman5.from_roman(&amp;lsquo;MCMLXXII&amp;rsquo;)
found M of length 1, adding 1000
found CM of length 2, adding 900
found L of length 1, adding 50
found X of length 1, adding 10
found X of length 1, adding 10
found I of length 1, adding 1
found I of length 1, adding 1
1972&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Time to re-run the tests.
you@localhost:~/diveintopython3/examples$ python3 romantest5.py
&amp;hellip;&amp;hellip;.&lt;/p&gt;

&lt;p&gt;Ran 7 tests in 0.060s&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;Two pieces of exciting news here. The first is that the from_roman() function works for good input, at least for all the known
values. The second is that the “round trip” test also passed. Combined with the known values tests, you can be reasonably sure that both the to_roman() and from_roman() functions work properly for all possible good values. (This is not guaranteed; it is theoretically possible that to_roman() has a bug that produces the wrong Roman numeral for some particular set of inputs, and that from_roman() has a reciprocal bug that produces the same wrong integer values for exactly that set of Roman numerals that to_roman() generated incorrectly. Depending on your application and your requirements, this possibility may bother you; if so, write more comprehensive test cases until it doesn&amp;rsquo;t bother you.)
.&lt;/p&gt;

&lt;p&gt;9.7. MORE BAD INPUT
Now that the from_roman() function works properly with good input, it&amp;rsquo;s time to fit in the last piece of the puzzle: making it work properly with bad input. That means finding a way to look at a string and determine if it&amp;rsquo;s a valid Roman numeral. This is inherently more difficult than validating
numeric
input
in the to_roman() function, but you have a powerful tool at your disposal: regular expressions. (If you’re not familiar with regular expressions, now would be a good time to read the
regular
expressions
chapter.)
As you saw in Case
Study:
Roman
Numerals, there are several simple rules for constructing a Roman
numeral, using the letters M, D, C, L, X, V, and I. Let&amp;rsquo;s review the rules:&lt;/p&gt;

&lt;p&gt;•   Sometimes characters are additive. I is 1, II is 2, and III is 3. VI is 6 (literally, “5 and 1”), VII is 7, and VIII is 8.&lt;/p&gt;

&lt;p&gt;•   The tens characters (I, X, C, and M) can be repeated up to three times. At 4, you need to subtract from the next highest fives character. You can&amp;rsquo;t represent 4 as IIII; instead, it is represented as IV (“1 less than 5”). 40 is written as XL (“10 less than 50”), 41 as XLI, 42 as XLII, 43 as XLIII, and then 44 as XLIV (“10 less than 50, then 1 less than 5”).&lt;/p&gt;

&lt;p&gt;•   Sometimes characters are… the opposite of additive. By putting certain characters before others, you subtract from the final value. For example, at 9, you need to subtract from the next highest tens character: 8 is VIII, but 9 is IX (“1 less than 10”), not VIIII (since the I character can not be repeated four times). 90 is XC, 900 is CM.&lt;/p&gt;

&lt;p&gt;•   The fives characters can not be repeated. 10 is always represented as X, never as VV. 100 is always C, never LL.&lt;/p&gt;

&lt;p&gt;•   Roman numerals are read left to right, so the order of characters matters very much. DC is 600; CD is a completely different number (400,“100 less than 500”). CI is 101; IC is not even a valid Roman numeral (because you can&amp;rsquo;t subtract 1 directly from 100; you would need to write it as XCIX,“10 less than 100, then 1 less than 10”).&lt;/p&gt;

&lt;p&gt;Thus, one useful test would be to ensure that the from_roman() function should fail when you pass it a
string with too many repeated numerals. How many is “too many” depends on the numeral.&lt;/p&gt;

&lt;p&gt;class FromRomanBadInput(unittest.TestCase):&lt;/p&gt;

&lt;p&gt;def test_too_many_repeated_numerals(self):
&amp;ldquo;&amp;lsquo;from_roman should fail with too many repeated numerals&amp;rdquo;&amp;rsquo;
for s in (&amp;lsquo;MMMM&amp;rsquo;, &amp;lsquo;DD&amp;rsquo;, &amp;lsquo;CCCC&amp;rsquo;, &amp;rsquo;LL&amp;rsquo;, &amp;lsquo;XXXX&amp;rsquo;, &amp;lsquo;VV&amp;rsquo;, &amp;lsquo;IIII&amp;rsquo;):&lt;/p&gt;

&lt;p&gt;self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)&lt;/p&gt;

&lt;p&gt;Another useful test would be to check that certain patterns aren’t repeated. For example, IX is 9, but IXIX is never valid.
def test_repeated_pairs(self):
&amp;ldquo;&amp;lsquo;from_roman should fail with repeated pairs of numerals&amp;rdquo;&amp;rsquo;
for s in (&amp;lsquo;CMCM&amp;rsquo;, &amp;lsquo;CDCD&amp;rsquo;, &amp;lsquo;XCXC&amp;rsquo;, &amp;lsquo;XLXL&amp;rsquo;, &amp;lsquo;IXIX&amp;rsquo;, &amp;lsquo;IVIV&amp;rsquo;):&lt;/p&gt;

&lt;p&gt;self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)&lt;/p&gt;

&lt;p&gt;A third test could check that numerals appear in the correct order, from highest to lowest value. For example, CL is 150, but LC is never valid, because the numeral for 50 can never come before the numeral for 100. This test includes a randomly chosen set of invalid antecedents: I before M, V before X, and so on.
def test_malformed_antecedents(self):
&amp;ldquo;&amp;lsquo;from_roman should fail with malformed antecedents&amp;rdquo;&amp;rsquo;
for s in (&amp;lsquo;IIMXCC&amp;rsquo;, &amp;lsquo;VX&amp;rsquo;, &amp;lsquo;DCM&amp;rsquo;, &amp;lsquo;CMM&amp;rsquo;, &amp;lsquo;IXIV&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;MCMC&amp;rsquo;, &amp;lsquo;XCX&amp;rsquo;, &amp;lsquo;IVI&amp;rsquo;, &amp;lsquo;LM&amp;rsquo;, &amp;lsquo;LD&amp;rsquo;, &amp;lsquo;LC&amp;rsquo;):
self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)&lt;/p&gt;

&lt;p&gt;Each of these tests relies the from_roman() function raising a new exception, InvalidRomanNumeralError, which we haven’t defined yet.&lt;/p&gt;

&lt;h1 id=&#34;roman6-py:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;roman6.py&lt;/h1&gt;

&lt;p&gt;class InvalidRomanNumeralError(ValueError): pass&lt;/p&gt;

&lt;p&gt;All three of these tests should fail, since the from_roman() function doesn’t currently have any validity checking. (If they don’t fail now, then what the heck are they testing?)
you@localhost:~/diveintopython3/examples$ python3 romantest6.py&lt;/p&gt;

&lt;h1 id=&#34;fff:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;FFF&amp;hellip;&amp;hellip;.&lt;/h1&gt;

&lt;p&gt;FAIL: test_malformed_antecedents (&lt;strong&gt;main&lt;/strong&gt;.FromRomanBadInput)
from_roman should fail with malformed antecedents&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest6.py&amp;rdquo;, line 113, in test_malformed_antecedents
self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)
AssertionError: InvalidRomanNumeralError not raised by from_roman&lt;/p&gt;

&lt;p&gt;======================================================================
FAIL: test_repeated_pairs (&lt;strong&gt;main&lt;/strong&gt;.FromRomanBadInput)
from_roman should fail with repeated pairs of numerals&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest6.py&amp;rdquo;, line 107, in test_repeated_pairs
self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)
AssertionError: InvalidRomanNumeralError not raised by from_roman&lt;/p&gt;

&lt;p&gt;======================================================================
FAIL: test_too_many_repeated_numerals (&lt;strong&gt;main&lt;/strong&gt;.FromRomanBadInput)
from_roman should fail with too many repeated numerals&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest6.py&amp;rdquo;, line 102, in test_too_many_repeated_numerals
self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)
AssertionError: InvalidRomanNumeralError not raised by from_roman&lt;/p&gt;

&lt;p&gt;Ran 10 tests in 0.058s&lt;/p&gt;

&lt;p&gt;FAILED (failures=3)&lt;/p&gt;

&lt;p&gt;Good deal. Now, all we need to do is add the regular
expression
to
test
for
valid
Roman
numerals
into the from_roman() function.
roman_numeral_pattern = re.compile(&amp;ldquo;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;^  # beginning of string&lt;br /&gt;
M{0,3}  # thousands - 0 to 3 Ms&lt;br /&gt;
(CM|CD|D?C{0,3})  # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),&lt;/p&gt;

&lt;h1 id=&#34;or-500-800-d-followed-by-0-to-3-cs-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;or 500-800 (D, followed by 0 to 3 Cs)&lt;/h1&gt;

&lt;p&gt;(XC|XL|L?X{0,3})  # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),&lt;/p&gt;

&lt;h1 id=&#34;or-50-80-l-followed-by-0-to-3-xs-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;or 50-80 (L, followed by 0 to 3 Xs)&lt;/h1&gt;

&lt;p&gt;(IX|IV|V?I{0,3})  # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),&lt;/p&gt;

&lt;h1 id=&#34;or-5-8-v-followed-by-0-to-3-is-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;or 5-8 (V, followed by 0 to 3 Is)&lt;/h1&gt;

&lt;p&gt;$  # end of string&lt;br /&gt;
&amp;rdquo;&amp;lsquo;, re.VERBOSE)&lt;/p&gt;

&lt;p&gt;def from_roman(s):
&amp;ldquo;&amp;lsquo;convert Roman numeral to integer&amp;rdquo;&amp;rsquo;
if not roman_numeral_pattern.search(s):&lt;/p&gt;

&lt;p&gt;raise InvalidRomanNumeralError(&amp;lsquo;Invalid Roman numeral: {0}&amp;lsquo;.format(s))&lt;/p&gt;

&lt;p&gt;result = 0
index = 0
for numeral, integer in roman_numeral_map:&lt;/p&gt;

&lt;p&gt;while s[index : index + len(numeral)] == numeral:
result += integer
index += len(numeral)&lt;/p&gt;

&lt;p&gt;return result&lt;/p&gt;

&lt;p&gt;And re-run the tests…
you@localhost:~/diveintopython3/examples$ python3 romantest7.py&lt;/p&gt;

&lt;p&gt;&amp;hellip;&amp;hellip;&amp;hellip;.&lt;/p&gt;

&lt;p&gt;Ran 10 tests in 0.066s&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;And the anticlimax award of the year goes to… the word “OK”, which is printed by the unittest module when all the tests pass.
CHAPTER 10. REFACTORING&lt;/p&gt;

&lt;p&gt;. After one has played a vast quantity of notes and more notes, it is simplicity that emerges as the crowning reward of art. .
— Frédéric Chopin
10.1. DIVING IN
Like it or not, bugs happen. Despite your best efforts to write comprehensive unit
tests, bugs happen. What do I mean by “bug”? A bug is a test case you haven’t written yet.
&amp;gt;&amp;gt;&amp;gt; import roman7
&amp;gt;&amp;gt;&amp;gt; roman7.from_roman(&amp;ldquo;) .
0&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;This is a bug. An empty string should raise an InvalidRomanNumeralError exception, just like any other sequence of characters that don’t represent a valid Roman numeral.
After reproducing the bug, and before fixing it, you should write a test case that fails, thus illustrating the bug.
class FromRomanBadInput(unittest.TestCase):
.
.
.
def testBlank(self):&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&amp;rdquo;&amp;lsquo;from_roman should fail with blank string&amp;rdquo;&amp;rsquo; self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, &amp;ldquo;) .
1.  Pretty simple stuff here. Call from_roman() with an empty string and make sure it raises an InvalidRomanNumeralError exception. The hard part was finding the bug; now that you know about it, testing for it is the easy part.
Since your code has a bug, and you now have a test case that tests this bug, the test case will fail:
you@localhost:~/diveintopython3/examples$ python3 romantest8.py -v
from_roman should fail with blank string &amp;hellip; FAIL
from_roman should fail with malformed antecedents &amp;hellip; ok
from_roman should fail with repeated pairs of numerals &amp;hellip; ok
from_roman should fail with too many repeated numerals &amp;hellip; ok
from_roman should give known result with known input &amp;hellip; ok
to_roman should give known result with known input &amp;hellip; ok
from_roman(to_roman(n))==n for all n &amp;hellip; ok
to_roman should fail with negative input &amp;hellip; ok
to_roman should fail with non-integer input &amp;hellip; ok
to_roman should fail with large input &amp;hellip; ok
to_roman should fail with 0 input &amp;hellip; ok&lt;/p&gt;

&lt;p&gt;======================================================================
FAIL: from_roman should fail with blank string&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest8.py&amp;rdquo;, line 117, in test_blank
self.assertRaises(roman8.InvalidRomanNumeralError, roman8.from_roman, &amp;ldquo;)
AssertionError: InvalidRomanNumeralError not raised by from_roman&lt;/p&gt;

&lt;p&gt;Ran 11 tests in 0.171s&lt;/p&gt;

&lt;p&gt;FAILED (failures=1)&lt;/p&gt;

&lt;p&gt;Now you can fix the bug.
def from_roman(s):&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;lsquo;convert Roman numeral to integer&amp;rdquo;&amp;rsquo; if not s: . raise InvalidRomanNumeralError(&amp;lsquo;Input can not be blank&amp;rsquo;) if not re.search(romanNumeralPattern, s): raise InvalidRomanNumeralError(&amp;lsquo;Invalid Roman numeral: {}&amp;lsquo;.format(s)) .
result = 0
index = 0
for numeral, integer in romanNumeralMap:&lt;/p&gt;

&lt;p&gt;while s[index:index+len(numeral)] == numeral:
result += integer
index += len(numeral)&lt;/p&gt;

&lt;p&gt;return result&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Only two lines of code are required: an explicit check for an empty string, and a raise statement.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I don’t think I’ve mentioned this yet anywhere in this book, so let this serve as your final lesson in string
formatting. Starting in Python 3.1, you can skip the numbers when using positional indexes in a format specifier. That is, instead of using the format specifier {0} to refer to the first parameter to the format() method, you can simply use {} and Python will fill in the proper positional index for you. This works for any number of arguments; the first {} is {0}, the second {} is {1}, and so forth.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;you@localhost:~/diveintopython3/examples$ python3 romantest8.py -v
from_roman should fail with blank string &amp;hellip; ok .
from_roman should fail with malformed antecedents &amp;hellip; ok
from_roman should fail with repeated pairs of numerals &amp;hellip; ok
from_roman should fail with too many repeated numerals &amp;hellip; ok
from_roman should give known result with known input &amp;hellip; ok
to_roman should give known result with known input &amp;hellip; ok
from_roman(to_roman(n))==n for all n &amp;hellip; ok
to_roman should fail with negative input &amp;hellip; ok
to_roman should fail with non-integer input &amp;hellip; ok
to_roman should fail with large input &amp;hellip; ok
to_roman should fail with 0 input &amp;hellip; ok&lt;/p&gt;

&lt;p&gt;Ran 11 tests in 0.156s&lt;/p&gt;

&lt;p&gt;OK .
1. The blank string test case now passes, so the bug is fixed.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;All the other test cases still pass, which means that this bug fix didn’t break anything else. Stop coding.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Coding this way does not make fixing bugs any easier. Simple bugs (like this one) require simple test cases; complex bugs will require complex test cases. In a testing-centric environment, it may seem like it takes longer to fix a bug, since you need to articulate in code exactly what the bug is (to write the test case), then fix the bug itself. Then if the test case doesn’t pass right away, you need to figure out whether the fix was wrong, or whether the test case itself has a bug in it. However, in the long run, this back-and-forth between test code and code tested pays for itself, because it makes it more likely that bugs are fixed correctly the first time. Also, since you can easily re-run all the test cases along with your new one, you are much less likely to break old code when fixing new code. Today’s unit test is tomorrow’s regression test.
.&lt;/p&gt;

&lt;p&gt;10.2. HANDLING CHANGING REQUIREMENTS
Despite your best efforts to pin your customers to the ground and extract exact requirements from them on pain of horrible nasty things involving scissors and hot wax, requirements will change. Most customers don’t know what they want until they see it, and even if they do, they aren’t that good at articulating what they want precisely enough to be useful. And even if they do, they’ll want more in the next release anyway. So be prepared to update your test cases as requirements change.
Suppose, for instance, that you wanted to expand the range of the Roman numeral conversion functions. Normally, no character in a Roman numeral can be repeated more than three times in a row. But the Romans were willing to make an exception to that rule by having 4 M characters in a row to represent 4000. If you make this change, you’ll be able to expand the range of convertible numbers from 1..3999 to 1..4999. But first, you need to make some changes to your test cases.
class KnownValues(unittest.TestCase):&lt;/p&gt;

&lt;p&gt;known_values = ( (1, &amp;lsquo;I&amp;rsquo;),
.
.
.&lt;/p&gt;

&lt;p&gt;(3999, &amp;lsquo;MMMCMXCIX&amp;rsquo;),
(4000, &amp;lsquo;MMMM&amp;rsquo;), .
(4500, &amp;lsquo;MMMMD&amp;rsquo;),
(4888, &amp;lsquo;MMMMDCCCLXXXVIII&amp;rsquo;),
(4999, &amp;lsquo;MMMMCMXCIX&amp;rsquo;) )&lt;/p&gt;

&lt;p&gt;class ToRomanBadInput(unittest.TestCase):&lt;/p&gt;

&lt;p&gt;def test_too_large(self):
&amp;ldquo;&amp;lsquo;to_roman should fail with large input&amp;rdquo;&amp;rsquo;
self.assertRaises(roman8.OutOfRangeError, roman8.to_roman, 5000) .&lt;/p&gt;

&lt;p&gt;.
.
.&lt;/p&gt;

&lt;p&gt;class FromRomanBadInput(unittest.TestCase):&lt;/p&gt;

&lt;p&gt;def test_too_many_repeated_numerals(self):
&amp;ldquo;&amp;lsquo;from_roman should fail with too many repeated numerals&amp;rdquo;&amp;rsquo;
for s in (&amp;lsquo;MMMMM&amp;rsquo;, &amp;lsquo;DD&amp;rsquo;, &amp;lsquo;CCCC&amp;rsquo;, &amp;rsquo;LL&amp;rsquo;, &amp;lsquo;XXXX&amp;rsquo;, &amp;lsquo;VV&amp;rsquo;, &amp;lsquo;IIII&amp;rsquo;): .&lt;/p&gt;

&lt;p&gt;self.assertRaises(roman8.InvalidRomanNumeralError, roman8.from_roman, s)&lt;/p&gt;

&lt;p&gt;.
.
.&lt;/p&gt;

&lt;p&gt;class RoundtripCheck(unittest.TestCase):&lt;/p&gt;

&lt;p&gt;def test_roundtrip(self):
&amp;ldquo;&amp;lsquo;from_roman(to_roman(n))==n for all n&amp;rdquo;&amp;rsquo;
for integer in range(1, 5000): .&lt;/p&gt;

&lt;p&gt;numeral = roman8.to_roman(integer)
result = roman8.from_roman(numeral)
self.assertEqual(integer, result)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The existing known values don’t change (they’re all still reasonable values to test), but you need to add a few more in the 4000 range. Here I’ve included 4000 (the shortest), 4500 (the second shortest), 4888 (the longest), and 4999 (the largest).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The definition of “large input” has changed. This test used to call to_roman() with 4000 and expect an error; now that 4000-4999 are good values, you need to bump this up to 5000.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The definition of “too many repeated numerals” has also changed. This test used to call from_roman() with &amp;lsquo;MMMM&amp;rsquo; and expect an error; now that MMMM is considered a valid Roman numeral, you need to bump this up to &amp;lsquo;MMMMM&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The sanity check loops through every number in the range, from 1 to 3999. Since the range has now expanded, this for loop need to be updated as well to go up to 4999.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now your test cases are up to date with the new requirements, but your code is not, so you expect several of the test cases to fail.
you@localhost:~/diveintopython3/examples$ python3 romantest9.py -v&lt;/p&gt;

&lt;p&gt;from_roman should fail with blank string &amp;hellip; ok&lt;br /&gt;
from_roman should fail with malformed antecedents &amp;hellip; ok&lt;br /&gt;
from_roman should fail with non-string input &amp;hellip; ok&lt;br /&gt;
from_roman should fail with repeated pairs of numerals &amp;hellip; ok&lt;br /&gt;
from_roman should fail with too many repeated numerals &amp;hellip; ok&lt;br /&gt;
from_roman should give known result with known input &amp;hellip; ERROR  .&lt;br /&gt;
to_roman should give known result with known input &amp;hellip; ERROR  .&lt;br /&gt;
from_roman(to_roman(n))==n for all n &amp;hellip; ERROR  .&lt;br /&gt;
to_roman should fail with negative input &amp;hellip; ok&lt;br /&gt;
to_roman should fail with non-integer input &amp;hellip; ok&lt;br /&gt;
to_roman should fail with large input &amp;hellip; ok&lt;br /&gt;
to_roman should fail with 0 input &amp;hellip; ok&lt;/p&gt;

&lt;p&gt;======================================================================
ERROR: from_roman should give known result with known input&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest9.py&amp;rdquo;, line 82, in test_from_roman_known_values
result = roman9.from_roman(numeral)
File &amp;ldquo;C:\home\diveintopython3\examples\roman9.py&amp;rdquo;, line 60, in from_roman
raise InvalidRomanNumeralError(&amp;lsquo;Invalid Roman numeral: {0}&amp;lsquo;.format(s))
roman9.InvalidRomanNumeralError: Invalid Roman numeral: MMMM&lt;/p&gt;

&lt;p&gt;======================================================================
ERROR: to_roman should give known result with known input&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest9.py&amp;rdquo;, line 76, in test_to_roman_known_values
result = roman9.to_roman(integer)
File &amp;ldquo;C:\home\diveintopython3\examples\roman9.py&amp;rdquo;, line 42, in to_roman
raise OutOfRangeError(&amp;lsquo;number out of range (must be 0..3999)&amp;rsquo;)
roman9.OutOfRangeError: number out of range (must be 0..3999)&lt;/p&gt;

&lt;p&gt;======================================================================
ERROR: from_roman(to_roman(n))==n for all n&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;romantest9.py&amp;rdquo;, line 131, in testSanity
numeral = roman9.to_roman(integer)
File &amp;ldquo;C:\home\diveintopython3\examples\roman9.py&amp;rdquo;, line 42, in to_roman
raise OutOfRangeError(&amp;lsquo;number out of range (must be 0..3999)&amp;rsquo;)
roman9.OutOfRangeError: number out of range (must be 0..3999)&lt;/p&gt;

&lt;p&gt;Ran 12 tests in 0.171s&lt;/p&gt;

&lt;p&gt;FAILED (errors=3)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The from_roman() known values test will fail as soon as it hits &amp;lsquo;MMMM&amp;rsquo;, because from_roman() still thinks this is an invalid Roman numeral.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The to_roman() known values test will fail as soon as it hits 4000, because to_roman() still thinks this is out of range.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The roundtrip check will also fail as soon as it hits 4000, because to_roman() still thinks this is out of range.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now that you have test cases that fail due to the new requirements, you can think about fixing the code to bring it in line with the test cases. (When you first start coding unit tests, it might feel strange that the code being tested is never “ahead” of the test cases. While it’s behind, you still have some work to do, and as soon as it catches up to the test cases, you stop coding. After you get used to it, you’ll wonder how you ever programmed without tests.)
roman_numeral_pattern = re.compile(&amp;ldquo;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;^  # beginning of string&lt;br /&gt;
M{0,4}  # thousands - 0 to 4 Ms  .&lt;br /&gt;
(CM|CD|D?C{0,3})  # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),&lt;/p&gt;

&lt;h1 id=&#34;or-500-800-d-followed-by-0-to-3-cs-2:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;or 500-800 (D, followed by 0 to 3 Cs)&lt;/h1&gt;

&lt;p&gt;(XC|XL|L?X{0,3})  # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),&lt;/p&gt;

&lt;h1 id=&#34;or-50-80-l-followed-by-0-to-3-xs-2:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;or 50-80 (L, followed by 0 to 3 Xs)&lt;/h1&gt;

&lt;p&gt;(IX|IV|V?I{0,3})  # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),&lt;/p&gt;

&lt;h1 id=&#34;or-5-8-v-followed-by-0-to-3-is-2:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;or 5-8 (V, followed by 0 to 3 Is)&lt;/h1&gt;

&lt;p&gt;$  # end of string&lt;br /&gt;
&amp;rdquo;&amp;lsquo;, re.VERBOSE)&lt;/p&gt;

&lt;p&gt;def to_roman(n): &amp;ldquo;&amp;lsquo;convert integer to Roman numeral&amp;rdquo;&amp;rsquo; if not (0 &amp;lt; n &amp;lt; 5000): .
raise OutOfRangeError(&amp;lsquo;number out of range (must be 1..4999)&amp;rsquo;)
if not isinstance(n, int):
raise NotIntegerError(&amp;lsquo;non-integers can not be converted&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;result = &amp;ldquo;
for numeral, integer in roman_numeral_map:&lt;/p&gt;

&lt;p&gt;while n &amp;gt;= integer:
result += numeral
n -= integer&lt;/p&gt;

&lt;p&gt;return result&lt;/p&gt;

&lt;p&gt;def from_roman(s):
.
.
.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;You don’t need to make any changes to the from_roman() function at all. The only change is to roman_numeral_pattern. If you look closely, you’ll notice that I changed the maximum number of optional M characters from 3 to 4 in the first section of the regular expression. This will allow the Roman numeral&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;equivalents of 4999 instead of 3999. The actual from_roman() function is completely generic; it just looks for repeated Roman numeral characters and adds them up, without caring how many times they repeat. The only reason it didn’t handle &amp;lsquo;MMMM&amp;rsquo; before is that you explicitly stopped it with the regular expression pattern matching.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The to_roman() function only needs one small change, in the range check. Where you used to check 0&amp;lt;n &amp;lt; 4000, you now check 0 &amp;lt; n &amp;lt; 5000. And you change the error message that you raise to reflect the new acceptable range (1..4999 instead of 1..3999). You don’t need to make any changes to the rest of the function; it handles the new cases already. (It merrily adds &amp;rsquo;M&amp;rsquo; for each thousand that it finds; given 4000, it will spit out &amp;lsquo;MMMM&amp;rsquo;. The only reason it didn’t do this before is that you explicitly stopped it with the range check.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You may be skeptical that these two small changes are all that you need. Hey, don’t take my word for it; see for yourself.
you@localhost:~/diveintopython3/examples$ python3 romantest9.py -v
from_roman should fail with blank string &amp;hellip; ok
from_roman should fail with malformed antecedents &amp;hellip; ok
from_roman should fail with non-string input &amp;hellip; ok
from_roman should fail with repeated pairs of numerals &amp;hellip; ok
from_roman should fail with too many repeated numerals &amp;hellip; ok
from_roman should give known result with known input &amp;hellip; ok
to_roman should give known result with known input &amp;hellip; ok
from_roman(to_roman(n))==n for all n &amp;hellip; ok
to_roman should fail with negative input &amp;hellip; ok
to_roman should fail with non-integer input &amp;hellip; ok
to_roman should fail with large input &amp;hellip; ok
to_roman should fail with 0 input &amp;hellip; ok&lt;/p&gt;

&lt;p&gt;Ran 12 tests in 0.203s&lt;/p&gt;

&lt;p&gt;OK .
1.  All the test cases pass. Stop coding.
Comprehensive unit testing means never having to rely on a programmer who says “Trust me.”
.&lt;/p&gt;

&lt;p&gt;10.3. REFACTORING
The best thing about comprehensive unit testing is not the feeling you get when all your test cases finally pass, or even the feeling you get when someone else blames you for breaking their code and you can actually prove that you didn’t. The best thing about unit testing is that it gives you the freedom to refactor mercilessly.
Refactoring is the process of taking working code and making it work better. Usually, “better” means “faster”, although it can also mean “using less memory”, or “using less disk space”, or simply “more elegantly”. Whatever it means to you, to your project, in your environment, refactoring is important to the long-term health of any program.
Here, “better” means both “faster” and “easier to maintain.” Specifically, the from_roman() function is slower and more complex than I’d like, because of that big nasty regular expression that you use to validate Roman numerals. Now, you might think, “Sure, the regular expression is big and hairy, but how else am I supposed to validate that an arbitrary string is a valid a Roman numeral?”
Answer: there’s only 5000 of them; why don’t you just build a lookup table? This idea gets even better when you realize that you don’t need to use regular expressions at all. As you build the lookup table for converting integers to Roman numerals, you can build the reverse lookup table to convert Roman numerals to integers. By the time you need to check whether an arbitrary string is a valid Roman numeral, you will have collected all the valid Roman numerals. “Validating” is reduced to a single dictionary lookup.
And best of all, you already have a complete set of unit tests. You can change over half the code in the module, but the unit tests will stay the same. That means you can prove — to yourself and to others — that the new code works just as well as the original.
class OutOfRangeError(ValueError): pass&lt;/p&gt;

&lt;p&gt;class NotIntegerError(ValueError): pass
class InvalidRomanNumeralError(ValueError): pass&lt;/p&gt;

&lt;p&gt;roman_numeral_map = ((&amp;rsquo;M&amp;rsquo;, 1000),
(&amp;lsquo;CM&amp;rsquo;, 900),
(&amp;rsquo;D&amp;rsquo;, 500),
(&amp;lsquo;CD&amp;rsquo;, 400),
(&amp;lsquo;C&amp;rsquo;, 100),
(&amp;lsquo;XC&amp;rsquo;, 90),
(&amp;lsquo;L&amp;rsquo;, 50),
(&amp;lsquo;XL&amp;rsquo;, 40),
(&amp;lsquo;X&amp;rsquo;, 10),
(&amp;lsquo;IX&amp;rsquo;, 9),
(&amp;lsquo;V&amp;rsquo;, 5),
(&amp;lsquo;IV&amp;rsquo;, 4),
(&amp;lsquo;I&amp;rsquo;, 1))&lt;/p&gt;

&lt;p&gt;to_roman_table = [ None ]
from_roman_table = {}&lt;/p&gt;

&lt;p&gt;def to_roman(n):
&amp;ldquo;&amp;lsquo;convert integer to Roman numeral&amp;rdquo;&amp;rsquo;
if not (0 &amp;lt; n &amp;lt; 5000):
raise OutOfRangeError(&amp;lsquo;number out of range (must be 1..4999)&amp;rsquo;)
if int(n) != n:
raise NotIntegerError(&amp;lsquo;non-integers can not be converted&amp;rsquo;)
return to_roman_table[n]&lt;/p&gt;

&lt;p&gt;def from_roman(s):
&amp;ldquo;&amp;lsquo;convert Roman numeral to integer&amp;rdquo;&amp;rsquo;
if not isinstance(s, str):
raise InvalidRomanNumeralError(&amp;lsquo;Input must be a string&amp;rsquo;)
if not s:&lt;/p&gt;

&lt;p&gt;raise InvalidRomanNumeralError(&amp;lsquo;Input can not be blank&amp;rsquo;)
if s not in from_roman_table:
raise InvalidRomanNumeralError(&amp;lsquo;Invalid Roman numeral: {0}&amp;lsquo;.format(s))
return from_roman_table[s]&lt;/p&gt;

&lt;p&gt;def build_lookup_tables():&lt;/p&gt;

&lt;p&gt;def to_roman(n):
result = &amp;ldquo;
for numeral, integer in roman_numeral_map:&lt;/p&gt;

&lt;p&gt;if n &amp;gt;= integer:
result = numeral
n -= integer
break&lt;/p&gt;

&lt;p&gt;if n &amp;gt; 0:
result += to_roman_table[n]
return result&lt;/p&gt;

&lt;p&gt;for integer in range(1, 5000):
roman_numeral = to_roman(integer)
to_roman_table.append(roman_numeral)
from_roman_table[roman_numeral] = integer&lt;/p&gt;

&lt;p&gt;build_lookup_tables()&lt;/p&gt;

&lt;p&gt;Let’s break that down into digestable pieces. Arguably, the most important line is the last one:
build_lookup_tables()&lt;/p&gt;

&lt;p&gt;You will note that is a function call, but there’s no if statement around it. This is not an if &lt;strong&gt;name&lt;/strong&gt; == &amp;lsquo;&lt;strong&gt;main&lt;/strong&gt;&amp;rsquo; block; it gets called when the module is imported. (It is important to understand that modules are only imported once, then cached. If you import an already-imported module, it does nothing. So this code will only get called the first time you import this module.)
So what does the build_lookup_tables() function do? I’m glad you asked.
to_roman_table = [ None ]&lt;/p&gt;

&lt;p&gt;from_roman_table = {}
.
.
.
def build_lookup_tables():&lt;/p&gt;

&lt;p&gt;def to_roman(n): .
result = &amp;ldquo;
for numeral, integer in roman_numeral_map:&lt;/p&gt;

&lt;p&gt;if n &amp;gt;= integer:
result = numeral
n -= integer
break&lt;/p&gt;

&lt;p&gt;if n &amp;gt; 0:
result += to_roman_table[n]
return result&lt;/p&gt;

&lt;p&gt;for integer in range(1, 5000):
roman_numeral = to_roman(integer) .
to_roman_table.append(roman_numeral) .
from_roman_table[roman_numeral] = integer&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This is a clever bit of programming… perhaps too clever. The to_roman() function is defined above; it looks up values in the lookup table and returns them. But the build_lookup_tables() function redefines the to_roman() function to actually do work (like the previous examples did, before you added a lookup table). Within the build_lookup_tables() function, calling to_roman() will call this redefined version. Once the build_lookup_tables() function exits, the redefined version disappears — it is only defined in the local scope of the build_lookup_tables() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This line of code will call the redefined to_roman() function, which actually calculates the Roman numeral.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once you have the result (from the redefined to_roman() function), you add the integer and its Roman numeral equivalent to both lookup tables.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Once the lookup tables are built, the rest of the code is both easy and fast.
def to_roman(n):
&amp;ldquo;&amp;lsquo;convert integer to Roman numeral&amp;rdquo;&amp;rsquo;
if not (0 &amp;lt; n &amp;lt; 5000):&lt;/p&gt;

&lt;p&gt;raise OutOfRangeError(&amp;lsquo;number out of range (must be 1..4999)&amp;rsquo;) if int(n) != n: raise NotIntegerError(&amp;lsquo;non-integers can not be converted&amp;rsquo;) return to_roman_table[n] .
def from_roman(s):
&amp;ldquo;&amp;lsquo;convert Roman numeral to integer&amp;rdquo;&amp;rsquo;
if not isinstance(s, str):&lt;/p&gt;

&lt;p&gt;raise InvalidRomanNumeralError(&amp;lsquo;Input must be a string&amp;rsquo;) if not s: raise InvalidRomanNumeralError(&amp;lsquo;Input can not be blank&amp;rsquo;) if s not in from_roman_table: raise InvalidRomanNumeralError(&amp;lsquo;Invalid Roman numeral: {0}&amp;lsquo;.format(s)) return from_roman_table[s] .
1.  After doing the same bounds checking as before, the to_roman() function simply finds the appropriate value in the lookup table and returns it.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Similarly, the from_roman() function is reduced to some bounds checking and one line of code. No more regular expressions. No more looping. O(1) conversion to and from Roman numerals.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;But does it work? Why yes, yes it does. And I can prove it.
you@localhost:~/diveintopython3/examples$ python3 romantest10.py -v
from_roman should fail with blank string &amp;hellip; ok
from_roman should fail with malformed antecedents &amp;hellip; ok
from_roman should fail with non-string input &amp;hellip; ok
from_roman should fail with repeated pairs of numerals &amp;hellip; ok
from_roman should fail with too many repeated numerals &amp;hellip; ok
from_roman should give known result with known input &amp;hellip; ok
to_roman should give known result with known input &amp;hellip; ok
from_roman(to_roman(n))==n for all n &amp;hellip; ok
to_roman should fail with negative input &amp;hellip; ok
to_roman should fail with non-integer input &amp;hellip; ok
to_roman should fail with large input &amp;hellip; ok
to_roman should fail with 0 input &amp;hellip; ok&lt;/p&gt;

&lt;p&gt;Ran 12 tests in 0.031s  .
OK&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Not that you asked, but it’s fast, too! Like, almost 10× as fast. Of course, it’s not entirely a fair comparison, because this version takes longer to import (when it builds the lookup tables). But since the import is only done once, the startup cost is amortized over all the calls to the to_roman() and from_roman() functions. Since the tests make several thousand function calls (the roundtrip test alone makes 10,000), this savings adds up in a hurry!
The moral of the story?
•   Simplicity is a virtue.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;•   Especially when regular expressions are involved.&lt;/p&gt;

&lt;p&gt;•   Unit tests can give you the confidence to do large-scale refactoring.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;10.4. SUMMARY
Unit testing is a powerful concept which, if properly implemented, can both reduce maintenance costs and increase flexibility in any long-term project. It is also important to understand that unit testing is not a panacea, a Magic Problem Solver, or a silver bullet. Writing good test cases is hard, and keeping them up to date takes discipline (especially when customers are screaming for critical bug fixes). Unit testing is not a replacement for other forms of testing, including functional testing, integration testing, and user acceptance testing. But it is feasible, and it does work, and once you’ve seen it work, you’ll wonder how you ever got along without it.
These few chapters have covered a lot of ground, and much of it wasn’t even Python-specific. There are unit testing frameworks for many languages, all of which require you to understand the same basic concepts:
•   Designing test cases that are specific, automated, and independent&lt;/p&gt;

&lt;p&gt;•   Writing test cases before the code they are testing&lt;/p&gt;

&lt;p&gt;•   Writing tests that test good input and check for proper results&lt;/p&gt;

&lt;p&gt;•   Writing tests that test bad input and check for proper failure responses&lt;/p&gt;

&lt;p&gt;•   Writing and updating test cases to reflect new requirements&lt;/p&gt;

&lt;p&gt;•   Refactoring mercilessly to improve performance, scalability, readability, maintainability, or whatever other -ility you’re lacking&lt;/p&gt;

&lt;p&gt;CHAPTER 11. FILES&lt;/p&gt;

&lt;p&gt;. A nine mile walk is no joke, especially in the rain. .
—   Harry Kemelman, The Nine Mile Walk
11.1. DIVING IN
My Windows laptop had 38,493 files before I installed a single application. Installing Python 3 added almost 3,000 files to that total. Files are the primary storage paradigm of every major operating system; the concept is so ingrained that most people would have trouble imagining
an
alternative. Your computer is, metaphorically speaking, drowning in files.
11.2. READING FROM TEXT FILES
Before you can read from a file, you need to open it. Opening a file in Python couldn’t be easier:
a_file = open(&amp;lsquo;examples/chinese.txt&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;Python has a built-in open() function, which takes a filename as an argument. Here the filename is
&amp;lsquo;examples/chinese.txt&amp;rsquo;. There are five interesting things about this filename:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It’s not just the name of a file; it’s a combination of a directory path and a filename. A hypothetical file-opening function could have taken two arguments — a directory path and a filename — but the open() function only takes one. In Python, whenever you need a “filename,” you can include some or all of a directory path as well.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The directory path uses a forward slash, but I didn’t say what operating system I was using. Windows uses backward slashes to denote subdirectories, while Mac OS X and Linux use forward slashes. But in Python, forward slashes always Just Work, even on Windows.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The directory path does not begin with a slash or a drive letter, so it is called a relative path. Relative to what, you might ask? Patience, grasshopper.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It’s a string. All modern operating systems (even Windows!) use Unicode to store the names of files and directories. Python 3 fully supports non-ASCII pathnames.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It doesn’t need to be on your local disk. You might have a network drive mounted. That “file” might be a figment of an
entirely
virtual
filesystem. If your computer considers it a file and can access it as a file, Python can open it.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;But that call to the open() function didn’t stop at the filename. There’s another argument, called encoding. Oh dear, that
sounds
dreadfully
familiar.
11.2.1. CHARACTER ENCODING REARS ITS UGLY HEAD
Bytes are bytes; characters
are
an
abstraction. A string is a sequence of Unicode characters. But a file on disk is not a sequence of Unicode characters; a file on disk is a sequence of bytes. So if you read a “text file” from disk, how does Python convert that sequence of bytes into a sequence of characters? It decodes the bytes according to a specific character encoding algorithm and returns a sequence of Unicode characters (otherwise known as a string).&lt;/p&gt;

&lt;h1 id=&#34;this-example-was-created-on-windows-other-platforms-may:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;This example was created on Windows. Other platforms may&lt;/h1&gt;

&lt;h1 id=&#34;behave-differently-for-reasons-outlined-below:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;behave differently, for reasons outlined below.&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;file = open(&amp;lsquo;examples/chinese.txt&amp;rsquo;)
a_string = file.read()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
File &amp;ldquo;C:\Python31\lib\encodings\cp1252.py&amp;rdquo;, line 23, in decode&lt;/p&gt;

&lt;p&gt;return codecs.charmap_decode(input,self.errors,decoding_table)[0]
UnicodeDecodeError: &amp;lsquo;charmap&amp;rsquo; codec can&amp;rsquo;t decode byte 0x8f in position 28: character maps to &lt;undefined&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;What just happened? You didn’t specify a character encoding, so Python is forced to use the default encoding. What’s the default encoding? If you look closely at the traceback, you can see that it’s dying in cp1252.py, meaning that Python is using CP-1252 as the default encoding here. (CP-1252 is a common encoding on computers running Microsoft Windows.) The CP-1252 character set doesn’t support the characters that are in this file, so the read fails with an ugly UnicodeDecodeError.
But wait, it’s worse than that! The default encoding is platform-dependent, so this code might work on your computer (if your default encoding is UTF-8), but then it will fail when you distribute it to someone else (whose default encoding is different, like CP-1252).&lt;/p&gt;

&lt;p&gt;. If you need to get the default character encoding, import the locale module and call locale.getpreferredencoding(). On my Windows laptop, it returns &amp;lsquo;cp1252&amp;rsquo;, but on my Linux box upstairs, it returns &amp;lsquo;UTF8&amp;rsquo;. I can’t even maintain consistency in my own house! Your results may be different (even on Windows) depending on which version of your operating system you have installed and how your regional/language settings are configured. This is why it’s so important to specify the encoding every time you open a file.
11.2.2. STREAM OBJECTS
So far, all we know is that Python has a built-in function called open(). The open() function returns a stream object, which has methods and attributes for getting information about and manipulating a stream of characters.
&amp;gt;&amp;gt;&amp;gt; a_file = open(&amp;lsquo;examples/chinese.txt&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;)&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_file.name .
&amp;lsquo;examples/chinese.txt&amp;rsquo;
a_file.encoding .
&amp;lsquo;utf-8&amp;rsquo;
a_file.mode .
&amp;lsquo;r&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;The name attribute reflects the name you passed in to the open() function when you opened the file. It is not normalized to an absolute pathname.&lt;/li&gt;
&lt;li&gt;Likewise, encoding attribute reflects the encoding you passed in to the open() function. If you didn’t specify the encoding when you opened the file (bad developer!) then the encoding attribute will reflect locale.getpreferredencoding().&lt;/li&gt;
&lt;li&gt;The mode attribute tells you in which mode the file was opened. You can pass an optional mode parameter to the open() function. You didn’t specify a mode when you opened this file, so Python defaults to &amp;lsquo;r&amp;rsquo;, which means “open for reading only, in text mode.” As you’ll see later in this chapter, the file mode serves several purposes; different modes let you write to a file, append to a file, or open a file in binary mode (in which you deal with bytes instead of strings).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. The documentation
for
the
open() function
lists all the possible file modes.
11.2.3. READING DATA FROM A TEXT FILE
After you open a file for reading, you’ll probably want to read from it at some point.
&amp;gt;&amp;gt;&amp;gt; a_file = open(&amp;lsquo;examples/chinese.txt&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; a_file.read() .
&amp;lsquo;Dive Into Python &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.. Python ..\n&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; a_file.read() .
&amp;ldquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Once you open a file (with the correct encoding), reading from it is just a matter of calling the stream
object’s read() method. The result is a string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perhaps somewhat surprisingly, reading the file again does not raise an exception. Python does not consider reading past end-of-file to be an error; it simply returns an empty string.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What if you want to re-read a file?&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-3:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_file.read() .
&amp;ldquo;
a_file.seek(0) .
0
a_file.read(16) .
&amp;lsquo;Dive Into Python&amp;rsquo;
a_file.read(1) .
&amp;lsquo; &amp;rsquo;
a_file.read(1)
&amp;lsquo;.&amp;rsquo;
a_file.tell() .
20&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Since you’re still at the end of the file, further calls to the stream object’s read() method simply return an
empty string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The seek() method moves to a specific byte position in a file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The read() method can take an optional parameter, the number of characters to read.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you like, you can even read one character at a time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;16+1+1 =…20?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s try that again.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-4:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_file.seek(17) .
17
a_file.read(1) .
&amp;lsquo;.&amp;rsquo;
a_file.tell() .
20&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;Move to the 17th byte.&lt;/li&gt;
&lt;li&gt;Read one character.&lt;/li&gt;
&lt;li&gt;Now you’re on the 20th byte.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Do you see it yet? The seek() and tell() methods always count bytes, but since you opened this file as text, the read() method counts characters. Chinese characters require
multiple
bytes
to
encode
in
UTF-8. The English characters in the file only require one byte each, so you might be misled into thinking that the seek() and read() methods are counting the same thing. But that’s only true for some characters.
But wait, it gets worse!
&amp;gt;&amp;gt;&amp;gt; a_file.seek(18) .
18
&amp;gt;&amp;gt;&amp;gt; a_file.read(1) .&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;pyshell#12&gt;&amp;rdquo;, line 1, in &lt;module&gt;
a_file.read(1)
File &amp;ldquo;C:\Python31\lib\codecs.py&amp;rdquo;, line 300, in decode
(result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: &amp;lsquo;utf8&amp;rsquo; codec can&amp;rsquo;t decode byte 0x98 in position 0: unexpected code byte&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Move to the 18th byte and try to read one character.&lt;/li&gt;
&lt;li&gt;Why does this fail? Because there isn’t a character at the 18th byte. The nearest character starts at the 17th byte (and goes for three bytes). Trying to read a character from the middle will fail with a UnicodeDecodeError.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;11.2.4. CLOSING FILES&lt;/p&gt;

&lt;p&gt;Open files consume system resources, and depending on the file mode, other programs may not be able to access them. It’s important to close files as soon as you’re finished with them.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-5:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_file.close()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Well that was anticlimactic.
The stream object a_file still exists; calling its close() method doesn’t destroy the object itself. But it’s not terribly useful.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-6:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_file.read() .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;pyshell#24&gt;&amp;rdquo;, line 1, in &lt;module&gt;
a_file.read()
ValueError: I/O operation on closed file.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a_file.seek(0) .
Traceback (most recent call last):
File &amp;ldquo;&lt;pyshell#25&gt;&amp;rdquo;, line 1, in &lt;module&gt;
a_file.seek(0)
ValueError: I/O operation on closed file.&lt;/p&gt;

&lt;p&gt;a_file.tell() .
Traceback (most recent call last):
File &amp;ldquo;&lt;pyshell#26&gt;&amp;rdquo;, line 1, in &lt;module&gt;
a_file.tell()
ValueError: I/O operation on closed file.&lt;/p&gt;

&lt;p&gt;a_file.close() .
a_file.closed .
True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;You can’t read from a closed file; that raises an IOError exception.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can’t seek in a closed file either.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There’s no current position in a closed file, so the tell() method also fails.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perhaps surprisingly, calling the close() method on a stream object whose file has been closed does not raise an exception. It’s just a no-op.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Closed stream objects do have one useful attribute: the closed attribute will confirm that the file is closed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;11.2.5. CLOSING FILES AUTOMATICALLY
Stream objects have an explicit close() method, but
what happens if your code has a bug and crashes before
you call close()? That file could theoretically stay open
for much longer than necessary. While you’re debugging
on your local computer, that’s not a big deal. On a
production server, maybe it is.&lt;/p&gt;

&lt;p&gt;Python 2 had a solution for this: the try..finally
block. That still works in Python 3, and you may see it
in other people’s code or in older code that was ported&lt;/p&gt;

&lt;p&gt;to
Python
3. But Python 2.6 introduced a cleaner
solution, which is now the preferred solution in Python&lt;/p&gt;

&lt;p&gt;3: the with statement.&lt;/p&gt;

&lt;p&gt;with open(&amp;lsquo;examples/chinese.txt&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as a_file:&lt;/p&gt;

&lt;p&gt;a_file.seek(17)&lt;/p&gt;

&lt;p&gt;a_character = a_file.read(1)&lt;/p&gt;

&lt;p&gt;print(a_character)&lt;/p&gt;

&lt;p&gt;This code calls open(), but it never calls a_file.close(). The with statement starts a code block, like an if statement or a for loop. Inside this code block, you can use the variable a_file as the stream object returned from the call to open(). All the regular stream object methods are available — seek(), read(), whatever you need. When the with block ends, Python calls a_file.close() automatically.
Here’s the kicker: no matter how or when you exit the with block, Python will close that file… even if you “exit” it via an unhandled exception. That’s right, even if your code raises an exception and your entire program comes to a screeching halt, that file will get closed. Guaranteed.
. In technical terms, the with statement creates a runtime context. In these examples,
the stream object acts as a context manager. Python creates the stream object
a_file and tells it that it is entering a runtime context. When the with code block
is completed, Python tells the stream object that it is exiting the runtime context,
and the stream object calls its own close() method. See Appendix
B,
“Classes
That&lt;/p&gt;

&lt;p&gt;Can
Be
Used
in
a
with Block”
for details.&lt;/p&gt;

&lt;p&gt;There’s nothing file-specific about the with statement; it’s just a generic framework for creating runtime contexts and telling objects that they’re entering and exiting a runtime context. If the object in question is a stream object, then it does useful file-like things (like closing the file automatically). But that behavior is defined in the stream object, not in the with statement. There are lots of other ways to use context managers that have nothing to do with files. You can even create your own, as you’ll see later in this chapter.
11.2.6. READING DATA ONE LINE AT A TIME
A “line” of a text file is just what you think it is — you type a few words and press ENTER, and now you’re on a new line. A line of text is a sequence of characters delimited by… what exactly? Well, it’s complicated, because text files can use several different characters to mark the end of a line. Every operating system has its own convention. Some use a carriage return character, others use a line feed character, and some use both characters at the end of every line.
Now breathe a sigh of relief, because Python handles line endings automatically by default. If you say, “I want to read this text file one line at a time,” Python will figure out which kind of line ending the text file uses and and it will all Just Work.
.&lt;/p&gt;

&lt;p&gt;If you need fine-grained control over what’s considered a line ending, you can pass the optional newline parameter to the open() function. See the
open() function
documentation
for all the gory details.
So, how do you actually do it? Read a file one line at a time, that is. It’s so simple, it’s beautiful.
line_number = 0
with open(&amp;lsquo;examples/favorite-people.txt&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as a_file: .&lt;/p&gt;

&lt;p&gt;for a_line in a_file: . line_number += 1 print(&amp;lsquo;{:&amp;gt;4} {}&amp;lsquo;.format(line_number, a_line.rstrip())) .
1.  Using the
with pattern, you safely open the file and let Python close it for you.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To read a file one line at a time, use a for loop. That’s it. Besides having explicit methods like read(), the stream object is also an iterator which spits out a single line every time you ask for a value.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using the
format() string
method, you can print out the line number and the line itself. The format specifier {:&amp;gt;4} means “print this argument right-justified within 4 spaces.” The a_line variable contains the complete line, carriage returns and all. The rstrip() string method removes the trailing whitespace, including the carriage return characters.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;you@localhost:~/diveintopython3$ python3 examples/oneline.py
1 Dora
2 Ethan
3 Wesley
4 John
5 Anne
6 Mike
7 Chris
8 Sarah
9 Alex&lt;/p&gt;

&lt;p&gt;10 Lizzie&lt;/p&gt;

&lt;p&gt;Did you get this error?
you@localhost:~/diveintopython3$ python3 examples/oneline.py&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;examples/oneline.py&amp;rdquo;, line 4, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;print(&amp;lsquo;{:&amp;gt;4} {}&amp;lsquo;.format(line_number, a_line.rstrip()))&lt;/p&gt;

&lt;p&gt;ValueError: zero length field name in format&lt;/p&gt;

&lt;p&gt;If so, you’re probably using Python 3.0. You should really upgrade to Python 3.1.
Python 3.0 supported string formatting, but only with explicitly
numbered
format
specifiers. Python 3.1 allows you to omit the argument indexes in your format specifiers. Here is the Python 3.0-compatible version for comparison:
print(&amp;lsquo;{0
:&amp;gt;4} {1
}&amp;lsquo;.format(line_number, a_line.rstrip()))&lt;/p&gt;

&lt;p&gt;.
11.3. WRITING TO TEXT FILES
You can write to files in much the same way that you read from them. First you open a file and get a stream object, then you use methods on the stream object to write data to the file, then you close the file.
To open a file for writing, use the open() function and specify the write mode. There are two file modes for writing:
•   “Write” mode will overwrite the file. Pass mode=&amp;lsquo;w&amp;rsquo; to the open() function.&lt;/p&gt;

&lt;p&gt;• “Append” mode will add data to the end of the file. Pass mode=&amp;lsquo;a&amp;rsquo; to the open() function.&lt;/p&gt;

&lt;p&gt;Either mode will create the file automatically if it doesn’t already exist, so there’s never a need for any sort of fiddly “if the file doesn’t exist yet, create a new empty file just so you can open it for the first time” function. Just open a file and start writing.
You should always close a file as soon as you’re done&lt;/p&gt;

&lt;p&gt;writing to it, to release the file handle and ensure that
the data is actually written to disk. As with reading data from a file, you can call the stream object’s close()
method, or you can use the with statement and let Python close the file for you. I bet you can guess which
technique I recommend.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;with open(&amp;lsquo;test.log&amp;rsquo;, mode=&amp;lsquo;w&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as a_file: .
&amp;hellip; a_file.write(&amp;lsquo;test succeeded&amp;rsquo;) .
with open(&amp;lsquo;test.log&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as a_file:
&amp;hellip; print(a_file.read())
test succeeded
with open(&amp;lsquo;test.log&amp;rsquo;, mode=&amp;lsquo;a&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as a_file: .
&amp;hellip; a_file.write(&amp;lsquo;and again&amp;rsquo;)
with open(&amp;lsquo;test.log&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as a_file:
&amp;hellip; print(a_file.read())
test succeededand again .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You start boldly by creating the new file test.log (or overwriting the existing file), and opening the file for writing. The mode=&amp;lsquo;w&amp;rsquo; parameter means open the file for writing. Yes, that’s all as dangerous as it sounds. I hope you didn’t care about the previous contents of that file (if any), because that data is gone now.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can add data to the newly opened file with the write() method of the stream object returned by the open() function. After the with block ends, Python automatically closes the file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That was so fun, let’s do it again. But this time, with mode=&amp;lsquo;a&amp;rsquo; to append to the file instead of overwriting it. Appending will never harm the existing contents of the file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Both the original line you wrote and the second line you appended are now in the file test.log. Also note that neither carriage returns nor line feeds are included. Since you didn’t write them explicitly to the file either time, the file doesn’t include them. You can write a carriage return with the &amp;lsquo;\r&amp;rsquo; character, and/or a line feed with the &amp;lsquo;\n&amp;rsquo; character. Since you didn’t do either, everything you wrote to the file ended up on one line.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;11.3.1. CHARACTER ENCODING AGAIN
Did you notice the encoding parameter that got passed in to the open() function while you were opening
a
file
for
writing? It’s important; don’t ever leave it out! As you saw in the beginning of this chapter, files don’t contain strings, they contain bytes. Reading a “string” from a text file only works because you told Python what encoding to use to read a stream of bytes and convert it to a string. Writing text to a file presents the same problem in reverse. You can’t write characters to a file; characters
are
an
abstraction. In order to write to the file, Python needs to know how to convert your string into a sequence of bytes. The only way to be sure it’s performing the correct conversion is to specify the encoding parameter when you open the file for writing.
.&lt;/p&gt;

&lt;p&gt;11.4. BINARY FILES
Not all files contain text. Some of them contain pictures of my dog.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;an_image = open(&amp;lsquo;examples/beauregard.jpg&amp;rsquo;, mode=&amp;lsquo;rb&amp;rsquo;) .
an_image.mode .
&amp;lsquo;rb&amp;rsquo;
an_image.name .
&amp;lsquo;examples/beauregard.jpg&amp;rsquo;
an_image.encoding .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
AttributeError: &amp;lsquo;_io.BufferedReader&amp;rsquo; object has no attribute &amp;lsquo;encoding&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Opening a file in binary mode is simple but subtle. The only difference from opening it in text mode is that the mode parameter contains a &amp;lsquo;b&amp;rsquo; character.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The stream object you get from opening a file in binary mode has many of the same attributes, including mode, which reflects the mode parameter you passed into the open() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Binary stream objects also have a name attribute, just like text stream objects.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Here’s one difference, though: a binary stream object has no encoding attribute. That makes sense, right? You’re reading (or writing) bytes, not strings, so there’s no conversion for Python to do. What you get out of a binary file is exactly what you put into it, no conversion necessary.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Did I mention you’re reading bytes? Oh yes you are.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-7:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;an_image.tell()
0
data = an_image.read(3) .
data
b&amp;rsquo;\xff\xd8\xff&amp;rsquo;
type(data) .
&lt;class &#39;bytes&#39;&gt;
an_image.tell() .
3
an_image.seek(0)
0
data = an_image.read()
len(data)
3150&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Like text files, you can read binary files a little bit at a time. But there’s a crucial difference…&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;…you’re reading bytes, not strings. Since you opened the file in binary mode, the read() method takes the number of bytes to read, not the number of characters.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That means that there’s never an
unexpected
mismatch
between the number you passed into the read() method and the position index you get out of the tell() method. The read() method reads bytes, and the seek() and tell() methods track the number of bytes read. For binary files, they’ll always agree.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.
11.5. STREAM OBJECTS FROM NON-FILE SOURCES
Imagine you’re writing a library, and one of your library functions is going to read some data from a file. The function could simply take a filename as a string, go open the file for reading, read it, and close it before exiting. But you shouldn’t do that. Instead, your API should take an arbitrary stream object.
In the simplest case, a stream object is anything with a read() method which takes an optional size parameter and returns a string. When called with no size parameter, the read() method should read everything there is to read from the input source and return all the data as a single value. When called with a size parameter, it reads that much from the input source and returns that much data. When called again, it picks up where it left off and returns the next chunk of data.&lt;/p&gt;

&lt;p&gt;That sounds exactly like the stream object you get from opening a real file. The difference is that you’re not limiting yourself to real files. The input source that’s being “read” could be anything: a web page, a string in memory, even the output of another program. As long as your functions take a stream object and simply call the object’s read() method, you can handle any input source that acts like a file, without specific code to handle each kind of input.
&amp;gt;&amp;gt;&amp;gt; a_string = &amp;lsquo;PapayaWhip is the new black.&amp;rsquo;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import io .
a_file = io.StringIO(a_string) .
a_file.read() .
&amp;lsquo;PapayaWhip is the new black.&amp;rsquo;
a_file.read() .
&amp;ldquo;
a_file.seek(0) .
0
a_file.read(10) .
&amp;lsquo;PapayaWhip&amp;rsquo;
a_file.tell()
10
a_file.seek(18)
18
a_file.read()
&amp;lsquo;new black.&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The io module defines the StringIO class that you can use to treat a string in memory as a file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To create a stream object out of a string, create an instance of the io.StringIO() class and pass it the string you want to use as your “file” data. Now you have a stream object, and you can do all sorts of stream-like things with it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Calling the read() method “reads” the entire “file,” which in the case of a StringIO object simply returns the original string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Just like a real file, calling the read() method again returns an empty string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can explicitly seek to the beginning of the string, just like seeking through a real file, by using the seek() method of the StringIO object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can also read the string in chunks, by passing a size parameter to the read() method.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. io.StringIO lets you treat a string as a text file. There’s also a io.BytesIO class,
which lets you treat a byte array as a binary file.
11.5.1. HANDLING COMPRESSED FILES&lt;/p&gt;

&lt;p&gt;The Python standard library contains modules that support reading and writing compressed files. There are a number of different compression schemes; the two most popular on non-Windows systems are gzip
and bzip2. (You may have also encountered PKZIP
archives
and GNU
Tar
archives. Python has modules for those, too.)
The gzip module lets you create a stream object for reading or writing a gzip-compressed file. The stream object it gives you supports the read() method (if you opened it for reading) or the write() method (if you opened it for writing). That means you can use the methods you’ve already learned for regular files to directly read or write a gzip-compressed file, without creating a temporary file to store the decompressed data.
As an added bonus, it supports the with statement too, so you can let Python automatically close your gzip­compressed file when you’re done with it.
you@localhost:~$ python3&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import gzip
with gzip.open(&amp;lsquo;out.log.gz&amp;rsquo;, mode=&amp;lsquo;wb&amp;rsquo;) as z_file: .
&amp;hellip; z_file.write(&amp;lsquo;A nine mile walk is no joke, especially in the rain.&amp;rsquo;.encode(&amp;lsquo;utf-8&amp;rsquo;))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;hellip;
&amp;gt;&amp;gt;&amp;gt; exit()&lt;/p&gt;

&lt;p&gt;you@localhost:~$ ls -l out.log.gz .
-rw-r&amp;ndash;r&amp;ndash;1 mark mark 79 2009-07-19 14:29 out.log.gz
you@localhost:~$ gunzip out.log.gz .
you@localhost:~$ cat out.log .
A nine mile walk is no joke, especially in the rain.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You should always open gzipped files in binary mode. (Note the &amp;lsquo;b&amp;rsquo; character in the mode argument.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I constructed this example on Linux. If you’re not familiar with the command line, this command is showing the “long listing” of the gzip-compressed file you just created in the Python Shell. This listing shows that the file exists (good), and that it is 79 bytes long. That’s actually larger than the string you started with! The gzip&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;file format includes a fixed-length header that contains some metadata about the file, so it’s inefficient for extremely small files.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The gunzip command (pronounced “gee-unzip”) decompresses the file and stores the contents in a new file named the same as the compressed file but without the .gz file extension.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The cat command displays the contents of a file. This file contains the string you originally wrote directly to the compressed file out.log.gz from within the Python Shell.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Did you get this error?
&amp;gt;&amp;gt;&amp;gt; with gzip.open(&amp;lsquo;out.log.gz&amp;rsquo;, mode=&amp;lsquo;wb&amp;rsquo;) as z_file:
&amp;hellip; z_file.write(&amp;lsquo;A nine mile walk is no joke, especially in the rain.&amp;rsquo;.encode(&amp;lsquo;utf-8&amp;rsquo;))
&amp;hellip;&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
AttributeError: &amp;lsquo;GzipFile&amp;rsquo; object has no attribute &amp;lsquo;&lt;strong&gt;exit&lt;/strong&gt;&amp;lsquo;&lt;/p&gt;

&lt;p&gt;If so, you’re probably using Python 3.0. You should really upgrade to Python 3.1.
Python 3.0 had a gzip module, but it did not support using a gzipped-file object as a context manager. Python 3.1 added the ability to use gzipped-file objects in a with statement.
.&lt;/p&gt;

&lt;p&gt;11.6. STANDARD INPUT, OUTPUT, AND ERROR
Command-line gurus are already familiar with the concept of standard input, standard output, and standard
error. This section is for the rest of you.
Standard output and standard error (commonly abbreviated stdout and stderr) are pipes that are built into every UNIX-like system, including Mac OS X and Linux. When you call the print() function, the thing you’re printing is sent to the stdout pipe. When your program crashes and prints out a traceback, it goes to the stderr pipe. By default, both of these pipes are just connected to the terminal window where you are&lt;/p&gt;

&lt;p&gt;working; when your program prints something, you see the output in your terminal window, and when a program crashes, you see the traceback in your terminal window too. In the graphical Python Shell, the stdout and stderr pipes default to your “Interactive Window”.
&amp;gt;&amp;gt;&amp;gt; for i in range(3):
&amp;hellip; print(&amp;lsquo;PapayaWhip&amp;rsquo;) .
PapayaWhip
PapayaWhip
PapayaWhip
&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; for i in range(3):
&amp;hellip; sys.stdout.write(&amp;lsquo;is the&amp;rsquo;) .
is theis theis the
&amp;gt;&amp;gt;&amp;gt; for i in range(3):
&amp;hellip; sys.stderr.write(&amp;lsquo;new black&amp;rsquo;) .
new blacknew blacknew black&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The print() function, in a loop. Nothing surprising here.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;stdout is defined in the sys module, and it is a stream
object. Calling its write() function will print out whatever string you give it. In fact, this is what the print function really does; it adds a carriage return to the end of the string you’re printing, and calls sys.stdout.write.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In the simplest case, sys.stdout and sys.stderr send their output to the same place: the Python IDE (if you’re in one), or the terminal (if you’re running Python from the command line). Like standard output, standard error does not add carriage returns for you. If you want carriage returns, you’ll need to write carriage return characters.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sys.stdout and sys.stderr are stream objects, but they are write-only. Attempting to call their read() method will always raise an IOError.
&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.stdout.read()&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
IOError: not readable&lt;/p&gt;

&lt;p&gt;11.6.1. REDIRECTING STANDARD OUTPUT
sys.stdout and sys.stderr are stream objects, albeit ones that only support writing. But they’re not constants; they’re variables. That means you can assign them a new value — any other stream object — to redirect their output.
import sys&lt;/p&gt;

&lt;p&gt;class RedirectStdoutTo:
def &lt;strong&gt;init&lt;/strong&gt;(self, out_new):
self.out_new = out_new&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;enter&lt;/strong&gt;(self):
self.out_old = sys.stdout
sys.stdout = self.out_new&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;exit&lt;/strong&gt;(self, *args):
sys.stdout = self.out_old&lt;/p&gt;

&lt;p&gt;print(&amp;lsquo;A&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;with open(&amp;lsquo;out.log&amp;rsquo;, mode=&amp;lsquo;w&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as a_file, RedirectStdoutTo(a_file):
print(&amp;lsquo;B&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;print(&amp;lsquo;C&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;Check this out:
you@localhost:~/diveintopython3/examples$ python3 stdout.py
A&lt;/p&gt;

&lt;p&gt;you@localhost:~/diveintopython3/examples$ cat out.log
B&lt;/p&gt;

&lt;p&gt;Did you get this error?
you@localhost:~/diveintopython3/examples$ python3 stdout.py&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;stdout.py&amp;rdquo;, line 15
with open(&amp;lsquo;out.log&amp;rsquo;, mode=&amp;lsquo;w&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as a_file, RedirectStdoutTo(a_file):
^
SyntaxError: invalid syntax&lt;/p&gt;

&lt;p&gt;If so, you’re probably using Python 3.0. You should really upgrade to Python 3.1.
Python 3.0 supported the with statement, but each statement can only use one context manager. Python 3.1 allows you to chain multiple context managers in a single with statement.
Let’s take the last part first.
print(&amp;lsquo;A&amp;rsquo;)
with open(&amp;lsquo;out.log&amp;rsquo;, mode=&amp;lsquo;w&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as a_file, RedirectStdoutTo(a_file):
print(&amp;lsquo;B&amp;rsquo;)
print(&amp;lsquo;C&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;That’s a complicated with statement. Let me rewrite it as something more recognizable.
with open(&amp;lsquo;out.log&amp;rsquo;, mode=&amp;lsquo;w&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as a_file:
with RedirectStdoutTo(a_file):
print(&amp;lsquo;B&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;As the rewrite shows, you actually have two with statements, one nested within the scope of the other. The “outer” with statement should be familiar by now: it opens a UTF-8-encoded text file named out.log for writing and assigns the stream object to a variable named a_file. But that’s not the only thing odd here.
with RedirectStdoutTo(a_file):&lt;/p&gt;

&lt;p&gt;Where’s the as clause? The with statement doesn’t actually require one. Just like you can call a function and ignore its return value, you can have a with statement that doesn’t assign the with context to a variable. In this case, you’re only interested in the side effects of the RedirectStdoutTo context.
What are those side effects? Take a look inside the RedirectStdoutTo class. This class is a custom context
manager. Any class can be a context manager by defining two special
methods: &lt;strong&gt;enter&lt;/strong&gt;() and &lt;strong&gt;exit&lt;/strong&gt;().
class RedirectStdoutTo:&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;init&lt;/strong&gt;(self, out_new): .
self.out_new = out_new&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;enter&lt;/strong&gt;(self): .
self.out_old = sys.stdout
sys.stdout = self.out_new&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;exit&lt;/strong&gt;(self, *args): .
sys.stdout = self.out_old&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;strong&gt;init&lt;/strong&gt;() method is called immediately after an instance is created. It takes one parameter, the stream object that you want to use as standard output for the life of the context. This method just saves the stream object in an instance variable so other methods can use it later.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;enter&lt;/strong&gt;() method is a special
class
method; Python calls it when entering a context (i.e. at the beginning of the with statement). This method saves the current value of sys.stdout in self.out_old, then redirects standard output by assigning self.out_new to sys.stdout.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;exit&lt;/strong&gt;() method is another special class method; Python calls it when exiting the context (i.e. at the end of the with statement). This method restores standard output to its original value by assigning the saved self.out_old value to sys.stdout.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Putting it all together:
print(&amp;lsquo;A&amp;rsquo;)  .
with open(&amp;lsquo;out.log&amp;rsquo;, mode=&amp;lsquo;w&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as a_file, RedirectStdoutTo(a_file): . print(&amp;lsquo;B&amp;rsquo;) .
print(&amp;lsquo;C&amp;rsquo;)  .
1.  This will print to the IDE “Interactive Window” (or the terminal, if running the script from the command line).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This with statement
takes a comma-separated list of contexts. The comma-separated list acts like a series of nested with blocks. The first context listed is the “outer” block; the last one listed is the “inner” block. The first context opens a file; the second context redirects sys.stdout to the stream object that was created in the first context.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Because this print() function is executed with the context created by the with statement, it will not print to the screen; it will write to the file out.log.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The with code block is over. Python has told each context manager to do whatever it is they do upon exiting a context. The context managers form a last-in-first-out stack. Upon exiting, the second context changed sys.stdout back to its original value, then the first context closed the file named out.log. Since standard output has been restored to its original value, calling the print() function will once again print to the screen.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Redirecting standard error works exactly the same way, using sys.stderr instead of sys.stdout.
.
11.7. FURTHER READING
•   Reading
and
writing
files
in the Python.org tutorial&lt;/p&gt;

&lt;p&gt;•   io module&lt;/p&gt;

&lt;p&gt;•   Stream
objects&lt;/p&gt;

&lt;p&gt;•   Context
manager
types&lt;/p&gt;

&lt;p&gt;•   sys.stdout and
sys.stderr
•   FUSE
on
Wikipedia&lt;/p&gt;

&lt;p&gt;CHAPTER 12. XML&lt;/p&gt;

&lt;p&gt;. In the archonship of Aristaechmus, Draco enacted his ordinances. .
— Aristotle
12.1. DIVING IN
Nearly all the chapters in this book revolve around a piece of sample code. But XML isn’t about code; it’s about data. One common use of XML is “syndication feeds” that list the latest articles on a blog, forum, or other frequently-updated website. Most popular blogging software can produce a feed and update it whenever new articles, discussion threads, or blog posts are published. You can follow a blog by “subscribing” to its feed, and you can follow multiple blogs with a dedicated “feed
aggregator” like Google
Reader.
Here, then, is the XML data we’ll be working with in this chapter. It’s a feed — specifically, an Atom
syndication
feed.
&amp;lt;?xml version=&amp;lsquo;1.0&amp;rsquo; encoding=&amp;lsquo;utf-8&amp;rsquo;?&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;&gt;
&lt;title&gt;dive into mark&lt;/title&gt;
&lt;subtitle&gt;currently between addictions&lt;/subtitle&gt;
&lt;id&gt;tag:diveintomark.org,2001-07-29:/&lt;/id&gt;
&lt;updated&gt;2009-03-27T21:56:07Z&lt;/updated&gt;
&lt;link rel=&#39;alternate&#39; type=&#39;text/html&#39; href=&#39;http://diveintomark.org/&#39;/&gt;
&lt;link rel=&#39;self&#39; type=&#39;application/atom+xml&#39; href=&#39;http://diveintomark.org/feed/&#39;/&gt;
&lt;entry&gt;&lt;/p&gt;

&lt;p&gt;&lt;author&gt;
&lt;name&gt;Mark&lt;/name&gt;
&lt;uri&gt;&lt;a href=&#34;http://diveintomark.org/&#34;&gt;http://diveintomark.org/&lt;/a&gt;&lt;/uri&gt;&lt;/p&gt;

&lt;p&gt;&lt;/author&gt;
&lt;title&gt;Dive into history, 2009 edition&lt;/title&gt;
&amp;lt;link rel=&amp;lsquo;alternate&amp;rsquo; type=&amp;lsquo;text/html&amp;rsquo;&lt;/p&gt;

&lt;p&gt;href=&amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;/&amp;gt;&#34;&gt;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;/&amp;gt;&lt;/a&gt;
&lt;id&gt;tag:diveintomark.org,2009-03-27:/archives/20090327172042&lt;/id&gt;
&lt;updated&gt;2009-03-27T21:56:07Z&lt;/updated&gt;
&lt;published&gt;2009-03-27T17:20:42Z&lt;/published&gt;
&lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;diveintopython&#39;/&gt;
&lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;docbook&#39;/&gt;
&lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;html&#39;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;summary type=&#39;html&#39;&gt;Putting an entire chapter on one page sounds
bloated, but consider this &amp;amp;mdash; my longest chapter so far
would be 75 printed pages, and it loads in under 5 seconds&amp;amp;hellip;
On dialup.&lt;/summary&gt;&lt;/p&gt;

&lt;p&gt;&lt;/entry&gt;
&lt;entry&gt;&lt;/p&gt;

&lt;p&gt;&lt;author&gt;
&lt;name&gt;Mark&lt;/name&gt;
&lt;uri&gt;&lt;a href=&#34;http://diveintomark.org/&#34;&gt;http://diveintomark.org/&lt;/a&gt;&lt;/uri&gt;&lt;/p&gt;

&lt;p&gt;&lt;/author&gt;
&lt;title&gt;Accessibility is a harsh mistress&lt;/title&gt;
&amp;lt;link rel=&amp;lsquo;alternate&amp;rsquo; type=&amp;lsquo;text/html&amp;rsquo;&lt;/p&gt;

&lt;p&gt;href=&amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress&#39;/&amp;gt;&#34;&gt;http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress&#39;/&amp;gt;&lt;/a&gt;
&lt;id&gt;tag:diveintomark.org,2009-03-21:/archives/20090321200928&lt;/id&gt;
&lt;updated&gt;2009-03-22T01:05:37Z&lt;/updated&gt;
&lt;published&gt;2009-03-21T20:09:28Z&lt;/published&gt;
&lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;accessibility&#39;/&gt;
&lt;summary type=&#39;html&#39;&gt;The accessibility orthodoxy does not permit people to&lt;/p&gt;

&lt;p&gt;question the value of features that are rarely useful and rarely used.&lt;/summary&gt;
&lt;/entry&gt;
&lt;entry&gt;&lt;/p&gt;

&lt;p&gt;&lt;author&gt;&lt;/p&gt;

&lt;p&gt;&lt;name&gt;Mark&lt;/name&gt;
&lt;/author&gt;
&lt;title&gt;A gentle introduction to video encoding, part 1: container formats&lt;/title&gt;
&amp;lt;link rel=&amp;lsquo;alternate&amp;rsquo; type=&amp;lsquo;text/html&amp;rsquo;&lt;/p&gt;

&lt;p&gt;href=&amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats&#39;/&amp;gt;&#34;&gt;http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats&#39;/&amp;gt;&lt;/a&gt;
&lt;id&gt;tag:diveintomark.org,2008-12-18:/archives/20081218155422&lt;/id&gt;
&lt;updated&gt;2009-01-11T19:39:22Z&lt;/updated&gt;
&lt;published&gt;2008-12-18T15:54:22Z&lt;/published&gt;
&lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;asf&#39;/&gt;
&lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;avi&#39;/&gt;
&lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;encoding&#39;/&gt;
&lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;flv&#39;/&gt;
&lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;GIVE&#39;/&gt;
&lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;mp4&#39;/&gt;
&lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;ogg&#39;/&gt;
&lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;video&#39;/&gt;
&lt;summary type=&#39;html&#39;&gt;These notes will eventually become part of a&lt;/p&gt;

&lt;p&gt;tech talk on video encoding.&lt;/summary&gt;
&lt;/entry&gt;
&lt;/feed&gt;&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;12.2. A 5-MINUTE CRASH COURSE IN XML
If you already know about XML, you can skip this section.
XML is a generalized way of describing hierarchical structured data. An XML document contains one or more elements, which are delimited by start and end tags. This is a complete (albeit boring) XML document:
&lt;foo&gt; .
&lt;/foo&gt; .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This is the start tag of the foo element.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is the matching end tag of the foo element. Like balancing parentheses in writing or mathematics or code, every start tag must be closed (matched) by a corresponding end tag.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Elements can be nested to any depth. An element bar inside an element foo is said to be a subelement or child of foo.
&lt;foo&gt;
&lt;bar&gt;&lt;/bar&gt;
&lt;/foo&gt;&lt;/p&gt;

&lt;p&gt;The first element in every XML document is called the root element. An XML document can only have one root element. The following is not an XML document, because it has two root elements:
&lt;foo&gt;&lt;/foo&gt;
&lt;bar&gt;&lt;/bar&gt;&lt;/p&gt;

&lt;p&gt;Elements can have attributes, which are name-value pairs. Attributes are listed within the start tag of an element and separated by whitespace. Attribute names can not be repeated within an element. Attribute values must be quoted. You may use either single or double quotes.
&lt;foo lang=&#39;en&#39;
&gt; .
&lt;bar id=xml-&#39;papayawhip&#39;&gt;lang=&amp;ldquo;fr&amp;rdquo;
&amp;gt;&lt;/bar&gt; .&lt;/p&gt;

&lt;p&gt;&lt;/foo&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The foo element has one attribute, named lang. The value of its lang attribute is en.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The bar element has two attributes, named id and lang. The value of its lang attribute is fr. This doesn’t conflict with the foo element in any way. Each element has its own set of attributes.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If an element has more than one attribute, the ordering of the attributes is not significant. An element’s attributes form an unordered set of keys and values, like a Python dictionary. There is no limit to the number of attributes you can define on each element.
Elements can have text content.
&lt;foo lang=&#39;en&#39;&gt;
&lt;bar lang=&#39;fr&#39;&gt;PapayaWhip
&lt;/bar&gt;
&lt;/foo&gt;&lt;/p&gt;

&lt;p&gt;Elements that contain no text and no children are empty.
&lt;foo&gt;&lt;/foo&gt;&lt;/p&gt;

&lt;p&gt;There is a shorthand for writing empty elements. By putting a / character in the start tag, you can skip the end tag altogther. The XML document in the previous example could be written like this instead:
&lt;foo/
&gt;&lt;/p&gt;

&lt;p&gt;Like Python functions can be declared in different modules, XML elements can be declared in different namespaces. Namespaces usually look like URLs. You use an xmlns declaration to define a default namespace. A namespace declaration looks similar to an attribute, but it has a different purpose.
&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39;
&gt; .
&lt;title&gt;dive into mark&lt;/title&gt; .
&lt;/feed&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The feed element is in the &lt;a href=&#34;http://www.w3.org/2005/Atom&#34;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; namespace.&lt;/li&gt;
&lt;li&gt;The title element is also in the &lt;a href=&#34;http://www.w3.org/2005/Atom&#34;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; namespace. The namespace declaration affects the element where it’s declared, plus all child elements.
You can also use an xmlns:prefix declaration to define a namespace and associate it with a prefix. Then each element in that namespace must be explicitly declared with the prefix.
&lt;atom:feed xmlns:atom=&#39;http://www.w3.org/2005/Atom&#39;
&gt; .
&lt;a href=&#34;atom:title&#34;&gt;atom:title&lt;/a&gt;dive into mark&lt;a href=&#34;https://harryho.github.io/atom:title&#34;&gt;/atom:title&lt;/a&gt; .&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;https://harryho.github.io/atom:feed&#34;&gt;/atom:feed&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The feed element is in the &lt;a href=&#34;http://www.w3.org/2005/Atom&#34;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; namespace.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The title element is also in the &lt;a href=&#34;http://www.w3.org/2005/Atom&#34;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; namespace.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As far as an XML parser is concerned, the previous two XML documents are identical. Namespace + element name = XML identity. Prefixes only exist to refer to namespaces, so the actual prefix name (atom:) is irrelevant. The namespaces match, the element names match, the attributes (or lack of attributes) match, and each element’s text content matches, therefore the XML documents are the same.
Finally, XML documents can contain character
encoding
information
on the first line, before the root element. (If you’re curious how a document can contain information which needs to be known before the document can be parsed, Section
F
of
the
XML
specification
details how to resolve this Catch-22.)
&amp;lt;?xml version=&amp;lsquo;1.0&amp;rsquo; encoding=&amp;lsquo;utf-8&amp;rsquo;
?&amp;gt;&lt;/p&gt;

&lt;p&gt;And now you know just enough XML to be dangerous!
.&lt;/p&gt;

&lt;p&gt;12.3. THE STRUCTURE OF AN ATOM FEED
Think of a weblog, or in fact any website with frequently updated content, like CNN.com. The site itself has a title (“CNN.com”), a subtitle (“Breaking News, U.S., World, Weather, Entertainment &amp;amp;Video News”), a last-updated date (“updated 12:43 p.m. EDT, Sat May 16, 2009”), and a list of articles posted at different times. Each article also has a title, a first-published date (and maybe also a last-updated date, if they published a correction or fixed a typo), and a unique URL.
The Atom syndication format is designed to capture all of this information in a standard format. My weblog and CNN.com are wildly different in design, scope, and audience, but they both have the same basic structure. CNN.com has a title; my blog has a title. CNN.com publishes articles; I publish articles.
At the top level is the root element, which every Atom feed shares: the feed element in the
&lt;a href=&#34;http://www.w3.org/2005/Atom&#34;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; namespace.&lt;/p&gt;

&lt;p&gt;&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; . 
xml:lang=&#39;en&#39;&gt; .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3.org/2005/Atom&#34;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; is the Atom namespace.&lt;/li&gt;
&lt;li&gt;Any element can contain an xml:lang attribute, which declares the language of the element and its children. In this case, the xml:lang attribute is declared once on the root element, which means the entire feed is in English.
An Atom feed contains several pieces of information about the feed itself. These are declared as children of the root-level feed element.
&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;&gt; &lt;title&gt;dive into mark&lt;/title&gt; . &lt;subtitle&gt;currently between addictions&lt;/subtitle&gt; . &lt;id&gt;tag:diveintomark.org,2001-07-29:/&lt;/id&gt; . &lt;updated&gt;2009-03-27T21:56:07Z&lt;/updated&gt; . &lt;link rel=&#39;alternate&#39; type=&#39;text/html&#39; href=&#39;http://diveintomark.org/&#39;/&gt; .&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The title of this feed is dive into mark.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The subtitle of this feed is currently between addictions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Every feed needs a globally unique identifier. See RFC
4151
for how to create one.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This feed was last updated on March 27, 2009, at 21:56 GMT. This is usually equivalent to the last-modified date of the most recent article.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now things start to get interesting. This link element has no text content, but it has three attributes: rel, type, and href. The rel value tells you what kind of link this is; rel=&amp;lsquo;alternate&amp;rsquo; means that this is a link to an alternate representation of this feed. The type=&amp;lsquo;text/html&amp;rsquo; attribute means that this is a link to an HTML page. And the link target is given in the href attribute.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now we know that this is a feed for a site named “dive into mark“ which is available at
&lt;a href=&#34;http://diveintomark.org/&#34;&gt;http://diveintomark.org/&lt;/a&gt; and was last updated on March 27, 2009.
. Although the order of elements can be relevant in some XML documents, it is not
relevant in an Atom feed.
After the feed-level metadata is the list of the most recent articles. An article looks like this:
&lt;entry&gt;&lt;/p&gt;

&lt;p&gt;&lt;author&gt; . &lt;name&gt;Mark&lt;/name&gt; &lt;uri&gt;&lt;a href=&#34;http://diveintomark.org/&#34;&gt;http://diveintomark.org/&lt;/a&gt;&lt;/uri&gt;
&lt;/author&gt;
&lt;title&gt;Dive into history, 2009 edition&lt;/title&gt; .
&amp;lt;link rel=&amp;lsquo;alternate&amp;rsquo; type=&amp;lsquo;text/html&amp;rsquo; .&lt;/p&gt;

&lt;p&gt;href=&amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;/&amp;gt;&#34;&gt;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;/&amp;gt;&lt;/a&gt; &lt;id&gt;tag:diveintomark.org,2009-03-27:/archives/20090327172042&lt;/id&gt; . &lt;updated&gt;2009-03-27T21:56:07Z&lt;/updated&gt; . &lt;published&gt;2009-03-27T17:20:42Z&lt;/published&gt; &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;diveintopython&#39;/&gt; . &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;docbook&#39;/&gt; &lt;category scheme=&#39;http://diveintomark.org&#39; term=&#39;html&#39;/&gt; &lt;summary type=&#39;html&#39;&gt;Putting an entire chapter on one page sounds .
bloated, but consider this &amp;amp;mdash; my longest chapter so far
would be 75 printed pages, and it loads in under 5 seconds&amp;amp;hellip;
On dialup.&lt;/summary&gt;&lt;/p&gt;

&lt;p&gt;&lt;/entry&gt;    .
1.  The author element tells who wrote this article: some guy named Mark, whom you can find loafing at &lt;a href=&#34;http://diveintomark.org/&#34;&gt;http://diveintomark.org/&lt;/a&gt;. (This is the same as the alternate link in the feed metadata, but it doesn’t have to be. Many weblogs have multiple authors, each with their own personal website.)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The title element gives the title of the article, “Dive into history, 2009 edition”.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As with the feed-level alternate link, this link element gives the address of the HTML version of this article.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Entries, like feeds, need a unique identifier.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Entries have two dates: a first-published date (published) and a last-modified date (updated).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Entries can have an arbitrary number of categories. This article is filed under diveintopython, docbook, and html.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The summary element gives a brief summary of the article. (There is also a content element, not shown here, if you want to include the complete article text in your feed.) This summary element has the Atom-specific type=&amp;lsquo;html&amp;rsquo; attribute, which specifies that this summary is a snippet of HTML, not plain text. This is important, since it has HTML-specific entities in it (&amp;mdash; and &amp;hellip;) which should be rendered as “—” and “…” rather than displayed directly.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, the end tag for the entry element, signaling the end of the metadata for this article.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;12.4. PARSING XML
Python can parse XML documents in several ways. It has traditional DOM
and SAX
parsers, but I will focus on a different library called ElementTree.
&amp;gt;&amp;gt;&amp;gt; import xml.etree.ElementTree as etree .
&amp;gt;&amp;gt;&amp;gt; tree = etree.parse(&amp;lsquo;examples/feed.xml&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; root = tree.getroot() .
&amp;gt;&amp;gt;&amp;gt; root .
&lt;Element {http://www.w3.org/2005/Atom}feed at cd1eb0&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The ElementTree library is part of the Python standard library, in xml.etree.ElementTree.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The primary entry point for the ElementTree library is the parse() function, which can take a filename or a file-like
object. This function parses the entire document at once. If memory is tight, there are ways to parse
an
XML
document
incrementally
instead.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The parse() function returns an object which represents the entire document. This is not the root element. To get a reference to the root element, call the getroot() method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As expected, the root element is the feed element in the &lt;a href=&#34;http://www.w3.org/2005/Atom&#34;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; namespace. The string representation of this object reinforces an important point: an XML element is a combination of its namespace and its tag name (also called the local name). Every element in this document is in the Atom namespace, so the root element is represented as {&lt;a href=&#34;http://www.w3.org/2005/Atom}feed&#34;&gt;http://www.w3.org/2005/Atom}feed&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. ElementTree represents XML elements as {namespace}localname. You’ll see and use this format in multiple places in the ElementTree API.
12.4.1. ELEMENTS ARE LISTS
In the ElementTree API, an element acts like a list. The items of the list are the element’s children.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-8:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;root.tag .
&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}feed&#39;&#34;&gt;http://www.w3.org/2005/Atom}feed&#39;&lt;/a&gt;
len(root) .
8
for child in root: .
&amp;hellip; print(child) .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;Element {http://www.w3.org/2005/Atom}title at e2b5d0&gt;
&lt;Element {http://www.w3.org/2005/Atom}subtitle at e2b4e0&gt;
&lt;Element {http://www.w3.org/2005/Atom}id at e2b6c0&gt;
&lt;Element {http://www.w3.org/2005/Atom}updated at e2b6f0&gt;
&lt;Element {http://www.w3.org/2005/Atom}link at e2b4b0&gt;
&lt;Element {http://www.w3.org/2005/Atom}entry at e2b720&gt;
&lt;Element {http://www.w3.org/2005/Atom}entry at e2b510&gt;
&lt;Element {http://www.w3.org/2005/Atom}entry at e2b750&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Continuing from the previous example, the root element is {&lt;a href=&#34;http://www.w3.org/2005/Atom}feed&#34;&gt;http://www.w3.org/2005/Atom}feed&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The “length” of the root element is the number of child elements.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can use the element itself as an iterator to loop through all of its child elements.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As you can see from the output, there are indeed 8 child elements: all of the feed-level metadata (title, subtitle, id, updated, and link) followed by the three entry elements.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You may have guessed this already, but I want to point it out explicitly: the list of child elements only includes direct children. Each of the entry elements contain their own children, but those are not included in the list. They would be included in the list of each entry’s children, but they are not included in the list of the feed’s children. There are ways to find elements no matter how deeply nested they are; we’ll look at two such ways later in this chapter.&lt;/p&gt;

&lt;p&gt;12.4.2. ATTRIBUTES ARE DICTONARIES
XML isn’t just a collection of elements; each element can also have its own set of attributes. Once you have a reference to a specific element, you can easily get its attributes as a Python dictionary.&lt;/p&gt;

&lt;h1 id=&#34;continuing-from-the-previous-example:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continuing from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;root.attrib .
{&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/XML/1998/namespace}lang&#39;:&#34;&gt;http://www.w3.org/XML/1998/namespace}lang&#39;:&lt;/a&gt; &amp;lsquo;en&amp;rsquo;}
root[4] .
&lt;Element {http://www.w3.org/2005/Atom}link at e181b0&gt;
root[4].attrib .
{&amp;lsquo;href&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintomark.org/&#39;&#34;&gt;http://diveintomark.org/&#39;&lt;/a&gt;,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;lsquo;type&amp;rsquo;: &amp;lsquo;text/html&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;rel&amp;rsquo;: &amp;lsquo;alternate&amp;rsquo;}
&amp;gt;&amp;gt;&amp;gt; root[3] .
&lt;Element {http://www.w3.org/2005/Atom}updated at e2b4e0&gt;
&amp;gt;&amp;gt;&amp;gt; root[3].attrib .
{}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The attrib property is a dictionary of the element’s attributes. The original markup here was &lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;&gt;. The xml: prefix refers to a built-in namespace that every XML document can use without declaring it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The fifth child — [4] in a 0-based list — is the link element.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The link element has three attributes: href, type, and rel.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The fourth child — [3] in a 0-based list — is the updated element.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The updated element has no attributes, so its .attrib is just an empty dictionary.
.
12.5. SEARCHING FOR NODES WITHIN AN XML DOCUMENT
So far, we’ve worked with this XML document “from the top down,” starting with the root element, getting its child elements, and so on throughout the document. But many uses of XML require you to find specific elements. Etree can do that, too.
&amp;gt;&amp;gt;&amp;gt; import xml.etree.ElementTree as etree
&amp;gt;&amp;gt;&amp;gt; tree = etree.parse(&amp;lsquo;examples/feed.xml&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; root = tree.getroot()
&amp;gt;&amp;gt;&amp;gt; root.findall(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}entry&#39;&#34;&gt;http://www.w3.org/2005/Atom}entry&#39;&lt;/a&gt;) .
[&lt;Element {http://www.w3.org/2005/Atom}entry at e2b4e0&gt;,&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;Element {http://www.w3.org/2005/Atom}entry at e2b510&gt;,&lt;/p&gt;

&lt;p&gt;&lt;Element {http://www.w3.org/2005/Atom}entry at e2b540&gt;]
&amp;gt;&amp;gt;&amp;gt; root.tag
&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}feed&#39;&#34;&gt;http://www.w3.org/2005/Atom}feed&#39;&lt;/a&gt;
&amp;gt;&amp;gt;&amp;gt; root.findall(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}feed&#39;&#34;&gt;http://www.w3.org/2005/Atom}feed&#39;&lt;/a&gt;) .
[]
&amp;gt;&amp;gt;&amp;gt; root.findall(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}author&#39;&#34;&gt;http://www.w3.org/2005/Atom}author&#39;&lt;/a&gt;) .
[]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The findall() method finds child elements that match a specific query. (More on the query format in a minute.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Each element — including the root element, but also child elements — has a findall() method. It finds all matching elements among the element’s children. But why aren’t there any results? Although it may not be obvious, this particular query only searches the element’s children. Since the root feed element has no child named feed, this query returns an empty list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This result may also surprise you. There
is
an
author element
in this document; in fact, there are three (one in each entry). But those author elements are not direct children of the root element; they are&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;“grandchildren” (literally, a child element of a child element). If you want to look for author elements at any nesting level, you can do that, but the query format is slightly different.
&amp;gt;&amp;gt;&amp;gt; tree.findall(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}entry&#39;&#34;&gt;http://www.w3.org/2005/Atom}entry&#39;&lt;/a&gt;) .
[&lt;Element {http://www.w3.org/2005/Atom}entry at e2b4e0&gt;,
&lt;Element {http://www.w3.org/2005/Atom}entry at e2b510&gt;,
&lt;Element {http://www.w3.org/2005/Atom}entry at e2b540&gt;]&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;tree.findall(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}author&#39;&#34;&gt;http://www.w3.org/2005/Atom}author&#39;&lt;/a&gt;) .
[]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;For convenience, the tree object (returned from the etree.parse() function) has several methods that mirror the methods on the root element. The results are the same as if you had called the tree.getroot().findall() method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perhaps surprisingly, this query does not find the author elements in this document. Why not? Because this is just a shortcut for tree.getroot().findall(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}author&#39;&#34;&gt;http://www.w3.org/2005/Atom}author&#39;&lt;/a&gt;), which means “find all the author elements that are children of the root element.” The author elements are not children of the root element; they’re children of the entry elements. Thus the query doesn’t return any matches.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There is also a find() method which returns the first matching element. This is useful for situations where you are only expecting one match, or if there are multiple matches, you only care about the first one.
&amp;gt;&amp;gt;&amp;gt; entries = tree.findall(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}entry&#39;&#34;&gt;http://www.w3.org/2005/Atom}entry&#39;&lt;/a&gt;) .
&amp;gt;&amp;gt;&amp;gt; len(entries)
3
&amp;gt;&amp;gt;&amp;gt; title_element = entries[0].find(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}title&#39;&#34;&gt;http://www.w3.org/2005/Atom}title&#39;&lt;/a&gt;) .
&amp;gt;&amp;gt;&amp;gt; title_element.text
&amp;lsquo;Dive into history, 2009 edition&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; foo_element = entries[0].find(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}foo&#39;&#34;&gt;http://www.w3.org/2005/Atom}foo&#39;&lt;/a&gt;) .
&amp;gt;&amp;gt;&amp;gt; foo_element
&amp;gt;&amp;gt;&amp;gt; type(foo_element)
&lt;class &#39;NoneType&#39;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You saw this in the previous example. It finds all the atom:entry elements.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The find() method takes an ElementTree query and returns the first matching element.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There are no elements in this entry named foo, so this returns None.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. There is a “gotcha” with the find() method that will eventually bite you. In a
boolean context, ElementTree element objects will evaluate to False if they contain
no children (i.e. if len(element) is 0). This means that if element.find(&amp;lsquo;&amp;hellip;&amp;rsquo;) is
not testing whether the find() method found a matching element; it’s testing
whether that matching element has any child elements! To test whether the find()
method returned an element, use if element.find(&amp;lsquo;&amp;hellip;&amp;rsquo;) is not None.&lt;/p&gt;

&lt;p&gt;There is a way to search for descendant elements, i.e. children, grandchildren, and any element at any nesting level.
&amp;gt;&amp;gt;&amp;gt; all_links = tree.findall(&amp;lsquo;//{&lt;a href=&#34;http://www.w3.org/2005/Atom}link&#39;&#34;&gt;http://www.w3.org/2005/Atom}link&#39;&lt;/a&gt;) .
&amp;gt;&amp;gt;&amp;gt; all_links
[&lt;Element {http://www.w3.org/2005/Atom}link at e181b0&gt;,&lt;/p&gt;

&lt;p&gt;&lt;Element {http://www.w3.org/2005/Atom}link at e2b570&gt;,
&lt;Element {http://www.w3.org/2005/Atom}link at e2b480&gt;,
&lt;Element {http://www.w3.org/2005/Atom}link at e2b5a0&gt;]&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;all_links[0].attrib     .
{&amp;lsquo;href&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintomark.org/&#39;&#34;&gt;http://diveintomark.org/&#39;&lt;/a&gt;,
&amp;lsquo;type&amp;rsquo;: &amp;lsquo;text/html&amp;rsquo;,
&amp;lsquo;rel&amp;rsquo;: &amp;lsquo;alternate&amp;rsquo;}&lt;/p&gt;

&lt;p&gt;all_links[1].attrib     .
{&amp;lsquo;href&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&#34;&gt;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&lt;/a&gt;,
&amp;lsquo;type&amp;rsquo;: &amp;lsquo;text/html&amp;rsquo;,
&amp;lsquo;rel&amp;rsquo;: &amp;lsquo;alternate&amp;rsquo;}&lt;/p&gt;

&lt;p&gt;all_links[2].attrib&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;{&amp;lsquo;href&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress&#39;&#34;&gt;http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress&#39;&lt;/a&gt;,
&amp;lsquo;type&amp;rsquo;: &amp;lsquo;text/html&amp;rsquo;,
&amp;lsquo;rel&amp;rsquo;: &amp;lsquo;alternate&amp;rsquo;}&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;all_links[3].attrib&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;{&amp;lsquo;href&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats&#39;&#34;&gt;http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats&#39;&lt;/a&gt;,
&amp;lsquo;type&amp;rsquo;: &amp;lsquo;text/html&amp;rsquo;,
&amp;lsquo;rel&amp;rsquo;: &amp;lsquo;alternate&amp;rsquo;}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This query — //{&lt;a href=&#34;http://www.w3.org/2005/Atom}link&#34;&gt;http://www.w3.org/2005/Atom}link&lt;/a&gt; — is very similar to the previous examples, except for the two slashes at the beginning of the query. Those two slashes mean “don’t just look for direct children; I want any elements, regardless of nesting level.” So the result is a list of four link elements, not just one.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The first result is a direct child of the root element. As you can see from its attributes, this is the feed-level alternate link that points to the HTML version of the website that the feed describes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The other three results are each entry-level alternate links. Each entry has a single link child element, and because of the double slash at the beginning of the query, this query finds all of them.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Overall, ElementTree’s findall() method is a very powerful feature, but the query language can be a bit surprising. It is officially described as “limited
support
for
XPath
expressions.” XPath
is a W3C standard for querying XML documents. ElementTree’s query language is similar enough to XPath to do basic searching, but dissimilar enough that it may annoy you if you already know XPath. Now let’s look at a third-party XML library that extends the ElementTree API with full XPath support.
.
12.6. GOING FURTHER WITH LXML
lxml is an open source third-party library that builds on the popular libxml2
parser. It provides a 100% compatible ElementTree API, then extends it with full XPath 1.0 support and a few other niceties. There are installers
available
for
Windows; Linux users should always try to use distribution-specific tools like yum or apt-get to install precompiled binaries from their repositories. Otherwise you’ll need to install
lxml manually.
&amp;gt;&amp;gt;&amp;gt; from lxml import etree .
&amp;gt;&amp;gt;&amp;gt; tree = etree.parse(&amp;lsquo;examples/feed.xml&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; root = tree.getroot() .
&amp;gt;&amp;gt;&amp;gt; root.findall(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}entry&#39;&#34;&gt;http://www.w3.org/2005/Atom}entry&#39;&lt;/a&gt;) .
[&lt;Element {http://www.w3.org/2005/Atom}entry at e2b4e0&gt;,&lt;/p&gt;

&lt;p&gt;&lt;Element {http://www.w3.org/2005/Atom}entry at e2b510&gt;,&lt;/p&gt;

&lt;p&gt;&lt;Element {http://www.w3.org/2005/Atom}entry at e2b540&gt;]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Once imported, lxml provides the same API as the built-in ElementTree library.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;parse() function: same as ElementTree.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getroot() method: also the same.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;findall() method: exactly the same.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For large XML documents, lxml is significantly faster than the built-in ElementTree library. If you’re only using the ElementTree API and want to use the fastest available implementation, you can try to import lxml and fall back to the built-in ElementTree.
try:&lt;/p&gt;

&lt;p&gt;from lxml import etree
except ImportError:
import xml.etree.ElementTree as etree&lt;/p&gt;

&lt;p&gt;But lxml is more than just a faster ElementTree. Its findall() method includes support for more
complicated expressions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import lxml.etree . &amp;gt;&amp;gt;&amp;gt; tree = lxml.etree.parse(&amp;lsquo;examples/feed.xml&amp;rsquo;) &amp;gt;&amp;gt;&amp;gt; tree.findall(&amp;lsquo;//{&lt;a href=&#34;http://www.w3.org/2005/Atom}*[@href]&#39;&#34;&gt;http://www.w3.org/2005/Atom}*[@href]&#39;&lt;/a&gt;) . [&lt;Element {http://www.w3.org/2005/Atom}link at eeb8a0&gt;,
&lt;Element {http://www.w3.org/2005/Atom}link at eeb990&gt;,
&lt;Element {http://www.w3.org/2005/Atom}link at eeb960&gt;,
&lt;Element {http://www.w3.org/2005/Atom}link at eeb9c0&gt;]&lt;/p&gt;

&lt;p&gt;tree.findall(&amp;ldquo;//{&lt;a href=&#34;http://www.w3.org/2005/Atom}*[@href=&#39;http://diveintomark.org/&#39;]&amp;quot;&#34;&gt;http://www.w3.org/2005/Atom}*[@href=&#39;http://diveintomark.org/&#39;]&amp;quot;&lt;/a&gt;) .
[&lt;Element {http://www.w3.org/2005/Atom}link at eeb930&gt;]
NS = &amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}&#39;&#34;&gt;http://www.w3.org/2005/Atom}&#39;&lt;/a&gt;
tree.findall(&amp;lsquo;//{NS}author[{NS}uri]&amp;lsquo;.format(NS=NS)) .
[&lt;Element {http://www.w3.org/2005/Atom}author at eeba80&gt;,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;Element {http://www.w3.org/2005/Atom}author at eebba0&gt;]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In this example, I’m going to import lxml.etree (instead of, say, from lxml import etree), to emphasize that these features are specific to lxml.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This query finds all elements in the Atom namespace, anywhere in the document, that have an href attribute. The // at the beginning of the query means “elements anywhere (not just as children of the root element).” {&lt;a href=&#34;http://www.w3.org/2005/Atom&#34;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;} means “only elements in the Atom namespace.” * means “elements with any local name.” And [@href] means “has an href attribute.”&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The query finds all Atom elements with an href whose value is &lt;a href=&#34;http://diveintomark.org/&#34;&gt;http://diveintomark.org/&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After doing some quick string
formatting
(because otherwise these compound queries get ridiculously long), this query searches for Atom author elements that have an Atom uri element as a child. This only returns two author elements, the ones in the first and second entry. The author in the last entry contains only a name, not a uri.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Not enough for you? lxml also integrates support for arbitrary XPath 1.0 expressions. I’m not going to go into depth about XPath syntax; that could be a whole book unto itself! But I will show you how it integrates into lxml.
&amp;gt;&amp;gt;&amp;gt; import lxml.etree
&amp;gt;&amp;gt;&amp;gt; tree = lxml.etree.parse(&amp;lsquo;examples/feed.xml&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; NSMAP = {&amp;lsquo;atom&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://www.w3.org/2005/Atom&#39;&#34;&gt;http://www.w3.org/2005/Atom&#39;&lt;/a&gt;} .
&amp;gt;&amp;gt;&amp;gt; entries = tree.xpath(&amp;ldquo;//atom:category[@term=&amp;lsquo;accessibility&amp;rsquo;]/..&amp;ldquo;, .
&amp;hellip; namespaces=NSMAP)
&amp;gt;&amp;gt;&amp;gt; entries .
[&lt;Element {http://www.w3.org/2005/Atom}entry at e2b630&gt;]
&amp;gt;&amp;gt;&amp;gt; entry = entries[0]
&amp;gt;&amp;gt;&amp;gt; entry.xpath(&amp;lsquo;./atom:title/text()&amp;lsquo;, namespaces=NSMAP) .
[&amp;lsquo;Accessibility is a harsh mistress&amp;rsquo;]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To perform XPath queries on namespaced elements, you need to define a namespace prefix mapping. This is just a Python dictionary.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Here is an XPath query. The XPath expression searches for category elements (in the Atom namespace) that contain a term attribute with the value accessibility. But that’s not actually the query result. Look at the very end of the query string; did you notice the /.. bit? That means “and then return the parent element of the category element you just found.” So this single XPath query will find all entries with a child element of &lt;category term=&#39;accessibility&#39;&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The xpath() function returns a list of ElementTree objects. In this document, there is only one entry with a category whose term is accessibility.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;XPath expressions don’t always return a list of elements. Technically, the DOM of a parsed XML document doesn’t contain elements; it contains nodes. Depending on their type, nodes can be elements, attributes, or even text content. The result of an XPath query is a list of nodes. This query returns a list of text nodes: the text content (text()) of the title element (atom:title) that is a child of the current element (./).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;12.7. GENERATING XML&lt;/p&gt;

&lt;p&gt;Python’s support for XML is not limited to parsing existing documents. You can also create XML documents from scratch.
&amp;gt;&amp;gt;&amp;gt; import xml.etree.ElementTree as etree
&amp;gt;&amp;gt;&amp;gt; new_feed = etree.Element(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}feed&#39;&#34;&gt;http://www.w3.org/2005/Atom}feed&#39;&lt;/a&gt;, .
&amp;hellip; attrib={&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/XML/1998/namespace}lang&#39;:&#34;&gt;http://www.w3.org/XML/1998/namespace}lang&#39;:&lt;/a&gt; &amp;lsquo;en&amp;rsquo;}) .
&amp;gt;&amp;gt;&amp;gt; print(etree.tostring(new_feed)) .
&lt;ns0:feed xmlns:ns0=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;/&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To create a new element, instantiate the Element class. You pass the element name (namespace + local name) as the first argument. This statement creates a feed element in the Atom namespace. This will be our new document’s root element.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To add attributes to the newly created element, pass a dictionary of attribute names and values in the attrib argument. Note that the attribute name should be in the standard ElementTree format, {namespace}localname.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;At any time, you can serialize any element (and its children) with the ElementTree tostring() function.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Was that serialization surprising to you? The way ElementTree serializes namespaced XML elements is technically accurate but not optimal. The sample XML document at the beginning of this chapter defined a default namespace (xmlns=&amp;lsquo;&lt;a href=&#34;http://www.w3.org/2005/Atom&#39;&#34;&gt;http://www.w3.org/2005/Atom&#39;&lt;/a&gt;). Defining a default namespace is useful for documents — like Atom feeds — where every element is in the same namespace, because you can declare the namespace once and declare each element with just its local name (&lt;feed&gt;, &lt;link&gt;, &lt;entry&gt;). There is no need to use any prefixes unless you want to declare elements from another namespace.
An XML parser won’t “see” any difference between an XML document with a default namespace and an XML document with a prefixed namespace. The resulting DOM of this serialization:
&lt;ns0:feed xmlns:ns0=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;/&gt;&lt;/p&gt;

&lt;p&gt;is identical to the DOM of this serialization:
&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;/&gt;&lt;/p&gt;

&lt;p&gt;The only practical difference is that the second serialization is several characters shorter. If we were to recast our entire sample feed with a ns0: prefix in every start and end tag, it would add 4 characters per start tag × 79 tags + 4 characters for the namespace declaration itself, for a total of 320 characters. Assuming UTF-8
encoding, that’s 320 extra bytes. (After gzipping, the difference drops to 21 bytes, but still, 21 bytes is 21 bytes.) Maybe that doesn’t matter to you, but for something like an Atom feed, which may be downloaded several thousand times whenever it changes, saving a few bytes per request can quickly add up.
The built-in ElementTree library does not offer this fine-grained control over serializing namespaced
elements, but lxml does.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import lxml.etree
NSMAP = {None: &amp;lsquo;&lt;a href=&#34;http://www.w3.org/2005/Atom&#39;&#34;&gt;http://www.w3.org/2005/Atom&#39;&lt;/a&gt;} .
new_feed = lxml.etree.Element(&amp;lsquo;feed&amp;rsquo;, nsmap=NSMAP) .
print(lxml.etree.tounicode(new_feed)) .
&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39;/&gt;
new_feed.set(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/XML/1998/namespace}lang&#39;&#34;&gt;http://www.w3.org/XML/1998/namespace}lang&#39;&lt;/a&gt;, &amp;lsquo;en&amp;rsquo;) .
print(lxml.etree.tounicode(new_feed))
&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To start, define a namespace mapping as a dictionary. Dictionary values are namespaces; dictionary keys are the desired prefix. Using None as a prefix effectively declares a default namespace.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now you can pass the lxml-specific nsmap argument when you create an element, and lxml will respect the namespace prefixes you’ve defined.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As expected, this serialization defines the Atom namespace as the default namespace and declares the feed element without a namespace prefix.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Oops, we forgot to add the xml:lang attribute. You can always add attributes to any element with the set() method. It takes two arguments: the attribute name in standard ElementTree format, then the attribute value. (This method is not lxml-specific. The only lxml-specific part of this example was the nsmap argument to control the namespace prefixes in the serialized output.)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Are XML documents limited to one element per document? No, of course not. You can easily create child elements, too.
&amp;gt;&amp;gt;&amp;gt; title = lxml.etree.SubElement(new_feed, &amp;lsquo;title&amp;rsquo;, .
&amp;hellip; attrib={&amp;lsquo;type&amp;rsquo;:&amp;lsquo;html&amp;rsquo;}) .
&amp;gt;&amp;gt;&amp;gt; print(lxml.etree.tounicode(new_feed)) .
&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;&gt;&lt;title type=&#39;html&#39;/&gt;&lt;/feed&gt;
&amp;gt;&amp;gt;&amp;gt; title.text = &amp;lsquo;dive into &amp;hellip;&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; print(lxml.etree.tounicode(new_feed)) .
&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;&gt;&lt;title type=&#39;html&#39;&gt;dive into &amp;amp;hellip;&lt;/title&gt;&lt;/feed&gt;
&amp;gt;&amp;gt;&amp;gt; print(lxml.etree.tounicode(new_feed, pretty_print=True)) .
&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;&gt;
&lt;title type=&#39;html&#39;&gt;dive into&amp;amp;hellip;&lt;/title&gt;
&lt;/feed&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To create a child element of an existing element, instantiate the SubElement class. The only required arguments are the parent element (new_feed in this case) and the new element’s name. Since this child element will inherit the namespace mapping of its parent, there is no need to redeclare the namespace or prefix here.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can also pass in an attribute dictionary. Keys are attribute names; values are attribute values.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As expected, the new title element was created in the Atom namespace, and it was inserted as a child of the feed element. Since the title element has no text content and no children of its own, lxml serializes it as an empty element (with the /&amp;gt; shortcut).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To set the text content of an element, simply set its .text property.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now the title element is serialized with its text content. Any text content that contains less-than signs or ampersands needs to be escaped when serialized. lxml handles this escaping automatically.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can also apply “pretty printing” to the serialization, which inserts line breaks after end tags, and after start tags of elements that contain child elements but no text content. In technical terms, lxml adds “insignificant whitespace” to make the output more readable.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. You might also want to check out xmlwitch, another third-party library for generating XML. It makes extensive use of the
with statement
to make XML generation code more readable.
.&lt;/p&gt;

&lt;p&gt;12.8. PARSING BROKEN XML&lt;/p&gt;

&lt;p&gt;The XML specification mandates that all conforming XML parsers employ “draconian error handling.” That is, they must halt and catch fire as soon as they detect any sort of wellformedness error in the XML document. Wellformedness errors include mismatched start and end tags, undefined entities, illegal Unicode characters, and a number of other esoteric rules. This is in stark contrast to other common formats like HTML — your browser doesn’t stop rendering a web page if you forget to close an HTML tag or escape an ampersand in an attribute value. (It is a common misconception that HTML has no defined error handling. HTML
error
handling
is actually quite well-defined, but it’s significantly more complicated than “halt and catch fire on first error.”)
Some people (myself included) believe that it was a mistake for the inventors of XML to mandate draconian error handling. Don’t get me wrong; I can certainly see the allure of simplifying the error handling rules. But in practice, the concept of “wellformedness” is trickier than it sounds, especially for XML documents (like Atom feeds) that are published on the web and served over HTTP. Despite the maturity of XML, which standardized on draconian error handling in 1997, surveys continually show a significant fraction of Atom feeds on the web are plagued with wellformedness errors.
So, I have both theoretical and practical reasons to parse XML documents “at any cost,” that is, not to halt and catch fire at the first wellformedness error. If you find yourself wanting to do this too, lxml can help.
Here is a fragment of a broken XML document. I’ve highlighted the wellformedness error.
&amp;lt;?xml version=&amp;lsquo;1.0&amp;rsquo; encoding=&amp;lsquo;utf-8&amp;rsquo;?&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;&gt;&lt;/p&gt;

&lt;p&gt;&lt;title&gt;dive into &amp;hellip;
&lt;/title&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/feed&gt;&lt;/p&gt;

&lt;p&gt;That’s an error, because the &amp;hellip; entity is not defined in XML. (It is defined in HTML.) If you try to parse this broken feed with the default settings, lxml will choke on the undefined entity.
&amp;gt;&amp;gt;&amp;gt; import lxml.etree&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;tree = lxml.etree.parse(&amp;lsquo;examples/feed-broken.xml&amp;rsquo;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;lxml.etree.pyx&amp;rdquo;, line 2693, in lxml.etree.parse (src/lxml/lxml.etree.c:52591)&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;parser.pxi&amp;rdquo;, line 1478, in lxml.etree._parseDocument (src/lxml/lxml.etree.c:75665)&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;parser.pxi&amp;rdquo;, line 1507, in lxml.etree._parseDocumentFromURL (src/lxml/lxml.etree.c:75993)&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;parser.pxi&amp;rdquo;, line 1407, in lxml.etree._parseDocFromFile (src/lxml/lxml.etree.c:75002)&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;parser.pxi&amp;rdquo;, line 965, in lxml.etree._BaseParser._parseDocFromFile (src/lxml/lxml.etree.c:72023)&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;parser.pxi&amp;rdquo;, line 539, in lxml.etree._ParserContext._handleParseResultDoc (src/lxml/lxml.etree.c:67830)&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;parser.pxi&amp;rdquo;, line 625, in lxml.etree._handleParseResult (src/lxml/lxml.etree.c:68877)&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;parser.pxi&amp;rdquo;, line 565, in lxml.etree._raiseParseError (src/lxml/lxml.etree.c:68125)&lt;/p&gt;

&lt;p&gt;lxml.etree.XMLSyntaxError: Entity &amp;lsquo;hellip&amp;rsquo; not defined, line 3, column 28&lt;/p&gt;

&lt;p&gt;To parse this broken XML document, despite its wellformedness error, you need to create a custom XML parser.
&amp;gt;&amp;gt;&amp;gt; parser = lxml.etree.XMLParser(recover=True) .
&amp;gt;&amp;gt;&amp;gt; tree = lxml.etree.parse(&amp;lsquo;examples/feed-broken.xml&amp;rsquo;, parser) .
&amp;gt;&amp;gt;&amp;gt; parser.error_log .
examples/feed-broken.xml:3:28:FATAL:PARSER:ERR_UNDECLARED_ENTITY: Entity &amp;lsquo;hellip&amp;rsquo; not defined&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;tree.findall(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}title&#39;&#34;&gt;http://www.w3.org/2005/Atom}title&#39;&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;[&lt;Element {http://www.w3.org/2005/Atom}title at ead510&gt;]&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;title = tree.findall(&amp;lsquo;{&lt;a href=&#34;http://www.w3.org/2005/Atom}title&#39;)[0&#34;&gt;http://www.w3.org/2005/Atom}title&#39;)[0&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;title.text .
&amp;lsquo;dive into &amp;lsquo;&lt;/p&gt;

&lt;p&gt;print(lxml.etree.tounicode(tree.getroot())) .
&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;title&gt;dive into &lt;/title&gt;&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;. [rest of serialization snipped for brevity]&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To create a custom parser, instantiate the lxml.etree.XMLParser class. It can take a
number
of
different
named
arguments. The one we’re interested in here is the recover argument. When set to True, the XML parser will try its best to “recover” from wellformedness errors.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To parse an XML document with your custom parser, pass the parser object as the second argument to the parse() function. Note that lxml does not raise an exception about the undefined &amp;hellip; entity.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The parser keeps a log of the wellformedness errors that it has encountered. (This is actually true regardless of whether it is set to recover from those errors or not.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Since it didn’t know what to do with the undefined &amp;hellip; entity, the parser just silently dropped it. The text content of the title element becomes &amp;lsquo;dive into &amp;lsquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As you can see from the serialization, the &amp;hellip; entity didn’t get moved; it was simply dropped.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It is important to reiterate that there is no guarantee of interoperability with “recovering” XML parsers. A different parser might decide that it recognized the &amp;hellip; entity from HTML, and replace it with &amp;amp;hellip; instead. Is that “better”? Maybe. Is it “more correct”? No, they are both equally incorrect. The correct behavior (according to the XML specification) is to halt and catch fire. If you’ve decided not to do that, you’re on your own.
.&lt;/p&gt;

&lt;p&gt;12.9. FURTHER READING
•   XML
on
Wikipedia.org&lt;/p&gt;

&lt;p&gt;•   The
ElementTree
XML
API&lt;/p&gt;

&lt;p&gt;•   Elements
and
Element
Trees&lt;/p&gt;

&lt;p&gt;•   XPath
Support
in
ElementTree&lt;/p&gt;

&lt;p&gt;•   The
ElementTree
iterparse
Function&lt;/p&gt;

&lt;p&gt;•   lxml
•   Parsing
XML
and
HTML
with
lxml&lt;/p&gt;

&lt;p&gt;•   XPath
and
XSLT
with
lxml&lt;/p&gt;

&lt;p&gt;•   xmlwitch&lt;/p&gt;

&lt;p&gt;CHAPTER 13. SERIALIZING PYTHON OBJECTS&lt;/p&gt;

&lt;p&gt;. Every Saturday since we’ve lived in this apartment, I have awakened at 6:15, poured myself a bowl of cereal, added a quarter-cup of 2% milk, sat on this end of this couch, turned on BBC America, and watched Doctor Who. .
—   Sheldon, The Big Bang Theory
13.1. DIVING IN
On the surface, the concept of serialization is simple. You have a data structure in memory that you want to save, reuse, or send to someone else. How would you do that? Well, that depends on how you want to save it, how you want to reuse it, and to whom you want to send it. Many games allow you to save your progress when you quit the game and pick up where you left off when you relaunch the game. (Actually, many non-gaming applications do this as well.) In this case, a data structure that captures “your progress so far” needs to be stored on disk when you quit, then loaded from disk when you relaunch. The data is only meant to be used by the same program that created it, never sent over a network, and never read by anything other than the program that created it. Therefore, the interoperability issues are limited to ensuring that later versions of the program can read data written by earlier versions.
For cases like this, the pickle module is ideal. It’s part of the Python standard library, so it’s always
available. It’s fast; the bulk of it is written in C, like the Python interpreter itself. It can store arbitrarily
complex Python data structures.&lt;/p&gt;

&lt;p&gt;What can the pickle module store?
•   All the native
datatypes
that Python supports: booleans, integers, floating point numbers, complex numbers, strings, bytes objects, byte arrays, and None.&lt;/p&gt;

&lt;p&gt;•   Lists, tuples, dictionaries, and sets containing any combination of native datatypes.&lt;/p&gt;

&lt;p&gt;•   Lists, tuples, dictionaries, and sets containing any combination of lists, tuples, dictionaries, and sets containing any combination of native datatypes (and so on, to the
maximum
nesting
level
that
Python
supports).&lt;/p&gt;

&lt;p&gt;• Functions, classes, and instances of classes (with caveats).&lt;/p&gt;

&lt;p&gt;If this isn’t enough for you, the pickle module is also extensible. If you’re interested in extensibility, check out the links in the Further
Reading
section at the end of the chapter.&lt;/p&gt;

&lt;p&gt;13.1.1. A QUICK NOTE ABOUT THE EXAMPLES IN THIS CHAPTER
This chapter tells a tale with two Python Shells. All of the examples in this chapter are part of a single story arc. You will be asked to switch back and forth between the two Python Shells as I demonstrate the pickle and json modules.
To help keep things straight, open the Python Shell and define the following variable:
&amp;gt;&amp;gt;&amp;gt; shell = 1&lt;/p&gt;

&lt;p&gt;Keep that window open. Now open another Python Shell and define the following variable:
&amp;gt;&amp;gt;&amp;gt; shell = 2&lt;/p&gt;

&lt;p&gt;Throughout this chapter, I will use the shell variable to indicate which Python Shell is being used in each example.
.
13.2. SAVING DATA TO A PICKLE FILE
The pickle module works with data structures. Let’s build one.
&amp;gt;&amp;gt;&amp;gt; shell&lt;/p&gt;

&lt;p&gt;1&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;entry = {}&lt;/p&gt;

&lt;p&gt;entry[&amp;lsquo;title&amp;rsquo;] = &amp;lsquo;Dive into history, 2009 edition&amp;rsquo;&lt;/p&gt;

&lt;p&gt;entry[&amp;lsquo;article_link&amp;rsquo;] = &amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&#34;&gt;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;entry[&amp;lsquo;comments_link&amp;rsquo;] = None&lt;/p&gt;

&lt;p&gt;entry[&amp;lsquo;internal_id&amp;rsquo;] = b&amp;rsquo;\xDE\xD5\xB4\xF8&amp;rsquo;&lt;/p&gt;

&lt;p&gt;entry[&amp;lsquo;tags&amp;rsquo;] = (&amp;lsquo;diveintopython&amp;rsquo;, &amp;lsquo;docbook&amp;rsquo;, &amp;lsquo;html&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;entry[&amp;lsquo;published&amp;rsquo;] = True&lt;/p&gt;

&lt;p&gt;import time&lt;/p&gt;

&lt;p&gt;entry[&amp;lsquo;published_date&amp;rsquo;] = time.strptime(&amp;lsquo;Fri Mar 27 22:20:42 2009&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;entry[&amp;lsquo;published_date&amp;rsquo;]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Follow along in Python Shell #1.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The idea here is to build a Python dictionary that could represent something useful, like an entry
in
an
Atom
feed. But I also want to ensure that it contains several different types of data, to show off the pickle module. Don’t read too much into these values.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The time module contains a data structure (time_struct) to represent a point in time (accurate to one millisecond) and functions to manipulate time structs. The strptime() function takes a formatted string an converts it to a time_struct. This string is in the default format, but you can control that with format codes. See the time module
for more details.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s a handsome-looking Python dictionary. Let’s save it to a file.
&amp;gt;&amp;gt;&amp;gt; shell .
1
&amp;gt;&amp;gt;&amp;gt; import pickle
&amp;gt;&amp;gt;&amp;gt; with open(&amp;lsquo;entry.pickle&amp;rsquo;, &amp;lsquo;wb&amp;rsquo;) as f: .
&amp;hellip; pickle.dump(entry, f) .
&amp;hellip;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;This is still in Python Shell #1.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use the open() function to open a file. Set the file mode to &amp;lsquo;wb&amp;rsquo; to open the file for writing in
binary
mode. Wrap it in a with statement
to ensure the file is closed automatically when you’re done with it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The dump() function in the pickle module takes a serializable Python data structure, serializes it into a binary, Python-specific format using the latest version of the pickle protocol, and saves it to an open file.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That last sentence was pretty important.
•   The pickle module takes a Python data structure and saves it to a file.&lt;/p&gt;

&lt;p&gt;•   To do this, it serializes the data structure using a data format called “the pickle protocol.”&lt;/p&gt;

&lt;p&gt;•   The pickle protocol is Python-specific; there is no guarantee of cross-language compatibility. You probably couldn’t take the entry.pickle file you just created and do anything useful with it in Perl, PHP, Java, or any other language.&lt;/p&gt;

&lt;p&gt;•   Not every Python data structure can be serialized by the pickle module. The pickle protocol has changed
several times as new data types have been added to the Python language, but there are still limitations.&lt;/p&gt;

&lt;p&gt;•   As a result of these changes, there is no guarantee of compatibility between different versions of Python itself. Newer versions of Python support the older serialization formats, but older versions of Python do not support newer formats (since they don’t support the newer data types).&lt;/p&gt;

&lt;p&gt;•   Unless you specify otherwise, the functions in the pickle module will use the latest version of the pickle protocol. This ensures that you have maximum flexibility in the types of data you can serialize, but it also means that the resulting file will not be readable by older versions of Python that do not support the latest version of the pickle protocol.&lt;/p&gt;

&lt;p&gt;•   The latest version of the pickle protocol is a binary format. Be sure to open your pickle files in
binary
mode, or the data will get corrupted during writing.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;13.3. LOADING DATA FROM A PICKLE FILE
Now switch to your second Python Shell — i.e. not the one where you created the entry dictionary.
&amp;gt;&amp;gt;&amp;gt; shell .
2
&amp;gt;&amp;gt;&amp;gt; entry .&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
NameError: name &amp;lsquo;entry&amp;rsquo; is not defined&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import pickle
with open(&amp;lsquo;entry.pickle&amp;rsquo;, &amp;lsquo;rb&amp;rsquo;) as f: .
&amp;hellip; entry = pickle.load(f) .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;hellip;
&amp;gt;&amp;gt;&amp;gt; entry .
{&amp;lsquo;comments_link&amp;rsquo;: None,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;internal_id&amp;rsquo;: b&amp;rsquo;\xDE\xD5\xB4\xF8&amp;rsquo;,
&amp;lsquo;title&amp;rsquo;: &amp;lsquo;Dive into history, 2009 edition&amp;rsquo;,
&amp;lsquo;tags&amp;rsquo;: (&amp;lsquo;diveintopython&amp;rsquo;, &amp;lsquo;docbook&amp;rsquo;, &amp;lsquo;html&amp;rsquo;),
&amp;lsquo;article_link&amp;rsquo;:
&amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&#34;&gt;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&lt;/a&gt;,
&amp;lsquo;published_date&amp;rsquo;: time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1),
&amp;lsquo;published&amp;rsquo;: True}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This is Python Shell #2.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There is no entry variable defined here. You defined an entry variable in Python Shell #1, but that’s a completely different environment with its own state.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Open the entry.pickle file you created in Python Shell #1. The pickle module uses a binary data format, so you should always open pickle files in binary mode.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The pickle.load() function takes a stream
object, reads the serialized data from the stream, creates a new Python object, recreates the serialized data in the new Python object, and returns the new Python object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now the entry variable is a dictionary with familiar-looking keys and values.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The pickle.dump() / pickle.load() cycle results in a new data structure that is equal to the original data structure.
&amp;gt;&amp;gt;&amp;gt; shell .
1
&amp;gt;&amp;gt;&amp;gt; with open(&amp;lsquo;entry.pickle&amp;rsquo;, &amp;lsquo;rb&amp;rsquo;) as f: .
&amp;hellip; entry2 = pickle.load(f) .
&amp;hellip;
&amp;gt;&amp;gt;&amp;gt; entry2 == entry .
True
&amp;gt;&amp;gt;&amp;gt; entry2 is entry .
False
&amp;gt;&amp;gt;&amp;gt; entry2[&amp;lsquo;tags&amp;rsquo;] .
(&amp;lsquo;diveintopython&amp;rsquo;, &amp;lsquo;docbook&amp;rsquo;, &amp;lsquo;html&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; entry2[&amp;lsquo;internal_id&amp;rsquo;]
b&amp;rsquo;\xDE\xD5\xB4\xF8&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Switch back to Python Shell #1.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Open the entry.pickle file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Load the serialized data into a new variable, entry2.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python confirms that the two dictionaries, entry and entry2, are equal. In this shell, you built entry from the ground up, starting with an empty dictionary and manually assigning values to specific keys. You serialized this dictionary and stored it in the entry.pickle file. Now you’ve read the serialized data from that file and created a perfect replica of the original data structure.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Equality is not the same as identity. I said you’ve created a perfect replica of the original data structure, which is true. But it’s still a copy.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For reasons that will become clear later in this chapter, I want to point out that the value of the &amp;lsquo;tags&amp;rsquo; key is a tuple, and the value of the &amp;lsquo;internal_id&amp;rsquo; key is a bytes object.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.
13.4. PICKLING WITHOUT A FILE
The examples in the previous section showed how to serialize a Python object directly to a file on disk. But what if you don’t want or need a file? You can also serialize to a bytes object in memory.
&amp;gt;&amp;gt;&amp;gt; shell&lt;/p&gt;

&lt;p&gt;1
&amp;gt;&amp;gt;&amp;gt; b = pickle.dumps(entry) .
&amp;gt;&amp;gt;&amp;gt; type(b) .
&lt;class &#39;bytes&#39;&gt;
&amp;gt;&amp;gt;&amp;gt; entry3 = pickle.loads(b) .
&amp;gt;&amp;gt;&amp;gt; entry3 == entry .
True&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The pickle.dumps() function (note the &amp;rsquo;s&amp;rsquo; at the end of the function name) performs the same serialization as the pickle.dump() function. Instead of taking a stream object and writing the serialized data to a file on disk, it simply returns the serialized data.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Since the pickle protocol uses a binary data format, the pickle.dumps() function returns a bytes object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The pickle.loads() function (again, note the &amp;rsquo;s&amp;rsquo; at the end of the function name) performs the same deserialization as the pickle.load() function. Instead of taking a stream object and reading the serialized data from a file, it takes a bytes object containing serialized data, such as the one returned by the pickle.dumps() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The end result is the same: a perfect replica of the original dictionary.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;.
13.5. BYTES AND STRINGS REAR THEIR UGLY HEADS AGAIN
The pickle protocol has been around for many years, and it has matured as Python itself has matured. There are now four
different
versions
of the pickle protocol.
•   Python 1.x had two pickle protocols, a text-based format (“version 0”) and a binary format (“version 1”).&lt;/p&gt;

&lt;p&gt;•   Python 2.3 introduced a new pickle protocol (“version 2”) to handle new functionality in Python class
objects. It is a binary format.&lt;/p&gt;

&lt;p&gt;•   Python 3.0 introduced another pickle protocol (“version 3”) with explicit support for bytes objects and byte arrays. It is a binary format.&lt;/p&gt;

&lt;p&gt;Oh look, the
difference
between
bytes
and
strings
rears its ugly head again. (If you’re surprised, you haven’t
been paying attention.) What this means in practice is that, while Python 3 can read data pickled with protocol version 2, Python 2 can not read data pickled with protocol version 3.
.&lt;/p&gt;

&lt;p&gt;13.6. DEBUGGING PICKLE FILES
What does the pickle protocol look like? Let’s jump out of the Python Shell for a moment and take a look at that entry.pickle file we created.
you@localhost:~/diveintopython3/examples$ ls -l entry.pickle
-rw-r&amp;ndash;r&amp;ndash; 1 you you 358 Aug 3 13:34 entry.pickle
you@localhost:~/diveintopython3/examples$ cat entry.pickle
comments_linkqNXtagsqXdiveintopythonqXdocbookqXhtmlq?qX publishedq?
XlinkXJhttp://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition
q Xpublished_dateq
ctime
struct_time
?qRqXtitleqXDive into history, 2009 editionqu.&lt;/p&gt;

&lt;p&gt;That wasn’t terribly helpful. You can see the strings, but other datatypes end up as unprintable (or at least unreadable) characters. Fields are not obviously delimited by tabs or spaces. This is not a format you would want to debug by yourself.
&amp;gt;&amp;gt;&amp;gt; shell&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import pickletools
with open(&amp;lsquo;entry.pickle&amp;rsquo;, &amp;lsquo;rb&amp;rsquo;) as f:
&amp;hellip; pickletools.dis(f)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;0: \x80 PROTO 3&lt;/p&gt;

&lt;p&gt;2: }&lt;/p&gt;

&lt;p&gt;3: q&lt;/p&gt;

&lt;p&gt;5: (&lt;/p&gt;

&lt;p&gt;6: X&lt;/p&gt;

&lt;p&gt;25: q&lt;/p&gt;

&lt;p&gt;27: c&lt;/p&gt;

&lt;p&gt;45: q&lt;/p&gt;

&lt;p&gt;47: (&lt;/p&gt;

&lt;p&gt;48: M&lt;/p&gt;

&lt;p&gt;51: K&lt;/p&gt;

&lt;p&gt;53: K&lt;/p&gt;

&lt;p&gt;55: K&lt;/p&gt;

&lt;p&gt;57: K&lt;/p&gt;

&lt;p&gt;59: K&lt;/p&gt;

&lt;p&gt;61: K&lt;/p&gt;

&lt;p&gt;63: K&lt;/p&gt;

&lt;p&gt;65: J&lt;/p&gt;

&lt;p&gt;70: t&lt;/p&gt;

&lt;p&gt;71: q&lt;/p&gt;

&lt;p&gt;73: }&lt;/p&gt;

&lt;p&gt;74: q
76: \x86&lt;/p&gt;

&lt;p&gt;77: q&lt;/p&gt;

&lt;p&gt;79: R&lt;/p&gt;

&lt;p&gt;80: q&lt;/p&gt;

&lt;p&gt;82: X&lt;/p&gt;

&lt;p&gt;100: q&lt;/p&gt;

&lt;p&gt;102: N&lt;/p&gt;

&lt;p&gt;EMPTY_DICT
BINPUT 0
MARK&lt;/p&gt;

&lt;p&gt;BINUNICODE &amp;lsquo;published_date&amp;rsquo;&lt;/p&gt;

&lt;p&gt;BINPUT 1&lt;/p&gt;

&lt;p&gt;GLOBAL &amp;lsquo;time struct_time&amp;rsquo;&lt;/p&gt;

&lt;p&gt;BINPUT 2&lt;/p&gt;

&lt;p&gt;MARK
BININT2
BININT1
BININT1
BININT1
BININT1
BININT1
BININT1
BININT1
BININT
TUPLE&lt;/p&gt;

&lt;p&gt;BINPUT 3&lt;/p&gt;

&lt;p&gt;EMPTY_DICT&lt;/p&gt;

&lt;p&gt;BINPUT  4&lt;br /&gt;
TUPLE2&lt;br /&gt;
BINPUT  5&lt;br /&gt;
REDUCE&lt;br /&gt;
BINPUT  6&lt;/p&gt;

&lt;p&gt;2009
3
27
22
20
42
4
86
-1
(MARK at 47)&lt;/p&gt;

&lt;p&gt;BINUNICODE &amp;lsquo;comments_link&amp;rsquo;
BINPUT 7
NONE&lt;/p&gt;

&lt;p&gt;103: X BINUNICODE &amp;lsquo;internal_id&amp;rsquo;&lt;/p&gt;

&lt;p&gt;119: q  BINPUT 8&lt;br /&gt;
121: C  SHORT_BINBYTES &amp;lsquo;ÞÕ´ø&amp;rsquo;&lt;br /&gt;
127: q  BINPUT 9&lt;br /&gt;
129: X  BINUNICODE &amp;lsquo;tags&amp;rsquo;&lt;br /&gt;
138: q  BINPUT 10&lt;br /&gt;
140: X  BINUNICODE &amp;lsquo;diveintopython&amp;rsquo;&lt;br /&gt;
159: q  BINPUT 11&lt;br /&gt;
161: X  BINUNICODE &amp;lsquo;docbook&amp;rsquo;&lt;br /&gt;
173: q  BINPUT 12&lt;br /&gt;
175: X  BINUNICODE &amp;lsquo;html&amp;rsquo;&lt;br /&gt;
184: q  BINPUT 13&lt;br /&gt;
186: \x87  TUPLE3&lt;br /&gt;
187: q  BINPUT 14&lt;br /&gt;
189: X  BINUNICODE &amp;lsquo;title&amp;rsquo;&lt;br /&gt;
199: q  BINPUT 15&lt;br /&gt;
201: X  BINUNICODE &amp;lsquo;Dive into history, 2009 edition&amp;rsquo;&lt;br /&gt;
237: q  BINPUT 16&lt;br /&gt;
239: X  BINUNICODE &amp;lsquo;article_link&amp;rsquo;&lt;br /&gt;
256: q  BINPUT 17&lt;br /&gt;
258: X  BINUNICODE &amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&#34;&gt;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&lt;/a&gt;&lt;br /&gt;
337: q  BINPUT 18&lt;br /&gt;
339: X  BINUNICODE &amp;lsquo;published&amp;rsquo;&lt;br /&gt;
353: q  BINPUT 19&lt;br /&gt;
355: \x88  NEWTRUE&lt;br /&gt;
356: u  SETITEMS (MARK at 5)&lt;/p&gt;

&lt;p&gt;357: . STOP
highest protocol among opcodes = 3&lt;/p&gt;

&lt;p&gt;The most interesting piece of information in that disassembly is on the last line, because it includes the version of the pickle protocol with which this file was saved. There is no explicit version marker in the pickle protocol. To determine which protocol version was used to store a pickle file, you need to look at the markers (“opcodes”) within the pickled data and use hard-coded knowledge of which opcodes were introduced with each version of the pickle protocol. The pickle.dis() function does exactly that, and it prints the result in the last line of the disassembly output. Here is a function that returns just the version number, without printing anything:
import pickletools&lt;/p&gt;

&lt;p&gt;def protocol_version(file_object):&lt;/p&gt;

&lt;p&gt;maxproto = -1&lt;/p&gt;

&lt;p&gt;for opcode, arg, pos in pickletools.genops(file_object):&lt;/p&gt;

&lt;p&gt;maxproto = max(maxproto, opcode.proto)&lt;/p&gt;

&lt;p&gt;return maxproto&lt;/p&gt;

&lt;p&gt;And here it is in action:
&amp;gt;&amp;gt;&amp;gt; import pickleversion
&amp;gt;&amp;gt;&amp;gt; with open(&amp;lsquo;entry.pickle&amp;rsquo;, &amp;lsquo;rb&amp;rsquo;) as f:
&amp;hellip; v = pickleversion.protocol_version(f)
&amp;gt;&amp;gt;&amp;gt; v&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;13.7. SERIALIZING PYTHON OBJECTS TO BE READ BY OTHER LANGUAGES
The data format used by the pickle module is Python-specific. It makes no attempt to be compatible with other programming languages. If cross-language compatibility is one of your requirements, you need to look at other serialization formats. One such format is JSON. “JSON” stands for “JavaScript Object Notation,” but don’t let the name fool you — JSON is explicitly designed to be usable across multiple programming languages.
Python 3 includes a json module in the standard library. Like the pickle module, the json module has functions for serializing data structures, storing the serialized data on disk, loading serialized data from disk, and unserializing the data back into a new Python object. But there are some important differences, too. First of all, the JSON data format is text-based, not binary. RFC
4627
defines the JSON format and how different types of data must be encoded as text. For example, a boolean value is stored as either the five-character string &amp;lsquo;false&amp;rsquo; or the four-character string &amp;lsquo;true&amp;rsquo;. All JSON values are case-sensitive.
Second, as with any text-based format, there is the issue of whitespace. JSON allows arbitrary amounts of whitespace (spaces, tabs, carriage returns, and line feeds) between values. This whitespace is “insignificant,” which means that JSON encoders can add as much or as little whitespace as they like, and JSON decoders are required to ignore the whitespace between values. This allows you to “pretty-print” your JSON data, nicely nesting values within values at different indentation levels so you can read it in a standard browser or text editor. Python’s json module has options for pretty-printing during encoding.
Third, there’s the perennial problem of character encoding. JSON encodes values as plain text, but as you know, there
ain’t
no
such
thing
as
“plain
text.”
JSON must be stored in a Unicode encoding (UTF-32, UTF-16, or the default, UTF-8), and section
3
of
RFC
4627
defines how to tell which encoding is being used.
.&lt;/p&gt;

&lt;p&gt;13.8. SAVING DATA TO A JSON FILE
JSON looks remarkably like a data structure you might define manually in JavaScript. This is no accident; you can actually use the JavaScript eval() function to “decode” JSON-serialized data. (The usual caveats
about
untrusted
input
apply, but the point is that JSON is valid JavaScript.) As such, JSON may already look familiar to you.
&amp;gt;&amp;gt;&amp;gt; shell&lt;/p&gt;

&lt;p&gt;1
&amp;gt;&amp;gt;&amp;gt; basic_entry = {} .
&amp;gt;&amp;gt;&amp;gt; basic_entry[&amp;lsquo;id&amp;rsquo;] = 256
&amp;gt;&amp;gt;&amp;gt; basic_entry[&amp;lsquo;title&amp;rsquo;] = &amp;lsquo;Dive into history, 2009 edition&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; basic_entry[&amp;lsquo;tags&amp;rsquo;] = (&amp;lsquo;diveintopython&amp;rsquo;, &amp;lsquo;docbook&amp;rsquo;, &amp;lsquo;html&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; basic_entry[&amp;lsquo;published&amp;rsquo;] = True
&amp;gt;&amp;gt;&amp;gt; basic_entry[&amp;lsquo;comments_link&amp;rsquo;] = None
&amp;gt;&amp;gt;&amp;gt; import json
&amp;gt;&amp;gt;&amp;gt; with open(&amp;lsquo;basic.json&amp;rsquo;, mode=&amp;lsquo;w&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as f: .
&amp;hellip; json.dump(basic_entry, f) .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We’re going to create a new data structure instead of re-using the existing entry data structure. Later in this chapter, we’ll see what happens when we try to encode the more complex data structure in JSON.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;JSON is a text-based format, which means you need to open this file in text mode and specify a character encoding. You can never go wrong with UTF-8.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Like the pickle module, the json module defines a dump() function which takes a Python data structure and a writeable stream object. The dump() function serializes the Python data structure and writes it to the stream object. Doing this inside a with statement will ensure that the file is closed properly when we’re done.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So what does the resulting JSON serialization look like?
you@localhost:~/diveintopython3/examples$ cat basic.json
{&amp;ldquo;published&amp;rdquo;: true, &amp;ldquo;tags&amp;rdquo;: [&amp;ldquo;diveintopython&amp;rdquo;, &amp;ldquo;docbook&amp;rdquo;, &amp;ldquo;html&amp;rdquo;], &amp;ldquo;comments_link&amp;rdquo;: null,
&amp;ldquo;id&amp;rdquo;: 256, &amp;ldquo;title&amp;rdquo;: &amp;ldquo;Dive into history, 2009 edition&amp;rdquo;}&lt;/p&gt;

&lt;p&gt;That’s certainly more
readable
than
a
pickle
file. But JSON can contain arbitrary whitespace between values, and the json module provides an easy way to take advantage of this to create even more readable JSON files.
&amp;gt;&amp;gt;&amp;gt; shell&lt;/p&gt;

&lt;p&gt;1
&amp;gt;&amp;gt;&amp;gt; with open(&amp;lsquo;basic-pretty.json&amp;rsquo;, mode=&amp;lsquo;w&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as f:
&amp;hellip; json.dump(basic_entry, f, indent=2
) .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If you pass an indent parameter to the json.dump() function, it will make the resulting JSON file more readable, at the expense of larger file size. The indent parameter is an integer. 0 means “put each value on its own line.” A number greater than 0 means “put each value on its own line, and use this number of spaces to indent nested data structures.”
And this is the result:
you@localhost:~/diveintopython3/examples$ cat basic-pretty.json&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;{
&amp;ldquo;published&amp;rdquo;: true,
&amp;ldquo;tags&amp;rdquo;: [&lt;/p&gt;

&lt;p&gt;&amp;ldquo;diveintopython&amp;rdquo;,
&amp;ldquo;docbook&amp;rdquo;,
&amp;ldquo;html&amp;rdquo;&lt;/p&gt;

&lt;p&gt;],
&amp;ldquo;comments_link&amp;rdquo;: null,
&amp;ldquo;id&amp;rdquo;: 256,
&amp;ldquo;title&amp;rdquo;: &amp;ldquo;Dive into history, 2009 edition&amp;rdquo;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;13.9. MAPPING OF PYTHON DATATYPES TO JSON
Since JSON is not Python-specific, there are some mismatches in its coverage of Python datatypes. Some of them are simply naming differences, but there is two important Python datatypes that are completely missing. See if you can spot them: Did you notice what was missing? Tuples &amp;amp;bytes! JSON has an array type, which the json module maps to a Python list, but it does not have a separate type for “frozen arrays” (tuples). And while JSON supports strings quite nicely, it has no support for bytes objects or byte arrays.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;13.10. SERIALIZING DATATYPES UNSUPPORTED BY JSON
Even if JSON has no built-in support for bytes, that doesn’t mean you can’t serialize bytes objects. The json module provides extensibility hooks for encoding and decoding unknown datatypes. (By “unknown,” I mean “not defined in JSON.” Obviously the json module knows about byte arrays, but it’s constrained by the limitations of the JSON specification.) If you want to encode bytes or other datatypes that JSON doesn’t support natively, you need to provide custom encoders and decoders for those types.
&amp;gt;&amp;gt;&amp;gt; shell&lt;/p&gt;

&lt;p&gt;1
&amp;gt;&amp;gt;&amp;gt; entry .
{&amp;lsquo;comments_link&amp;rsquo;: None,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;internal_id&amp;rsquo;: b&amp;rsquo;\xDE\xD5\xB4\xF8&amp;rsquo;,
&amp;lsquo;title&amp;rsquo;: &amp;lsquo;Dive into history, 2009 edition&amp;rsquo;,
&amp;lsquo;tags&amp;rsquo;: (&amp;lsquo;diveintopython&amp;rsquo;, &amp;lsquo;docbook&amp;rsquo;, &amp;lsquo;html&amp;rsquo;),
&amp;lsquo;article_link&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&#34;&gt;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&lt;/a&gt;,
&amp;lsquo;published_date&amp;rsquo;: time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1),
&amp;lsquo;published&amp;rsquo;: True}&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import json
with open(&amp;lsquo;entry.json&amp;rsquo;, &amp;lsquo;w&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as f: .
&amp;hellip; json.dump(entry, f) .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 5, in &lt;module&gt;
File &amp;ldquo;C:\Python31\lib\json__init__.py&amp;rdquo;, line 178, in dump&lt;/p&gt;

&lt;p&gt;for chunk in iterable:
File &amp;ldquo;C:\Python31\lib\json\encoder.py&amp;rdquo;, line 408, in _iterencode
for chunk in _iterencode_dict(o, _current_indent_level):
File &amp;ldquo;C:\Python31\lib\json\encoder.py&amp;rdquo;, line 382, in _iterencode_dict
for chunk in chunks:
File &amp;ldquo;C:\Python31\lib\json\encoder.py&amp;rdquo;, line 416, in _iterencode&lt;/p&gt;

&lt;p&gt;o = _default(o)
File &amp;ldquo;C:\Python31\lib\json\encoder.py&amp;rdquo;, line 170, in default&lt;/p&gt;

&lt;p&gt;raise TypeError(repr(o) + &amp;ldquo; is not JSON serializable&amp;rdquo;)
TypeError: b&amp;rsquo;\xDE\xD5\xB4\xF8&amp;rsquo; is not JSON serializable&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;OK, it’s time to revisit the entry data structure. This has it all: a boolean value, a None value, a string, a tuple of strings, a bytes object, and a time structure.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I know I’ve said it before, but it’s worth repeating: JSON is a text-based format. Always open JSON files in text mode with a UTF-8 character encoding.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Well that’s not good. What happened?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here’s what happened: the json.dump() function tried to serialize the bytes object b&amp;rsquo;\xDE\xD5\xB4\xF8&amp;rsquo;, but it failed, because JSON has no support for bytes objects. However, if storing bytes is important to you, you can define your own “mini-serialization format.”
def to_json(python_object): .
if isinstance(python_object, bytes): .
return {&amp;rsquo;&lt;strong&gt;class&lt;/strong&gt;&amp;lsquo;: &amp;lsquo;bytes&amp;rsquo;,
&amp;lsquo;&lt;strong&gt;value&lt;/strong&gt;&amp;lsquo;: list(python_object)} .
raise TypeError(repr(python_object) + &amp;lsquo; is not JSON serializable&amp;rsquo;) .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To define your own “mini-serialization format” for a datatype that JSON doesn’t support natively, just define a function that takes a Python object as a parameter. This Python object will be the actual object that the json.dump() function is unable to serialize by itself — in this case, the bytes object b&amp;rsquo;\xDE\xD5\xB4\xF8&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Your custom serialization function should check the type of the Python object that the json.dump() function passed to it. This is not strictly necessary if your function only serializes one datatype, but it makes it crystal clear what case your function is covering, and it makes it easier to extend if you need to add serializations for more datatypes later.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In this case, I’ve chosen to convert a bytes object into a dictionary. The &lt;strong&gt;class&lt;/strong&gt; key will hold the original datatype (as a string, &amp;lsquo;bytes&amp;rsquo;), and the &lt;strong&gt;value&lt;/strong&gt; key will hold the actual value. Of course this can’t be a bytes object; the entire point is to convert it into something that can be serialized in JSON! A bytes object is just a sequence of integers; each integer is somewhere in the range 0–255. We can use the list() function to convert the bytes object into a list of integers. So b&amp;rsquo;\xDE\xD5\xB4\xF8&amp;rsquo; becomes [222, 213, 180, 248]. (Do the math! It works! The byte \xDE in hexadecimal is 222 in decimal, \xD5 is 213, and so on.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This line is important. The data structure you’re serializing may contain types that neither the built-in JSON serializer nor your custom serializer can handle. In this case, your custom serializer must raise a TypeError so that the json.dump() function knows that your custom serializer did not recognize the type.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s it; you don’t need to do anything else. In particular, this custom serialization function returns a Python dictionary, not a string. You’re not doing the entire serializing-to-JSON yourself; you’re only doing the converting-to-a-supported-datatype part. The json.dump() function will do the rest.
&amp;gt;&amp;gt;&amp;gt; shell&lt;/p&gt;

&lt;p&gt;1&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import customserializer     .
with open(&amp;lsquo;entry.json&amp;rsquo;, &amp;lsquo;w&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as f:    .
&amp;hellip; json.dump(entry, f, default=customserializer.to_json
)   .
&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 9, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;json.dump(entry, f, default=customserializer.to_json)&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;C:\Python31\lib\json__init__.py&amp;rdquo;, line 178, in dump&lt;/p&gt;

&lt;p&gt;for chunk in iterable:&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;C:\Python31\lib\json\encoder.py&amp;rdquo;, line 408, in _iterencode&lt;/p&gt;

&lt;p&gt;for chunk in _iterencode_dict(o, _current_indent_level):&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;C:\Python31\lib\json\encoder.py&amp;rdquo;, line 382, in _iterencode_dict&lt;/p&gt;

&lt;p&gt;for chunk in chunks:&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;C:\Python31\lib\json\encoder.py&amp;rdquo;, line 416, in _iterencode&lt;/p&gt;

&lt;p&gt;o = _default(o)
File &amp;ldquo;/Users/pilgrim/diveintopython3/examples/customserializer.py&amp;rdquo;, line 12, in to_json&lt;/p&gt;

&lt;p&gt;raise TypeError(repr(python_object) + &amp;lsquo; is not JSON serializable&amp;rsquo;) . TypeError: time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1) is not JSON serializable
1.  The customserializer module is where you just defined the to_json() function in the previous example.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Text mode, UTF-8 encoding, yadda yadda. (You’ll forget! I forget sometimes! And everything will work right up until the moment that it fails, and then it will fail most spectacularly.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is the important bit: to hook your custom conversion function into the json.dump() function, pass your function into the json.dump() function in the default parameter. (Hooray, everything
in
Python
is
an
object!)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;OK, so it didn’t actually work. But take a look at the exception. The json.dump() function is no longer complaining about being unable to serialize the bytes object. Now it’s complaining about a completely different object: the time.struct_time object.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While getting a different exception might not seem like progress, it really is! It’ll just take one more tweak
to get past this.&lt;/p&gt;

&lt;p&gt;import time&lt;/p&gt;

&lt;p&gt;def to_json(python_object):
if isinstance(python_object, time.struct_time): .
return {&amp;rsquo;&lt;strong&gt;class&lt;/strong&gt;&amp;lsquo;: &amp;lsquo;time.asctime&amp;rsquo;,
&amp;lsquo;&lt;strong&gt;value&lt;/strong&gt;&amp;lsquo;: time.asctime(python_object)} .
if isinstance(python_object, bytes):
return {&amp;rsquo;&lt;strong&gt;class&lt;/strong&gt;&amp;lsquo;: &amp;lsquo;bytes&amp;rsquo;,
&amp;lsquo;&lt;strong&gt;value&lt;/strong&gt;&amp;lsquo;: list(python_object)}
raise TypeError(repr(python_object) + &amp;lsquo; is not JSON serializable&amp;rsquo;)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Adding to our existing customserializer.to_json() function, we need to check whether the Python object (that the json.dump() function is having trouble with) is a time.struct_time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If so, we’ll do something similar to the conversion we did with the bytes object: convert the time.struct_time object to a dictionary that only contains JSON-serializable values. In this case, the easiest way to convert a datetime into a JSON-serializable value is to convert it to a string with the time.asctime() function. The time.asctime() function will convert that nasty-looking time.struct_time into the string &amp;lsquo;Fri Mar 27 22:20:42 2009&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With these two custom conversions, the entire entry data structure should serialize to JSON without any further problems.
&amp;gt;&amp;gt;&amp;gt; shell
1
&amp;gt;&amp;gt;&amp;gt; with open(&amp;lsquo;entry.json&amp;rsquo;, &amp;lsquo;w&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as f:
&amp;hellip; json.dump(entry, f, default=customserializer.to_json)
&amp;hellip;&lt;/p&gt;

&lt;p&gt;you@localhost:~/diveintopython3/examples$ ls -l example.json
-rw-r&amp;ndash;r&amp;ndash; 1 you you 391 Aug 3 13:34 entry.json
you@localhost:~/diveintopython3/examples$ cat example.json
{&amp;ldquo;published_date&amp;rdquo;: {&amp;rdquo;&lt;strong&gt;class&lt;/strong&gt;&amp;ldquo;: &amp;ldquo;time.asctime&amp;rdquo;, &amp;ldquo;&lt;strong&gt;value&lt;/strong&gt;&amp;ldquo;: &amp;ldquo;Fri Mar 27 22:20:42 2009&amp;rdquo;},
&amp;ldquo;comments_link&amp;rdquo;: null, &amp;ldquo;internal_id&amp;rdquo;: {&amp;rdquo;&lt;strong&gt;class&lt;/strong&gt;&amp;ldquo;: &amp;ldquo;bytes&amp;rdquo;, &amp;ldquo;&lt;strong&gt;value&lt;/strong&gt;&amp;ldquo;: [222, 213, 180, 248]},
&amp;ldquo;tags&amp;rdquo;: [&amp;ldquo;diveintopython&amp;rdquo;, &amp;ldquo;docbook&amp;rdquo;, &amp;ldquo;html&amp;rdquo;], &amp;ldquo;title&amp;rdquo;: &amp;ldquo;Dive into history, 2009 edition&amp;rdquo;,
&amp;ldquo;article_link&amp;rdquo;: &amp;ldquo;&lt;a href=&#34;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&amp;quot;&#34;&gt;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&amp;quot;&lt;/a&gt;,
&amp;ldquo;published&amp;rdquo;: true}&lt;/p&gt;

&lt;p&gt;.
13.11. LOADING DATA FROM A JSON FILE
Like the pickle module, the json module has a load() function which takes a stream object, reads JSON-encoded data from it, and creates a new Python object that mirrors the JSON data structure.
&amp;gt;&amp;gt;&amp;gt; shell&lt;/p&gt;

&lt;p&gt;2
&amp;gt;&amp;gt;&amp;gt; del entry .
&amp;gt;&amp;gt;&amp;gt; entry&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
NameError: name &amp;lsquo;entry&amp;rsquo; is not defined&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import json
with open(&amp;lsquo;entry.json&amp;rsquo;, &amp;lsquo;r&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as f:
&amp;hellip; entry = json.load(f) .
&amp;hellip;
entry .
{&amp;lsquo;comments_link&amp;rsquo;: None,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;lsquo;internal_id&amp;rsquo;: {&amp;rsquo;&lt;strong&gt;class&lt;/strong&gt;&amp;lsquo;: &amp;lsquo;bytes&amp;rsquo;, &amp;lsquo;&lt;strong&gt;value&lt;/strong&gt;&amp;lsquo;: [222, 213, 180, 248]},
&amp;lsquo;title&amp;rsquo;: &amp;lsquo;Dive into history, 2009 edition&amp;rsquo;,
&amp;lsquo;tags&amp;rsquo;: [&amp;lsquo;diveintopython&amp;rsquo;, &amp;lsquo;docbook&amp;rsquo;, &amp;lsquo;html&amp;rsquo;],
&amp;lsquo;article_link&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&#34;&gt;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&lt;/a&gt;,
&amp;lsquo;published_date&amp;rsquo;: {&amp;rsquo;&lt;strong&gt;class&lt;/strong&gt;&amp;lsquo;: &amp;lsquo;time.asctime&amp;rsquo;, &amp;lsquo;&lt;strong&gt;value&lt;/strong&gt;&amp;lsquo;: &amp;lsquo;Fri Mar 27 22:20:42 2009&amp;rsquo;},
&amp;lsquo;published&amp;rsquo;: True}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;For demonstration purposes, switch to Python Shell #2 and delete the entry data structure that you created earlier in this chapter with the pickle module.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In the simplest case, the json.load() function works the same as the pickle.load() function. You pass in a stream object and it returns a new Python object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I have good news and bad news. Good news first: the json.load() function successfully read the entry.json file you created in Python Shell #1 and created a new Python object that contained the data. Now the bad news: it didn’t recreate the original entry data structure. The two values &amp;lsquo;internal_id&amp;rsquo; and &amp;lsquo;published_date&amp;rsquo; were recreated as dictionaries — specifically, the dictionaries with JSON-compatible values that you created in the to_json() conversion function.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;json.load() doesn’t know anything about any conversion function you may have passed to json.dump(). What you need is the opposite of the to_json() function — a function that will take a custom-converted JSON object and convert it back to the original Python datatype.&lt;/p&gt;

&lt;h1 id=&#34;add-this-to-customserializer-py:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;add this to customserializer.py&lt;/h1&gt;

&lt;p&gt;def from_json(json_object): .
if &amp;lsquo;&lt;strong&gt;class&lt;/strong&gt;&amp;rsquo; in json_object: .
if json_object[&amp;rsquo;&lt;strong&gt;class&lt;/strong&gt;&amp;rsquo;] == &amp;lsquo;time.asctime&amp;rsquo;:
return time.strptime(json_object[&amp;rsquo;&lt;strong&gt;value&lt;/strong&gt;&amp;rsquo;]) .
if json_object[&amp;rsquo;&lt;strong&gt;class&lt;/strong&gt;&amp;rsquo;] == &amp;lsquo;bytes&amp;rsquo;:
return bytes(json_object[&amp;rsquo;&lt;strong&gt;value&lt;/strong&gt;&amp;rsquo;]) .
return json_object&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This conversion function also takes one parameter and returns one value. But the parameter it takes is not a string, it’s a Python object — the result of deserializing a JSON-encoded string into Python.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;All you need to do is check whether this object contains the &amp;lsquo;&lt;strong&gt;class&lt;/strong&gt;&amp;rsquo; key that the to_json() function created. If so, the value of the &amp;lsquo;&lt;strong&gt;class&lt;/strong&gt;&amp;rsquo; key will tell you how to decode the value back into the original Python datatype.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To decode the time string returned by the time.asctime() function, you use the time.strptime() function. This function takes a formatted datetime string (in a customizable format, but it defaults to the same format that time.asctime() defaults to) and returns a time.struct_time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To convert a list of integers back into a bytes object, you can use the bytes() function.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That was it; there were only two datatypes handled in the to_json() function, and now those two
datatypes are handled in the from_json() function. This is the result:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;shell
2
import customserializer
with open(&amp;lsquo;entry.json&amp;rsquo;, &amp;lsquo;r&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as f:
&amp;hellip; entry = json.load(f, object_hook=customserializer.from_json) .
&amp;hellip;
entry .
{&amp;lsquo;comments_link&amp;rsquo;: None,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;lsquo;internal_id&amp;rsquo;: b&amp;rsquo;\xDE\xD5\xB4\xF8&amp;rsquo;,
&amp;lsquo;title&amp;rsquo;: &amp;lsquo;Dive into history, 2009 edition&amp;rsquo;,
&amp;lsquo;tags&amp;rsquo;: [&amp;lsquo;diveintopython&amp;rsquo;, &amp;lsquo;docbook&amp;rsquo;, &amp;lsquo;html&amp;rsquo;],
&amp;lsquo;article_link&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&#34;&gt;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;&lt;/a&gt;,
&amp;lsquo;published_date&amp;rsquo;: time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1),
&amp;lsquo;published&amp;rsquo;: True}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To hook the from_json() function into the deserialization process, pass it as the object_hook parameter to the json.load() function. Functions that take functions; it’s so handy!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The entry data structure now contains an &amp;lsquo;internal_id&amp;rsquo; key whose value is a bytes object. It also contains a &amp;lsquo;published_date&amp;rsquo; key whose value is a time.struct_time object.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There is one final glitch, though.
&amp;gt;&amp;gt;&amp;gt; shell
1
&amp;gt;&amp;gt;&amp;gt; import customserializer
&amp;gt;&amp;gt;&amp;gt; with open(&amp;lsquo;entry.json&amp;rsquo;, &amp;lsquo;r&amp;rsquo;, encoding=&amp;lsquo;utf-8&amp;rsquo;) as f:
&amp;hellip; entry2 = json.load(f, object_hook=customserializer.from_json)
&amp;hellip;
&amp;gt;&amp;gt;&amp;gt; entry2 == entry .
False
&amp;gt;&amp;gt;&amp;gt; entry[&amp;lsquo;tags&amp;rsquo;] .
(&amp;lsquo;diveintopython&amp;rsquo;, &amp;lsquo;docbook&amp;rsquo;, &amp;lsquo;html&amp;rsquo;)
&amp;gt;&amp;gt;&amp;gt; entry2[&amp;lsquo;tags&amp;rsquo;] .
[&amp;lsquo;diveintopython&amp;rsquo;, &amp;lsquo;docbook&amp;rsquo;, &amp;lsquo;html&amp;rsquo;]&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Even after hooking the to_json() function into the serialization, and hooking the from_json() function into the deserialization, we still haven’t recreated a perfect replica of the original data structure. Why not?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In the original entry data structure, the value of the &amp;lsquo;tags&amp;rsquo; key was a tuple of three strings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;But in the round-tripped entry2 data structure, the value of the &amp;lsquo;tags&amp;rsquo; key is a list of three strings. JSON doesn’t distinguish between tuples and lists; it only has a single list-like datatype, the array, and the json module silently converts both tuples and lists into JSON arrays during serialization. For most uses, you can ignore the difference between tuples and lists, but it’s something to keep in mind as you work with the json module.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;13.12. FURTHER READING
. Many articles about the pickle module make references to cPickle. In Python 2, there were two implementations of the pickle module, one written in pure Python and another written in C (but still callable from Python). In Python 3, these
two
modules
have
been
consolidated, so you should always just import pickle. You may find these articles useful, but you should ignore the now-obsolete information about cPickle.
On pickling with the pickle module:
•   pickle module&lt;/p&gt;

&lt;p&gt;•   pickle and
cPickle —
Python
object
serialization&lt;/p&gt;

&lt;p&gt;•   Using
pickle&lt;/p&gt;

&lt;p&gt;•   Python
persistence
management&lt;/p&gt;

&lt;p&gt;•   json —
JavaScript
Object
Notation
Serializer&lt;/p&gt;

&lt;p&gt;•   JSON
encoding
and
ecoding
with
custom
objects
in
Python&lt;/p&gt;

&lt;p&gt;• Pickling
class
instances&lt;/p&gt;

&lt;p&gt;• Persistence
of
external
objects&lt;/p&gt;

&lt;p&gt;• Handling
stateful
objects&lt;/p&gt;

&lt;p&gt;On  JSON and the json module:
On pickle extensibility:
CHAPTER 14. HTTP WEB SERVICES&lt;/p&gt;

&lt;p&gt;. A ruffled mind makes a restless pillow. .
— Charlotte Brontë
14.1. DIVING IN
Philosophically, I can describe HTTP web services in 12 words: exchanging data with remote servers using nothing but the operations of HTTP. If you want to get data from the server, use HTTP GET. If you want to send new data to the server, use HTTP POST. Some more advanced HTTP web service APIs also allow creating, modifying, and deleting data, using HTTP PUT and HTTP DELETE. That’s it. No registries, no envelopes, no wrappers, no tunneling. The “verbs” built into the HTTP protocol (GET, POST, PUT, and DELETE) map directly to application-level operations for retrieving, creating, modifying, and deleting data.
The main advantage of this approach is simplicity, and its simplicity has proven popular. Data — usually XML
or JSON
— can be built and stored statically, or generated dynamically by a server-side script, and all major programming languages (including Python, of course!) include an HTTP library for downloading it. Debugging is also easier; because each resource in an HTTP web service has a unique address (in the form of a URL), you can load it in your web browser and immediately see the raw data.
Examples of HTTP web services:
•   Google
Data
APIs
allow you to interact with a wide variety of Google services, including Blogger
and YouTube.&lt;/p&gt;

&lt;p&gt;•   Flickr
Services
allow you to upload and download photos from Flickr.&lt;/p&gt;

&lt;p&gt;•   Twitter
API
allows you to publish status updates on Twitter.&lt;/p&gt;

&lt;p&gt;•   …and
many
more&lt;/p&gt;

&lt;p&gt;•   http.client is a low-level library that implements RFC
2616, the HTTP protocol.&lt;/p&gt;

&lt;p&gt;•   urllib.request is an abstraction layer built on top of http.client. It provides a standard API for accessing both HTTP and FTP servers, automatically follows HTTP redirects, and handles some common forms of HTTP authentication.&lt;/p&gt;

&lt;p&gt;Python 3 comes with two different libraries for interacting with HTTP web services: So which one should you use? Neither of them. Instead, you should use httplib2, an open source third-party library that implements HTTP more fully than http.client but provides a better abstraction than urllib.request.
To understand why httplib2 is the right choice, you first need to understand HTTP.
.&lt;/p&gt;

&lt;p&gt;14.2. FEATURES OF HTTP
There are five important features which all HTTP clients should support.
14.2.1. CACHING
The most important thing to understand about any type of web service is that network access is incredibly expensive. I don’t mean “dollars and cents” expensive (although bandwidth ain’t free). I mean that it takes an extraordinary long time to open a connection, send a request, and retrieve a response from a remote server. Even on the fastest broadband connection, latency (the time it takes to send a request and start retrieving data in a response) can still be higher than you anticipated. A router misbehaves, a packet is dropped, an intermediate proxy is under attack — there’s never
a
dull
moment
on the public internet, and there may be nothing you can do about it.
HTTP is designed with caching in mind. There is an entire class of devices (called “caching proxies”) whose only job is to sit between you and the rest of the world and minimize network access. Your company or ISP almost certainly maintains caching proxies, even if you’re unaware of them. They work because caching built into the HTTP protocol.
Here’s a concrete example of how caching works. You visit diveintomark.org in your browser. That page includes a background image, wearehugh.com/m.jpg. When your browser downloads that image, the server includes the following HTTP headers:
HTTP/1.1 200 OK
Date: Sun, 31 May 2009 17:14:04 GMT
Server: Apache
Last-Modified: Fri, 22 Aug 2008 04:28:16 GMT
ETag: &amp;ldquo;3075-ddc8d800&amp;rdquo;
Accept-Ranges: bytes
Content-Length: 12405
Cache-Control: max-age=31536000, public
Expires: Mon, 31 May 2010 17:14:04 GMT
Connection: close
Content-Type: image/jpeg&lt;/p&gt;

&lt;p&gt;The Cache-Control and Expires headers tell your browser (and any caching proxies between you and the server) that this image can be cached for up to a year. A year! And if, in the next year, you visit another page which also includes a link to this image, your browser will load the image from its cache without generating any network activity whatsoever.
But wait, it gets better. Let’s say your browser purges the image from your local cache for some reason. Maybe it ran out of disk space; maybe you manually cleared the cache. Whatever. But the HTTP headers said that this data could be cached by public caching proxies. (Technically, the important thing is what the headers don’t say; the Cache-Control header doesn’t have the private keyword, so this data is cacheable by default.) Caching proxies are designed to have tons of storage space, probably far more than your local browser has allocated.
If your company or ISP maintain a caching proxy, the proxy may still have the image cached. When you visit diveintomark.org again, your browser will look in its local cache for the image, but it won’t find it, so it will make a network request to try to download it from the remote server. But if the caching proxy still has a copy of the image, it will intercept that request and serve the image from its cache. That means that your request will never reach the remote server; in fact, it will never leave your company’s network. That makes for a faster download (fewer network hops) and saves your company money (less data being downloaded from the outside world).
HTTP caching only works when everybody does their part. On one side, servers need to send the correct headers in their response. On the other side, clients need to understand and respect those headers before they request the same data twice. The proxies in the middle are not a panacea; they can only be as smart as the servers and clients allow them to be.
Python’s HTTP libraries do not support caching, but httplib2 does.&lt;/p&gt;

&lt;p&gt;14.2.2. LAST-MODIFIED CHECKING
Some data never changes, while other data changes all the time. In between, there is a vast field of data that might have changed, but hasn’t. CNN.com’s feed is updated every few minutes, but my weblog’s feed may not change for days or weeks at a time. In the latter case, I don’t want to tell clients to cache my feed for weeks at a time, because then when I do actually post something, people may not read it for weeks (because they’re respecting my cache headers which said “don’t bother checking this feed for weeks”). On the other hand, I don’t want clients downloading my entire feed once an hour if it hasn’t changed!
HTTP has a solution to this, too. When you request data for the first time, the server can send back a Last-
Modified header. This is exactly what it sounds like: the date that the data was changed. That background image referenced from diveintomark.org included a Last-Modified header.
HTTP/1.1 200 OK
Date: Sun, 31 May 2009 17:14:04 GMT
Server: Apache
Last-Modified: Fri, 22 Aug 2008 04:28:16 GMT
ETag: &amp;ldquo;3075-ddc8d800&amp;rdquo;
Accept-Ranges: bytes
Content-Length: 12405
Cache-Control: max-age=31536000, public
Expires: Mon, 31 May 2010 17:14:04 GMT
Connection: close
Content-Type: image/jpeg&lt;/p&gt;

&lt;p&gt;When you request the same data a second (or third or fourth) time, you can send an If-Modified-Since header with your request, with the date you got back from the server last time. If the data has changed since then, then the server ignores the If-Modified-Since header and just gives you the new data with a 200 status code. But if the data hasn’t changed since then, the server sends back a special HTTP 304 status code, which means “this data hasn’t changed since the last time you asked for it.” You can test this on the command line, using curl:
you@localhost:~$ curl -I -H &amp;ldquo;If-Modified-Since: Fri, 22 Aug 2008 04:28:16 GMT&amp;rdquo;
&lt;a href=&#34;http://wearehugh.com/m.jpg&#34;&gt;http://wearehugh.com/m.jpg&lt;/a&gt;
HTTP/1.1 304 Not Modified
Date: Sun, 31 May 2009 18:04:39 GMT
Server: Apache
Connection: close
ETag: &amp;ldquo;3075-ddc8d800&amp;rdquo;
Expires: Mon, 31 May 2010 18:04:39 GMT
Cache-Control: max-age=31536000, public&lt;/p&gt;

&lt;p&gt;Why is this an improvement? Because when the server sends a 304, it doesn’t re-send the data. All you get is the status code. Even after your cached copy has expired, last-modified checking ensures that you won’t download the same data twice if it hasn’t changed. (As an extra bonus, this 304 response also includes caching headers. Proxies will keep a copy of data even after it officially “expires,” in the hopes that the data hasn’t really changed and the next request responds with a 304 status code and updated cache information.)
Python’s HTTP libraries do not support last-modified date checking, but httplib2 does.
14.2.3. ETAG CHECKING
ETags are an alternate way to accomplish the same thing as the last-modified
checking. With Etags, the server sends a hash code in an ETag header along with the data you requested. (Exactly how this hash is determined is entirely up to the server. The only requirement is that it changes when the data changes.) That background image referenced from diveintomark.org had an ETag header.
HTTP/1.1 200 OK
Date: Sun, 31 May 2009 17:14:04 GMT
Server: Apache
Last-Modified: Fri, 22 Aug 2008 04:28:16 GMT
ETag: &amp;ldquo;3075-ddc8d800&amp;rdquo;
Accept-Ranges: bytes
Content-Length: 12405
Cache-Control: max-age=31536000, public
Expires: Mon, 31 May 2010 17:14:04 GMT
Connection: close
Content-Type: image/jpeg&lt;/p&gt;

&lt;p&gt;The second time you request the same data, you include the ETag hash in an If-None-Match header of your request. If the data hasn’t changed, the server will send you back a 304 status code. As with the last-modified date checking, the server sends back only the 304 status code; it doesn’t send you the same data a second time. By including the ETag hash in your second request, you’re telling the server that there’s no need to re-send the same data if it still matches this hash, since you
still
have
the
data
from
the
last
time.
Again with the curl:&lt;/p&gt;

&lt;p&gt;you@localhost:~$ curl -I -H &amp;ldquo;If-None-Match: \&amp;ldquo;3075-ddc8d800\&amp;ldquo;&amp;rdquo;
&lt;a href=&#34;http://wearehugh.com/m.jpg&#34;&gt;http://wearehugh.com/m.jpg&lt;/a&gt; . HTTP/1.1 304 Not Modified Date: Sun, 31 May 2009 18:04:39 GMT Server: Apache Connection: close ETag: &amp;ldquo;3075-ddc8d800&amp;rdquo; Expires: Mon, 31 May 2010 18:04:39 GMT Cache-Control: max-age=31536000, public
1.  ETags are commonly enclosed in quotation marks, but the quotation marks are part of the value. That means you need to send the quotation marks back to the server in the If-None-Match header.
Python’s HTTP libraries do not support ETags, but httplib2 does.&lt;/p&gt;

&lt;p&gt;14.2.4. COMPRESSION&lt;/p&gt;

&lt;p&gt;When you talk about HTTP web services, you’re almost always talking about moving text-based data back and forth over the wire. Maybe it’s XML, maybe it’s JSON, maybe it’s just plain
text. Regardless of the format, text compresses well. The example feed in the
XML
chapter
is 3070 bytes uncompressed, but would be 941 bytes after gzip compression. That’s just 30% of the original size!
HTTP supports several
compression
algorithms. The two most common types are gzip
and deflate. When you request a resource over HTTP, you can ask the server to send it in compressed format. You include an Accept-encoding header in your request that lists which compression algorithms you support. If the server supports any of the same algorithms, it will send you back compressed data (with a Content-encoding header that tells you which algorithm it used). Then it’s up to you to decompress the data.
. Important tip for server-side developers: make sure that the compressed version of a
resource has a different Etag
than the uncompressed version. Otherwise, caching
proxies will get confused and may serve the compressed version to clients that can’t
handle it. Read the discussion of Apache
bug
39727
for more details on this subtle
issue.&lt;/p&gt;

&lt;p&gt;Python’s HTTP libraries do not support compression, but httplib2 does.
14.2.5. REDIRECTS
Cool
URIs
don’t
change, but many URIs are seriously uncool. Web sites get reorganized, pages move to new addresses. Even web services can reorganize. A syndicated feed at &lt;a href=&#34;http://example.com/index.xml&#34;&gt;http://example.com/index.xml&lt;/a&gt; might be moved to &lt;a href=&#34;http://example.com/xml/atom.xml&#34;&gt;http://example.com/xml/atom.xml&lt;/a&gt;. Or an entire domain might move, as an organization expands and reorganizes; &lt;a href=&#34;http://www.example.com/index.xml&#34;&gt;http://www.example.com/index.xml&lt;/a&gt; becomes &lt;a href=&#34;http://server­farm-1.example.com/index.xml&#34;&gt;http://server­farm-1.example.com/index.xml&lt;/a&gt;.
Every time you request any kind of resource from an
HTTP server, the server includes a status code in its
response. Status code 200 means “everything’s normal, here’s the page you asked for”. Status code 404 means “page not found”. (You’ve probably seen 404 errors while browsing the web.) Status codes in the 300’s indicate some form of redirection.
HTTP has several different ways of signifying that a resource has moved. The two most common techiques are status codes 302 and 301. Status code 302 is a temporary redirect; it means “oops, that got moved over&lt;/p&gt;

&lt;p&gt;here temporarily” (and then gives the temporary address in a Location header). Status code 301 is a permanent redirect; it means “oops, that got moved permanently” (and then gives the new address in a Location header). If you get a 302 status code and a new address, the HTTP specification says you should use the new address to get what you asked for, but the next time you want to access the same resource, you should retry the old address. But if you get a 301 status code and a new address, you’re supposed to use the new address from then on.
The urllib.request module automatically “follow” redirects when it receives the appropriate status code from the HTTP server, but it doesn’t tell you that it did so. You’ll end up getting data you asked for, but you’ll never know that the underlying library “helpfully” followed a redirect for you. So you’ll continue pounding away at the old address, and each time you’ll get redirected to the new address, and each time the urllib.request module will “helpfully” follow the redirect. In other words, it treats permanent redirects the same as temporary redirects. That means two round trips instead of one, which is bad for the server and bad for you.
httplib2 handles permanent redirects for you. Not only will it tell you that a permanent redirect occurred, it will keep track of them locally and automatically rewrite redirected URLs before requesting them.
.&lt;/p&gt;

&lt;p&gt;14.3. HOW NOT TO FETCH DATA OVER HTTP&lt;/p&gt;

&lt;p&gt;Let’s say you want to download a resource over HTTP, such as an
Atom
feed. Being a feed, you’re not just going to download it once; you’re going to download it over and over again. (Most feed readers will check for changes once an hour.) Let’s do it the quick-and-dirty way first, and then see how you can do better.
&amp;gt;&amp;gt;&amp;gt; import urllib.request
&amp;gt;&amp;gt;&amp;gt; a_url = &amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed.xml&#39;&lt;/a&gt;
&amp;gt;&amp;gt;&amp;gt; data = urllib.request.urlopen(a_url).read() .
&amp;gt;&amp;gt;&amp;gt; type(data) .
&lt;class &#39;bytes&#39;&gt;
&amp;gt;&amp;gt;&amp;gt; print(data)
&amp;lt;?xml version=&amp;lsquo;1.0&amp;rsquo; encoding=&amp;lsquo;utf-8&amp;rsquo;?&amp;gt;
&lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;&gt;&lt;/p&gt;

&lt;p&gt;&lt;title&gt;dive into mark&lt;/title&gt;
&lt;subtitle&gt;currently between addictions&lt;/subtitle&gt;
&lt;id&gt;tag:diveintomark.org,2001-07-29:/&lt;/id&gt;
&lt;updated&gt;2009-03-27T21:56:07Z&lt;/updated&gt;
&lt;link rel=&#39;alternate&#39; type=&#39;text/html&#39; href=&#39;http://diveintomark.org/&#39;/&gt;
…&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Downloading anything over HTTP is incredibly easy in Python; in fact, it’s a one-liner. The urllib.request module has a handy urlopen() function that takes the address of the page you want, and returns a file-like object that you can just read() from to get the full contents of the page. It just can’t get any easier.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The urlopen().read() method always returns a
bytes object,
not
a
string. Remember, bytes are bytes; characters are an abstraction. HTTP servers don’t deal in abstractions. If you request a resource, you get bytes. If you want it as a string, you’ll need to determine
the
character
encoding
and explicitly convert it to a string.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So what’s wrong with this? For a quick one-off during testing or development, there’s nothing wrong with it. I do it all the time. I wanted the contents of the feed, and I got the contents of the feed. The same technique works for any web page. But once you start thinking in terms of a web service that you want to access on a regular basis (e.g. requesting this feed once an hour), then you’re being inefficient, and you’re being rude.
.&lt;/p&gt;

&lt;p&gt;14.4. WHAT’S ON THE WIRE?
To see why this is inefficient and rude, let’s turn on the debugging features of Python’s HTTP library and see what’s being sent “on the wire” (i.e. over the network).
&amp;gt;&amp;gt;&amp;gt; from http.client import HTTPConnection
&amp;gt;&amp;gt;&amp;gt; HTTPConnection.debuglevel = 1 .
&amp;gt;&amp;gt;&amp;gt; from urllib.request import urlopen
&amp;gt;&amp;gt;&amp;gt; response = urlopen(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed.xml&#39;&lt;/a&gt;) .
send: b&amp;rsquo;GET /examples/feed.xml HTTP/1.1 .
Host: diveintopython3.org .
Accept-Encoding: identity .
User-Agent: Python-urllib/3.1&amp;rsquo; .
Connection: close
reply: &amp;lsquo;HTTP/1.1 200 OK&amp;rsquo;
…further debugging information omitted…&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;As I mentioned at the beginning of the chapter, urllib.request relies on another standard Python library, http.client. Normally you don’t need to touch http.client directly. (The urllib.request module imports it automatically.) But we import it here so we can toggle the debugging flag on the HTTPConnection class that urllib.request uses to connect to the HTTP server.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now that the debugging flag is set, information on the HTTP request and response is printed out in real time. As you can see, when you request the Atom feed, the urllib.request module sends five lines to the server.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The first line specifies the HTTP verb you’re using, and the path of the resource (minus the domain name).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The second line specifies the domain name from which we’re requesting this feed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The third line specifies the compression algorithms that the client supports. As I mentioned earlier, urllib.request does
not
support
compression
by default.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The fourth line specifies the name of the library that is making the request. By default, this is Python-urllib plus a version number. Both urllib.request and httplib2 support changing the user agent, simply by adding a User-Agent header to the request (which will override the default value).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now let’s look at what the server sent back in its
response.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-previous-example:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;print(response.headers.as_string()) .
Date: Sun, 31 May 2009 19:23:06 GMT .
Server: Apache
Last-Modified: Sun, 31 May 2009 06:39:55 GMT .
ETag: &amp;ldquo;bfe-93d9c4c0&amp;rdquo; .
Accept-Ranges: bytes
Content-Length: 3070 .
Cache-Control: max-age=86400 .
Expires: Mon, 01 Jun 2009 19:23:06 GMT
Vary: Accept-Encoding
Connection: close
Content-Type: application/xml
data = response.read() .
len(data)
3070&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The response returned from the urllib.request.urlopen() function contains all the HTTP headers the server sent back. It also contains methods to download the actual data; we’ll get to that in a minute.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The server tells you when it handled your request.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This response includes a Last-Modified header.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This response includes an ETag header.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The data is 3070 bytes long. Notice what isn’t here: a Content-encoding header. Your request stated that you only accept uncompressed data (Accept-encoding: identity), and sure enough, this response contains uncompressed data.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This response includes caching headers that state that this feed can be cached for up to 24 hours (86400 seconds).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And finally, download the actual data by calling response.read(). As you can tell from the len() function, this downloads all 3070 bytes at once.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As you can see, this code is already inefficient: it asked for (and received) uncompressed data. I know for a fact that this server supports gzip
compression, but HTTP compression is opt-in. We didn’t ask for it, so we didn’t get it. That means we’re downloading 3070 bytes when we could have just downloaded 941. Bad dog, no biscuit.
But wait, it gets worse! To see just how inefficient this code is, let’s request the same feed a second time.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-9:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;response2 = urlopen(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed.xml&#39;&lt;/a&gt;)
send: b&amp;rsquo;GET /examples/feed.xml HTTP/1.1
Host: diveintopython3.org
Accept-Encoding: identity
User-Agent: Python-urllib/3.1&amp;rsquo;
Connection: close
reply: &amp;lsquo;HTTP/1.1 200 OK&amp;rsquo;
…further debugging information omitted…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Notice anything peculiar about this request? It hasn’t changed! It’s exactly the same as the first request. No sign of If-Modified-Since headers. No sign of If-None-Match headers. No respect for the caching headers. Still no compression.
And what happens when you do the same thing twice? You get the same response. Twice.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-10:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;print(response2.headers.as_string()) .
Date: Mon, 01 Jun 2009 03:58:00 GMT
Server: Apache
Last-Modified: Sun, 31 May 2009 22:51:11 GMT
ETag: &amp;ldquo;bfe-255ef5c0&amp;rdquo;
Accept-Ranges: bytes
Content-Length: 3070
Cache-Control: max-age=86400
Expires: Tue, 02 Jun 2009 03:58:00 GMT
Vary: Accept-Encoding
Connection: close
Content-Type: application/xml
data2 = response2.read()
len(data2) .
3070
data2 == data .
True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The server is still sending the same array of “smart” headers: Cache-Control and Expires to allow caching, Last-Modified and ETag to enable “not-modified” tracking. Even the Vary: Accept-Encoding header hints that the server would support compression, if only you would ask for it. But you didn’t.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once again, fetching this data downloads the whole 3070 bytes…&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;…the exact same 3070 bytes you downloaded last time.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HTTP is designed to work better than this. urllib speaks HTTP like I speak Spanish — enough to get by in a jam, but not enough to hold a conversation. HTTP is a conversation. It’s time to upgrade to a library that speaks HTTP fluently.
.
14.5. INTRODUCING httplib2
Before you can use httplib2, you’ll need to install it. Visit code.google.com/p/httplib2/ and download the latest version. httplib2 is available for Python 2.x and Python 3.x; make sure you get the Python 3 version, named something like httplib2-python3-0.5.0.zip.
Unzip the archive, open a terminal window, and go to the newly created httplib2 directory. On Windows, open the Start menu, select Run&amp;hellip;, type cmd.exe and press ENTER.
c:\Users\pilgrim\Downloads&amp;gt; dir
Volume in drive C has no label.
Volume Serial Number is DED5-B4F8&lt;/p&gt;

&lt;p&gt;Directory of c:\Users\pilgrim\Downloads&lt;/p&gt;

&lt;p&gt;07/28/2009 12:36 PM &lt;DIR&gt; .
07/28/2009 12:36 PM &lt;DIR&gt; ..
07/28/2009 12:36 PM &lt;DIR&gt; httplib2-python3-0.5.0
07/28/2009 12:33 PM 18,997 httplib2-python3-0.5.0.zip&lt;/p&gt;

&lt;p&gt;1 File(s) 18,997 bytes
3 Dir(s) 61,496,684,544 bytes free&lt;/p&gt;

&lt;p&gt;c:\Users\pilgrim\Downloads&amp;gt; cd httplib2-python3-0.5.0
c:\Users\pilgrim\Downloads\httplib2-python3-0.5.0&amp;gt; c:\python31\python.exe setup.py install
running install
running build
running build_py
running install_lib
creating c:\python31\Lib\site-packages\httplib2
copying build\lib\httplib2\iri2uri.py -&amp;gt; c:\python31\Lib\site-packages\httplib2
copying build\lib\httplib2__init&lt;strong&gt;.py -&amp;gt; c:\python31\Lib\site-packages\httplib2
byte-compiling c:\python31\Lib\site-packages\httplib2\iri2uri.py to iri2uri.pyc
byte-compiling c:\python31\Lib\site-packages\httplib2__init&lt;/strong&gt;.py to &lt;strong&gt;init&lt;/strong&gt;.pyc
running install_egg_info
Writing c:\python31\Lib\site-packages\httplib2-python3_0.5.0-py3.1.egg-info&lt;/p&gt;

&lt;p&gt;On Mac OS X, run the Terminal.app application in your /Applications/Utilities/ folder. On Linux, run the Terminal application, which is usually in your Applications menu under Accessories or System.
you@localhost:~/Desktop$ unzip httplib2-python3-0.5.0.zip&lt;/p&gt;

&lt;p&gt;Archive: httplib2-python3-0.5.0.zip&lt;/p&gt;

&lt;p&gt;inflating: httplib2-python3-0.5.0/README&lt;/p&gt;

&lt;p&gt;inflating: httplib2-python3-0.5.0/setup.py&lt;/p&gt;

&lt;p&gt;inflating: httplib2-python3-0.5.0/PKG-INFO&lt;/p&gt;

&lt;p&gt;inflating: httplib2-python3-0.5.0/httplib2/&lt;strong&gt;init&lt;/strong&gt;.py&lt;/p&gt;

&lt;p&gt;inflating: httplib2-python3-0.5.0/httplib2/iri2uri.py&lt;/p&gt;

&lt;p&gt;you@localhost:~/Desktop$ cd httplib2-python3-0.5.0/&lt;/p&gt;

&lt;p&gt;you@localhost:~/Desktop/httplib2-python3-0.5.0$ sudo python3 setup.py install&lt;/p&gt;

&lt;p&gt;running install&lt;/p&gt;

&lt;p&gt;running build&lt;/p&gt;

&lt;p&gt;running build_py&lt;/p&gt;

&lt;p&gt;creating build&lt;/p&gt;

&lt;p&gt;creating build/lib.linux-x86_64-3.1&lt;/p&gt;

&lt;p&gt;creating build/lib.linux-x86_64-3.1/httplib2&lt;/p&gt;

&lt;p&gt;copying httplib2/iri2uri.py -&amp;gt; build/lib.linux-x86_64-3.1/httplib2&lt;/p&gt;

&lt;p&gt;copying httplib2/&lt;strong&gt;init&lt;/strong&gt;.py -&amp;gt; build/lib.linux-x86_64-3.1/httplib2&lt;/p&gt;

&lt;p&gt;running install_lib&lt;/p&gt;

&lt;p&gt;creating /usr/local/lib/python3.1/dist-packages/httplib2&lt;/p&gt;

&lt;p&gt;copying build/lib.linux-x86_64-3.1/httplib2/iri2uri.py -&amp;gt; /usr/local/lib/python3.1/dist-packages/httplib2&lt;/p&gt;

&lt;p&gt;copying build/lib.linux-x86_64-3.1/httplib2/&lt;strong&gt;init&lt;/strong&gt;.py -&amp;gt; /usr/local/lib/python3.1/dist-packages/httplib2&lt;/p&gt;

&lt;p&gt;byte-compiling /usr/local/lib/python3.1/dist-packages/httplib2/iri2uri.py to iri2uri.pyc&lt;/p&gt;

&lt;p&gt;byte-compiling /usr/local/lib/python3.1/dist-packages/httplib2/&lt;strong&gt;init&lt;/strong&gt;.py to &lt;strong&gt;init&lt;/strong&gt;.pyc&lt;/p&gt;

&lt;p&gt;running install_egg_info&lt;/p&gt;

&lt;p&gt;Writing /usr/local/lib/python3.1/dist-packages/httplib2-python3_0.5.0.egg-info&lt;/p&gt;

&lt;p&gt;To use httplib2, create an instance of the httplib2.Http class.
&amp;gt;&amp;gt;&amp;gt; import httplib2
&amp;gt;&amp;gt;&amp;gt; h = httplib2.Http(&amp;lsquo;.cache&amp;rsquo;) .
&amp;gt;&amp;gt;&amp;gt; response, content = h.request(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed.xml&#39;&lt;/a&gt;) .
&amp;gt;&amp;gt;&amp;gt; response.status .
200
&amp;gt;&amp;gt;&amp;gt; content[:52] .
b&amp;rdquo;&amp;lt;?xml version=&amp;lsquo;1.0&amp;rsquo; encoding=&amp;lsquo;utf-8&amp;rsquo;?&amp;gt;\r\n&lt;feed xmlns=&#34; 
&gt;&amp;gt;&amp;gt; len(content)
3070&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The primary interface to httplib2 is the Http object. For reasons you’ll see in the next section, you should always pass a directory name when you create an Http object. The directory does not need to exist; httplib2 will create it if necessary.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once you have an Http object, retrieving data is as simple as calling the request() method with the address of the data you want. This will issue an HTTP GET request for that URL. (Later in this chapter, you’ll see how to issue other HTTP requests, like POST.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The request() method returns two values. The first is an httplib2.Response object, which contains all the HTTP headers the server returned. For example, a status code of 200 indicates that the request was successful.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The content variable contains the actual data that was returned by the HTTP server. The data is returned as a
bytes object,
not
a
string. If you want it as a string, you’ll need to determine
the
character
encoding
and convert it yourself.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. You probably only need one httplib2.Http object. There are valid reasons for creating more than one, but you should only do so if you know why you need them. “I need to request data from two different URLs” is not a valid reason. Re-use the Http object and just call the request() method twice.&lt;/p&gt;

&lt;p&gt;14.5.1. A SHORT DIGRESSION TO EXPLAIN WHY httplib2 RETURNS BYTES INSTEAD OF STRINGS
Bytes. Strings. What a pain. Why can’t httplib2 “just” do the conversion for you? Well, it’s complicated, because the rules for determining the character encoding are specific to what kind of resource you’re requesting. How could httplib2 know what kind of resource you’re requesting? It’s usually listed in the Content-Type HTTP header, but that’s an optional feature of HTTP and not all HTTP servers include it. If that header is not included in the HTTP response, it’s left up to the client to guess. (This is commonly called “content sniffing,” and it’s never perfect.)
If you know what sort of resource you’re expecting (an XML document in this case), perhaps you could “just” pass the returned bytes object to the xml.etree.ElementTree.parse() function. That’ll work as long as the XML document includes information on its own character encoding (as this one does), but that’s an optional feature and not all XML documents do that. If an XML document doesn’t include encoding information, the client is supposed to look at the enclosing transport — i.e. the Content-Type HTTP header, which can include a charset parameter.
But it’s worse than that. Now character encoding information can be in two
places: within the XML document itself, and within the Content-Type HTTP
header. If the information is in both places, which one wins? According to RFC&lt;/p&gt;

&lt;p&gt;3023
(I swear I am not making this up), if the media type given in the Content-
Type HTTP header is application/xml, application/xml-dtd, application/
xml-external-parsed-entity, or any one of the subtypes of application/xml
such as application/atom+xml or application/rss+xml or even application/
rdf+xml, then the encoding is&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;the encoding given in the charset parameter of the Content-Type HTTP header, or&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the encoding given in the encoding attribute of the XML declaration within the document, or 3. UTF-8&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;On the other hand, if the media type given in the Content-Type HTTP header is text/xml, text/xml­external-parsed-entity, or a subtype like text/AnythingAtAll+xml, then the encoding attribute of the XML declaration within the document is ignored completely, and the encoding is&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the encoding given in the charset parameter of the Content-Type HTTP header, or&lt;/li&gt;
&lt;li&gt;us-ascii
And that’s just for XML documents. For HTML documents, web browsers have constructed such byzantine
rules
for
content-sniffing
[PDF] that we’re
still
trying
to
figure
them
all
out.
“Patches
welcome.”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;14.5.2. HOW httplib2 HANDLES CACHING
Remember in the previous section when I said you should always create an httplib2.Http object with a directory name? Caching is the reason.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-11:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;response2, content2 = h.request(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed.xml&#39;&lt;/a&gt;) .
response2.status .
200
content2[:52] .
b&amp;rdquo;&amp;lt;?xml version=&amp;lsquo;1.0&amp;rsquo; encoding=&amp;lsquo;utf-8&amp;rsquo;?&amp;gt;\r\n&amp;lt;feed xmlns=&amp;rdquo;
len(content2)
3070&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This shouldn’t be terribly surprising. It’s the same thing you did last time, except you’re putting the result into two new variables.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The HTTP status is once again 200, just like last time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The downloaded content is the same as last time, too.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So… who cares? Quit your Python interactive shell and relaunch it with a new session, and I’ll show you.&lt;/p&gt;

&lt;h1 id=&#34;not-continued-from-previous-example:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;NOT continued from previous example!&lt;/h1&gt;

&lt;h1 id=&#34;please-exit-out-of-the-interactive-shell:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;Please exit out of the interactive shell&lt;/h1&gt;

&lt;h1 id=&#34;and-launch-a-new-one:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;and launch a new one.&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import httplib2
httplib2.debuglevel = 1 .
h = httplib2.Http(&amp;lsquo;.cache&amp;rsquo;) .
response, content = h.request(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed.xml&#39;&lt;/a&gt;) .
len(content) .
3070
response.status .
200
response.fromcache .
True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Let’s turn on debugging and see what’s
on
the
wire. This is the httplib2 equivalent of turning on debugging in http.client. httplib2 will print all the data being sent to the server and some key information being sent back.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create an httplib2.Http object with the same directory name as before.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Request the same URL as before. Nothing appears to happen. More precisely, nothing gets sent to the server, and nothing gets returned from the server. There is absolutely no network activity whatsoever.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Yet we did “receive” some data — in fact, we received all of it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We also “received” an HTTP status code indicating that the “request” was successful.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Here’s the rub: this “response” was generated from httplib2’s local cache. That directory name you passed in when you created the httplib2.Http object — that directory holds httplib2’s cache of all the operations it’s ever performed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. If you want to turn on httplib2 debugging, you need to set a module-level constant
(httplib2.debuglevel), then create a new httplib2.Http object. If you want to turn off debugging, you need to change the same module-level constant, then create a new httplib2.Http object.
You previously requested the data at this URL. That request was successful (status: 200). That response included not only the feed data, but also a set of caching
headers
that told anyone who was listening that they could cache this resource for up to 24 hours (Cache­&lt;/p&gt;

&lt;p&gt;Control: max-age=86400, which is 24 hours measured in seconds). httplib2 understand and respects those caching headers, and it stored the previous response in the .cache directory (which you passed in when you create the Http object). That cache hasn’t expired yet, so the second time you request the data at this URL, httplib2 simply returns the cached result without ever hitting the network.
I say “simply,” but obviously there is a lot of complexity hidden behind that simplicity. httplib2 handles HTTP caching automatically and by default. If for some reason you need to know whether a response came from the cache, you can check response.fromcache. Otherwise, it Just Works.
Now, suppose you have data cached, but you want to bypass the cache and re-request it from the remote server. Browsers sometimes do this if the user specifically requests it. For example, pressing F5 refreshes the current page, but pressing Ctrl+F5 bypasses the cache and re-requests the current page from the remote server. You might think “oh, I’ll just delete the data from my local cache, then request it again.” You could do that, but remember that there may be more parties involved than just you and the remote server. What about those intermediate proxy servers? They’re completely beyond your control, and they may still have that data cached, and will happily return it to you because (as far as they are concerned) their cache is still valid.
Instead of manipulating your local cache and hoping for the best, you should use the features of HTTP to ensure that your request actually reaches the remote server.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-12:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;response2, content2 = h.request(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed.xml&#39;&lt;/a&gt;,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;hellip;  headers={&amp;lsquo;cache-control&amp;rsquo;:&amp;lsquo;no-cache&amp;rsquo;})  .&lt;br /&gt;
connect: (diveintopython3.org, 80)  .&lt;br /&gt;
send: b&amp;rsquo;GET /examples/feed.xml HTTP/1.1&lt;br /&gt;
Host: diveintopython3.org&lt;br /&gt;
user-agent: Python-httplib2/$Rev: 259 $&lt;br /&gt;
accept-encoding: deflate, gzip&lt;br /&gt;
cache-control: no-cache&amp;rsquo;&lt;br /&gt;
reply: &amp;lsquo;HTTP/1.1 200 OK&amp;rsquo;&lt;br /&gt;
…further debugging information omitted…&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; response2.status&lt;br /&gt;
200&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; response2.fromcache  .&lt;br /&gt;
False&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; print(dict(response2.items()))  .&lt;br /&gt;
{&amp;lsquo;status&amp;rsquo;: &amp;lsquo;200&amp;rsquo;,&lt;br /&gt;
&amp;lsquo;content-length&amp;rsquo;: &amp;lsquo;3070&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;content-location&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed.xml&#39;&lt;/a&gt;,
&amp;lsquo;accept-ranges&amp;rsquo;: &amp;lsquo;bytes&amp;rsquo;,
&amp;lsquo;expires&amp;rsquo;: &amp;lsquo;Wed, 03 Jun 2009 00:40:26 GMT&amp;rsquo;,
&amp;lsquo;vary&amp;rsquo;: &amp;lsquo;Accept-Encoding&amp;rsquo;,
&amp;lsquo;server&amp;rsquo;: &amp;lsquo;Apache&amp;rsquo;,
&amp;lsquo;last-modified&amp;rsquo;: &amp;lsquo;Sun, 31 May 2009 22:51:11 GMT&amp;rsquo;,
&amp;lsquo;connection&amp;rsquo;: &amp;lsquo;close&amp;rsquo;,
&amp;lsquo;-content-encoding&amp;rsquo;: &amp;lsquo;gzip&amp;rsquo;,
&amp;lsquo;etag&amp;rsquo;: &amp;lsquo;&amp;ldquo;bfe-255ef5c0&amp;rdquo;&amp;rsquo;,
&amp;lsquo;cache-control&amp;rsquo;: &amp;lsquo;max-age=86400&amp;rsquo;,
&amp;lsquo;date&amp;rsquo;: &amp;lsquo;Tue, 02 Jun 2009 00:40:26 GMT&amp;rsquo;,
&amp;lsquo;content-type&amp;rsquo;: &amp;lsquo;application/xml&amp;rsquo;}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;httplib2 allows you to add arbitrary HTTP headers to any outgoing request. In order to bypass all caches (not just your local disk cache, but also any caching proxies between you and the remote server), add a no-cache header in the headers dictionary.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now you see httplib2 initiating a network request. httplib2 understands and respects caching headers in both directions — as part of the incoming response and as part of the outgoing request. It noticed that you added the no-cache header, so it bypassed its local cache altogether and then had no choice but to hit the network to request the data.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This response was not generated from your local cache. You knew that, of course, because you saw the debugging information on the outgoing request. But it’s nice to have that programmatically verified.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The request succeeded; you downloaded the entire feed again from the remote server. Of course, the server also sent back a full complement of HTTP headers along with the feed data. That includes caching headers, which httplib2 uses to update its local cache, in the hopes of avoiding network access the next time you request this feed. Everything about HTTP caching is designed to maximize cache hits and minimize network access. Even though you bypassed the cache this time, the remote server would really appreciate it if you would cache the result for next time.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;14.5.3. HOW httplib2 HANDLES Last-Modified AND ETag HEADERS
The Cache-Control and Expires caching
headers
are called freshness indicators. They tell caches in no uncertain terms that you can completely avoid all network access until the cache expires. And that’s exactly the behavior you saw in
the
previous
section: given a freshness indicator, httplib2 does not generate a single byte of network activity to serve up cached data (unless you explicitly bypass
the
cache, of course).
But what about the case where the data might have changed, but hasn’t? HTTP defines Last-Modified and Etag headers for this purpose. These headers are called validators. If the local cache is no longer fresh, a client can send the validators with the next request to see if the data has actually changed. If the data hasn’t changed, the server sends back a 304 status code and no data. So there’s still a round-trip over the network, but you end up downloading fewer bytes.
&amp;gt;&amp;gt;&amp;gt; import httplib2&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;httplib2.debuglevel = 1&lt;/p&gt;

&lt;p&gt;h = httplib2.Http(&amp;lsquo;.cache&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;response, content = h.request(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/&#39;&#34;&gt;http://diveintopython3.org/&#39;&lt;/a&gt;) .
connect: (diveintopython3.org, 80)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;send: b&amp;rsquo;GET / HTTP/1.1&lt;/p&gt;

&lt;p&gt;Host: diveintopython3.org&lt;/p&gt;

&lt;p&gt;accept-encoding: deflate, gzip&lt;/p&gt;

&lt;p&gt;user-agent: Python-httplib2/$Rev: 259 $&amp;rsquo;&lt;/p&gt;

&lt;p&gt;reply: &amp;lsquo;HTTP/1.1 200 OK&amp;rsquo;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;print(dict(response.items()))   .
{&amp;lsquo;-content-encoding&amp;rsquo;: &amp;lsquo;gzip&amp;rsquo;,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;lsquo;accept-ranges&amp;rsquo;: &amp;lsquo;bytes&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;connection&amp;rsquo;: &amp;lsquo;close&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;content-length&amp;rsquo;: &amp;lsquo;6657&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;content-location&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/&#39;&#34;&gt;http://diveintopython3.org/&#39;&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;content-type&amp;rsquo;: &amp;lsquo;text/html&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;date&amp;rsquo;: &amp;lsquo;Tue, 02 Jun 2009 03:26:54 GMT&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;etag&amp;rsquo;: &amp;lsquo;&amp;ldquo;7f806d-1a01-9fb97900&amp;rdquo;&amp;rsquo;,
&amp;lsquo;last-modified&amp;rsquo;: &amp;lsquo;Tue, 02 Jun 2009 02:51:48 GMT&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;server&amp;rsquo;: &amp;lsquo;Apache&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;status&amp;rsquo;: &amp;lsquo;200&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;vary&amp;rsquo;: &amp;lsquo;Accept-Encoding,User-Agent&amp;rsquo;}&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;len(content)    .
6657&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Instead of the feed, this time we’re going to download the site’s home page, which is HTML. Since this is the first time you’ve ever requested this page, httplib2 has little to work with, and it sends out a minimum of headers with the request.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The response contains a multitude of HTTP headers… but no caching information. However, it does include both an ETag and Last-Modified header.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;At the time I constructed this example, this page was 6657 bytes. It’s probably changed since then, but don’t worry about it.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-13:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;response, content = h.request(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/&#39;&#34;&gt;http://diveintopython3.org/&#39;&lt;/a&gt;) .
connect: (diveintopython3.org, 80)
send: b&amp;rsquo;GET / HTTP/1.1
Host: diveintopython3.org
if-none-match: &amp;ldquo;7f806d-1a01-9fb97900&amp;rdquo; .
if-modified-since: Tue, 02 Jun 2009 02:51:48 GMT .
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $&amp;rsquo;
reply: &amp;lsquo;HTTP/1.1 304 Not Modified&amp;rsquo; .
response.fromcache .
True
response.status .
200
response.dict[&amp;lsquo;status&amp;rsquo;] .
&amp;lsquo;304&amp;rsquo;
len(content) .
6657&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You request the same page again, with the same Http object (and the same local cache).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;httplib2 sends the ETag validator back to the server in the If-None-Match header.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;httplib2 also sends the Last-Modified validator back to the server in the If-Modified-Since header.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The server looked at these validators, looked at the page you requested, and determined that the page has not changed since you last requested it, so it sends back a 304 status code and no data.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Back on the client, httplib2 notices the 304 status code and loads the content of the page from its cache.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This might be a bit confusing. There are really two status codes — 304 (returned from the server this time, which caused httplib2 to look in its cache), and 200 (returned from the server last time, and stored in httplib2’s cache along with the page data). response.status returns the status from the cache.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you want the raw status code returned from the server, you can get that by looking in response.dict, which is a dictionary of the actual headers returned from the server.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;However, you still get the data in the content variable. Generally, you don’t need to know why a response was served from the cache. (You may not even care that it was served from the cache at all, and that’s fine too. httplib2 is smart enough to let you act dumb.) By the time the request() method returns to the caller, httplib2 has already updated its cache and returned the data to you.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;14.5.4. HOW http2lib HANDLES COMPRESSION
HTTP supports several
types
of
compression; the two most common types are gzip and deflate. httplib2 supports both of these.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;response, content = h.request(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/&#39;&#34;&gt;http://diveintopython3.org/&#39;&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;connect: (diveintopython3.org, 80)
send: b&amp;rsquo;GET / HTTP/1.1
Host: diveintopython3.org
accept-encoding: deflate, gzip .
user-agent: Python-httplib2/$Rev: 259 $&amp;rsquo;
reply: &amp;lsquo;HTTP/1.1 200 OK&amp;rsquo;
&amp;gt;&amp;gt;&amp;gt; print(dict(response.items()))
{&amp;lsquo;-content-encoding&amp;rsquo;: &amp;lsquo;gzip&amp;rsquo;, .&lt;/p&gt;

&lt;p&gt;&amp;lsquo;accept-ranges&amp;rsquo;: &amp;lsquo;bytes&amp;rsquo;,
&amp;lsquo;connection&amp;rsquo;: &amp;lsquo;close&amp;rsquo;,
&amp;lsquo;content-length&amp;rsquo;: &amp;lsquo;6657&amp;rsquo;,
&amp;lsquo;content-location&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/&#39;&#34;&gt;http://diveintopython3.org/&#39;&lt;/a&gt;,
&amp;lsquo;content-type&amp;rsquo;: &amp;lsquo;text/html&amp;rsquo;,
&amp;lsquo;date&amp;rsquo;: &amp;lsquo;Tue, 02 Jun 2009 03:26:54 GMT&amp;rsquo;,
&amp;lsquo;etag&amp;rsquo;: &amp;lsquo;&amp;ldquo;7f806d-1a01-9fb97900&amp;rdquo;&amp;rsquo;,
&amp;lsquo;last-modified&amp;rsquo;: &amp;lsquo;Tue, 02 Jun 2009 02:51:48 GMT&amp;rsquo;,
&amp;lsquo;server&amp;rsquo;: &amp;lsquo;Apache&amp;rsquo;,
&amp;lsquo;status&amp;rsquo;: &amp;lsquo;304&amp;rsquo;,
&amp;lsquo;vary&amp;rsquo;: &amp;lsquo;Accept-Encoding,User-Agent&amp;rsquo;}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Every time httplib2 sends a request, it includes an Accept-Encoding header to tell the server that it can handle either deflate or gzip compression.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In this case, the server has responded with a gzip-compressed payload. By the time the request() method returns, httplib2 has already decompressed the body of the response and placed it in the content variable. If you’re curious about whether or not the response was compressed, you can check response[&amp;lsquo;-content­encoding&amp;rsquo;]; otherwise, don’t worry about it.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;14.5.5. HOW httplib2 HANDLES REDIRECTS
HTTP defines two
kinds
of
redirects: temporary and permanent. There’s nothing special to do with
temporary redirects except follow them, which httplib2 does automatically.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import httplib2
httplib2.debuglevel = 1
h = httplib2.Http(&amp;lsquo;.cache&amp;rsquo;)
response, content = h.request(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed-302.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed-302.xml&#39;&lt;/a&gt;) .
connect: (diveintopython3.org, 80)
send: b&amp;rsquo;GET /examples/feed-302.xml HTTP/1.1 .
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $&amp;rsquo;
reply: &amp;lsquo;HTTP/1.1 302 Found&amp;rsquo; .
send: b&amp;rsquo;GET /examples/feed.xml HTTP/1.1 .
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $&amp;rsquo;
reply: &amp;lsquo;HTTP/1.1 200 OK&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;There is no feed at this URL. I’ve set up my server to issue a temporary redirect to the correct address.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There’s the request.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And there’s the response: 302 Found. Not shown here, this response also includes a Location header that points to the real URL.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;httplib2 immediately turns around and “follows” the redirect by issuing another request for the URL given in the Location header: &lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#34;&gt;http://diveintopython3.org/examples/feed.xml&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;“Following” a redirect is nothing more than this example shows. httplib2 sends a request for the URL you asked for. The server comes back with a response that says “No no, look over there instead.” httplib2 sends another request for the new URL.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-14:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;response .
{&amp;lsquo;status&amp;rsquo;: &amp;lsquo;200&amp;rsquo;,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;lsquo;content-length&amp;rsquo;: &amp;lsquo;3070&amp;rsquo;,
&amp;lsquo;content-location&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed.xml&#39;&lt;/a&gt;, .
&amp;lsquo;accept-ranges&amp;rsquo;: &amp;lsquo;bytes&amp;rsquo;,
&amp;lsquo;expires&amp;rsquo;: &amp;lsquo;Thu, 04 Jun 2009 02:21:41 GMT&amp;rsquo;,
&amp;lsquo;vary&amp;rsquo;: &amp;lsquo;Accept-Encoding&amp;rsquo;,
&amp;lsquo;server&amp;rsquo;: &amp;lsquo;Apache&amp;rsquo;,
&amp;lsquo;last-modified&amp;rsquo;: &amp;lsquo;Wed, 03 Jun 2009 02:20:15 GMT&amp;rsquo;,
&amp;lsquo;connection&amp;rsquo;: &amp;lsquo;close&amp;rsquo;,
&amp;lsquo;-content-encoding&amp;rsquo;: &amp;lsquo;gzip&amp;rsquo;, .
&amp;lsquo;etag&amp;rsquo;: &amp;lsquo;&amp;ldquo;bfe-4cbbf5c0&amp;rdquo;&amp;rsquo;,
&amp;lsquo;cache-control&amp;rsquo;: &amp;lsquo;max-age=86400&amp;rsquo;, .
&amp;lsquo;date&amp;rsquo;: &amp;lsquo;Wed, 03 Jun 2009 02:21:41 GMT&amp;rsquo;,
&amp;lsquo;content-type&amp;rsquo;: &amp;lsquo;application/xml&amp;rsquo;}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The response you get back from this single call to the request() method is the response from the final URL.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;httplib2 adds the final URL to the response dictionary, as content-location. This is not a header that came from the server; it’s specific to httplib2.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Apropos of nothing, this feed is compressed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And cacheable. (This is important, as you’ll see in a minute.)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The response you get back gives you information about the final URL. What if you want more information about the intermediate URLs, the ones that eventually redirected to the final URL? httplib2 lets you do that, too.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-15:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;response.previous .
{&amp;lsquo;status&amp;rsquo;: &amp;lsquo;302&amp;rsquo;,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;lsquo;content-length&amp;rsquo;: &amp;lsquo;228&amp;rsquo;,
&amp;lsquo;content-location&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed-302.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed-302.xml&#39;&lt;/a&gt;,
&amp;lsquo;expires&amp;rsquo;: &amp;lsquo;Thu, 04 Jun 2009 02:21:41 GMT&amp;rsquo;,
&amp;lsquo;server&amp;rsquo;: &amp;lsquo;Apache&amp;rsquo;,
&amp;lsquo;connection&amp;rsquo;: &amp;lsquo;close&amp;rsquo;,
&amp;lsquo;location&amp;rsquo;: &amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed.xml&#39;&lt;/a&gt;,
&amp;lsquo;cache-control&amp;rsquo;: &amp;lsquo;max-age=86400&amp;rsquo;,
&amp;lsquo;date&amp;rsquo;: &amp;lsquo;Wed, 03 Jun 2009 02:21:41 GMT&amp;rsquo;,
&amp;lsquo;content-type&amp;rsquo;: &amp;lsquo;text/html; charset=iso-8859-1&amp;rsquo;}&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;type(response) .
&lt;class &#39;httplib2.Response&#39;&gt;
type(response.previous)
&lt;class &#39;httplib2.Response&#39;&gt;
response.previous.previous .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;The response.previous attribute holds a reference to the previous response object that httplib2 followed to get to the current response object.&lt;/li&gt;
&lt;li&gt;Both response and response.previous are httplib2.Response objects.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That means you can check response.previous.previous to follow the redirect chain backwards even further. (Scenario: one URL redirects to a second URL which redirects to a third URL. It could happen!) In this case, we’ve already reached the beginning of the redirect chain, so the attribute is None.
What happens if you request the same URL again?&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-16:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;response2, content2 = h.request(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed-302.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed-302.xml&#39;&lt;/a&gt;) .
connect: (diveintopython3.org, 80)
send: b&amp;rsquo;GET /examples/feed-302.xml HTTP/1.1 .
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $&amp;rsquo;
reply: &amp;lsquo;HTTP/1.1 302 Found&amp;rsquo; .
content2 == content .
True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Same URL, same httplib2.Http object (and therefore the same cache).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The 302 response was not cached, so httplib2 sends another request for the same URL.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once again, the server responds with a 302. But notice what didn’t happen: there wasn’t ever a second request for the final URL, &lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#34;&gt;http://diveintopython3.org/examples/feed.xml&lt;/a&gt;. That response was cached (remember the Cache-Control header that you saw in the previous example). Once httplib2 received the 302 Found code, it checked its cache before issuing another request. The cache contained a fresh copy of &lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#34;&gt;http://diveintopython3.org/examples/feed.xml&lt;/a&gt;, so there was no need to re-request it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;By the time the request() method returns, it has read the feed data from the cache and returned it. Of course, it’s the same as the data you received last time.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In other words, you don’t have to do anything special for temporary redirects. httplib2 will follow them automatically, and the fact that one URL redirects to another has no bearing on httplib2’s support for compression, caching, ETags, or any of the other features of HTTP.
Permanent redirects are just as simple.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-17:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;response, content = h.request(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed-301.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed-301.xml&#39;&lt;/a&gt;) .
connect: (diveintopython3.org, 80)
send: b&amp;rsquo;GET /examples/feed-301.xml HTTP/1.1
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $&amp;rsquo;
reply: &amp;lsquo;HTTP/1.1 301 Moved Permanently&amp;rsquo; .
response.fromcache .
True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Once again, this URL doesn’t really exist. I’ve set up my server to issue a permanent redirect to &lt;a href=&#34;http://diveintopython3.org/examples/feed.xml&#34;&gt;http://diveintopython3.org/examples/feed.xml&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And here it is: status code 301. But again, notice what didn’t happen: there was no request to the redirect URL. Why not? Because it’s already cached locally.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;httplib2 “followed” the redirect right into its cache.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;But wait! There’s more!&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-18:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;response2, content2 = h.request(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/examples/feed-301.xml&#39;&#34;&gt;http://diveintopython3.org/examples/feed-301.xml&#39;&lt;/a&gt;) .
response2.fromcache .
True
content2 == content .
True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Here’s the difference between temporary and permanent redirects: once httplib2 follows a permanent redirect, all further requests for that URL will transparently be rewritten to the target URL without hitting the network for the original URL . Remember, debugging is still turned on, yet there is no output of network activity whatsoever.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Yep, this response was retrieved from the local cache.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Yep, you got the entire feed (from the cache).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HTTP. It works.
.&lt;/p&gt;

&lt;p&gt;14.6. BEYOND HTTP GET
HTTP web services are not limited to GET requests. What if you want to create something new? Whenever you post a comment on a discussion forum, update your weblog, publish your status on a microblogging service like Twitter
or Identi.ca, you’re probably already using HTTP POST.
Both Twitter and Identi.ca both offer a simple HTTP-based API for publishing and updating your status in 140 characters or less. Let’s look at Identi.ca’s
API
documentation
for
updating
your
status:&lt;/p&gt;

&lt;p&gt;Identi.ca REST API Method: statuses/update
Updates the authenticating user’s status. Requires the status parameter specified below. Request must be a POST.
URL
&lt;a href=&#34;https://identi.ca/api/statuses/update.format&#34;&gt;https://identi.ca/api/statuses/update.format&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Formats
xml, json, rss, atom
HTTP Method(s)
POST&lt;/p&gt;

&lt;p&gt;Requires Authentication
true
Parameters
status. Required. The text of your status update. URL-encode as necessary.
How does this work? To publish a new message on Identi.ca, you need to issue an HTTP POST request to &lt;a href=&#34;http://identi.ca/api/statuses/update.format&#34;&gt;http://identi.ca/api/statuses/update.format&lt;/a&gt;. (The format bit is not part of the URL; you replace it with the data format you want the server to return in response to your request. So if you want a response in XML, you would post the request to &lt;a href=&#34;https://identi.ca/api/statuses/update.xml.&#34;&gt;https://identi.ca/api/statuses/update.xml.&lt;/a&gt;) The request needs to include a parameter called status, which contains the text of your status update. And the request needs to be authenticated.
Authenticated? Sure. To update your status on Identi.ca, you need to prove who you are. Identi.ca is not a wiki; only you can update your own status. Identi.ca uses HTTP
Basic
Authentication
(a.k.a. RFC
2617) over SSL to provide secure but easy-to-use authentication. httplib2 supports both SSL and HTTP Basic Authentication, so this part is easy.
A POST request is different from a GET request, because it includes a payload. The payload is the data you want to send to the server. The one piece of data that this API method requires is status, and it should be URL-encoded. This is a very simple serialization format that takes a set of key-value pairs (i.e. a dictionary) and transforms it into a string.
&amp;gt;&amp;gt;&amp;gt; from urllib.parse import urlencode .
&amp;gt;&amp;gt;&amp;gt; data = {&amp;lsquo;status&amp;rsquo;: &amp;lsquo;Test update from Python 3&amp;rsquo;} .
&amp;gt;&amp;gt;&amp;gt; urlencode(data) .
&amp;lsquo;status=Test+update+from+Python+3&amp;rsquo;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Python comes with a utility function to URL-encode a dictionary: urllib.parse.urlencode().&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is the sort of dictionary that the Identi.ca API is looking for. It contains one key, status, whose value is the text of a single status update.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is what the URL-encoded string looks like. This is the payload that will be sent “on the wire” to the Identi.ca API server in your HTTP POST request.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;from urllib.parse import urlencode
import httplib2
httplib2.debuglevel = 1
h = httplib2.Http(&amp;lsquo;.cache&amp;rsquo;)
data = {&amp;lsquo;status&amp;rsquo;: &amp;lsquo;Test update from Python 3&amp;rsquo;}
h.add_credentials(&amp;lsquo;diveintomark&amp;rsquo;, &amp;lsquo;MY_SECRET_PASSWORD&amp;rsquo;, &amp;lsquo;identi.ca&amp;rsquo;) .
resp, content = h.request(&amp;lsquo;&lt;a href=&#34;https://identi.ca/api/statuses/update.xml&#39;&#34;&gt;https://identi.ca/api/statuses/update.xml&#39;&lt;/a&gt;,
&amp;hellip; &amp;lsquo;POST&amp;rsquo;, .
&amp;hellip; urlencode(data), .
&amp;hellip; headers={&amp;lsquo;Content-Type&amp;rsquo;: &amp;lsquo;application/x-www-form-urlencoded&amp;rsquo;}) .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This is how httplib2 handles authentication. Store your username and password with the add_credentials() method. When httplib2 tries to issue the request, the server will respond with a 401 Unauthorized status code, and it will list which authentication methods it supports (in the WWW-Authenticate header). httplib2 will automatically construct an Authorization header and re-request the URL.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The second parameter is the type of HTTP request, in this case POST.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The third parameter is the payload to send to the server. We’re sending the URL-encoded dictionary with a status message.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, we need to tell the server that the payload is URL-encoded data.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. The third parameter to the add_credentials() method is the domain in which the credentials are valid. You should always specify this! If you leave out the domain and later reuse the httplib2.Http object on a different authenticated site, httplib2 might end up leaking one site’s username and password to the other site.
This is what goes over the wire:&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-19:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;p&gt;send: b&amp;rsquo;POST /api/statuses/update.xml HTTP/1.1
Host: identi.ca
Accept-Encoding: identity
Content-Length: 32
content-type: application/x-www-form-urlencoded
user-agent: Python-httplib2/$Rev: 259 $&lt;/p&gt;

&lt;p&gt;status=Test+update+from+Python+3&amp;rsquo;
reply: &amp;lsquo;HTTP/1.1 401 Unauthorized&amp;rsquo; .
send: b&amp;rsquo;POST /api/statuses/update.xml HTTP/1.1 .
Host: identi.ca
Accept-Encoding: identity
Content-Length: 32
content-type: application/x-www-form-urlencoded
authorization: Basic SECRET_HASH_CONSTRUCTED_BY_HTTPLIB2 .
user-agent: Python-httplib2/$Rev: 259 $&lt;/p&gt;

&lt;p&gt;status=Test+update+from+Python+3&amp;rsquo;
reply: &amp;lsquo;HTTP/1.1 200 OK&amp;rsquo; .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;After the first request, the server responds with a 401 Unauthorized status code. httplib2 will never send authentication headers unless the server explicitly asks for them. This is how the server asks for them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;httplib2 immediately turns around and requests the same URL a second time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This time, it includes the username and password that you added with the add_credentials() method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It worked!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What does the server send back after a successful request? That depends entirely on the web service API. In some protocols (like the Atom
Publishing
Protocol), the server sends back a 201 Created status code and the location of the newly created resource in the Location header. Identi.ca sends back a 200 OK and an XML document containing information about the newly created resource.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-20:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;print(content.decode(&amp;lsquo;utf-8&amp;rsquo;)) .
&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&amp;gt;
&lt;status&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;text&gt;Test update from Python 3&lt;/text&gt; .
&lt;truncated&gt;false&lt;/truncated&gt;
&lt;created_at&gt;Wed Jun 10 03:53:46 +0000 2009&lt;/created_at&gt;
&lt;in_reply_to_status_id&gt;&lt;/in_reply_to_status_id&gt;
&lt;source&gt;api&lt;/source&gt;
&lt;id&gt;5131472&lt;/id&gt; .
&lt;in_reply_to_user_id&gt;&lt;/in_reply_to_user_id&gt;
&lt;in_reply_to_screen_name&gt;&lt;/in_reply_to_screen_name&gt;
&lt;favorited&gt;false&lt;/favorited&gt;
&lt;user&gt;&lt;/p&gt;

&lt;p&gt;&lt;id&gt;3212&lt;/id&gt;
&lt;name&gt;Mark Pilgrim&lt;/name&gt;
&lt;screen_name&gt;diveintomark&lt;/screen_name&gt;
&lt;location&gt;27502, US&lt;/location&gt;
&lt;description&gt;tech writer, husband, father&lt;/description&gt;
&lt;profile_image_url&gt;&lt;a href=&#34;http://avatar.identi.ca/3212-48-20081216000626.png&#34;&gt;http://avatar.identi.ca/3212-48-20081216000626.png&lt;/a&gt;&lt;/profile_image_url&gt;
&lt;url&gt;&lt;a href=&#34;http://diveintomark.org/&#34;&gt;http://diveintomark.org/&lt;/a&gt;&lt;/url&gt;
&lt;protected&gt;false&lt;/protected&gt;
&lt;followers_count&gt;329&lt;/followers_count&gt;
&lt;profile_background_color&gt;&lt;/profile_background_color&gt;
&lt;profile_text_color&gt;&lt;/profile_text_color&gt;
&lt;profile_link_color&gt;&lt;/profile_link_color&gt;
&lt;profile_sidebar_fill_color&gt;&lt;/profile_sidebar_fill_color&gt;
&lt;profile_sidebar_border_color&gt;&lt;/profile_sidebar_border_color&gt;
&lt;friends_count&gt;2&lt;/friends_count&gt;
&lt;created_at&gt;Wed Jul 02 22:03:58 +0000 2008&lt;/created_at&gt;
&lt;favourites_count&gt;30768&lt;/favourites_count&gt;
&lt;utc_offset&gt;0&lt;/utc_offset&gt;
&lt;time_zone&gt;UTC&lt;/time_zone&gt;
&lt;profile_background_image_url&gt;&lt;/profile_background_image_url&gt;&lt;/p&gt;

&lt;p&gt;&lt;profile_background_tile&gt;false&lt;/profile_background_tile&gt;&lt;/p&gt;

&lt;p&gt;&lt;statuses_count&gt;122&lt;/statuses_count&gt;
&lt;following&gt;false&lt;/following&gt;
&lt;notifications&gt;false&lt;/notifications&gt;&lt;/p&gt;

&lt;p&gt;&lt;/user&gt;
&lt;/status&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Remember, the data returned by httplib2 is always bytes, not a string. To convert it to a string, you need to decode it using the proper character encoding. Identi.ca’s API always returns results in UTF-8, so that part is easy.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There’s the text of the status message we just published.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There’s the unique identifier for the new status message. Identi.ca uses this to construct a URL for viewing the message on the web.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And here it is:&lt;/p&gt;

&lt;p&gt;.
14.7. BEYOND HTTP POST
HTTP isn’t limited to GET and POST. Those are certainly the most common types of requests, especially in web browsers. But web service APIs can go beyond GET and POST, and httplib2 is ready.&lt;/p&gt;

&lt;h1 id=&#34;continued-from-the-previous-example-21:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;continued from the previous example&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;from xml.etree import ElementTree as etree
tree = etree.fromstring(content) .
status_id = tree.findtext(&amp;lsquo;id&amp;rsquo;) .
status_id
&amp;lsquo;5131472&amp;rsquo;
url = &amp;lsquo;&lt;a href=&#34;https://identi.ca/api/statuses/destroy/{0}.xml&#39;.format(status_id&#34;&gt;https://identi.ca/api/statuses/destroy/{0}.xml&#39;.format(status_id&lt;/a&gt;) .
resp, deleted_content = h.request(url, &amp;lsquo;DELETE&amp;rsquo;) .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The server returned XML, right? You know how
to
parse
XML.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The findtext() method finds the first instance of the given expression and extracts its text content. In this case, we’re just looking for an &lt;id&gt; element.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Based on the text content of the &lt;id&gt; element, we can construct a URL to delete the status message we just published.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To delete a message, you simply issue an HTTP DELETE request to that URL.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is what goes over the wire:
send: b&amp;rsquo;DELETE /api/statuses/destroy/5131472.xml HTTP/1.1 .
Host: identi.ca
Accept-Encoding: identity
user-agent: Python-httplib2/$Rev: 259 $&lt;/p&gt;

&lt;p&gt;&amp;rsquo;
reply: &amp;lsquo;HTTP/1.1 401 Unauthorized&amp;rsquo; .
send: b&amp;rsquo;DELETE /api/statuses/destroy/5131472.xml HTTP/1.1 .
Host: identi.ca
Accept-Encoding: identity
authorization: Basic SECRET_HASH_CONSTRUCTED_BY_HTTPLIB2 .
user-agent: Python-httplib2/$Rev: 259 $&lt;/p&gt;

&lt;p&gt;&amp;rsquo;
reply: &amp;lsquo;HTTP/1.1 200 OK&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; resp.status
200&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;“Delete this status message.”&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;“I’m sorry, Dave, I’m afraid I can’t do that.”&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;“Unauthorized. Hmmph. Delete this status message, please…&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;…and here’s my username and password.”&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;“Consider it done!”&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And just like that, poof, it’s gone.&lt;/p&gt;

&lt;p&gt;.
14.8. FURTHER READING
httplib2:
• httplib2 project
page&lt;/p&gt;

&lt;p&gt;• More
httplib2 code
examples&lt;/p&gt;

&lt;p&gt;• Doing
HTTP
Caching
Right:
Introducing
httplib2&lt;/p&gt;

&lt;p&gt;• httplib2:
HTTP
Persistence
and
Authentication&lt;/p&gt;

&lt;p&gt;• HTTP
Caching
Tutorial
by Mark Nottingham&lt;/p&gt;

&lt;p&gt;• How
to
control
caching
with
HTTP
headers
on Google Doctype&lt;/p&gt;

&lt;p&gt;RFCs:&lt;/p&gt;

&lt;p&gt;• RFC
2616:
HTTP&lt;/p&gt;

&lt;p&gt;• RFC
2617:
HTTP
Basic
Authentication&lt;/p&gt;

&lt;p&gt;• RFC
1951:
deflate
compression&lt;/p&gt;

&lt;p&gt;• RFC
1952:
gzip
compression&lt;/p&gt;

&lt;p&gt;HTTP caching:
CHAPTER 15. CASE STUDY: PORTING chardet TO PYTHON 3
. Words, words. They’re all we have to go on. .
— Rosencrantz and Guildenstern are Dead
15.1. DIVING IN
Question: what’s the #1 cause of gibberish text on the web, in your inbox, and across every computer system ever written? It’s character encoding. In the Strings
chapter, I talked about the history of character encoding and the creation of Unicode, the “one encoding to rule them all.” I’d love it if I never had to see a gibberish character on a web page again, because all authoring systems stored accurate encoding information, all transfer protocols were Unicode-aware, and every system that handled text maintained perfect fidelity when converting between encodings.
I’d also like a pony.
A Unicode pony.
A Unipony, as it were.
I’ll settle for character encoding auto-detection.
.&lt;/p&gt;

&lt;p&gt;15.2. WHAT IS CHARACTER ENCODING AUTO-DETECTION?&lt;/p&gt;

&lt;p&gt;It means taking a sequence of bytes in an unknown character encoding, and attempting to determine the encoding so you can read the text. It’s like cracking a code when you don’t have the decryption key.&lt;/p&gt;

&lt;p&gt;15.2.1. ISN’T THAT IMPOSSIBLE?
In general, yes. However, some encodings are optimized for specific languages, and languages are not random. Some character sequences pop up all the time, while other sequences make no sense. A person fluent in English who opens a newspaper and finds “txzqJv 2!dasd0a QqdKjvz” will instantly recognize that that isn’t English (even though it is composed entirely of English letters). By studying lots of “typical” text, a computer algorithm can simulate this kind of fluency and make an educated guess about a text’s language.
In other words, encoding detection is really language detection, combined with knowledge of which languages tend to use which character encodings.&lt;/p&gt;

&lt;p&gt;15.2.2. DOES SUCH AN ALGORITHM EXIST?
As it turns out, yes. All major browsers have character encoding auto-detection, because the web is full of pages that have no encoding information whatsoever. Mozilla
Firefox
contains
an
encoding
auto-detection
library
which is open source. I
ported
the
library
to
Python
2
and dubbed it the chardet module. This chapter will take you step-by-step through the process of porting the chardet module from Python 2 to Python 3.
.&lt;/p&gt;

&lt;p&gt;15.3. INTRODUCING THE chardet MODULE
Before we set off porting the code, it would help if you understood how the code worked! This is a brief guide to navigating the code itself. The chardet library is too large to include inline here, but you can download
it
from
chardet.feedparser.org.
The main entry point for the detection algorithm is
universaldetector.py, which has one class,
UniversalDetector. (You might think the main entry
point is the detect function in chardet/&lt;strong&gt;init&lt;/strong&gt;.py,
but that’s really just a convenience function that creates
a UniversalDetector object, calls it, and returns its
result.)&lt;/p&gt;

&lt;p&gt;There are 5 categories of encodings that
UniversalDetector handles:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;UTF-N with a Byte Order Mark (BOM). This includes UTF-8, both Big-Endian and Little-Endian variants of UTF-16, and all 4 byte-order variants of UTF-32.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Escaped encodings, which are entirely 7-bit ASCII compatible, where non-ASCII characters start with an escape sequence. Examples: ISO-2022-JP (Japanese) and HZ-GB-2312 (Chinese).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Multi-byte encodings, where each character is represented by a variable number of bytes. Examples: BIG5 (Chinese), SHIFT_JIS (Japanese), EUC-KR (Korean), and UTF-8 without a BOM.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Single-byte encodings, where each character is represented by one byte. Examples: KOI8-R (Russian), WINDOWS-1255 (Hebrew), and TIS-620 (Thai).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WINDOWS-1252, which is used primarily on Microsoft Windows by middle managers who wouldn’t know a character encoding from a hole in the ground.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;15.3.1. UTF-N WITH A BOM
If the text starts with a BOM, we can reasonably assume that the text is encoded in UTF-8, UTF-16, or UTF-32. (The BOM will tell us exactly which one; that’s what it’s for.) This is handled inline in UniversalDetector, which returns the result immediately without any further processing.&lt;/p&gt;

&lt;p&gt;15.3.2. ESCAPED ENCODINGS&lt;/p&gt;

&lt;p&gt;If the text contains a recognizable escape sequence that might indicate an escaped encoding, UniversalDetector creates an EscCharSetProber (defined in escprober.py) and feeds it the text.
EscCharSetProber creates a series of state machines, based on models of HZ-GB-2312, ISO-2022-CN, ISO-2022-JP, and ISO-2022-KR (defined in escsm.py). EscCharSetProber feeds the text to each of these state machines, one byte at a time. If any state machine ends up uniquely identifying the encoding, EscCharSetProber immediately returns the positive result to UniversalDetector, which returns it to the caller. If any state machine hits an illegal sequence, it is dropped and processing continues with the other state machines.&lt;/p&gt;

&lt;p&gt;15.3.3. MULTI-BYTE ENCODINGS
Assuming no BOM, UniversalDetector checks whether the text contains any high-bit characters. If so, it creates a series of “probers” for detecting multi-byte encodings, single-byte encodings, and as a last resort, windows-1252.
The multi-byte encoding prober, MBCSGroupProber (defined in mbcsgroupprober.py), is really just a shell that manages a group of other probers, one for each multi-byte encoding: BIG5, GB2312, EUC-TW, EUC­KR, EUC-JP, SHIFT_JIS, and UTF-8. MBCSGroupProber feeds the text to each of these encoding-specific probers and checks the results. If a prober reports that it has found an illegal byte sequence, it is dropped from further processing (so that, for instance, any subsequent calls to UniversalDetector.feed() will skip that prober). If a prober reports that it is reasonably confident that it has detected the encoding, MBCSGroupProber reports this positive result to UniversalDetector, which reports the result to the caller.
Most of the multi-byte encoding probers are inherited from MultiByteCharSetProber (defined in mbcharsetprober.py), and simply hook up the appropriate state machine and distribution analyzer and let MultiByteCharSetProber do the rest of the work. MultiByteCharSetProber runs the text through the encoding-specific state machine, one byte at a time, to look for byte sequences that would indicate a conclusive positive or negative result. At the same time, MultiByteCharSetProber feeds the text to an encoding-specific distribution analyzer.
The distribution analyzers (each defined in chardistribution.py) use language-specific models of which characters are used most frequently. Once MultiByteCharSetProber has fed enough text to the distribution analyzer, it calculates a confidence rating based on the number of frequently-used characters, the total number of characters, and a language-specific distribution ratio. If the confidence is high enough, MultiByteCharSetProber returns the result to MBCSGroupProber, which returns it to UniversalDetector, which returns it to the caller.
The case of Japanese is more difficult. Single-character distribution analysis is not always sufficient to distinguish between EUC-JP and SHIFT_JIS, so the SJISProber (defined in sjisprober.py) also uses 2-character distribution analysis. SJISContextAnalysis and EUCJPContextAnalysis (both defined in jpcntx.py and both inheriting from a common JapaneseContextAnalysis class) check the frequency of Hiragana syllabary characters within the text. Once enough text has been processed, they return a confidence level to SJISProber, which checks both analyzers and returns the higher confidence level to MBCSGroupProber.&lt;/p&gt;

&lt;p&gt;15.3.4. SINGLE-BYTE ENCODINGS
The single-byte encoding prober, SBCSGroupProber (defined in sbcsgroupprober.py), is also just a shell
that manages a group of other probers, one for each combination of single-byte encoding and language: windows-1251, KOI8-R, ISO-8859-5, MacCyrillic, IBM855, and IBM866 (Russian); ISO-8859-7 and windows-1253 (Greek); ISO-8859-5 and windows-1251 (Bulgarian); ISO-8859-2 and windows-1250 (Hungarian); TIS-620 (Thai); windows-1255 and ISO-8859-8 (Hebrew).
SBCSGroupProber feeds the text to each of these encoding+language-specific probers and checks the results. These probers are all implemented as a single&lt;/p&gt;

&lt;p&gt;class, SingleByteCharSetProber (defined in sbcharsetprober.py), which takes a language model as an argument. The language model defines how frequently different 2-character sequences appear in typical text. SingleByteCharSetProber processes the text and tallies the most frequently used 2-character sequences. Once enough text has been processed, it calculates a confidence level based on the number of frequently-used sequences, the total number of characters, and a language-specific distribution ratio.
Hebrew is handled as a special case. If the text appears to be Hebrew based on 2-character distribution analysis, HebrewProber (defined in hebrewprober.py) tries to distinguish between Visual Hebrew (where the source text actually stored “backwards” line-by-line, and then displayed verbatim so it can be read from right to left) and Logical Hebrew (where the source text is stored in reading order and then rendered right-to-left by the client). Because certain characters are encoded differently based on whether they appear in the middle of or at the end of a word, we can make a reasonable guess about direction of the source text, and return the appropriate encoding (windows-1255 for Logical Hebrew, or ISO-8859-8 for Visual Hebrew).
15.3.5. windows-1252
If UniversalDetector detects a high-bit character in the text, but none of the other multi-byte or single-byte encoding probers return a confident result, it creates a Latin1Prober (defined in latin1prober.py) to try to detect English text in a windows-1252 encoding. This detection is inherently unreliable, because English letters are encoded in the same way in many different encodings. The only way to distinguish windows-1252 is through commonly used symbols like smart quotes, curly apostrophes, copyright symbols, and the like. Latin1Prober automatically reduces its confidence rating to allow more accurate probers to win if at all possible.
.&lt;/p&gt;

&lt;p&gt;15.4. RUNNING 2to3
We’re going to migrate the chardet module from Python 2 to Python 3. Python 3 comes with a utility script called 2to3, which takes your actual Python 2 source code as input and auto-converts as much as it can to Python 3. In some cases this is easy — a function was renamed or moved to a different module — but in other cases it can get pretty complex. To get a sense of all that it can do, refer to the appendix, Porting
code
to
Python
3
with
2to3. In this chapter, we’ll start by running 2to3 on the chardet
package, but as you’ll see, there will still be a lot of work to do after the automated tools have performed
their magic.
The main chardet package is split across several different files, all in the same directory. The 2to3 script makes it easy to convert multiple files at once: just pass a directory as a command line argument, and 2to3 will convert each of the files in turn.
C:\home\chardet&amp;gt; python c:\Python30\Tools\Scripts\2to3.py -w chardet\
RefactoringTool: Skipping implicit fixer: buffer
RefactoringTool: Skipping implicit fixer: idioms
RefactoringTool: Skipping implicit fixer: set_literal
RefactoringTool: Skipping implicit fixer: ws_comma
&amp;mdash; chardet__init&lt;strong&gt;.py (original)
+++ chardet__init&lt;/strong&gt;.py (refactored)
@@ -18,7 +18,7 @@&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;version&lt;/strong&gt; = &amp;ldquo;1.0.1&amp;rdquo;&lt;/p&gt;

&lt;p&gt;def detect(aBuf):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;import universaldetector&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;from . import universaldetector&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;u = universaldetector.UniversalDetector()
u.reset()
u.feed(aBuf)&lt;/p&gt;

&lt;p&gt;&amp;mdash; chardet\big5prober.py (original)
+++ chardet\big5prober.py (refactored)
@@ -25,10 +25,10 @@&lt;/p&gt;

&lt;h1 id=&#34;02110-1301-usa:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;02110-1301 USA&lt;/h1&gt;

&lt;p&gt;######################### END LICENSE BLOCK #########################&lt;/p&gt;

&lt;p&gt;-from mbcharsetprober import MultiByteCharSetProber&lt;br /&gt;
-from codingstatemachine import CodingStateMachine&lt;br /&gt;
-from chardistribution import Big5DistributionAnalysis&lt;br /&gt;
-from mbcssm import Big5SMModel&lt;br /&gt;
+from .mbcharsetprober import MultiByteCharSetProber&lt;br /&gt;
+from .codingstatemachine import CodingStateMachine&lt;br /&gt;
+from .chardistribution import Big5DistributionAnalysis&lt;br /&gt;
+from .mbcssm import Big5SMModel&lt;/p&gt;

&lt;p&gt;class Big5Prober(MultiByteCharSetProber):
def &lt;strong&gt;init&lt;/strong&gt;(self):
&amp;mdash; chardet\chardistribution.py (original)&lt;/p&gt;

&lt;p&gt;+++ chardet\chardistribution.py (refactored)&lt;/p&gt;

&lt;p&gt;@@ -25,12 +25,12 @@&lt;/p&gt;

&lt;h1 id=&#34;02110-1301-usa-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;02110-1301 USA&lt;/h1&gt;

&lt;p&gt;######################### END LICENSE BLOCK #########################&lt;/p&gt;

&lt;p&gt;-import constants&lt;br /&gt;
-from euctwfreq import EUCTWCharToFreqOrder, EUCTW_TABLE_SIZE, EUCTW_TYPICAL_DISTRIBUTION_RATIO&lt;br /&gt;
-from euckrfreq import EUCKRCharToFreqOrder, EUCKR_TABLE_SIZE, EUCKR_TYPICAL_DISTRIBUTION_RATIO&lt;br /&gt;
-from gb2312freq import GB2312CharToFreqOrder, GB2312_TABLE_SIZE, GB2312_TYPICAL_DISTRIBUTION_RATIO&lt;br /&gt;
-from big5freq import Big5CharToFreqOrder, BIG5_TABLE_SIZE, BIG5_TYPICAL_DISTRIBUTION_RATIO&lt;br /&gt;
-from jisfreq import JISCharToFreqOrder, JIS_TABLE_SIZE, JIS_TYPICAL_DISTRIBUTION_RATIO&lt;br /&gt;
+from . import constants&lt;br /&gt;
+from .euctwfreq import EUCTWCharToFreqOrder, EUCTW_TABLE_SIZE, EUCTW_TYPICAL_DISTRIBUTION_RATIO&lt;br /&gt;
+from .euckrfreq import EUCKRCharToFreqOrder, EUCKR_TABLE_SIZE, EUCKR_TYPICAL_DISTRIBUTION_RATIO&lt;br /&gt;
+from .gb2312freq import GB2312CharToFreqOrder, GB2312_TABLE_SIZE, GB2312_TYPICAL_DISTRIBUTION_RATIO&lt;br /&gt;
+from .big5freq import Big5CharToFreqOrder, BIG5_TABLE_SIZE, BIG5_TYPICAL_DISTRIBUTION_RATIO&lt;br /&gt;
+from .jisfreq import JISCharToFreqOrder, JIS_TABLE_SIZE, JIS_TYPICAL_DISTRIBUTION_RATIO&lt;/p&gt;

&lt;p&gt;ENOUGH_DATA_THRESHOLD = 1024&lt;/p&gt;

&lt;p&gt;SURE_YES = 0.99
.
.
. (it goes on like this for a while)
.
.
RefactoringTool: Files that were modified:
RefactoringTool: chardet__init__.py
RefactoringTool: chardet\big5prober.py
RefactoringTool: chardet\chardistribution.py
RefactoringTool: chardet\charsetgroupprober.py
RefactoringTool: chardet\codingstatemachine.py
RefactoringTool: chardet\constants.py
RefactoringTool: chardet\escprober.py
RefactoringTool: chardet\escsm.py&lt;/p&gt;

&lt;p&gt;RefactoringTool: chardet\eucjpprober.py
RefactoringTool: chardet\euckrprober.py
RefactoringTool: chardet\euctwprober.py
RefactoringTool: chardet\gb2312prober.py
RefactoringTool: chardet\hebrewprober.py
RefactoringTool: chardet\jpcntx.py
RefactoringTool: chardet\langbulgarianmodel.py
RefactoringTool: chardet\langcyrillicmodel.py
RefactoringTool: chardet\langgreekmodel.py
RefactoringTool: chardet\langhebrewmodel.py
RefactoringTool: chardet\langhungarianmodel.py
RefactoringTool: chardet\langthaimodel.py
RefactoringTool: chardet\latin1prober.py
RefactoringTool: chardet\mbcharsetprober.py
RefactoringTool: chardet\mbcsgroupprober.py
RefactoringTool: chardet\mbcssm.py
RefactoringTool: chardet\sbcharsetprober.py
RefactoringTool: chardet\sbcsgroupprober.py
RefactoringTool: chardet\sjisprober.py
RefactoringTool: chardet\universaldetector.py
RefactoringTool: chardet\utf8prober.py&lt;/p&gt;

&lt;p&gt;Now run the 2to3 script on the testing harness, test.py.
C:\home\chardet&amp;gt; python c:\Python30\Tools\Scripts\2to3.py -w test.py
RefactoringTool: Skipping implicit fixer: buffer
RefactoringTool: Skipping implicit fixer: idioms
RefactoringTool: Skipping implicit fixer: set_literal
RefactoringTool: Skipping implicit fixer: ws_comma
&amp;mdash; test.py (original)
+++ test.py (refactored)
@@ -4,7 +4,7 @@&lt;/p&gt;

&lt;p&gt;count = 0
u = UniversalDetector()
for f in glob.glob(sys.argv[1]):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;print f.ljust(60),&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;print(f.ljust(60), end=&amp;rsquo; &amp;lsquo;)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;u.reset()
for line in file(f, &amp;lsquo;rb&amp;rsquo;):
u.feed(line)&lt;/p&gt;

&lt;p&gt;@@ -12,8 +12,8 @@
u.close()
result = u.result
if result[&amp;lsquo;encoding&amp;rsquo;]:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;print result[&amp;lsquo;encoding&amp;rsquo;], &amp;lsquo;with confidence&amp;rsquo;, result[&amp;lsquo;confidence&amp;rsquo;]&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;print(result[&amp;lsquo;encoding&amp;rsquo;], &amp;lsquo;with confidence&amp;rsquo;, result[&amp;lsquo;confidence&amp;rsquo;])&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;else:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;print &amp;lsquo;******** no result&amp;rsquo;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;print(&amp;rsquo;******** no result&amp;rsquo;)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;count += 1&lt;/p&gt;

&lt;p&gt;-print count, &amp;lsquo;tests&amp;rsquo;&lt;br /&gt;
+print(count, &amp;lsquo;tests&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;RefactoringTool: Files that were modified:
RefactoringTool: test.py&lt;/p&gt;

&lt;p&gt;Well, that wasn’t so hard. Just a few imports and print statements to convert. Speaking of which, what was the problem with all those import statements? To answer that, you need to understand how the chardet module is split into multiple files.
.
15.5. A SHORT DIGRESSION INTO MULTI-FILE MODULES
chardet is a multi-file module. I could have chosen to put all the code in one file (named chardet.py), but I didn’t. Instead, I made a directory (named chardet), then I made an &lt;strong&gt;init&lt;/strong&gt;.py file in that directory. If Python sees an &lt;strong&gt;init&lt;/strong&gt;.py file in a directory, it assumes that all of the files in that directory are part of the same module. The module’s name is the name of the directory. Files within the directory can reference other files within the same directory, or even within subdirectories. (More on that in a minute.) But the entire collection of files is presented to other Python code as a single module — as if all the functions and classes were in a single .py file.
What goes in the &lt;strong&gt;init&lt;/strong&gt;.py file? Nothing. Everything. Something in between. The &lt;strong&gt;init&lt;/strong&gt;.py file doesn’t need to define anything; it can literally be an empty file. Or you can use it to define your main entry point functions. Or you put all your functions in it. Or all but one.
. A directory with an &lt;strong&gt;init&lt;/strong&gt;.py file is always treated as a multi-file module. Without an &lt;strong&gt;init&lt;/strong&gt;.py file, a directory is just a directory of unrelated .py files.
Let’s see how that works in practice.
&amp;gt;&amp;gt;&amp;gt; import chardet
&amp;gt;&amp;gt;&amp;gt; dir(chardet) .
[&amp;rsquo;&lt;strong&gt;builtins&lt;/strong&gt;&amp;rsquo;, &amp;lsquo;&lt;strong&gt;doc&lt;/strong&gt;&amp;rsquo;, &amp;lsquo;&lt;strong&gt;file&lt;/strong&gt;&amp;rsquo;, &amp;lsquo;&lt;strong&gt;name&lt;/strong&gt;&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;lsquo;&lt;strong&gt;package&lt;/strong&gt;&amp;rsquo;, &amp;lsquo;&lt;strong&gt;path&lt;/strong&gt;&amp;rsquo;, &amp;lsquo;&lt;strong&gt;version&lt;/strong&gt;&amp;rsquo;, &amp;lsquo;detect&amp;rsquo;]
&amp;gt;&amp;gt;&amp;gt; chardet .
&lt;module &#39;chardet&#39; from &#39;C:\Python31\lib\site-packages\chardet\__init__.py&#39;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Other than the usual class attributes, the only thing in the chardet module is a detect() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Here’s your first clue that the chardet module is more than just a file: the “module” is listed as the &lt;strong&gt;init&lt;/strong&gt;.py file within the chardet/ directory.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s take a peek in that &lt;strong&gt;init&lt;/strong&gt;.py file.
def detect(aBuf): .
from . import universaldetector .
u = universaldetector.UniversalDetector()
u.reset()
u.feed(aBuf)
u.close()
return u.result&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;strong&gt;init&lt;/strong&gt;.py file defines the detect() function, which is the main entry point into the chardet library.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;But the detect() function hardly has any code! In fact, all it really does is import the universaldetector module and start using it. But where is universaldetector defined?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The answer lies in that odd-looking import statement:
from . import universaldetector&lt;/p&gt;

&lt;p&gt;Translated into English, that means “import the universaldetector module; that’s in the same directory I am,” where “I” is the chardet/&lt;strong&gt;init&lt;/strong&gt;.py file. This is called a relative import. It’s a way for the files within a multi-file module to reference each other, without worrying about naming conflicts with other modules you may have installed in your
import
search
path. This import statement will only look for the universaldetector module within the chardet/ directory itself.
These two concepts — &lt;strong&gt;init&lt;/strong&gt;.py and relative imports — mean that you can break up your module into as many pieces as you like. The chardet module comprises 36 .py files — 36! Yet all you need to do to start using it is import chardet, then you can call the main chardet.detect() function. Unbeknownst to your code, the detect() function is actually defined in the chardet/&lt;strong&gt;init&lt;/strong&gt;.py file. Also unbeknownst to you, the detect() function uses a relative import to reference a class defined in chardet/ universaldetector.py, which in turn uses relative imports on five other files, all contained in the chardet/ directory.
.&lt;/p&gt;

&lt;p&gt;If you ever find yourself writing a large library in Python (or more likely, when you realize that your small library has grown into a large one), take the time to refactor it into a multi-file module. It’s one of the many things Python is good at, so take advantage of it.
.
15.6. FIXING WHAT 2to3 CAN’T&lt;/p&gt;

&lt;p&gt;15.6.1. False IS INVALID SYNTAX
Now for the real test: running the test harness against the test suite. Since the test suite is designed to cover
all the possible code paths, it’s a good way to test our ported code to make sure there aren’t any bugs lurking anywhere.
C:\home\chardet&amp;gt; python test.py tests**&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;test.py&amp;rdquo;, line 1, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;from chardet.universaldetector import UniversalDetector
File &amp;ldquo;C:\home\chardet\chardet\universaldetector.py&amp;rdquo;, line 51
self.done = constants.False
^
SyntaxError: invalid syntax&lt;/p&gt;

&lt;p&gt;Hmm, a small snag. In Python 3, False is a reserved word, so you can’t use it as a variable name. Let’s look at constants.py to see where it’s defined. Here’s the original version from constants.py, before the 2to3 script changed it:
import &lt;strong&gt;builtin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;if not hasattr(&lt;strong&gt;builtin&lt;/strong&gt;, &amp;lsquo;False&amp;rsquo;):&lt;/p&gt;

&lt;p&gt;False = 0&lt;/p&gt;

&lt;p&gt;True = 1&lt;/p&gt;

&lt;p&gt;else:&lt;/p&gt;

&lt;p&gt;False = &lt;strong&gt;builtin&lt;/strong&gt;.False&lt;/p&gt;

&lt;p&gt;True = &lt;strong&gt;builtin&lt;/strong&gt;.True&lt;/p&gt;

&lt;p&gt;This piece of code is designed to allow this library to run under older versions of Python 2. Prior to Python 2.3, Python had no built-in bool type. This code detects the absence of the built-in constants True and False, and defines them if necessary.
However, Python 3 will always have a bool type, so this entire code snippet is unnecessary. The simplest solution is to replace all instances of constants.True and constants.False with True and False, respectively, then delete this dead code from constants.py.
So this line in universaldetector.py:
self.done = constants.False&lt;/p&gt;

&lt;p&gt;Becomes
self.done = False&lt;/p&gt;

&lt;p&gt;Ah, wasn’t that satisfying? The code is shorter and more readable already.&lt;/p&gt;

&lt;p&gt;15.6.2. NO MODULE NAMED constants
Time to run test.py again and see how far it gets.
C:\home\chardet&amp;gt; python test.py tests**&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;test.py&amp;rdquo;, line 1, in &lt;module&gt;
from chardet.universaldetector import UniversalDetector
File &amp;ldquo;C:\home\chardet\chardet\universaldetector.py&amp;rdquo;, line 29, in &lt;module&gt;
import constants, sys
ImportError: No module named constants&lt;/p&gt;

&lt;p&gt;What’s that you say? No module named constants? Of course there’s a module named constants. It’s right there, in chardet/constants.py.
Remember when the 2to3 script fixed up all those import statements? This library has a lot of relative imports — that is, modules
that
import
other
modules
within
the
same
library
— but the logic behind relative imports has changed in Python 3. In Python 2, you could just import constants and it would look in the chardet/ directory first. In Python 3, all
import
statements
are
absolute
by
default. If you want to do a relative import in Python 3, you need to be explicit about it:
from . import constants&lt;/p&gt;

&lt;p&gt;But wait. Wasn’t the 2to3 script supposed to take care of these for you? Well, it did, but this particular import statement combines two different types of imports into one line: a relative import of the constants module within the library, and an absolute import of the sys module that is pre-installed in the Python standard library. In Python 2, you could combine these into one import statement. In Python 3, you can’t, and the 2to3 script is not smart enough to split the import statement into two.
The solution is to split the import statement manually. So this two-in-one import:
import constants, sys&lt;/p&gt;

&lt;p&gt;Needs to become two separate imports:
from . import constants
import sys&lt;/p&gt;

&lt;p&gt;There are variations of this problem scattered throughout the chardet library. In some places it’s “import
constants, sys”; in other places, it’s “import constants, re”. The fix is the same: manually split the import statement into two lines, one for the relative import, the other for the absolute import.
Onward!&lt;/p&gt;

&lt;p&gt;15.6.3. NAME &amp;lsquo;file&amp;rsquo; IS NOT DEFINED
And here we go again, running test.py to try to execute our test cases…
C:\home\chardet&amp;gt; python test.py tests**
tests\ascii\howto.diveintomark.org.xml&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;test.py&amp;rdquo;, line 9, in &lt;module&gt;
for line in file(f, &amp;lsquo;rb&amp;rsquo;):
NameError: name &amp;lsquo;file&amp;rsquo; is not defined&lt;/p&gt;

&lt;p&gt;This one surprised me, because I’ve been using this idiom as long as I can remember. In Python 2, the global file() function was an alias for the open() function, which was the standard way of opening
text
files
for
reading. In Python 3, the global file() function no longer exists, but the open() function still exists.&lt;/p&gt;

&lt;p&gt;Thus, the simplest solution to the problem of the missing file() is to call the open() function instead:
for line in open(f, &amp;lsquo;rb&amp;rsquo;): And that’s all I have to say about that.&lt;/p&gt;

&lt;p&gt;15.6.4. CAN’T USE A STRING PATTERN ON A BYTES-LIKE OBJECT
Now things are starting to get interesting. And by “interesting,” I mean “confusing as all hell.”
C:\home\chardet&amp;gt; python test.py tests**&lt;/p&gt;

&lt;p&gt;tests\ascii\howto.diveintomark.org.xml&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;test.py&amp;rdquo;, line 10, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;u.feed(line)&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;C:\home\chardet\chardet\universaldetector.py&amp;rdquo;, line 98, in feed&lt;/p&gt;

&lt;p&gt;if self._highBitDetector.search(aBuf):&lt;/p&gt;

&lt;p&gt;TypeError: can&amp;rsquo;t use a string pattern on a bytes-like object&lt;/p&gt;

&lt;p&gt;To debug this, let’s see what self._highBitDetector is. It’s defined in the &lt;strong&gt;init&lt;/strong&gt; method of the UniversalDetector class:
class UniversalDetector:
def &lt;strong&gt;init&lt;/strong&gt;(self):
self._highBitDetector = re.compile(r&amp;rsquo;[\x80-\xFF]&amp;lsquo;)&lt;/p&gt;

&lt;p&gt;This pre-compiles a regular expression designed to find non-ASCII characters in the range 128–255 (0x80–0xFF). Wait, that’s not quite right; I need to be more precise with my terminology. This pattern is designed to find non-ASCII bytes in the range 128-255.
And therein lies the problem.
In Python 2, a string was an array of bytes whose character encoding was tracked separately. If you wanted Python 2 to keep track of the character encoding, you had to use a Unicode string (u&amp;rdquo;) instead. But in Python 3, a string is always what Python 2 called a Unicode string — that is, an array of Unicode characters (of possibly varying byte lengths). Since this regular expression is defined by a string pattern, it can only be used to search a string — again, an array of characters. But what we’re searching is not a string, it’s a byte array. Looking at the traceback, this error occurred in universaldetector.py:
def feed(self, aBuf):&lt;/p&gt;

&lt;p&gt;.
.
.
if self._mInputState == ePureAscii:&lt;/p&gt;

&lt;p&gt;if self._highBitDetector.search(aBuf):&lt;/p&gt;

&lt;p&gt;And what is aBuf? Let’s backtrack further to a place that calls UniversalDetector.feed(). One place that calls it is the test harness, test.py.
u = UniversalDetector()
.
.
.
for line in open(f, &amp;lsquo;rb&amp;rsquo;):&lt;/p&gt;

&lt;p&gt;u.feed(line)&lt;/p&gt;

&lt;p&gt;And here we find our answer: in the UniversalDetector.feed() method, aBuf is a line read from a file on disk. Look carefully at the parameters used to open the file: &amp;lsquo;rb&amp;rsquo;. &amp;lsquo;r&amp;rsquo; is for “read”; OK, big deal, we’re reading the file. Ah, but &amp;lsquo;b&amp;rsquo; is
for
“binary.”
Without the &amp;lsquo;b&amp;rsquo; flag, this for loop would read the file, line by line, and convert each line into a string — an array of Unicode characters — according to the system default character encoding. But with the &amp;lsquo;b&amp;rsquo; flag, this for loop reads the file, line by line, and stores each line exactly as it appears in the file, as an array of bytes. That byte array gets passed to UniversalDetector.feed(), and eventually gets passed to the pre-compiled regular expression, self._highBitDetector, to search for high-bit… characters. But we don’t have characters; we have bytes. Oops.&lt;/p&gt;

&lt;p&gt;What we need this regular expression to search is not an array of characters, but an array of bytes.
Once you realize that, the solution is not difficult. Regular expressions defined with strings can search strings. Regular expressions defined with byte arrays can search byte arrays. To define a byte array pattern, we simply change the type of the argument we use to define the regular expression to a byte array. (There is one other case of this same problem, on the very next line.)
class UniversalDetector:
def &lt;strong&gt;init&lt;/strong&gt;(self):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;self._highBitDetector = re.compile(r&amp;rsquo;[\x80-\xFF]&amp;lsquo;)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;self._escDetector = re.compile(r&amp;rsquo;(\033|~{)&amp;lsquo;)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;self._highBitDetector = re.compile(b&amp;rsquo;[\x80-\xFF]&amp;lsquo;)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;self._escDetector = re.compile(b&amp;rsquo;(\033|~{)&amp;lsquo;)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;self._mEscCharSetProber = None
self._mCharSetProbers = []
self.reset()&lt;/p&gt;

&lt;p&gt;Searching the entire codebase for other uses of the re module turns up two more instances, in charsetprober.py. Again, the code is defining regular expressions as strings but executing them on aBuf, which is a byte array. The solution is the same: define the regular expression patterns as byte arrays.
class CharSetProber:&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;def filter_high_bit_only(self, aBuf):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aBuf = re.sub(r&amp;rsquo;([\x00-\x7F])+&amp;lsquo;, &amp;rsquo; &amp;lsquo;, aBuf)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;aBuf = re.sub(b&amp;rsquo;([\x00-\x7F])+&amp;lsquo;, b&amp;rsquo; &amp;lsquo;, aBuf)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;return aBuf&lt;/p&gt;

&lt;p&gt;def filter_without_english_letters(self, aBuf):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aBuf = re.sub(r&amp;rsquo;([A-Za-z])+&amp;lsquo;, &amp;rsquo; &amp;lsquo;, aBuf)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;aBuf = re.sub(b&amp;rsquo;([A-Za-z])+&amp;lsquo;, b&amp;rsquo; &amp;lsquo;, aBuf)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;return aBuf&lt;/p&gt;

&lt;p&gt;15.6.5. CAN&amp;rsquo;T CONVERT &amp;lsquo;bytes&amp;rsquo; OBJECT TO str IMPLICITLY
Curiouser and curiouser…
C:\home\chardet&amp;gt; python test.py tests**&lt;/p&gt;

&lt;p&gt;tests\ascii\howto.diveintomark.org.xml&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;test.py&amp;rdquo;, line 10, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;u.feed(line)&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;C:\home\chardet\chardet\universaldetector.py&amp;rdquo;, line 100, in feed&lt;/p&gt;

&lt;p&gt;elif (self._mInputState == ePureAscii) and self._escDetector.search(self._mLastChar + aBuf):&lt;/p&gt;

&lt;p&gt;TypeError: Can&amp;rsquo;t convert &amp;lsquo;bytes&amp;rsquo; object to str implicitly&lt;/p&gt;

&lt;p&gt;There’s an unfortunate clash of coding style and Python interpreter here. The TypeError could be anywhere on that line, but the traceback doesn’t tell you exactly where it is. It could be in the first conditional or the second, and the traceback would look the same. To narrow it down, you should split the line in half, like this:
elif (self._mInputState == ePureAscii) and \
self._escDetector.search(self._mLastChar + aBuf):&lt;/p&gt;

&lt;p&gt;And re-run the test:
C:\home\chardet&amp;gt; python test.py tests**
tests\ascii\howto.diveintomark.org.xml&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;test.py&amp;rdquo;, line 10, in &lt;module&gt;
u.feed(line)
File &amp;ldquo;C:\home\chardet\chardet\universaldetector.py&amp;rdquo;, line 101, in feed
self._escDetector.search(self._mLastChar + aBuf):
TypeError: Can&amp;rsquo;t convert &amp;lsquo;bytes&amp;rsquo; object to str implicitly&lt;/p&gt;

&lt;p&gt;Aha! The problem was not in the first conditional (self._mInputState == ePureAscii) but in the second one. So what could cause a TypeError there? Perhaps you’re thinking that the search() method is expecting a value of a different type, but that wouldn’t generate this traceback. Python functions can take any value; if you pass the right number of arguments, the function will execute. It may crash if you pass it a value of a different type than it’s expecting, but if that happened, the traceback would point to somewhere inside the function. But this traceback says it never got as far as calling the search() method. So the problem must be in that + operation, as it’s trying to construct the value that it will eventually pass to the search() method.
We know from previous
debugging
that aBuf is a byte array. So what is self._mLastChar? It’s an instance variable, defined in the reset() method, which is actually called from the &lt;strong&gt;init&lt;/strong&gt;() method.
class UniversalDetector:&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;init&lt;/strong&gt;(self):
self._highBitDetector = re.compile(b&amp;rsquo;[\x80-\xFF]&amp;lsquo;)
self._escDetector = re.compile(b&amp;rsquo;(\033|~{)&amp;lsquo;)
self._mEscCharSetProber = None
self._mCharSetProbers = []
self.reset()&lt;/p&gt;

&lt;p&gt;def reset(self):
self.result = {&amp;lsquo;encoding&amp;rsquo;: None, &amp;lsquo;confidence&amp;rsquo;: 0.0}
self.done = False
self._mStart = True
self._mGotData = False
self._mInputState = ePureAscii
self._mLastChar = &amp;ldquo;&lt;/p&gt;

&lt;p&gt;And now we have our answer. Do you see it? self._mLastChar is a string, but aBuf is a byte array. And you can’t concatenate a string to a byte array — not even a zero-length string.
So what is self._mLastChar anyway? In the feed() method, just a few lines down from where the trackback occurred.
if self._mInputState == ePureAscii:
if self._highBitDetector.search(aBuf):
self._mInputState = eHighbyte
elif (self._mInputState == ePureAscii) and \
self._escDetector.search(self._mLastChar + aBuf):
self._mInputState = eEscAscii&lt;/p&gt;

&lt;p&gt;self._mLastChar = aBuf[-1]&lt;/p&gt;

&lt;p&gt;The calling function calls this feed() method over and over again with a few bytes at a time. The method processes the bytes it was given (passed in as aBuf), then stores the last byte in self._mLastChar in case it’s needed during the next call. (In a multi-byte encoding, the feed() method might get called with half of a character, then called again with the other half.) But because aBuf is now a byte array instead of a string, self._mLastChar needs to be a byte array as well. Thus:
def reset(self):
.
.
.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;self._mLastChar = &amp;ldquo;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;self._mLastChar = b&amp;rdquo;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Searching the entire codebase for “mLastChar” turns up a similar problem in mbcharsetprober.py, but instead of tracking the last character, it tracks the last two characters. The MultiByteCharSetProber class uses a list of 1-character strings to track the last two characters. In Python 3, it needs to use a list of integers, because it’s not really tracking characters, it’s tracking bytes. (Bytes are just integers from 0-255.)
class MultiByteCharSetProber(CharSetProber):&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;init&lt;/strong&gt;(self):
CharSetProber.&lt;strong&gt;init&lt;/strong&gt;(self)
self._mDistributionAnalyzer = None
self._mCodingSM = None&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;self._mLastChar = [&amp;rsquo;\x00&amp;rsquo;, &amp;lsquo;\x00&amp;rsquo;]&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;self._mLastChar = [0, 0]&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;def reset(self):
CharSetProber.reset(self)
if self._mCodingSM:
self._mCodingSM.reset()
if self._mDistributionAnalyzer:
self._mDistributionAnalyzer.reset()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;self._mLastChar = [&amp;rsquo;\x00&amp;rsquo;, &amp;lsquo;\x00&amp;rsquo;]&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;self._mLastChar = [0, 0]&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;15.6.6. UNSUPPORTED OPERAND TYPE(S) FOR +: &amp;lsquo;int&amp;rsquo; AND &amp;lsquo;bytes&amp;rsquo;
I have good news, and I have bad news. The good news is we’re making progress…
C:\home\chardet&amp;gt; python test.py tests**
tests\ascii\howto.diveintomark.org.xml&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;test.py&amp;rdquo;, line 10, in &lt;module&gt;
u.feed(line)
File &amp;ldquo;C:\home\chardet\chardet\universaldetector.py&amp;rdquo;, line 101, in feed
self._escDetector.search(self._mLastChar + aBuf):
TypeError: unsupported operand type(s) for +: &amp;lsquo;int&amp;rsquo; and &amp;lsquo;bytes&amp;rsquo;&lt;/p&gt;

&lt;p&gt;…The bad news is it doesn’t always feel like progress.
But this is progress! Really! Even though the traceback calls out the same line of code, it’s a different error than it used to be. Progress! So what’s the problem now? The last time I checked, this line of code didn’t try to concatenate an int with a byte array (bytes). In fact, you just spent a lot of time ensuring
that
self._mLastChar was
a
byte
array. How did it turn into an int?
The answer lies not in the previous lines of code, but in the following lines.
if self._mInputState == ePureAscii:
if self._highBitDetector.search(aBuf):
self._mInputState = eHighbyte
elif (self._mInputState == ePureAscii) and \
self._escDetector.search(self._mLastChar + aBuf):
self._mInputState = eEscAscii&lt;/p&gt;

&lt;p&gt;self._mLastChar = aBuf[-1]&lt;/p&gt;

&lt;p&gt;This error doesn’t occur the first time the feed()
method gets called; it occurs the second time, after self._mLastChar has been set to the last byte of aBuf. Well, what’s the problem with that? Getting a single element from a byte array yields an integer, not a byte array. To see the difference, follow me to the interactive shell:
&amp;gt;&amp;gt;&amp;gt; aBuf = b&amp;rsquo;\xEF\xBB\xBF&amp;rsquo; .
&amp;gt;&amp;gt;&amp;gt; len(aBuf)
3
&amp;gt;&amp;gt;&amp;gt; mLastChar = aBuf[-1]
&amp;gt;&amp;gt;&amp;gt; mLastChar .
191
&amp;gt;&amp;gt;&amp;gt; type(mLastChar) .
&lt;class &#39;int&#39;&gt;
&amp;gt;&amp;gt;&amp;gt; mLastChar + aBuf .&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;TypeError: unsupported operand type(s) for +: &amp;lsquo;int&amp;rsquo; and &amp;lsquo;bytes&amp;rsquo;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;mLastChar = aBuf[-1:] .
mLastChar
b&amp;rsquo;\xbf&amp;rsquo;
mLastChar + aBuf .
b&amp;rsquo;\xbf\xef\xbb\xbf&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Define a byte array of length 3.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The last element of the byte array is 191.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That’s an integer.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Concatenating an integer with a byte array doesn’t work. You’ve now replicated the error you just found in universaldetector.py.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ah, here’s the fix. Instead of taking the last element of the byte array, use list
slicing
to create a new byte array containing just the last element. That is, start with the last element and continue the slice until the end of the byte array. Now mLastChar is a byte array of length 1.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Concatenating a byte array of length 1 with a byte array of length 3 returns a new byte array of length 4.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, to ensure that the feed() method in universaldetector.py continues to work no matter how often it’s called, you need to initialize
self._mLastChar as
a
0-length
byte
array, then make sure it stays a byte array.
self._escDetector.search(self._mLastChar + aBuf):
self._mInputState = eEscAscii&lt;/p&gt;

&lt;p&gt;-self._mLastChar = aBuf[-1]&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;self._mLastChar = aBuf[-1:]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;15.6.7. ord() EXPECTED STRING OF LENGTH 1, BUT int FOUND
Tired yet? You’re almost there…
C:\home\chardet&amp;gt; python test.py tests**&lt;/p&gt;

&lt;p&gt;tests\ascii\howto.diveintomark.org.xml  ascii with confidence 1.0&lt;/p&gt;

&lt;p&gt;tests\Big5\0804.blogspot.com.xml&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;test.py&amp;rdquo;, line 10, in &lt;module&gt;&lt;/p&gt;

&lt;p&gt;u.feed(line)&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;C:\home\chardet\chardet\universaldetector.py&amp;rdquo;, line 116, in feed&lt;/p&gt;

&lt;p&gt;if prober.feed(aBuf) == constants.eFoundIt:&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;C:\home\chardet\chardet\charsetgroupprober.py&amp;rdquo;, line 60, in feed&lt;/p&gt;

&lt;p&gt;st = prober.feed(aBuf)&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;C:\home\chardet\chardet\utf8prober.py&amp;rdquo;, line 53, in feed&lt;/p&gt;

&lt;p&gt;codingState = self._mCodingSM.next_state&amp;copy;&lt;/p&gt;

&lt;p&gt;File &amp;ldquo;C:\home\chardet\chardet\codingstatemachine.py&amp;rdquo;, line 43, in next_state&lt;/p&gt;

&lt;p&gt;byteCls = self._mModel[&amp;lsquo;classTable&amp;rsquo;][ord&amp;copy;]&lt;/p&gt;

&lt;p&gt;TypeError: ord() expected string of length 1, but int found&lt;/p&gt;

&lt;p&gt;OK, so c is an int, but the ord() function was expecting a 1-character string. Fair enough. Where is c defined?&lt;/p&gt;

&lt;h1 id=&#34;codingstatemachine-py:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;codingstatemachine.py&lt;/h1&gt;

&lt;p&gt;def next_state(self, c):&lt;/p&gt;

&lt;h1 id=&#34;for-each-byte-we-get-its-class:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;for each byte we get its class&lt;/h1&gt;

&lt;h1 id=&#34;if-it-is-first-byte-we-also-get-byte-length:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;if it is first byte, we also get byte length&lt;/h1&gt;

&lt;p&gt;byteCls = self._mModel[&amp;lsquo;classTable&amp;rsquo;][ord&amp;copy;]&lt;/p&gt;

&lt;p&gt;That’s no help; it’s just passed into the function. Let’s pop the stack.&lt;/p&gt;

&lt;h1 id=&#34;utf8prober-py:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;utf8prober.py&lt;/h1&gt;

&lt;p&gt;def feed(self, aBuf):
for c in aBuf:
codingState = self._mCodingSM.next_state&amp;copy;&lt;/p&gt;

&lt;p&gt;Do you see it? In Python 2, aBuf was a string, so c was a 1-character string. (That’s what you get when you iterate over a string — all the characters, one by one.) But now, aBuf is a byte array, so c is an int, not a 1-character string. In other words, there’s no need to call the ord() function because c is already an int!
Thus:
def next_state(self, c):&lt;/p&gt;

&lt;h1 id=&#34;for-each-byte-we-get-its-class-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;for each byte we get its class&lt;/h1&gt;

&lt;h1 id=&#34;if-it-is-first-byte-we-also-get-byte-length-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;if it is first byte, we also get byte length&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;byteCls = self._mModel[&amp;lsquo;classTable&amp;rsquo;][ord&amp;copy;]&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;byteCls = self._mModel[&amp;lsquo;classTable&amp;rsquo;][c]&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Searching the entire codebase for instances of “ord&amp;copy;” uncovers similar problems in sbcharsetprober.py…&lt;/p&gt;

&lt;h1 id=&#34;sbcharsetprober-py:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;sbcharsetprober.py&lt;/h1&gt;

&lt;p&gt;def feed(self, aBuf):
if not self._mModel[&amp;lsquo;keepEnglishLetter&amp;rsquo;]:&lt;/p&gt;

&lt;p&gt;aBuf = self.filter_without_english_letters(aBuf)
aLen = len(aBuf)
if not aLen:&lt;/p&gt;

&lt;p&gt;return self.get_state()
for c in aBuf:
order = self._mModel[&amp;lsquo;charToOrderMap&amp;rsquo;][ord&amp;copy;]&lt;/p&gt;

&lt;p&gt;…and latin1prober.py…&lt;/p&gt;

&lt;h1 id=&#34;latin1prober-py:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;latin1prober.py&lt;/h1&gt;

&lt;p&gt;def feed(self, aBuf):
aBuf = self.filter_with_english_letters(aBuf)
for c in aBuf:&lt;/p&gt;

&lt;p&gt;charClass = Latin1_CharToClass[ord&amp;copy;]&lt;/p&gt;

&lt;p&gt;c is iterating over aBuf, which means it is an integer, not a 1-character string. The solution is the same: change ord&amp;copy; to just plain c.&lt;/p&gt;

&lt;h1 id=&#34;sbcharsetprober-py-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;sbcharsetprober.py&lt;/h1&gt;

&lt;p&gt;def feed(self, aBuf):
if not self._mModel[&amp;lsquo;keepEnglishLetter&amp;rsquo;]:&lt;/p&gt;

&lt;p&gt;aBuf = self.filter_without_english_letters(aBuf)
aLen = len(aBuf)
if not aLen:&lt;/p&gt;

&lt;p&gt;return self.get_state()
for c in aBuf:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;order = self._mModel[&amp;lsquo;charToOrderMap&amp;rsquo;][ord&amp;copy;]&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;order = self._mModel[&amp;lsquo;charToOrderMap&amp;rsquo;][c]&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;latin1prober-py-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;latin1prober.py&lt;/h1&gt;

&lt;p&gt;def feed(self, aBuf):
aBuf = self.filter_with_english_letters(aBuf)
for c in aBuf:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;charClass = Latin1_CharToClass[ord&amp;copy;]&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;charClass = Latin1_CharToClass[c]&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;15.6.8. UNORDERABLE TYPES: int() &amp;gt;= str()
Let’s go again.
C:\home\chardet&amp;gt; python test.py tests**
tests\ascii\howto.diveintomark.org.xml ascii with confidence 1.0
tests\Big5\0804.blogspot.com.xml&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;test.py&amp;rdquo;, line 10, in &lt;module&gt;
u.feed(line)
File &amp;ldquo;C:\home\chardet\chardet\universaldetector.py&amp;rdquo;, line 116, in feed
if prober.feed(aBuf) == constants.eFoundIt:
File &amp;ldquo;C:\home\chardet\chardet\charsetgroupprober.py&amp;rdquo;, line 60, in feed
st = prober.feed(aBuf)
File &amp;ldquo;C:\home\chardet\chardet\sjisprober.py&amp;rdquo;, line 68, in feed
self._mContextAnalyzer.feed(self._mLastChar[2 - charLen :], charLen)
File &amp;ldquo;C:\home\chardet\chardet\jpcntx.py&amp;rdquo;, line 145, in feed
order, charLen = self.get_order(aBuf[i:i+2])
File &amp;ldquo;C:\home\chardet\chardet\jpcntx.py&amp;rdquo;, line 176, in get_order
if ((aStr[0] &amp;gt;= &amp;lsquo;\x81&amp;rsquo;) and (aStr[0] &amp;lt;= &amp;lsquo;\x9F&amp;rsquo;)) or \
TypeError: unorderable types: int() &amp;gt;= str()&lt;/p&gt;

&lt;p&gt;So what’s this all about? “Unorderable types”? Once again, the difference between byte arrays and strings is rearing its ugly head. Take a look at the code:
class SJISContextAnalysis(JapaneseContextAnalysis):&lt;/p&gt;

&lt;p&gt;def get_order(self, aStr):
if not aStr: return -1, 1&lt;/p&gt;

&lt;h1 id=&#34;find-out-current-char-s-byte-length:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;find out current char&amp;rsquo;s byte length&lt;/h1&gt;

&lt;p&gt;if ((aStr[0] &amp;gt;= &amp;lsquo;\x81&amp;rsquo;) and (aStr[0] &amp;lt;= &amp;lsquo;\x9F&amp;rsquo;)) or &lt;/p&gt;

&lt;p&gt;((aStr[0] &amp;gt;= &amp;lsquo;\xE0&amp;rsquo;) and (aStr[0] &amp;lt;= &amp;lsquo;\xFC&amp;rsquo;)):
charLen = 2
else:
charLen = 1&lt;/p&gt;

&lt;p&gt;And where does aStr come from? Let’s pop the stack:
def feed(self, aBuf, aLen):&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;i = self._mNeedToSkipCharNum&lt;/p&gt;

&lt;p&gt;while i &amp;lt; aLen:&lt;/p&gt;

&lt;p&gt;order, charLen = self.get_order(aBuf[i:i+2])&lt;/p&gt;

&lt;p&gt;Oh look, it’s our old friend, aBuf. As you might have guessed from every other issue we’ve encountered in this chapter, aBuf is a byte array. Here, the feed() method isn’t just passing it on wholesale; it’s slicing it. But as you saw earlier
in
this
chapter, slicing a byte array returns a byte array, so the aStr parameter that gets passed to the get_order() method is still a byte array.
And what is this code trying to do with aStr? It’s taking the first element of the byte array and comparing it to a string of length 1. In Python 2, that worked, because aStr and aBuf were strings, and aStr[0] would be a string, and you can compare strings for inequality. But in Python 3, aStr and aBuf are byte arrays, aStr[0] is an integer, and you can’t compare integers and strings for inequality without explicitly coercing one of them.
In this case, there’s no need to make the code more complicated by adding an explicit coercion. aStr[0] yields an integer; the things you’re comparing to are all constants. Let’s change them from 1-character strings to integers. And while we’re at it, let’s change aStr to aBuf, since it’s not actually a string.
class SJISContextAnalysis(JapaneseContextAnalysis):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;def get_order(self, aStr):&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if not aStr: return -1, 1&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;def get_order(self, aBuf):&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if not aBuf: return -1, 1&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;find-out-current-char-s-byte-length-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;find out current char&amp;rsquo;s byte length&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;if ((aStr[0] &amp;gt;= &amp;lsquo;\x81&amp;rsquo;) and (aStr[0] &amp;lt;= &amp;lsquo;\x9F&amp;rsquo;)) or \&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;((aBuf[0] &amp;gt;= &amp;lsquo;\xE0&amp;rsquo;) and (aBuf[0] &amp;lt;= &amp;lsquo;\xFC&amp;rsquo;)):&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if ((aBuf[0] &amp;gt;= 0x81) and (aBuf[0] &amp;lt;= 0x9F)) or \&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;((aBuf[0] &amp;gt;= 0xE0) and (aBuf[0] &amp;lt;= 0xFC)):&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;charLen = 2
else:&lt;/p&gt;

&lt;p&gt;charLen = 1&lt;/p&gt;

&lt;h1 id=&#34;return-its-order-if-it-is-hiragana:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;return its order if it is hiragana&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;if len(aStr) &amp;gt; 1:&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if (aStr[0] == &amp;lsquo;\202&amp;rsquo;) and \&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;(aStr[1] &amp;gt;= &amp;lsquo;\x9F&amp;rsquo;) and \&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;(aStr[1] &amp;lt;= &amp;lsquo;\xF1&amp;rsquo;):&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;return ord(aStr[1]) - 0x9F, charLen&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if len(aBuf) &amp;gt; 1:&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if (aBuf[0] == 202) and \&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;(aBuf[1] &amp;gt;= 0x9F) and \&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;(aBuf[1] &amp;lt;= 0xF1):&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;return aBuf[1] - 0x9F, charLen&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;return -1, charLen&lt;/p&gt;

&lt;p&gt;class EUCJPContextAnalysis(JapaneseContextAnalysis):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;def get_order(self, aStr):&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if not aStr: return -1, 1&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;def get_order(self, aBuf):&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if not aBuf: return -1, 1&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;find-out-current-char-s-byte-length-2:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;find out current char&amp;rsquo;s byte length&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;if (aStr[0] == &amp;lsquo;\x8E&amp;rsquo;) or \&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;((aStr[0] &amp;gt;= &amp;lsquo;\xA1&amp;rsquo;) and (aStr[0] &amp;lt;= &amp;lsquo;\xFE&amp;rsquo;)):&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if (aBuf[0] == 0x8E) or \&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;((aBuf[0] &amp;gt;= 0xA1) and (aBuf[0] &amp;lt;= 0xFE)):&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;charLen = 2&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;elif aStr[0] == &amp;lsquo;\x8F&amp;rsquo;:&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;elif aBuf[0] == 0x8F:&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;charLen = 3
else:
charLen = 1&lt;/p&gt;

&lt;h1 id=&#34;return-its-order-if-it-is-hiragana-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;return its order if it is hiragana&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;if len(aStr) &amp;gt; 1:&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if (aStr[0] == &amp;lsquo;\xA4&amp;rsquo;) and \&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;(aStr[1] &amp;gt;= &amp;lsquo;\xA1&amp;rsquo;) and \&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;(aStr[1] &amp;lt;= &amp;lsquo;\xF3&amp;rsquo;):&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;return ord(aStr[1]) - 0xA1, charLen&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if len(aBuf) &amp;gt; 1:&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if (aBuf[0] == 0xA4) and \&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;(aBuf[1] &amp;gt;= 0xA1) and \&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;(aBuf[1] &amp;lt;= 0xF3):&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;return aBuf[1] - 0xA1, charLen&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;return -1, charLen&lt;/p&gt;

&lt;p&gt;Searching the entire codebase for occurrences of the ord() function uncovers the same problem in chardistribution.py (specifically, in the EUCTWDistributionAnalysis, EUCKRDistributionAnalysis, GB2312DistributionAnalysis, Big5DistributionAnalysis, SJISDistributionAnalysis, and EUCJPDistributionAnalysis classes. In each case, the fix is similar to the change we made to the EUCJPContextAnalysis and SJISContextAnalysis classes in jpcntx.py.&lt;/p&gt;

&lt;p&gt;15.6.9. GLOBAL NAME &amp;lsquo;reduce&amp;rsquo; IS NOT DEFINED
Once more into the breach…
C:\home\chardet&amp;gt; python test.py tests**&lt;/p&gt;

&lt;p&gt;tests\ascii\howto.diveintomark.org.xml ascii with confidence 1.0
tests\Big5\0804.blogspot.com.xml&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;test.py&amp;rdquo;, line 12, in &lt;module&gt;
u.close()
File &amp;ldquo;C:\home\chardet\chardet\universaldetector.py&amp;rdquo;, line 141, in close
proberConfidence = prober.get_confidence()
File &amp;ldquo;C:\home\chardet\chardet\latin1prober.py&amp;rdquo;, line 126, in get_confidence
total = reduce(operator.add, self._mFreqCounter)
NameError: global name &amp;lsquo;reduce&amp;rsquo; is not defined&lt;/p&gt;

&lt;p&gt;According to the official What’s
New
In
Python
3.0
guide, the reduce() function has been moved out of the global namespace and into the functools module. Quoting the guide: “Use functools.reduce() if you really need it; however, 99 percent of the time an explicit for loop is more readable.” You can read more about the decision from Guido van Rossum’s weblog: The
fate
of
reduce()
in
Python
3000.
def get_confidence(self):
if self.get_state() == constants.eNotMe:
return 0.01&lt;/p&gt;

&lt;p&gt;total = reduce(operator.add, self._mFreqCounter)&lt;/p&gt;

&lt;p&gt;The reduce() function takes two arguments — a function and a list (strictly speaking, any iterable object will do) — and applies the function cumulatively to each item of the list. In other words, this is a fancy and roundabout way of adding up all the items in a list and returning the result.
This monstrosity was so common that Python added a global sum() function.
def get_confidence(self):
if self.get_state() == constants.eNotMe:
return 0.01&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;total = reduce(operator.add, self._mFreqCounter)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;total = sum(self._mFreqCounter)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since you’re no longer using the operator module, you can remove that import from the top of the file as well.
from .charsetprober import CharSetProber
from . import constants&lt;/p&gt;

&lt;p&gt;-import operator&lt;/p&gt;

&lt;p&gt;I CAN HAZ TESTZ?&lt;/p&gt;

&lt;p&gt;C:\home\chardet&amp;gt; python test.py tests**&lt;/p&gt;

&lt;p&gt;tests\ascii\howto.diveintomark.org.xml  ascii with confidence 1.0&lt;br /&gt;
tests\Big5\0804.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\blog.worren.net.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\carbonxiv.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\catshadow.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\coolloud.org.tw.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\digitalwall.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\ebao.us.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\fudesign.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\kafkatseng.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\ke207.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\leavesth.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\letterlego.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\linyijen.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\marilynwu.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\myblog.pchome.com.tw.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\oui-design.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\sanwenji.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\sinica.edu.tw.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\sylvia1976.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\tlkkuo.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\tw.blog.xubg.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\unoriginalblog.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\upsaid.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\willythecop.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\Big5\ytc.blogspot.com.xml  Big5 with confidence 0.99&lt;br /&gt;
tests\EUC-JP\aivy.co.jp.xml  EUC-JP with confidence 0.99&lt;br /&gt;
tests\EUC-JP\akaname.main.jp.xml  EUC-JP with confidence 0.99&lt;br /&gt;
tests\EUC-JP\arclamp.jp.xml  EUC-JP with confidence 0.99&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
316 tests&lt;/p&gt;

&lt;p&gt;Holy crap, it actually works! /me does a little dance
.
15.7. SUMMARY
What have we learned?
1.  Porting any non-trivial amount of code from Python 2 to Python 3 is going to be a pain. There’s no way around it. It’s hard.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The automated
2to3 tool
is helpful as far as it goes, but it will only do the easy parts — function renames, module renames, syntax changes. It’s an impressive piece of engineering, but in the end it’s just an intelligent search-and-replace bot.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The #1 porting problem in this library was the difference between strings and bytes. In this case that seems obvious, since the whole point of the chardet library is to convert a stream of bytes into a string. But “a stream of bytes” comes up more often than you might think. Reading a file in “binary” mode? You’ll get a stream of bytes. Fetching a web page? Calling a web API? They return a stream of bytes, too.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You need to understand your program. Thoroughly. Preferably because you wrote it, but at the very least, you need to be comfortable with all its quirks and musty corners. The bugs are everywhere.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Test cases are essential. Don’t port anything without them. The only reason I have any confidence that chardet works in Python 3 is that I started with a test suite that exercised all major code paths. If you don’t have any tests, write some tests before you start porting to Python 3. If you have a few tests, write more. If you have a lot of tests, then the real fun can begin.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CHAPTER 16. PACKAGING PYTHON LIBRARIES&lt;/p&gt;

&lt;p&gt;. You’ll find the shame is like the pain; you only feel it once. .
— Marquise de Merteuil, Dangerous Liaisons
16.1. DIVING IN
Real artists ship. Or so says Steve Jobs. Do you want to release a Python script, library, framework, or application? Excellent. The world needs more Python code. Python 3 comes with a packaging framework called Distutils. Distutils is many things: a build tool (for you), an installation tool (for your users), a package metadata format (for search engines), and more. It integrates with the Python
Package
Index
(“PyPI”), a central repository for open source Python libraries.
All of these facets of Distutils center around the setup script, traditionally called setup.py. In fact, you’ve already seen several Distutils setup scripts in this book. You used Distutils to install httplib2 in HTTP
Web
Services
and again to install chardet in Case
Study:
Porting
chardet to
Python
3.
In this chapter, you’ll learn how the setup scripts for chardet and httplib2 work, and you’ll step through the process of releasing your own Python software.&lt;/p&gt;

&lt;h1 id=&#34;chardet-s-setup-py:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;chardet&amp;rsquo;s setup.py&lt;/h1&gt;

&lt;p&gt;from distutils.core import setup
setup(&lt;/p&gt;

&lt;p&gt;name = &amp;ldquo;chardet&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;packages = [&amp;ldquo;chardet&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;version = &amp;ldquo;1.0.2&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;description = &amp;ldquo;Universal encoding detector&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;author = &amp;ldquo;Mark Pilgrim&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;author_email = &amp;ldquo;mark@diveintomark.org&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;url = &amp;ldquo;&lt;a href=&#34;http://chardet.feedparser.org/&amp;quot;&#34;&gt;http://chardet.feedparser.org/&amp;quot;&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;download_url = &amp;ldquo;&lt;a href=&#34;http://chardet.feedparser.org/download/python3-chardet-1.0.1.tgz&amp;quot;&#34;&gt;http://chardet.feedparser.org/download/python3-chardet-1.0.1.tgz&amp;quot;&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;keywords = [&amp;ldquo;encoding&amp;rdquo;, &amp;ldquo;i18n&amp;rdquo;, &amp;ldquo;xml&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;classifiers = [&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Programming Language :: Python&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Programming Language :: Python :: 3&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Development Status :: 4 - Beta&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Environment :: Other Environment&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Intended Audience :: Developers&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;&amp;ldquo;License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)&amp;ldquo;,&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Operating System :: OS Independent&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Topic :: Software Development :: Libraries :: Python Modules&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Topic :: Text Processing :: Linguistic&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;],&lt;/p&gt;

&lt;p&gt;long_description = &amp;ldquo;&amp;rdquo;&amp;rdquo;\
Universal character encoding detector&lt;/p&gt;

&lt;p&gt;Detects&lt;/p&gt;

&lt;p&gt;-ASCII, UTF-8, UTF-16 (2 variants), UTF-32 (4 variants)&lt;/p&gt;

&lt;p&gt;-Big5, GB2312, EUC-TW, HZ-GB-2312, ISO-2022-CN (Traditional and Simplified Chinese)&lt;/p&gt;

&lt;p&gt;-EUC-JP, SHIFT_JIS, ISO-2022-JP (Japanese)&lt;/p&gt;

&lt;p&gt;-EUC-KR, ISO-2022-KR (Korean)&lt;/p&gt;

&lt;p&gt;-KOI8-R, MacCyrillic, IBM855, IBM866, ISO-8859-5, windows-1251 (Cyrillic)
- ISO-8859-2, windows-1250 (Hungarian)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ISO-8859-5, windows-1251 (Bulgarian)&lt;/li&gt;
&lt;li&gt;windows-1252 (English)&lt;/li&gt;
&lt;li&gt;ISO-8859-7, windows-1253 (Greek)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-ISO-8859-8, windows-1255 (Visual and Logical Hebrew)
- TIS-620 (Thai)&lt;/p&gt;

&lt;p&gt;This version requires Python 3 or later; a Python 2 version is available separately.
&amp;ldquo;&amp;rdquo;&amp;rdquo;
)&lt;/p&gt;

&lt;p&gt;. chardet and httplib2 are open source, but there’s no requirement that you release your own Python libraries under any particular license. The process described in this chapter will work for any Python software, regardless of license.
.
16.2. THINGS DISTUTILS CAN’T DO FOR YOU
Releasing your first Python package is a daunting process. (Releasing your second one is a little easier.) Distutils tries to automate as much of it as possible, but there are some things you simply must do yourself.
•   Choose a license. This is a complicated topic, fraught with politics and peril. If you wish to release your
software as open source, I humbly offer five pieces of advice:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Don’t write your own license.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Don’t write your own license.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Don’t write your own license.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It doesn’t need to be GPL, but it
needs
to
be
GPL-compatible.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Don’t write your own license.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;•   Classify your software using the PyPI classification system. I’ll explain what this means later in this chapter.&lt;/p&gt;

&lt;p&gt;•   Write a “read me” file. Don’t skimp on this. At a minimum, it should give your users an overview of
what your software does and how to install it.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;16.3. DIRECTORY STRUCTURE
To start packaging your Python software, you need to get your files and directories in order. The httplib2 directory looks like this:
httplib2/ .
|
+&amp;ndash;README.txt .
|
+&amp;ndash;setup.py .
|
+&amp;ndash;httplib2/ .&lt;/p&gt;

&lt;p&gt;|
+&amp;ndash;&lt;strong&gt;init&lt;/strong&gt;.py
|
+&amp;ndash;iri2uri.py&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Make a root directory to hold everything. Give it the same name as your Python module.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To accomodate Windows users, your “read me” file should include a .txt extension, and it should use Windows-style carriage returns. Just because you use a fancy text editor that runs from the command line and includes its own macro language, that doesn’t mean you need to make life difficult for your users. (Your users use Notepad. Sad but true.) Even if you’re on Linux or Mac OS X, your fancy text editor undoubtedly has an option to save files with Windows-style carriage returns.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Your Distutils setup script should be named setup.py unless you have a good reason not to. You do not have a good reason not to.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If your Python software is a single .py file, you should put it in the root directory along with your “read me” file and your setup script. But httplib2 is not a single .py file; it’s a
multi-file
module. But that’s OK! Just put the httplib2 directory in the root directory, so you have an &lt;strong&gt;init&lt;/strong&gt;.py file within an httplib2/ directory within the httplib2/ root directory. That’s not a problem; in fact, it will simplify your packaging process.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The chardet directory looks slightly different. Like httplib2, it’s a
multi-file
module, so there’s a chardet/ directory within the chardet/ root directory. In addition to the README.txt file, chardet has HTML-formatted documentation in the docs/ directory. The docs/ directory contains several .html and .css files and an images/ subdirectory, which contains several .png and .gif files. (This will be important later.) Also, in keeping with the convention for (L)GPL-licensed software, it has a separate file called COPYING.txt which contains the complete text of the LGPL.
chardet/
|
+&amp;ndash;COPYING.txt
|
+&amp;ndash;setup.py
|
+&amp;ndash;README.txt
|
+&amp;ndash;docs/&lt;/p&gt;

&lt;p&gt;|  |&lt;br /&gt;
|  +&amp;ndash;index.html&lt;br /&gt;
|  |&lt;br /&gt;
|  +&amp;ndash;usage.html&lt;br /&gt;
|  |&lt;br /&gt;
|  +&amp;ndash;images/ &amp;hellip;&lt;br /&gt;
|&lt;/p&gt;

&lt;p&gt;+&amp;ndash;chardet/
|
+&amp;ndash;&lt;strong&gt;init&lt;/strong&gt;.py
|
+&amp;ndash;big5freq.py
|
+&amp;ndash;&amp;hellip;&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;16.4. WRITING YOUR SETUP SCRIPT&lt;/p&gt;

&lt;p&gt;The Distutils setup script is a Python script. In theory, it can do anything Python can do. In practice, it should do as little as possible, in as standard a way as possible. Setup scripts should be boring. The more exotic your installation process is, the more exotic your bug reports will be.
The first line of every Distutils setup script is always the same:
from distutils.core import setup&lt;/p&gt;

&lt;p&gt;This imports the setup() function, which is the main entry point into Distutils. 95% of all Distutils setup scripts consist of a single call to setup() and nothing else. (I totally just made up that statistic, but if your Distutils setup script is doing more than calling the Distutils setup() function, you should have a good reason. Do you have a good reason? I didn’t think so.)
The setup() function can
take
dozens
of
parameters. For the sanity of everyone involved, you must use named
arguments
for every parameter. This is not merely a convention; it’s a hard requirement. Your setup script will crash if you try to call the setup() function with non-named arguments.
The following named arguments are required:
•   name, the name of the package.&lt;/p&gt;

&lt;p&gt;•   version, the version number of the package.&lt;/p&gt;

&lt;p&gt;•   author, your full name.&lt;/p&gt;

&lt;p&gt;•   author_email, your email address.&lt;/p&gt;

&lt;p&gt;•   url, the home page of your project. This can be your PyPI
package page if you don’t have a separate project website.&lt;/p&gt;

&lt;p&gt;Although not required, I recommend that you also include the following in your setup script:&lt;/p&gt;

&lt;p&gt;•   description, a one-line summary of the project.&lt;/p&gt;

&lt;p&gt;•   long_description, a multi-line string in reStructuredText
format. PyPI
converts this to HTML and displays it on your package page.&lt;/p&gt;

&lt;p&gt;•   classifiers, a list of specially-formatted strings described in the next section.&lt;/p&gt;

&lt;p&gt;. Setup script metadata is defined in PEP
314.
Now let’s look at the chardet setup script. It has all of these required and recommended parameters, plus one I haven’t mentioned yet: packages.
from distutils.core import setup&lt;/p&gt;

&lt;p&gt;setup(&lt;/p&gt;

&lt;p&gt;name = &amp;lsquo;chardet&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;packages = [&amp;lsquo;chardet&amp;rsquo;]
,&lt;/p&gt;

&lt;p&gt;version = &amp;lsquo;1.0.2&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;description = &amp;lsquo;Universal encoding detector&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;author=&amp;lsquo;Mark Pilgrim&amp;rsquo;,&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;)&lt;/p&gt;

&lt;p&gt;The packages parameter highlights an unfortunate vocabulary overlap in the distribution process. We’ve been talking about the “package” as the thing you’re building (and potentially listing in The Python “Package” Index). But that’s not what this packages parameter refers to. It refers to the fact that the chardet module is a
multi-file
module, sometimes known as… a “package.” The packages parameter tells Distutils to include the chardet/ directory, its &lt;strong&gt;init&lt;/strong&gt;.py file, and all the other .py files that constitute the chardet module. That’s kind of important; all this happy talk about documentation and metadata is irrelevant if you forget to include the actual code!
.&lt;/p&gt;

&lt;p&gt;16.5. CLASSIFYING YOUR PACKAGE
The Python Package Index (“PyPI”) contains thousands of Python libraries. Proper classification metadata will allow people to find yours more easily. PyPI lets you browse
packages
by
classifier. You can even select multiple classifiers to narrow your search. Classifiers are not invisible metadata that you can just ignore!
To classify your software, pass a classifiers parameter to the Distutils setup() function. The classifiers parameter is a list of strings. These strings are not freeform. All classifier strings should come from this
list
on
PyPI.
Classifiers are optional. You can write a Distutils setup script without any classifiers at all. Don’t do that. You should always include at least these classifiers:
•   Programming Language. In particular, you should include both &amp;ldquo;Programming Language :: Python&amp;rdquo; and &amp;ldquo;Programming Language :: Python :: 3&amp;rdquo;. If you do not include these, your package will not show up in this
list
of
Python
3-compatible
libraries, which linked from the sidebar of every single page of pypi.python.org.&lt;/p&gt;

&lt;p&gt;•   License. This is the absolute first thing I look for when I’m evaluating third-party libraries. Don’t make me hunt for this vital information. Don’t include more than one license classifier unless your software is explicitly available under multiple licenses. (And don’t release software under multiple licenses unless you’re forced to do so. And don’t force other people to do so. Licensing is enough of a headache; don’t make it worse.)&lt;/p&gt;

&lt;p&gt;•   Operating System. If your software only runs on Windows (or Mac OS X, or Linux), I want to know sooner rather than later. If your software runs anywhere without any platform-specific code, use the classifier &amp;ldquo;Operating System :: OS Independent&amp;rdquo;. Multiple Operating System classifiers are only necessary if your software requires specific support for each platform. (This is not common.)&lt;/p&gt;

&lt;p&gt;I also recommend that you include the following classifiers:&lt;/p&gt;

&lt;p&gt;•   Development Status. Is your software beta quality? Alpha quality? Pre-alpha? Pick one. Be honest.&lt;/p&gt;

&lt;p&gt;•   Intended Audience. Who would download your software? The most common choices are Developers, End Users/Desktop, Science/Research, and System Administrators.&lt;/p&gt;

&lt;p&gt;•   Framework. If your software is a plugin for a larger Python framework like Django
or Zope, include the appropriate Framework classifier. If not, omit it.&lt;/p&gt;

&lt;p&gt;•   Topic. There are a
large
number
of
topics
to
choose
from; choose all that apply.&lt;/p&gt;

&lt;p&gt;16.5.1. EXAMPLES OF GOOD PACKAGE CLASSIFIERS
By way of example, here are the classifiers for Django, a production-ready, cross-platform, BSD-licensed web application framework that runs on your web server. (Django is not yet compatible with Python 3, so the Programming Language :: Python :: 3 classifier is not listed.)
Programming Language :: Python&lt;/p&gt;

&lt;p&gt;License :: OSI Approved :: BSD License
Operating System :: OS Independent
Development Status :: 5 - Production/Stable
Environment :: Web Environment
Framework :: Django
Intended Audience :: Developers
Topic :: Internet :: WWW/HTTP
Topic :: Internet :: WWW/HTTP :: Dynamic Content
Topic :: Internet :: WWW/HTTP :: WSGI
Topic :: Software Development :: Libraries :: Python Modules&lt;/p&gt;

&lt;p&gt;Here are the classifiers for chardet, the character encoding detection library covered in Case
Study:
Porting
chardet to
Python
3. chardet is beta quality, cross-platform, Python 3-compatible, LGPL-licensed, and intended for developers to integrate into their own products.
Programming Language :: Python
Programming Language :: Python :: 3
License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)
Operating System :: OS Independent
Development Status :: 4 - Beta
Environment :: Other Environment
Intended Audience :: Developers
Topic :: Text Processing :: Linguistic
Topic :: Software Development :: Libraries :: Python Modules&lt;/p&gt;

&lt;p&gt;And here are the classifiers for httplib2, the library featured in the HTTP
Web
Services
chapter. httplib2 is beta quality, cross-platform, MIT-licensed, and intended for Python developers.
Programming Language :: Python
Programming Language :: Python :: 3
License :: OSI Approved :: MIT License
Operating System :: OS Independent
Development Status :: 4 - Beta
Environment :: Web Environment
Intended Audience :: Developers
Topic :: Internet :: WWW/HTTP
Topic :: Software Development :: Libraries :: Python Modules&lt;/p&gt;

&lt;p&gt;16.6. SPECIFYING ADDITIONAL FILES WITH A MANIFEST
By default, Distutils will include the following files in your release package:
• README.txt&lt;/p&gt;

&lt;p&gt;• setup.py&lt;/p&gt;

&lt;p&gt;• The .py files needed by the multi-file modules listed in the packages parameter&lt;/p&gt;

&lt;p&gt;• The individual .py files listed in the py_modules parameter&lt;/p&gt;

&lt;p&gt;That will cover all
the
files
in
the
httplib2 project. But for the chardet project, we also want to include the COPYING.txt license file and the entire docs/ directory that contains images and HTML files. To tell Distutils to include these additional files and directories when it builds the chardet release package, you need a manifest file.
A manifest file is a text file called MANIFEST.in. Place it in the project’s root directory, next to README.txt and setup.py. Manifest files are not Python scripts; they are text files that contain a series of “commands” in a Distutils-defined format. Manifest commands allow you to include or exclude specific files and directories.
This is the entire manifest file for the chardet project:
include COPYING.txt .
recursive-include docs *.html *.css *.png *.gif .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The first line is self-explanatory: include the COPYING.txt file from the project’s root directory.&lt;/li&gt;
&lt;li&gt;The second line is a bit more complicated. The recursive-include command takes a directory name and one or more filenames. The filenames aren’t limited to specific files; they can include wildcards. This line means “See that docs/ directory in the project’s root directory? Look in there (recursively) for .html, .css, .png, and .gif files. I want all of them in my release package.”
All manifest commands preserve the directory structure that you set up in your project directory. That recursive-include command is not going to put a bunch of .html and .png files in the root directory of the release package. It’s going to maintain the existing docs/ directory structure, but only include those files inside that directory that match the given wildcards. (I didn’t mention it earlier, but the chardet documentation is actually written in XML and converted to HTML by a separate script. I don’t want to include the XML files in the release package, just the HTML and the images.)
. Manifest files have their own unique format. See Specifying
the
files
to
distribute
and the
manifest
template
commands
for details.
To reiterate: you only need to create a manifest file if you want to include files that Distutils doesn’t include by default. If you do need a manifest file, it should only include the files and directories that Distutils wouldn’t otherwise find on its own.
16.7. CHECKING YOUR SETUP SCRIPT FOR ERRORS
There’s a lot to keep track of. Distutils comes with a built-in validation command that checks that all the required metadata is present in your setup script. For example, if you forget to include the version parameter, Distutils will remind you.
c:\Users\pilgrim\chardet&amp;gt; c:\python31\python.exe setup.py check
running check
warning: check: missing required meta-data: version&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Once you include a version parameter (and all the other required bits of metadata), the check command will look like this:
c:\Users\pilgrim\chardet&amp;gt; c:\python31\python.exe setup.py check
running check&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;16.8. CREATING A SOURCE DISTRIBUTION
Distutils supports building multiple types of release packages. At a minimum, you should build a “source distribution” that contains your source code, your Distutils setup script, your “read me” file, and whatever additional
files
you
want
to
include. To build a source distribution, pass the sdist command to your Distutils setup script.
c:\Users\pilgrim\chardet&amp;gt; c:\python31\python.exe setup.py sdist
running sdist
running check
reading manifest template &amp;lsquo;MANIFEST.in&amp;rsquo;
writing manifest file &amp;lsquo;MANIFEST&amp;rsquo;
creating chardet-1.0.2
creating chardet-1.0.2\chardet
creating chardet-1.0.2\docs
creating chardet-1.0.2\docs\images
copying files to chardet-1.0.2&amp;hellip;
copying COPYING -&amp;gt; chardet-1.0.2
copying README.txt -&amp;gt; chardet-1.0.2
copying setup.py -&amp;gt; chardet-1.0.2
copying chardet__init__.py -&amp;gt; chardet-1.0.2\chardet
copying chardet\big5freq.py -&amp;gt; chardet-1.0.2\chardet
&amp;hellip;
copying chardet\universaldetector.py -&amp;gt; chardet-1.0.2\chardet
copying chardet\utf8prober.py -&amp;gt; chardet-1.0.2\chardet
copying docs\faq.html -&amp;gt; chardet-1.0.2\docs
copying docs\history.html -&amp;gt; chardet-1.0.2\docs
copying docs\how-it-works.html -&amp;gt; chardet-1.0.2\docs
copying docs\index.html -&amp;gt; chardet-1.0.2\docs
copying docs\license.html -&amp;gt; chardet-1.0.2\docs
copying docs\supported-encodings.html -&amp;gt; chardet-1.0.2\docs
copying docs\usage.html -&amp;gt; chardet-1.0.2\docs
copying docs\images\caution.png -&amp;gt; chardet-1.0.2\docs\images
copying docs\images\important.png -&amp;gt; chardet-1.0.2\docs\images
copying docs\images\note.png -&amp;gt; chardet-1.0.2\docs\images
copying docs\images\permalink.gif -&amp;gt; chardet-1.0.2\docs\images
copying docs\images\tip.png -&amp;gt; chardet-1.0.2\docs\images
copying docs\images\warning.png -&amp;gt; chardet-1.0.2\docs\images
creating dist
creating &amp;lsquo;dist\chardet-1.0.2.zip&amp;rsquo; and adding &amp;lsquo;chardet-1.0.2&amp;rsquo; to it
adding &amp;lsquo;chardet-1.0.2\COPYING&amp;rsquo;&lt;/p&gt;

&lt;p&gt;adding &amp;lsquo;chardet-1.0.2\PKG-INFO&amp;rsquo;&lt;/p&gt;

&lt;p&gt;adding &amp;lsquo;chardet-1.0.2\README.txt&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\setup.py&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\chardet\big5freq.py&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\chardet\big5prober.py&amp;rsquo;
&amp;hellip;
adding &amp;lsquo;chardet-1.0.2\chardet\universaldetector.py&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\chardet\utf8prober.py&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\chardet__init__.py&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\faq.html&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\history.html&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\how-it-works.html&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\index.html&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\license.html&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\supported-encodings.html&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\usage.html&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\images\caution.png&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\images\important.png&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\images\note.png&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\images\permalink.gif&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\images\tip.png&amp;rsquo;
adding &amp;lsquo;chardet-1.0.2\docs\images\warning.png&amp;rsquo;
removing &amp;lsquo;chardet-1.0.2&amp;rsquo; (and everything under it)&lt;/p&gt;

&lt;p&gt;Several things to note here:
•   Distutils noticed the manifest file (MANIFEST.in).&lt;/p&gt;

&lt;p&gt;•   Distutils successfully parsed the manifest file and added the additional files we wanted — COPYING.txt and the HTML and image files in the docs/ directory.&lt;/p&gt;

&lt;p&gt;•   If you look in your project directory, you’ll see that Distutils created a dist/ directory. Within the dist/ directory the .zip file that you can distribute.&lt;/p&gt;

&lt;p&gt;c:\Users\pilgrim\chardet&amp;gt; dir dist
Volume in drive C has no label.
Volume Serial Number is DED5-B4F8&lt;/p&gt;

&lt;p&gt;Directory of c:\Users\pilgrim\chardet\dist&lt;/p&gt;

&lt;p&gt;07/30/2009 06:29 PM &lt;DIR&gt; .
07/30/2009 06:29 PM &lt;DIR&gt; ..
07/30/2009 06:29 PM 206,440 chardet-1.0.2.zip&lt;/p&gt;

&lt;p&gt;1 File(s) 206,440 bytes
2 Dir(s) 61,424,635,904 bytes free&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;16.9. CREATING A GRAPHICAL INSTALLER
In my opinion, every Python library deserves a graphical installer for Windows users. It’s easy to make (even if you don’t run Windows yourself), and Windows users appreciate it.
Distutils can create
a
graphical
Windows
installer
for
you, by passing the bdist_wininst command to your Distutils setup script.
c:\Users\pilgrim\chardet&amp;gt; c:\python31\python.exe setup.py bdist_wininst&lt;/p&gt;

&lt;p&gt;running bdist_wininst
running build
running build_py
creating build
creating build\lib
creating build\lib\chardet
copying chardet\big5freq.py -&amp;gt; build\lib\chardet
copying chardet\big5prober.py -&amp;gt; build\lib\chardet
&amp;hellip;
copying chardet\universaldetector.py -&amp;gt; build\lib\chardet
copying chardet\utf8prober.py -&amp;gt; build\lib\chardet
copying chardet__init&lt;strong&gt;.py -&amp;gt; build\lib\chardet
installing to build\bdist.win32\wininst
running install_lib
creating build\bdist.win32
creating build\bdist.win32\wininst
creating build\bdist.win32\wininst\PURELIB
creating build\bdist.win32\wininst\PURELIB\chardet
copying build\lib\chardet\big5freq.py -&amp;gt; build\bdist.win32\wininst\PURELIB\chardet
copying build\lib\chardet\big5prober.py -&amp;gt; build\bdist.win32\wininst\PURELIB\chardet
&amp;hellip;
copying build\lib\chardet\universaldetector.py -&amp;gt; build\bdist.win32\wininst\PURELIB\chardet
copying build\lib\chardet\utf8prober.py -&amp;gt; build\bdist.win32\wininst\PURELIB\chardet
copying build\lib\chardet__init&lt;/strong&gt;.py -&amp;gt; build\bdist.win32\wininst\PURELIB\chardet
running install_egg_info
Writing build\bdist.win32\wininst\PURELIB\chardet-1.0.2-py3.1.egg-info
creating &amp;lsquo;c:\users\pilgrim\appdata\local\temp\tmp2f4h7e.zip&amp;rsquo; and adding &amp;lsquo;.&amp;rsquo; to it
adding &amp;lsquo;PURELIB\chardet-1.0.2-py3.1.egg-info&amp;rsquo;
adding &amp;lsquo;PURELIB\chardet\big5freq.py&amp;rsquo;
adding &amp;lsquo;PURELIB\chardet\big5prober.py&amp;rsquo;
&amp;hellip;
adding &amp;lsquo;PURELIB\chardet\universaldetector.py&amp;rsquo;
adding &amp;lsquo;PURELIB\chardet\utf8prober.py&amp;rsquo;&lt;/p&gt;

&lt;p&gt;adding &amp;lsquo;PURELIB\chardet__init__.py&amp;rsquo;&lt;/p&gt;

&lt;p&gt;removing &amp;lsquo;build\bdist.win32\wininst&amp;rsquo; (and everything under it)
c:\Users\pilgrim\chardet&amp;gt; dir dist
c:\Users\pilgrim\chardet&amp;gt;dir dist&lt;/p&gt;

&lt;p&gt;Volume in drive C has no label.
Volume Serial Number is AADE-E29F&lt;/p&gt;

&lt;p&gt;Directory of c:\Users\pilgrim\chardet\dist&lt;/p&gt;

&lt;p&gt;07/30/2009 10:14 PM &lt;DIR&gt; .
07/30/2009 10:14 PM &lt;DIR&gt; ..
07/30/2009 10:14 PM 371,236 chardet-1.0.2.win32.exe
07/30/2009 06:29 PM 206,440 chardet-1.0.2.zip&lt;/p&gt;

&lt;p&gt;2 File(s) 577,676 bytes
2 Dir(s) 61,424,070,656 bytes free&lt;/p&gt;

&lt;p&gt;16.9.1. BUILDING INSTALLABLE PACKAGES FOR OTHER OPERATING SYSTEMS
Distutils can help you build
installable
packages
for
Linux
users. In my opinion, this probably isn’t worth your time. If you want your software distributed for Linux, your time would be better spent working with community members who specialize in packaging software for major Linux distributions.
For example, my chardet library is in
the
Debian
GNU/Linux
repositories
(and therefore in
the
Ubuntu
repositories
as well). I had nothing to do with this; the packages just showed up there one day. The Debian community has their
own
policies
for
packaging
Python
libraries, and the Debian python-chardet package is designed to follow these conventions. And since the package lives in Debian’s repositories, Debian users will receive security updates and/or new versions, depending on the system-wide settings they’ve chosen to manage their own computers.
The Linux packages that Distutils builds offer none of these advantages. Your time is better spent elsewhere.
.&lt;/p&gt;

&lt;p&gt;16.10. ADDING YOUR SOFTWARE TO THE PYTHON PACKAGE INDEX&lt;/p&gt;

&lt;p&gt;Uploading software to the Python Package Index is a three step process.
1. Register yourself&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Register your software&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Upload the packages you created with setup.py sdist and setup.py bdist_*&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To register yourself, go to the
PyPI
user
registration
page. Enter your desired username and password, provide a valid email address, and click the Register button. (If you have a PGP or GPG key, you can also provide that. If you don’t have one or don’t know what that means, don’t worry about it.) Check your email; within a few minutes, you should receive a message from PyPI with a validation link. Click the link to complete the registration process.
Now you need to register your software with PyPI and upload it. You can do this all in one step.
c:\Users\pilgrim\chardet&amp;gt; c:\python31\python.exe setup.py register sdist bdist_wininst upload&lt;/p&gt;

&lt;p&gt;running register
We need to know who you are, so please choose either:&lt;/p&gt;

&lt;p&gt;1.
 use your existing login,&lt;/p&gt;

&lt;p&gt;2.
 register as a new user,&lt;/p&gt;

&lt;p&gt;3.
 have the server generate a new password for you (and email it to you), or&lt;/p&gt;

&lt;p&gt;4.
 quit&lt;/p&gt;

&lt;p&gt;Your selection [default 1]: 1&lt;/p&gt;

&lt;p&gt;Username: MarkPilgrim
Password:&lt;/p&gt;

&lt;p&gt;Registering chardet to &lt;a href=&#34;http://pypi.python.org/pypi&#34;&gt;http://pypi.python.org/pypi&lt;/a&gt;
Server response (200): OK&lt;/p&gt;

&lt;p&gt;running sdist
&amp;hellip; output trimmed for brevity &amp;hellip;&lt;/p&gt;

&lt;p&gt;running bdist_wininst
&amp;hellip; output trimmed for brevity &amp;hellip;
running upload
Submitting dist\chardet-1.0.2.zip to &lt;a href=&#34;http://pypi.python.org/pypi&#34;&gt;http://pypi.python.org/pypi&lt;/a&gt;
Server response (200): OK
Submitting dist\chardet-1.0.2.win32.exe to &lt;a href=&#34;http://pypi.python.org/pypi&#34;&gt;http://pypi.python.org/pypi&lt;/a&gt;
Server response (200): OK
I can store your PyPI login so future submissions will be faster.
(the login will be stored in c:\home.pypirc)&lt;/p&gt;

&lt;p&gt;Save your login (y/N)?n&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;When you release your project for the first time, Distutils will add your software to the Python Package Index and give it its own URL. Every time after that, it will simply update the project metadata with any changes you may have made in your setup.py parameters. Next, it builds a source distribution (sdist) and a Windows installer (bdist_wininst), then uploads them to PyPI (upload).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Type 1 or just press ENTER to select “use your existing login.”&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Enter the username and password you selected on the the
PyPI
user
registration
page. Distuils will not echo your password; it will not even echo asterisks in place of characters. Just type your password and press ENTER.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Distutils registers your package with the Python Package Index…&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;…builds your source distribution…&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;…builds your Windows installer…&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;…and uploads them both to the Python Package Index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you want to automate the process of releasing new versions, you need to save your PyPI credentials in a local file. This is completely insecure and completely optional.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Congratulations, you now have your own page on the Python Package Index! The address is
&lt;a href=&#34;http://pypi.python.org/pypi/NAME&#34;&gt;http://pypi.python.org/pypi/NAME&lt;/a&gt;, where NAME is the string you passed in the name parameter in your
setup.py file.&lt;/p&gt;

&lt;p&gt;If you want to release a new version, just update your setup.py with the new version number, then run the same upload command again:
c:\Users\pilgrim\chardet&amp;gt; c:\python31\python.exe setup.py register sdist bdist_wininst upload&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;16.11. THE MANY POSSIBLE FUTURES OF PYTHON PACKAGING
Distutils is not the be-all and end-all of Python packaging, but as of this writing (August 2009), it’s the only
packaging framework that works in Python 3. There are a number of other frameworks for Python 2; some
focus on installation, others on testing and deployment. Some or all of these may end up being ported to
Python 3 in the future.&lt;/p&gt;

&lt;p&gt;These frameworks focus on installation:
•   Setuptools&lt;/p&gt;

&lt;p&gt;•   Pip&lt;/p&gt;

&lt;p&gt;•   Distribute&lt;/p&gt;

&lt;p&gt;These focus on testing and deployment:
•  virtualenv&lt;br /&gt;
•  zc.buildout&lt;br /&gt;
•  Paver&lt;/p&gt;

&lt;p&gt;•  Fabric&lt;/p&gt;

&lt;p&gt;•  py2exe&lt;/p&gt;

&lt;p&gt;.
16.12. FURTHER READING
On Distutils:
• Distributing
Python
Modules
with
Distutils&lt;/p&gt;

&lt;p&gt;• Core
Distutils
functionality
lists all the possible arguments to the setup() function&lt;/p&gt;

&lt;p&gt;• Distutils
Cookbook&lt;/p&gt;

&lt;p&gt;• PEP
370:
Per
user
site-packages directory&lt;/p&gt;

&lt;p&gt;• PEP
370
and
“environment
stew”&lt;/p&gt;

&lt;p&gt;On other packaging frameworks:&lt;/p&gt;

&lt;p&gt;• The
Python
packaging
ecosystem&lt;/p&gt;

&lt;p&gt;• On
packaging&lt;/p&gt;

&lt;p&gt;• A
few
corrections
to
“On
packaging”&lt;/p&gt;

&lt;p&gt;• Why
I
like
Pip&lt;/p&gt;

&lt;p&gt;• Python
packaging:
a
few
observations&lt;/p&gt;

&lt;p&gt;• Nobody
expects
Python
packaging!&lt;/p&gt;

&lt;p&gt;CHAPTER 17. PORTING CODE TO PYTHON 3 WITH&lt;/p&gt;

&lt;p&gt;2to3&lt;/p&gt;

&lt;p&gt;. Life is pleasant. Death is peaceful. It’s the transition that’s troublesome. .
— Isaac Asimov (attributed)
17.1. DIVING IN
So much has changed between Python 2 and Python 3, there are vanishingly few programs that will run unmodified under both. But don’t despair! To help with this transition, Python 3 comes with a utility script called 2to3, which takes your actual Python 2 source code as input and auto-converts as much as it can to Python 3. Case
study:
porting
chardet to
Python
3
describes how to run the 2to3 script, then shows some things it can’t fix automatically. This appendix documents what it can fix automatically.
17.2. print STATEMENT
In Python 2, print was a statement. Whatever you wanted to print simply followed the print keyword. In Python 3, print() is
a
function. Whatever you want to print, pass it to print() like any other function.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To print a blank line, call print() without any arguments.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To print a single value, call print() with one argument.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To print two values separated by a space, call print() with two arguments.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This one is a little tricky. In Python 2, if you ended a print statement with a comma, it would print the values separated by spaces, then print a trailing space, then stop without printing a carriage return. (Technically, it’s a little more complicated than that. The print statement in Python 2 used a now-deprecated attribute called softspace. Instead of printing a space, Python 2 would set sys.stdout.softspace to 1. The space character wasn’t really printed until something else got printed on the same line. If the next print statement printed a carriage return, sys.stdout.softspace would be set to 0 and the space would never be printed. You probably never noticed the difference unless your application was sensitive to the presence or absence of trailing whitespace in print-generated output.) In Python 3, the way to do this is to pass end=&amp;rsquo; &amp;lsquo; as a keyword argument to the print() function. The end argument defaults to &amp;lsquo;\n&amp;rsquo; (a carriage return), so overriding it will suppress the carriage return after printing the other arguments.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In Python 2, you could redirect the output to a pipe — like sys.stderr — by using the &amp;gt;&amp;gt;pipe_name syntax. In Python 3, the way to do this is to pass the pipe in the file keyword argument. The file argument defaults to sys.stdout (standard out), so overriding it will output to a different pipe instead.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.3. UNICODE STRING LITERALS
Python 2 had two string types: Unicode strings and non-Unicode strings. Python 3 has one string type: Unicode
strings.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Unicode string literals are simply converted into string literals, which, in Python 3, are always Unicode.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unicode raw strings (in which Python does not auto-escape backslashes) are converted to raw strings. In Python 3, raw strings are always Unicode.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.4. unicode() GLOBAL FUNCTION
Python 2 had two global functions to coerce objects into strings: unicode() to coerce them into Unicode strings, and str() to coerce them into non-Unicode strings. Python 3 has only one string type, Unicode
strings, so the str() function is all you need. (The unicode() function no longer exists.)&lt;/p&gt;

&lt;p&gt;17.5. long DATA TYPE
Python 2 had separate int and long types for non-floating-point numbers. An int could not be any larger than sys.maxint, which varied by platform. Longs were defined by appending an L to the end of the number, and they could be, well, longer than ints. In Python 3, there
is
only
one
integer
type, called int, which mostly behaves like the long type in Python 2. Since there are no longer two types, there is no need for special syntax to distinguish them.
Further reading: PEP
237:
Unifying
Long
Integers
and
Integers.&lt;/p&gt;

&lt;p&gt;Notes&lt;/p&gt;

&lt;p&gt;Python 2&lt;/p&gt;

&lt;p&gt;.
x = 1000000000000L&lt;/p&gt;

&lt;p&gt;.
x = 0xFFFFFFFFFFFFL&lt;/p&gt;

&lt;p&gt;.
long(x)&lt;/p&gt;

&lt;p&gt;.
type(x) is long&lt;/p&gt;

&lt;p&gt;.
isinstance(x, long)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Base 10 long integer literals become base 10 integer literals.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Base 16 long integer literals become base 16 integer literals.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Python 3
x = 1000000000000
x = 0xFFFFFFFFFFFF
int(x)
type(x) is int
isinstance(x, int)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In Python 3, the old long() function no longer exists, since longs don’t exist. To coerce a variable to an integer, use the int() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To check whether a variable is an integer, get its type and compare it to int, not long.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can also use the isinstance() function to check data types; again, use int, not long, to check for integers.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.6. &amp;lt;&amp;gt; COMPARISON
Python 2 supported &amp;lt;&amp;gt; as a synonym for !=, the not-equals comparison operator. Python 3 supports the != operator, but not &amp;lt;&amp;gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A simple comparison.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A more complex comparison between three values.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.7. has_key() DICTIONARY METHOD
In Python 2, dictionaries had a has_key() method to test whether the dictionary had a certain key. In Python 3, this method no longer exists. Instead, you need to use the
in operator.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The simplest form.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The in operator takes precedence over the or operator, so there is no need for parentheses around x in a_dictionary or around y in a_dictionary.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;On the other hand, you do need parentheses around x or y here, for the same reason — in takes precedence over or. (Note: this code is completely different from the previous line. Python interprets x or y first, which results in either x (if x is true
in
a
boolean
context) or y. Then it takes that singular value and checks whether it is a key in a_dictionary.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The + operator takes precedence over the in operator, so this form technically doesn’t need parentheses around x+y, but 2to3 includes them anyway.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This form definitely needs parentheses around y in a_dictionary, since the + operator takes precedence over the in operator.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.8. DICTIONARY METHODS THAT RETURN LISTS&lt;/p&gt;

&lt;p&gt;In Python 2, many dictionary methods returned lists. The most frequently used methods were keys(), items(), and values(). In Python 3, all of these methods return dynamic views. In some contexts, this is not a problem. If the method’s return value is immediately passed to another function that iterates through the entire sequence, it makes no difference whether the actual type is a list or a view. In other contexts, it matters a great deal. If you were expecting a complete list with individually addressable elements, your code&lt;/p&gt;

&lt;p&gt;will choke, because views do not support indexing.
Notes  Python 2&lt;br /&gt;
.  a_dictionary.keys()&lt;br /&gt;
.  a_dictionary.items()&lt;br /&gt;
.  a_dictionary.iterkeys()&lt;br /&gt;
.  [i for i in a_dictionary.iterkeys()]&lt;br /&gt;
.  min(a_dictionary.keys())&lt;/p&gt;

&lt;p&gt;Python 3
list(a_dictionary.keys())
list(a_dictionary.items())
iter(a_dictionary.keys())
[i for i in a_dictionary.keys()]&lt;/p&gt;

&lt;p&gt;no change
1.  2to3 errs on the side of safety, converting the return value from keys() to a static list with the list() function. This will always work, but it will be less efficient than using a view. You should examine the converted code to see if a list is absolutely necessary, or if a view would do.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Another view-to-list conversion, with the items() method. 2to3 will do the same thing with the values() method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python 3 does not support the iterkeys() method anymore. Use keys(), and if necessary, convert the view to an iterator with the iter() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2to3 recognizes when the iterkeys() method is used inside a list comprehension, and converts it to the keys() method (without wrapping it in an extra call to iter()). This works because views are iterable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2to3 recognizes that the keys() method is immediately passed to a function which iterates through an entire sequence, so there is no need to convert the return value to a list first. The min() function will happily iterate through the view instead. This applies to min(), max(), sum(), list(), tuple(), set(), sorted(), any(), and all().&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.9. MODULES THAT HAVE BEEN RENAMED OR REORGANIZED
Several modules in the Python Standard Library have been renamed. Several other modules which are related to each other have been combined or reorganized to make their association more logical.
17.9.1. http
In Python 3, several related HTTP modules have been combined into a single package, http.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The http.client module implements a low-level library that can request HTTP resources and interpret HTTP responses.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The http.cookies module provides a Pythonic interface to browser cookies that are sent in a Set-Cookie: HTTP header.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The http.cookiejar module manipulates the actual files on disk that popular web browsers use to store cookies.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The http.server module provides a basic HTTP server.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.9.2. urllib
Python 2 had a rat’s nest of overlapping modules to parse, encode, and fetch URLS. In Python 3, these have all been refactored and combined in a single package, urllib.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The old urllib module in Python 2 had a variety of functions, including urlopen() for fetching data and splittype(), splithost(), and splituser() for splitting a URL into its constituent parts. These functions have been reorganized more logically within the new urllib package. 2to3 will also change all calls to these functions so they use the new naming scheme.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The old urllib2 module in Python 2 has been folded into the urllib package in Python 3. All your urllib2 favorites — the build_opener() method, Request objects, and HTTPBasicAuthHandler and friends — are still available.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The urllib.parse module in Python 3 contains all the parsing functions from the old urlparse module in Python 2.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The urllib.robotparser module parses robots.txt files.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The FancyURLopener class, which handles HTTP redirects and other status codes, is still available in the new urllib.request module. The urlencode() function has moved to urllib.parse.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The Request object is still available in urllib.request, but constants like HTTPError have been moved to urllib.error.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Did I mention that 2to3 will rewrite your function calls too? For example, if your Python 2 code imports the urllib module and calls urllib.urlopen() to fetch data, 2to3 will fix both the import statement and the function call.
Notes Python 2 Python 3
import urllib&lt;/p&gt;

&lt;p&gt;import urllib.request, urllib.parse, urllib.error
print urllib.urlopen(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/&#39;).read(&#34;&gt;http://diveintopython3.org/&#39;).read(&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;print(urllib.request.urlopen(&amp;lsquo;&lt;a href=&#34;http://diveintopython3.org/&#39;).read()&#34;&gt;http://diveintopython3.org/&#39;).read()&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;17.9.3. dbm
All the various DBM clones are now in a single package, dbm. If you need a specific variant like GNU DBM , you can import the appropriate module within the dbm package.&lt;/p&gt;

&lt;p&gt;17.9.4. xmlrpc
XML-RPC is a lightweight method of performing remote RPC calls over HTTP. The XML-RPC client library and several XML-RPC server implementations are now combined in a single package, xmlrpc.&lt;/p&gt;

&lt;p&gt;17.9.5. OTHER MODULES&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A common idiom in Python 2 was to try to import cStringIO as StringIO, and if that failed, to import StringIO instead. Do not do this in Python 3; the io module does it for you. It will find the fastest implementation available and use it automatically.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A similar idiom was used to import the fastest pickle implementation. Do not do this in Python 3; the pickle module does it for you.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The builtins module contains the global functions, classes, and constants used throughout the Python language. Redefining a function in the builtins module will redefine the global function everywhere. That is exactly as powerful and scary as it sounds.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The copyreg module adds pickle support for custom types defined in C.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The queue module implements a multi-producer, multi-consumer queue.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The socketserver module provides generic base classes for implementing different kinds of socket servers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The configparser module parses INI-style configuration files.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The reprlib module reimplements the built-in repr() function, with additional controls on how long the representations can be before they are truncated.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The subprocess module allows you to spawn processes, connect to their pipes, and obtain their return codes.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.10. RELATIVE IMPORTS WITHIN A PACKAGE
A package is a group of related modules that function as a single entity. In Python 2, when modules within a package need to reference each other, you use import foo or from foo import Bar. The Python 2 interpreter first searches within the current package to find foo.py, and then moves on to the other directories in the Python search path (sys.path). Python 3 works a bit differently. Instead of searching the current package, it goes directly to the Python search path. If you want one module within a package to import another module in the same package, you need to explicitly provide the relative path between the two modules.
Suppose you had this package, with multiple files in the same directory:
chardet/
|
+&amp;ndash;&lt;strong&gt;init&lt;/strong&gt;.py
|
+&amp;ndash;constants.py
|
+&amp;ndash;mbcharsetprober.py
|
+&amp;ndash;universaldetector.py&lt;/p&gt;

&lt;p&gt;Now suppose that universaldetector.py needs to import the entire constants.py file and one class from mbcharsetprober.py. How do you do it?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;When you need to import an entire module from elsewhere in your package, use the new from . import syntax. The period is actually a relative path from this file (universaldetector.py) to the file you want to import (constants.py). In this case, they are in the same directory, thus the single period. You can also import from the parent directory (from .. import anothermodule) or a subdirectory.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To import a specific class or function from another module directly into your module’s namespace, prefix the target module with a relative path, minus the trailing slash. In this case, mbcharsetprober.py is in the same directory as universaldetector.py, so the path is a single period. You can also import form the parent directory (from ..anothermodule import AnotherClass) or a subdirectory.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.11. next() ITERATOR METHOD
In Python 2, iterators had a next() method which returned the next item in the sequence. That’s still true in Python 3, but there is now also a
global
next() function
that takes an iterator as an argument.&lt;/p&gt;

&lt;p&gt;Notes&lt;/p&gt;

&lt;p&gt;Python 2&lt;/p&gt;

&lt;p&gt;Python 3
.
anIterator.next()&lt;/p&gt;

&lt;p&gt;next(anIterator)&lt;/p&gt;

&lt;p&gt;.
a_function_that_returns_an_iterator().next()&lt;/p&gt;

&lt;p&gt;next(a_function_that_returns_an_iterator())&lt;/p&gt;

&lt;p&gt;class A:&lt;/p&gt;

&lt;p&gt;class A:
def next(self):&lt;/p&gt;

&lt;p&gt;.
def &lt;strong&gt;next&lt;/strong&gt;(self):
pass&lt;/p&gt;

&lt;p&gt;pass&lt;/p&gt;

&lt;p&gt;class A:&lt;/p&gt;

&lt;p&gt;.
no change
def next(self, x, y):
pass&lt;/p&gt;

&lt;p&gt;next = 42&lt;/p&gt;

&lt;p&gt;next = 42
for an_iterator in a_sequence_of_iterators:&lt;/p&gt;

&lt;p&gt;.
for an_iterator in a_sequence_of_iterators:
an_iterator.next()&lt;/p&gt;

&lt;p&gt;an_iterator.&lt;strong&gt;next&lt;/strong&gt;()&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In the simplest case, instead of calling an iterator’s next() method, you now pass the iterator itself to the global next() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you have a function that returns an iterator, call the function and pass the result to the next() function. (The 2to3 script is smart enough to convert this properly.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you define your own class and mean to use it as an iterator, define the &lt;strong&gt;next&lt;/strong&gt;() special method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you define your own class and just happen to have a method named next() that takes one or more arguments, 2to3 will not touch it. This class can not be used as an iterator, because its next() method takes arguments.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This one is a bit tricky. If you have a local variable named next, then it takes precedence over the new global next() function. In this case, you need to call the iterator’s special &lt;strong&gt;next&lt;/strong&gt;() method to get the next item in the sequence. (Alternatively, you could also refactor the code so the local variable wasn’t named next, but 2to3 will not do that for you automatically.)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.12. filter() GLOBAL FUNCTION
In Python 2, the filter() function returned a list, the result of filtering a sequence through a function that returned True or False for each item in the sequence. In Python 3, the filter() function returns an iterator, not a list.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In the most basic case, 2to3 will wrap a call to filter() with a call to list(), which simply iterates through its argument and returns a real list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;However, if the call to filter() is already wrapped in list(), 2to3 will do nothing, since the fact that filter() is returning an iterator is irrelevant.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For the special syntax of filter(None, &amp;hellip;), 2to3 will transform the call into a semantically equivalent list comprehension.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In contexts like for loops, which iterate through the entire sequence anyway, no changes are necessary.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Again, no changes are necessary, because the list comprehension will iterate through the entire sequence, and it can do that just as well if filter() returns an iterator as if it returns a list.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.13. map() GLOBAL FUNCTION
In much the same way as filter(), the map() function now returns an iterator. (In Python 2, it returned a&lt;/p&gt;

&lt;p&gt;list.)
Notes Python 2
.
map(a_function, &amp;lsquo;PapayaWhip&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;.
map(None, &amp;lsquo;PapayaWhip&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;.
map(lambda x: x+1, range(42))&lt;/p&gt;

&lt;p&gt;.
for i in map(a_function, a_sequence):&lt;/p&gt;

&lt;p&gt;.
[i for i in map(a_function,
a_sequence)]&lt;/p&gt;

&lt;p&gt;Python 3
list(map(a_function, &amp;lsquo;PapayaWhip&amp;rsquo;))
list(&amp;lsquo;PapayaWhip&amp;rsquo;)
[x+1 for x in range(42)]&lt;/p&gt;

&lt;p&gt;no change no change
1.  As with filter(), in the most basic case, 2to3 will wrap a call to map() with a call to list().&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;For the special syntax of map(None, &amp;hellip;), the identity function, 2to3 will convert it to an equivalent call to list().&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the first argument to map() is a lambda function, 2to3 will convert it to an equivalent list comprehension.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In contexts like for loops, which iterate through the entire sequence anyway, no changes are necessary.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Again, no changes are necessary, because the list comprehension will iterate through the entire sequence, and it can do that just as well if map() returns an iterator as if it returns a list.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.14. reduce() GLOBAL FUNCTION
In Python 3, the reduce() function has been removed from the global namespace and placed in the functools module.&lt;/p&gt;

&lt;p&gt;17.15. apply() GLOBAL FUNCTION
Python 2 had a global function called apply(), which took a function f and a list [a, b, c] and returned f(a, b, c). You can accomplish the same thing by calling the function directly and passing it the list of arguments preceded by an asterisk. In Python 3, the apply() function no longer exists; you must use the asterisk notation.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In the simplest form, you can call a function with a list of arguments (an actual list like [a, b, c]) by prepending the list with an asterisk (*). This is exactly equivalent to the old apply() function in Python 2.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In Python 2, the apply() function could actually take three parameters: a function, a list of arguments, and a dictionary of named arguments. In Python 3, you can accomplish the same thing by prepending the list of arguments with an asterisk (*) and the dictionary of named arguments with two asterisks (**).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The + operator, used here for list concatenation, takes precedence over the * operator, so there is no need for extra parentheses around a_list_of_args + z.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The 2to3 script is smart enough to convert complex apply() calls, including calling functions within imported modules.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.16. intern() GLOBAL FUNCTION
In Python 2, you could call the intern() function on a string to intern it as a performance optimization. In Python 3, the intern() function has been moved to the sys module.&lt;/p&gt;

&lt;p&gt;17.17. exec STATEMENT
Just as the
print statement
became a function in Python 3, so too has the exec statement. The exec() function takes a string which contains arbitrary Python code and executes it as if it were just another statement or expression. exec() is like eval(), but even more powerful and evil. The eval() function can only evaluate a single expression, but exec() can execute multiple statements, imports, function declarations — essentially an entire Python program in a string.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In the simplest form, the 2to3 script simply encloses the code-as-a-string in parentheses, since exec() is now a function instead of a statement.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The old exec statement could take a namespace, a private environment of globals in which the code-as-a­string would be executed. Python 3 can also do this; just pass the namespace as the second argument to the exec() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Even fancier, the old exec statement could also take a local namespace (like the variables defined within a function). In Python 3, the exec() function can do that too.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.18. execfile STATEMENT
Like the old exec statement, the old execfile statement will execute strings as if they were Python code. Where exec took a string, execfile took a filename. In Python 3, the execfile statement has been eliminated. If you really need to take a file of Python code and execute it (but you’re not willing to simply import it), you can accomplish the same thing by opening the file, reading its contents, calling the global compile() function to force the Python interpreter to compile the code, and then call the new exec() function.&lt;/p&gt;

&lt;p&gt;17.19. repr LITERALS (BACKTICKS)
In Python 2, there was a special syntax of wrapping any object in backticks (like &lt;code&gt;x&lt;/code&gt;) to get a representation of the object. In Python 3, this capability still exists, but you can no longer use backticks to get it. Instead, use the global repr() function.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Remember, x can be anything — a class, a function, a module, a primitive data type, &amp;amp;c. The repr() function works on everything.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In Python 2, backticks could be nested, leading to this sort of confusing (but valid) expression. The 2to3 tool is smart enough to convert this into nested calls to repr().&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.20. try&amp;hellip;except STATEMENT
The syntax for catching
exceptions
has changed slightly between Python 2 and Python 3.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Instead of a comma after the exception type, Python 3 uses a new keyword, as.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The as keyword also works for catching multiple types of exceptions at once.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you catch an exception but don’t actually care about accessing the exception object itself, the syntax is identical between Python 2 and Python 3.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Similarly, if you use a fallback to catch all exceptions, the syntax is identical.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. You should never use a fallback to catch all exceptions when importing modules (or most other times). Doing so will catch things like KeyboardInterrupt (if the user pressed Ctrl-C to interrupt the program) and can make it more difficult to debug errors.
17.21. raise STATEMENT
The syntax for raising
your
own
exceptions
has changed slightly between Python 2 and Python 3.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In the simplest form, raising an exception without a custom error message, the syntax is unchanged.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The change becomes noticeable when you want to raise an exception with a custom error message. Python 2 separated the exception class and the message with a comma; Python 3 passes the error message as a parameter.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python 2 supported a more complex syntax to raise an exception with a custom traceback (stack trace). You can do this in Python 3 as well, but the syntax is quite different.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In Python 2, you could raise an exception with no exception class, just an error message. In Python 3, this is no longer possible. 2to3 will warn you that it was unable to fix this automatically.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.22. throw METHOD ON GENERATORS
In Python 2, generators have a throw() method. Calling a_generator.throw() raises an exception at the point where the generator was paused, then returns the next value yielded by the generator function. In Python 3, this functionality is still available, but the syntax is slightly different.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In the simplest form, a generator throws an exception without a custom error message. In this case, the syntax has not changed between Python 2 and Python 3.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the generator throws an exception with a custom error message, you need to pass the error string to the exception when you create it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python 2 also supported throwing an exception with only a custom error message. Python 3 does not support this, and the 2to3 script will display a warning telling you that you will need to fix this code manually.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.23. xrange() GLOBAL FUNCTION
In Python 2, there were two ways to get a range of numbers: range(), which returned a list, and xrange(), which returned an iterator. In Python 3, range() returns an iterator, and xrange() doesn’t exist.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In the simplest case, the 2to3 script will simply convert xrange() to range().&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If your Python 2 code used range(), the 2to3 script does not know whether you needed a list, or whether an iterator would do. It errs on the side of caution and coerces the return value into a list by calling the list() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the xrange() function was inside a list comprehension, the 2to3 script is clever enough not to wrap the range() function with a call to list(). The list comprehension will work just fine with the iterator that the range() function returns.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Similarly, a for loop will work just fine with an iterator, so there is no need to change anything here.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The sum() function will also work with an iterator, so 2to3 makes no changes here either. Like dictionary
methods
that
return
views
instead
of
lists, this applies to min(), max(), sum(), list(), tuple(), set(), sorted(), any(), and all().&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.24. raw_input() AND input() GLOBAL FUNCTIONS
Python 2 had two global functions for asking the user for input on the command line. The first, called input(), expected the user to enter a Python expression (and returned the result). The second, called raw_input(), just returned whatever the user typed. This was wildly confusing for beginners and widely regarded as a “wart” in the language. Python 3 excises this wart by renaming raw_input() to input(), so it works the way everyone naively expects it to work.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In the simplest form, raw_input() becomes input().&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In Python 2, the raw_input() function could take a prompt as a parameter. This has been retained in Python 3.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you actually need to ask the user for a Python expression to evaluate, use the input() function and pass the result to eval().&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.25. func_* FUNCTION ATTRIBUTES
In Python 2, code within functions can access special attributes about the function itself. In Python 3, these special function attributes have been renamed for consistency with other attributes.&lt;/p&gt;

&lt;p&gt;Notes
Python 2
.
a_function.func_name&lt;/p&gt;

&lt;p&gt;.
a_function.func_doc&lt;/p&gt;

&lt;p&gt;.
a_function.func_defaults&lt;/p&gt;

&lt;p&gt;.
a_function.func_dict&lt;/p&gt;

&lt;p&gt;.
a_function.func_closure&lt;/p&gt;

&lt;p&gt;.
a_function.func_globals&lt;/p&gt;

&lt;p&gt;.
a_function.func_code&lt;/p&gt;

&lt;p&gt;Python 3
a_function.&lt;strong&gt;name&lt;/strong&gt;
a_function.&lt;strong&gt;doc&lt;/strong&gt;
a_function.&lt;strong&gt;defaults&lt;/strong&gt;
a_function.&lt;strong&gt;dict&lt;/strong&gt;
a_function.&lt;strong&gt;closure&lt;/strong&gt;
a_function.&lt;strong&gt;globals&lt;/strong&gt;
a_function.&lt;strong&gt;code&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;strong&gt;name&lt;/strong&gt; attribute (previously func_name) contains the function’s name.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;doc&lt;/strong&gt; attribute (previously func_doc) contains the docstring that you defined in the function’s source code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;defaults&lt;/strong&gt; attribute (previously func_defaults) is a tuple containing default argument values for those arguments that have default values.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;dict&lt;/strong&gt; attribute (previously func_dict) is the namespace supporting arbitrary function attributes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;closure&lt;/strong&gt; attribute (previously func_closure) is a tuple of cells that contain bindings for the function’s free variables.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;globals&lt;/strong&gt; attribute (previously func_globals) is a reference to the global namespace of the module in which the function was defined.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;code&lt;/strong&gt; attribute (previously func_code) is a code object representing the compiled function body.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.26. xreadlines() I/O METHOD
In Python 2, file objects had an xreadlines() method which returned an iterator that would read the file one line at a time. This was useful in for loops, among other places. In fact, it was so useful, later versions of Python 2 added the capability to file objects themselves.
In Python 3, the xreadlines() method no longer exists. 2to3 can fix the simple cases, but some edge cases will require manual intervention.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;If you used to call xreadlines() with no arguments, 2to3 will convert it to just the file object. In Python 3, this will accomplish the same thing: read the file one line at a time and execute the body of the for loop.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you used to call xreadlines() with an argument (the number of lines to read at a time), 2to3 will not fix&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;it, and your code will fail with an AttributeError: &amp;lsquo;_io.TextIOWrapper&amp;rsquo; object has no attribute
&amp;lsquo;xreadlines&amp;rsquo;. You can manually change xreadlines() to readlines() to get it to work in Python 3. (The
readlines() method now returns an iterator, so it is just as efficient as xreadlines() was in Python 2.)
?
17.27. lambda FUNCTIONS THAT TAKE A TUPLE INSTEAD OF MULTIPLE PARAMETERS
In Python 2, you could define anonymous lambda functions which took multiple parameters by defining the function as taking a tuple with a specific number of items. In effect, Python 2 would “unpack” the tuple into named arguments, which you could then reference (by name) within the lambda function. In Python 3, you can still pass a tuple to a lambda function, but the Python interpreter will not unpack the tuple into named arguments. Instead, you will need to reference each argument by its positional index.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;If you had defined a lambda function that took a tuple of one item, in Python 3 that would become a lambda with references to x1[0]. The name x1 is autogenerated by the 2to3 script, based on the named arguments in the original tuple.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A lambda function with a two-item tuple (x, y) gets converted to x_y with positional arguments x_y[0] and x_y[1].&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The 2to3 script can even handle lambda functions with nested tuples of named arguments. The resulting Python 3 code is a bit unreadable, but it works the same as the old code did in Python 2.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can define lambda functions that take multiple arguments. Without parentheses around the arguments, Python 2 just treats it as a lambda function with multiple arguments; within the lambda function, you simply reference the arguments by name, just like any other function. This syntax still works in Python 3.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.28. SPECIAL METHOD ATTRIBUTES
In Python 2, class methods can reference the class object in which they are defined, as well as the method object itself. im_self is the class instance object; im_func is the function object; im_class is the class of im_self. In Python 3, these special method attributes have been renamed to follow the naming conventions
of other attributes.
Notes Python 2
aClassInstance.aClassMethod.im_func
aClassInstance.aClassMethod.im_self
aClassInstance.aClassMethod.im_class&lt;/p&gt;

&lt;p&gt;Python 3
aClassInstance.aClassMethod.&lt;strong&gt;func&lt;/strong&gt;
aClassInstance.aClassMethod.&lt;strong&gt;self&lt;/strong&gt;
aClassInstance.aClassMethod.&lt;strong&gt;self&lt;/strong&gt;.&lt;strong&gt;class&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;17.29. &lt;strong&gt;nonzero&lt;/strong&gt; SPECIAL METHOD
In Python 2, you could build your own classes that could be used in a boolean context. For example, you could instantiate the class and then use the instance in an if statement. To do this, you defined a special &lt;strong&gt;nonzero&lt;/strong&gt;() method which returned True or False, and it was called whenever the instance was used in a boolean context. In Python 3, you can still do this, but the name of the method has changed to &lt;strong&gt;bool&lt;/strong&gt;().&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Instead of &lt;strong&gt;nonzero&lt;/strong&gt;(), Python 3 calls the &lt;strong&gt;bool&lt;/strong&gt;() method when evaluating an instance in a boolean context.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;However, if you have a &lt;strong&gt;nonzero&lt;/strong&gt;() method that takes arguments, the 2to3 tool will assume that you were using it for some other purpose, and it will not make any changes.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.30. OCTAL LITERALS
The syntax for defining base 8 (octal) numbers has changed slightly between Python 2 and Python 3.&lt;/p&gt;

&lt;p&gt;17.31. sys.maxint
Due to the integration
of
the
long and
int types, the sys.maxint constant is no longer accurate. Because the value may still be useful in determining platform-specific capabilities, it has been retained but renamed as sys.maxsize.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;maxint becomes maxsize.&lt;/li&gt;
&lt;li&gt;Any usage of sys.maxint becomes sys.maxsize.
17.32. callable() GLOBAL FUNCTION
In Python 2, you could check whether an object was callable (like a function) with the global callable() function. In Python 3, this global function has been eliminated. To check whether an object is callable, check for the existence of the &lt;strong&gt;call&lt;/strong&gt;() special method.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.33. zip() GLOBAL FUNCTION
In Python 2, the global zip() function took any number of sequences and returned a list of tuples. The first tuple contained the first item from each sequence; the second tuple contained the second item from each sequence; and so on. In Python 3, zip() returns an iterator instead of a list.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In the simplest form, you can get the old behavior of the zip() function by wrapping the return value in a call to list(), which will run through the iterator that zip() returns and return a real list of the results.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In contexts that already iterate through all the items of a sequence (such as this call to the join() method), the iterator that zip() returns will work just fine. The 2to3 script is smart enough to detect these cases and make no change to your code.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.34. StandardError EXCEPTION
In Python 2, StandardError was the base class for all built-in exceptions other than StopIteration, GeneratorExit, KeyboardInterrupt, and SystemExit. In Python 3, StandardError has been eliminated; use Exception instead.&lt;/p&gt;

&lt;p&gt;17.35. types MODULE CONSTANTS
The types module contains a variety of constants to help you determine the type of an object. In Python 2, it contained constants for all primitive types like dict and int. In Python 3, these constants have been eliminated; just use the primitive type name instead.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;types.StringType gets mapped to bytes instead of str because a Python 2 “string”
(not a Unicode string, just a regular string) is really just a sequence of bytes in a particular character encoding.
17.36. isinstance() GLOBAL FUNCTION
The isinstance() function checks whether an object is an instance of a particular class or type. In Python 2, you could pass a tuple of types, and isinstance() would return True if the object was any of those types. In Python 3, you can still do this, but passing the same type twice is deprecated.&lt;/p&gt;

&lt;p&gt;17.37. basestring DATATYPE
Python 2 had two string types: Unicode and non-Unicode. But there was also another type, basestring. It was an abstract type, a superclass for both the str and unicode types. It couldn’t be called or instantiated directly, but you could pass it to the global isinstance() function to check whether an object was either a Unicode or non-Unicode string. In Python 3, there is only one string type, so basestring has no reason to exist.&lt;/p&gt;

&lt;p&gt;17.38. itertools MODULE
Python 2.3 introduced the itertools module, which defined variants of the global zip(), map(), and filter() functions that returned iterators instead of lists. In Python 3, those global functions return iterators, so those functions in the itertools module have been eliminated. (There are still lots
of
useful
functions
in
the
itertools module, just not these.)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Instead of itertools.izip(), just use the global zip() function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instead of itertools.imap(), just use map().&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;itertools.ifilter() becomes filter().&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The itertools module still exists in Python 3, it just doesn’t have the functions that have migrated to the global namespace. The 2to3 script is smart enough to remove the specific imports that no longer exist, while leaving other imports intact.
17.39. sys.exc_type, sys.exc_value, sys.exc_traceback
Python 2 had three variables in the sys module that you could access while an exception was being handled: sys.exc_type, sys.exc_value, sys.exc_traceback. (Actually, these date all the way back to Python 1.) Ever since Python 1.5, these variables have been deprecated in favor of sys.exc_info(), which is a function that returns a tuple containing those three values. In Python 3, these individual variables have finally gone away; you must use the sys.exc_info() function.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Notes Python 2 sys.exc_type sys.exc_value sys.exc_traceback&lt;/p&gt;

&lt;p&gt;Python 3
sys.exc_info()[0]
sys.exc_info()[1]
sys.exc_info()[2]&lt;/p&gt;

&lt;p&gt;17.40. LIST COMPREHENSIONS OVER TUPLES
In Python 2, if you wanted to code a list comprehension that iterated over a tuple, you did not need to put parentheses around the tuple values. In Python 3, explicit parentheses are required.&lt;/p&gt;

&lt;p&gt;17.41. os.getcwdu() FUNCTION
Python 2 had a function named os.getcwd(), which returned the current working directory as a (non-Unicode) string. Because modern file systems can handle directory names in any character encoding, Python
2.3 introduced os.getcwdu(). The os.getcwdu() function returned the current working directory as a Unicode string. In Python 3, there is only
one
string
type
(Unicode), so os.getcwd() is all you need.&lt;/p&gt;

&lt;p&gt;17.42. METACLASSES
In Python 2, you could create metaclasses either by defining the metaclass argument in the class declaration, or by defining a special class-level &lt;strong&gt;metaclass&lt;/strong&gt; attribute. In Python 3, the class-level attribute
has been eliminated.
Notes  Python 2&lt;br /&gt;
.  class C(metaclass=PapayaMeta):&lt;br /&gt;
pass&lt;br /&gt;
.  class Whip:&lt;br /&gt;
&lt;strong&gt;metaclass&lt;/strong&gt; = PapayaMeta&lt;br /&gt;
.  class C(Whipper, Beater):&lt;br /&gt;
&lt;strong&gt;metaclass&lt;/strong&gt; = PapayaMeta&lt;/p&gt;

&lt;p&gt;Python 3
unchanged
class Whip(metaclass=PapayaMeta):&lt;/p&gt;

&lt;p&gt;pass
class C(Whipper, Beater, metaclass=PapayaMeta):&lt;/p&gt;

&lt;p&gt;pass&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Declaring the metaclass in the class declaration worked in Python 2, and it still works the same in Python 3.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Declaring the metaclass in a class attribute worked in Python 2, but doesn’t work in Python 3.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The 2to3 script is smart enough to construct a valid class declaration, even if the class is inherited from one or more base classes.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;17.43. MATTERS OF STYLE
The rest of the “fixes” listed here aren’t really fixes per se. That is, the things they change are matters of style, not substance. They work just as well in Python 3 as they do in Python 2, but the developers of Python have a vested interest in making Python code as uniform as possible. To that end, there is an official&lt;/p&gt;

&lt;p&gt;Python
style
guide
which outlines — in excruciating detail — all sorts of nitpicky details that you almost
certainly don’t care about. And given that 2to3 provides such a great infrastructure for converting Python code from one thing to another, the authors took it upon themselves to add a few optional features to improve the readability of your Python programs.&lt;/p&gt;

&lt;p&gt;17.43.1. set() LITERALS (EXPLICIT)
In Python 2, the only way to define a literal set in your code was to call set(a_sequence). This still works in Python 3, but a clearer way of doing it is to use the new set literal notation: curly braces. This works for everything except empty sets, because dictionaries also use curly braces, so {} is
an
empty
dictionary,
not
an
empty
set.
. The 2to3 script will not fix set() literals by default. To enable this fix, specify -f
set_literal on the command line when you call 2to3.&lt;/p&gt;

&lt;p&gt;17.43.2. buffer() GLOBAL FUNCTION (EXPLICIT)
Python objects implemented in C can export a “buffer interface,” which allows other Python code to directly read and write a block of memory. (That is exactly as powerful and scary as it sounds.) In Python 3, buffer() has been renamed to memoryview(). (It’s a little more complicated than that, but you can almost certainly ignore the differences.)
. The 2to3 script will not fix the buffer() function by default. To enable this fix,
specify -f buffer on the command line when you call 2to3.&lt;/p&gt;

&lt;p&gt;17.43.3. WHITESPACE AROUND COMMAS (EXPLICIT)
Despite being draconian about whitespace for indenting and outdenting, Python is actually quite liberal about whitespace in other areas. Within lists, tuples, sets, and dictionaries, whitespace can appear before and after commas with no ill effects. However, the Python style guide states that commas should be preceded by zero spaces and followed by one. Although this is purely an aesthetic issue (the code works either way, in both Python 2 and Python 3), the 2to3 script can optionally fix this for you.
. The 2to3 script will not fix whitespace around commas by default. To enable this fix, specify -f wscomma on the command line when you call 2to3.&lt;/p&gt;

&lt;p&gt;17.43.4. COMMON IDIOMS (EXPLICIT)
There were a number of common idioms built up in the Python community. Some, like the while 1: loop, date back to Python 1. (Python didn’t have a true boolean type until version 2.3, so developers used 1 and 0 instead.) Modern Python programmers should train their brains to use modern versions of these idioms instead.
. The 2to3 script will not fix common idioms by default. To enable this fix, specify -f
idioms on the command line when you call 2to3.&lt;/p&gt;

&lt;p&gt;while True:&lt;/p&gt;

&lt;p&gt;do_stuff()
isinstance(x, T)
isinstance(x, T)
a_list = sorted(a_sequence)
do_stuff(a_list)&lt;/p&gt;

&lt;p&gt;while 1:&lt;/p&gt;

&lt;p&gt;do_stuff()
type(x) == T
type(x) is T
a_list = list(a_sequence)
a_list.sort()
do_stuff(a_list)&lt;/p&gt;

&lt;p&gt;CHAPTER 18. SPECIAL METHOD NAMES&lt;/p&gt;

&lt;p&gt;.   My specialty is being right when other people are wrong. .
— George Bernard Shaw
18.1. DIVING IN
Throughout this book, you’ve seen examples of “special methods” — certain “magic” methods that Python invokes when you use certain syntax. Using special methods, your classes can act like sets, like dictionaries, like functions, like iterators, or even like numbers. This appendix serves both as a reference for the special methods we’ve seen already and a brief introduction to some of the more esoteric ones.
18.2. BASICS
If you’ve read the introduction
to
classes, you’ve already seen the most common special method: the &lt;strong&gt;init&lt;/strong&gt;() method. The majority of classes I write end up needing some initialization. There are also a few other basic special methods that are especially useful for debugging your custom classes.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;strong&gt;init&lt;/strong&gt;() method is called after the instance is created. If you want to control the actual creation process, use the
&lt;strong&gt;new&lt;/strong&gt;() method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;By convention, the &lt;strong&gt;repr&lt;/strong&gt;() method should return a string that is a valid Python expression.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;str&lt;/strong&gt;() method is also called when you print(x).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;New in Python 3, since the bytes type was introduced.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;By convention, format_spec should conform to the Format
Specification
Mini-Language. decimal.py in the Python standard library provides its own &lt;strong&gt;format&lt;/strong&gt;() method.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;18.3. CLASSES THAT ACT LIKE ITERATORS
In  the
Iterators
chapter, you saw how to build an iterator from the ground up using the &lt;strong&gt;iter&lt;/strong&gt;() and
&lt;strong&gt;next&lt;/strong&gt;() methods.
Notes You Want…
.  to iterate through a sequence&lt;br /&gt;
.  to get the next value from an&lt;br /&gt;
iterator&lt;br /&gt;
.  to create an iterator in reverse&lt;br /&gt;
order&lt;/p&gt;

&lt;p&gt;So You Write…
iter(seq)
next(seq)&lt;/p&gt;

&lt;p&gt;reversed(seq)&lt;/p&gt;

&lt;p&gt;And Python Calls…
seq.&lt;strong&gt;iter&lt;/strong&gt;()&lt;/p&gt;

&lt;p&gt;seq.&lt;strong&gt;next&lt;/strong&gt;()&lt;/p&gt;

&lt;p&gt;seq.&lt;strong&gt;reversed&lt;/strong&gt;()&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;strong&gt;iter&lt;/strong&gt;() method is called whenever you create a new iterator. It’s a good place to initialize the iterator with initial values.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;next&lt;/strong&gt;() method is called whenever you retrieve the next value from an iterator.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;reversed&lt;/strong&gt;() method is uncommon. It takes an existing sequence and returns an iterator that yields the items in the sequence in reverse order, from last to first.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As you saw in the
Iterators
chapter, a for loop can act on an iterator. In this loop:
for x in seq:
print(x)&lt;/p&gt;

&lt;p&gt;Python 3 will call seq.&lt;strong&gt;iter&lt;/strong&gt;() to create an iterator, then call the &lt;strong&gt;next&lt;/strong&gt;() method on that iterator to get each value of x. When the &lt;strong&gt;next&lt;/strong&gt;() method raises a StopIteration exception, the for loop ends gracefully.
18.4. COMPUTED ATTRIBUTES&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;If your class defines a &lt;strong&gt;getattribute&lt;/strong&gt;() method, Python will call it on every reference to any attribute or method name (except special method names, since that would cause an unpleasant infinite loop).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If your class defines a &lt;strong&gt;getattr&lt;/strong&gt;() method, Python will call it only after looking for the attribute in all the normal places. If an instance x defines an attribute color, x.color will not call x.&lt;strong&gt;getattr&lt;/strong&gt;(&amp;lsquo;color&amp;rsquo;); it will simply return the already-defined value of x.color.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;setattr&lt;/strong&gt;() method is called whenever you assign a value to an attribute.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;delattr&lt;/strong&gt;() method is called whenever you delete an attribute.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;dir&lt;/strong&gt;() method is useful if you define a &lt;strong&gt;getattr&lt;/strong&gt;() or &lt;strong&gt;getattribute&lt;/strong&gt;() method. Normally, calling dir(x) would only list the regular attributes and methods. If your &lt;strong&gt;getattr&lt;/strong&gt;() method handles a color attribute dynamically, dir(x) would not list color as one of the available attributes. Overriding the &lt;strong&gt;dir&lt;/strong&gt;() method allows you to list color as an available attribute, which is helpful for other people who wish to use your class without digging into the internals of it.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The distinction between the &lt;strong&gt;getattr&lt;/strong&gt;() and &lt;strong&gt;getattribute&lt;/strong&gt;() methods is subtle but important. I can explain it with two examples:
class Dynamo:
def &lt;strong&gt;getattr&lt;/strong&gt;(self, key):
if key == &amp;lsquo;color&amp;rsquo;: .
return &amp;lsquo;PapayaWhip&amp;rsquo;
else:
raise AttributeError .&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;dyn = Dynamo()
dyn.color .
&amp;lsquo;PapayaWhip&amp;rsquo;
dyn.color = &amp;lsquo;LemonChiffon&amp;rsquo;
dyn.color .
&amp;lsquo;LemonChiffon&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The attribute name is passed into the &lt;strong&gt;getattr&lt;/strong&gt;() method as a string. If the name is &amp;lsquo;color&amp;rsquo;, the method returns a value. (In this case, it’s just a hard-coded string, but you would normally do some sort of computation and return the result.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the attribute name is unknown, the &lt;strong&gt;getattr&lt;/strong&gt;() method needs to raise an AttributeError exception, otherwise your code will silently fail when accessing undefined attributes. (Technically, if the method doesn’t raise an exception or explicitly return a value, it returns None, the Python null value. This means that all attributes not explicitly defined will be None, which is almost certainly not what you want.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The dyn instance does not have an attribute named color, so the &lt;strong&gt;getattr&lt;/strong&gt;() method is called to provide a computed value.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After explicitly setting dyn.color, the &lt;strong&gt;getattr&lt;/strong&gt;() method will no longer be called to provide a value for dyn.color, because dyn.color is already defined on the instance.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;On the other hand, the &lt;strong&gt;getattribute&lt;/strong&gt;() method is absolute and unconditional.
class SuperDynamo:&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;getattribute&lt;/strong&gt;(self, key):
if key == &amp;lsquo;color&amp;rsquo;:
return &amp;lsquo;PapayaWhip&amp;rsquo;
else:
raise AttributeError&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;dyn = SuperDynamo()
dyn.color .
&amp;lsquo;PapayaWhip&amp;rsquo;
dyn.color = &amp;lsquo;LemonChiffon&amp;rsquo;
dyn.color .
&amp;lsquo;PapayaWhip&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;strong&gt;getattribute&lt;/strong&gt;() method is called to provide a value for dyn.color.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Even after explicitly setting dyn.color, the &lt;strong&gt;getattribute&lt;/strong&gt;() method is still called to provide a value for dyn.color. If present, the &lt;strong&gt;getattribute&lt;/strong&gt;() method is called unconditionally for every attribute and method lookup, even for attributes that you explicitly set after creating an instance.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. If your class defines a &lt;strong&gt;getattribute&lt;/strong&gt;() method, you probably also want to define a &lt;strong&gt;setattr&lt;/strong&gt;() method and coordinate between them to keep track of attribute values. Otherwise, any attributes you set after creating an instance will disappear into a black hole.
You need to be extra careful with the &lt;strong&gt;getattribute&lt;/strong&gt;() method, because it is also called when Python looks up a method name on your class.
class Rastan:&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;getattribute&lt;/strong&gt;(self, key):
raise AttributeError .
def swim(self):
pass&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;hero = Rastan()
hero.swim() .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Traceback (most recent call last):
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 1, in &lt;module&gt;
File &amp;ldquo;&lt;stdin&gt;&amp;rdquo;, line 3, in &lt;strong&gt;getattribute&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AttributeError&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This class defines a &lt;strong&gt;getattribute&lt;/strong&gt;() method which always raises an AttributeError exception. No attribute or method lookups will succeed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When you call hero.swim(), Python looks for a swim() method in the Rastan class. This lookup goes through the &lt;strong&gt;getattribute&lt;/strong&gt;() method, because all attribute and method lookups go through the &lt;strong&gt;getattribute&lt;/strong&gt;() method. In this case, the &lt;strong&gt;getattribute&lt;/strong&gt;() method raises an AttributeError exception, so the method lookup fails, so the method call fails.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;18.5. CLASSES THAT ACT LIKE FUNCTIONS
You can make an instance of a class callable — exactly like a function is callable — by defining the
&lt;strong&gt;call&lt;/strong&gt;() method.&lt;/p&gt;

&lt;p&gt;The zipfile module
uses this to define a class that can decrypt an encrypted zip file with a given password. The zip decryption algorithm requires you to store state during decryption. Defining the decryptor as a class allows you to maintain this state within a single instance of the decryptor class. The state is initialized in the &lt;strong&gt;init&lt;/strong&gt;() method and updated as the file is decrypted. But since the class is also “callable” like a function, you can pass the instance as the first argument of the map() function, like so:&lt;/p&gt;

&lt;h1 id=&#34;excerpt-from-zipfile-py:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;excerpt from zipfile.py&lt;/h1&gt;

&lt;p&gt;class _ZipDecrypter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def __init__(self, pwd): 
    self.key0 = 305419896 . 
    self.key1 = 591751049 
    self.key2 = 878082192 
    for p in pwd: 
        self._UpdateKeys(p) 

def __call__(self, c): . 
    assert isinstance(c, int) 
    k = self.key2 | 2 
    c = c ^ (((k * (k^1)) &amp;gt;&amp;gt; 8) &amp;amp; 255) 
    self._UpdateKeys(c) 
    return c 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.
zd = _ZipDecrypter(pwd) .
bytes = zef_file.read(12)
h = list(map(zd, bytes[0:12])) .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The _ZipDecryptor class maintains state in the form of three rotating keys, which are later updated in the _UpdateKeys() method (not shown here).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The class defines a &lt;strong&gt;call&lt;/strong&gt;() method, which makes class instances callable like functions. In this case, the &lt;strong&gt;call&lt;/strong&gt;() method decrypts a single byte of the zip file, then updates the rotating keys based on the byte that was decrypted.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;zd is an instance of the _ZipDecryptor class. The pwd variable is passed to the &lt;strong&gt;init&lt;/strong&gt;() method, where it is stored and used to update the rotating keys for the first time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given the first 12 bytes of a zip file, decrypt them by mapping the bytes to zd, in effect “calling” zd 12 times, which invokes the &lt;strong&gt;call&lt;/strong&gt;() method 12 times, which updates its internal state and returns a resulting byte 12 times.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;18.6. CLASSES THAT ACT LIKE SETS
If your class acts as a container for a set of values — that is, if it makes sense to ask whether your class “contains” a value — then it should probably define the following special methods that make it act like a set.&lt;/p&gt;

&lt;p&gt;The cgi module
uses these methods in its FieldStorage class, which represents all of the form fields or query parameters submitted to a dynamic web page.&lt;/p&gt;

&lt;h1 id=&#34;a-script-which-responds-to-http-example-com-search-q-cgi:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;A script which responds to &lt;a href=&#34;http://example.com/search?q=cgi&#34;&gt;http://example.com/search?q=cgi&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;import cgi
fs = cgi.FieldStorage()
if &amp;lsquo;q&amp;rsquo; in fs: .&lt;/p&gt;

&lt;p&gt;do_search()&lt;/p&gt;

&lt;h1 id=&#34;an-excerpt-from-cgi-py-that-explains-how-that-works:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;An excerpt from cgi.py that explains how that works&lt;/h1&gt;

&lt;p&gt;class FieldStorage:
.
.
.&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;contains&lt;/strong&gt;(self, key): .
if self.list is None:
raise TypeError(&amp;lsquo;not indexable&amp;rsquo;)
return any(item.name == key for item in self.list) .&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;len&lt;/strong&gt;(self): .
return len(self.keys()) .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Once you create an instance of the cgi.FieldStorage class, you can use the “in” operator to check whether a particular parameter was included in the query string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;contains&lt;/strong&gt;() method is the magic that makes this work.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When you say if &amp;lsquo;q&amp;rsquo; in fs, Python looks for the &lt;strong&gt;contains&lt;/strong&gt;() method on the fs object, which is defined in cgi.py. The value &amp;lsquo;q&amp;rsquo; is passed into the &lt;strong&gt;contains&lt;/strong&gt;() method as the key argument.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The same FieldStorage class also supports returning its length, so you can say len(fs) and it will call the &lt;strong&gt;len&lt;/strong&gt;() method on the FieldStorage class to return the number of query parameters that it identified.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The self.keys() method checks whether self.list is None, so the &lt;strong&gt;len&lt;/strong&gt; method doesn’t need to duplicate this error checking.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;18.7. CLASSES THAT ACT LIKE DICTIONARIES
Extending the previous section a bit, you can define classes that not only respond to the “in” operator and the len() function, but they act like full-blown dictionaries, returning values based on keys.&lt;/p&gt;

&lt;p&gt;The FieldStorage class
from the cgi module
also defines these special methods, which means you can do things like this:&lt;/p&gt;

&lt;h1 id=&#34;a-script-which-responds-to-http-example-com-search-q-cgi-1:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;A script which responds to &lt;a href=&#34;http://example.com/search?q=cgi&#34;&gt;http://example.com/search?q=cgi&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;import cgi
fs = cgi.FieldStorage()
if &amp;lsquo;q&amp;rsquo; in fs:&lt;/p&gt;

&lt;p&gt;do_search(fs[&amp;lsquo;q&amp;rsquo;]) .&lt;/p&gt;

&lt;h1 id=&#34;an-excerpt-from-cgi-py-that-shows-how-it-works:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;An excerpt from cgi.py that shows how it works&lt;/h1&gt;

&lt;p&gt;class FieldStorage:
.
.
.&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;getitem&lt;/strong&gt;(self, key): .
if self.list is None:&lt;/p&gt;

&lt;p&gt;raise TypeError(&amp;lsquo;not indexable&amp;rsquo;)
found = []
for item in self.list:&lt;/p&gt;

&lt;p&gt;if item.name == key: found.append(item)
if not found:
raise KeyError(key)
if len(found) == 1:
return found[0]
else:
return found&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The fs object is an instance of cgi.FieldStorage, but you can still evaluate expressions like fs[&amp;lsquo;q&amp;rsquo;].&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fs[&amp;lsquo;q&amp;rsquo;] invokes the &lt;strong&gt;getitem&lt;/strong&gt;() method with the key parameter set to &amp;lsquo;q&amp;rsquo;. It then looks up in its internally maintained list of query parameters (self.list) for an item whose .name matches the given key.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;18.8. CLASSES THAT ACT LIKE NUMBERS
Using the appropriate special methods, you can define your own classes that act like numbers. That is, you can add them, subtract them, and perform other mathematical operations on them. This is how fractions are implemented — the Fraction class implements these special methods, then you can do things like this:
&amp;gt;&amp;gt;&amp;gt; from fractions import Fraction
&amp;gt;&amp;gt;&amp;gt; x = Fraction(1, 3)
&amp;gt;&amp;gt;&amp;gt; x / 3
Fraction(1, 9)&lt;/p&gt;

&lt;p&gt;Here is the comprehensive list of special methods you need to implement a number-like class.
Notes You Want…
addition subtraction multiplication division floor division modulo (remainder) floor division &amp;amp;modulo raise to power left bit-shift right bit-shift bitwise and bitwise xor bitwise or&lt;/p&gt;

&lt;p&gt;So You Write… And Python Calls…&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x+y 
x.__add__(y) 



x-y 
x.__sub__(y) 



x*y 
x.__mul__(y) 



x/y 
x.__truediv__(y) 



x // y 
x.__floordiv__(y) 



x%y 
x.__mod__(y) 



divmod(x, y) 
x.__divmod__(y) 



x ** y 
x.__pow__(y) 



x &amp;lt;&amp;lt; y 
x.__lshift__(y) 



x &amp;gt;&amp;gt; y 
x.__rshift__(y) 



x&amp;amp;y 
x.__and__(y) 



x^y 
x.__xor__(y) 



x|y 
x.__or__(y) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s all well and good if x is an instance of a class that implements those methods. But what if it doesn’t implement one of them? Or worse, what if it implements it, but it can’t handle certain kinds of arguments? For example:
&amp;gt;&amp;gt;&amp;gt; from fractions import Fraction
&amp;gt;&amp;gt;&amp;gt; x = Fraction(1, 3)
&amp;gt;&amp;gt;&amp;gt; 1 / x
Fraction(3, 1)&lt;/p&gt;

&lt;p&gt;This is not a case of taking a Fraction and dividing it by an integer (as in the previous example). That case was straightforward: x/3 calls x.&lt;strong&gt;truediv&lt;/strong&gt;(3), and the &lt;strong&gt;truediv&lt;/strong&gt;() method of the Fraction class handles all the math. But integers don’t “know” how to do arithmetic operations with fractions. So why does this example work?
There is a second set of arithmetic special methods with reflected operands. Given an arithmetic operation that takes two operands (e.g. x/y), there are two ways to go about it:
1. Tell x to divide itself by y, or&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tell y to divide itself into x&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The set of special methods above take the first approach: given x/y, they provide a way for x to say “I know how to divide myself by y.” The following set of special methods tackle the second approach: they provide a way for y to say “I know how to be the denominator and divide myself into x.”&lt;/p&gt;

&lt;p&gt;But wait! There’s more! If you’re doing “in-place” operations, like x /= 3, there are even more special methods you can define.&lt;/p&gt;

&lt;p&gt;Note: for the most part, the in-place operation methods are not required. If you don’t define an in-place method for a particular operation, Python will try the methods. For example, to execute the expression x /= y, Python will:
1.  Try calling x.&lt;strong&gt;itruediv&lt;/strong&gt;(y). If this method is defined and returns a value other than NotImplemented, we’re done.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Try calling x.&lt;strong&gt;truediv&lt;/strong&gt;(y). If this method is defined and returns a value other than NotImplemented, the old value of x is discarded and replaced with the return value, just as if you had done x=x/y instead.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Try calling y.&lt;strong&gt;rtruediv&lt;/strong&gt;(x). If this method is defined and returns a value other than NotImplemented, the old value of x is discarded and replaced with the return value.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So you only need to define in-place methods like the &lt;strong&gt;itruediv&lt;/strong&gt;() method if you want to do some special optimization for in-place operands. Otherwise Python will essentially reformulate the in-place operand to use a regular operand + a variable assignment.
There are also a few “unary” mathematical operations you can perform on number-like objects by themselves.&lt;/p&gt;

&lt;p&gt;18.9. CLASSES THAT CAN BE COMPARED
I broke this section out from the previous one because comparisons are not strictly the purview of numbers. Many datatypes can be compared — strings, lists, even dictionaries. If you’re creating your own class and it makes sense to compare your objects to other objects, you can use the following special methods to implement comparisons.&lt;/p&gt;

&lt;p&gt;. If you define a &lt;strong&gt;lt&lt;/strong&gt;() method but no &lt;strong&gt;gt&lt;/strong&gt;() method, Python will use the &lt;strong&gt;lt&lt;/strong&gt;() method with operands swapped. However, Python will not combine methods. For example, if you define a &lt;strong&gt;lt&lt;/strong&gt;() method and a &lt;strong&gt;eq&lt;/strong&gt;() method and try to test whether x &amp;lt;= y, Python will not call &lt;strong&gt;lt&lt;/strong&gt;() and &lt;strong&gt;eq&lt;/strong&gt;() in sequence. It will only call the &lt;strong&gt;le&lt;/strong&gt;() method.
18.10. CLASSES THAT CAN BE SERIALIZED
Python supports serializing
and
unserializing
arbitrary
objects. (Most Python references call this process “pickling” and “unpickling.”) This can be useful for saving state to a file and restoring it later. All of the native
datatypes
support pickling already. If you create a custom class that you want to be able to pickle, read up on the
pickle
protocol
to see when and how the following special methods are called.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To recreate a serialized object, Python needs to create a new object that looks like the serialized object, then set the values of all the attributes on the new object. The &lt;strong&gt;getnewargs&lt;/strong&gt;() method controls how the object is created, then the &lt;strong&gt;setstate&lt;/strong&gt;() method controls how the attribute values are restored.
18.11. CLASSES THAT CAN BE USED IN A with BLOCK
A with block defines a runtime
context; you “enter” the context when you execute the with statement, and you “exit” the context after you execute the last statement in the block.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is how the with file idiom
works.&lt;/p&gt;

&lt;h1 id=&#34;excerpt-from-io-py:45a87c9728df9c83ddeca3aacf10a54d&#34;&gt;excerpt from io.py:&lt;/h1&gt;

&lt;p&gt;def _checkClosed(self, msg=None):
&amp;ldquo;&amp;lsquo;Internal: raise an ValueError if file is closed
&amp;ldquo;&amp;rsquo;
if self.closed:&lt;/p&gt;

&lt;p&gt;raise ValueError(&amp;lsquo;I/O operation on closed file.&amp;rsquo;
if msg is None else msg)&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;enter&lt;/strong&gt;(self):&lt;br /&gt;
&amp;rdquo;&amp;lsquo;Context management protocol.  Returns self.&amp;ldquo;&amp;rsquo;&lt;br /&gt;
self._checkClosed()  .&lt;br /&gt;
return self  .&lt;br /&gt;
def &lt;strong&gt;exit&lt;/strong&gt;(self, *args):&lt;br /&gt;
&amp;rdquo;&amp;lsquo;Context management protocol.  Calls close()&amp;ldquo;&amp;rsquo;&lt;br /&gt;
self.close()  .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The file object defines both an &lt;strong&gt;enter&lt;/strong&gt;() and an &lt;strong&gt;exit&lt;/strong&gt;() method. The &lt;strong&gt;enter&lt;/strong&gt;() method checks that the file is open; if it’s not, the _checkClosed() method raises an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;strong&gt;enter&lt;/strong&gt;() method should almost always return self — this is the object that the with block will use to dispatch properties and methods.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After the with block, the file object automatically closes. How? In the &lt;strong&gt;exit&lt;/strong&gt;() method, it calls self.close().&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;. The &lt;strong&gt;exit&lt;/strong&gt;() method will always be called, even if an exception is raised inside the with block. In fact, if an exception is raised, the exception information will be passed to the &lt;strong&gt;exit&lt;/strong&gt;() method. See With
Statement
Context
Managers
for more details.
For more on context managers, see Closing
Files
Automatically
and Redirecting
Standard
Output.
18.12. REALLY ESOTERIC STUFF&lt;/p&gt;

&lt;p&gt;If you know what you’re doing, you can gain almost complete control over how classes are compared, how attributes are defined, and what kinds of classes are considered subclasses of your class.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exactly when Python calls the &lt;strong&gt;del&lt;/strong&gt;() special method is
incredibly
complicated. To fully understand it, you need to know how Python
keeps
track
of
objects
in
memory. Here’s a good article on Python
garbage
collection
and
class
destructors. You should also read about weak
references, the weakref module, and probably the gc module
for good measure.
18.13. FURTHER READING
Modules mentioned in this appendix:
• zipfile module&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;• cgi module&lt;/p&gt;

&lt;p&gt;• collections module&lt;/p&gt;

&lt;p&gt;• math module&lt;/p&gt;

&lt;p&gt;• pickle module&lt;/p&gt;

&lt;p&gt;• copy module&lt;/p&gt;

&lt;p&gt;• abc (“Abstract
Base
Classes”)
module&lt;/p&gt;

&lt;p&gt;Other light reading:&lt;/p&gt;

&lt;p&gt;• Format
Specification
Mini-Language&lt;/p&gt;

&lt;p&gt;• Python
data
model&lt;/p&gt;

&lt;p&gt;• Built-in
types&lt;/p&gt;

&lt;p&gt;• PEP
357:
Allowing
Any
Object
to
be
Used
for
Slicing&lt;/p&gt;

&lt;p&gt;• PEP
3119:
Introducing
Abstract
Base
Classes&lt;/p&gt;

&lt;p&gt;CHAPTER 19. WHERE TO GO FROM HERE&lt;/p&gt;

&lt;p&gt;. Go forth on your path, as it exists only through your walking. .
— St. Augustine of Hippo (attributed)
19.1. THINGS TO READ
Unfortunately, I can not write cover every facet of Python 3 in this book. Fortunately, there are many wonderful, freely available tutorials available elsewhere.
Decorators:
• Function
Decorators
by Ariel Ortiz&lt;/p&gt;

&lt;p&gt;• More
on
Function
Decorators
by Ariel Ortiz&lt;/p&gt;

&lt;p&gt;• Charming
Python:
Decorators
make
magic
easy
by David Mertz&lt;/p&gt;

&lt;p&gt;• Function
Definitions
in the official Python documentation&lt;/p&gt;

&lt;p&gt;Properties:&lt;/p&gt;

&lt;p&gt;• The
Python
property builtin
by Adam Gomaa&lt;/p&gt;

&lt;p&gt;• Getters/Setters/Fuxors
by Ryan Tomayko&lt;/p&gt;

&lt;p&gt;• property() function
in the official Python documentation&lt;/p&gt;

&lt;p&gt;• How-To
Guide
For
Descriptors
by Raymond Hettinger&lt;/p&gt;

&lt;p&gt;• Charming
Python:
Python
elegance
and
warts,
Part
2
by David Mertz&lt;/p&gt;

&lt;p&gt;• Python
Descriptors
by Mark Summerfield&lt;/p&gt;

&lt;p&gt;• Invoking
Descriptors
in the official Python documentation&lt;/p&gt;

&lt;p&gt;Descriptors: Threading &amp;amp;multiprocessing:
• threading module&lt;/p&gt;

&lt;p&gt;• threading —
Manage
concurrent
threads&lt;/p&gt;

&lt;p&gt;• multiprocessing module&lt;/p&gt;

&lt;p&gt;• multiprocessing —
Manage
processes
like
threads&lt;/p&gt;

&lt;p&gt;• Python
threads
and
the
Global
Interpreter
Lock
by Jesse Noller&lt;/p&gt;

&lt;p&gt;• Inside
the
Python
GIL
(video)
by David Beazley&lt;/p&gt;

&lt;p&gt;Metaclasses:
• Metaclass
programming
in
Python
by David Mertz and Michele Simionato&lt;/p&gt;

&lt;p&gt;• Metaclass
programming
in
Python,
Part
2
by David Mertz and Michele Simionato&lt;/p&gt;

&lt;p&gt;• Metaclass
programming
in
Python,
Part
3
by David Mertz and Michele Simionato&lt;/p&gt;

&lt;p&gt;In addition, Doug Hellman’s Python
Module
of
the
Week
is a fantastic guide to many of the modules in the Python standard library.
19.2. WHERE TO LOOK FOR PYTHON 3-COMPATIBLE CODE
As Python 3 is relatively new, there is a dearth of compatible libraries. Here are some of the places to look for code that works with Python 3.
• Python
Package
Index:
list
of
Python
3
packages&lt;/p&gt;

&lt;p&gt;• Python
Cookbook: list of recipes tagged “python3”&lt;/p&gt;

&lt;p&gt;• Google
Project Hosting: list of projects tagged “python3”&lt;/p&gt;

&lt;p&gt;• SourceForge:
list of projects matching “Python 3”&lt;/p&gt;

&lt;p&gt;• GitHub:
list of projects matching “python3” (also, list of projects matching “python 3”)&lt;/p&gt;

&lt;p&gt;• BitBucket:
list of projects matching “python3” (and those matching “python 3”)&lt;/p&gt;

&lt;p&gt;CHAPTER 20. TROUBLESHOOTING&lt;/p&gt;

&lt;p&gt;. Where’s the ANY key? .
— variously attributed&lt;/p&gt;

&lt;p&gt;20.1. DIVING IN FIXME
20.2. GETTING TO THE COMMAND LINE
Throughout this book, there are examples of executing Python programs from the command line. Where is the command line?
On Linux, look in your Applications menu for a program called Terminal. (It may be in a submenu like Accessories or System.)
On Mac OS X, there is an application called Terminal in your /Applications/Utilities/ folder. To get there, click on your desktop, open the Go menu, select Go to folder&amp;hellip;, and type /Applications/ Utilities/. Then double-click the Terminal program.
On Windows, click Start, select Run&amp;hellip;, type cmd, and press ENTER.
20.3. RUNNING PYTHON ON THE COMMAND LINE
Once you get
to
the
command
line, you should be able to run the Python interactive shell. On the Linux or Mac OS X command line, type python3 and press ENTER. On the Windows command line, type c:\python31\python and press ENTER. If all goes well, you should see something like this:
you@localhost:~$ python3&lt;/p&gt;

&lt;p&gt;Python 3.1 (r31:73572, Jul 28 2009, 06:52:23)
[GCC 4.2.4 (Ubuntu 4.2.4-1ubuntu4)] on linux2
Type &amp;ldquo;help&amp;rdquo;, &amp;ldquo;copyright&amp;rdquo;, &amp;ldquo;credits&amp;rdquo; or &amp;ldquo;license&amp;rdquo; for more information.
&amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;(Type exit() and press ENTER to exit the Python interactive shell and go back to the command line. This works on all platforms.)
If you get a “command not found” error, it probably means you don’t
have
Python
3
installed.
you@localhost:~$ python3
bash: python3: command not found&lt;/p&gt;

&lt;p&gt;On the other hand, if you get into a Python interactive shell but the version number is not what you expected, you may have more than one version of Python installed. This happens most often on Linux and Mac OS X systems, where an older version of Python is pre-installed. You can install the latest version without deleting the older version (they will live side-by-side in peace), but you will need to be more specific when you run Python from the command line.
For example, on my home Linux box, I have several versions of Python installed so I can test the Python software that I write. To run a specific version, I can type python3.0, python3.1, or python2.6.
mark@atlantis:~$ python3.0
Python 3.0.1+ (r301:69556, Apr 15 2009, 17:25:52)
[GCC 4.3.3] on linux2
Type &amp;ldquo;help&amp;rdquo;, &amp;ldquo;copyright&amp;rdquo;, &amp;ldquo;credits&amp;rdquo; or &amp;ldquo;license&amp;rdquo; for more information.
&amp;gt;&amp;gt;&amp;gt; exit()
mark@atlantis:~$ python3.1
Python 3.1 (r31:73572, Jul 28 2009, 06:52:23)
[GCC 4.2.4 (Ubuntu 4.2.4-1ubuntu4)] on linux2
Type &amp;ldquo;help&amp;rdquo;, &amp;ldquo;copyright&amp;rdquo;, &amp;ldquo;credits&amp;rdquo; or &amp;ldquo;license&amp;rdquo; for more information.
&amp;gt;&amp;gt;&amp;gt; exit()
mark@atlantis:~$ python2.6
Python 2.6.5 (r265:79063, Apr 16 2010, 13:57:41)
[GCC 4.4.3] on linux2
Type &amp;ldquo;help&amp;rdquo;, &amp;ldquo;copyright&amp;rdquo;, &amp;ldquo;credits&amp;rdquo; or &amp;ldquo;license&amp;rdquo; for more information.
&amp;gt;&amp;gt;&amp;gt; exit()&lt;/p&gt;

&lt;p&gt;© 2001–9 Mark
Pilgrim&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go programm language</title>
      <link>https://harryho.github.io/cache/golang/go-program-lang/</link>
      <pubDate>Sun, 10 Apr 2016 14:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/cache/golang/go-program-lang/</guid>
      <description>

&lt;p&gt;We assume that you have programmed in one or more other languages, whether compiled like C, C++, and Java, or interpreted like Python, Ruby, and JavaScript, so we won’t spell out everything as if for a total beginner. Surface syntax will be familiar, as will variables and constants, expressions, control flow, and functions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Chapter 1 is a tutorial on the basic constructs of Go, introduced through a dozen programs for everyday tasks like reading and writing files, formatting text, creating images, and communicating with Internet clients and servers.&lt;/p&gt;

&lt;p&gt;Chapter 2 describes the structural elements of a Go program—declarations, variables, new types, packages and files, and scope.&lt;/p&gt;

&lt;p&gt;Chapter 3 discusses numbers, booleans, strings, and constants, and explains how to process Unicode.&lt;/p&gt;

&lt;p&gt;Chapter 4 describes composite types, that is, types built up from simpler ones using arrays, maps, structs, and slices, Go’s approach to dynamic lists.&lt;/p&gt;

&lt;p&gt;Chapter 5 covers functions and discusses error handling, panic and recover, and the defer statement.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Chapters 1 through 5 are thus the basics, things that are part of any mainstream imperative language. Go’s syntax and style sometimes differ from other languages, but most programmers will pick them up quickly. The remaining chapters focus on topics where Go’s approach is less conventional: methods, interfaces, concurrency, packages, testing, and reflection.&lt;/p&gt;

&lt;p&gt;Go has an unusual approach to object-oriented programming. There are no class hierarchies, or indeed any classes; complex object behaviors are created from simpler ones by composition, not inheritance. Methods may be associated with any user-defined type, not just structures, and the relationship between concrete types and abstract types (interfaces) is implicit, so a concrete type may satisfy an interface that the type’s designer was unaware of.&lt;/p&gt;

&lt;p&gt;Methods are covered in Chapter 6 and interfaces in Chapter 7.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Chapter 8 presents Go’s approach to concurrency, which is based on the idea of communicating sequential processes (CSP), embodied by goroutines and channels. Chapter 9 explains the more traditional aspects of concurrency based on shared variables.&lt;/p&gt;

&lt;p&gt;Chapter 10 describes packages, the mechanism for organizing libraries. This chapter also shows how to make effective use of the go tool, which provides for compilation, testing, benchmarking, program formatting, documentation, and many other tasks, all within a single command.&lt;/p&gt;

&lt;p&gt;Chapter 11 deals with testing, where Go takes a notably lightweight approach, avoiding abstraction-laden frameworks in favor of simple libraries and tools. The testing libraries provide a foundation atop which more complex abstractions can be built if necessary.&lt;/p&gt;

&lt;p&gt;Chapter 12 discusses reflection, the ability of a program to examine its own representation during execution. Reflection is a powerful tool, though one to be used carefully; this chapter explains finding the right balance by showing how it is used to implement some important Go libraries.&lt;/p&gt;

&lt;p&gt;Chapter 13 explains the gory details of low-level programming that uses the unsafe package to step around Go’s type system, and when that is appropriate.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Each chapter has a number of exercises that you can use to test your understanding of Go, and to explore extensions and alternatives to the examples from the book.
All but the most trivial code examples in the book are available for download from the public Git repository at gopl.io. Each example is identified by its package import path and may be conveniently fetched, built, and installed using the go getcommand. You’ll need to choose a directory to be your Go workspace and set the GOPATH environment variable to point to it. The go tool will create the directory if
necessary.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export GOPATH=$HOME/gobook workspace directory $ go get // gopl.io/ch1/helloworld build, install $ $GOPATH/bin/helloworld Hello,  # # #  choose fetch, run  

To run the examples, you will need at least version 1.5 of Go.  
$ go version go version go1.5 linux/amd64  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Follow the instructions at &lt;a href=&#34;https://golang.org/doc/install&#34;&gt;https://golang.org/doc/install&lt;/a&gt; if the go tool on your computer is older or missing.&lt;/p&gt;

&lt;p&gt;Where to Find More Information&lt;/p&gt;

&lt;p&gt;The best source for more information about Go is the official web site, &lt;a href=&#34;https://golang.org&#34;&gt;https://golang.org&lt;/a&gt;, which provides access to the documentation, including the Go Programming Language Specification, standard packages, and the like. There are also tutorials on how to write Go and how to write it well, and a wide variety of online text and video resources that will be valuable complements to this book. The Go Blog at blog.golang.org publishes some of the best writing on Go, with articles on the state of the language, plans for the future, reports on conferences, and in-depth explanations of a wide variety of Go-related topics.&lt;/p&gt;

&lt;p&gt;One of the most useful aspects of online access to Go (and a regrettable limitation of a paper book) is the ability to run Go programs from the web pages that describe them. This functionality is provided by the Go Playground at play.golang.org, and may be embedded within other pages, such as the home page at golang.org or the documentation pages served by the godoc tool.&lt;/p&gt;

&lt;p&gt;The Playground makes it convenient to perform simple experiments to check one’s understanding of syntax, semantics, or library packages with short programs, and in many ways takes the place of a read-eval-print loop (REPL) in other languages. Its persistent URLs are great for sharing snippets of Go code with others, for reporting bugs or making suggestions.&lt;/p&gt;

&lt;p&gt;Built atop the Playground, the Go Tour at tour.golang.org is a sequence of short interactive lessons on the basic ideas and constructions of Go, an orderly walk through the language.&lt;/p&gt;

&lt;p&gt;The primary shortcoming of the Playground and the Tour is that they allow only standard libraries to be imported, and many library features—networking, for example —are restricted for practical or security reasons. They also require access to the Internet to compile and run each program. So for more elaborate experiments, you will have to run Go programs on your own computer. Fortunately the download process is straightforward, so it should not take more than a few minutes to fetch the Go distribution from golang.org and start writing and running Go programs of your own.&lt;/p&gt;

&lt;p&gt;Since Go is an open-source project, you can read the code for any type or function in the standard library online at &lt;a href=&#34;https://golang.org/pkg&#34;&gt;https://golang.org/pkg&lt;/a&gt;; the same code is part of the downloaded distribution. Use this to figure out how something works, or to
answer questions about details, or merely to see how experts write really good Go.&lt;/p&gt;

&lt;p&gt;Acknowledgments&lt;/p&gt;

&lt;p&gt;Rob Pike and Russ Cox, core members of the Go team, read the manuscript several times with great care; their comments on everything from word choice to overall structure and organization have been invaluable. While preparing the Japanese translation, Yoshiki Shibata went far beyond the call of duty; his meticulous eye spotted numerous inconsistencies in the English text and errors in the code. We greatly appreciate thorough reviews and critical comments on the entire manuscript from Brian Goetz, Corey Kosak, Arnold Robbins, Josh Bleecher Snyder, and Peter Weinberger.&lt;/p&gt;

&lt;p&gt;We are indebted to Sameer Ajmani, Ittai Balaban, David Crawshaw, Billy Donohue, Jonathan Feinberg, Andrew Gerrand, Robert Griesemer, John Linderman, Minux Ma, Bryan Mills, Bala Natarajan, Cosmos Nicolaou, Paul Staniforth, Nigel Tao, and Howard Trickey for many helpful suggestions. We also thank David Brailsford and Raph Levien for typesetting advice, and Chris Loper for explaining many mysteries of e-book production.&lt;/p&gt;

&lt;p&gt;Our editor Greg Doench at Addison-Wesley got the ball rolling originally and has been continuously helpful ever since. The AW production team—John Fuller, Dayna Isley, Julie Nahil, Chuti Prasertsith, and Barbara Wood—has been outstanding; authors could not hope for better support.&lt;/p&gt;

&lt;p&gt;Alan Donovan wishes to thank: Sameer Ajmani, Chris Demetriou, Walt Drummond, and Reid Tatge at Google for allowing him time to write; Stephen Donovan, for his advice and timely encouragement; and above all, his wife Leila Kazemi, for her unhesitating enthusiasm and unwavering support for this project, despite the long hours of distraction and absenteeism from family life that it entailed.&lt;/p&gt;

&lt;p&gt;Brian Kernighan is deeply grateful to friends and colleagues for their patience and forbearance as he moved slowly along the path to understanding, and especially to his wife Meg, who has been unfailingly supportive of book-writing and so much else.&lt;/p&gt;

&lt;p&gt;New York October 2015&lt;/p&gt;

&lt;h1 id=&#34;tutorial:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Tutorial&lt;/h1&gt;

&lt;p&gt;This chapter is a tour of the basic components of Go. We hope to provide enough information and examples to get you off the ground and doing useful things as quickly as possible. The examples here, and indeed in the whole book, are aimed at tasks that you might have to do in the real world. In this chapter we’ll try to give you a taste of the diversity of programs that one might write in Go, ranging from simple file processing and a bit of graphics to concurrent Internet clients and servers. We certainly won’t explain everything in the first chapter, but studying such programs in a new language can be an effective way to get started.&lt;/p&gt;

&lt;p&gt;When you’re learning a new language, there’s a natural tendency to write code as you would have written it in a language you already know. Be aware of this bias as you learn Go and try to avoid it. We’ve tried to illustrate and explain how to write good Go, so use the code here as a guide when you’re writing your own.&lt;/p&gt;

&lt;h2 id=&#34;hello-world:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Hello, World&lt;/h2&gt;

&lt;p&gt;We’ll start with the now-traditional “hello, world” example, which appears at the beginning of The C Programming Language, published in 1978. C is one of the most direct influences on Go, and “hello, world” illustrates a number of central ideas.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/helloworld

package main
import &amp;quot;fmt&amp;quot; 
func main() {
    fmt.Println(&amp;quot;Hello, &amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go is a compiled language. The Go toolchain converts a source program and the things it depends on into instructions in the native machine language of a computer. These tools are accessed through a single command called go that has a number of subcommands. The simplest of these subcommands is run, which compiles the source code from one or more source files whose names end in .go, links it with libraries, then runs the resulting executable file. (We will use $ as the command prompt throughout the book.)&lt;/p&gt;

&lt;p&gt;$ go run helloworld.go&lt;/p&gt;

&lt;p&gt;Not surprisingly, this prints
Hello,&lt;/p&gt;

&lt;p&gt;Go natively handles Unicode, so it can process text in all the world’s languages.&lt;/p&gt;

&lt;p&gt;If the program is more than a one-shot experiment, it’s likely that you would want to
compile it once and save the compiled result for later use. That is done with go
build:&lt;/p&gt;

&lt;p&gt;$ go build helloworld.go This creates an executable binary file called helloworld that can be run any time without further processing:
$ ./helloworld&lt;/p&gt;

&lt;p&gt;Hello,&lt;/p&gt;

&lt;p&gt;We have labeled each significant example as a reminder that you can obtain the code from the book’s source code repository at gopl.io:&lt;/p&gt;

&lt;p&gt;// gopl.io/ch1/helloworld&lt;/p&gt;

&lt;p&gt;If you run go get // gopl.io/ch1/helloworld , it will fetch the source code and place it in the corresponding directory. There’s more about this topic in Section 2.6 and Section 10.7.&lt;/p&gt;

&lt;p&gt;Let’s now talk about the program itself. Go code is organized into packages, which are similar to libraries or modules in other languages. A package consists of one or more .go source files in a single directory that define what the package does. Each source file begins with a package declaration, here package main , that states which package the file belongs to, followed by a list of other packages that it imports, and then the declarations of the program that are stored in that file.&lt;/p&gt;

&lt;p&gt;The Go standard library has over 100 packages for common tasks like input and output, sorting, and text manipulation. For instance, the fmt package contains functions for printing formatted output and scanning input. Println is one of the basic output functions in fmt; it prints one or more values, separated by spaces, with a newline character at the end so that the values appear as a single line of output.&lt;/p&gt;

&lt;p&gt;Package main is special. It defines a standalone executable program, not a library. Within package main the function main is also special—it’s where execution of the program begins. Whatever main does is what the program does. Of course, main will normally call upon functions in other packages to do much of the work, such as the function fmt.Println.&lt;/p&gt;

&lt;p&gt;We must tell the compiler what packages are needed by this source file; that’s the role of the import declaration that follows the package declaration. The “hello, world” program uses only one function from one other package, but most programs will import more packages.&lt;/p&gt;

&lt;p&gt;You must import exactly the packages you need. A program will not compile if there are missing imports or if there are unnecessary ones. This strict requirement prevents references to unused packages from accumulating as programs evolve.&lt;/p&gt;

&lt;p&gt;The import declarations must follow the package declaration. After that, a program consists of the declarations of functions, variables, constants, and types (introduced by the keywords func, var, const, and type); for the most part, the order of declarations does not matter. This program is about as short as possible since it declares only one function, which in turn calls only one other function. To save space, we will sometimes not show the package and import declarations when presenting examples, but they are in the source file and must be there to compile the code.&lt;/p&gt;

&lt;p&gt;A function declaration consists of the keyword func, the name of the function, a parameter list (empty for main), a result list (also empty here), and the body of the function—the statements that define what it does—enclosed in braces. We’ll take a closer look at functions in Chapter 5.&lt;/p&gt;

&lt;p&gt;Go does not require semicolons at the ends of statements or declarations, except where two or more appear on the same line. In effect, newlines following certain tokens are converted into semicolons, so where newlines are placed matters to proper parsing of Go code. For instance, the opening brace { of the function must be on the same line as the end of the func declaration, not on a line by itself, and in the expression x+y , a newline is permitted after but not before the + operator.&lt;/p&gt;

&lt;p&gt;Go takes a strong stance on code formatting. The gofmt tool rewrites code into the standard format, and the go tool’s fmt subcommand applies gofmt to all the files in the specified package, or the ones in the current directory by default. All Go source files in the book have been run through gofmt, and you should get into the habit of doing the same for your own code. Declaring a standard format by fiat eliminates a lot of pointless debate about trivia and, more importantly, enables a variety of automated source code transformations that would be infeasible if arbitrary formatting were allowed.&lt;/p&gt;

&lt;p&gt;Many text editors can be configured to run gofmt each time you save a file, so that your source code is always properly formatted. A related tool, goimports, additionally manages the insertion and removal of import declarations as needed. It is not part of the standard distribution but you can obtain it with this command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go get golang.org/x/tools/cmd/goimports 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For most users, the usual way to download and build packages, run their tests, show their documentation, and so on, is with the go tool, which we’ll look at in Section 10.7.&lt;/p&gt;

&lt;h2 id=&#34;command-line-arguments:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Command-Line Arguments&lt;/h2&gt;

&lt;p&gt;Most programs process some input to produce some output; that’s pretty much the definition of computing. But how does a program get input data on which to operate? Some programs generate their own data, but more often, input comes from an external source: a file, a network connection, the output of another program, a user at a keyboard, command-line arguments, or the like. The next few examples will discuss some of these alternatives, starting with command-line arguments.&lt;/p&gt;

&lt;p&gt;The os package provides functions and other values for dealing with the operating system in a platform-independent fashion. Command-line arguments are available to a program in a variable named Args that is part of the os package; thus its name anywhere outside the os package is os.Args.&lt;/p&gt;

&lt;p&gt;The variable os.Args is a slice of strings. Slices are a fundamental notion in Go, and we’ll talk a lot more about them soon. For now, think of a slice as a dynamically sized sequence s of array elements where individual elements can be accessed as s[i] and a contiguous subsequence as s[m:n]. The number of elements is given by len(s). As in most other programming languages, all indexing in Go uses half-open intervals that include the first index but exclude the last, because it simplifies logic. For example, the slice s[m:n], where 0 = m = n = len(s), contains n-m elements.&lt;/p&gt;

&lt;p&gt;The first element of os.Args, os.Args[0], is the name of the command itself; the other elements are the arguments that were presented to the program when it started execution. A slice expression of the form s[m:n] yields a slice that refers to elements m through n-1, so the elements we need for our next example are those in the slice os.Args[1:len(os.Args)]. If m or n is omitted, it defaults to 0 or len(s) respectively, so we can abbreviate the desired slice as os.Args[1:].&lt;/p&gt;

&lt;p&gt;Here’s an implementation of the Unix echo command, which prints its command-line arguments on a single line. It imports two packages, which are given as a parenthesized list rather than as individual import declarations. Either form is legal, but conventionally the list form is used. The order of imports doesn’t matter; the gofmt tool sorts the package names into alphabetical order. (When there are several versions of an example, we will often number them so you can be sure of which one we’re talking about.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/echo1 
// Echo1 prints its command-line arguments. 
package main 

import (
    &amp;quot;fmt&amp;quot; 
    &amp;quot;os&amp;quot; 
) 
func main() {
    var s, sep string 
    for i := 1; i &amp;lt; len(os.Args); i++ {
        s += sep + os.Args[i] 
        sep = &amp;quot; &amp;quot; 
    }
    fmt.Println(s) 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comments begin with //. All text from a // to the end of the line is commentary for programmers and is ignored by the compiler. By convention, we describe each package in a comment immediately preceding its package declaration; for a main package, this comment is one or more complete sentences that describe the program as a whole.&lt;/p&gt;

&lt;p&gt;The var declaration declares two variables s and sep, of type string. A variable can be initialized as part of its declaration. If it is not explicitly initialized, it is implicitly initialized to the zero value for its type, which is 0 for numeric types and the empty string &amp;ldquo;&amp;rdquo; for strings. Thus in this example, the declaration implicitly initializes s and sep to empty strings. We’ll have more to say about variables and declarations in Chapter 2.&lt;/p&gt;

&lt;p&gt;For numbers, Go provides the usual arithmetic and logical operators. When applied to strings, however, the + operator concatenates the values, so the expression
sep + os.Args[i]&lt;/p&gt;

&lt;p&gt;represents the concatenation of the strings sep and os.Args[i]. The statement we used in the program,
s += sep + os.Args[i]
is an assignment statement that concatenates the old value of s with sep and os.Args[i] and assigns it back to s; it is equivalent to
s = s + sep + os.Args[i]&lt;/p&gt;

&lt;p&gt;The operator += is an assignment operator. Each arithmetic and logical operator like + or * has a corresponding assignment operator.&lt;/p&gt;

&lt;p&gt;The echo program could have printed its output in a loop one piece at a time, but this version instead builds up a string by repeatedly appending new text to the end. The string s starts life empty, that is, with value &amp;ldquo;&amp;rdquo;, and each trip through the loop adds some text to it; after the first iteration, a space is also inserted so that when the loop is finished, there is one space between each argument. This is a quadratic process that could be costly if the number of arguments is large, but for echo, that’s unlikely. We’ll show a number of improved versions of echo in this chapter and the next that will deal with any real inefficiency.&lt;/p&gt;

&lt;p&gt;The loop index variable i is declared in the first part of the for loop. The := symbol is part of a short variable declaration, a statement that declares one or more variables and gives them appropriate types based on the initializer values; there’s more about this in the next chapter.&lt;/p&gt;

&lt;p&gt;The increment statement i++ adds 1 to i; it’s equivalent to i += 1 which is in turn equivalent to i=i+1 . There’s a corresponding decrement statement i&amp;ndash;that subtracts 1. These are statements, not expressions as they are in most languages in the C family, so j = i++ is illegal, and they are postfix only, so &amp;ndash;i is not legal either.&lt;/p&gt;

&lt;p&gt;The for loop is the only loop statement in Go. It has a number of forms, one of which is illustrated here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for initialization; condition; post {
// zero or more statements 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parentheses are never used around the three components of a for loop. The braces are mandatory, however, and the opening brace must be on the same line as the post statement.&lt;/p&gt;

&lt;p&gt;The optional initialization statement is executed before the loop starts. If it is present, it must be a simple statement, that is, a short variable declaration, an increment or assignment statement, or a function call. The condition is a boolean expression that is evaluated at the beginning of each iteration of the loop; if it evaluates to true, the statements controlled by the loop are executed. The post statement is executed after the body of the loop, then the condition is evaluated again. The loop ends when the condition becomes false.&lt;/p&gt;

&lt;p&gt;Any of these parts may be omitted. If there is no initialization and no post, the semicolons may also be omitted:&lt;/p&gt;

&lt;p&gt;// a traditional &amp;ldquo;while&amp;rdquo; loop
for condition {
// &amp;hellip;
}&lt;/p&gt;

&lt;p&gt;If the condition is omitted entirely in any of these forms, for example in
// a traditional infinite loop
for {
// &amp;hellip;
}&lt;/p&gt;

&lt;p&gt;the loop is infinite, though loops of this form may be terminated in some other way, like a break or return statement.&lt;/p&gt;

&lt;p&gt;Another form of the for loop iterates over a range of values from a data type like a string or a slice. To illustrate, here’s a second version of echo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/echo2 
// Echo2 prints its command-line arguments. 
package main 
import (
&amp;quot;fmt&amp;quot; 
&amp;quot;os&amp;quot; 
) 
func main() {
s, sep := &amp;quot;&amp;quot;, &amp;quot;&amp;quot; 

for _, arg := range os.Args[1:] { 
s += sep + arg 
sep = &amp;quot; &amp;quot; }
fmt.Println(s) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In each iteration of the loop, range produces a pair of values: the index and the value of the element at that index. In this example, we don’t need the index, but the syntax of a range loop requires that if we deal with the element, we must deal with the index too. One idea would be to assign the index to an obviously temporary variable like temp and ignore its value, but Go does not permit unused local variables, so this would result in a compilation error.&lt;/p&gt;

&lt;p&gt;The solution is to use the blank identifier, whose name is _ (that is, an underscore). The blank identifier may be used whenever syntax requires a variable name but program logic does not, for instance to discard an unwanted loop index when we require only the element value. Most Go programmers would likely use range and _ to write the echo program as above, since the indexing over os.Args is implicit, not explicit, and thus easier to get right.&lt;/p&gt;

&lt;p&gt;This version of the program uses a short variable declaration to declare and initialize s and sep, but we could equally well have declared the variables separately. There are several ways to declare a string variable; these are all equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s := &amp;quot;&amp;quot; 
var s string 
var s = &amp;quot;&amp;quot; 
var s string = &amp;quot;&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why should you prefer one form to another? The first form, a short variable declaration, is the most compact, but it may be used only within a function, not for package-level variables. The second form relies on default initialization to the zero value for strings, which is &amp;ldquo;&amp;rdquo;. The third form is rarely used except when declaring multiple variables. The fourth form is explicit about the variable’s type, which is redundant when it is the same as that of the initial value but necessary in other cases where they are not of the same type. In practice, you should generally use one of the first two forms, with explicit initialization to say that the initial value is important and implicit initialization to say that the initial value doesn’t matter.&lt;/p&gt;

&lt;p&gt;As noted above, each time around the loop, the string s gets completely new contents. The += statement makes a new string by concatenating the old string, a space character, and the next argument, then assigns the new string to s. The old contents of s are no longer in use, so they will be garbage-collected in due course.&lt;/p&gt;

&lt;p&gt;If the amount of data involved is large, this could be costly. A simpler and more efficient solution would be to use the Join function from the strings package:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/echo3 
func main() {
fmt.Println(strings.Join(os.Args[1:], &amp;quot; &amp;quot;)) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, if we don’t care about format but just want to see the values, perhaps for debugging, we can let Println format the results for us:
fmt.Println(os.Args[1:]) The output of this statement is like what we would get from strings.Join, but with surrounding brackets. Any slice may be printed this way.&lt;/p&gt;

&lt;p&gt;Exercise 1.1: Modify the echo program to also print os.Args[0], the name of  the command that invoked it.&lt;/p&gt;

&lt;p&gt;Exercise 1.2: Modify the echo program to print the index and value of each of its arguments, one per line.&lt;/p&gt;

&lt;p&gt;Exercise 1.3: Experiment to measure the difference in running time between our potentially inefficient versions and the one that uses strings.Join. (Section 1.6 illustrates part of the time package, and Section 11.4 shows how to write
benchmark tests for systematic performance evaluation.)&lt;/p&gt;

&lt;h2 id=&#34;finding-duplicate-lines:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Finding Duplicate Lines&lt;/h2&gt;

&lt;p&gt;Programs for file copying, printing, searching, sorting, counting, and the like all have a similar structure: a loop over the input, some computation on each element, and generation of output on the fly or at the end. We’ll show three variants of a program called dup; it is partly inspired by the Unix uniq command, which looks for adjacent duplicate lines. The structures and packages used are models that can be easily adapted.&lt;/p&gt;

&lt;p&gt;The first version of dup prints each line that appears more than once in the standard input, preceded by its count. This program introduces the if statement, the map data type, and the bufio package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/dup1 
// Dup1 prints the text of each line that appears more than // once in the standard input, preceded by its count. package main 
import (
&amp;quot;bufio&amp;quot; 
&amp;quot;fmt&amp;quot; 
&amp;quot;os&amp;quot; 

) 
func main() {
counts := make(map[string]int) 
input := bufio.NewScanner(os.Stdin) 
for input.Scan() {

counts[input.Text()]++ }// NOTE: ignoring potential errors from 
input.Err()
for line, n := range counts {
if n &amp;gt; 1 {
fmt.Printf(&amp;quot;%d\t%s\n&amp;quot;, n, line) 

}
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with for, parentheses are never used around the condition in an if statement, but braces are required for the body. There can be an optional else part that is executed if the condition is false.&lt;/p&gt;

&lt;p&gt;A map holds a set of key/value pairs and provides constant-time operations to store, retrieve, or test for an item in the set. The key may be of any type whose values can be compared with ==, strings being the most common example; the value may be of any type at all. In this example, the keys are strings and the values are ints. The built-in function make creates a new empty map; it has other uses too. Maps are discussed at length in Section 4.3.&lt;/p&gt;

&lt;p&gt;Each time dup reads a line of input, the line is used as a key into the map and the corresponding value is incremented. The statement counts[input.Text()]++ is equivalent to these two statements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;line := input.Text()
counts[line] = counts[line] + 1 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It’s not a problem if the map doesn’t yet contain that key. The first time a new line is seen, the expression counts[line] on the right-hand side evaluates to the zero value for its type, which is 0 for int.&lt;/p&gt;

&lt;p&gt;To print the results, we use another range-based for loop, this time over the counts map. As before, each iteration produces two results, a key and the value of the map element for that key. The order of map iteration is not specified, but in practice it is random, varying from one run to another. This design is intentional, since it prevents programs from relying on any particular ordering where none is guaranteed.&lt;/p&gt;

&lt;p&gt;Onward to the bufio package, which helps make input and output efficient and convenient. One of its most useful features is a type called Scanner that reads input and breaks it into lines or words; it’s often the easiest way to process input that comes naturally in lines.&lt;/p&gt;

&lt;p&gt;The program uses a short variable declaration to create a new variable input that refers to a bufio.Scanner:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;input := bufio.NewScanner(os.Stdin) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The scanner reads from the program’s standard input. Each call to input.Scan()reads the next line and removes the newline character from the end; the result can be retrieved by calling input.Text(). The Scan function returns true if there is a line and false when there is no more input.&lt;/p&gt;

&lt;p&gt;The function fmt.Printf, like printf in C and other languages, produces formatted output from a list of expressions. Its first argument is a format string that specifies how subsequent arguments should be formatted. The format of each argument is determined by a conversion character, a letter following a percent sign. For example, %d formats an integer operand using decimal notation, and %s expands to the value of a string operand.&lt;/p&gt;

&lt;p&gt;Printf has over a dozen such conversions, which Go programmers call verbs. This table is far from a complete specification but illustrates many of the features that are available:&lt;/p&gt;

&lt;p&gt;View table image&lt;br /&gt;
%d  decimal integer&lt;br /&gt;
%x, %o,  %b  integer in hexadecimal, octal, binary&lt;br /&gt;
%f, %g, %t  %e  floating-point number: 3.141593 boolean: true or false  3.141592653589793&lt;br /&gt;
%c  rune (Unicode code point)&lt;br /&gt;
%s  string&lt;br /&gt;
%q %v  quoted string &amp;ldquo;abc&amp;rdquo; or rune &amp;lsquo;c&amp;rsquo; any value in a natural format&lt;br /&gt;
%T  type of any value&lt;br /&gt;
%%  literal percent sign (no operand)&lt;/p&gt;

&lt;p&gt;The format string in dup1 also contains a tab \t and a newline \n. String literals may contain such escape sequences for representing otherwise invisible characters. Printf does not write a newline by default. By convention, formatting functions whose names end in f, such as log.Printf and fmt.Errorf, use the formatting rules of fmt.Printf, whereas those whose names end in ln follow Println, formatting their arguments as if by %v, followed by a newline.&lt;/p&gt;

&lt;p&gt;Many programs read either from their standard input, as above, or from a sequence of named files. The next version of dup can read from the standard input or handle a list of file names, using os.Open to open each one:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/dup2 
// Dup2 prints the count and text of lines that appear more than once // in the input. It reads from stdin or from a list of named files. package main 
import (
&amp;quot;bufio&amp;quot; 
&amp;quot;fmt&amp;quot; 
&amp;quot;os&amp;quot; 
) 
func main() {
counts := make(map[string]int) 
files := os.Args[1:] 
if len(files) == 0 {

countLines(os.Stdin, counts) 
} else {

for     _, arg := range files {f, err := os.Open(arg) if err != nil {
fmt.Fprintf(os.Stderr, &amp;quot;dup2: %v\n&amp;quot;, err) 
continue }countLines(f, counts) f.Close() 
}
}
for line, n := range counts {

if n &amp;gt; 1 {fmt.Printf(&amp;quot;%d\t%s\n&amp;quot;, n, line) 
}
}
} 

func countLines(f *os.File, counts map[string]int) { 
input := bufio.NewScanner(f) 
for input.Scan() {
counts[input.Text()]++ 
}
// NOTE: ignoring potential errors from 
input.Err()
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function os.Open returns two values. The first is an open file (*os.File) that is used in subsequent reads by the Scanner.&lt;/p&gt;

&lt;p&gt;The second result of os.Open is a value of the built-in error type. If err equals the special built-in value nil, the file was opened successfully. The file is read, and when the end of the input is reached, Close closes the file and releases any resources. On the other hand, if err is not nil, something went wrong.&lt;/p&gt;

&lt;p&gt;In that case, the error value describes the problem. Our simple-minded error handling prints a message on the standard error stream using Fprintf and the verb %v, which displays a value of any type in a default format, and dup then carries on with the next file; the continue statement goes to the next iteration of the enclosing for loop.&lt;/p&gt;

&lt;p&gt;In the interests of keeping code samples to a reasonable size, our early examples are intentionally somewhat cavalier about error handling. Clearly we must check for an error from os.Open; however, we are ignoring the less likely possibility that an error could occur while reading the file with input.Scan. We will note places where we’ve skipped error checking, and we will go into the details of error handling in Section 5.4.&lt;/p&gt;

&lt;p&gt;Notice that the call to countLines precedes its declaration. Functions and other package-level entities may be declared in any order.&lt;/p&gt;

&lt;p&gt;A map is a reference to the data structure created by make. When a map is passed to a function, the function receives a copy of the reference, so any changes the called function makes to the underlying data structure will be visible through the caller’s map reference too. In our example, the values inserted into the counts map by countLines are seen by main.&lt;/p&gt;

&lt;p&gt;The versions of dup above operate in a “streaming” mode in which input is read and broken into lines as needed, so in principle these programs can handle an arbitrary amount of input. An alternative approach is to read the entire input into memory in one big gulp, split it into lines all at once, then process the lines. The following version, dup3, operates in that fashion. It introduces the function ReadFile (from the io/ioutil package), which reads the entire contents of a named file, and strings.Split, which splits a string into a slice of substrings. (Split is the opposite of strings.Join, which we saw earlier.)&lt;/p&gt;

&lt;p&gt;We’ve simplified dup3 somewhat. First, it only reads named files, not the standard input, since ReadFile requires a file name argument. Second, we moved the counting of the lines back into main, since it is now needed in only one place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/dup3 
package main 
import (
&amp;quot;fmt&amp;quot; 
&amp;quot;io/ioutil&amp;quot;
&amp;quot;os&amp;quot; 
&amp;quot;strings&amp;quot; ) 
func main() {
    counts := make(map[string]int) 
    for _, filename := range os.Args[1:] { 
        data, err := ioutil.ReadFile(filename) 
        if err != nil {
            fmt.Fprintf(os.Stderr, &amp;quot;dup3: %v\n&amp;quot;, err) 
            continue 
        }
        for _, line := range strings.Split(string(data), &amp;quot;\n&amp;quot;) { 
            counts[line]++ 
        } 
    }
    for line, n := range counts {
        if n &amp;gt; 1 {
            fmt.Printf(&amp;quot;%d\t%s\n&amp;quot;, n, line) 
        }
    }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ReadFile returns a byte slice that must be converted into a string so it can be split by strings.Split. We will discuss strings and byte slices at length in Section 3.5.4.&lt;/p&gt;

&lt;p&gt;Under the covers, bufio.Scanner, ioutil.ReadFile, and ioutil.WriteFile use the Read and Write methods of *os.File, but it’s rare that most programmers need to access those lower-level routines directly. The higher-level functions like those from bufio and io/ioutil are easier to use.&lt;/p&gt;

&lt;p&gt;Exercise 1.4: Modify dup2 to print the names of all files in which each duplicated line occurs.&lt;/p&gt;

&lt;h2 id=&#34;animated-gifs:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Animated GIFs&lt;/h2&gt;

&lt;p&gt;The next program demonstrates basic usage of Go’s standard image packages, which we’ll use to create a sequence of bit-mapped images and then encode the sequence as a GIF animation. The images, called Lissajous figures, were a staple visual effect in sci-fi films of the 1960s. They are the parametric curves produced by harmonic oscillation in two dimensions, such as two sine waves fed into the x and y inputs of an oscilloscope. Figure 1.1 shows some examples.&lt;/p&gt;

&lt;p&gt;There are several new constructs in this code, including const declarations, struct types, and composite literals. Unlike most of our examples, this one also involves floating-point computations. We’ll discuss these topics only briefly here, pushing most details off to later chapters, since the primary goal right now is to give you an idea of what Go looks like and the kinds of things that can be done easily with the language and its libraries.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/lissajous 
// Lissajous generates GIF animations of random 
Lissajous figures. 
package main 
import (
    &amp;quot;image&amp;quot;
    &amp;quot;image/color&amp;quot;
    &amp;quot;image/gif&amp;quot;
    &amp;quot;io&amp;quot; 

    &amp;quot;math&amp;quot; 
    &amp;quot;math/rand&amp;quot;
    &amp;quot;os&amp;quot; 

) 
var palette = []color.Color{color.White, color.Black} 
const (
    whiteIndex = 0 // first color in palette 
    blackIndex = 1 // next color in palette 
) 
func main() {lissajous(os.Stdout) } 

func lissajous(out io.Writer) { 
    const (cycles = 5 // number of complete x oscillator revolutions 
    res = 0.001 // angular resolution 
    size = 100 // image canvas 
    covers [­size..+size]nframes = 64 // number of animation frames 
    delay = 8 // delay between frames in 10ms units )
    freq := rand.Float64() * 3.0 // relative frequency of y oscillator 
    anim := gif.GIF{LoopCount: nframes} 
    phase := 0.0 // phase difference 
    for i := 0; i &amp;lt; nframes; i++ {
    rect := image.Rect(0, 0, 2*size+1, 2*size+1) 
    img := image.NewPaletted(rect, palette) 
    for t := 0.0; t &amp;lt; cycles*2*math.Pi; t += res {
        x := math.Sin(t) 
        y := math.Sin(t*freq + phase)
        img.SetColorIndex(size+int(x*size+0.5),size+int(y*size+0.5), blackIndex) 
    }
    phase += 0.1 
    anim.Delay = append(anim.Delay, delay) 
    anim.Image = append(anim.Image, img) }
    gif.EncodeAll(out, &amp;amp;anim) // NOTE: ignoring encoding errors 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After importing a package whose path has multiple components, like image/color, we refer to the package with a name that comes from the last component. Thus the variable color.White belongs to the image/color package and gif.GIF belongs to image/gif.&lt;/p&gt;

&lt;p&gt;A const declaration (§3.6) gives names to constants, that is, values that are fixed at compile time, such as the numerical parameters for cycles, frames, and delay. Like var declarations, const declarations may appear at package level (so the names are visible throughout the package) or within a function (so the names are visible only within that function). The value of a constant must be a number, string, or boolean.&lt;/p&gt;

&lt;p&gt;The expressions []color.Color{&amp;hellip;} and gif.GIF{&amp;hellip;} are composite literals (§4.2, §4.4.1), a compact notation for instantiating any of Go’s composite types from a sequence of element values. Here, the first one is a slice and the second one is a struct.&lt;/p&gt;

&lt;p&gt;The type gif.GIF is a struct type (§4.4). A struct is a group of values called fields, often of different types, that are collected together in a single object that can be treated as a unit. The variable anim is a struct of type gif.GIF. The struct literal creates a struct value whose LoopCount field is set to nframes; all other fields have the zero value for their type. The individual fields of a struct can be accessed using dot notation, as in the final two assignments which explicitly update the Delay and Image fields of anim.&lt;/p&gt;

&lt;p&gt;The lissajous function has two nested loops. The outer loop runs for 64 iterations, each producing a single frame of the animation. It creates a new 201×201 image with a palette of two colors, white and black. All pixels are initially set to the palette’s zero value (the zeroth color in the palette), which we set to white. Each pass through the inner loop generates a new image by setting some pixels to black. The result is appended, using the built-in append function (§4.2.1), to a list of frames in anim, along with a specified delay of 80ms.&lt;/p&gt;

&lt;p&gt;Finally the sequence of frames and delays is encoded into GIF format and written to the output stream out. The type of out is io.Writer, which lets us write to a wide range of possible destinations, as we’ll show soon.&lt;/p&gt;

&lt;p&gt;The inner loop runs the two oscillators. The x oscillator is just the sine function. The y oscillator is also a sinusoid, but its frequency relative to the x oscillator is a random number between 0 and 3, and its phase relative to the x oscillator is initially zero but increases with each frame of the animation. The loop runs until the x oscillator has completed five full cycles. At each step, it calls SetColorIndex to color the pixel corresponding to (x, y) black, which is at position 1 in the palette.&lt;/p&gt;

&lt;p&gt;The main function calls the lissajous function, directing it to write to the standard output, so this command produces an animated GIF with frames like those in Figure 1.1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go build gopl.io/ch1/lissajous 
$ ./lissajous &amp;gt;out.gif 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exercise 1.5: Change the Lissajous program’s color palette to green on black, for added authenticity. To create the web color #RRGGBB, use color.RGBA{0xRR,0xGG, 0x BB, 0xff} , where each pair of hexadecimal digits represents the intensity of the red, green, or blue component of the pixel.&lt;/p&gt;

&lt;p&gt;Exercise 1.6: Modify the Lissajous program to produce images in multiple colors by adding more values to palette and then displaying them by changing the third argument of SetColorIndex in some interesting way.&lt;/p&gt;

&lt;h2 id=&#34;fetching-a-url:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Fetching a URL&lt;/h2&gt;

&lt;p&gt;For many applications, access to information from the Internet is as important as access to the local file system. Go provides a collection of packages, grouped under net, that make it easy to send and receive information through the Internet, make low-level network connections, and set up servers, for which Go’s concurrency features (introduced in Chapter 8) are particularly useful.&lt;/p&gt;

&lt;p&gt;To illustrate the minimum necessary to retrieve information over HTTP, here’s a simple program called fetch that fetches the content of each specified URL and prints it as uninterpreted text; it’s inspired by the invaluable utility curl. Obviously one would usually do more with such data, but this shows the basic idea. We will use this program frequently in the book.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/fetch 
// Fetch prints the content found at a URL. 
package main 

import (
&amp;quot;fmt&amp;quot; 
&amp;quot;io/ioutil&amp;quot;
&amp;quot;net/http&amp;quot;
&amp;quot;os&amp;quot; 

) 
func main() {
    for _, url := range os.Args[1:] { 
        resp, err := http.Get(url) 
        if err != nil {
            fmt.Fprintf(os.Stderr, &amp;quot;fetch: %v\n&amp;quot;, err) 
            os.Exit(1) 
        }
        b, err := ioutil.ReadAll(resp.Body)resp.Body.Close()
        if err != nil {
            fmt.Fprintf(os.Stderr, &amp;quot;fetch: reading %s: %v\n&amp;quot;, url, err)
            os.Exit(1) 
        }
        fmt.Printf(&amp;quot;%s&amp;quot;, b) 
    }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program introduces functions from two packages, net/http and io/ioutil. The http.Get function makes an HTTP request and, if there is no error, returns the result in the response struct resp. The Body field of resp contains the server response as a readable stream. Next, ioutil.ReadAll reads the entire response; the result is stored in b. The Body stream is closed to avoid leaking resources, and Printf writes the response to the standard output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch1/fetch 
$ ./fetch http://gopl.io 
&amp;lt;html&amp;gt; 
&amp;lt;head&amp;gt; 
&amp;lt;title&amp;gt;The Go Programming Language&amp;lt;/title&amp;gt; 
... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the HTTP request fails, fetch reports the failure instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./fetch http://bad.gopl.io 
fetch: Get http://bad.gopl.io: dial tcp: lookup 
bad.gopl.io: no such host 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In either error case, os.Exit(1) causes the process to exit with a status code of 1.&lt;/p&gt;

&lt;p&gt;Exercise 1.7: The function call io.Copy(dst, src) reads from src and writes to dst. Use it instead of ioutil.ReadAll to copy the response body to os.Stdout without requiring a buffer large enough to hold the entire stream. Be sure to check the error result of io.Copy.&lt;/p&gt;

&lt;p&gt;Exercise 1.8: Modify fetch to add the prefix http:// to each argument URL if it is missing. You might want to use strings.HasPrefix.&lt;/p&gt;

&lt;p&gt;Exercise 1.9: Modify fetch to also print the HTTP status code, found in resp.Status.&lt;/p&gt;

&lt;h2 id=&#34;fetching-urls-concurrently:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Fetching URLs Concurrently&lt;/h2&gt;

&lt;p&gt;One of the most interesting and novel aspects of Go is its support for concurrent programming. This is a large topic, to which Chapter 8 and Chapter 9 are devoted, so for now we’ll give you just a taste of Go’s main concurrency mechanisms, goroutines and channels.&lt;/p&gt;

&lt;p&gt;The next program, fetchall, does the same fetch of a URL’s contents as the previous example, but it fetches many URLs, all concurrently, so that the process will take no longer than the longest fetch rather than the sum of all the fetch times. This version of fetchall discards the responses but reports the size and elapsed time for each one:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/fetchall 
// Fetchall fetches URLs in parallel and reports their times and sizes. package main 
import (
&amp;quot;fmt&amp;quot; 
&amp;quot;io&amp;quot; 
&amp;quot;io/ioutil&amp;quot;
&amp;quot;net/http&amp;quot;
&amp;quot;os&amp;quot; 
&amp;quot;time&amp;quot; 

) 
func main() {
start := time.Now() 
ch := make(chan string) 
for _, url := range os.Args[1:] { 

go fetch(url, ch) // start a goroutine }for range os.Args[1:] {
fmt.Println(&amp;lt;-ch) // receive from channel ch } 
fmt.Printf(&amp;quot;%.2fs elapsed\n&amp;quot;,
time.Since(start).Seconds())
} 

func fetch(url string, ch chan&amp;lt;-string) { 
start := time.Now() 
resp, err := http.Get(url) 
if err != nil {

ch &amp;lt;-fmt.Sprint(err) // send to channel ch return } 
nbytes, err := io.Copy(ioutil.Discard, resp.Body) resp.Body.Close() // don&#39;t leak resources if err != nil {
ch &amp;lt;-fmt.Sprintf(&amp;quot;while reading %s: %v&amp;quot;, url, err) 
return }secs := time.Since(start).Seconds() ch &amp;lt;-fmt.Sprintf(&amp;quot;%.2fs %7d %s&amp;quot;, secs, nbytes, 
url)
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here’s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go build gopl.io/ch1/fetchall 
$ ./fetchall https://golang.org http://gopl.io 
https://godoc.org
0.14s 6852 https://godoc.org 
0.16s 7261 https://golang.org 
0.48s 2475 http://gopl.io 
0.48s elapsed 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A goroutine is a concurrent function execution. A channel is a communication mechanism that allows one goroutine to pass values of a specified type to another goroutine. The function main runs in a goroutine and the go statement creates additional goroutines.&lt;/p&gt;

&lt;p&gt;The main function creates a channel of strings using make. For each command-line argument, the go statement in the first range loop starts a new goroutine that calls fetch asynchronously to fetch the URL using http.Get. The io.Copy function reads the body of the response and discards it by writing to the ioutil.Discard output stream. Copy returns the byte count, along with any error that occurred. As each result arrives, fetch sends a summary line on the channel ch. The second range loop in main receives and prints those lines.&lt;/p&gt;

&lt;p&gt;When one goroutine attempts a send or receive on a channel, it blocks until another goroutine attempts the corresponding receive or send operation, at which point the value is transferred and both goroutines proceed. In this example, each fetch sends a value (ch &amp;lt;-expression) on the channel ch, and main receives all of them (&amp;lt;­ch). Having main do all the printing ensures that output from each goroutine is processed as a unit, with no danger of interleaving if two goroutines finish at the same time.&lt;/p&gt;

&lt;p&gt;Exercise 1.10: Find a web site that produces a large amount of data. Investigate caching by running fetchall twice in succession to see whether the reported time changes much. Do you get the same content each time? Modify fetchall to print its output to a file so it can be examined.&lt;/p&gt;

&lt;p&gt;Exercise 1.11: Try fetchall with longer argument lists, such as samples from the top million web sites available at alexa.com. How does the program behave if a web site just doesn’t respond? (Section 8.9 describes mechanisms for coping in such cases.)&lt;/p&gt;

&lt;h2 id=&#34;a-web-server:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;A Web Server&lt;/h2&gt;

&lt;p&gt;Go’s libraries makes it easy to write a web server that responds to client requests like those made by fetch. In this section, we’ll show a minimal server that returns the path component of the URL used to access the server. That is, if the request is for &lt;a href=&#34;http://localhost:8000/hello&#34;&gt;http://localhost:8000/hello&lt;/a&gt;, the response will be URL.Path = &amp;ldquo;/hello&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/server1 
// Server1 is a minimal &amp;quot;echo&amp;quot; server. 
package main 

import (
&amp;quot;fmt&amp;quot; 
&amp;quot;log&amp;quot;
&amp;quot;net/http&amp;quot; 

) 
func main() {
http.HandleFunc(&amp;quot;/&amp;quot;, handler) // each request 
calls handler 

log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;,nil))} 
// handler echoes the Path component of the requested 
URL. 
func handler(w http.ResponseWriter, r *http.Request) { 

fmt.Fprintf(w, &amp;quot;URL.Path = %q\n&amp;quot;, r.URL.Path) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The program is only a handful of lines long because library functions do most of the work. The main function connects a handler function to incoming URLs whose path begins with /, which is all URLs, and starts a server listening for incoming requests on port 8000. A request is represented as a struct of type http.Request, which contains a number of related fields, one of which is the URL of the incoming request. When a request arrives, it is given to the handler function, which extracts the path component (/hello) from the request URL and sends it back as the response, using fmt.Fprintf. Web servers will be explained in detail in Section 7.7.&lt;/p&gt;

&lt;p&gt;Let’s start the server in the background. On Mac OS X or Linux, add an ampersand (&amp;amp;) to the command; on Microsoft Windows, you will need to run the command without the ampersand in a separate command window.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run src/// gopl.io/ch1/server1/main.go &amp;amp; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then make client requests from the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go build gopl.io/ch1/fetch 
$ ./fetch http://localhost:8000 
URL.Path = &amp;quot;/&amp;quot; 
$ ./fetch http://localhost:8000/help 
URL.Path = &amp;quot;/help&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, we can access the server from a web browser, as shown in Figure 1.2.&lt;/p&gt;

&lt;p&gt;It’s easy to add features to the server. One useful addition is a specific URL that returns a status of some sort. For example, this version does the same echo but also counts the number of requests; a request to the URL /count returns the count so far, excluding /count requests themselves:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/server2 
// Server2 is a minimal &amp;quot;echo&amp;quot; and counter server. 
package main 
import (
&amp;quot;fmt&amp;quot; 
&amp;quot;log&amp;quot;
&amp;quot;net/http&amp;quot;
&amp;quot;sync&amp;quot; 

) 
var mu sync.Mutex 
var count int 

func main() {http.HandleFunc(&amp;quot;/&amp;quot;, handler)http.HandleFunc(&amp;quot;/count&amp;quot;, counter)log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;,
nil))
} 

// handler echoes the Path component of the requested 
URL. 
func handler(w http.ResponseWriter, r *http.Request) { 

mu.Lock()
count++ 
mu.Unlock()
fmt.Fprintf(w, &amp;quot;URL.Path = %q\n&amp;quot;, r.URL.Path) 

} 
// counter echoes the number of calls so far. 
func counter(w http.ResponseWriter, r *http.Request) { mu.Lock()fmt.Fprintf(w, &amp;quot;Count %d\n&amp;quot;, count) mu.Unlock() 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The server has two handlers, and the request URL determines which one is called: a request for /count invokes counter and all others invoke handler. A handler pattern that ends with a slash matches any URL that has the pattern as a prefix. Behind the scenes, the server runs the handler for each incoming request in a separate goroutine so that it can serve multiple requests simultaneously. However, if two concurrent requests try to update count at the same time, it might not be incremented consistently; the program would have a serious bug called a race condition (§9.1).&lt;/p&gt;

&lt;p&gt;To avoid this problem, we must ensure that at most one goroutine accesses the variable at a time, which is the purpose of the mu.Lock() and mu.Unlock() calls that bracket each access of count. We’ll look more closely at concurrency with shared variables in Chapter 9.&lt;/p&gt;

&lt;p&gt;As a richer example, the handler function can report on the headers and form data that it receives, making the server useful for inspecting and debugging requests:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch1/server3 
// handler echoes the HTTP request. 

func handler(w http.ResponseWriter, r *http.Request) { 
    fmt.Fprintf(w, &amp;quot;%s %s %s\n&amp;quot;, r.Method, r.URL, r.Proto) for k, v := range r.Header {
        fmt.Fprintf(w, &amp;quot;Header[%q] = %q\n&amp;quot;, k, v) 
    }

    fmt.Fprintf(w, &amp;quot;Host = %q\n&amp;quot;, r.Host) 
    fmt.Fprintf(w, &amp;quot;RemoteAddr = %q\n&amp;quot;, r.RemoteAddr)

    if err := r.ParseForm(); err != nil {
        log.Print(err) 
    }
    for k, v := range r.Form {
        fmt.Fprintf(w, &amp;quot;Form[%q] = %q\n&amp;quot;, k, v) 
    }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This uses the fields of the http.Request struct to produce output like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;GET /?q=query HTTP/1.1
Header[&amp;quot;Accept-Encoding&amp;quot;] = [&amp;quot;gzip, deflate, sdch&amp;quot;] 
Header[&amp;quot;Accept-Language&amp;quot;] = [&amp;quot;en-US,en;q=0.8&amp;quot;] 
Header[&amp;quot;Connection&amp;quot;] = [&amp;quot;keep-alive&amp;quot;] 
Header[&amp;quot;Accept&amp;quot;] = 
[&amp;quot;text/html,application/xhtml+xml,application/xml;...&amp;quot;] 

Header[&amp;quot;User-Agent&amp;quot;] = [&amp;quot;Mozilla/5.0 (Macintosh; Intel 
Mac OS X 10_7_5)...&amp;quot;] 
Host = &amp;quot;localhost:8000&amp;quot; 
RemoteAddr = &amp;quot;127.0.0.1:59911&amp;quot; 
Form[&amp;quot;q&amp;quot;] = [&amp;quot;query&amp;quot;] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how the call to ParseForm is nested within an if statement. Go allows a simple statement such as a local variable declaration to precede the if condition, which is particularly useful for error handling as in this example. We could have written it as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;err := r.ParseForm() 
if err != nil {
log.Print(err) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but combining the statements is shorter and reduces the scope of the variable err, which is good practice. We’ll define scope in Section 2.7.&lt;/p&gt;

&lt;p&gt;In these programs, we’ve seen three very different types used as output streams. The fetch program copied HTTP response data to os.Stdout, a file, as did the lissajous program. The fetchall program threw the response away (while counting its length) by copying it to the trivial sink ioutil.Discard. And the web server above used fmt.Fprintf to write to an http.ResponseWriter representing the web browser.&lt;/p&gt;

&lt;p&gt;Although these three types differ in the details of what they do, they all satisfy a common interface, allowing any of them to be used wherever an output stream is needed. That interface, called io.Writer, is discussed in Section 7.1.&lt;/p&gt;

&lt;p&gt;Go’s interface mechanism is the topic of Chapter 7, but to give an idea of what it’s capable of, let’s see how easy it is to combine the web server with the lissajousfunction so that animated GIFs are written not to the standard output, but to the HTTP client. Just add these lines to the web server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;handler := func(w http.ResponseWriter, r *http.Request) {
lissajous(w) 
} 

http.HandleFunc(&amp;quot;/&amp;quot;, handler) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or equivalently:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
    lissajous(w) 
}) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second argument to the HandleFunc function call immediately above is a function literal, that is, an anonymous function defined at its point of use. We will explain it further in Section 5.6.&lt;/p&gt;

&lt;p&gt;Once you’ve made this change, visit &lt;a href=&#34;http://localhost:8000&#34;&gt;http://localhost:8000&lt;/a&gt; in your browser. Each time you load the page, you’ll see a new animation like the one in Figure 1.3.&lt;/p&gt;

&lt;p&gt;Exercise 1.12: Modify the Lissajous server to read parameter values from the URL. For example, you might arrange it so that a URL like &lt;a href=&#34;http://localhost:8000/?cycles=20&#34;&gt;http://localhost:8000/?cycles=20&lt;/a&gt; sets the number of cycles to 20 instead of the default 5. Use the strconv.Atoi function to convert the string parameter into an integer. You can see its documentation with go doc strconv.Atoi.&lt;/p&gt;

&lt;h2 id=&#34;loose-ends:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Loose Ends&lt;/h2&gt;

&lt;p&gt;There is a lot more to Go than we’ve covered in this quick introduction. Here are some topics we’ve barely touched upon or omitted entirely, with just enough discussion that they will be familiar when they make brief appearances before the full treatment.&lt;/p&gt;

&lt;p&gt;Control flow: We covered the two fundamental control-flow statements, if and for, but not the switch statement, which is a multi-way branch. Here’s a small example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;switch coinflip() { 
    case &amp;quot;heads&amp;quot;: 
        heads++ 
    case &amp;quot;tails&amp;quot;: 
        tails++ 
    default: 
        fmt.Println(&amp;quot;landed on edge!&amp;quot;) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result of calling coinflip is compared to the value of each case. Cases are evaluated from top to bottom, so the first matching one is executed. The optional default case matches if none of the other cases does; it may be placed anywhere. Cases do not fall through from one to the next as in C-like languages (though there is a rarely used fallthrough statement that overrides this behavior).&lt;/p&gt;

&lt;p&gt;A switch does not need an operand; it can just list the cases, each of which is a boolean expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Signum(x int) int {
    switch {
        case x &amp;gt; 0: 
        return +1 
        default: 
        return 0 
        case x &amp;lt; 0: 
        return -1 
    } 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This form is called a tagless switch; it’s equivalent to switch true .
Like the for and if statements, a switch may include an optional simple statement—a short variable declaration, an increment or assignment statement, or a function call—that can be used to set a value before it is tested.&lt;/p&gt;

&lt;p&gt;The break and continue statements modify the flow of control. A break causes control to resume at the next statement after the innermost for, switch, or select statement (which we’ll see later), and as we saw in Section 1.3, a continue causes the innermost for loop to start its next iteration. Statements may be labeled so that break and continue can refer to them, for instance to break out of several nested loops at once or to start the next iteration of the outermost loop. There is even a goto statement, though it’s intended for machine-generated code, not regular use by programmers.&lt;/p&gt;

&lt;p&gt;Named types: A type declaration makes it possible to give a name to an existing type. Since struct types are often long, they are nearly always named. A familiar example is the definition of a Point type for a 2-D graphics system:&lt;/p&gt;

&lt;p&gt;type Point struct {
X, Y int }
var p Point
Type declarations and named types are covered in Chapter 2.&lt;/p&gt;

&lt;p&gt;Pointers: Go provides pointers, that is, values that contain the address of a variable. In some languages, notably C, pointers are relatively unconstrained. In other languages, pointers are disguised as “references,” and there’s not much that can be done with them except pass them around. Go takes a position somewhere in the middle. Pointers are explicitly visible. The &amp;amp; operator yields the address of a variable, and the * operator retrieves the variable that the pointer refers to, but there is no pointer arithmetic. We’ll explain pointers in Section 2.3.2.&lt;/p&gt;

&lt;p&gt;Methods and interfaces: A method is a function associated with a named type; Go is unusual in that methods may be attached to almost any named type. Methods are covered in Chapter 6. Interfaces are abstract types that let us treat different concrete types in the same way based on what methods they have, not how they are represented or implemented. Interfaces are the subject of Chapter 7.&lt;/p&gt;

&lt;p&gt;Packages: Go comes with an extensive standard library of useful packages, and the Go community has created and shared many more. Programming is often more about using existing packages than about writing original code of one’s own. Throughout the book, we will point out a couple of dozen of the most important standard packages, but there are many more we don’t have space to mention, and we cannot provide anything remotely like a complete reference for any package.&lt;/p&gt;

&lt;p&gt;Before you embark on any new program, it’s a good idea to see if packages already exist that might help you get your job done more easily. You can find an index of the standard library packages at &lt;a href=&#34;https://golang.org/pkg&#34;&gt;https://golang.org/pkg&lt;/a&gt; and the packages contributed by the community at &lt;a href=&#34;https://godoc.org&#34;&gt;https://godoc.org&lt;/a&gt;. The go doc tool makes these documents easily accessible from the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go doc http.ListenAndServe 
package http // import &amp;quot;net/http&amp;quot; 
func ListenAndServe(addr string, handler Handler) 
error 
ListenAndServe listens on the TCP network address 
addr and then 
calls Serve with handler to handle requests on 
incoming connections. 
... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comments: We have already mentioned documentation comments at the beginning of a program or package. It’s also good style to write a comment before the declaration of each function to specify its behavior. These conventions are important, because they are used by tools like go doc and godoc to locate and display documentation (§10.7.4).&lt;/p&gt;

&lt;p&gt;For comments that span multiple lines or appear within an expression or statement, there is also the &lt;code&gt;/* ... */&lt;/code&gt; notation familiar from other languages. Such comments are sometimes used at the beginning of a file for a large block of explanatory text to avoid a &lt;code&gt;//&lt;/code&gt; on every line. Within a comment, &lt;code&gt;/&lt;/code&gt;/ and &lt;code&gt;/*&lt;/code&gt; have no special meaning, so comments do not nest.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Program Structure&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In Go, as in any other programming language, one builds large programs from a small set of basic constructs. Variables store values. Simple expressions are combined into larger ones with operations like addition and subtraction. Basic types are collected into aggregates like arrays and structs. Expressions are used in statements whose execution order is determined by control-flow statements like if and for. Statements are grouped into functions for isolation and reuse. Functions are gathered into source files and packages.&lt;/p&gt;

&lt;p&gt;We saw examples of most of these in the previous chapter. In this chapter, we’ll go into more detail about the basic structural elements of a Go program. The example programs are intentionally simple, so we can focus on the language without getting sidetracked by complicated algorithms or data structures.&lt;/p&gt;

&lt;h2 id=&#34;names:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Names&lt;/h2&gt;

&lt;p&gt;The names of Go functions, variables, constants, types, statement labels, and packages follow a simple rule: a name begins with a letter (that is, anything that Unicode deems a letter) or an underscore and may have any number of additional letters, digits, and underscores. Case matters: heapSort and Heapsort are different names.&lt;/p&gt;

&lt;p&gt;Go has 25 keywords like if and switch that may be used only where the syntax permits; they can’t be used as names.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;break default func interface select case defer go map struct chan else goto package switch const fallthrough if range typecontinue for import return var 

In addition, there are about three dozen predeclared names like int and true for built-in constants, types, and functions: 
Constants:  true  false  iota  nil  
Types:  int  int8  int16  int32  int64  
uint  uint8  uint16  uint32  uint64  
uintptrfloat32 float64 bool byte rune  complex128 complex64 string error  
Functions:  make close  len cap delete  new  append  copy  

complex real imag panic recover 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These names are not reserved, so you may use them in declarations. We’ll see a handful of places where redeclaring one of them makes sense, but beware of the potential for confusion.&lt;/p&gt;

&lt;p&gt;If an entity is declared within a function, it is local to that function. If declared outside of a function, however, it is visible in all files of the package to which it belongs. The case of the first letter of a name determines its visibility across package boundaries. If the name begins with an upper-case letter, it is exported, which means that it is visible and accessible outside of its own package and may be referred to by other parts of the program, as with Printf in the fmt package. Package names themselves are always in lower case.&lt;/p&gt;

&lt;p&gt;There is no limit on name length, but convention and style in Go programs lean toward short names, especially for local variables with small scopes; you are much more likely to see variables named i than theLoopIndex. Generally, the larger the scope of a name, the longer and more meaningful it should be.&lt;/p&gt;

&lt;p&gt;Stylistically, Go programmers use “camel case” when forming names by combining words; that is, interior capital letters are preferred over interior underscores. Thus the standard libraries have functions with names like QuoteRuneToASCII and parseRequestLine but never quote_rune_to_ASCII or parse_request_line. The letters of acronyms and initialisms like ASCII and HTML are always rendered in the same case, so a function might be called htmlEscape, HTMLEscape, or escapeHTML, but not escapeHtml.&lt;/p&gt;

&lt;h2 id=&#34;declarations:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Declarations&lt;/h2&gt;

&lt;p&gt;A declaration names a program entity and specifies some or all of its properties. There are four major kinds of declarations: var, const, type, and func. We’ll talk about variables and types in this chapter, constants in Chapter 3, and functions in Chapter 5.&lt;/p&gt;

&lt;p&gt;A Go program is stored in one or more files whose names end in .go. Each file begins with a package declaration that says what package the file is part of. The package declaration is followed by any import declarations, and then a sequence of package-level declarations of types, variables, constants, and functions, in any order. For example, this program declares a constant, a function, and a couple of variables:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch2/boiling 
// Boiling prints the boiling point of water. 
package main 
import &amp;quot;fmt&amp;quot; 
const boilingF = 212.0 
func main() {
    var f = boilingF 
    var c = (f -32) * 5 / 9 
    fmt.Printf(&amp;quot;boiling point = %g°F or %g°C\n&amp;quot;, f, c) 
    // Output: 
    // boiling point = 212°F or 100°C 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The constant boilingF is a package-level declaration (as is main), whereas the variables f and c are local to the function main. The name of each package-level entity is visible not only throughout the source file that contains its declaration, but throughout all the files of the package. By contrast, local declarations are visible only within the function in which they are declared and perhaps only within a small part of it.&lt;/p&gt;

&lt;p&gt;A function declaration has a name, a list of parameters (the variables whose values are provided by the function’s callers), an optional list of results, and the function body, which contains the statements that define what the function does. The result list is omitted if the function does not return anything. Execution of the function begins with the first statement and continues until it encounters a return statement or reaches the end of a function that has no results. Control and any results are then returned to the caller.&lt;/p&gt;

&lt;p&gt;We’ve seen a fair number of functions already and there are lots more to come, including an extensive discussion in Chapter 5, so this is only a sketch. The function fToC below encapsulates the temperature conversion logic so that it is defined only once but may be used from multiple places. Here main calls it twice, using the values of two different local constants:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch2/ftoc 
// FtoC prints two Fahrenheit-to-Celsius conversions. package main 
import &amp;quot;fmt&amp;quot; 
func main() {
    const freezingF, boilingF = 32.0, 212.0 
    fmt.Printf(&amp;quot;%g°F = %g°C\n&amp;quot;, freezingF, 

    fToC(freezingF)) // &amp;quot;32°F = 0°C&amp;quot; 
    fmt.Printf(&amp;quot;%g°F = %g°C\n&amp;quot;, boilingF, fToC(boilingF)) // &amp;quot;212°F = 100°C&amp;quot; 
} 

func fToC(f float64) float64 {
    return (f -32) * 5 / 9 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;variables:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Variables&lt;/h2&gt;

&lt;p&gt;A var declaration creates a variable of a particular type, attaches a name to it, and sets its initial value. Each declaration has the general form var name type = expression&lt;/p&gt;

&lt;p&gt;Either the type or the = expression part may be omitted, but not both. If the type is omitted, it is determined by the initializer expression. If the expression is omitted, the initial value is the zero value for the type, which is 0 for numbers, false for booleans, &amp;ldquo;&amp;rdquo; for strings, and nil for interfaces and reference types (slice, pointer, map, channel, function). The zero value of an aggregate type like an array or a struct has the zero value of all of its elements or fields.&lt;/p&gt;

&lt;p&gt;The zero-value mechanism ensures that a variable always holds a well-defined value of its type; in Go there is no such thing as an uninitialized variable. This simplifies code and often ensures sensible behavior of boundary conditions without extra work. For example,&lt;/p&gt;

&lt;p&gt;var s string
fmt.Println(s) // &amp;ldquo;&amp;rdquo;
prints an empty string, rather than causing some kind of error or unpredictable behavior. Go programmers often go to some effort to make the zero value of a more complicated type meaningful, so that variables begin life in a useful state.&lt;/p&gt;

&lt;p&gt;It is possible to declare and optionally initialize a set of variables in a single declaration, with a matching list of expressions. Omitting the type allows declaration of multiple variables of different types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var i, j, k int // int, int, int 
var b, f, s = true, 2.3, &amp;quot;four&amp;quot; // bool, float64, string 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Initializers may be literal values or arbitrary expressions. Package-level variables are initialized before main begins (§2.6.2), and local variables are initialized as their declarations are encountered during function execution.&lt;/p&gt;

&lt;p&gt;A set of variables can also be initialized by calling a function that returns multiple values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var f, err = os.Open(name) // os.Open returns a file and an error 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;short-variable-declarations:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Short Variable Declarations&lt;/h3&gt;

&lt;p&gt;Within a function, an alternate form called a short variable declaration may be used to declare and initialize local variables. It takes the form name := expression, and the type of name is determined by the type of expression. Here are three of the many short variable declarations in the lissajous function (§1.4):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;anim := gif.GIF{LoopCount: nframes} 
freq := rand.Float64() * 3.0 
t := 0.0 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because of their brevity and flexibility, short variable declarations are used to declare and initialize the majority of local variables. A var declaration tends to be reserved for local variables that need an explicit type that differs from that of the initializer expression, or for when the variable will be assigned a value later and its initial value is unimportant.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;i := 100 // an int 
var boiling float64 = 100 // a float64 
var names []string 
var err error 
var p Point 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with var declarations, multiple variables may be declared and initialized in the same short variable declaration,
i, j := 0, 1
but declarations with multiple initializer expressions should be used only when they help readability, such as for short and natural groupings like the initialization part of a for loop.&lt;/p&gt;

&lt;p&gt;Keep in mind that := is a declaration, whereas = is an assignment. A multi-variable declaration should not be confused with a tuple assignment (§2.4.1), in which each variable on the left-hand side is assigned the corresponding value from the right-hand side:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;i, j = j, i // swap values of i and j 
Like ordinary var declarations, short variable declarations may be used for calls to functions like os.Open that return two or more values: 
f, err := os.Open(name) 
if err != nil {
return err 
}
// ...use f... 
f.Close() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One subtle but important point: a short variable declaration does not necessarily declare all the variables on its left-hand side. If some of them were already declared in the same lexical block (§2.7), then the short variable declaration acts like an assignment to those variables.&lt;/p&gt;

&lt;p&gt;In the code below, the first statement declares both in and err. The second declares out but only assigns a value to the existing err variable.
in, err := os.Open(infile)
// &amp;hellip;
out, err := os.Create(outfile)&lt;/p&gt;

&lt;p&gt;A short variable declaration must declare at least one new variable, however, so this code will not compile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f, err := os.Open(infile) 
// ... 
f, err := os.Create(outfile) // compile error: no new variables 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fix is to use an ordinary assignment for the second statement.&lt;/p&gt;

&lt;p&gt;A short variable declaration acts like an assignment only to variables that were already declared in the same lexical block; declarations in an outer block are ignored. We’ll see examples of this at the end of the chapter.&lt;/p&gt;

&lt;h3 id=&#34;pointers:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Pointers&lt;/h3&gt;

&lt;p&gt;A variable is a piece of storage containing a value. Variables created by declarations are identified by a name, such as x, but many variables are identified only by expressions like x[i] or x.f. All these expressions read the value of a variable, except when they appear on the left-hand side of an assignment, in which case a new value is assigned to the variable.&lt;/p&gt;

&lt;p&gt;A pointer value is the address of a variable. A pointer is thus the location at which a value is stored. Not every value has an address, but every variable does. With a pointer, we can read or update the value of a variable indirectly, without using or even knowing the name of the variable, if indeed it has a name.&lt;/p&gt;

&lt;p&gt;If a variable is declared var x int , the expression &amp;amp;x (“address of x”) yields a pointer to an integer variable, that is, a value of type *int, which is pronounced “pointer to int.” If this value is called p, we say “p points to x,” or equivalently “pcontains the address of x.” The variable to which p points is written *p. The expression *p yields the value of that variable, an int, but since *p denotes a variable, it may also appear on the left-hand side of an assignment, in which case the assignment updates the variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x := 1 
p := &amp;amp;x // p, of type *int, points to x 
fmt.Println(*p) // &amp;quot;1&amp;quot; 
*p =2 // equivalent to x=2 
fmt.Println(x) // &amp;quot;2&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each component of a variable of aggregate type—a field of a struct or an element of an array—is also a variable and thus has an address too.
Variables are sometimes described as addressable values. Expressions that denote variables are the only expressions to which the address-of operator &amp;amp; may be applied.&lt;/p&gt;

&lt;p&gt;The zero value for a pointer of any type is nil. The test p != nil is true if ppoints to a variable. Pointers are comparable; two pointers are equal if and only if they point to the same variable or both are nil.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x, y int 
fmt.Println(&amp;amp;x == &amp;amp;x, &amp;amp;x == &amp;amp;y, &amp;amp;x == nil) // &amp;quot;true false false&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is perfectly safe for a function to return the address of a local variable. For instance, in the code below, the local variable v created by this particular call to f will remain in existence even after the call has returned, and the pointer p will still refer to it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var p = f() 
func f() *int {
v := 1 
return &amp;amp;v 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each call of f returns a distinct value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Println(f() == f()) // &amp;quot;false&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because a pointer contains the address of a variable, passing a pointer argument to a function makes it possible for the function to update the variable that was indirectly passed. For example, this function increments the variable that its argument points to and returns the new value of the variable so it may be used in an expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func incr(p *int) int {
*p++ // increments what p points to; does not 
change p
return *p 
} 

v := 1 
incr(&amp;amp;v) // side effect: v is now 2 
fmt.Println(incr(&amp;amp;v)) // &amp;quot;3&amp;quot; (and v is 3) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each time we take the address of a variable or copy a pointer, we create new aliases or ways to identify the same variable. For example, *p is an alias for v. Pointer aliasing is useful because it allows us to access a variable without using its name, but this is a double-edged sword: to find all the statements that access a variable, we have to know all its aliases. It’s not just pointers that create aliases; aliasing also occurs when we copy values of other reference types like slices, maps, and channels, and even structs, arrays, and interfaces that contain these types.&lt;/p&gt;

&lt;p&gt;Pointers are key to the flag package, which uses a program’s command-line arguments to set the values of certain variables distributed throughout the program. To illustrate, this variation on the earlier echo command takes two optional flags: -n causes echo to omit the trailing newline that would normally be printed, and -s sep causes it to separate the output arguments by the contents of the string sep instead of the default single space. Since this is our fourth version, the package is called // gopl.io/ch2/echo4.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch2/echo4 
// Echo4 prints its command-line arguments. 
package main 

import (
    &amp;quot;flag&amp;quot;
    &amp;quot;fmt&amp;quot; 
    &amp;quot;strings&amp;quot; 

) 
var n = flag.Bool(&amp;quot;n&amp;quot;, false, &amp;quot;omit trailing newline&amp;quot;) var sep = flag.String(&amp;quot;s&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;separator&amp;quot;) 
func main() {
    flag.Parse()
    fmt.Print(strings.Join(flag.Args(), *sep)) 
    if !*n {
       fmt.Println() 
    }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function flag.Bool creates a new flag variable of type bool. It takes three arguments: the name of the flag (&amp;ldquo;n&amp;rdquo;), the variable’s default value (false), and a message that will be printed if the user provides an invalid argument, an invalid flag, or -h or -help. Similarly, flag.String takes a name, a default value, and a message, and creates a string variable. The variables sep and n are pointers to the flag variables, which must be accessed indirectly as *sep and *n.&lt;/p&gt;

&lt;p&gt;When the program is run, it must call flag.Parse before the flags are used, to update the flag variables from their default values. The non-flag arguments are available from flag.Args() as a slice of strings. If flag.Parse encounters an error, it prints a usage message and calls os.Exit(2) to terminate the program.&lt;/p&gt;

&lt;p&gt;Let’s run some test cases on echo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go build gopl.io/ch2/echo4 
$ ./echo4 a bc def 
a bc def 
$ ./echo4 -s / a bc def 
a/bc/def
$ ./echo4 -n a bc def 
a bc def$ 
$ ./echo4 -help 
Usage of ./echo4: 
-n omit trailing newline 
-s stringseparator (default &amp;quot; &amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-new-function:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;The new Function&lt;/h3&gt;

&lt;p&gt;Another way to create a variable is to use the built-in function new. The expression new(T) creates an unnamed variable of type T, initializes it to the zero value of T, and returns its address, which is a value of type *T.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;p := new(int) // p, of type *int, points to an unnamed int variable 
fmt.Println(*p) // &amp;quot;0&amp;quot; 
*p = 2 // sets the unnamed int to 2 
fmt.Println(*p) // &amp;quot;2&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A variable created with new is no different from an ordinary local variable whose address is taken, except that there’s no need to invent (and declare) a dummy name, and we can use new(T) in an expression. Thus new is only a syntactic convenience, not a fundamental notion: the two newInt functions below have identical behaviors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func newInt() *int { func newInt() *int {return new(int) var dummy int } return &amp;amp;dummy } 

Each call to new returns a distinct variable with a unique address: 
p := new(int) 
q := new(int)
fmt.Println(p == q) // &amp;quot;false&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is one exception to this rule: two variables whose type carries no information and is therefore of size zero, such as struct{} or [0]int, may, depending on the implementation, have the same address.&lt;/p&gt;

&lt;p&gt;The new function is relatively rarely used because the most common unnamed variables are of struct types, for which the struct literal syntax (§4.4.1) is more flexible.&lt;/p&gt;

&lt;p&gt;Since new is a predeclared function, not a keyword, it’s possible to redefine the name for something else within a function, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func delta(old, new int) int { return new -old } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, within delta, the built-in new function is unavailable.&lt;/p&gt;

&lt;h3 id=&#34;lifetime-of-variables:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Lifetime of Variables&lt;/h3&gt;

&lt;p&gt;The lifetime of a variable is the interval of time during which it exists as the program executes. The lifetime of a package-level variable is the entire execution of the program. By contrast, local variables have dynamic lifetimes: a new instance is created each time the declaration statement is executed, and the variable lives on until it becomes unreachable, at which point its storage may be recycled. Function parameters and results are local variables too; they are created each time their enclosing function is called.&lt;/p&gt;

&lt;p&gt;For example, in this excerpt from the Lissajous program of Section 1.4,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for t := 0.0; t &amp;lt; cycles*2*math.Pi; t += res {
x := math.Sin(t) 
y := math.Sin(t*freq + phase)
img.SetColorIndex(size+int(x*size+0.5),
size+int(y*size+0.5),
blackIndex) } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the variable t is created each time the for loop begins, and new variables x and yare created on each iteration of the loop.&lt;/p&gt;

&lt;p&gt;How does the garbage collector know that a variable’s storage can be reclaimed? The full story is much more detailed than we need here, but the basic idea is that every package-level variable, and every local variable of each currently active function, can potentially be the start or root of a path to the variable in question, following pointers and other kinds of references that ultimately lead to the variable. If no such path exists, the variable has become unreachable, so it can no longer affect the rest of the computation.&lt;/p&gt;

&lt;p&gt;Because the lifetime of a variable is determined only by whether or not it is reachable, a local variable may outlive a single iteration of the enclosing loop. It may continue to exist even after its enclosing function has returned.&lt;/p&gt;

&lt;p&gt;A compiler may choose to allocate local variables on the heap or on the stack but, perhaps surprisingly, this choice is not determined by whether var or new was used to declare the variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var global *int func f() { func g() { 
var x int y := new(int) 
x=1 *y =1 
global = &amp;amp;x }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, x must be heap-allocated because it is still reachable from the variable global after f has returned, despite being declared as a local variable; we say x escapes from
f. Conversely, when g returns, the variable *y becomes unreachable and can be recycled. Since *y does not escape from g, it’s safe for the compiler to allocate *y on the stack, even though it was allocated with new. In any case, the notion of escaping is not something that you need to worry about in order to write correct code, though it’s good to keep in mind during performance optimization, since each variable that escapes requires an extra memory allocation.&lt;/p&gt;

&lt;p&gt;Garbage collection is a tremendous help in writing correct programs, but it does not relieve you of the burden of thinking about memory. You don’t need to explicitly allocate and free memory, but to write efficient programs you still need to be aware of the lifetime of variables. For example, keeping unnecessary pointers to short-lived objects within long-lived objects, especially global variables, will prevent the garbage collector from reclaiming the short-lived objects.&lt;/p&gt;

&lt;h2 id=&#34;assignments:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Assignments&lt;/h2&gt;

&lt;p&gt;The value held by a variable is updated by an assignment statement, which in its simplest form has a variable on the left of the = sign and an expression on the right.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x = 1 // named variable 
*p = true // indirect variable 
person.name = &amp;quot;bob&amp;quot; // struct field 
count[x] = count[x] * scale // array or slice or map 
element 
Each of the arithmetic and bitwise binary operators has a corresponding assignment operator allowing, for example, the last statement to be rewritten as 
count[x] *= scale 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which saves us from having to repeat (and re-evaluate) the expression for the variable.
Numeric variables can also be incremented and decremented by ++ and -­statements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;v := 1 
v++ // same as v=v+1; vbecomes 2 
v--// same as v=v-1; vbecomes 1again 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tuple-assignment:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Tuple Assignment&lt;/h3&gt;

&lt;p&gt;Another form of assignment, known as tuple assignment, allows several variables to be assigned at once. All of the right-hand side expressions are evaluated before any of the variables are updated, making this form most useful when some of the variables appear on both sides of the assignment, as happens, for example, when swapping the values of two variables:&lt;/p&gt;

&lt;p&gt;x, y = y, x a[i], a[j] = a[j], a[i]
or when computing the greatest common divisor (GCD) of two integers:
func gcd(x, y int) int {
for y != 0 {
x, y = y, x%y }
return x
}
or when computing the n-th Fibonacci number iteratively:
func fib(n int) int {
x, y := 0, 1
for i := 0; i &amp;lt; n; i++ {
x, y = y, x+y }
return x
}
Tuple assignment can also make a sequence of trivial assignments more compact,
i, j, k = 2, 3, 5
though as a matter of style, avoid the tuple form if the expressions are complex; a sequence of separate statements is easier to read.
Certain expressions, such as a call to a function with multiple results, produce several values. When such a call is used in an assignment statement, the left-hand side must have as many variables as the function has results.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f, err = os.Open(&amp;quot;foo.txt&amp;quot;) // function call returns two values 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Often, functions use these additional results to indicate some kind of error, either by returning an error as in the call to os.Open, or a bool, usually called ok. As we’ll see in later chapters, there are three operators that sometimes behave this way too. If a map lookup (§4.3), type assertion (§7.10), or channel receive (§8.4.2) appears in an assignment in which two results are expected, each produces an additional boolean result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;v, ok = m[key] // map lookup 
v, ok = x.(T) // type assertion 
v, ok = &amp;lt;-ch // channel receive 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with variable declarations, we can assign unwanted values to the blank identifier:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;_, err = io.Copy(dst, src) // discard byte count 
_, ok = x.(T) // check type but discard result 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;assignability:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Assignability&lt;/h3&gt;

&lt;p&gt;Assignment statements are an explicit form of assignment, but there are many places in a program where an assignment occurs implicitly: a function call implicitly assigns the argument values to the corresponding parameter variables; a return statement implicitly assigns the return operands to the corresponding result variables; and a literal expression for a composite type (§4.2) such as this slice:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;medals := []string{&amp;quot;gold&amp;quot;, &amp;quot;silver&amp;quot;, &amp;quot;bronze&amp;quot;} 
implicitly assigns each element, as if it had been written like this: 
medals[0] = &amp;quot;gold&amp;quot; 
medals[1] = &amp;quot;silver&amp;quot; 
medals[2] = &amp;quot;bronze&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The elements of maps and channels, though not ordinary variables, are also subject to similar implicit assignments.&lt;/p&gt;

&lt;p&gt;Anassignment, explicit or implicit, is always legal if the left-hand side (the variable) and the right-hand side (the value) have the same type. More generally, the assignment is legal only if the value is assignable to the type of the variable.&lt;/p&gt;

&lt;p&gt;The rule for assignability has cases for various types, so we’ll explain the relevant case as we introduce each new type. For the types we’ve discussed so far, the rules are simple: the types must exactly match, and nil may be assigned to any variable of interface or reference type. Constants (§3.6) have more flexible rules for assignability that avoid the need for most explicit conversions.
Whether two values may be compared with == and != is related to assignability: in any comparison, the first operand must be assignable to the type of the second operand, or vice versa. As with assignability, we’ll explain the relevant cases for comparability when we present each new type.&lt;/p&gt;

&lt;h2 id=&#34;type-declarations:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Type Declarations&lt;/h2&gt;

&lt;p&gt;The type of a variable or expression defines the characteristics of the values it may take on, such as their size (number of bits or number of elements, perhaps), how they are represented internally, the intrinsic operations that can be performed on them, and the methods associated with them.&lt;/p&gt;

&lt;p&gt;In any program there are variables that share the same representation but signify very different concepts. For instance, an int could be used to represent a loop index, a timestamp, a file descriptor, or a month; a float64 could represent a velocity in meters per second or a temperature in one of several scales; and a string could represent a password or the name of a color.&lt;/p&gt;

&lt;p&gt;A type declaration defines a new named type that has the same underlying type as an existing type. The named type provides a way to separate different and perhaps incompatible uses of the underlying type so that they can’t be mixed unintentionally.&lt;/p&gt;

&lt;p&gt;type name underlying-type&lt;/p&gt;

&lt;p&gt;Type declarations most often appear at package level, where the named type is visible throughout the package, and if the name is exported (it starts with an upper-case letter), it’s accessible from other packages as well.&lt;/p&gt;

&lt;p&gt;To illustrate type declarations, let’s turn the different temperature scales into different types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch2/tempconv0 
// Package tempconv performs Celsius and Fahrenheit 
temperature computations. 
package tempconv 
import &amp;quot;fmt&amp;quot; 
type Celsius float64 
type Fahrenheit float64 
const (
AbsoluteZeroC Celsius = -273.15 

FreezingC Celsius = 0 
BoilingC Celsius = 100 
) 

func CToF(c Celsius) Fahrenheit { return 
Fahrenheit(c*9/5 + 32) } 
func FToC(f Fahrenheit) Celsius { return Celsius((f ­
32) * 5 / 9) } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This package defines two types, Celsius and Fahrenheit, for the two units of temperature. Even though both have the same underlying type, float64, they are not the same type, so they cannot be compared or combined in arithmetic expressions. Distinguishing the types makes it possible to avoid errors like inadvertently combining temperatures in the two different scales; an explicit type conversion like Celsius(t) or Fahrenheit(t) is required to convert from a float64. Celsius(t) and Fahrenheit(t) are conversions, not function calls. They don’t change the value or representation in any way, but they make the change of meaning explicit. On the other hand, the functions CToF and FToC convert between the two scales; they do return different values.&lt;/p&gt;

&lt;p&gt;For every type T, there is a corresponding conversion operation T(x) that converts the value x to type T. A conversion from one type to another is allowed if both have the same underlying type, or if both are unnamed pointer types that point to variables of the same underlying type; these conversions change the type but not the representation of the value. If x is assignable to T, a conversion is permitted but is usually redundant,&lt;/p&gt;

&lt;p&gt;Conversions are also allowed between numeric types, and between string and some slice types, as we will see in the next chapter. These conversions may change the representation of the value. For instance, converting a floating-point number to an integer discards any fractional part, and converting a string to a []byte slice allocates a copy of the string data. In any case, a conversion never fails at run time.&lt;/p&gt;

&lt;p&gt;The underlying type of a named type determines its structure and representation, and also the set of intrinsic operations it supports, which are the same as if the underlying type had been used directly. That means that arithmetic operators work the same for Celsius and Fahrenheit as they do for float64, as you might expect.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Printf(&amp;quot;%g\n&amp;quot;, BoilingC-FreezingC) // &amp;quot;100&amp;quot; °C 
boilingF := CToF(BoilingC)
fmt.Printf(&amp;quot;%g\n&amp;quot;, boilingF-CToF(FreezingC)) // &amp;quot;180&amp;quot; 
°F 
fmt.Printf(&amp;quot;%g\n&amp;quot;, boilingF-FreezingC) // compile error: type mismatch 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comparison operators like == and &amp;lt; can also be used to compare a value of a named type to another of the same type, or to a value of the underlying type. But two values of different named types cannot be compared directly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var c Celsius 
var f Fahrenheit 
fmt.Println(c == 0) // &amp;quot;true&amp;quot; 
fmt.Println(f &amp;gt;= 0) // &amp;quot;true&amp;quot; 
fmt.Println(c == f) // compile error: type mismatch 
fmt.Println(c == Celsius(f)) // &amp;quot;true&amp;quot;! 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the last case carefully. In spite of its name, the type conversion Celsius(f)does not change the value of its argument, just its type. The test is true because c and f are both zero.&lt;/p&gt;

&lt;p&gt;A named type may provide notational convenience if it helps avoid writing out complex types over and over again. The advantage is small when the underlying type is simple like float64, but big for complicated types, as we will see when we discuss structs.&lt;/p&gt;

&lt;p&gt;Named types also make it possible to define new behaviors for values of the type. These behaviors are expressed as a set of functions associated with the type, called the type’s methods. We’ll look at methods in detail in Chapter 6 but will give a taste of the mechanism here.&lt;/p&gt;

&lt;p&gt;The declaration below, in which the Celsius parameter c appears before the function name, associates with the Celsius type a method named String that returns c’s numeric value followed by °C:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c Celsius) String() string { return fmt.Sprintf(&amp;quot;%g°C&amp;quot;, c) } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Many types declare a String method of this form because it controls how values of the type appear when printed as a string by the fmt package, as we will see in Section 7.1.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;c := FToC(212.0)
fmt.Println(c.String()) // &amp;quot;100°C&amp;quot; 
fmt.Printf(&amp;quot;%v\n&amp;quot;, c) // &amp;quot;100°C&amp;quot;; no need to call 

String explicitly
fmt.Printf(&amp;quot;%s\n&amp;quot;, c) // &amp;quot;100°C&amp;quot; 
fmt.Println(c) // &amp;quot;100°C&amp;quot; 
fmt.Printf(&amp;quot;%g\n&amp;quot;, c) // &amp;quot;100&amp;quot;; does not call String 
fmt.Println(float64(c)) // &amp;quot;100&amp;quot;; does not call String 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;packages-and-files:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Packages and Files&lt;/h2&gt;

&lt;p&gt;Packages in Go serve the same purposes as libraries or modules in other languages, supporting modularity, encapsulation, separate compilation, and reuse. The source code for a package resides in one or more .go files, usually in a directory whose name ends with the import path; for instance, the files of the // gopl.io/ch1/helloworld package are stored in directory $GOPATH/src/// gopl.io/ch1/helloworld.&lt;/p&gt;

&lt;p&gt;Each package serves as a separate name space for its declarations. Within the image package, for example, the identifier Decode refers to a different function than does the same identifier in the unicode/utf16 package. To refer to a function from outside its package, we must qualify the identifier to make explicit whether we mean image.Decode or utf16.Decode.
Packages also let us hide information by controlling which names are visible outside the package, or exported. In Go, a simple rule governs which identifiers are exported and which are not: exported identifiers start with an upper-case letter.&lt;/p&gt;

&lt;p&gt;To illustrate the basics, suppose that our temperature conversion software has become popular and we want to make it available to the Go community as a new package. How do we do that?&lt;/p&gt;

&lt;p&gt;Let’s create a package called // gopl.io/ch2/tempconv, a variation on the previous example. (Here we’ve made an exception to our usual rule of numbering examples in sequence, so that the package path can be more realistic.) The package itself is stored in two files to show how declarations in separate files of a package are accessed; in real life, a tiny package like this would need only one file.&lt;/p&gt;

&lt;p&gt;We have put the declarations of the types, their constants, and their methods in tempconv.go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch2/tempconv 
// Package tempconv performs Celsius and Fahrenheit 
conversions. 
package tempconv import &amp;quot;fmt&amp;quot; 
type Celsius float64 
type Fahrenheit float64 

const (
AbsoluteZeroC Celsius = -273.15 
FreezingC Celsius = 0 
BoilingC Celsius = 100 

) 
func (c Celsius) String() string { return 
fmt.Sprintf(&amp;quot;%g°C&amp;quot;, c) } 
func (f Fahrenheit) String() string { return 
fmt.Sprintf(&amp;quot;%g°F&amp;quot;, f) } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the conversion functions in conv.go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package tempconv 
// CToF converts a Celsius temperature to Fahrenheit. func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) } 
// FToC converts a Fahrenheit temperature to Celsius. func FToC(f Fahrenheit) Celsius { return Celsius((f ­
32) * 5 / 9) } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each file starts with a package declaration that defines the package name. When the package is imported, its members are referred to as tempconv.CToF and so on. Package-level names like the types and constants declared in one file of a package are visible to all the other files of the package, as if the source code were all in a single file. Note that tempconv.go imports fmt, but conv.go does not, because it does not use anything from fmt.&lt;/p&gt;

&lt;p&gt;Because the package-level const names begin with upper-case letters, they too are accessible with qualified names like tempconv.AbsoluteZeroC:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Printf(&amp;quot;Brrrr! %v\n&amp;quot;, tempconv.AbsoluteZeroC) // &amp;quot;Brrrr! -273.15°C&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To convert a Celsius temperature to Fahrenheit in a package that imports // gopl.io/ch2/tempconv, we can write the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(tempconv.CToF(tempconv.BoilingC)) // &amp;quot;212°F&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The doc comment (§10.7.4) immediately preceding the package declaration documents the package as a whole. Conventionally, it should start with a summary sentence in the style illustrated. Only one file in each package should have a package doc comment. Extensive doc comments are often placed in a file of their own, conventionally called doc.go.&lt;/p&gt;

&lt;p&gt;Exercise 2.1: Add types, constants, and functions to tempconv for processing temperatures in the Kelvin scale, where zero Kelvin is -273.15°C and a difference of 1K has the same magnitude as 1°C.&lt;/p&gt;

&lt;h3 id=&#34;imports:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Imports&lt;/h3&gt;

&lt;p&gt;Within a Go program, every package is identified by a unique string called its import path. These are the strings that appear in an import declaration like &amp;ldquo;// gopl.io/ch2/tempconv&amp;rdquo;. The language specification doesn’t define where these strings come from or what they mean; it’s up to the tools to interpret them. When using the go tool (Chapter 10), an import path denotes a directory containing one or more Go source files that together make up the package.&lt;/p&gt;

&lt;p&gt;In addition to its import path, each package has a package name, which is the short (and not necessarily unique) name that appears in its package declaration. By convention, a package’s name matches the last segment of its import path, making it easy to predict that the package name of // gopl.io/ch2/tempconv is tempconv.&lt;/p&gt;

&lt;p&gt;To use // gopl.io/ch2/tempconv, we must import it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch2/cf 
// Cf converts its numeric argument to Celsius and Fahrenheit. 
package main 

import (
&amp;quot;fmt&amp;quot; 
&amp;quot;os&amp;quot; 
&amp;quot;strconv&amp;quot; 

&amp;quot;// gopl.io/ch2/tempconv&amp;quot; 
) 

func main() {
for     _, arg := range os.Args[1:] { t, err := strconv.ParseFloat(arg, 64) if err != nil {
fmt.Fprintf(os.Stderr, &amp;quot;cf: %v\n&amp;quot;, err) 
os.Exit(1) }f := tempconv.Fahrenheit(t) c := tempconv.Celsius(t)fmt.Printf(&amp;quot;%s = %s, %s = %s\n&amp;quot;, 
f, tempconv.FToC(f), c, tempconv.CToF(c)) }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The import declaration binds a short name to the imported package that may be used to refer to its contents throughout the file. The import above lets us refer to names within // gopl.io/ch2/tempconv by using a qualified identifier like tempconv.CToF. By default, the short name is the package name—tempconv in this case—but an import declaration may specify an alternative name to avoid a conflict (§10.3).&lt;/p&gt;

&lt;p&gt;The cf program converts a single numeric command-line argument to its value in both Celsius and Fahrenheit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go build gopl.io/ch2/cf 
$ ./cf 32 
32°F = 0°C, 32°C = 89.6°F 

$ ./cf 212 
212°F = 100°C, 212°C = 413.6°F 
$ ./cf -40 
-40°F = -40°C, -40°C = -40°F 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is an error to import a package and then not refer to it. This check helps eliminate dependencies that become unnecessary as the code evolves, although it can be a nuisance during debugging, since commenting out a line of code like log.Print(&amp;ldquo;got here!&amp;rdquo;) may remove the sole reference to the package name log, causing the compiler to emit an error. In this situation, you need to comment out or delete the unnecessary import.&lt;/p&gt;

&lt;p&gt;Better still, use the golang.org/x/tools/cmd/goimports tool, which automatically inserts and removes packages from the import declaration as necessary; most editors can be configured to run goimports each time you save a file. Like the gofmt tool, it also pretty-prints Go source files in the canonical format.&lt;/p&gt;

&lt;p&gt;Exercise 2.2: Write a general-purpose unit-conversion program analogous to cf that reads numbers from its command-line arguments or from the standard input if there are no arguments, and converts each number into units like temperature in Celsius and Fahrenheit, length in feet and meters, weight in pounds and kilograms, and the like.&lt;/p&gt;

&lt;h3 id=&#34;package-initialization:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Package Initialization&lt;/h3&gt;

&lt;p&gt;Package initialization begins by initializing package-level variables in the order in which they are declared, except that dependencies are resolved first:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var a = b + c // a initialized third, to 3 
var b = f() // b initialized second, to 2, by 
calling f 
var c = 1 // c initialized first, to 1 
func f() int { return c + 1 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the package has multiple .go files, they are initialized in the order in which the files are given to the compiler; the go tool sorts .go files by name before invoking the compiler.&lt;/p&gt;

&lt;p&gt;Each variable declared at package level starts life with the value of its initializer expression, if any, but for some variables, like tables of data, an initializer expression may not be the simplest way to set its initial value. In that case, the init function mechanism may be simpler. Any file may contain any number of functions whose declaration is just &lt;code&gt;func init() { /* ... */ }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Such init functions can’t be called or referenced, but otherwise they are normal functions. Within each file, init functions are automatically executed when the program starts, in the order in which they are declared.&lt;/p&gt;

&lt;p&gt;One package is initialized at a time, in the order of imports in the program, dependencies first, so a package p importing q can be sure that q is fully initialized before p’s initialization begins. Initialization proceeds from the bottom up; the main package is the last to be initialized. In this manner, all packages are fully initialized before the application’s main function begins.&lt;/p&gt;

&lt;p&gt;The package below defines a function PopCount that returns the number of set bits, that is, bits whose value is 1, in a uint64 value, which is called its population count. It uses an init function to precompute a table of results, pc, for each possible 8-bit value so that the PopCount function needn’t take 64 steps but can just return the sum of eight table lookups. (This is definitely not the fastest algorithm for counting bits, but it’s convenient for illustrating init functions, and for showing how to precompute a table of values, which is often a useful programming technique.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch2/popcount 
package popcount 
// pc[i] is the population count of i. 
var pc [256]byte 
func init() {
for i := range pc {
pc[i] = pc[i/2] + byte(i&amp;amp;1) 
}
} 

// PopCount returns the population count (number of 
set bits) of x. 
func PopCount(x uint64) int {

return int(pc[byte(x&amp;gt;&amp;gt;(0*8))] + 
pc[byte(x&amp;gt;&amp;gt;(1*8))] + 
pc[byte(x&amp;gt;&amp;gt;(2*8))] + 
pc[byte(x&amp;gt;&amp;gt;(3*8))] + 
pc[byte(x&amp;gt;&amp;gt;(4*8))] + 
pc[byte(x&amp;gt;&amp;gt;(5*8))] + 
pc[byte(x&amp;gt;&amp;gt;(6*8))] + 
pc[byte(x&amp;gt;&amp;gt;(7*8))]) 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the range loop in init uses only the index; the value is unnecessary and thus need not be included. The loop could also have been written as
&lt;code&gt;for i, _ := range pc {&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We’ll see other uses of init functions in the next section and in Section 10.5.&lt;/p&gt;

&lt;p&gt;Exercise 2.3: Rewrite PopCount to use a loop instead of a single expression. Compare the performance of the two versions. (Section 11.4 shows how to compare the performance of different implementations systematically.)&lt;/p&gt;

&lt;p&gt;Exercise 2.4: Write a version of PopCount that counts bits by shifting its argument through 64 bit positions, testing the rightmost bit each time. Compare its performance to the table-lookup version.&lt;/p&gt;

&lt;p&gt;Exercise 2.5: The expression x&amp;amp;(x-1) clears the rightmost non-zero bit of x. Write a version of PopCount that counts bits by using this fact, and assess its performance.&lt;/p&gt;

&lt;h2 id=&#34;scope:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Scope&lt;/h2&gt;

&lt;p&gt;A declaration associates a name with a program entity, such as a function or a variable. The scope of a declaration is the part of the source code where a use of the declared name refers to that declaration.&lt;/p&gt;

&lt;p&gt;Don’t confuse scope with lifetime. The scope of a declaration is a region of the program text; it is a compile-time property. The lifetime of a variable is the range of time during execution when the variable can be referred to by other parts of the program; it is a run-time property.&lt;/p&gt;

&lt;p&gt;A syntactic block is a sequence of statements enclosed in braces like those that surround the body of a function or loop. A name declared inside a syntactic block is not visible outside that block. The block encloses its declarations and determines their scope. We can generalize this notion of blocks to include other groupings of declarations that are not explicitly surrounded by braces in the source code; we’ll call them all lexical blocks.&lt;/p&gt;

&lt;p&gt;There is a lexical block for the entire source code, called the universe block; for each package; for each file; for each for, if, and switch statement; for each case in a switch or select statement; and, of course, for each explicit syntactic block.&lt;/p&gt;

&lt;p&gt;A declaration’s lexical block determines its scope, which may be large or small. The declarations of built-in types, functions, and constants like int, len, and true are in the universe block and can be referred to throughout the entire program.&lt;/p&gt;

&lt;p&gt;Declarations outside any function, that is, at package level, can be referred to from any file in the same package. Imported packages, such as fmt in the tempconv example, are declared at the file level, so they can be referred to from the same file, but not from another file in the same package without another import. Many declarations, like that of the variable c in the tempconv.CToF function, are local, so they can be referred to only from within the same function or perhaps just a part of it.&lt;/p&gt;

&lt;p&gt;The scope of a control-flow label, as used by break, continue, and goto statements, is the entire enclosing function.&lt;/p&gt;

&lt;p&gt;A program may contain multiple declarations of the same name so long as each declaration is in a different lexical block. For example, you can declare a local variable with the same name as a package-level variable. Or, as shown in Section 2.3.3, you can declare a function parameter called new, even though a function of this name is predeclared in the universe block. Don’t overdo it, though; the larger the scope of the redeclaration, the more likely you are to surprise the reader.&lt;/p&gt;

&lt;p&gt;When the compiler encounters a reference to a name, it looks for a declaration, starting with the innermost enclosing lexical block and working up to the universe block. If the compiler finds no declaration, it reports an “undeclared name” error. If a name is declared in both an outer block and an inner block, the inner declaration will be found first. In that case, the inner declaration is said to shadow or hide the outer one, making it inaccessible:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func f() {} 
var g = &amp;quot;g&amp;quot; 
func main() { 
f := &amp;quot;f&amp;quot; 
fmt.Println(f) // &amp;quot;f&amp;quot;; local var f shadows 
package-level func f 
fmt.Println(g) // &amp;quot;g&amp;quot;; package-level var 
fmt.Println(h) // compile error: undefined: h } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Within a function, lexical blocks may be nested to arbitrary depth, so one local declaration can shadow another. Most blocks are created by control-flow constructs like if statements and for loops. The program below has three different variables called x because each declaration appears in a different lexical block. (This example illustrates scope rules, not good style!)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() { 
x := &amp;quot;hello!&amp;quot; 
for i := 0; i &amp;lt; len(x); i++ {
x := x[i] 
if x != &#39;!&#39; {
x := x + &#39;A&#39; -&#39;a&#39; 
fmt.Printf(&amp;quot;%c&amp;quot;, x) // &amp;quot;HELLO&amp;quot; (one letter per iteration)} 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The expressions x[i] and x+&amp;lsquo;A&amp;rsquo; -&amp;lsquo;a&amp;rsquo; each refer to a declaration of x from an outer block; we’ll explain that in a moment. (Note that the latter expression is not equivalent to unicode.ToUpper.)&lt;/p&gt;

&lt;p&gt;As mentioned above, not all lexical blocks correspond to explicit brace-delimited sequences of statements; some are merely implied. The for loop above creates two lexical blocks: the explicit block for the loop body, and an implicit block that additionally encloses the variables declared by the initialization clause, such as i. The scope of a variable declared in the implicit block is the condition, post-statement (i++), and body of the for statement.&lt;/p&gt;

&lt;p&gt;The example below also has three variables named x, each declared in a different block—one in the function body, one in the for statement’s block, and one in the loop body—but only two of the blocks are explicit:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() { 
x := &amp;quot;hello&amp;quot; 
for _, x := range x {

x := x + &#39;A&#39; -&#39;a&#39; fmt.Printf(&amp;quot;%c&amp;quot;, x) // &amp;quot;HELLO&amp;quot; (one letter per iteration)}} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like for loops, if statements and switch statements also create implicit blocks in addition to their body blocks. The code in the following if-else chain shows the scope of x and y:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if x := f(); x == 0 {
fmt.Println(x) 
} else if y := g(x); x == y { 
fmt.Println(x, y) 
} else {
fmt.Println(x, y) 
} 

fmt.Println(x, y) // compile error: x and y are not visible here 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second if statement is nested within the first, so variables declared within the first statement’s initializer are visible within the second. Similar rules apply to each case of a switch statement: there is a block for the condition and a block for each case body.
At the package level, the order in which declarations appear has no effect on their scope, so a declaration may refer to itself or to another that follows it, letting us declare recursive or mutually recursive types and functions. The compiler will report an error if a constant or variable declaration refers to itself, however.&lt;/p&gt;

&lt;p&gt;In this program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if f, err := os.Open(fname); err != nil { // compile error: unused: f 
return err 
}
f.ReadByte() // compile error: undefined f 
f.Close() // compile error: undefined f 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the scope of f is just the if statement, so f is not accessible to the statements that follow, resulting in compiler errors. Depending on the compiler, you may get an additional error reporting that the local variable f was never used.
Thus it is often necessary to declare f before the condition so that it is accessible after:
f, err := os.Open(fname)
if err != nil {&lt;/p&gt;

&lt;p&gt;return err
}
f.ReadByte()
f.Close()&lt;/p&gt;

&lt;p&gt;You may be tempted to avoid declaring f and err in the outer block by moving the calls to ReadByte and Close inside an else block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if f, err := os.Open(fname); err != nil { return err 
} else {// f and err are visible here too 
f.ReadByte()
f.Close() 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but normal practice in Go is to deal with the error in the if block and then return, so that the successful execution path is not indented.
Short variable declarations demand an awareness of scope. Consider the program below, which starts by obtaining its current working directory and saving it in a package-level variable. This could be done by calling os.Getwd in function main, but it might be better to separate this concern from the primary logic, especially if failing to get the directory is a fatal error. The function log.Fatalf prints a message and calls os.Exit(1).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var cwd string 
func init() {cwd, err := os.Getwd() // compile error: unused: cwd 
if err != nil {log.Fatalf(&amp;quot;os.Getwd failed: %v&amp;quot;, err) 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since neither cwd nor err is already declared in the init function’s block, the := statement declares both of them as local variables. The inner declaration of cwd makes the outer one inaccessible, so the statement does not update the package-level cwd variable as intended.
Current Go compilers detect that the local cwd variable is never used and report this as an error, but they are not strictly required to perform this check. Furthermore, a minor change, such as the addition of a logging statement that refers to the local cwd would defeat the check.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var cwd string 
func init() {
cwd, err := os.Getwd() // NOTE: wrong! 
if err != nil {

log.Fatalf(&amp;quot;os.Getwd failed: %v&amp;quot;, err) }log.Printf(&amp;quot;Working directory = %s&amp;quot;, cwd) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The global cwd variable remains uninitialized, and the apparently normal log output obfuscates the bug.&lt;/p&gt;

&lt;p&gt;There are a number of ways to deal with this potential problem. The most direct is to avoid := by declaring err in a separate var declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var cwd string 
func init() {
var err error 
cwd, err = os.Getwd() 
if err != nil {

log.Fatalf(&amp;quot;os.Getwd failed: %v&amp;quot;, err) 
}
} 


We’ve now seen how packages, files, declarations, and statements express the structure of programs. In the next two chapters, we’ll look at the structure of data. 

3. Basic Data Types 

It’s all bits at the bottom, of course, but computers operate fundamentally on fixed-size numbers called words, which are interpreted as integers, floating-point numbers, bit sets, or memory addresses, then combined into larger aggregates that represent packets, pixels, portfolios, poetry, and everything else. Go offers a variety of ways to organize data, with a spectrum of data types that at one end match the features of the hardware and at the other end provide what programmers need to conveniently represent complicated data structures. 

Go’s types fall into four categories: basic types, aggregate types, reference types, and interface types. Basic types, the topic of this chapter, include numbers, strings, and booleans. Aggregate types—arrays (§4.1) and structs (§4.4)—form more complicated data types by combining values of several simpler ones. Reference types are a diverse group that includes pointers (§2.3.2), slices (§4.2), maps (§4.3), functions (Chapter 5), and channels (Chapter 8), but what they have in common is that they all refer to program variables or state indirectly, so that the effect of an operation applied to one reference is observed by all copies of that reference. 
Finally, we’ll talk about interface types in Chapter 7. 


## Integers 

Go’s numeric data types include several sizes of integers, floating-point numbers, and complex numbers. Each numeric type determines the size and signedness of its values. Let’s begin with integers. 

Goprovides both signed and unsigned integer arithmetic. There are four distinct sizes of signed integers—8, 16, 32, and 64 bits—represented by the types int8, int16, int32, and int64, and corresponding unsigned versions uint8, uint16, uint32, and uint64. 


There are also two types called just int and uint that are the natural or most efficient size for signed and unsigned integers on a particular platform; int is by far the most widely used numeric type. Both these types have the same size, either 32 or 64 bits, but one must not make assumptions about which; different compilers may make different choices even on identical hardware. 


The type rune is a synonym for int32 and conventionally indicates that a value is a Unicode code point. The two names may be used interchangeably. Similarly, the type byte is a synonym for uint8, and emphasizes that the value is a piece of raw data rather than a small numeric quantity. 

Finally, there is an unsigned integer type uintptr, whose width is not specified but is sufficient to hold all the bits of a pointer value. The uintptr type is used only for low-level programming, such as at the boundary of a Go program with a C library or an operating system. We’ll see examples of this when we deal with the unsafe package in Chapter 13. 

Regardless of their size, int, uint, and uintptr are different types from their explicitly sized siblings. Thus int is not the same type as int32, even if the natural size of integers is 32 bits, and an explicit conversion is required to use an int value where an int32 is needed, and vice versa. 
Signed numbers are represented in 2’s-complement form, in which the high-order bit is reserved for the sign of the number and the range of values of an n-bit number is 
from -2n-1 to 2n-1-1. Unsigned integers use the full range of bits for non-negative values and thus have the range 0 to 2n-1. For instance, the range of int8 is -128 to 127, whereas the range of uint8 is 0 to 255. 
Go’s binary operators for arithmetic, logic, and comparison are listed here in order of decreasing precedence: 

```go
*/%&amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp;&amp;amp;^ 
+-|^ 
== != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;= 
&amp;amp;&amp;amp; 
|| 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are only five levels of precedence for binary operators. Operators at the same level associate to the left, so parentheses may be required for clarity, or to make the operators evaluate in the intended order in an expression like mask &amp;amp; (1 &amp;lt;&amp;lt; 28) .&lt;/p&gt;

&lt;p&gt;Each operator in the first two lines of the table above, for instance +, has a corresponding assignment operator like += that may be used to abbreviate an assignment statement.&lt;/p&gt;

&lt;p&gt;The integer arithmetic operators +, -, *, and / may be applied to integer, floating-point, and complex numbers, but the remainder operator % applies only to integers. The behavior of % for negative numbers varies across programming languages. In Go, the sign of the remainder is always the same as the sign of the dividend, so -5%3 and -5%-3 are both -2. The behavior of / depends on whether its operands are integers, so 5.0/4.0 is 1.25, but &lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; is 1 because integer division truncates the result toward zero.&lt;/p&gt;

&lt;p&gt;If the result of an arithmetic operation, whether signed or unsigned, has more bits than can be represented in the result type, it is said to overflow. The high-order bits that do not fit are silently discarded. If the original number is a signed type, the result could be negative if the leftmost bit is a 1, as in the int8 example here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var u uint8 = 255 
fmt.Println(u, u+1, u*u) // &amp;quot;255 0 1&amp;quot; 
var i int8 = 127 
fmt.Println(i, i+1, i*i) // &amp;quot;127 -128 1&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two integers of the same type may be compared using the binary comparison operators below; the type of a comparison expression is a boolean.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;== equal to 
!= not equal to 
&amp;lt; less than 
&amp;lt;= less than or equal to 
&amp;gt; greater than 
&amp;gt;= greater than or equal to 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, all values of basic type—booleans, numbers, and strings—are comparable, meaning that two values of the same type may be compared using the == and != operators. Furthermore, integers, floating-point numbers, and strings are ordered by the comparison operators. The values of many other types are not comparable, and no other types are ordered. As we encounter each type, we’ll present the rules governing the comparability of its values.&lt;/p&gt;

&lt;p&gt;There are also unary addition and subtraction operators:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ unary positive (no effect) 
-unary negation 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For integers, +x is a shorthand for 0+x and -x is a shorthand for 0-x; for floating-point and complex numbers, +x is just x and -x is the negation of x.&lt;/p&gt;

&lt;p&gt;Goalso provides the following bitwise binary operators, the first four of which treat their operands as bit patterns with no concept of arithmetic carry or sign:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp; bitwise AND 
| bitwise OR 
^ bitwise XOR 
&amp;amp;^ bit clear (AND NOT) 
&amp;lt;&amp;lt; left shift 
&amp;gt;&amp;gt; right shift 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The operator ^ is bitwise exclusive OR (XOR) when used as a binary operator, but when used as a unary prefix operator it is bitwise negation or complement; that is, it returns a value with each bit in its operand inverted. The &amp;amp;^ operator is bit clear (AND NOT): in the expression z = x &amp;amp;^ y , each bit of z is 0 if the corresponding bit of y is 1; otherwise it equals the corresponding bit of x.&lt;/p&gt;

&lt;p&gt;The code below shows how bitwise operations can be used to interpret a uint8 value as a compact and efficient set of 8 independent bits. It uses Printf’s %b verb to print a number’s binary digits; 08 modifies %b (an adverb!) to pad the result with zeros to exactly 8 digits.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x uint8 = 1&amp;lt;&amp;lt;1 | 1&amp;lt;&amp;lt;5 
var y uint8 = 1&amp;lt;&amp;lt;1 | 1&amp;lt;&amp;lt;2 

fmt.Printf(&amp;quot;%08b\n&amp;quot;, x) // &amp;quot;00100010&amp;quot;, the set {1, 
5}
fmt.Printf(&amp;quot;%08b\n&amp;quot;, y) // &amp;quot;00000110&amp;quot;, the set {1, 
2} 

fmt.Printf(&amp;quot;%08b\n&amp;quot;, x&amp;amp;y) // &amp;quot;00000010&amp;quot;, the 
intersection {1}
fmt.Printf(&amp;quot;%08b\n&amp;quot;, x|y) // &amp;quot;00100110&amp;quot;, the union 
{1, 2, 5}
fmt.Printf(&amp;quot;%08b\n&amp;quot;, x^y) // &amp;quot;00100100&amp;quot;, the 
symmetric difference {2, 5} 
fmt.Printf(&amp;quot;%08b\n&amp;quot;, x&amp;amp;^y) // &amp;quot;00100000&amp;quot;, the 
difference {5} 

for i := uint(0); i &amp;lt; 8; i++ {
if x&amp;amp;(1&amp;lt;&amp;lt;i) != 0 { // membership test 
fmt.Println(i) // &amp;quot;1&amp;quot;, &amp;quot;5&amp;quot; 
}
} 

fmt.Printf(&amp;quot;%08b\n&amp;quot;, x&amp;lt;&amp;lt;1) // &amp;quot;01000100&amp;quot;, the set {2, 
6}
fmt.Printf(&amp;quot;%08b\n&amp;quot;, x&amp;gt;&amp;gt;1) // &amp;quot;00010001&amp;quot;, the set {0, 
4} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Section 6.5 shows an implementation of integer sets that can be much bigger than a byte.)&lt;/p&gt;

&lt;p&gt;In the shift operations x&amp;lt;&lt;n and x&gt;&amp;gt;n, the n operand determines the number of bit positions to shift and must be unsigned; the x operand may be unsigned or signed. Arithmetically, a left shift x&amp;lt;&lt;n is equivalent to multiplication by 2n and a right shift x&gt;&amp;gt;n is equivalent to the floor of division by 2n .&lt;/p&gt;

&lt;p&gt;Left shifts fill the vacated bits with zeros, as do right shifts of unsigned numbers, but right shifts of signed numbers fill the vacated bits with copies of the sign bit. For this reason, it is important to use unsigned arithmetic when you’re treating an integer as a bit pattern.&lt;/p&gt;

&lt;p&gt;Although Go provides unsigned numbers and arithmetic, we tend to use the signed int form even for quantities that can’t be negative, such as the length of an array, though uint might seem a more obvious choice. Indeed, the built-in len function returns a signed int, as in this loop which announces prize medals in reverse order:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;medals := []string{&amp;quot;gold&amp;quot;, &amp;quot;silver&amp;quot;, &amp;quot;bronze&amp;quot;} 
for i := len(medals) -1; i &amp;gt;= 0; i--{
fmt.Println(medals[i]) // &amp;quot;bronze&amp;quot;, &amp;quot;silver&amp;quot;, 
&amp;quot;gold&amp;quot;
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The alternative would be calamitous. If len returned an unsigned number, then i too would be a uint, and the condition i &amp;gt;= 0 would always be true by definition. After the third iteration, in which i == 0 , the i&amp;ndash;statement would cause i to
become not -1, but the maximum uint value (for example, 264-1), and the evaluation of medals[i] would fail at run time, or panic (§5.9), by attempting to access an element outside the bounds of the slice.&lt;/p&gt;

&lt;p&gt;For this reason, unsigned numbers tend to be used only when their bitwise operators or peculiar arithmetic operators are required, as when implementing bit sets, parsing binary file formats, or for hashing and cryptography. They are typically not used for merely non-negative quantities.&lt;/p&gt;

&lt;p&gt;In general, an explicit conversion is required to convert a value from one type to another, and binary operators for arithmetic and logic (except shifts) must have operands of the same type. Although this occasionally results in longer expressions, it also eliminates a whole class of problems and makes programs easier to understand.&lt;/p&gt;

&lt;p&gt;As an example familiar from other contexts, consider this sequence:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var apples int32 = 1 
var oranges int16 = 2 
var compote int = apples + oranges // compile error 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Attempting to compile these three declarations produces an error message:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;invalid operation: apples + oranges (mismatched types 
int32 and int16) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This type mismatch can be fixed in several ways, most directly by converting everything to a common type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var compote = int(apples) + int(oranges) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As described in Section 2.5, for every type T, the conversion operation T(x) converts the value x to type T if the conversion is allowed. Many integer-to-integer conversions do not entail any change in value; they just tell the compiler how to interpret a value. But a conversion that narrows a big integer into a smaller one, or a conversion from integer to floating-point or vice versa, may change the value or lose precision:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f := 3.141 // a float64 
i := int(f)
fmt.Println(f, i) // &amp;quot;3.141 3&amp;quot; 
f = 1.99 
fmt.Println(int(f)) // &amp;quot;1&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Float to integer conversion discards any fractional part, truncating toward zero. You should avoid conversions in which the operand is out of range for the target type, because the behavior depends on the implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f := 1e100 // a float64 
i := int(f) // result is implementation-dependent 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Integer literals of any size and type can be written as ordinary decimal numbers, or as octal numbers if they begin with 0, as in 0666, or as hexadecimal if they begin with 0x or 0X, as in 0xdeadbeef. Hex digits may be upper or lower case. Nowadays octal numbers seem to be used for exactly one purpose—file permissions on POSIX systems—but hexadecimal numbers are widely used to emphasize the bit pattern of a number over its numeric value.&lt;/p&gt;

&lt;p&gt;When printing numbers using the fmt package, we can control the radix and format with the %d, %o, and %x verbs, as shown in this example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;o := 0666 
fmt.Printf(&amp;quot;%d %[1]o %#[1]o\n&amp;quot;, o) // &amp;quot;438 666 0666&amp;quot; 
x := int64(0xdeadbeef)
fmt.Printf(&amp;quot;%d %[1]x %#[1]x %#[1]X\n&amp;quot;, x) 
// Output: 
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the use of two fmt tricks. Usually a Printf format string containing multiple % verbs would require the same number of extra operands, but the [1] “adverbs” after % tell Printf to use the first operand over and over again. Second, the # adverb for %o or %x or %X tells Printf to emit a 0 or 0x or 0X prefix respectively.
Rune literals are written as a character within single quotes. The simplest example is an ASCII character like &amp;lsquo;a&amp;rsquo;, but it’s possible to write any Unicode code point either directly or with numeric escapes, as we will see shortly.
Runes are printed with %c, or with %q if quoting is desired:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ascii := &#39;a&#39; 
unicode := &#39; 
&#39; 
newline := &#39;\n&#39; 
fmt.Printf(&amp;quot;%d %[1]c %[1]q\n&amp;quot;, ascii) // &amp;quot;97 a &#39;a&#39;&amp;quot; 
fmt.Printf(&amp;quot;%d %[1]c %[1]q\n&amp;quot;, unicode) // &amp;quot;22269 
&#39; 
&#39;&amp;quot; 
fmt.Printf(&amp;quot;%d %[1]q\n&amp;quot;, newline) // &amp;quot;10 &#39;\n&#39;&amp;quot; 3.2 Floating-Point Numbers 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go provides two sizes of floating-point numbers, float32 and float64. Their arithmetic properties are governed by the IEEE 754 standard implemented by all modern CPUs.&lt;/p&gt;

&lt;p&gt;Values of these numeric types range from tiny to huge. The limits of floating-point values can be found in the math package. The constant math.MaxFloat32, the largest float32, is about 3.4e38, and math.MaxFloat64 is about 1.8e308. The smallest positive values are near 1.4e-45 and 4.9e-324, respectively.&lt;/p&gt;

&lt;p&gt;A float32 provides approximately six decimal digits of precision, whereas a float64 provides about 15 digits; float64 should be preferred for most purposes because float32 computations accumulate error rapidly unless one is quite careful, and the smallest positive integer that cannot be exactly represented as a float32 is not large:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var f float32 = 16777216 // 1 &amp;lt;&amp;lt; 24 
fmt.Println(f == f+1) // &amp;quot;true&amp;quot;! 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Floating-point numbers can be written literally using decimals, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const e = 2.71828 // (approximately) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Digits may be omitted before the decimal point (.707) or after it (1.). Very small or very large numbers are better written in scientific notation, with the letter e or E preceding the decimal exponent:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const Avogadro = 6.02214129e23 
const Planck = 6.62606957e-34 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Floating-point values are conveniently printed with Printf’s %g verb, which chooses the most compact representation that has adequate precision, but for tables of data, the %e (exponent) or %f (no exponent) forms may be more appropriate. All three verbs allow field width and numeric precision to be controlled.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for x := 0; x &amp;lt; 8; x++ {
fmt.Printf(&amp;quot;x = %d ex = %8.3f\n&amp;quot;, x, 
math.Exp(float64(x)))
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thee code above prints the powers of e with three decimal digits of precision, aligned in an eight-character field:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x=0 ex= 1.000 
x=1 ex= 2.718 
x=2 ex= 7.389 
x = 3 ex = 20.086 
x = 4 ex = 54.598 
x = 5 ex = 148.413 
x = 6 ex = 403.429 
x = 7 ex = 1096.633 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to a large collection of the usual mathematical functions, the math package has functions for creating and detecting the special values defined by IEEE
754: the positive and negative infinities, which represent numbers of excessive magnitude and the result of division by zero; and NaN (“not a number”), the result of such mathematically dubious operations as 0/0 or Sqrt(-1).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var z float64 fmt.Println(z, -z, 1/z, -1/z, z/z) // &amp;quot;0 -0 +Inf -Inf NaN&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function math.IsNaN tests whether its argument is a not-a-number value, and math.NaN returns such a value. It’s tempting to use NaN as a sentinel value in a numeric computation, but testing whether a specific computational result is equal to NaN is fraught with peril because any comparison with NaN always yields false:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;nan := math.NaN()
fmt.Println(nan == nan, nan &amp;lt; nan, nan &amp;gt; nan) // 

&amp;quot;false false false&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If a function that returns a floating-point result might fail, it’s better to report the failure separately, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func compute() (value float64, ok bool) { 
// ... 
if failed {
return 0, false }
return result, true } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next program illustrates floating-point graphics computation. It plots a function of two variables z = f(x, y) as a wire mesh 3-D surface, using Scalable Vector Graphics (SVG), a standard XML notation for line drawings. Figure 3.1 shows an example of its output for the function sin&amp;reg;/r, where r is sqrt(x*x+y*y).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch3/surface 
// Surface computes an SVG rendering of a 3-D surface function. package main 
import (
&amp;quot;fmt&amp;quot; 
&amp;quot;math&amp;quot; 

) 
const (width, height = 600, 320 // canvas size in pixelscells = 100 // number of grid cells xyrange = 30.0 // axis ranges (-xyrange..+xyrange)xyscale = width / 2 / xyrange // pixels per x or y unit zscale = height * 0.4 // pixels per z unit 
angle = math.Pi / 6 // angle of x, y axes (=30°) ) 
var sin30, cos30 = math.Sin(angle), math.Cos(angle) // sin(30°), cos(30°) 
func main() {
fmt.Printf(&amp;quot;&amp;lt;svg
xmlns=&#39;http://www.w3.org/2000/svg&#39; &amp;quot;+ 
&amp;quot;style=&#39;stroke: grey; fill: white; stroke-
width: 0.7&#39; &amp;quot;+ 
&amp;quot;width=&#39;%d&#39; height=&#39;%d&#39;&amp;gt;&amp;quot;, width, height) 
for i := 0; i &amp;lt; cells; i++ {

for     j := 0; j &amp;lt; cells; j++ {ax, ay := corner(i+1, j) bx, by := corner(i, j) cx, cy := corner(i, j+1) 
dx, dy := corner(i+1, j+1) fmt.Printf(&amp;quot;&amp;lt;polygon points=&#39;%g,%g %g,%g %g,%g %g,%g&#39;/&amp;gt;\n&amp;quot;,ax, ay, bx, by, cx, cy, dx, dy) 
}
}
fmt.Println(&amp;quot;&amp;lt;/svg&amp;gt;&amp;quot;) 

} 
func corner(i, j int) (float64, float64) { 
// Find point (x,y) at corner of cell (i,j). 
x := xyrange * (float64(i)/cells -0.5) 
y := xyrange * (float64(j)/cells -0.5) 

// Compute surface height z. 
z := f(x, y) 

// Project (x,y,z) isometrically onto 2-D SVG 
canvas (sx,sy). sx := width/2 + (x-y)*cos30*xyscale sy := height/2 + (x+y)*sin30*xyscale -z*zscale return sx, sy 
} 
func f(x, y float64) float64 {
r := math.Hypot(x, y) // distance from (0,0) 
return math.Sin(r) / r 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the function corner returns two values, the coordinates of the corner of the cell.&lt;/p&gt;

&lt;p&gt;The explanation of how the program works requires only basic geometry, but it’s fine to skip over it, since the point is to illustrate floating-point computation. The essence of the program is mapping between three different coordinate systems, shown in Figure 3.2. The first is a 2-D grid of 100×100 cells identified by integer coordinates (i, j), starting at (0, 0) in the far back corner. We plot from the back to the front so that background polygons may be obscured by foreground ones.&lt;/p&gt;

&lt;p&gt;The second coordinate system is a mesh of 3-D floating-point coordinates (x, y, z), where x and y are linear functions of i and j, translated so that the origin is in the center, and scaled by the constant xyrange. The height z is the value of the surface function f (x, y).&lt;/p&gt;

&lt;p&gt;The third coordinate system is the 2-D image canvas, with (0, 0) in the top left corner. Points in this plane are denoted (sx, sy). We use an isometric projection to map each 3-D point (x, y, z) onto the 2-D canvas. A point appears farther to the right on the canvas the greater its x value or the smaller its y value. And a point appears farther down the canvas the greater its x value or y value, and the smaller its z value. The vertical and horizontal scale factors for x and y are derived from the sine and cosine of a 30° angle. The scale factor for z, 0.4, is an arbitrary parameter.&lt;/p&gt;

&lt;p&gt;For each cell in the 2-D grid, the main function computes the coordinates on the image canvas of the four corners of the polygon ABCD, where B corresponds to (i, j) and A, C, and D are its neighbors, then prints an SVG instruction to draw it.&lt;/p&gt;

&lt;p&gt;Exercise 3.1: If the function f returns a non-finite float64 value, the SVG file will contain invalid &lt;polygon&gt; elements (although many SVG renderers handle this gracefully). Modify the program to skip invalid polygons.&lt;/p&gt;

&lt;p&gt;Exercise 3.2: Experiment with visualizations of other functions from the math package. Can you produce an egg box, moguls, or a saddle?&lt;/p&gt;

&lt;p&gt;Exercise 3.3: Color each polygon based on its height, so that the peaks are colored red (#ff0000) and the valleys blue (#0000ff).&lt;/p&gt;

&lt;p&gt;Exercise 3.4: Following the approach of the Lissajous example in Section 1.7, construct a web server that computes surfaces and writes SVG data to the client. The server must set the Content-Type header like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;image/svg+xml&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(This step was not required in the Lissajous example because the server uses standard heuristics to recognize common formats like PNG from the first 512 bytes of the response, and generates the proper header.) Allow the client to specify values like height, width, and color as HTTP request parameters.&lt;/p&gt;

&lt;h2 id=&#34;complex-numbers:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Complex Numbers&lt;/h2&gt;

&lt;p&gt;Go provides two sizes of complex numbers, complex64 and complex128, whose components are float32 and float64 respectively.&lt;/p&gt;

&lt;p&gt;The built-in function complex creates a complex number from its real and imaginary components, and the built-in real and imag functions extract those components:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x complex128 = complex(1, 2) // 1+2i 
var y complex128 = complex(3, 4) // 3+4i 
fmt.Println(x*y) // &amp;quot;(-5+10i)&amp;quot; 
fmt.Println(real(x*y)) // &amp;quot;-5&amp;quot; 
fmt.Println(imag(x*y)) // &amp;quot;10&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If a floating-point literal or decimal integer literal is immediately followed by i, such as 3.141592i or 2i, it becomes an imaginary literal, denoting a complex number with a zero real component:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(1i * 1i) // &amp;quot;(-1+0i)&amp;quot;, i² = -1 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Under the rules for constant arithmetic, complex constants can be added to other numeric constants (integer or floating point, real or imaginary), allowing us to write complex numbers naturally, like 1+2i or, equivalently, 2i+1. The declarations of x and y above can be simplified:
x := 1 + 2i
y := 3 + 4i Complex numbers may be compared for equality with == and !=. Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.&lt;/p&gt;

&lt;p&gt;The math/cmplx package provides library functions for working with complex numbers, such as the complex square root and exponentiation functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(cmplx.Sqrt(-1)) // &amp;quot;(0+1i)&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following program uses complex128 arithmetic to generate a Mandelbrot set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch3/mandelbrot 
// Mandelbrot emits a PNG image of the Mandelbrot 
fractal. 
package main 

import (
&amp;quot;image&amp;quot;
&amp;quot;image/color&amp;quot;
&amp;quot;image/png&amp;quot;
&amp;quot;math/cmplx&amp;quot;
&amp;quot;os&amp;quot; 

) 
func main() {
const (xmin, ymin, xmax, ymax = -2, -2, +2, +2 width, height = 1024, 1024 
) 
img := image.NewRGBA(image.Rect(0, 0, width, 
height))

for     py := 0; py &amp;lt; height; py++ {y := float64(py)/height*(ymax-ymin) + ymin for px := 0; px &amp;lt; width; px++ {
x := float64(px)/width*(xmax-xmin) + xmin z := complex(x, y) // Image point (px, py) represents complex 
value z. 
img.Set(px, py, mandelbrot(z)) 

}}png.Encode(os.Stdout, img) // NOTE: ignoring 
errors 
} 

func mandelbrot(z complex128) color.Color {
const iterations = 200 

const contrast = 15 
var v complex128 
for n := uint8(0); n &amp;lt; iterations; n++ {
v = v*v + z 
if cmplx.Abs(v) &amp;gt; 2 {
return color.Gray{255 -contrast*n} }}
return color.Black 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two nested loops iterate over each point in a 1024×1024 grayscale raster image representing the -2 to +2 portion of the complex plane. The program tests whether repeatedly squaring and adding the number that point represents eventually “escapes” the circle of radius 2. If so, the point is shaded by the number of iterations it took to escape. If not, the value belongs to the Mandelbrot set, and the point remains black.
Finally, the program writes to its standard output the PNG-encoded image of the iconic fractal, shown in Figure 3.3.&lt;/p&gt;

&lt;p&gt;Exercise 3.5: Implement a full-color Mandelbrot set using the function image.NewRGBA and the type color.RGBA or color.YCbCr.&lt;/p&gt;

&lt;p&gt;Exercise 3.6: Supersampling is a technique to reduce the effect of pixelation by computing the color value at several points within each pixel and taking the average. The simplest method is to divide each pixel into four “subpixels.” Implement it.&lt;/p&gt;

&lt;p&gt;Exercise 3.7: Another simple fractal uses Newton’s method to find complex solutions to a function such as z4-1 = 0. Shade each starting point by the number of iterations required to get close to one of the four roots. Color each point by the root it approaches.&lt;/p&gt;

&lt;p&gt;Exercise 3.8: Rendering fractals at high zoom levels demands great arithmetic precision. Implement the same fractal using four different representations of numbers: complex64, complex128, big.Float, and big.Rat. (The latter two types are found in the math/big package. Float uses arbitrary but bounded-precision floating-point; Rat uses unbounded-precision rational numbers.) How do they compare in performance and memory usage? At what zoom levels do rendering artifacts become visible?&lt;/p&gt;

&lt;p&gt;Exercise 3.9: Write a web server that renders fractals and writes the image data to the client. Allow the client to specify the x, y, and zoom values as parameters to the HTTP request.&lt;/p&gt;

&lt;h2 id=&#34;booleans:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Booleans&lt;/h2&gt;

&lt;p&gt;A value of type bool, or boolean, has only two possible values, true and false. The conditions in if and for statements are booleans, and comparison operators like == and &amp;lt; produce a boolean result. The unary operator ! is logical negation, so !true is false, or, one might say, (!true==false)==true, although as a matter of style, we always simplify redundant boolean expressions like x==true to x.
Boolean values can be combined with the &amp;amp;&amp;amp; (AND) and || (OR) operators, which have short-circuit behavior: if the answer is already determined by the value of the left operand, the right operand is not evaluated, making it safe to write expressions like this:
s != &amp;ldquo;&amp;rdquo; &amp;amp;&amp;amp; s[0] == &amp;lsquo;x&amp;rsquo; where s[0] would panic if applied to an empty string. Since &amp;amp;&amp;amp; has higher precedence than || (mnemonic: &amp;amp;&amp;amp; is boolean multiplication,
|| is boolean addition), no parentheses are required for conditions of this form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if &#39;a&#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &#39;z&#39; || 
&#39;A&#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &#39;Z&#39; || 
&#39;0&#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &#39;9&#39; {
// ...ASCII letter or digit... 
} 

There is no implicit conversion from a boolean value to a numeric value like 0 or 1, or vice versa. It’s necessary to use an explicit if, as in 
i := 0 
if b {
i=1 
} 


It might be worth writing a conversion function if this operation were needed often: 

```go
// btoi returns 1 if b is true and 0 if false. 
func btoi(b bool) int {
if b {

return 1 
}
return 0 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The inverse operation is so simple that it doesn’t warrant a function, but for symmetry here it is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// itob reports whether i is non-zero. 
func itob(i int) bool { return i != 0 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;strings:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Strings&lt;/h2&gt;

&lt;p&gt;A string is an immutable sequence of bytes. Strings may contain arbitrary data, including bytes with value 0, but usually they contain human-readable text. Text strings are conventionally interpreted as UTF-8-encoded sequences of Unicode code points (runes), which we’ll explore in detail very soon.&lt;/p&gt;

&lt;p&gt;The built-in len function returns the number of bytes (not runes) in a string, and the index operation s[i] retrieves the i-th byte of string s, where 0 = i &amp;lt; len(s).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s := &amp;quot;hello, world&amp;quot; 
fmt.Println(len(s)) // &amp;quot;12&amp;quot; 
fmt.Println(s[0], s[7]) // &amp;quot;104 119&amp;quot; (&#39;h&#39; and &#39;w&#39;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Attempting to access a byte outside this range results in a panic:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;c := s[len(s)] // panic: index out of range 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The i-th byte of a string is not necessarily the i-th character of a string, because the UTF-8 encoding of a non-ASCII code point requires two or more bytes. Working with characters is discussed shortly.&lt;/p&gt;

&lt;p&gt;The substring operation s[i:j] yields a new string consisting of the bytes of the original string starting at index i and continuing up to, but not including, the byte at index j. The result contains j-i bytes.&lt;/p&gt;

&lt;p&gt;fmt.Println(s[0:5]) // &amp;ldquo;hello&amp;rdquo; Again, a panic results if either index is out of bounds or if j is less than i. Either or both of the i and j operands may be omitted, in which case the default values of 0 (the start of the string) and len(s) (its end) are assumed, respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(s[:5]) // &amp;quot;hello&amp;quot; 
fmt.Println(s[7:]) // &amp;quot;world&amp;quot; 
fmt.Println(s[:]) // &amp;quot;hello, world&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The + operator makes a new string by concatenating two strings:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(&amp;quot;goodbye&amp;quot; + s[5:]) // &amp;quot;goodbye, world&amp;quot; 

Strings may be compared with comparison operators like == and &amp;lt;; the comparison is done byte by byte, so the result is the natural lexicographic ordering. String values are immutable: the byte sequence contained in a string value can never be changed, though of course we can assign a new value to a string variable. To append one string to another, for instance, we can write 

s := &amp;quot;left foot&amp;quot; 
t := s 
s += &amp;quot;, right foot&amp;quot; 

This does not modify the string that s originally held but causes s to hold the new string formed by the += statement; meanwhile, t still contains the old string. 

```go
fmt.Println(s) // &amp;quot;left foot, right foot&amp;quot; 
fmt.Println(t) // &amp;quot;left foot&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since strings are immutable, constructions that try to modify a string’s data in place are not allowed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s[0] = &#39;L&#39; // compile error: cannot assign to s[0] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Immutability means that it is safe for two copies of a string to share the same underlying memory, making it cheap to copy strings of any length. Similarly, a string s and a substring like s[7:] may safely share the same data, so the substring operation is also cheap. No new memory is allocated in either case. Figure 3.4 illustrates the arrangement of a string and two of its substrings sharing the same underlying byte array.&lt;/p&gt;

&lt;h3 id=&#34;string-literals:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;String Literals&lt;/h3&gt;

&lt;p&gt;A string value can be written as a string literal, a sequence of bytes enclosed in double quotes:
&amp;ldquo;Hello,
&amp;ldquo;&lt;/p&gt;

&lt;p&gt;Because Go source files are always encoded in UTF-8 and Go text strings are conventionally interpreted as UTF-8, we can include Unicode code points in string literals.
Within a double-quoted string literal, escape sequences that begin with a backslash \ can be used to insert arbitrary byte values into the string. One set of escapes handles ASCII control codes like newline, carriage return, and tab:
\a “alert” or bell
\b backspace
\f form feed
\n newline
\r carriage return
\t tab
\v vertical tab
\&amp;rsquo; single quote (only in the rune literal &amp;lsquo;\&amp;ldquo;)
\&amp;rdquo; double quote (only within &amp;ldquo;&amp;hellip;&amp;rdquo; literals)
\ backslash&lt;/p&gt;

&lt;p&gt;Arbitrary bytes can also be included in literal strings using hexadecimal or octal&lt;/p&gt;

&lt;p&gt;escapes. A hexadecimal escape is written \xhh, with exactly two hexadecimal digits h (in upper or lower case). An octal escape is written \ooo with exactly three octal digits o (0 through 7) not exceeding \377. Both denote a single byte with the specified value. Later, we’ll see how to encode Unicode code points numerically in string literals.&lt;/p&gt;

&lt;p&gt;A raw string literal is written &lt;code&gt;...&lt;/code&gt;, using backquotes instead of double quotes. Within a raw string literal, no escape sequences are processed; the contents are taken literally, including backslashes and newlines, so a raw string literal may spread over several lines in the program source. The only processing is that carriage returns are deleted so that the value of the string is the same on all platforms, including those that conventionally put carriage returns in text files.&lt;/p&gt;

&lt;p&gt;Raw string literals are a convenient way to write regular expressions, which tend to have lots of backslashes. They are also useful for HTML templates, JSON literals, command usage messages, and the like, which often extend over multiple lines.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const GoUsage = `Go is a tool for managing Go source 
code. 
Usage:
go command [arguments] 
...` 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unicode:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Unicode&lt;/h3&gt;

&lt;p&gt;Long ago, life was simple and there was, at least in a parochial view, only one character set to deal with: ASCII, the American Standard Code for Information Interchange. ASCII, or more precisely US-ASCII, uses 7 bits to represent 128 “characters”: the upper-and lower-case letters of English, digits, and a variety of punctuation and device-control characters. For much of the early days of computing, this was adequate, but it left a very large fraction of the world’s population unable to use their own writing systems in computers. With the growth of the Internet, data in myriad languages has become much more common. How can this rich variety be dealt with at all and, if possible, efficiently?&lt;/p&gt;

&lt;p&gt;The answer is Unicode (unicode.org), which collects all of the characters in all of the world’s writing systems, plus accents and other diacritical marks, control codes like tab and carriage return, and plenty of esoterica, and assigns each one a standard number called a Unicode code point or, in Go terminology, a rune.
Unicode version 8 defines code points for over 120,000 characters in well over 100 languages and scripts. How are these represented in computer programs and data? The natural data type to hold a single rune is int32, and that’s what Go uses; it has the synonym rune for precisely this purpose.&lt;/p&gt;

&lt;p&gt;We could represent a sequence of runes as a sequence of int32 values. In this representation, which is called UTF-32 or UCS-4, the encoding of each Unicode code point has the same size, 32 bits. This is simple and uniform, but it uses much more space than necessary since most computer-readable text is in ASCII, which requires only 8 bits or 1 byte per character. All the characters in widespread use still number fewer than 65,536, which would fit in 16 bits. Can we do better?&lt;/p&gt;

&lt;h3 id=&#34;utf-8:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;UTF-8&lt;/h3&gt;

&lt;p&gt;UTF-8 is a variable-length encoding of Unicode code points as bytes. UTF-8 was invented by Ken Thompson and Rob Pike, two of the creators of Go, and is now a Unicode standard. It uses between 1 and 4 bytes to represent each rune, but only 1 byte for ASCII characters, and only 2 or 3 bytes for most runes in common use.&lt;/p&gt;

&lt;p&gt;The high-order bits of the first byte of the encoding for a rune indicate how many bytes follow. A high-order 0 indicates 7-bit ASCII, where each rune takes only 1 byte, so it is identical to conventional ASCII. A high-order 110 indicates that the rune takes 2 bytes; the second byte begins with 10. Larger runes have analogous encodings.&lt;/p&gt;

&lt;p&gt;View table image&lt;br /&gt;
0xxxxxx  runes 0–127&lt;br /&gt;
110xxxxx  10xxxxxx  128–2047&lt;br /&gt;
1110xxxx  10xxxxxx  10xxxxxx  2048–65535&lt;br /&gt;
11110xxx  10xxxxxx  10xxxxxx 10xxxxxx  65536–0x10ffff&lt;/p&gt;

&lt;p&gt;A variable-length encoding precludes direct indexing to access the n-th character of a string, but UTF-8 has many desirable properties to compensate. The encoding is compact, compatible with ASCII, and self-synchronizing: it’s possible to find the beginning of a character by backing up no more than three bytes.&lt;/p&gt;

&lt;p&gt;It’s also a prefix code, so it can be decoded from left to right without any ambiguity or lookahead. No rune’s encoding is a substring of any other, or even of a sequence of others, so you can search for a rune by just searching for its bytes, without worrying about the preceding context. The lexicographic byte order equals the Unicode code point order, so sorting UTF-8 works naturally. There are no embedded NUL (zero) bytes, which is convenient for programming languages that use NUL to terminate strings.&lt;/p&gt;

&lt;p&gt;Gosource files are always encoded in UTF-8, and UTF-8 is the preferred encoding for text strings manipulated by Go programs. The unicode package provides functions for working with individual runes (such as distinguishing letters from numbers, or converting an upper-case letter to a lower-case one), and the unicode/utf8 package provides functions for encoding and decoding runes as bytes using UTF-8.&lt;/p&gt;

&lt;p&gt;Many Unicode characters are hard to type on a keyboard or to distinguish visually from similar-looking ones; some are even invisible. Unicode escapes in Go string literals allow us to specify them by their numeric code point value. There are two forms, \uhhhh for a 16-bit value and \Uhhhhhhhh for a 32-bit value, where each h is a hexadecimal digit; the need for the 32-bit form arises very infrequently.&lt;/p&gt;

&lt;p&gt;Each denotes the UTF-8 encoding of the specified code point. Thus, for example, the following string literals all represent the same six-byte string:
&amp;ldquo;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;\xe4\xb8\x96\xe7\x95\x8c&amp;rdquo;
&amp;ldquo;\u4e16\u754c&amp;rdquo;
&amp;ldquo;\U00004e16\U0000754c&amp;rdquo;&lt;/p&gt;

&lt;p&gt;The three escape sequences above provide alternative notations for the first string, but the values they denote are identical.
Unicode escapes may also be used in rune literals. These three literals are equivalent:
&amp;lsquo;
&amp;lsquo; &amp;lsquo;\u4e16&amp;rsquo; &amp;lsquo;\U00004e16&amp;rsquo;&lt;/p&gt;

&lt;p&gt;A rune whose value is less than 256 may be written with a single hexadecimal escape, such as &amp;lsquo;\x41&amp;rsquo; for &amp;lsquo;A&amp;rsquo;, but for higher values, a \u or \U escape must be used. Consequently, &amp;lsquo;\xe4\xb8\x96&amp;rsquo; is not a legal rune literal, even though those three bytes are a valid UTF-8 encoding of a single code point.&lt;/p&gt;

&lt;p&gt;Thanks to the nice properties of UTF-8, many string operations don’t require decoding. We can test whether one string contains another as a prefix:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func HasPrefix(s, prefix string) bool {
return len(s) &amp;gt;= len(prefix) &amp;amp;&amp;amp; s[:len(prefix)] == prefix
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or as a suffix:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func HasSuffix(s, suffix string) bool {
return len(s) &amp;gt;= len(suffix) &amp;amp;&amp;amp; s[len(s)­
len(suffix):] == suffix 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or as a substring:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Contains(s, substr string) bool {
for i := 0; i &amp;lt; len(s); i++ {
if HasPrefix(s[i:], substr) { 
return true 
}}
return false 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;using the same logic for UTF-8-encoded text as for raw bytes. This is not true for other encodings. (The functions above are drawn from the strings package, though its implementation of Contains uses a hashing technique to search more efficiently.)&lt;/p&gt;

&lt;p&gt;On the other hand, if we really care about the individual Unicode characters, we have to use other mechanisms. Consider the string from our very first example, which includes two East Asian characters. Figure 3.5 illustrates its representation in memory. The string contains 13 bytes, but interpreted as UTF-8, it encodes only nine code points or runes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;unicode/utf8&amp;quot; 
s := &amp;quot;Hello, 
&amp;quot; 
fmt.Println(len(s)) // &amp;quot;13&amp;quot; 
fmt.Println(utf8.RuneCountInString(s)) // &amp;quot;9&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To process those characters, we need a UTF-8 decoder. The unicode/utf8 package provides one that we can use like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for     i := 0; i &amp;lt; len(s); { 
r, size := utf8.DecodeRuneInString(s[i:])
fmt.Printf(&amp;quot;%d\t%c\n&amp;quot;, i, r) 
i += size 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each call to DecodeRuneInString returns r, the rune itself, and size, the number of bytes occupied by the UTF-8 encoding of r. The size is used to update the byte index i of the next rune in the string. But this is clumsy, and we need loops of this kind all the time. Fortunately, Go’s range loop, when applied to a string,
performs UTF-8 decoding implicitly. The output of the loop below is also shown in Figure 3.5; notice how the index jumps by more than 1 for each non-ASCII rune.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i, r := range &amp;quot;Hello, 
&amp;quot; {
fmt.Printf(&amp;quot;%d\t%q\t%d\n&amp;quot;, i, r, r) 
} 


We could use a simple range loop to count the number of runes in a string, like this: 
n := 0 
for _, _ = range s {
n++ 
} 


As with the other forms of range loop, we can omit the variables we don’t need: 
n := 0 
for range s {
n++ 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or we can just call utf8.RuneCountInString(s).&lt;/p&gt;

&lt;p&gt;We mentioned earlier that it is mostly a matter of convention in Go that text strings are interpreted as UTF-8-encoded sequences of Unicode code points, but for correct use of range loops on strings, it’s more than a convention, it’s a necessity. What happens if we range over a string containing arbitrary binary data or, for that matter, UTF-8 data containing errors?&lt;/p&gt;

&lt;p&gt;Each time a UTF-8 decoder, whether explicit in a call to utf8.DecodeRuneInString or implicit in a range loop, consumes an unexpected input byte, it generates a special Unicode replacement character, &amp;lsquo;\uFFFD&amp;rsquo;, which is usually printed as a white question mark inside a black hexagonal or diamond-like shape
. When a program encounters this rune value, it’s often a sign that some upstream part of the system that generated the string data has been careless in its treatment of text encodings.&lt;/p&gt;

&lt;p&gt;UTF-8 is exceptionally convenient as an interchange format but within a program runes may be more convenient because they are of uniform size and are thus easily indexed in arrays and slices.
A []rune conversion applied to a UTF-8-encoded string returns the sequence of Unicode code points that the string encodes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// &amp;quot;program&amp;quot; in Japanese katakana 
s:= &amp;quot; &amp;quot; 
fmt.Printf(&amp;quot;% x\n&amp;quot;, s) // &amp;quot;e3 83 97 e3 83 ad e3 82 b0 
e3 83 a9 e3 83 a0&amp;quot; 
r := []rune(s)
fmt.Printf(&amp;quot;%x\n&amp;quot;, r) // &amp;quot;[30d7 30ed 30b0 30e9 30e0]&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The verb %x in the first Printf inserts a space between each pair of hex digits.)&lt;/p&gt;

&lt;p&gt;If a slice of runes is converted to a string, it produces the concatenation of the UTF-8 encodings of each rune:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(string(r)) // &amp;quot; &amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Converting an integer value to a string interprets the integer as a rune value, and yields the UTF-8 representation of that rune:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(string(65)) // &amp;quot;A&amp;quot;, not &amp;quot;65&amp;quot; 
fmt.Println(string(0x4eac)) // &amp;quot; &amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the rune is invalid, the replacement character is substituted:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(string(1234567)) // &amp;quot; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;strings-and-byte-slices:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Strings and Byte Slices&lt;/h3&gt;

&lt;p&gt;Four standard packages are particularly important for manipulating strings: bytes, strings, strconv, and unicode. The strings package provides many functions for searching, replacing, comparing, trimming, splitting, and joining strings.&lt;/p&gt;

&lt;p&gt;The bytes package has similar functions for manipulating slices of bytes, of type []byte, which share some properties with strings. Because strings are immutable, building up strings incrementally can involve a lot of allocation and copying. In such cases, it’s more efficient to use the bytes.Buffer type, which we’ll show in a moment.&lt;/p&gt;

&lt;p&gt;The strconv package provides functions for converting boolean, integer, and floating-point values to and from their string representations, and functions for quoting and unquoting strings.&lt;/p&gt;

&lt;p&gt;The unicode package provides functions like IsDigit, IsLetter, IsUpper, and IsLower for classifying runes. Each function takes a single rune argument and returns a boolean. Conversion functions like ToUpper and ToLower convert a rune into the given case if it is a letter. All these functions use the Unicode standard categories for letters, digits, and so on. The strings package has similar functions, also called ToUpper and ToLower, that return a new string with the specified transformation applied to each character of the original string.&lt;/p&gt;

&lt;p&gt;The basename function below was inspired by the Unix shell utility of the same name. In our version, basename(s) removes any prefix of s that looks like a file system path with components separated by slashes, and it removes any suffix that looks like a file type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(basename(&amp;quot;a/b/c.go&amp;quot;)) // &amp;quot;c&amp;quot; 
fmt.Println(basename(&amp;quot;c.d.go&amp;quot;)) // &amp;quot;c.d&amp;quot; 
fmt.Println(basename(&amp;quot;abc&amp;quot;)) // &amp;quot;abc&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first version of basename does all the work without the help of libraries:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch3/basename1 
// basename removes directory components and a .suffix. 
// e.g., a =&amp;gt; a, a.go =&amp;gt; a, a/b/c.go =&amp;gt; c, a/b.c.go =&amp;gt; b.c 
func basename(s string) string { 
// Discard last &#39;/&#39; and everything before. 
for i := len(s) -1; i &amp;gt;= 0; i--{
if s[i] == &#39;/&#39; {
s = s[i+1:] 
break 

}}
// Preserve everything before last &#39;.&#39;. 
for i := len(s) -1; i &amp;gt;= 0; i--{
if s[i] == &#39;.&#39; {
s = s[:i]
break 
}}
return s 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A simpler version uses the strings.LastIndex library function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch3/basename2 
func basename(s string) string { 
slash := strings.LastIndex(s, &amp;quot;/&amp;quot;) // -1 if &amp;quot;/&amp;quot; 
not found 
s = s[slash+1:] 
if dot := strings.LastIndex(s, &amp;quot;.&amp;quot;); dot &amp;gt;= 0 {
s = s[:dot] }
return s 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The path and path/filepath packages provide a more general set of functions for manipulating hierarchical names. The path package works with slash-delimited paths on any platform. It shouldn’t be used for file names, but it is appropriate for other domains, like the path component of a URL. By contrast, path/filepathmanipulates file names using the rules for the host platform, such as /foo/bar for POSIX or c:\foo\bar on Microsoft Windows.
Let’s continue with another substring example. The task is to take a string representation of an integer, such as &amp;ldquo;12345&amp;rdquo;, and insert commas every three places, as in &amp;ldquo;12,345&amp;rdquo;. This version only works for integers; handling floating-point numbers is left as a exercise.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch3/comma 
// comma inserts commas in a non-negative decimal 
integer string. 
func comma(s string) string { 
n := len(s) 
if n &amp;lt;= 3 {
return s 
}
return comma(s[:n-3]) + &amp;quot;,&amp;quot; + s[n-3:] } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The argument to comma is a string. If its length is less than or equal to 3, no comma is necessary. Otherwise, comma calls itself recursively with a substring consisting of all but the last three characters, and appends a comma and the last three characters to the result of the recursive call.&lt;/p&gt;

&lt;p&gt;A string contains an array of bytes that, once created, is immutable. By contrast, the elements of a byte slice can be freely modified.&lt;/p&gt;

&lt;p&gt;Strings can be converted to byte slices and back again:
s := &amp;ldquo;abc&amp;rdquo;
b := []byte(s)
s2 := string(b)&lt;/p&gt;

&lt;p&gt;Conceptually, the []byte(s) conversion allocates a new byte array holding a copy of the bytes of s, and yields a slice that references the entirety of that array. An optimizing compiler may be able to avoid the allocation and copying in some cases, but in general copying is required to ensure that the bytes of s remain unchanged even if those of b are subsequently modified. The conversion from byte slice back to string with string(b) also makes a copy, to ensure immutability of the resulting string s2.&lt;/p&gt;

&lt;p&gt;To avoid conversions and unnecessary memory allocation, many of the utility functions in the bytes package directly parallel their counterparts in the strings package. For example, here are half a dozen functions from strings:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Contains(s, substr string) bool 
func Count(s, sep string) int 
func Fields(s string) []string 
func HasPrefix(s, prefix string) bool 
func Index(s, sep string) int 
func Join(a []string, sep string) string 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the corresponding ones from bytes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Contains(b, subslice []byte) bool 
func Count(s, sep []byte) int 
func Fields(s []byte) [][]byte 
func HasPrefix(s, prefix []byte) bool 
func Index(s, sep []byte) int 
func Join(s [][]byte, sep []byte) []byte 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only difference is that strings have been replaced by byte slices.&lt;/p&gt;

&lt;p&gt;The bytes package provides the Buffer type for efficient manipulation of byte slices. A Buffer starts out empty but grows as data of types like string, byte, and []byte are written to it. As the example below shows, a bytes.Buffer variable requires no initialization because its zero value is usable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch3/printints 
// intsToString is like fmt.Sprint(values) but adds 
commas. 
func intsToString(values []int) string { 

var buf bytes.Buffer
buf.WriteByte(&#39;[&#39;)
for i, v := range values {

if i &amp;gt; 0 {
buf.WriteString(&amp;quot;, &amp;quot;) 
}
fmt.Fprintf(&amp;amp;buf, &amp;quot;%d&amp;quot;, v) 

}
buf.WriteByte(&#39;]&#39;)
return buf.String() 

} 
func main() { 
fmt.Println(intsToString([]int{1, 2, 3})) // &amp;quot;[1, 2, 3]&amp;quot; } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When appending the UTF-8 encoding of an arbitrary rune to a bytes.Buffer, it’s
best to use bytes.Buffer’s WriteRune method, but WriteByte is fine for
ASCII characters such as &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;The bytes.Buffer type is extremely versatile, and when we discuss interfaces in
Chapter 7, we’ll see how it may be used as a replacement for a file whenever an I/O
function requires a sink for bytes (io.Writer) as Fprintf does above, or a
source of bytes (io.Reader).&lt;/p&gt;

&lt;p&gt;Exercise 3.10: Write a non-recursive version of comma, using bytes.Buffer&lt;/p&gt;

&lt;p&gt;instead of string concatenation.&lt;/p&gt;

&lt;p&gt;Exercise 3.11: Enhance comma so that it deals correctly with floating-point numbers
and an optional sign.&lt;/p&gt;

&lt;p&gt;Exercise 3.12: Write a function that reports whether two strings are anagrams of each
other, that is, they contain the same letters in a different order.&lt;/p&gt;

&lt;h3 id=&#34;conversions-between-strings-and-numbers:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Conversions between Strings and Numbers&lt;/h3&gt;

&lt;p&gt;In addition to conversions between strings, runes, and bytes, it’s often necessary to convert between numeric values and their string representations. This is done with functions from the strconv package.&lt;/p&gt;

&lt;p&gt;To convert an integer to a string, one option is to use fmt.Sprintf; another is to use the function strconv.Itoa (“integer to ASCII”):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x := 123 
y := fmt.Sprintf(&amp;quot;%d&amp;quot;, x) 
fmt.Println(y, strconv.Itoa(x)) // &amp;quot;123 123&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FormatInt and FormatUint can be used to format numbers in a different base:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(strconv.FormatInt(int64(x), 2)) // &amp;quot;1111011&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fmt.Printf verbs %b, %d, %u, and %x are often more convenient than Format functions, especially if we want to include additional information besides the number:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s := fmt.Sprintf(&amp;quot;x=%b&amp;quot;, x) // &amp;quot;x=1111011&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To parse a string representing an integer, use the strconv functions Atoi or ParseInt, or ParseUint for unsigned integers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x, err := strconv.Atoi(&amp;quot;123&amp;quot;) // x is an int 
y, err := strconv.ParseInt(&amp;quot;123&amp;quot;, 10, 64) // base 10, up to 64 bits 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The third argument of ParseInt gives the size of the integer type that the result must fit into; for example, 16 implies int16, and the special value of 0 implies int. In any case, the type of the result y is always int64, which you can then convert to a smaller type.&lt;/p&gt;

&lt;p&gt;Sometimes fmt.Scanf is useful for parsing input that consists of orderly mixtures of strings and numbers all on a single line, but it can be inflexible, especially when handling incomplete or irregular input.&lt;/p&gt;

&lt;h2 id=&#34;constants:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Constants&lt;/h2&gt;

&lt;p&gt;Constants are expressions whose value is known to the compiler and whose evaluation is guaranteed to occur at compile time, not at run time. The underlying type of every constant is a basic type: boolean, string, or number.&lt;/p&gt;

&lt;p&gt;A const declaration defines named values that look syntactically like variables but whose value is constant, which prevents accidental (or nefarious) changes during program execution. For instance, a constant is more appropriate than a variable for a mathematical constant like pi, since its value won’t change:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const pi = 3.14159 // approximately; math.Pi is a better approximation 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with variables, a sequence of constants can appear in one declaration; this would be appropriate for a group of related values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (e= 2.71828182845904523536028747135266249775724709369995957 
pi = 3.14159265358979323846264338327950288419716939937510582 
) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Many computations on constants can be completely evaluated at compile time, reducing the work necessary at run time and enabling other compiler optimizations. Errors ordinarily detected at run time can be reported at compile time when their operands are constants, such as integer division by zero, string indexing out of bounds, and any floating-point operation that would result in a non-finite value.&lt;/p&gt;

&lt;p&gt;The results of all arithmetic, logical, and comparison operations applied to constant operands are themselves constants, as are the results of conversions and calls to certain built-in functions such as len, cap, real, imag, complex, and unsafe.Sizeof (§13.1).&lt;/p&gt;

&lt;p&gt;Since their values are known to the compiler, constant expressions may appear in types, specifically as the length of an array type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const IPv4Len = 4 
// parseIPv4 parses an IPv4 address (d.d.d.d). 
func parseIPv4(s string) IP {
var p [IPv4Len]byte 
// ... } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A constant declaration may specify a type as well as a value, but in the absence of an explicit type, the type is inferred from the expression on the right-hand side. In the following, time.Duration is a named type whose underlying type is int64, and time.Minute is a constant of that type. Both of the constants declared below thus have the type time.Duration as well, as revealed by %T:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const const  noDelay timeout  time.Duration = 0 = 5 * time.Minute  
fmt.Printf(&amp;quot;%T %[1]v\n&amp;quot;, noDelay) &amp;quot;time.Duration 0&amp;quot;  //  
fmt.Printf(&amp;quot;%T %[1]v\n&amp;quot;, timeout) &amp;quot;time.Duration 5m0s&amp;quot;  //  

fmt.Printf(&amp;quot;%T %[1]v\n&amp;quot;, time.Minute) // &amp;quot;time.Duration 1m0s&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When a sequence of constants is declared as a group, the right-hand side expression may be omitted for all but the first of the group, implying that the previous expression and its type should be used again. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (a=1 b c=2 d 
) fmt.Println(a, b, c, d) // &amp;quot;1 1 2 2&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is not very useful if the implicitly copied right-hand side expression always evaluates to the same thing. But what if it could vary? This brings us to iota.&lt;/p&gt;

&lt;h3 id=&#34;the-constant-generator-iota:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;The Constant Generator iota&lt;/h3&gt;

&lt;p&gt;A const declaration may use the constant generator iota, which is used to create a sequence of related values without spelling out each one explicitly. In a const declaration, the value of iota begins at zero and increments by one for each item in the sequence.&lt;/p&gt;

&lt;p&gt;Here’s an example from the time package, which defines named constants of type Weekday for the days of the week, starting with zero for Sunday. Types of this kind are often called enumerations, or enums for short.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Weekday int 
const (Sunday Weekday = iota 
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday ) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This declares Sunday to be 0, Monday to be 1, and so on.&lt;/p&gt;

&lt;p&gt;We can use iota in more complex expressions too, as in this example from the net package where each of the lowest 5 bits of an unsigned integer is given a distinct name and boolean interpretation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Flags uint 
const ( 
FlagUp Flags = 1 &amp;lt;&amp;lt; iota // is up FlagBroadcast // supports broadcast access capabilityFlagLoopback // is a loopback interface FlagPointToPoint // belongs to a point-to­point link 
FlagMulticast // supports multicast 
access capability 
) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As iota increments, each constant is assigned the value of 1 &amp;lt;&amp;lt; iota , which evaluates to successive powers of two, each corresponding to a single bit. We can use these constants within functions that test, set, or clear one or more of these bits:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch3/netflag 
func IsUp(v Flags) bool { return v&amp;amp;FlagUp == 
FlagUp }
func TurnDown(v *Flags) { *v &amp;amp;^= FlagUp } 
func SetBroadcast(v *Flags) { *v |= FlagBroadcast }
func IsCast(v Flags) bool { return v&amp;amp; 
(FlagBroadcast|FlagMulticast) != 0 } 


func main() {var v Flags = FlagMulticast | FlagUp fmt.Printf(&amp;quot;%b %t\n&amp;quot;, v, IsUp(v)) // &amp;quot;10001 true&amp;quot; TurnDown(&amp;amp;v)fmt.Printf(&amp;quot;%b %t\n&amp;quot;, v, IsUp(v)) // &amp;quot;10000 false&amp;quot; SetBroadcast(&amp;amp;v)fmt.Printf(&amp;quot;%b %t\n&amp;quot;, v, IsUp(v)) // &amp;quot;10010 
false&amp;quot; 
fmt.Printf(&amp;quot;%b %t\n&amp;quot;, v, IsCast(v)) // &amp;quot;10010 
true&amp;quot; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a more complex example of iota, this declaration names the powers of 1024:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const ( _ = 1 &amp;lt;&amp;lt; (10 * iota) 
KiB // 1024 
MiB // 1048576 
GiB // 1073741824 
TiB // 1099511627776 (exceeds 1 &amp;lt;&amp;lt; 32) PiB // 1125899906842624 
EiB // 1152921504606846976 
ZiB // 1180591620717411303424 (exceeds 1 &amp;lt;&amp;lt; 64) YiB // 1208925819614629174706176 ) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The iota mechanism has its limits. For example, it’s not possible to generate the more familiar powers of 1000 (KB, MB, and so on) because there is no exponentiation operator.&lt;/p&gt;

&lt;p&gt;Exercise 3.13: Write const declarations for KB, MB, up through YB as compactly as you can.&lt;/p&gt;

&lt;h3 id=&#34;untyped-constants:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Untyped Constants&lt;/h3&gt;

&lt;p&gt;Constants in Go are a bit unusual. Although a constant can have any of the basic data types like int or float64, including named basic types like time.Duration, many constants are not committed to a particular type. The compiler represents these uncommitted constants with much greater numeric precision than values of basic types, and arithmetic on them is more precise than machine arithmetic; you may assume at least 256 bits of precision. There are six flavors of these uncommitted constants, called untyped boolean, untyped integer, untyped rune, untyped floating-point, untyped complex, and untyped string.&lt;/p&gt;

&lt;p&gt;By deferring this commitment, untyped constants not only retain their higher precision until later, but they can participate in many more expressions than committed constants without requiring conversions. For example, the values ZiB and YiB in the example above are too big to store in any integer variable, but they are legitimate constants that may be used in expressions like this one:
&lt;code&gt;fmt.Println(YiB/ZiB) // &amp;quot;1024&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;As another example, the floating-point constant math.Pi may be used wherever any floating-point or complex value is needed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x float32 = math.Pi 
var y float64 = math.Pi 
var z complex128 = math.Pi 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If math.Pi had been committed to a specific type such as float64, the result would not be as precise, and type conversions would be required to use it when a float32 or complex128 value is wanted:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const Pi64 float64 = math.Pi 
var x float32 = float32(Pi64) 
var y float64 = Pi64 
var z complex128 = complex128(Pi64) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For literals, syntax determines flavor. The literals 0, 0.0, 0i, and &amp;lsquo;\u0000&amp;rsquo; all denote constants of the same value but different flavors: untyped integer, untyped floating-point, untyped complex, and untyped rune, respectively. Similarly, true and false are untyped booleans and string literals are untyped strings.
Recall that / may represent integer or floating-point division depending on its operands. Consequently, the choice of literal may affect the result of a constant division expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var f float64 = 212 
fmt.Println((f -32) * 5 / 9) // &amp;quot;100&amp;quot;; (f -32) * 5 is a float64 
fmt.Println(5 / 9 * (f -32)) // &amp;quot;0&amp;quot;; 5/9 is an untyped integer, 0 
fmt.Println(5.0 / 9.0 * (f -32)) // &amp;quot;100&amp;quot;; 5.0/9.0 is an untyped float
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only constants can be untyped. When an untyped constant is assigned to a variable, as in the first statement below, or appears on the right-hand side of a variable declaration with an explicit type, as in the other three statements, the constant is implicitly converted to the type of that variable if possible.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var f float64 = 3 + 0i // untyped complex -&amp;gt; float64 
f = 2 // untyped integer -&amp;gt; float64 
f = 1e123 // untyped floating-point -&amp;gt; 
float64 
f = &#39;a&#39; // untyped rune -&amp;gt; float64 

The statements above are thus equivalent to these: 
var f float64 = float64(3 + 0i) 
f = float64(2) 
f = float64(1e123) 
f = float64(&#39;a&#39;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whether implicit or explicit, converting a constant from one type to another requires that the target type can represent the original value. Rounding is allowed for real and complex floating-point numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
deadbeef = 0xdeadbeef // untyped int with value 
3735928559 
a = uint32(deadbeef) // uint32 with value 
3735928559 
b = float32(deadbeef) // float32 with value 
3735928576 (rounded up) 
c = float64(deadbeef) // float64 with value 
3735928559 (exact) 
d = int32(deadbeef) // compile error: constant 
overflows int32 
e = float64(1e309) // compile error: constant 
overflows float64 
f = uint(-1) // compile error: constant 
underflows uint 
) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a variable declaration without an explicit type (including short variable declarations), the flavor of the untyped constant implicitly determines the default type of the variable, as in these examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;i := 0 // untyped integer; implicit int(0) 
r := &#39;\000&#39; // untyped rune; implicit 
rune(&#39;\000&#39;)
f := 0.0 // untyped floating-point; implicit 
float64(0.0)
c := 0i // untyped complex; implicit 
complex128(0i) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the asymmetry: untyped integers are converted to int, whose size is not guaranteed, but untyped floating-point and complex numbers are converted to the explicitly sized types float64 and complex128. The language has no unsized float and complex types analogous to unsized int, because it is very difficult to write correct numerical algorithms without knowing the size of one’s floating-point data types.&lt;/p&gt;

&lt;p&gt;To give the variable a different type, we must explicitly convert the untyped constant to the desired type or state the desired type in the variable declaration, as in these examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var i = int8(0) 
var i int8 = 0 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These defaults are particularly important when converting an untyped constant to an interface value (see Chapter 7) since they determine its dynamic type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Printf(&amp;quot;%T\n&amp;quot;, 0) // &amp;quot;int&amp;quot; 
fmt.Printf(&amp;quot;%T\n&amp;quot;, 0.0) // &amp;quot;float64&amp;quot; 
fmt.Printf(&amp;quot;%T\n&amp;quot;, 0i) // &amp;quot;complex128&amp;quot; 
fmt.Printf(&amp;quot;%T\n&amp;quot;, &#39;\000&#39;) // &amp;quot;int32&amp;quot; (rune) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We’ve now covered the basic data types of Go. The next step is to show how they can be combined into larger groupings like arrays and structs, and then into data structures for solving real programming problems; that is the topic of Chapter 4.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Composite Types&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In Chapter 3 we discussed the basic types that serve as building blocks for data structures in a Go program; they are the atoms of our universe. In this chapter, we’ll take a look at composite types, the molecules created by combining the basic types in various ways. We’ll talk about four such types—arrays, slices, maps, and structs— and at the end of the chapter, we’ll show how structured data using these types can be encoded as and parsed from JSON data and used to generate HTML from templates.&lt;/p&gt;

&lt;p&gt;Arrays and structs are aggregate types; their values are concatenations of other values in memory. Arrays are homogeneous—their elements all have the same type— whereas structs are heterogeneous. Both arrays and structs are fixed size. In contrast, slices and maps are dynamic data structures that grow as values are added.&lt;/p&gt;

&lt;h2 id=&#34;arrays:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Arrays&lt;/h2&gt;

&lt;p&gt;Anarray is a fixed-length sequence of zero or more elements of a particular type. Because of their fixed length, arrays are rarely used directly in Go. Slices, which can grow and shrink, are much more versatile, but to understand slices we must understand arrays first.&lt;/p&gt;

&lt;p&gt;Individual array elements are accessed with the conventional subscript notation, where subscripts run from zero to one less than the array length. The built-in function len returns the number of elements in the array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var a [3]int // array of 3 integers fmt.Println(a[0]) // print the first element fmt.Println(a[len(a)-1]) // print the last element, a[2] 
// Print the indices and elements. 
for i, v := range a {
fmt.Printf(&amp;quot;%d %d\n&amp;quot;, i, v) 
} 

// Print the elements only. 
for _, v := range a {
fmt.Printf(&amp;quot;%d\n&amp;quot;, v) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, the elements of a new array variable are initially set to the zero value for the element type, which is 0 for numbers. We can use an array literal to initialize an array with a list of values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var q [3]int = [3]int{1, 2, 3} 
var r [3]int = [3]int{1, 2} 
fmt.Println(r[2]) // &amp;quot;0&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In an array literal, if an ellipsis “&amp;hellip;” appears in place of the length, the array length is determined by the number of initializers. The definition of q can be simplified to
q := [&amp;hellip;]int{1, 2, 3}
fmt.Printf(&amp;ldquo;%T\n&amp;rdquo;, q) // &amp;ldquo;[3]int&amp;rdquo;&lt;/p&gt;

&lt;p&gt;The size of an array is part of its type, so [3]int and [4]int are different types. The size must be a constant expression, that is, an expression whose value can be computed as the program is being compiled.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;q := [3]int{1, 2, 3} q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we’ll see, the literal syntax is similar for arrays, slices, maps, and structs. The specific form above is a list of values in order, but it is also possible to specify a list of index and value pairs, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Currency int 
const (
USD Currency = iota 
EUR 
GBP 
RMB 

) 
symbol := [...]string{USD: &amp;quot;$&amp;quot;, EUR: &amp;quot;€&amp;quot;, GBP: &amp;quot;£&amp;quot;, RMB: &amp;quot;¥&amp;quot;} 
fmt.Println(RMB, symbol[RMB]) // &amp;quot;3 ¥&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this form, indices can appear in any order and some may be omitted; as before, unspecified values take on the zero value for the element type. For instance,
r := [&amp;hellip;]int{99: -1}
defines an array r with 100 elements, all zero except for the last, which has value -1.&lt;/p&gt;

&lt;p&gt;If an array’s element type is comparable then the array type is comparable too, so we may directly compare two arrays of that type using the == operator, which reports whether all corresponding elements are equal. The != operator is its negation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a := [2]int{1, 2} 
b := [...]int{1, 2} 
c := [2]int{1, 3} 
fmt.Println(a == b, a == c, b == c) // &amp;quot;true false 
false&amp;quot; 
d := [3]int{1, 2} 
fmt.Println(a == d) // compile error: cannot compare 
[2]int == [3]int 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a more plausible example, the function Sum256 in the crypto/sha256 package produces the SHA256 cryptographic hash or digest of a message stored in an arbitrary byte slice. The digest has 256 bits, so its type is [32]byte. If two digests are the same, it is extremely likely that the two messages are the same; if the digests differ, the two messages are different. This program prints and compares the SHA256 digests of &amp;ldquo;x&amp;rdquo; and &amp;ldquo;X&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/sha256 
import &amp;quot;crypto/sha256&amp;quot; 
func main() {c1 := sha256.Sum256([]byte(&amp;quot;x&amp;quot;)) c2 := sha256.Sum256([]byte(&amp;quot;X&amp;quot;))fmt.Printf(&amp;quot;%x\n%x\n%t\n%T\n&amp;quot;, c1, c2, c1 == c2, 
c1) 
// Output: 
// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db0225871 //4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5 
// false 
// [32]uint8 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two inputs differ by only a single bit, but approximately half the bits are different in the digests. Notice the Printf verbs: %x to print all the elements of an array or slice of bytes in hexadecimal, %t to show a boolean, and %T to display the type of a value.&lt;/p&gt;

&lt;p&gt;When a function is called, a copy of each argument value is assigned to the corresponding parameter variable, so the function receives a copy, not the original. Passing large arrays in this way can be inefficient, and any changes that the function makes to array elements affect only the copy, not the original. In this regard, Go treats arrays like any other type, but this behavior is different from languages that implicitly pass arrays by reference.&lt;/p&gt;

&lt;p&gt;Of course, we can explicitly pass a pointer to an array so that any modifications the function makes to array elements will be visible to the caller. This function zeroes the contents of a [32]byte array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func zero(ptr *[32]byte) { 
for i := range ptr {
ptr[i] = 0 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The array literal [32]byte{} yields an array of 32 bytes. Each element of the array has the zero value for byte, which is zero. We can use that fact to write a different version of zero:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func zero(ptr *[32]byte) { 
*ptr = [32]byte{} 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using a pointer to an array is efficient and allows the called function to mutate the caller’s variable, but arrays are still inherently inflexible because of their fixed size. The zero function will not accept a pointer to a [16]byte variable, for example, nor is there any way to add or remove array elements. For these reasons, other than special cases like SHA256’s fixed-size hash, arrays are seldom used as function parameters; instead, we use slices.&lt;/p&gt;

&lt;p&gt;Exercise 4.1: Write a function that counts the number of bits that are different in two SHA256 hashes. (See PopCount from Section 2.6.2.)&lt;/p&gt;

&lt;p&gt;Exercise 4.2: Write a program that prints the SHA256 hash of its standard input by default but supports a command-line flag to print the SHA384 or SHA512 hash instead.&lt;/p&gt;

&lt;h2 id=&#34;slices:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Slices&lt;/h2&gt;

&lt;p&gt;Slices represent variable-length sequences whose elements all have the same type. A slice type is written []T, where the elements have type T; it looks like an array type without a size.
Arrays and slices are intimately connected. A slice is a lightweight data structure that gives access to a subsequence (or perhaps all) of the elements of an array, which is known as the slice’s underlying array. A slice has three components: a pointer, a length, and a capacity. The pointer points to the first element of the array that is reachable through the slice, which is not necessarily the array’s first element. The length is the number of slice elements; it can’t exceed the capacity, which is usually the number of elements between the start of the slice and the end of the underlying array. The built-in functions len and cap return those values.&lt;/p&gt;

&lt;p&gt;Multiple slices can share the same underlying array and may refer to overlapping parts of that array. Figure 4.1 shows an array of strings for the months of the year, and two overlapping slices of it. The array is declared as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;months := [...]string{1: &amp;quot;January&amp;quot;, /* ... */, 12: 
&amp;quot;December&amp;quot;} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so January is months[1] and December is months[12]. Ordinarily, the array element at index 0 would contain the first value, but because months are always numbered from 1, we can leave it out of the declaration and it will be initialized to an empty string.&lt;/p&gt;

&lt;p&gt;The slice operator s[i:j], where 0 = i = j = cap(s), creates a new slice that refers to elements i through j-1 of the sequence s, which may be an array variable, a pointer to an array, or another slice. The resulting slice has j-i elements. If i is omitted, it’s 0, and if j is omitted, it’s len(s). Thus the slice months[1:13] refers to the whole range of valid months, as does the slice months[1:]; the slice months[:] refers to the whole array. Let’s define overlapping slices for the second quarter and the northern summer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Q2 := months[4:7] 
summer := months[6:9]
fmt.Println(Q2) // [&amp;quot;April&amp;quot; &amp;quot;May&amp;quot; &amp;quot;June&amp;quot;] 
fmt.Println(summer) // [&amp;quot;June&amp;quot; &amp;quot;July&amp;quot; &amp;quot;August&amp;quot;] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;June is included in each and is the sole output of this (inefficient) test for common elements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for _, s := range summer {
for _, q := range Q2 {
if s == q {
fmt.Printf(&amp;quot;%s appears in both\n&amp;quot;, s) 
}
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Slicing beyond cap(s) causes a panic, but slicing beyond len(s) extends the slice, so the result may be longer than the original:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(summer[:20]) // panic: out of range 
endlessSummer := summer[:5] // extend a slice (within 
capacity)
fmt.Println(endlessSummer) // &amp;quot;[June July August September October]&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As an aside, note the similarity of the substring operation on strings to the slice operator on []byte slices. Both are written x[m:n], and both return a subsequence of the original bytes, sharing the underlying representation so that both operations take constant time. The expression x[m:n] yields a string if x is a string, or a []byte if x is a []byte.&lt;/p&gt;

&lt;p&gt;Since a slice contains a pointer to an element of an array, passing a slice to a function permits the function to modify the underlying array elements. In other words, copying a slice creates an alias (§2.3.2) for the underlying array. The function reverse reverses the elements of an []int slice in place, and it may be applied to slices of any length.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/rev 
// reverse reverses a slice of ints in place. func reverse(s []int) { for i, j := 0, len(s)-1; i &amp;lt; j; i, j = i+1, j-1 {s[i], s[j] = s[j], s[i] }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we reverse the whole array a:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a := [...]int{0, 1, 2, 3, 4, 5} 
reverse(a[:])
fmt.Println(a) // &amp;quot;[5 4 3 2 1 0]&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A simple way to rotate a slice left by n elements is to apply the reverse function three times, first to the leading n elements, then to the remaining elements, and finally to the whole slice. (To rotate to the right, make the third call first.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s := []int{0, 1, 2, 3, 4, 5} 
// Rotate s left by two positions. 
reverse(s[:2])
reverse(s[2:]) reverse(s)
fmt.Println(s) // &amp;quot;[2 3 4 5 0 1]&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how the expression that initializes the slice s differs from that for the array a. A slice literal looks like an array literal, a sequence of values separated by commas and surrounded by braces, but the size is not given. This implicitly creates an array variable of the right size and yields a slice that points to it. As with array literals, slice literals may specify the values in order, or give their indices explicitly, or use a mix of the two styles.
Unlike arrays, slices are not comparable, so we cannot use == to test whether two slices contain the same elements. The standard library provides the highly optimized bytes.Equal function for comparing two slices of bytes ([]byte), but for other types of slice, we must do the comparison ourselves:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func equal(x, y []string) bool {
if len(x) != len(y) { 
return false 
}
for i := range x {
if x[i] != y[i] { 
return false 
}}
return true 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given how natural this “deep” equality test is, and that it is no more costly at run time than the == operator for arrays of strings, it may be puzzling that slice comparisons do not also work this way. There are two reasons why deep equivalence is problematic. First, unlike array elements, the elements of a slice are indirect, making it possible for a slice to contain itself. Although there are ways to deal with such cases, none is simple, efficient, and most importantly, obvious.
Second, because slice elements are indirect, a fixed slice value may contain different elements at different times as the contents of the underlying array are modified. Because a hash table such as Go’s map type makes only shallow copies of its keys, it requires that equality for each key remain the same throughout the lifetime of the hash table. Deep equivalence would thus make slices unsuitable for use as map keys.&lt;/p&gt;

&lt;p&gt;For reference types like pointers and channels, the == operator tests reference identity, that is, whether the two entities refer to the same thing. An analogous “shallow” equality test for slices could be useful, and it would solve the problem with maps, but the inconsistent treatment of slices and arrays by the == operator would be confusing. The safest choice is to disallow slice comparisons altogether.&lt;/p&gt;

&lt;p&gt;The only legal slice comparison is against nil, as in
if summer == nil { /* &amp;hellip; */ }&lt;/p&gt;

&lt;p&gt;The zero value of a slice type is nil. A nil slice has no underlying array. The nil slice has length and capacity zero, but there are also non-nil slices of length and capacity zero, such as []int{} or make([]int, 3)[3:]. As with any type that can have nil values, the nil value of a particular slice type can be written using a conversion expression such as []int(nil).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var s []int // len(s) == 0, s == nil 
s = nil // len(s) == 0, s == nil 
s = []int(nil) // len(s) == 0, s == nil 
s = []int{} // len(s) == 0, s != nil 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, if you need to test whether a slice is empty, use len(s) == 0 , not s == nil. Other than comparing equal to nil, a nil slice behaves like any other zero-length slice; reverse(nil) is perfectly safe, for example. Unless clearly documented to the contrary, Go functions should treat all zero-length slices the same way, whether nil or non-nil.&lt;/p&gt;

&lt;p&gt;The built-in function make creates a slice of a specified element type, length, and capacity. The capacity argument may be omitted, in which case the capacity equals the length.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;make([]T, len) 
make([]T, len, cap) // same as make([]T, cap)[:len] 
Under the hood, make creates an unnamed array variable and returns a slice of it; the array is accessible only through the returned slice. In the first form, the slice is a view of the entire array. In the second, the slice is a view of only the array’s first len elements, but its capacity includes the entire array. The additional elements are set aside for future growth. 

### The append Function 

The built-in append function appends items to slices: 

```go
var runes []rune 
for _, r := range &amp;quot;Hello, 
&amp;quot; {
runes = append(runes, r) }
fmt.Printf(&amp;quot;%q\n&amp;quot;, runes) // &amp;quot;[&#39;H&#39; &#39;e&#39; &#39;l&#39; &#39;l&#39; &#39;o&#39; &#39;,&#39; 
&#39;&#39;&#39;
&#39;&#39; &#39;]&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The loop uses append to build the slice of nine runes encoded by the string literal, although this specific problem is more conveniently solved by using the built-in conversion []rune(&amp;ldquo;Hello,&lt;/p&gt;

&lt;p&gt;&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;The append function is crucial to understanding how slices work, so let’s take a look at what is going on. Here’s a version called appendInt that is specialized for []int slices:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/append 
func appendInt(x []int, y int) []int {
var z []int 
zlen := len(x) + 1 
if zlen &amp;lt;= cap(x) { 
// There is room to grow. Extend the slice. 
z = x[:zlen] 
} else {
// There is insufficient space. Allocate a new array.
// Grow by doubling, for amortized linear complexity.
zcap := zlen 
if zcap &amp;lt; 2*len(x) { zcap = 2 * len(x) }
z = make([]int, zlen, zcap) 
copy(z, x) // a built-in function; see text }
z[len(x)] = y
return z 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each call to appendInt must check whether the slice has sufficient capacity to hold the new elements in the existing array. If so, it extends the slice by defining a larger slice (still within the original array), copies the element y into the new space, and returns the slice. The input x and the result z share the same underlying array.&lt;/p&gt;

&lt;p&gt;If there is insufficient space for growth, appendInt must allocate a new array big enough to hold the result, copy the values from x into it, then append the new element y. The result z now refers to a different underlying array than the array that x refers to.&lt;/p&gt;

&lt;p&gt;It would be straightforward to copy the elements with explicit loops, but it’s easier to use the built-in function copy, which copies elements from one slice to another of the same type. Its first argument is the destination and its second is the source, resembling the order of operands in an assignment like dst = src . The slices may refer to the same underlying array; they may even overlap. Although we don’t use it here, copy returns the number of elements actually copied, which is the smaller of the two slice lengths, so there is no danger of running off the end or overwriting something out of range.&lt;/p&gt;

&lt;p&gt;For efficiency, the new array is usually somewhat larger than the minimum needed to hold x and y. Expanding the array by doubling its size at each expansion avoids an excessive number of allocations and ensures that appending a single element takes constant time on average. This program demonstrates the effect:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
var x, y []int 
for i := 0; i &amp;lt; 10; i++ {
y = appendInt(x, i) 
fmt.Printf(&amp;quot;%d cap=%d\t%v\n&amp;quot;, i, cap(y), y) 
x=y 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each change in capacity indicates an allocation and a copy:
0 cap=1 [0]
1 cap=2 [0 1]
2 cap=4 [0 1 2]
3 cap=4 [0 1 2 3]
4 cap=8 [0 1234]
5 cap=8 [0 12345]
6 cap=8 [0 123456]
7 cap=8 [0 1234567]
8 cap=16 [0 12345678]
9 cap=16 [0 123456789]
Let’s take a closer look at the i=3 iteration. The slice x contains the three elements
[0 1 2] but has capacity 4, so there is a single element of slack at the end, and appendInt of the element 3 may proceed without reallocating. The resulting slice y has length and capacity 4, and has the same underlying array as the original slice x, as Figure 4.2 shows.&lt;/p&gt;

&lt;p&gt;On the next iteration, i=4, there is no slack at all, so appendInt allocates a new array of size 8, copies the four elements [0 1 2 3] of x, and appends 4, the value of i. The resulting slice y has a length of 5 but a capacity of 8; the slack of 3 will save the next three iterations from the need to reallocate. The slices y and x are views of different arrays. This operation is depicted in Figure 4.3.&lt;/p&gt;

&lt;p&gt;The built-in append function may use a more sophisticated growth strategy than appendInt’s simplistic one. Usually we don’t know whether a given call to append will cause a reallocation, so we can’t assume that the original slice refers to the same array as the resulting slice, nor that it refers to a different one. Similarly, we must not assume that assignments to elements of the old slice will (or will not) be reflected in the new slice. Consequently, it’s usual to assign the result of a call to append to the same slice variable whose value we passed to append:
runes = append(runes, r)
Updating the slice variable is required not just when calling append, but for any function that may change the length or capacity of a slice or make it refer to a different underlying array. To use slices correctly, it’s important to bear in mind that although the elements of the underlying array are indirect, the slice’s pointer, length, and capacity are not. To update them requires an assignment like the one above. In this respect, slices are not “pure” reference types but resemble an aggregate type such as this struct:
type IntSlice struct {
ptr *int
len, cap int }&lt;/p&gt;

&lt;p&gt;Our appendInt function adds a single element to a slice, but the built-in append lets us add more than one new element, or even a whole slice of them.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x []int 
x = append(x, 1) 
x = append(x, 2, 3) 
x = append(x, 4, 5, 6) 
x = append(x, x...) // append the slice x 
fmt.Println(x) // &amp;quot;[1 23456123456]&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the small modification shown below, we can match the behavior of the built-in append. The ellipsis “&amp;hellip;” in the declaration of appendInt makes the function variadic: it accepts any number of final arguments. The corresponding ellipsis in the call above to append shows how to supply a list of arguments from a slice. We’ll explain this mechanism in detail in Section 5.7.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func appendInt(x []int, y ...int) []int {
var z []int 
zlen := len(x) + len(y) 
// ...expand z to at least zlen... 
copy(z[len(x):], y) 
return z 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The logic to expand z’s underlying array remains unchanged and is not shown.&lt;/p&gt;

&lt;h3 id=&#34;in-place-slice-techniques:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;In-Place Slice Techniques&lt;/h3&gt;

&lt;p&gt;Let’s see more examples of functions that, like rotate and reverse, modify the elements of a slice in place. Given a list of strings, the nonempty function returns the non-empty ones:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/nonempty 
// Nonempty is an example of an in-place slice 
algorithm.
package main 
import &amp;quot;fmt&amp;quot; 
// nonempty returns a slice holding only the non-empty 
strings.
// The underlying array is modified during the call. 
func nonempty(strings []string) []string { 

i := 0 
for _, s := range strings {

if s != &amp;quot;&amp;quot; {
strings[i] = s 
i++ 

}
}
return strings[:i] 

} 

The subtle part is that the input slice and the output slice share the same underlying array. This avoids the need to allocate another array, though of course the contents of data are partly overwritten, as evidenced by the second print statement: 

```go
data := []string{&amp;quot;one&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;three&amp;quot;} 
fmt.Printf(&amp;quot;%q\n&amp;quot;, nonempty(data)) // `[&amp;quot;one&amp;quot; 
&amp;quot;three&amp;quot;]`
fmt.Printf(&amp;quot;%q\n&amp;quot;, data) // `[&amp;quot;one&amp;quot; &amp;quot;three&amp;quot; 
&amp;quot;three&amp;quot;]` 

Thus we would usually write: data = nonempty(data) . 

The nonempty function can also be written using append: 

```go
func nonempty2(strings []string) []string { 
out := strings[:0] // zero-length slice of 
original
for _, s := range strings {
if s != &amp;quot;&amp;quot; {
out = append(out, s) 

}
}
return out 

} 
Whichever variant we use, reusing an array in this way requires that at most one output value is produced for each input value, which is true of many algorithms that filter out elements of a sequence or combine adjacent ones. Such intricate slice usage is the exception, not the rule, but it can be clear, efficient, and useful on occasion. 

A slice can be used to implement a stack. Given an initially empty slice stack, we can push a new value onto the end of the slice with append: 

```go
stack = append(stack, v) // push v 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The top of the stack is the last element:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;top := stack[len(stack)-1] // top of stack 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and shrinking the stack by popping that element is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;stack = stack[:len(stack)-1] // pop 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To remove an element from the middle of a slice, preserving the order of the remaining elements, use copy to slide the higher-numbered elements down by one to fill the gap:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func remove(slice []int, i int) []int {
copy(slice[i:], slice[i+1:]) 
return slice[:len(slice)-1] } 
func main() { 
s := []int{5, 6, 7, 8, 9} 
fmt.Println(remove(s, 2)) // &amp;quot;[5 6 8 9]&amp;quot; } 

And if we don’t need to preserve the order, we can just move the last element into the gap: 

```go
func remove(slice []int, i int) []int {
slice[i] = slice[len(slice)-1] 
return slice[:len(slice)-1] 

} 
func main() { 
s := []int{5, 6, 7, 8, 9} 
fmt.Println(remove(s, 2)) // &amp;quot;[5 6 9 8] 

} 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exercise 4.3: Rewrite reverse to use an array pointer instead of a slice.&lt;/p&gt;

&lt;p&gt;Exercise 4.4: Write a version of rotate that operates in a single pass.&lt;/p&gt;

&lt;p&gt;Exercise 4.5: Write an in-place function to eliminate adjacent duplicates in a []string slice.&lt;/p&gt;

&lt;p&gt;Exercise 4.6: Write an in-place function that squashes each run of adjacent Unicode spaces (see unicode.IsSpace) in a UTF-8-encoded []byte slice into a single ASCII space.&lt;/p&gt;

&lt;p&gt;Exercise 4.7: Modify reverse to reverse the characters of a []byte slice that represents a UTF-8-encoded string, in place. Can you do it without allocating new memory?&lt;/p&gt;

&lt;h2 id=&#34;maps:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Maps&lt;/h2&gt;

&lt;p&gt;The hash table is one of the most ingenious and versatile of all data structures. It is an unordered collection of key/value pairs in which all the keys are distinct, and the value associated with a given key can be retrieved, updated, or removed using a constant number of key comparisons on the average, no matter how large the hash table.&lt;/p&gt;

&lt;p&gt;In Go, a map is a reference to a hash table, and a map type is written map[K]V, where K and V are the types of its keys and values. All of the keys in a given map are of the same type, and all of the values are of the same type, but the keys need not be of the same type as the values. The key type K must be comparable using ==, so that the map can test whether a given key is equal to one already within it. Though floating-point numbers are comparable, it’s a bad idea to compare floats for equality and, as we mentioned in Chapter 3, especially bad if NaN is a possible value. There are no restrictions on the value type V.&lt;/p&gt;

&lt;p&gt;The built-in function make can be used to create a map:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ages := make(map[string]int) // mapping from strings to ints 

We can also use a map literal to create a new map populated with some initial key/value pairs: 
ages := map[string]int{
&amp;quot;alice&amp;quot;: 31, 
&amp;quot;charlie&amp;quot;: 34, 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ages := make(map[string]int)
ages[&amp;quot;alice&amp;quot;] = 31 
ages[&amp;quot;charlie&amp;quot;] = 34 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so an alternative expression for a new empty map is map[string]int{}.
Map elements are accessed through the usual subscript notation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ages[&amp;quot;alice&amp;quot;] = 32 
fmt.Println(ages[&amp;quot;alice&amp;quot;]) // &amp;quot;32&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and removed with the built-in function delete:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;delete(ages, &amp;quot;alice&amp;quot;) // remove element ages[&amp;quot;alice&amp;quot;] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of these operations are safe even if the element isn’t in the map; a map lookup using a key that isn’t present returns the zero value for its type, so, for instance, the following works even when &amp;ldquo;bob&amp;rdquo; is not yet a key in the map because the value of ages[&amp;ldquo;bob&amp;rdquo;] will be 0.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ages[&amp;quot;bob&amp;quot;] = ages[&amp;quot;bob&amp;quot;] + 1 // happy birthday! The shorthand assignment forms x += y and x++ also work for map elements, so we can rewrite the statement above as 
ages[&amp;quot;bob&amp;quot;] += 1 
or even more concisely as 
ages[&amp;quot;bob&amp;quot;]++ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But a map element is not a variable, and we cannot take its address:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;_ = &amp;amp;ages[&amp;quot;bob&amp;quot;] // compile error: cannot take address 
of map element 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One reason that we can’t take the address of a map element is that growing a map might cause rehashing of existing elements into new storage locations, thus potentially invalidating the address.&lt;/p&gt;

&lt;p&gt;To enumerate all the key/value pairs in the map, we use a range-based for loop similar to those we saw for slices. Successive iterations of the loop cause the name and age variables to be set to the next key/value pair:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for name, age := range ages { 
fmt.Printf(&amp;quot;%s\t%d\n&amp;quot;, name, age) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The order of map iteration is unspecified, and different implementations might use a different hash function, leading to a different ordering. In practice, the order is random, varying from one execution to the next. This is intentional; making the sequence vary helps force programs to be robust across implementations. To enumerate the key/value pairs in order, we must sort the keys explicitly, for instance, using the Strings function from the sort package if the keys are strings. This is a common pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;sort&amp;quot; 
var names []string 
for name := range ages {

names = append(names, name) 
}
sort.Strings(names)
for _, name := range names {

fmt.Printf(&amp;quot;%s\t%d\n&amp;quot;, name, ages[name]) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we know the final size of names from the outset, it is more efficient to allocate an array of the required size up front. The statement below creates a slice that is initially empty but has sufficient capacity to hold all the keys of the ages map:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;names := make([]string, 0, len(ages)) 
In the first range loop above, we require only the keys of the ages map, so we omit the second loop variable. In the second loop, we require only the elements of the names slice, so we use the blank identifier _ to ignore the first variable, the index. 

The zero value for a map type is nil, that is, a reference to no hash table at all. 

```go
var ages map[string]int
fmt.Println(ages == nil) // &amp;quot;true&amp;quot; 
fmt.Println(len(ages) == 0) // &amp;quot;true&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most operations on maps, including lookup, delete, len, and range loops, are safe to perform on a nil map reference, since it behaves like an empty map. But storing to a nil map causes a panic:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ages[&amp;quot;carol&amp;quot;] = 21 // panic: assignment to entry in 
nil map 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You must allocate the map before you can store into it.
Accessing a map element by subscripting always yields a value. If the key is present in the map, you get the corresponding value; if not, you get the zero value for the element type, as we saw with ages[&amp;ldquo;bob&amp;rdquo;]. For many purposes that’s fine, but sometimes you need to know whether the element was really there or not. For example, if the element type is numeric, you might have to distinguish between a nonexistent element and an element that happens to have the value zero, using a test like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;age, ok := ages[&amp;quot;bob&amp;quot;] 
if !ok { /* &amp;quot;bob&amp;quot; is not a key in this map; age == 0. 
*/ } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You’ll often see these two statements combined, like this:
if age, ok := ages[&amp;ldquo;bob&amp;rdquo;]; !ok { /* &amp;hellip; */ }
Subscripting a map in this context yields two values; the second is a boolean that reports whether the element was present. The boolean variable is often called ok, especially if it is immediately used in an if condition.&lt;/p&gt;

&lt;p&gt;As with slices, maps cannot be compared to each other; the only legal comparison is with nil. To test whether two maps contain the same keys and the same associated values, we must write a loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func equal(x, y map[string]int) bool {
if len(x) != len(y) { 
return false 
}
for k, xv := range x { 
if yv, ok := y[k]; !ok || yv != xv {return false 
}
}
return true 

} 
Observe how we use !ok to distinguish the “missing” and “present but zero” cases. Had we naïvely written xv != y[k] , the call below would incorrectly report its arguments as equal: 

```go
// True if equal is written incorrectly. equal(map[string]int{&amp;quot;A&amp;quot;: 0}, map[string]int{&amp;quot;B&amp;quot;: 42}) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go does not provide a set type, but since the keys of a map are distinct, a map can serve this purpose. To illustrate, the program dedup reads a sequence of lines and prints only the first occurrence of each distinct line. (It’s a variant of the dup program that we showed in Section 1.3.) The dedup program uses a map whose keys represent the set of lines that have already appeared to ensure that subsequent occurrences are not printed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/dedup 
func main() {seen := make(map[string]bool) // a set of strings 
    input := bufio.NewScanner(os.Stdin) for input.Scan() {
        line := input.Text() 
        if !seen[line] {
        seen[line] = true 
        fmt.Println(line) 

        }
    } 

    if err := input.Err(); err != nil {
        fmt.Fprintf(os.Stderr, &amp;quot;dedup: %v\n&amp;quot;, err) os.Exit(1) 
    }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go programmers often describe a map used in this fashion as a “set of strings” without further ado, but beware, not all map[string]bool values are simple sets; some may contain both true and false values.&lt;/p&gt;

&lt;p&gt;Sometimes we need a map or set whose keys are slices, but because a map’s keys must be comparable, this cannot be expressed directly. However, it can be done in two steps. First we define a helper function k that maps each key to a string, with the property that k(x) == k(y) if and only if we consider x and y equivalent. Then we create a map whose keys are strings, applying the helper function to each key before we access the map.&lt;/p&gt;

&lt;p&gt;The example below uses a map to record the number of times Add has been called with a given list of strings. It uses fmt.Sprintf to convert a slice of strings into a single string that is a suitable map key, quoting each slice element with %q to record string boundaries faithfully:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var m = make(map[string]int) 
func k(list []string) string { return 
fmt.Sprintf(&amp;quot;%q&amp;quot;, list) } 
func Add(list []string) { m[k(list)]++ }
func Count(list []string) int { return m[k(list)] } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same approach can be used for any non-comparable key type, not just slices. It’s even useful for comparable key types when you want a definition of equality other than ==, such as case-insensitive comparisons for strings. And the type of k(x)needn’t be a string; any comparable type with the desired equivalence property will do, such as integers, arrays, or structs.&lt;/p&gt;

&lt;p&gt;Here’s another example of maps in action, a program that counts the occurrences of each distinct Unicode code point in its input. Since there are a large number of possible characters, only a small fraction of which would appear in any particular document, a map is a natural way to keep track of just the ones that have been seen and their corresponding counts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/charcount 
// Charcount computes counts of Unicode characters. package main 
import (
&amp;quot;bufio&amp;quot; 
&amp;quot;fmt&amp;quot; 
&amp;quot;io&amp;quot; 
&amp;quot;os&amp;quot; 
&amp;quot;unicode&amp;quot; 
&amp;quot;unicode/utf8&amp;quot; ) 
func main() {
counts := make(map[rune]int) // counts of 
Unicode characters 
var utflen [utf8.UTFMax + 1]int // count of lengths of UTF-8 encodings 
invalid := 0 // count of invalid UTF-8 characters 

in := bufio.NewReader(os.Stdin) 
for {
r, n, err := in.ReadRune() // returns rune, nbytes, error 
if err == io.EOF {
break 
}
if err != nil {
fmt.Fprintf(os.Stderr, &amp;quot;charcount: %v\n&amp;quot;, err) 
os.Exit(1) 
}
if r == unicode.ReplacementChar &amp;amp;&amp;amp; n == 1 {
invalid++ 
continue 
}
counts[r]++
utflen[n]++ 
}
fmt.Printf(&amp;quot;rune\tcount\n&amp;quot;)
for c, n := range counts {
fmt.Printf(&amp;quot;%q\t%d\n&amp;quot;, c, n) 
}
fmt.Print(&amp;quot;\nlen\tcount\n&amp;quot;)
for i, n := range utflen {
if i &amp;gt; 0 {fmt.Printf(&amp;quot;%d\t%d\n&amp;quot;, i, n) 
}
}
if invalid &amp;gt; 0 {

fmt.Printf(&amp;quot;\n%d invalid UTF-8 characters\n&amp;quot;, invalid)}} 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The ReadRune method performs UTF-8 decoding and returns three values: the decoded rune, the length in bytes of its UTF-8 encoding, and an error value. The only error we expect is end-of-file. If the input was not a legal UTF-8 encoding of a rune, the returned rune is unicode.ReplacementChar and the length is 1.&lt;/p&gt;

&lt;p&gt;The charcount program also prints a count of the lengths of the UTF-8 encodings of the runes that appeared in the input. A map is not the best data structure for that; since encoding lengths range only from 1 to utf8.UTFMax (which has the value 4), an array is more compact.&lt;/p&gt;

&lt;p&gt;As an experiment, we ran charcount on this book itself at one point. Although it’s mostly in English, of course, it does have a fair number of non-ASCII characters. Here are the top ten:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;°27 
15 
14 é13 x10 =5×5 

## 

3 
and here is the distribution of the lengths of all the UTF-8 encodings: 
len count 
1 765391 
2 60 
3 70 

40 

The value type of a map can itself be a composite type, such as a map or slice. In the following code, the key type of graph is string and the value type is map[string]bool, representing a set of strings. Conceptually, graph maps a string to a set of related strings, its successors in a directed graph. 

```go
// gopl.io/ch4/graph 
var graph = make(map[string]map[string]bool) 
func addEdge(from, to string) { 
edges := graph[from] 
if edges == nil {
edges = make(map[string]bool)
graph[from] = edges }
edges[to] = true } 
func hasEdge(from, to string) bool {
return graph[from][to] 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The addEdge function shows the idiomatic way to populate a map lazily, that is, to initialize each value as its key appears for the first time. The hasEdge function shows how the zero value of a missing map entry is often put to work: even if neither from nor to is present, graph[from][to] will always give a meaningful result.&lt;/p&gt;

&lt;p&gt;Exercise 4.8: Modify charcount to count letters, digits, and so on in their Unicode categories, using functions like unicode.IsLetter.&lt;/p&gt;

&lt;p&gt;Exercise 4.9: Write a program wordfreq to report the frequency of each word in an input text file. Call input.Split(bufio.ScanWords) before the first call to Scan to break the input into words instead of lines.&lt;/p&gt;

&lt;h2 id=&#34;structs:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Structs&lt;/h2&gt;

&lt;p&gt;A struct is an aggregate data type that groups together zero or more named values of arbitrary types as a single entity. Each value is called a field. The classic example of a struct from data processing is the employee record, whose fields are a unique ID, the employee’s name, address, date of birth, position, salary, manager, and the like. All of these fields are collected into a single entity that can be copied as a unit, passed to functions and returned by them, stored in arrays, and so on.
These two statements declare a struct type called Employee and a variable called dilbert that is an instance of an Employee:
type Employee struct {
ID int
Name string
Address string
DoB time.Time
Position string
Salary int
ManagerID int&lt;/p&gt;

&lt;p&gt;}
var dilbert Employee&lt;/p&gt;

&lt;p&gt;The individual fields of dilbert are accessed using dot notation like dilbert.Name and dilbert.DoB. Because dilbert is a variable, its fields are variables too, so we may assign to a field:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;dilbert.Salary -= 5000 // demoted, for writing too few lines of code 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or take its address and access it through a pointer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;position := &amp;amp;dilbert.Position 
*position = &amp;quot;Senior &amp;quot; + *position // promoted, for outsourcing to Elbonia 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The dot notation also works with a pointer to a struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var employeeOfTheMonth *Employee = &amp;amp;dilbert 
employeeOfTheMonth.Position += &amp;quot; (proactive team 
player)&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last statement is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;(*employeeOfTheMonth).Position += &amp;quot; (proactive team player)&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given an employee’s unique ID, the function EmployeeByID returns a pointer to an Employee struct. We can use the dot notation to access its fields:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func EmployeeByID(id int) *Employee { /* ... */ } 
fmt.Println(EmployeeByID(dilbert.ManagerID).Position)// &amp;quot;Pointy-haired boss&amp;quot; 
id := dilbert.ID EmployeeByID(id).Salary = 0 // fired for... no real reason 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last statement updates the Employee struct that is pointed to by the result of the call to EmployeeByID. If the result type of EmployeeByID were changed to Employee instead of *Employee, the assignment statement would not compile since its left-hand side would not identify a variable.&lt;/p&gt;

&lt;p&gt;Fields are usually written one per line, with the field’s name preceding its type, but consecutive fields of the same type may be combined, as with Name and Address here:
type Employee struct {
ID int
Name, Address string
DoB time.Time
Position string&lt;/p&gt;

&lt;p&gt;Salary int
ManagerID int
}&lt;/p&gt;

&lt;p&gt;Field order is significant to type identity. Had we also combined the declaration of the Position field (also a string), or interchanged Name and Address, we would be defining a different struct type. Typically we only combine the declarations of related fields.&lt;/p&gt;

&lt;p&gt;The name of a struct field is exported if it begins with a capital letter; this is Go’s main access control mechanism. A struct type may contain a mixture of exported and unexported fields.&lt;/p&gt;

&lt;p&gt;Struct types tend to be verbose because they often involve a line for each field. Although we could write out the whole type each time it is needed, the repetition would get tiresome. Instead, struct types usually appear within the declaration of a named type like Employee.&lt;/p&gt;

&lt;p&gt;A named struct type S can’t declare a field of the same type S: an aggregate value cannot contain itself. (An analogous restriction applies to arrays.) But S may declare a field of the pointer type *S, which lets us create recursive data structures like linked lists and trees. This is illustrated in the code below, which uses a binary tree to implement an insertion sort:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/treesort 

type tree struct {
value int 
left, right *tree } 
// Sort sorts values in place. 
func Sort(values []int) { 
var root *tree 
for _, v := range values {
root = add(root, v) }
appendValues(values[:0], root) } // appendValues appends the elements of t to values in 
order 
// and returns the resulting slice. 
func appendValues(values []int, t *tree) []int {
if t != nil {
values = appendValues(values, t.left) 
values = append(values, t.value) 
values = appendValues(values, t.right) 
}
return values 
} 
func add(t *tree, value int) *tree {
if t == nil {
// Equivalent to return &amp;amp;tree{value: value}. 
t = new(tree)
t.value = value 
return t 
}
if value &amp;lt; t.value {
t.left = add(t.left, value) 
} else {
t.right = add(t.right, value) }
return t 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The zero value for a struct is composed of the zero values of each of its fields. It is usually desirable that the zero value be a natural or sensible default. For example, in bytes.Buffer, the initial value of the struct is a ready-to-use empty buffer, and the zero value of sync.Mutex, which we’ll see in Chapter 9, is a ready-to-use unlocked mutex. Sometimes this sensible initial behavior happens for free, but sometimes the type designer has to work at it.&lt;/p&gt;

&lt;p&gt;The struct type with no fields is called the empty struct, written struct{}. It has size zero and carries no information but may be useful nonetheless. Some Go programmers use it instead of bool as the value type of a map that represents a set, to emphasize that only the keys are significant, but the space saving is marginal and the syntax more cumbersome, so we generally avoid it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;seen := make(map[string]struct{}) // set of strings 
// ... 
if _, ok := seen[s]; !ok {
seen[s] = struct{}{} 
// ...first time seeing s... 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;struct-literals:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Struct Literals&lt;/h3&gt;

&lt;p&gt;A value of a struct type can be written using a struct literal that specifies values for its fields.
type Point struct{ X, Y int }
p := Point{1, 2}&lt;/p&gt;

&lt;p&gt;There are two forms of struct literal. The first form, shown above, requires that a value be specified for every field, in the right order. It burdens the writer (and reader) with remembering exactly what the fields are, and it makes the code fragile should the set of fields later grow or be reordered. Accordingly, this form tends to be used only within the package that defines the struct type, or with smaller struct types for which there is an obvious field ordering convention, like image.Point{x, y} or color.RGBA{red, green, blue, alpha} .
More often, the second form is used, in which a struct value is initialized by listing some or all of the field names and their corresponding values, as in this statement from the Lissajous program of Section 1.4:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;anim := gif.GIF{LoopCount: nframes} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If a field is omitted in this kind of literal, it is set to the zero value for its type. Because names are provided, the order of fields doesn’t matter.&lt;/p&gt;

&lt;p&gt;The two forms cannot be mixed in the same literal. Nor can you use the (order­based) first form of literal to sneak around the rule that unexported identifiers may not be referred to from another package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package ptype T struct{ a, b int } // a and b are not exported 
package q
import &amp;quot;p&amp;quot; 
var _ = p.T{a: 1, b: 2} // compile error: can&#39;t 
reference a, b 
var _ = p.T{1, 2} // compile error: can&#39;t 
reference a, b 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the last line above doesn’t mention the unexported field identifiers, it’s really using them implicitly, so it’s not allowed.
Struct values can be passed as arguments to functions and returned from them. For instance, this function scales a Point by a specified factor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Scale(p Point, factor int) Point {
return Point{p.X * factor, p.Y * factor} 
} 

fmt.Println(Scale(Point{1, 2}, 5)) // &amp;quot;{5 10}&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For efficiency, larger struct types are usually passed to or returned from functions indirectly using a pointer,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Bonus(e *Employee, percent int) int {
return e.Salary * percent / 100 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and this is required if the function must modify its argument, since in a call-by-value language like Go, the called function receives only a copy of an argument, not a reference to the original argument.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func AwardAnnualRaise(e *Employee) { 
e.Salary = e.Salary * 105 / 100 

} 

Because structs are so commonly dealt with through pointers, it’s possible to use this shorthand notation to create and initialize a struct variable and obtain its address: 
pp := &amp;amp;Point{1, 2} 

It is exactly equivalent to 
pp := new(Point) 
*pp = Point{1, 2} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but &amp;amp;Point{1, 2} can be used directly within an expression, such as a function call.&lt;/p&gt;

&lt;h3 id=&#34;comparing-structs:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Comparing Structs&lt;/h3&gt;

&lt;p&gt;If all the fields of a struct are comparable, the struct itself is comparable, so two expressions of that type may be compared using == or !=. The == operation compares the corresponding fields of the two structs in order, so the two printed expressions below are equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Point struct{ X, Y int } 
p := Point{1, 2} 
q := Point{2, 1}
fmt.Println(p.X == q.X &amp;amp;&amp;amp; p.Y == q.Y) // &amp;quot;false&amp;quot; 
fmt.Println(p == q) // &amp;quot;false&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comparable struct types, like other comparable types, may be used as the key type of a map.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type address struct {
hostname string 
port int 

} 

hits := make(map[address]int) hits[address{&amp;quot;golang.org&amp;quot;, 443}]++ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;struct-embedding-and-anonymous-fields:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Struct Embedding and Anonymous Fields&lt;/h3&gt;

&lt;p&gt;In this section, we’ll see how Go’s unusual struct embedding mechanism lets us use one named struct type as an anonymous field of another struct type, providing a convenient syntactic shortcut so that a simple dot expression like x.f can stand for a chain of fields like x.d.e.f.
Consider a 2-D drawing program that provides a library of shapes, such as rectangles, ellipses, stars, and wheels. Here are two of the types it might define:
type Circle struct {
X, Y, Radius int
}&lt;/p&gt;

&lt;p&gt;type Wheel struct {
X, Y, Radius, Spokes int
}&lt;/p&gt;

&lt;p&gt;A Circle has fields for the X and Y coordinates of its center, and a Radius.A Wheel has all the features of a Circle, plus Spokes, the number of inscribed radial spokes. Let’s create a wheel:
var w Wheel
w.X = 8
w.Y = 8
w.Radius = 5
w.Spokes = 20&lt;/p&gt;

&lt;p&gt;As the set of shapes grows, we’re bound to notice similarities and repetition among them, so it may be convenient to factor out their common parts:
type Point struct {
X, Y int
}&lt;/p&gt;

&lt;p&gt;type Circle struct {
Center Point
Radius int&lt;/p&gt;

&lt;p&gt;}
type Wheel struct {
Circle Circle
Spokes int&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

The application may be clearer for it, but this change makes accessing the fields of a Wheel more verbose: 
var w Wheel 
w.Circle.Center.X = 8 
w.Circle.Center.Y = 8 
w.Circle.Radius = 5 
w.Spokes = 20 


Go lets us declare a field with a type but no name; such fields are called anonymous fields. The type of the field must be a named type or a pointer to a named type. Below, Circle and Wheel have one anonymous field each. We say that a Point is embedded within Circle, and a Circle is embedded within Wheel. 
type Circle struct {
Point 
Radius int 

} 
type Wheel struct {
Circle 
Spokes int 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to embedding, we can refer to the names at the leaves of the implicit tree without giving the intervening names:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var w Wheel 
w.X = 8 // equivalent to w.Circle.Point.X = 8 
w.Y = 8 // equivalent to w.Circle.Point.Y = 8 
w.Radius = 5 // equivalent to w.Circle.Radius = 5 w.Spokes = 20 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The explicit forms shown in the comments above are still valid, however, showing that “anonymous field” is something of a misnomer. The fields Circle and Point do have names—that of the named type—but those names are optional in dot expressions. We may omit any or all of the anonymous fields when selecting their subfields.
Unfortunately, there’s no corresponding shorthand for the struct literal syntax, so neither of these will compile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;w = Wheel{8, 8, 5, 20} // 
compile error: unknown fields 
w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // 
compile error: unknown fields 


The struct literal must follow the shape of the type declaration, so we must use one of the two forms below, which are equivalent to each other: 

```go
// gopl.io/ch4/embed 
w = Wheel{Circle{Point{8, 8}, 5}, 20} 
w = Wheel{
Circle: Circle{
Point: Point{X: 8, Y: 8}, 
Radius: 5, 

},
Spokes: 20, // NOTE: trailing comma necessary here (and at Radius) } 
fmt.Printf(&amp;quot;%#v\n&amp;quot;, w) 
// Output: 
// Wheel{Circle:Circle{Point:Point{X:8, Y:8}, 
Radius:5}, Spokes:20} 

w.X = 42 
fmt.Printf(&amp;quot;%#v\n&amp;quot;, w) 
// Output: 

// Wheel{Circle:Circle{Point:Point{X:42, Y:8}, 
Radius:5}, Spokes:20} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how the # adverb causes Printf’s %v verb to display values in a form similar to Go syntax. For struct values, this form includes the name of each field.&lt;/p&gt;

&lt;p&gt;Because “anonymous” fields do have implicit names, you can’t have two anonymous fields of the same type since their names would conflict. And because the name of the field is implicitly determined by its type, so too is the visibility of the field. In the examples above, the Point and Circle anonymous fields are exported. Had they been unexported (point and circle), we could still use the shorthand form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;w.X = 8 // equivalent to w.circle.point.X = 8 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but the explicit long form shown in the comment would be forbidden outside the declaring package because circle and point would be inaccessible.&lt;/p&gt;

&lt;p&gt;What we’ve seen so far of struct embedding is just a sprinkling of syntactic sugar on the dot notation used to select struct fields. Later, we’ll see that anonymous fields need not be struct types; any named type or pointer to a named type will do. But why would you want to embed a type that has no subfields?&lt;/p&gt;

&lt;p&gt;The answer has to do with methods. The shorthand notation used for selecting the fields of an embedded type works for selecting its methods as well. In effect, the outer struct type gains not just the fields of the embedded type but its methods too. This mechanism is the main way that complex object behaviors are composed from simpler ones. Composition is central to object-oriented programming in Go, and we’ll explore it further in Section 6.3.&lt;/p&gt;

&lt;h2 id=&#34;json:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;JSON&lt;/h2&gt;

&lt;p&gt;JavaScript Object Notation (JSON) is a standard notation for sending and receiving structured information. JSON is not the only such notation. XML (§7.14), ASN.1, and Google’s Protocol Buffers serve similar purposes and each has its niche, but because of its simplicity, readability, and universal support, JSON is the most widely used.&lt;/p&gt;

&lt;p&gt;Gohas excellent support for encoding and decoding these formats, provided by the standard library packages encoding/json, encoding/xml, encoding/asn1, and so on, and these packages all have similar APIs. This section gives a brief overview of the most important parts of the encoding/json package.&lt;/p&gt;

&lt;p&gt;JSON is an encoding of JavaScript values—strings, numbers, booleans, arrays, and objects—as Unicode text. It’s an efficient yet readable representation for the basic data types of Chapter 3 and the composite types of this chapter—arrays, slices, structs, and maps.&lt;/p&gt;

&lt;p&gt;The basic JSON types are numbers (in decimal or scientific notation), booleans (true or false), and strings, which are sequences of Unicode code points enclosed in double quotes, with backslash escapes using a similar notation to Go, though JSON’s \Uhhhh numeric escapes denote UTF-16 codes, not runes.
These basic types may be combined recursively using JSON arrays and objects. A JSON array is an ordered sequence of values, written as a comma-separated list enclosed in square brackets; JSON arrays are used to encode Go arrays and slices. A JSON object is a mapping from strings to values, written as a sequence of name:value pairs separated by commas and surrounded by braces; JSON objects are used to encode Go maps (with string keys) and structs. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;boolean number string  true -273.15 &amp;quot;She said  \&amp;quot;Hello,  \&amp;quot;&amp;quot;  

array [&amp;quot;gold&amp;quot;, &amp;quot;silver&amp;quot;, &amp;quot;bronze&amp;quot;] 

object {&amp;quot;year&amp;quot;: 1980, &amp;quot;event&amp;quot;: &amp;quot;archery&amp;quot;, 
&amp;quot;medals&amp;quot;: [&amp;quot;gold&amp;quot;, &amp;quot;silver&amp;quot;, 
&amp;quot;bronze&amp;quot;]} 

Consider an application that gathers movie reviews and offers recommendations. Its Movie data type and a typical list of values are declared below. (The string literals after the Year and Color field declarations are field tags; we’ll explain them in a moment.) 

```go
// gopl.io/ch4/movie 
type Movie struct {
Title string 
Year int `json:&amp;quot;released&amp;quot;` 
Color bool `json:&amp;quot;color,omitempty&amp;quot;` 
Actors []string 

} 
var movies = []Movie{ {Title: &amp;quot;Casablanca&amp;quot;, Year: 1942, Color: false, Actors: []string{&amp;quot;Humphrey Bogart&amp;quot;, &amp;quot;Ingrid Bergman&amp;quot;}},{Title: &amp;quot;Cool Hand Luke&amp;quot;, Year: 1967, Color: true, Actors: []string{&amp;quot;Paul Newman&amp;quot;}}, {Title: &amp;quot;Bullitt&amp;quot;, Year: 1968, Color: true, Actors: []string{&amp;quot;Steve McQueen&amp;quot;, &amp;quot;Jacqueline Bisset&amp;quot;}},// ... } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Data structures like this are an excellent fit for JSON, and it’s easy to convert in both directions. Converting a Go data structure like movies to JSON is called marshaling. Marshaling is done by json.Marshal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;data, err := json.Marshal(movies) 
if err != nil {

log.Fatalf(&amp;quot;JSON marshaling failed: %s&amp;quot;, err) 
}
fmt.Printf(&amp;quot;%s\n&amp;quot;, data) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Marshal produces a byte slice containing a very long string with no extraneous white space; we’ve folded the lines so it fits:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;[{&amp;quot;Title&amp;quot;:&amp;quot;Casablanca&amp;quot;,&amp;quot;released&amp;quot;:1942,&amp;quot;Actors&amp;quot;:
[&amp;quot;Humphrey Bogart&amp;quot;,&amp;quot;Ingr 
id Bergman&amp;quot;]},{&amp;quot;Title&amp;quot;:&amp;quot;Cool Hand 
Luke&amp;quot;,&amp;quot;released&amp;quot;:1967,&amp;quot;color&amp;quot;:true,&amp;quot;Ac
tors&amp;quot;:[&amp;quot;Paul Newman&amp;quot;]},
{&amp;quot;Title&amp;quot;:&amp;quot;Bullitt&amp;quot;,&amp;quot;released&amp;quot;:1968,&amp;quot;color&amp;quot;:true,&amp;quot;
Actors&amp;quot;:[&amp;quot;Steve McQueen&amp;quot;,&amp;quot;Jacqueline Bisset&amp;quot;]}] 

This compact representation contains all the information but it’s hard to read. For human consumption, a variant called json.MarshalIndent produces neatly indented output. Two additional arguments define a prefix for each line of output and a string for each level of indentation: 

```go
data, err := json.MarshalIndent(movies, &amp;quot;&amp;quot;, &amp;quot; &amp;quot;) if err != nil {
log.Fatalf(&amp;quot;JSON marshaling failed: %s&amp;quot;, err) 
}
fmt.Printf(&amp;quot;%s\n&amp;quot;, data) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above prints&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;[ 
{ 
&amp;quot;Title&amp;quot;: &amp;quot;Casablanca&amp;quot;,
&amp;quot;released&amp;quot;: 1942, 
&amp;quot;Actors&amp;quot;: [

&amp;quot;Humphrey Bogart&amp;quot;, &amp;quot;Ingrid Bergman&amp;quot; 
]
},
{ 

&amp;quot;Title&amp;quot;: &amp;quot;Cool Hand Luke&amp;quot;, 
&amp;quot;released&amp;quot;: 1967, 

&amp;quot;color&amp;quot;: true, 
&amp;quot;Actors&amp;quot;: [
&amp;quot;Paul Newman&amp;quot; 
]},
{ &amp;quot;Title&amp;quot;: &amp;quot;Bullitt&amp;quot;,
&amp;quot;released&amp;quot;: 1968, 
&amp;quot;color&amp;quot;: true, 
&amp;quot;Actors&amp;quot;: [
&amp;quot;Steve McQueen&amp;quot;,
&amp;quot;Jacqueline Bisset&amp;quot; ]}] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Marshaling uses the Go struct field names as the field names for the JSON objects (through reflection, as we’ll see in Section 12.6). Only exported fields are marshaled, which is why we chose capitalized names for all the Go field names.&lt;/p&gt;

&lt;p&gt;You may have noticed that the name of the Year field changed to released in the output, and Color changed to color. That’s because of the field tags. A field tag is a string of metadata associated at compile time with the field of a struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
Year int `json:&amp;quot;released&amp;quot;` 
Color bool `json:&amp;quot;color,omitempty&amp;quot;` 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A field tag may be any literal string, but it is conventionally interpreted as a space-separated list of key:&amp;ldquo;value&amp;rdquo; pairs; since they contain double quotation marks, field tags are usually written with raw string literals. The json key controls the behavior of the encoding/json package, and other encoding/&amp;hellip; packages follow this convention. The first part of the json field tag specifies an alternative JSON name for the Go field. Field tags are often used to specify an idiomatic JSON name like total_count for a Go field named TotalCount. The tag for Color has an additional option, omitempty, which indicates that no JSON output should be produced if the field has the zero value for its type (false, here) or is otherwise empty. Sure enough, the JSON output for Casablanca, a black-and-white movie, has no color field.&lt;/p&gt;

&lt;p&gt;The inverse operation to marshaling, decoding JSON and populating a Go data structure, is called unmarshaling, and it is done by json.Unmarshal. The code below unmarshals the JSON movie data into a slice of structs whose only field is Title. By defining suitable Go data structures in this way, we can select which parts of the JSON input to decode and which to discard. When Unmarshal returns, it has filled in the slice with the Title information; other names in the JSON are ignored.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var titles []struct{ Title string } 
if err := json.Unmarshal(data, &amp;amp;titles); err != nil {

log.Fatalf(&amp;quot;JSON unmarshaling failed: %s&amp;quot;, err) }fmt.Println(titles) // &amp;quot;[{Casablanca} {Cool Hand Luke} {Bullitt}]&amp;quot; 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Many web services provide a JSON interface—make a request with HTTP and back comes the desired information in JSON format. To illustrate, let’s query the GitHub issue tracker using its web-service interface. First we’ll define the necessary types and constants:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/github 
// Package github provides a Go API for the GitHub issue tracker. // See https://developer.github.com/v3/search/#search­issues. package github 
import &amp;quot;time&amp;quot; 
const IssuesURL = 
&amp;quot;https://api.github.com/search/issues&amp;quot; 

type IssuesSearchResult struct {

TotalCount int `json:&amp;quot;total_count&amp;quot;` 

Items []*Issue 

} 
type Issue struct {

Number  int  
HTMLURL Title State User  string `json:&amp;quot;html_url&amp;quot;` string string *User  
CreatedAt Body  time.Time string  `json:&amp;quot;created_at&amp;quot;` // in Markdown format  

} 
type User struct {Login string HTMLURL string `json:&amp;quot;html_url&amp;quot;` 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As before, the names of all the struct fields must be capitalized even if their JSON names are not. However, the matching process that associates JSON names with Go struct names during unmarshaling is case-insensitive, so it’s only necessary to use a field tag when there’s an underscore in the JSON name but not in the Go name. Again, we are being selective about which fields to decode; the GitHub search response contains considerably more information than we show here.&lt;/p&gt;

&lt;p&gt;The SearchIssues function makes an HTTP request and decodes the result as JSON. Since the query terms presented by a user could contain characters like ? and &amp;amp; that have special meaning in a URL, we use url.QueryEscape to ensure that they are taken literally.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/github 
package github 
import (&amp;quot;encoding/json&amp;quot;&amp;quot;fmt&amp;quot; &amp;quot;net/http&amp;quot;&amp;quot;net/url&amp;quot;&amp;quot;strings&amp;quot; 
) 
// SearchIssues queries the GitHub issue tracker. 
func SearchIssues(terms []string) 
(*IssuesSearchResult, error) { 

q := url.QueryEscape(strings.Join(terms, &amp;quot; &amp;quot;)) resp, err := http.Get(IssuesURL + &amp;quot;?q=&amp;quot; + q) if err != nil {
return nil, err 
} 

// We must close resp.Body on all execution paths. // (Chapter 5 presents &#39;defer&#39;, which makes this simpler.)
if resp.StatusCode != http.StatusOK {resp.Body.Close()return nil, fmt.Errorf(&amp;quot;search query failed: 
%s&amp;quot;, resp.Status) 
} 

var result IssuesSearchResult 
if err := json.NewDecoder(resp.Body).Decode(&amp;amp;result); err != nil { 
resp.Body.Close()
return nil, err 
}
resp.Body.Close()
return &amp;amp;result, nil 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The earlier examples used json.Unmarshal to decode the entire contents of a byte slice as a single JSON entity. For variety, this example uses the streaming decoder, json.Decoder, which allows several JSON entities to be decoded in sequence from the same stream, although we don’t need that feature here. As you might expect, there is a corresponding streaming encoder called json.Encoder.&lt;/p&gt;

&lt;p&gt;The call to Decode populates the variable result. There are various ways we can format its value nicely. The simplest, demonstrated by the issues command below, is as a text table with fixed-width columns, but in the next section we’ll see a more sophisticated approach based on templates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/issues 
// Issues prints a table of GitHub issues matching the search terms. package main 
import (
&amp;quot;fmt&amp;quot; 
&amp;quot;log&amp;quot;
&amp;quot;os&amp;quot; 

&amp;quot;// gopl.io/ch4/github&amp;quot; 
) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;func main() {result, err := github.SearchIssues(os.Args[1:]) if err != nil {
log.Fatal(err) }fmt.Printf(&amp;ldquo;%d issues:\n&amp;rdquo;, result.TotalCount) for _, item := range result.Items {
fmt.Printf(&amp;ldquo;#%-5d %9.9s %.55s\n&amp;rdquo;, item.Number, item.User.Login, item.Title) }}&lt;/p&gt;

&lt;p&gt;The command-line arguments specify the search terms. The command below queries the Go project’s issue tracker for the list of open bugs related to JSON decoding:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch4/issues 
$ ./issues repo:golang/go is:open json decoder 13 issues: #5680 eaigner encoding/json: set key converter on en/decoder#6050 gopherbot encoding/json: provide tokenizer #8658 gopherbot encoding/json: use bufio #8462 kortschak encoding/json: UnmarshalText confuses json.Unmarshal#5901 rsc encoding/json: allow override type marshaling#9812 klauspost encoding/json: string tag not symmetric#7872 extempora encoding/json: Encoder internally buffers full output #9650 cespare encoding/json: Decoding gives errPhase when unmarshalin #6716 gopherbot encoding/json: include field name in unmarshal error me #6901 lukescott encoding/json, encoding/xml: option to treat unknown fi #6384 joeshaw encoding/json: encode precise floating point integers u #6647 btracey x/tools/cmd/godoc: display type kind of each named type #4237 gjemiller encoding/base64: URLEncoding padding is optional 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The GitHub web-service interface at &lt;a href=&#34;https://developer.github.com/v3/&#34;&gt;https://developer.github.com/v3/&lt;/a&gt; has many more features than we have space for here.&lt;/p&gt;

&lt;p&gt;Exercise 4.10: Modify issues to report the results in age categories, say less than a month old, less than a year old, and more than a year old.&lt;/p&gt;

&lt;p&gt;Exercise 4.11: Build a tool that lets users create, read, update, and delete GitHub issues from the command line, invoking their preferred text editor when substantial text input is required.&lt;/p&gt;

&lt;p&gt;Exercise 4.12: The popular web comic xkcd has a JSON interface. For example, a request to &lt;a href=&#34;https://xkcd.com/571/info.0.json&#34;&gt;https://xkcd.com/571/info.0.json&lt;/a&gt; produces a detailed description of comic 571, one of many favorites. Download each URL (once!) and build an offline index. Write a tool xkcd that, using this index, prints the URL and transcript of each comic that matches a search term provided on the command line.&lt;/p&gt;

&lt;p&gt;Exercise 4.13: The JSON-based web service of the Open Movie Database lets you search &lt;a href=&#34;https://omdbapi.com/&#34;&gt;https://omdbapi.com/&lt;/a&gt; for a movie by name and download its poster image. Write a tool poster that downloads the poster image for the movie named on the command line.&lt;/p&gt;

&lt;h2 id=&#34;text-and-html-templates:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Text and HTML Templates&lt;/h2&gt;

&lt;p&gt;The previous example does only the simplest possible formatting, for which Printf is entirely adequate. But sometimes formatting must be more elaborate, and it’s desirable to separate the format from the code more completely. This can be done with the text/template and html/template packages, which provide a mechanism for substituting the values of variables into a text or HTML template.&lt;/p&gt;

&lt;p&gt;A template is a string or file containing one or more portions enclosed in double braces, {{&amp;hellip;}}, called actions. Most of the string is printed literally, but the actions trigger other behaviors. Each action contains an expression in the template language, a simple but powerful notation for printing values, selecting struct fields, calling functions and methods, expressing control flow such as if-else statements and range loops, and instantiating other templates. A simple template string is shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/issuesreport 
const templ = `{{.TotalCount}} issues: 
{{range .Items}}-------------------------------------­
Number: {{.Number}} 
User: {{.User.Login}} 
Title: {{.Title | printf &amp;quot;%.64s&amp;quot;}} 
Age: {{.CreatedAt | daysAgo}} days 
{{end}}` 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This template first prints the number of matching issues, then prints the number, user, title, and age in days of each one. Within an action, there is a notion of the current value, referred to as “dot” and written as “.”, a period. The dot initially refers to the template’s parameter, which will be a github.IssuesSearchResult in this example. The {{.TotalCount}} action expands to the value of the TotalCount field, printed in the usual way. The {{range .Items}} and {{end}} actions create a loop, so the text between them is expanded multiple times, with dot bound to successive elements of Items.&lt;/p&gt;

&lt;p&gt;Within an action, the | notation makes the result of one operation the argument of another, analogous to a Unix shell pipeline. In the case of Title, the second operation is the printf function, which is a built-in synonym for fmt.Sprintf in all templates. For Age, the second operation is the following function, daysAgo, which converts the CreatedAt field into an elapsed time, using time.Since:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func daysAgo(t time.Time) int {
return int(time.Since(t).Hours() / 24) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the type of CreatedAt is time.Time, not string. In the same way that a type may control its string formatting (§2.5) by defining certain methods, a type may also define methods to control its JSON marshaling and unmarshaling behavior. The JSON-marshaled value of a time.Time is a string in a standard format.&lt;/p&gt;

&lt;p&gt;Producing output with a template is a two-step process. First we must parse the template into a suitable internal representation, and then execute it on specific inputs. Parsing need be done only once. The code below creates and parses the template templ defined above. Note the chaining of method calls: template.New creates and returns a template; Funcs adds daysAgo to the set of functions accessible within this template, then returns that template; finally, Parse is called on the result.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;report, err := template.New(&amp;quot;report&amp;quot;).
Funcs(template.FuncMap{&amp;quot;daysAgo&amp;quot;: daysAgo}). 
Parse(templ) 
if err != nil {
log.Fatal(err) 
} 

Because templates are usually fixed at compile time, failure to parse a template indicates a fatal bug in the program. The template.Must helper function makes error handling more convenient: it accepts a template and an error, checks that the error is nil (and panics otherwise), and then returns the template. We’ll come back to this idea in Section 5.9. 

Once the template has been created, augmented with daysAgo, parsed, and checked, we can execute it using a github.IssuesSearchResult as the data source and os.Stdout as the destination: 

```go
var     report = template.Must(template.New(&amp;quot;issuelist&amp;quot;).Funcs(template.FuncMap{&amp;quot;daysAgo&amp;quot;: daysAgo}). Parse(templ)) 
func main() {result, err := github.SearchIssues(os.Args[1:]) if err != nil {
log.Fatal(err) }if err := report.Execute(os.Stdout, result); err 
!= nil {
log.Fatal(err) 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The program prints a plain text report like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch4/issuesreport $ ./issuesreport repo:golang/go is:open json decoder 13 issues: 
Number: 5680 User: eaigner Title: encoding/json: set key converter on en/decoder Age: 750 days
Number: 6050 
User: gopherbot 
Title: encoding/json: provide tokenizer 
Age: 695 days

... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let’s turn to the html/template package. It uses the same API and expression language as text/template but adds features for automatic and context-appropriate escaping of strings appearing within HTML, JavaScript, CSS, or URLs. These features can help avoid a perennial security problem of HTML
generation, an injection attack, in which an adversary crafts a string value like the title of an issue to include malicious code that, when improperly escaped by a template, gives them control over the page.&lt;/p&gt;

&lt;p&gt;The template below prints the list of issues as an HTML table. Note the different import:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/issueshtml 
import &amp;quot;html/template&amp;quot; 
var issueList = 
template.Must(template.New(&amp;quot;issuelist&amp;quot;).Parse(`
&amp;lt;h1&amp;gt;{{.TotalCount}} issues&amp;lt;/h1&amp;gt; 
&amp;lt;table&amp;gt; 
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt; 

&amp;lt;th&amp;gt;#&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;State&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;User&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;Title&amp;lt;/th&amp;gt;

&amp;lt;/tr&amp;gt;
{{range .Items}} 
&amp;lt;tr&amp;gt; 

&amp;lt;td&amp;gt;&amp;lt;a href=&#39;{{.HTMLURL}}&#39;&amp;gt;{{.Number}}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;{{.State}}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;a href=&#39;{{.User.HTMLURL}}&#39;&amp;gt;{{.User.Login}}&amp;lt;/a&amp;gt; 
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;a href=&#39;{{.HTMLURL}}&#39;&amp;gt;{{.Title}}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt; 
&amp;lt;/tr&amp;gt;
{{end}}
&amp;lt;/table&amp;gt;
`)) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The command below executes the new template on the results of a slightly different query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch4/issueshtml $ ./issueshtml repo:golang/go commenter:gopherbot json encoder &amp;gt;issues.html 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Figure 4.4. An HTML table of Go project issues relating to JSON encoding.&lt;/p&gt;

&lt;p&gt;None of the issues in Figure 4.4 pose a challenge for HTML, but we can see the effect more clearly with issues whose titles contain HTML metacharacters like &amp;amp; and &amp;lt;. We’ve selected two such issues for this example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ ./issueshtml repo:golang/go 3133 10535 &amp;gt;issues2.html 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Figure 4.5 shows the result of this query. Notice that the html/template package automatically HTML-escaped the titles so that they appear literally. Had we used the text/template package by mistake, the four-character string &amp;ldquo;&amp;lt;&amp;rdquo; would have been rendered as a less-than character &amp;lsquo;&amp;lt;&amp;lsquo;, and the string &amp;ldquo;&lt;link&gt;&amp;rdquo; would have become a link element, changing the structure of the HTML document and perhaps compromising its security.&lt;/p&gt;

&lt;p&gt;We can suppress this auto-escaping behavior for fields that contain trusted HTML data by using the named string type template.HTML instead of string. Similar named types exist for trusted JavaScript, CSS, and URLs. The program below demonstrates the principle by using two fields with the same value but different types: A is a string and B is a template.HTML.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch4/autoescape 
func main() {const templ = `&amp;lt;p&amp;gt;A: {{.A}}&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;B: {{.B}}&amp;lt;/p&amp;gt;` t := 
template.Must(template.New(&amp;quot;escape&amp;quot;).Parse(templ))
var     data struct {A string // untrusted plain text B template.HTML // trusted HTML 
}
data.A = &amp;quot;&amp;lt;b&amp;gt;Hello!&amp;lt;/b&amp;gt;&amp;quot; 
data.B = &amp;quot;&amp;lt;b&amp;gt;Hello!&amp;lt;/b&amp;gt;&amp;quot; 
if err := t.Execute(os.Stdout, data); err != nil {

log.Fatal(err) 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Figure 4.6 shows the template’s output as it appears in a browser. We can see that A was subject to escaping but B was not.&lt;/p&gt;

&lt;p&gt;We have space here to show only the most basic features of the template system. As always, for more information, consult the package documentation:
$ go doc text/template
$ go doc html/template&lt;/p&gt;

&lt;p&gt;Exercise 4.14: Create a web server that queries GitHub once and then allows navigation of the list of bug reports, milestones, and users.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Functions&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A function lets us wrap up a sequence of statements as a unit that can be called from elsewhere in a program, perhaps multiple times. Functions make it possible to break a big job into smaller pieces that might well be written by different people separated by both time and space. A function hides its implementation details from its users. For all of these reasons, functions are a critical part of any programming language.&lt;/p&gt;

&lt;p&gt;We’ve seen many functions already. Now let’s take time for a more thorough discussion. The running example of this chapter is a web crawler, that is, the component of a web search engine responsible for fetching web pages, discovering the links within them, fetching the pages identified by those links, and so on. A web crawler gives us ample opportunity to explore recursion, anonymous functions, error handling, and aspects of functions that are unique to Go.&lt;/p&gt;

&lt;h2 id=&#34;function-declarations:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Function Declarations&lt;/h2&gt;

&lt;p&gt;A function declaration has a name, a list of parameters, an optional list of results, and a body:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func name(parameter-list)(result-list){ 
body 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parameter list specifies the names and types of the function’s parameters, which are the local variables whose values or arguments are supplied by the caller. The result list specifies the types of the values that the function returns. If the function returns one unnamed result or no results at all, parentheses are optional and usually omitted. Leaving off the result list entirely declares a function that does not return any value and is called only for its effects. In the hypot function,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func hypot(x, y float64) float64 {
return math.Sqrt(x*x + y*y) 
} 

fmt.Println(hypot(3, 4)) // &amp;quot;5&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x and y are parameters in the declaration, 3 and 4 are arguments of the call, and the function returns a float64 value.
Like parameters, results may be named. In that case, each name declares a local&lt;/p&gt;

&lt;p&gt;variable initialized to the zero value for its type.&lt;/p&gt;

&lt;p&gt;A function that has a result list must end with a return statement unless execution
clearly cannot reach the end of the function, perhaps because the function ends with a
call to panic or an infinite for loop with no break.&lt;/p&gt;

&lt;p&gt;As we saw with hypot, a sequence of parameters or results of the same type can be
factored so that the type itself is written only once. These two declarations are
equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;

func f(i, j, k int, s, t string) { /* 
... */ } 
func f(i int, j int, k int, s string, t string) { /* 
... */ } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here are four ways to declare a function with two parameters and one result, all of type int. The blank identifier can be used to emphasize that a parameter is unused.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x int, y int) int { return x + y } 
func sub(x, y int) (z int) { z = x -y; return }
func first(x int, _ int) int { return x }
func zero(int, int) int { return 0 } 
fmt.Printf(&amp;quot;%T\n&amp;quot;, add) // &amp;quot;func(int, int) int&amp;quot; 
fmt.Printf(&amp;quot;%T\n&amp;quot;, sub) // &amp;quot;func(int, int) int&amp;quot; 
fmt.Printf(&amp;quot;%T\n&amp;quot;, first) // &amp;quot;func(int, int) int&amp;quot; 
fmt.Printf(&amp;quot;%T\n&amp;quot;, zero) // &amp;quot;func(int, int) int&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The type of a function is sometimes called its signature. Two functions have the same type or signature if they have the same sequence of parameter types and the same sequence of result types. The names of parameters and results don’t affect the type, nor does whether or not they were declared using the factored form.&lt;/p&gt;

&lt;p&gt;Every function call must provide an argument for each parameter, in the order in which the parameters were declared. Go has no concept of default parameter values, nor any way to specify arguments by name, so the names of parameters and results don’t matter to the caller except as documentation.&lt;/p&gt;

&lt;p&gt;Parameters are local variables within the body of the function, with their initial values set to the arguments supplied by the caller. Function parameters and named results are variables in the same lexical block as the function’s outermost local variables.&lt;/p&gt;

&lt;p&gt;Arguments are passed by value, so the function receives a copy of each argument; modifications to the copy do not affect the caller. However, if the argument contains some kind of reference, like a pointer, slice, map, function, or channel, then the caller may be affected by any modifications the function makes to variables indirectly referred to by the argument.&lt;/p&gt;

&lt;p&gt;You may occasionally encounter a function declaration without a body, indicating that the function is implemented in a language other than Go. Such a declaration defines the function signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package math 
func Sin(x float64) float64 // implemented in assembly language 

## Recursion 
Functions may be recursive, that is, they may call themselves, either directly or indirectly. Recursion is a powerful technique for many problems, and of course it’s essential for processing recursive data structures. In Section 4.4, we used recursion over a tree to implement a simple insertion sort. In this section, we’ll use it again for processing HTML documents. 

The example program below uses a non-standard package, golang.org/x/net/html, which provides an HTML parser. The golang.org/x/... repositories hold packages designed and maintained by the Go team for applications such as networking, internationalized text processing, mobile platforms, image manipulation, cryptography, and developer tools. These packages are not in the standard library because they’re still under development or because they’re rarely needed by the majority of Go programmers. 

The parts of the golang.org/x/net/html API that we’ll need are shown below. The function html.Parse reads a sequence of bytes, parses them, and returns the root of the HTML document tree, which is an html.Node. HTML has several kinds of nodes—text, comments, and so on—but here we are concerned only with element nodes of the form `&amp;lt;name key=&#39;value&#39;&amp;gt;` . 

```go
//golang.org/x/net/html 
package html 
type Node struct {
Type NodeType 
Data string 
Attr []Attribute 
FirstChild, NextSibling *Node } 
type NodeType int32 
const (
    ErrorNode NodeType = iota 

    TextNode 
    DocumentNode 
    ElementNode 
    CommentNode 
    DoctypeNode 

) 
type Attribute struct {
    Key, Val string 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;func Parse(r io.Reader) (*Node, error)&lt;/p&gt;

&lt;p&gt;The main function parses the standard input as HTML, extracts the links using a recursive visit function, and prints each discovered link:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch5/findlinks1 
// Findlinks1 prints the links in an HTML document 
read from standard input. 
package main 

import (
&amp;quot;fmt&amp;quot; 
&amp;quot;os&amp;quot; 

&amp;quot;golang.org/x/net/html&amp;quot; 
) 

func main() {
doc, err := html.Parse(os.Stdin) 
if err != nil {

fmt.Fprintf(os.Stderr, &amp;quot;findlinks1: %v\n&amp;quot;, 
err) 

os.Exit(1) 
}
for _, link := range visit(nil, doc) { 

fmt.Println(link) 
} 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The visit function traverses an HTML node tree, extracts the link from the href attribute of each anchor element &lt;a href=&#39;...&#39;&gt; , appends the links to a slice of strings, and returns the resulting slice:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// visit appends to links each link found in n and 
returns the result. 
func visit(links []string, n *html.Node) []string { 
if n.Type == html.ElementNode &amp;amp;&amp;amp; n.Data == &amp;quot;a&amp;quot; {
for _, a := range n.Attr {
if a.Key == &amp;quot;href&amp;quot; {
links = append(links, a.Val) 
}}}
for c := n.FirstChild; c != nil; c = c.NextSibling 
{ links = visit(links, c) }
return links 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To descend the tree for a node n, visit recursively calls itself for each of n’s children, which are held in the FirstChild linked list.
Let’s run findlinks on the Go home page, piping the output of fetch (§1.5) to the input of findlinks. We’ve edited the output slightly for brevity.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch1/fetch 
$ go build gopl.io/ch5/findlinks1 
$ ./fetch https://golang.org | ./findlinks1 
# 
/doc/
/pkg/
/help/
/blog/
http://play.golang.org/ 
//tour.golang.org/
https://golang.org/dl/
//blog.golang.org/
/LICENSE
/doc/tos.html
http://www.google.com/intl/en/policies/privacy/ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the variety of forms of links that appear in the page. Later we’ll see how to resolve them relative to the base URL, &lt;a href=&#34;https://golang.org&#34;&gt;https://golang.org&lt;/a&gt;, to make absolute URLs.&lt;/p&gt;

&lt;p&gt;The next program uses recursion over the HTML node tree to print the structure of the tree in outline. As it encounters each element, it pushes the element’s tag onto a stack, then prints the stack.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch5/outline 
func main() {
doc, err := html.Parse(os.Stdin) 
if err != nil {
fmt.Fprintf(os.Stderr, &amp;quot;outline: %v\n&amp;quot;, err) 
os.Exit(1) 
}
outline(nil, doc) } 
func outline(stack []string, n *html.Node) { 
if n.Type == html.ElementNode {
stack = append(stack, n.Data) // push tag 
fmt.Println(stack) 
}
for c := n.FirstChild; c != nil; c = c.NextSibling 
{ outline(stack, c) }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note one subtlety: although outline “pushes” an element on stack, there is no corresponding pop. When outline calls itself recursively, the callee receives a copy of stack. Although the callee may append elements to this slice, modifying its underlying array and perhaps even allocating a new array, it doesn’t modify the initial elements that are visible to the caller, so when the function returns, the caller’s stack is as it was before the call.&lt;/p&gt;

&lt;p&gt;Here’s the outline of &lt;a href=&#34;https://golang.org&#34;&gt;https://golang.org&lt;/a&gt;, again edited for brevity:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch5/outline 
$ ./fetch https://golang.org | ./outline 
[html]
[html head] 
[html head meta] 
[html head title] 
[html head link] 
[html body] 
[html body div] 
[html body div] 
[html body div div] 
[html body div div form] 
[html body div div form div] 
[html body div div form div a] 
... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see by experimenting with outline, most HTML documents can be processed with only a few levels of recursion, but it’s not hard to construct pathological web pages that require extremely deep recursion.&lt;/p&gt;

&lt;p&gt;Many programming language implementations use a fixed-size function call stack; sizes from 64KB to 2MB are typical. Fixed-size stacks impose a limit on the depth of recursion, so one must be careful to avoid a stack overflow when traversing large data structures recursively; fixed-size stacks may even pose a security risk. In contrast, typical Go implementations use variable-size stacks that start small and grow as needed up to a limit on the order of a gigabyte. This lets us use recursion safely and without worrying about overflow.&lt;/p&gt;

&lt;p&gt;Exercise 5.1: Change the findlinks program to traverse the n.FirstChild linked list using recursive calls to visit instead of a loop.&lt;/p&gt;

&lt;p&gt;Exercise 5.2: Write a function to populate a mapping from element names—p, div,
span, and so on—to the number of elements with that name in an HTML document&lt;/p&gt;

&lt;p&gt;tree.&lt;/p&gt;

&lt;p&gt;Exercise 5.3: Write a function to print the contents of all text nodes in an HTML document tree. Do not descend into &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; elements, since their contents are not visible in a web browser.&lt;/p&gt;

&lt;p&gt;Exercise 5.4: Extend the visit function so that it extracts other kinds of links from
the document, such as images, scripts, and style sheets.&lt;/p&gt;

&lt;h2 id=&#34;multiple-return-values:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Multiple Return Values&lt;/h2&gt;

&lt;p&gt;A function can return more than one result. We’ve seen many examples of functions from standard packages that return two values, the desired computational result and an error value or boolean that indicates whether the computation worked. The next example shows how to write one of our own.&lt;/p&gt;

&lt;p&gt;The program below is a variation of findlinks that makes the HTTP request itself so that we no longer need to run fetch. Because the HTTP and parsing operations can fail, findLinks declares two results: the list of discovered links and an error. Incidentally, the HTML parser can usually recover from bad input and construct a document containing error nodes, so Parse rarely fails; when it does, it’s typically due to underlying I/O errors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch5/findlinks2 
func main() {
for     _, url := range os.Args[1:] { 
links, err := findLinks(url) 
if err != nil {

fmt.Fprintf(os.Stderr, &amp;quot;findlinks2: %v\n&amp;quot;, err) 
continue }for _, link := range links {
fmt.Println(link) 
}
}
} 

// findLinks performs an HTTP GET request for url, 
parses the 
// response as HTML, and extracts and returns the 
links. 
func findLinks(url string) ([]string, error) { 

resp, err := http.Get(url) 
if err != nil { 

return nil, err }
if resp.StatusCode != http.StatusOK {
resp.Body.Close()
return nil, fmt.Errorf(&amp;quot;getting %s: %s&amp;quot;, url, resp.Status)
}
doc, err := html.Parse(resp.Body)
resp.Body.Close()
if err != nil {
return nil, fmt.Errorf(&amp;quot;parsing %s as HTML: %v&amp;quot;, url, err) 
}
return visit(nil, doc), nil } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are four return statements in findLinks, each of which returns a pair of values. The first three returns cause the function to pass the underlying errors from the http and html packages on to the caller. In the first case, the error is returned unchanged; in the second and third, it is augmented with additional context information by fmt.Errorf (§7.8). If findLinks is successful, the final return statement returns the slice of links, with no error.&lt;/p&gt;

&lt;p&gt;We must ensure that resp.Body is closed so that network resources are properly released even in case of error. Go’s garbage collector recycles unused memory, but do not assume it will release unused operating system resources like open files and network connections. They should be closed explicitly.&lt;/p&gt;

&lt;p&gt;The result of calling a multi-valued function is a tuple of values. The caller of such a function must explicitly assign the values to variables if any of them are to be used:
links, err := findLinks(url)&lt;/p&gt;

&lt;p&gt;To ignore one of the values, assign it to the blank identifier:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;links, _ := findLinks(url) // errors ignored 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result of a multi-valued call may itself be returned from a (multi-valued) calling function, as in this function that behaves like findLinks but logs its argument:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func findLinksLog(url string) ([]string, error) { 
log.Printf(&amp;quot;findLinks %s&amp;quot;, url) 
return findLinks(url) 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A multi-valued call may appear as the sole argument when calling a function of multiple parameters. Although rarely used in production code, this feature is sometimes convenient during debugging since it lets us print all the results of a call using a single statement. The two print statements below have the same effect.
log.Println(findLinks(url))
links, err := findLinks(url)
log.Println(links, err)&lt;/p&gt;

&lt;p&gt;Well-chosen names can document the significance of a function’s results. Names are particularly valuable when a function returns multiple results of the same type, like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Size(rect image.Rectangle) (width, height int) func Split(path string) (dir, file string) func HourMinSec(t time.Time) (hour, minute, second int) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but it’s not always necessary to name multiple results solely for documentation. For instance, convention dictates that a final bool result indicates success; an error result often needs no explanation.&lt;/p&gt;

&lt;p&gt;In a function with named results, the operands of a return statement may be omitted. This is called a bare return.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// CountWordsAndImages does an HTTP GET request for the HTML // document url and returns the number of words and images in it. func CountWordsAndImages(url string) (words, images int, err error) { 
resp, err := http.Get(url) 
if err != nil {
return 

} 
doc, err := html.Parse(resp.Body)
resp.Body.Close()
if err != nil {
err = fmt.Errorf(&amp;quot;parsing HTML: %s&amp;quot;, err) 
return 
}
words, images = countWordsAndImages(doc) 
return 
} 
func countWordsAndImages(n *html.Node) (words, images 
int) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A bare return is a shorthand way to return each of the named result variables in order, so in the function above, each return statement is equivalent to return words, images, err&lt;/p&gt;

&lt;p&gt;In functions like this one, with many return statements and several results, bare returns can reduce code duplication, but they rarely make code easier to understand. For instance, it’s not obvious at first glance that the two early returns are equivalent to return 0, 0, err (because the result variables words and images are initialized to their zero values) and that the final return is equivalent to return words, images, nil . For this reason, bare returns are best used sparingly. Exercise 5.5: Implement countWordsAndImages. (See Exercise 4.9 for word-splitting.)&lt;/p&gt;

&lt;p&gt;Exercise 5.6: Modify the corner function in // gopl.io/ch3/surface (§3.2) to use named results and a bare return statement.&lt;/p&gt;

&lt;h2 id=&#34;errors:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Errors&lt;/h2&gt;

&lt;p&gt;Some functions always succeed at their task. For example, strings.Contains and strconv.FormatBool have well-defined results for all possible argument values and cannot fail—barring catastrophic and unpredictable scenarios like running out of memory, where the symptom is far from the cause and from which there’s little hope of recovery.&lt;/p&gt;

&lt;p&gt;Other functions always succeed so long as their preconditions are met. For example, the time.Date function always constructs a time.Time from its components— year, month, and so on—unless the last argument (the time zone) is nil, in which case it panics. This panic is a sure sign of a bug in the calling code and should never happen in a well-written program.&lt;/p&gt;

&lt;p&gt;For many other functions, even in a well-written program, success is not assured because it depends on factors beyond the programmer’s control. Any function that does I/O, for example, must confront the possibility of error, and only a naïve programmer believes a simple read or write cannot fail. Indeed, it’s when the most reliable operations fail unexpectedly that we most need to know why.&lt;/p&gt;

&lt;p&gt;Errors are thus an important part of a package’s API or an application’s user interface, and failure is just one of several expected behaviors. This is the approach Go takes to error handling.&lt;/p&gt;

&lt;p&gt;A function for which failure is an expected behavior returns an additional result, conventionally the last one. If the failure has only one possible cause, the result is a boolean, usually called ok, as in this example of a cache lookup that always succeeds unless there was no entry for that key:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;value, ok := cache.Lookup(key) 
if !ok {
// ...cache[key] does not exist... 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More often, and especially for I/O, the failure may have a variety of causes for which the caller will need an explanation. In such cases, the type of the additional result is error.&lt;/p&gt;

&lt;p&gt;The built-in type error is an interface type. We’ll see more of what this means and its implications for error handling in Chapter 7. For now it’s enough to know that an error may be nil or non-nil, that nil implies success and non-nil implies failure, and that a non-nil error has an error message string which we can obtain by calling its Error method or print by calling fmt.Println(err) or fmt.Printf(&amp;ldquo;%v&amp;rdquo;, err) .&lt;/p&gt;

&lt;p&gt;Usually when a function returns a non-nil error, its other results are undefined and should be ignored. However, a few functions may return partial results in error cases. For example, if an error occurs while reading from a file, a call to Read returns the number of bytes it was able to read and an error value describing the problem. For correct behavior, some callers may need to process the incomplete data before handling the error, so it is important that such functions clearly document their results.&lt;/p&gt;

&lt;p&gt;Go’s approach sets it apart from many other languages in which failures are reported using exceptions, not ordinary values. Although Go does have an exception mechanism of sorts, as we will see in Section 5.9, it is used only for reporting truly unexpected errors that indicate a bug, not the routine errors that a robust program should be built to expect.&lt;/p&gt;

&lt;p&gt;The reason for this design is that exceptions tend to entangle the description of an error with the control flow required to handle it, often leading to an undesirable outcome: routine errors are reported to the end user in the form of an incomprehensible stack trace, full of information about the structure of the program but lacking intelligible context about what went wrong.
By contrast, Go programs use ordinary control-flow mechanisms like if and return to respond to errors. This style undeniably demands that more attention be paid to error-handling logic, but that is precisely the point.&lt;/p&gt;

&lt;h3 id=&#34;error-handling-strategies:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Error-Handling Strategies&lt;/h3&gt;

&lt;p&gt;When a function call returns an error, it’s the caller’s responsibility to check it and take appropriate action. Depending on the situation, there may be a number of possibilities. Let’s take a look at five of them.&lt;/p&gt;

&lt;p&gt;First, and most common, is to propagate the error, so that a failure in a subroutine becomes a failure of the calling routine. We saw examples of this in the findLinks
function of Section 5.3. If the call to http.Get fails, findLinks returns the HTTP error to the caller without further ado:
resp, err := http.Get(url)
if err != nil {
return nil, err
}&lt;/p&gt;

&lt;p&gt;In contrast, if the call to html.Parse fails, findLinks does not return the HTML parser’s error directly because it lacks two crucial pieces of information: that the error occurred in the parser, and the URL of the document that was being parsed. In this case, findLinks constructs a new error message that includes both pieces of information as well as the underlying parse error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;doc, err := html.Parse(resp.Body)
resp.Body.Close()
if err != nil {
return nil, fmt.Errorf(&amp;quot;parsing %s as HTML: %v&amp;quot;, 
url, err) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fmt.Errorf function formats an error message using fmt.Sprintf and returns a new error value. We use it to build descriptive errors by successively prefixing additional context information to the original error message. When the error is ultimately handled by the program’s main function, it should provide a clear causal chain from the root problem to the overall failure, reminiscent of a NASA accident investigation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;genesis: crashed: no parachute: G-switch failed: bad
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;relay orientation&lt;/p&gt;

&lt;p&gt;Because error messages are frequently chained together, message strings should not be capitalized and newlines should be avoided. The resulting errors may be long, but they will be self-contained when found by tools like grep.&lt;/p&gt;

&lt;p&gt;When designing error messages, be deliberate, so that each one is a meaningful description of the problem with sufficient and relevant detail, and be consistent, so that errors returned by the same function or by a group of functions in the same package are similar in form and can be dealt with in the same way.&lt;/p&gt;

&lt;p&gt;For example, the os package guarantees that every error returned by a file operation, such as os.Open or the Read, Write, or Close methods of an open file, describes not just the nature of the failure (permission denied, no such directory, and so on) but also the name of the file, so the caller needn’t include this information in the error message it constructs.&lt;/p&gt;

&lt;p&gt;In general, the call f(x) is responsible for reporting the attempted operation f and the argument value x as they relate to the context of the error. The caller is responsible for adding further information that it has but the call f(x) does not, such as the URL in the call to html.Parse above.
Let’s move on to the second strategy for handling errors. For errors that represent transient or unpredictable problems, it may make sense to retry the failed operation, possibly with a delay between tries, and perhaps with a limit on the number of attempts or the time spent trying before giving up entirely.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
// gopl.io/ch5/wait 
// WaitForServer attempts to contact the server of a 
URL. 
// It tries for one minute using exponential back-off. 
// It reports an error if all attempts fail. 
func WaitForServer(url string) error {
const timeout = 1 * time.Minute 
deadline := time.Now().Add(timeout) 
for tries := 0; time.Now().Before(deadline); 
tries++ { _, err := http.Head(url) 
if err == nil {
return nil // success }
log.Printf(&amp;quot;server not responding (%s); 
retrying...&amp;quot;, err)
time.Sleep(time.Second &amp;lt;&amp;lt; uint(tries)) // 
exponential back-off 
}
return fmt.Errorf(&amp;quot;server %s failed to respond 
after %s&amp;quot;, url, timeout) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Third, if progress is impossible, the caller can print the error and stop the program gracefully, but this course of action should generally be reserved for the main package of a program. Library functions should usually propagate errors to the caller, unless the error is a sign of an internal inconsistency—that is, a bug.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// (In function main.) 
if err := WaitForServer(url); err != nil {fmt.Fprintf(os.Stderr, &amp;quot;Site is down: %v\n&amp;quot;, err) os.Exit(1) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A more convenient way to achieve the same effect is to call log.Fatalf. As with all the log functions, by default it prefixes the time and date to the error message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if err := WaitForServer(url); err != nil {
log.Fatalf(&amp;quot;Site is down: %v\n&amp;quot;, err) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default format is helpful in a long-running server, but less so for an interactive tool:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;2006/01/02 15:04:05 Site is down: no such domain: 
bad.gopl.io 


For a more attractive output, we can set the prefix used by the log package to the name of the command, and suppress the display of the date and time: 
log.SetPrefix(&amp;quot;wait: &amp;quot;) 
log.SetFlags(0) 

Fourth, in some cases, it’s sufficient just to log the error and then continue, perhaps with reduced functionality. Again there’s a choice between using the log package, which adds the usual prefix: 

```go
if err := Ping(); err != nil {
log.Printf(&amp;quot;ping failed: %v; networking disabled&amp;quot;, err)} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and printing directly to the standard error stream:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if err := Ping(); err != nil {
fmt.Fprintf(os.Stderr, &amp;quot;ping failed: %v; 
networking disabled\n&amp;quot;, err) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(All log functions append a newline if one is not already present.)&lt;/p&gt;

&lt;p&gt;And fifth and finally, in rare cases we can safely ignore an error entirely:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;dir, err := ioutil.TempDir(&amp;quot;&amp;quot;, &amp;quot;scratch&amp;quot;) 
if err != nil {

return fmt.Errorf(&amp;quot;failed to create temp dir: %v&amp;quot;, err)} 
// ...use temp dir... 
os.RemoveAll(dir) // ignore errors; $TMPDIR is cleaned periodically 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call to os.RemoveAll may fail, but the program ignores it because the operating system periodically cleans out the temporary directory. In this case, discarding the error was intentional, but the program logic would be the same had we forgotten to deal with it. Get into the habit of considering errors after every function call, and when you deliberately ignore one, document your intention clearly.&lt;/p&gt;

&lt;p&gt;Error handling in Go has a particular rhythm. After checking an error, failure is usually dealt with before success. If failure causes the function to return, the logic for success is not indented within an else block but follows at the outer level. Functions tend to exhibit a common structure, with a series of initial checks to reject errors, followed by the substance of the function at the end, minimally indented.&lt;/p&gt;

&lt;h3 id=&#34;end-of-file-eof:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;End of File (EOF)&lt;/h3&gt;

&lt;p&gt;Usually, the variety of errors that a function may return is interesting to the end user but not to the intervening program logic. On occasion, however, a program must take different actions depending on the kind of error that has occurred. Consider an attempt to read n bytes of data from a file. If n is chosen to be the length of the file, any error represents a failure. On the other hand, if the caller repeatedly tries to read fixed-size chunks until the file is exhausted, the caller must respond differently to an end-of-file condition than it does to all other errors. For this reason, the io package guarantees that any read failure caused by an end-of-file condition is always reported by a distinguished error, io.EOF, which is defined as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package io 
import &amp;quot;errors&amp;quot; 
// EOF is the error returned by Read when no more 
input is available. 
var EOF = errors.New(&amp;quot;EOF&amp;quot;) 

The caller can detect this condition using a simple comparison, as in the loop below, which reads runes from the standard input. (The charcount program in Section 4.3 provides a more complete example.) 

```go
in := bufio.NewReader(os.Stdin) 
for {r, _, err := in.ReadRune() 
if err == io.EOF {
break // finished reading }
if err != nil {
return fmt.Errorf(&amp;quot;read failed: %v&amp;quot;, err) }
// ...use r... 
} 

Since in an end-of-file condition there is no information to report besides the fact of it, io.EOF has a fixed error message, &amp;quot;EOF&amp;quot;. For other errors, we may need to report both the quality and quantity of the error, so to speak, so a fixed error value will not do. In Section 7.11, we’ll present a more systematic way to distinguish certain error values from others. 

## Function Values 
Functions are first-class values in Go: like other values, function values have types, and they may be assigned to variables or passed to or returned from functions. A function value may be called like any other function. For example: 

```go
func square(n int) int { return n * n }
func negative(n int) int { return -n }
func product(m, n int) int { return m * n } 

f := square
fmt.Println(f(3)) // &amp;quot;9&amp;quot; 

f = negative
fmt.Println(f(3)) // &amp;quot;-3&amp;quot; 
fmt.Printf(&amp;quot;%T\n&amp;quot;, f) // &amp;quot;func(int) int&amp;quot; 

f = product // compile error: can&#39;t assign f(int, int) int to f(int) int 

The zero value of a function type is nil. Calling a nil function value causes a panic: 

```go
var f func(int) int 
f(3) // panic: call of nil function 

Function values may be compared with nil: 
var f func(int) int 
if f != nil {
f(3) 
} 

but they are not comparable, so they may not be compared against each other or used as keys in a map. 
Function values let us parameterize our functions over not just data, but behavior too. The standard libraries contain many examples. For instance, strings.Map applies a function to each character of a string, joining the results to make another string. 

```go
func add1(r rune) rune { return r + 1 } 
fmt.Println(strings.Map(add1, &amp;quot;HAL-9000&amp;quot;)) // 
&amp;quot;IBM.:111&amp;quot; 
fmt.Println(strings.Map(add1, &amp;quot;VMS&amp;quot;)) // &amp;quot;WNT&amp;quot; 

fmt.Println(strings.Map(add1, &amp;quot;Admix&amp;quot;)) // &amp;quot;Benjy&amp;quot; 


The findLinks function from Section 5.2 uses a helper function, visit, to visit all the nodes in an HTML document and apply an action to each one. Using a function value, we can separate the logic for tree traversal from the logic for the action to be applied to each node, letting us reuse the traversal with different actions. 

```go
// gopl.io/ch5/outline2 
// forEachNode calls the functions pre(x) and post(x) for each node // x in the tree rooted at n. Both functions are optional.// pre is called before the children are visited (preorder) and // post is called after (postorder). func forEachNode(n *html.Node, pre, post func(n *html.Node)) {
if pre != nil {
pre(n) 
} 

for c := n.FirstChild; c != nil; c = c.NextSibling { forEachNode(c, pre, post) } 
if post != nil {
post(n) 

}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The forEachNode function accepts two function arguments, one to call before a node’s children are visited and one to call after. This arrangement gives the caller a great deal of flexibility. For example, the functions startElement and endElement print the start and end tags of an HTML element like &lt;b&gt;&amp;hellip;&lt;/b&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var depth int 
func startElement(n *html.Node) { 
if n.Type == html.ElementNode {fmt.Printf(&amp;quot;%*s&amp;lt;%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data) depth++ 
}
} 

func endElement(n *html.Node) { 
if n.Type == html.ElementNode {depth-­fmt.Printf(&amp;quot;%*s&amp;lt;/%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data) 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The functions also indent the output using another fmt.Printf trick. The * adverb in %*s prints a string padded with a variable number of spaces. The width and the string are provided by the arguments depth*2 and &amp;ldquo;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If we call forEachNode on an HTML document, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;forEachNode(doc, startElement, endElement) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we get a more elaborate variation on the output of our earlier outline program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch5/outline2 
$ ./outline2 http://gopl.io 
&amp;lt;html&amp;gt; 

&amp;lt;head&amp;gt; 
&amp;lt;meta&amp;gt; 
&amp;lt;/meta&amp;gt;
&amp;lt;title&amp;gt; 
&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
&amp;lt;/style&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;table&amp;gt; 
&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt; 
&amp;lt;td&amp;gt; 

&amp;lt;a&amp;gt; 
&amp;lt;img&amp;gt;
&amp;lt;/img&amp;gt; 

... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exercise 5.7: Develop startElement and endElement into a general HTML pretty-printer. Print comment nodes, text nodes, and the attributes of each element (&lt;code&gt;&amp;lt;a href=&#39;...&#39;&amp;gt;&lt;/code&gt; ). Use short forms like &lt;code&gt;&amp;lt;img/&amp;gt;&lt;/code&gt; instead of &lt;code&gt;&amp;lt;img&amp;gt;&amp;lt;/img&amp;gt;&lt;/code&gt; when an element has no children. Write a test to ensure that the output can be parsed successfully. (See Chapter 11.)&lt;/p&gt;

&lt;p&gt;Exercise 5.8: Modify forEachNode so that the pre and post functions return a boolean result indicating whether to continue the traversal. Use it to write a function ElementByID with the following signature that finds the first HTML element with the specified id attribute. The function should stop the traversal as soon as a match is found.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ElementByID(doc *html.Node, id string) *html.Node 

Exercise 5.9: Write a function expand(s string, f func(string) string) string that replaces each substring “$foo” within s by the text returned by f(&amp;quot;foo&amp;quot;). 

## Anonymous Functions 
Named functions can be declared only at the package level, but we can use a function literal to denote a function value within any expression. A function literal is written like a function declaration, but without a name following the func keyword. It is an expression, and its value is called an anonymous function. 
Function literals let us define a function at its point of use. As an example, the earlier call to strings.Map can be rewritten as 

```go
strings.Map(func(r rune) rune { return r + 1 }, &amp;quot;HAL­9000&amp;quot;) 
More importantly, functions defined in this way have access to the entire lexical environment, so the inner function can refer to variables from the enclosing function, as this example shows: 

```go
// gopl.io/ch5/squares 
// squares returns a function that returns 
// the next square number each time it is called. 
func squares() func() int {

var x int 
return func() int {
x++ 
return x * x 

}
} 

func main() { 
f := squares()
fmt.Println(f()) // &amp;quot;1&amp;quot; 
fmt.Println(f()) // &amp;quot;4&amp;quot; 
fmt.Println(f()) // &amp;quot;9&amp;quot; 
fmt.Println(f()) // &amp;quot;16&amp;quot; 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function squares returns another function, of type func() int . A call to squares creates a local variable x and returns an anonymous function that, each time it is called, increments x and returns its square. A second call to squares would create a second variable x and return a new anonymous function which increments that variable.&lt;/p&gt;

&lt;p&gt;The squares example demonstrates that function values are not just code but can have state. The anonymous inner function can access and update the local variables of the enclosing function squares. These hidden variable references are why we classify functions as reference types and why function values are not comparable. Function values like these are implemented using a technique called closures, and Go programmers often use this term for function values.&lt;/p&gt;

&lt;p&gt;Here again we see an example where the lifetime of a variable is not determined by its scope: the variable x exists after squares has returned within main, even though x is hidden inside f.&lt;/p&gt;

&lt;p&gt;As a somewhat academic example of anonymous functions, consider the problem of computing a sequence of computer science courses that satisfies the prerequisite requirements of each one. The prerequisites are given in the prereqs table below, which is a mapping from each course to the list of courses that must be completed before it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch5/toposort 
// prereqs maps computer science courses to their 
prerequisites.
var prereqs = map[string][]string{
&amp;quot;algorithms&amp;quot;: {&amp;quot;data structures&amp;quot;}, 
&amp;quot;calculus&amp;quot;: {&amp;quot;linear algebra&amp;quot;}, 
&amp;quot;compilers&amp;quot;: {
&amp;quot;data structures&amp;quot;,
&amp;quot;formal languages&amp;quot;,
&amp;quot;computer organization&amp;quot;, }, 
&amp;quot;data structures&amp;quot;: {&amp;quot;discrete math&amp;quot;}, &amp;quot;databases&amp;quot;: {&amp;quot;data structures&amp;quot;}, &amp;quot;discrete math&amp;quot;: {&amp;quot;intro to programming&amp;quot;}, &amp;quot;formal languages&amp;quot;: {&amp;quot;discrete math&amp;quot;}, &amp;quot;networks&amp;quot;: {&amp;quot;operating systems&amp;quot;}, &amp;quot;operating systems&amp;quot;: {&amp;quot;data structures&amp;quot;, 
&amp;quot;computer organization&amp;quot;},
&amp;quot;programming languages&amp;quot;: {&amp;quot;data structures&amp;quot;, 
&amp;quot;computer organization&amp;quot;}, 
} 

This kind of problem is known as topological sorting. Conceptually, the prerequisite information forms a directed graph with a node for each course and edges from each course to the courses that it depends on. The graph is acyclic: there is no path from a course that leads back to itself. We can compute a valid sequence using depth-first search through the graph with the code below: 

```go
func main() {
for i, course := range topoSort(prereqs) {
fmt.Printf(&amp;quot;%d:\t%s\n&amp;quot;, i+1, course) 
}
} 

func topoSort(m map[string][]string) []string { 
var order []string 
seen := make(map[string]bool) 
var visitAll func(items []string) 

visitAll = func(items []string) { 
for _, item := range items {

if !seen[item] {seen[item] = true visitAll(m[item])order = append(order, item) 
}
}
} 

var keys []string 
for key := range m { 

keys = append(keys, key) 
} 

sort.Strings(keys)
visitAll(keys)
return order 

} 

When an anonymous function requires recursion, as in this example, we must first declare a variable, and then assign the anonymous function to that variable. Had these two steps been combined in the declaration, the function literal would not be within the scope of the variable visitAll so it would have no way to call itself recursively: 

```go
visitAll := func(items []string) { 
// ... 
visitAll(m[item]) // compile error: undefined: 

visitAll 
// ... 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output of the toposort program is shown below. It is deterministic, an often-desirable property that doesn’t always come for free. Here, the values of the prereqs map are slices, not more maps, so their iteration order is deterministic, and we sorted the keys of prereqs before making the initial calls to visitAll.
1: intro to programming
2: discrete math
3: data structures
4: algorithms
5: linear algebra
6: calculus
7: formal languages
8: computer organization
9: compilers
10: databases
11: operating systems
12: networks
13: programming languages
Let’s return to our findLinks example. We’ve moved the link-extraction function links.Extract to its own package, since we’ll use it again in Chapter 8. We replaced the visit function with an anonymous function that appends to the links slice directly, and used forEachNode to handle the traversal. Since Extract needs only the pre function, it passes nil for the post argument.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch5/links 
// Package links provides a link-extraction function. package links 
import (
&amp;quot;fmt&amp;quot; 
&amp;quot;net/http&amp;quot; 

&amp;quot;golang.org/x/net/html&amp;quot; 
) 

// Extract makes an HTTP GET request to the specified URL, parses // the response as HTML, and returns the links in the HTML document. func Extract(url string) ([]string, error) { 
resp, err := http.Get(url) 
if err != nil {

return nil, err 
}
if resp.StatusCode != http.StatusOK {

resp.Body.Close()return nil, fmt.Errorf(&amp;quot;getting %s: %s&amp;quot;, url, resp.Status)} 
doc, err := html.Parse(resp.Body)
resp.Body.Close()
if err != nil {

return nil, fmt.Errorf(&amp;quot;parsing %s as HTML: %v&amp;quot;, url, err) 
} 

var links []string 
visitNode := func(n *html.Node) { 
if n.Type == html.ElementNode &amp;amp;&amp;amp; n.Data == &amp;quot;a&amp;quot; { 
for _, a := range n.Attr {
if a.Key != &amp;quot;href&amp;quot; {
continue 
}
link, err := 
resp.Request.URL.Parse(a.Val)
if err != nil {
continue // ignore bad URLs }
links = append(links, link.String()) 
}}}
forEachNode(doc, visitNode, nil) 
return links, nil } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of appending the raw href attribute value to the links slice, this version parses it as a URL relative to the base URL of the document, resp.Request.URL. The resulting link is in absolute form, suitable for use in a call to http.Get.
Crawling the web is, at its heart, a problem of graph traversal. The topoSortexample showed a depth-first traversal; for our web crawler, we’ll use breadth-first traversal, at least initially. In Chapter 8, we’ll explore concurrent traversal.&lt;/p&gt;

&lt;p&gt;The function below encapsulates the essence of a breadth-first traversal. The caller provides an initial list worklist of items to visit and a function value f to call for each item. Each item is identified by a string. The function f returns a list of new items to append to the worklist. The breadthFirst function returns when all items have been visited. It maintains a set of strings to ensure that no item is visited twice.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch5/findlinks3 
// breadthFirst calls f for each item in the worklist. // Any items returned by f are added to the worklist. // f is called at most once for each item. func breadthFirst(f func(item string) []string, worklist []string) { 
seen := make(map[string]bool) 
for     len(worklist) &amp;gt; 0 {
items := worklist 
worklist = nil 
for _, item := range items {

if !seen[item] {seen[item] = true worklist = append(worklist, 
f(item)...) 
}
}
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we explained in passing in Chapter 3, the argument “f(item)&amp;hellip;” causes all the items in the list returned by f to be appended to the worklist.&lt;/p&gt;

&lt;p&gt;In our crawler, items are URLs. The crawl function we’ll supply to breadthFirst prints the URL, extracts its links, and returns them so that they too are visited.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func crawl(url string) []string {
fmt.Println(url)
list, err := links.Extract(url) 
if err != nil {

log.Print(err) 
}
return list 

} 

To start the crawler off, we’ll use the command-line arguments as the initial URLs. 

```go
func main() {
// Crawl the web breadth-first, 
// starting from the command-line arguments. 
breadthFirst(crawl, os.Args[1:]) 

} 
Let’s crawl the web starting from https://golang.org. Here are some of the resulting links: 

```go
$ go build gopl.io/ch5/findlinks3 
$ ./findlinks3 https://golang.org
https://golang.org/
https://golang.org/doc/
https://golang.org/pkg/
https://golang.org/project/
https://code.google.com/p/go-tour/
https://golang.org/doc/code.html
https://www.youtube.com/watch?v=XCsL89YtqCs
http://research.swtch.com/gotour
https://vimeo.com/53221560 
... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The process ends when all reachable web pages have been crawled or the memory of the computer is exhausted.&lt;/p&gt;

&lt;p&gt;Exercise 5.10: Rewrite topoSort to use maps instead of slices and eliminate the initial sort. Verify that the results, though nondeterministic, are valid topological orderings.&lt;/p&gt;

&lt;p&gt;Exercise 5.11: The instructor of the linear algebra course decides that calculus is now a prerequisite. Extend the topoSort function to report cycles.&lt;/p&gt;

&lt;p&gt;Exercise 5.12: The startElement and endElement functions in // gopl.io/ch5/outline2 (§5.5) share a global variable, depth. Turn them into anonymous functions that share a variable local to the outline function.&lt;/p&gt;

&lt;p&gt;Exercise 5.13: Modify crawl to make local copies of the pages it finds, creating directories as necessary. Don’t make copies of pages that come from a different domain. For example, if the original page comes from golang.org, save all files from there, but exclude ones from vimeo.com.&lt;/p&gt;

&lt;p&gt;Exercise 5.14: Use the breadthFirst function to explore a different structure. For example, you could use the course dependencies from the topoSort example (a directed graph), the file system hierarchy on your computer (a tree), or a list of bus or subway routes downloaded from your city government’s web site (an undirected graph).&lt;/p&gt;

&lt;h3 id=&#34;caveat-capturing-iteration-variables:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Caveat: Capturing Iteration Variables&lt;/h3&gt;

&lt;p&gt;In this section, we’ll look at a pitfall of Go’s lexical scope rules that can cause surprising results. We urge you to understand the problem before proceeding, because the trap can ensnare even experienced programmers.
Consider a program that must create a set of directories and later remove them. We can use a slice of function values to hold the clean-up operations. (For brevity, we have omitted all error handling in this example.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var     rmdirs []func() 
for     _, d := range tempDirs() { 
dir := d // NOTE: necessary! 
os.MkdirAll(dir, 0755) // creates parent 

directories too 
rmdirs = append(rmdirs, func() { 
os.RemoveAll(dir) 
}) 
} 

// ...do some work... 
for _, rmdir := range rmdirs {
rmdir() // clean up 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may be wondering why we assigned the loop variable d to a new local variable dir within the loop body, instead of just naming the loop variable dir as in this subtly incorrect variant:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var rmdirs []func() 
for _, dir := range tempDirs() { 
os.MkdirAll(dir, 0755) 
rmdirs = append(rmdirs, func() { 
os.RemoveAll(dir) // NOTE: incorrect! 
}) } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason is a consequence of the scope rules for loop variables. In the program immediately above, the for loop introduces a new lexical block in which the variable dir is declared. All function values created by this loop “capture” and share the same variable—an addressable storage location, not its value at that particular moment. The value of dir is updated in successive iterations, so by the time the cleanup functions are called, the dir variable has been updated several times by the now-completed for loop. Thus dir holds the value from the final iteration, and consequently all calls to os.RemoveAll will attempt to remove the same directory.
Frequently, the inner variable introduced to work around this problem—dir in our example—is given the exact same name as the outer variable of which it is a copy, leading to odd-looking but crucial variable declarations like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for _, dir := range tempDirs() { dir := dir // declares inner dir, initialized to outer dir // ... } 

The risk is not unique to range-based for loops. The loop in the example below suffers from the same problem due to unintended capture of the index variable i. 

```go
var rmdirs []func() 
dirs := tempDirs() 
for i := 0; i &amp;lt; len(dirs); i++ {
os.MkdirAll(dirs[i], 0755) // OK 
rmdirs = append(rmdirs, func() {
os.RemoveAll(dirs[i]) // NOTE: incorrect! 
}) } 

The problem of iteration variable capture is most often encountered when using the go statement (Chapter 8) or with defer (which we will see in a moment) since both may delay the execution of a function value until after the loop has finished. But the problem is not inherent to go or defer. 

## Variadic Functions 


A variadic function is one that can be called with varying numbers of arguments. The most familiar examples are fmt.Printf and its variants. Printf requires one fixed argument at the beginning, then accepts any number of subsequent arguments. 

To declare a variadic function, the type of the final parameter is preceded by an ellipsis, “...”, which indicates that the function may be called with any number of arguments of this type. 

```go
// gopl.io/ch5/sum 
func sum(vals ...int) int {
total := 0 
for _, val := range vals {

total += val 
}
return total 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The sum function above returns the sum of zero or more int arguments. Within the body of the function, the type of vals is an []int slice. When sum is called, any number of values may be provided for its vals parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(sum()) // &amp;quot;0&amp;quot; 
fmt.Println(sum(3)) // &amp;quot;3&amp;quot; 
fmt.Println(sum(1, 2, 3, 4)) // &amp;quot;10&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Implicitly, the caller allocates an array, copies the arguments into it, and passes a slice of the entire array to the function. The last call above thus behaves the same as the call below, which shows how to invoke a variadic function when the arguments are already in a slice: place an ellipsis after the final argument.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;values := []int{1, 2, 3, 4}
fmt.Println(sum(values...)) // &amp;quot;10&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the &amp;hellip;int parameter behaves like a slice within the function body, the type of a variadic function is distinct from the type of a function with an ordinary slice parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func f(...int) {} 
func g([]int) {} 
fmt.Printf(&amp;quot;%T\n&amp;quot;, f) // &amp;quot;func(...int)&amp;quot; 
fmt.Printf(&amp;quot;%T\n&amp;quot;, g) // &amp;quot;func([]int)&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Variadic functions are often used for string formatting. The errorf function below constructs a formatted error message with a line number at the beginning. The suffix f is a widely followed naming convention for variadic functions that accept a Printf-style format string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func errorf(linenum int, format string, args 
...interface{}) {
fmt.Fprintf(os.Stderr, &amp;quot;Line %d: &amp;quot;, linenum) 
fmt.Fprintf(os.Stderr, format, args...) 
fmt.Fprintln(os.Stderr) 
} 
linenum, name := 12, &amp;quot;count&amp;quot; 
errorf(linenum, &amp;quot;undefined: %s&amp;quot;, name) // &amp;quot;Line 12: 
undefined: count&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interface{} type means that this function can accept any values at all for its final arguments, as we’ll explain in Chapter 7.&lt;/p&gt;

&lt;p&gt;Exercise 5.15: Write variadic functions max and min, analogous to sum. What should these functions do when called with no arguments? Write variants that require at least one argument.&lt;/p&gt;

&lt;p&gt;Exercise 5.16: Write a variadic version of strings.Join.&lt;/p&gt;

&lt;p&gt;Exercise 5.17: Write a variadic function ElementsByTagName that, given an HTML node tree and zero or more names, returns all the elements that match one of those names. Here are two example calls:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ElementsByTagName(doc *html.Node, name ...string) 
[]*html.Node 

images := ElementsByTagName(doc, &amp;quot;img&amp;quot;) 
headings := ElementsByTagName(doc, &amp;quot;h1&amp;quot;, &amp;quot;h2&amp;quot;, &amp;quot;h3&amp;quot;, 
&amp;quot;h4&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;deferred-function-calls:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Deferred Function Calls&lt;/h2&gt;

&lt;p&gt;Our findLinks examples used the output of http.Get as the input to html.Parse. This works well if the content of the requested URL is indeed HTML, but many pages contain images, plain text, and other file formats. Feeding such files into an HTML parser could have undesirable effects.&lt;/p&gt;

&lt;p&gt;The program below fetches an HTML document and prints its title. The title function inspects the Content-Type header of the server’s response and returns an error if the document is not HTML.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch5/title1 
func title(url string) error {
resp, err := http.Get(url) 
if err != nil {

return err 
} 

// Check Content-Type is HTML (e.g., &amp;quot;text/html; 
charset=utf-8&amp;quot;).
ct := resp.Header.Get(&amp;quot;Content-Type&amp;quot;) 
if ct != &amp;quot;text/html&amp;quot; &amp;amp;&amp;amp; !strings.HasPrefix(ct, 

&amp;quot;text/html;&amp;quot;) {
resp.Body.Close()
return fmt.Errorf(&amp;quot;%s has type %s, not 

text/html&amp;quot;, url, ct) 
} 

doc, err := html.Parse(resp.Body)
resp.Body.Close()
if err != nil {

return fmt.Errorf(&amp;quot;parsing %s as HTML: %v&amp;quot;, url, err) } 
visitNode := func(n *html.Node) { if n.Type == html.ElementNode &amp;amp;&amp;amp; n.Data == &amp;quot;title&amp;quot; &amp;amp;&amp;amp; 
n.FirstChild != nil {
fmt.Println(n.FirstChild.Data) 
}}
forEachNode(doc, visitNode, nil) 
return nil 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here’s a typical session, slightly edited to fit:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch5/title1 
$ ./title1 http://gopl.io 

The Go Programming Language 
$ ./title1 https://golang.org/doc/effective_go.html 
Effective Go -The Go Programming Language 
$ ./title1 https://golang.org/doc/gopher/frontpage.png 
title: https://golang.org/doc/gopher/frontpage.png 
has type image/png, not text/html 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Observe the duplicated resp.Body.Close() call, which ensures that title closes the network connection on all execution paths, including failures. As functions grow more complex and have to handle more errors, such duplication of clean-up logic may become a maintenance problem. Let’s see how Go’s novel defer mechanism makes things simpler.
Syntactically, a defer statement is an ordinary function or method call prefixed by the keyword defer. The function and argument expressions are evaluated when the statement is executed, but the actual call is deferred until the function that contains the defer statement has finished, whether normally, by executing a return statement or falling off the end, or abnormally, by panicking. Any number of calls may be deferred; they are executed in the reverse of the order in which they were deferred.&lt;/p&gt;

&lt;p&gt;A defer statement is often used with paired operations like open and close, connect and disconnect, or lock and unlock to ensure that resources are released in all cases, no matter how complex the control flow. The right place for a defer statement that releases a resource is immediately after the resource has been successfully acquired. In the title function below, a single deferred call replaces both previous calls to
resp.Body.Close():&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch5/title2 
func title(url string) error {
resp, err := http.Get(url) 
if err != nil {
return err 
}
defer resp.Body.Close() 
ct := resp.Header.Get(&amp;quot;Content-Type&amp;quot;) 
if ct != &amp;quot;text/html&amp;quot; &amp;amp;&amp;amp; !strings.HasPrefix(ct, 
&amp;quot;text/html;&amp;quot;) {
return fmt.Errorf(&amp;quot;%s has type %s, not 
text/html&amp;quot;, url, ct) 
} 

doc, err := html.Parse(resp.Body) if err != nil {return fmt.Errorf(&amp;quot;parsing %s as HTML: %v&amp;quot;, url, err) } 
// ...print doc&#39;s title element... 
return nil 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same pattern can be used for other resources beside network connections, for instance to close an open file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;io/ioutil 
package ioutil 
func ReadFile(filename string) ([]byte, error) { 
f, err := os.Open(filename) 

if err != nil {
return nil, err }
defer f.Close() 
return ReadAll(f) } 
or to unlock a mutex (§9.2): 
var mu sync.Mutex 
var m = make(map[string]int) 
func lookup(key string) int {
mu.Lock()
defer mu.Unlock() 
return m[key] } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The defer statement can also be used to pair “on entry” and “on exit” actions when debugging a complex function. The bigSlowOperation function below calls trace immediately, which does the “on entry” action then returns a function value that, when called, does the corresponding “on exit” action. By deferring a call to the returned function in this way, we can instrument the entry point and all exit points of a function in a single statement and even pass values, like the start time, between the two actions. But don’t forget the final parentheses in the defer statement, or the “on entry” action will happen on exit and the on-exit action won’t happen at all!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch5/trace 
func bigSlowOperation() {
defer trace(&amp;quot;bigSlowOperation&amp;quot;)() // don&#39;t forget 
the extra parentheses 
// ...lots of work... 
time.Sleep(10 * time.Second) // simulate slow 
operation by sleeping 
} 
func trace(msg string) func() { 
start := time.Now() 

log.Printf(&amp;quot;enter %s&amp;quot;, msg) 
return func() { log.Printf(&amp;quot;exit %s (%s)&amp;quot;, msg, time.Since(start)) }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each time bigSlowOperation is called, it logs its entry and exit and the elapsed time between them. (We used time.Sleep to simulate a slow operation.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch5/trace 
$ ./trace
2015/11/18 09:53:26 enter bigSlowOperation 
2015/11/18 09:53:36 exit bigSlowOperation 
(10.000589217s) 

Deferred functions run after return statements have updated the function’s result variables. Because an anonymous function can access its enclosing function’s variables, including named results, a deferred anonymous function can observe the function’s results. 
Consider the function double: 

```go
func double(x int) int {
return x + x 
} 

By naming its result variable and adding a defer statement, we can make the function print its arguments and results each time it is called. 

```go
func double(x int) (result int) { defer func() { fmt.Printf(&amp;quot;double(%d) = %d\n&amp;quot;, x, result) }()return x + x } 
_ = double(4) 
// Output: 
// &amp;quot;double(4) = 8&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This trick is overkill for a function as simple as double but may be useful in functions with many return statements.&lt;/p&gt;

&lt;p&gt;A deferred anonymous function can even change the values that the enclosing function returns to its caller:
func triple(x int) (result int) {
defer func() { result += x }()
return double(x)&lt;/p&gt;

&lt;p&gt;}
fmt.Println(triple(4)) // &amp;ldquo;12&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

Because deferred functions aren’t executed until the very end of a function’s execution, a defer statement in a loop deserves extra scrutiny. The code below could run out of file descriptors since no file will be closed until all files have been processed: 

```go
for     _, filename := range filenames {
f, err := os.Open(filename) 
if err != nil {

return err }defer f.Close() // NOTE: risky; could run out of 
file descriptors
// ...process f... 
} 


One solution is to move the loop body, including the defer statement, into another function that is called on each iteration. 

```go
for _, filename := range filenames {
if err := doFile(filename); err != nil {
return err 
}
} 

func doFile(filename string) error { 
f, err := os.Open(filename) 
if err != nil {

return err 
}
defer f.Close() 
// ...process f... 

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example below is an improved fetch program (§1.5) that writes the HTTP response to a local file instead of to the standard output. It derives the file name from the last component of the URL path, which it obtains using the path.Base function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch5/fetch 
// Fetch downloads the URL and returns the 
// name and length of the local file. 
func fetch(url string) (filename string, n int64, err 
error) {

resp, err := http.Get(url) 
if err != nil {

return &amp;quot;&amp;quot;, 0, err 
}
defer resp.Body.Close() 

local := path.Base(resp.Request.URL.Path) if local == &amp;quot;/&amp;quot; {
local = &amp;quot;index.html&amp;quot; 
}
f, err := os.Create(local) 
if err != nil {

return &amp;quot;&amp;quot;, 0, err }n, err = io.Copy(f, resp.Body) // Close file, but prefer error from Copy, if any. if closeErr := f.Close(); err == nil {
err = closeErr 
}return local, n, err }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The deferred call to resp.Body.Close should be familiar by now. It’s tempting to use a second deferred call, to f.Close, to close the local file, but this would be subtly wrong because os.Create opens a file for writing, creating it as needed. On many file systems, notably NFS, write errors are not reported immediately but may be postponed until the file is closed. Failure to check the result of the close operation could cause serious data loss to go unnoticed. However, if both io.Copy and f.Close fail, we should prefer to report the error from io.Copy since it occurred first and is more likely to tell us the root cause.&lt;/p&gt;

&lt;p&gt;Exercise 5.18: Without changing its behavior, rewrite the fetch function to use defer to close the writable file.&lt;/p&gt;

&lt;h2 id=&#34;panic:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Panic&lt;/h2&gt;

&lt;p&gt;Go’s type system catches many mistakes at compile time, but others, like an out-of­bounds array access or nil pointer dereference, require checks at run time. When the Go runtime detects these mistakes, it panics.
During a typical panic, normal execution stops, all deferred function calls in that goroutine are executed, and the program crashes with a log message. This log message includes the panic value, which is usually an error message of some sort, and, for each goroutine, a stack trace showing the stack of function calls that were active at the time of the panic. This log message often has enough information to diagnose the root cause of the problem without running the program again, so it should always be included in a bug report about a panicking program.
Not all panics come from the runtime. The built-in panic function may be called directly; it accepts any value as an argument. A panic is often the best thing to do when some “impossible” situation happens, for instance, execution reaches a case that logically can’t happen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;switch s := suit(drawCard()); s {
case &amp;quot;Spades&amp;quot;: // ... 
case &amp;quot;Hearts&amp;quot;: // ... 
case &amp;quot;Diamonds&amp;quot;: // ... 
case &amp;quot;Clubs&amp;quot;: // ... 
default: 
panic(fmt.Sprintf(&amp;quot;invalid suit %q&amp;quot;, s)) // Joker? 
} 

It’s good practice to assert that the preconditions of a function hold, but this can easily be done to excess. Unless you can provide a more informative error message or detect an error sooner, there is no point asserting a condition that the runtime will check for you. 

```go
func Reset(x *Buffer) { 
if x == nil {
panic(&amp;quot;x is nil&amp;quot;) // unnecessary! 

}
x.elements = nil 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although Go’s panic mechanism resembles exceptions in other languages, the situations in which panic is used are quite different. Since a panic causes the program to crash, it is generally used for grave errors, such as a logical inconsistency in the program; diligent programmers consider any crash to be proof of a bug in their code. In a robust program, “expected” errors, the kind that arise from incorrect input, misconfiguration, or failing I/O, should be handled gracefully; they are best dealt with using error values.
Consider the function regexp.Compile, which compiles a regular expression into an efficient form for matching. It returns an error if called with an ill-formed pattern, but checking this error is unnecessary and burdensome if the caller knows that a particular call cannot fail. In such cases, it’s reasonable for the caller to handle an error by panicking, since it is believed to be impossible.&lt;/p&gt;

&lt;p&gt;Since most regular expressions are literals in the program source code, the regexp package provides a wrapper function regexp.MustCompile that does this check:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package regexp 
func Compile(expr string) (*Regexp, error) { /* ... */ 
} 
func MustCompile(expr string) *Regexp { 
re, err := Compile(expr) 
if err != nil {
panic(err) }
return re 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The wrapper function makes it convenient for clients to initialize a package-level variable with a compiled regular expression, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var httpSchemeRE = regexp.MustCompile(`^https?:`) // 
&amp;quot;http:&amp;quot; or &amp;quot;https:&amp;quot; 
Of course, MustCompile should not be called with untrusted input values. The Must prefix is a common naming convention for functions of this kind, like template.Must in Section 4.6. 

When a panic occurs, all deferred functions are run in reverse order, starting with those of the topmost function on the stack and proceeding up to main, as the program below demonstrates: 

```go
// gopl.io/ch5/defer1 
func main() {
f(3) 
} 

func f(x int) {fmt.Printf(&amp;quot;f(%d)\n&amp;quot;, x+0/x) // panics if x == 0 defer fmt.Printf(&amp;quot;defer %d\n&amp;quot;, x) f(x -1) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When run, the program prints the following to the standard output:
f(3)
f(2)
f(1)
defer 1
defer 2
defer 3&lt;/p&gt;

&lt;p&gt;A panic occurs during the call to f(0), causing the three deferred calls to fmt.Printf to run. Then the runtime terminates the program, printing the panic message and a stack dump to the standard error stream (simplified for clarity):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;panic: runtime error: integer divide by zero 
main.f(0)
src/// gopl.io/ch5/defer1/defer.go:14
main.f(1) 

src/// gopl.io/ch5/defer1/defer.go:16
main.f(2)
src/// gopl.io/ch5/defer1/defer.go:16 

main.f(3)
src/// gopl.io/ch5/defer1/defer.go:16
main.main()
src/// gopl.io/ch5/defer1/defer.go:10 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we will see soon, it is possible for a function to recover from a panic so that it does not terminate the program.&lt;/p&gt;

&lt;p&gt;For diagnostic purposes, the runtime package lets the programmer dump the stack using the same machinery. By deferring a call to printStack in main,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch5/defer2 
func main() {
defer printStack() 
f(3) 

} 
func printStack() {
var buf [4096]byte 
n := runtime.Stack(buf[:], false) 
os.Stdout.Write(buf[:n]) 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the following additional text (again simplified for clarity) is printed to the standard output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;goroutine 1 [running]:
main.printStack()
src/// gopl.io/ch5/defer2/defer.go:20
main.f(0)
src/// gopl.io/ch5/defer2/defer.go:27
main.f(1)
src/// gopl.io/ch5/defer2/defer.go:29 

main.f(2)
src/// gopl.io/ch5/defer2/defer.go:29
main.f(3)
src/// gopl.io/ch5/defer2/defer.go:29
main.main()
src/// gopl.io/ch5/defer2/defer.go:15 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Readers familiar with exceptions in other languages may be surprised that runtime.Stack can print information about functions that seem to have already been “unwound.” Go’s panic mechanism runs the deferred functions before it unwinds the stack.
5.10 Recover
Giving up is usually the right response to a panic, but not always. It might be possible to recover in some way, or at least clean up the mess before quitting. For example, a web server that encounters an unexpected problem could close the connection rather than leave the client hanging, and during development, it might report the error to the client too.&lt;/p&gt;

&lt;p&gt;If the built-in recover function is called within a deferred function and the function containing the defer statement is panicking, recover ends the current state of panic and returns the panic value. The function that was panicking does not continue where it left off but returns normally. If recover is called at any other time, it has no effect and returns nil.&lt;/p&gt;

&lt;p&gt;To illustrate, consider the development of a parser for a language. Even when it appears to be working well, given the complexity of its job, bugs may still lurk in obscure corner cases. We might prefer that, instead of crashing, the parser turns these panics into ordinary parse errors, perhaps with an extra message exhorting the user to file a bug report.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Parse(input string) (s *Syntax, err error) { 
defer func() { 
if p := recover(); p != nil {
err = fmt.Errorf(&amp;quot;internal error: %v&amp;quot;, p) }}()
// ...parser... 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The deferred function in Parse recovers from a panic, using the panic value to construct an error message; a fancier version might include the entire call stack using runtime.Stack. The deferred function then assigns to the err result, which is returned to the caller.
Recovering indiscriminately from panics is a dubious practice because the state of a package’s variables after a panic is rarely well defined or documented. Perhaps a critical update to a data structure was incomplete, a file or network connection was opened but not closed, or a lock was acquired but not released. Furthermore, by replacing a crash with, say, a line in a log file, indiscriminate recovery may cause bugs to go unnoticed.
Recovering from a panic within the same package can help simplify the handling of complex or unexpected errors, but as a general rule, you should not attempt to recover from another package’s panic. Public APIs should report failures as errors. Similarly, you should not recover from a panic that may pass through a function you do not maintain, such as a caller-provided callback, since you cannot reason about its safety.&lt;/p&gt;

&lt;p&gt;For example, the net/http package provides a web server that dispatches incoming requests to user-provided handler functions. Rather than let a panic in one of these handlers kill the process, the server calls recover, prints a stack trace, and continues serving. This is convenient in practice, but it does risk leaking resources or leaving the failed handler in an unspecified state that could lead to other problems.&lt;/p&gt;

&lt;p&gt;For all the above reasons, it’s safest to recover selectively if at all. In other words, recover only from panics that were intended to be recovered from, which should be rare. This intention can be encoded by using a distinct, unexported type for the panic value and testing whether the value returned by recover has that type. (We’ll see one way to do this in the next example.) If so, we report the panic as an ordinary error; if not, we call panic with the same value to resume the state of panic.&lt;/p&gt;

&lt;p&gt;The example below is a variation on the title program that reports an error if the HTML document contains multiple &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; elements. If so, it aborts the recursion by calling panic with a value of the special type bailout.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch5/title3 
// soleTitle returns the text of the first non-empty 
title element 
// in doc, and an error if there was not exactly one. 
func soleTitle(doc *html.Node) (title string, err 
error) {type bailout struct{} 
defer func() {
switch p := recover(); p { 

case nil: 
// no panic 
case bailout{}:
// &amp;quot;expected&amp;quot; panic 
err = fmt.Errorf(&amp;quot;multiple title elements&amp;quot;)default: 
panic(p) // unexpected panic; carry on panicking
}}() 
// Bail out of recursion if we find more than one 
non-empty title. 
forEachNode(doc, func(n *html.Node) { 
if n.Type == html.ElementNode &amp;amp;&amp;amp; n.Data == &amp;quot;title&amp;quot; &amp;amp;&amp;amp; n.FirstChild != nil {
if title != &amp;quot;&amp;quot; {
panic(bailout{}) // multiple title elements }
title = n.FirstChild.Data 
}
}, nil) 
if title == &amp;quot;&amp;quot; {
return &amp;quot;&amp;quot;, fmt.Errorf(&amp;quot;no title element&amp;quot;) }
return title, nil } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The deferred handler function calls recover, checks the panic value, and reports an ordinary error if the value was bailout{}. All other non-nil values indicate an unexpected panic, in which case the handler calls panic with that value, undoing the effect of recover and resuming the original state of panic. (This example does somewhat violate our advice about not using panics for “expected” errors, but it provides a compact illustration of the mechanics.)
From some conditions there is no recovery. Running out of memory, for example, causes the Go runtime to terminate the program with a fatal error.&lt;/p&gt;

&lt;p&gt;Exercise 5.19: Use panic and recover to write a function that contains no return statement yet returns a non-zero value.
6. Methods&lt;/p&gt;

&lt;p&gt;Since the early 1990s, object-oriented programming (OOP) has been the dominant programming paradigm in industry and education, and nearly all widely used languages developed since then have included support for it. Go is no exception.&lt;/p&gt;

&lt;p&gt;Although there is no universally accepted definition of object-oriented programming, for our purposes, an object is simply a value or variable that has methods, and a method is a function associated with a particular type. An object-oriented program is one that uses methods to express the properties and operations of each data structure so that clients need not access the object’s representation directly.&lt;/p&gt;

&lt;p&gt;In earlier chapters, we have made regular use of methods from the standard library, like the Seconds method of type time.Duration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const day = 24 * time.Hour 
fmt.Println(day.Seconds()) // &amp;quot;86400&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we defined a method of our own in Section 2.5, a String method for the Celsius type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c Celsius) String() string { return 
fmt.Sprintf(&amp;quot;%g°C&amp;quot;, c) } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this chapter, the first of two on object-oriented programming, we’ll show how to define and use methods effectively. We’ll also cover two key principles of object-oriented programming, encapsulation and composition.&lt;/p&gt;

&lt;h2 id=&#34;method-declarations:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Method Declarations&lt;/h2&gt;

&lt;p&gt;A method is declared with a variant of the ordinary function declaration in which an extra parameter appears before the function name. The parameter attaches the function to the type of that parameter.
Let’s write our first method in a simple package for plane geometry:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch6/geometry 
package geometry 
import &amp;quot;math&amp;quot; 
type Point struct{ X, Y float64 } 
// traditional function 
func Distance(p, q Point) float64 {
return math.Hypot(q.X-p.X, q.Y-p.Y) 
} 

// same thing, but as a method of the Point type 
func (p Point) Distance(q Point) float64 {
return math.Hypot(q.X-p.X, q.Y-p.Y) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The extra parameter p is called the method’s receiver, a legacy from early object-oriented languages that described calling a method as “sending a message to an object.”&lt;/p&gt;

&lt;p&gt;In Go, we don’t use a special name like this or self for the receiver; we choose receiver names just as we would for any other parameter. Since the receiver name will be frequently used, it’s a good idea to choose something short and to be consistent across methods. A common choice is the first letter of the type name, like p for Point.&lt;/p&gt;

&lt;p&gt;In a method call, the receiver argument appears before the method name. This parallels the declaration, in which the receiver parameter appears before the method name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;p := Point{1, 2} 
q := Point{4, 6}
fmt.Println(Distance(p, q)) // &amp;quot;5&amp;quot;, function call 
fmt.Println(p.Distance(q)) // &amp;quot;5&amp;quot;, method call 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There’s no conflict between the two declarations of functions called Distance above. The first declares a package-level function called geometry.Distance. The second declares a method of the type Point, so its name is Point.Distance.&lt;/p&gt;

&lt;p&gt;The expression p.Distance is called a selector, because it selects the appropriate Distance method for the receiver p of type Point. Selectors are also used to select fields of struct types, as in p.X. Since methods and fields inhabit the same name space, declaring a method X on the struct type Point would be ambiguous and the compiler will reject it.&lt;/p&gt;

&lt;p&gt;Since each type has its own name space for methods, we can use the name Distance for other methods so long as they belong to different types. Let’s define a type Path that represents a sequence of line segments and give it a Distance method too.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// A Path is a journey connecting the points with 
straight lines. 
type Path []Point 
// Distance returns the distance traveled along the path.
func (path Path) Distance() float64 {
sum := 0.0 
for i := range path {
if i &amp;gt; 0 {
sum += path[i-1].Distance(path[i]) 
}}
return sum } 
Path is a named slice type, not a struct type like Point, yet we can still define methods for it. In allowing methods to be associated with any type, Go is unlike many other object-oriented languages. It is often convenient to define additional behaviors for simple types such as numbers, strings, slices, maps, and sometimes even functions. Methods may be declared on any named type defined in the same package, so long as its underlying type is neither a pointer nor an interface. 

The two Distance methods have different types. They’re not related to each other at all, though Path.Distance uses Point.Distance internally to compute the length of each segment that connects adjacent points. 
Let’s call the new method to compute the perimeter of a right triangle: 


```go
perim := Path{ 
{1, 1}, 
{5, 1}, 
{5, 4}, 
{1, 1}, }
fmt.Println(perim.Distance()) // &amp;quot;12&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the two calls above to methods named Distance, the compiler determines which function to call based on both the method name and the type of the receiver. In the first, path[i-1] has type Point so Point.Distance is called; in the second, perim has type Path, so Path.Distance is called.
All methods of a given type must have unique names, but different types can use the same name for a method, like the Distance methods for Point and Path; there’s no need to qualify function names (for example, PathDistance) to disambiguate. Here we see the first benefit to using methods over ordinary functions: method names can be shorter. The benefit is magnified for calls originating outside the package, since they can use the shorter name and omit the package name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;// gopl.io/ch6/geometry&amp;quot; 

perim := geometry.Path{{1, 1}, {5, 1}, {5, 4}, {1, 1}} 
fmt.Println(geometry.PathDistance(perim)) // &amp;quot;12&amp;quot;, 
standalone function 
fmt.Println(perim.Distance()) // &amp;quot;12&amp;quot;, method of geometry.Path 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;methods-with-a-pointer-receiver:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Methods with a Pointer Receiver&lt;/h2&gt;

&lt;p&gt;Because calling a function makes a copy of each argument value, if a function needs to update a variable, or if an argument is so large that we wish to avoid copying it, we must pass the address of the variable using a pointer. The same goes for methods that need to update the receiver variable: we attach them to the pointer type, such as *Point.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (p *Point) ScaleBy(factor float64) { 
p.X *= factor 
p.Y *= factor 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The name of this method is (*Point).ScaleBy. The parentheses are necessary; without them, the expression would be parsed as *(Point.ScaleBy).&lt;/p&gt;

&lt;p&gt;In a realistic program, convention dictates that if any method of Point has a pointer receiver, then all methods of Point should have a pointer receiver, even ones that don’t strictly need it. We’ve broken this rule for Point so that we can show both kinds of method.
Named types (Point) and pointers to them (*Point) are the only types that may appear in a receiver declaration. Furthermore, to avoid ambiguities, method declarations are not permitted on named types that are themselves pointer types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type P *int 
func (P) f() { /* ... */ } // compile error: invalid 
receiver type 

The (*Point).ScaleBy method can be called by providing a *Point receiver, like this: 
r := &amp;amp;Point{1, 2} 
r.ScaleBy(2)
fmt.Println(*r) // &amp;quot;{2, 4}&amp;quot; 
or this: 
p := Point{1, 2} 
pptr := &amp;amp;p
pptr.ScaleBy(2)
fmt.Println(p) // &amp;quot;{2, 4}&amp;quot; 

or this: 
p := Point{1, 2}
(&amp;amp;p).ScaleBy(2)
fmt.Println(p) // &amp;quot;{2, 4}&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But the last two cases are ungainly. Fortunately, the language helps us here. If the receiver p is a variable of type Point but the method requires a *Point receiver, we can use this shorthand:
p.ScaleBy(2)
and the compiler will perform an implicit &amp;amp;p on the variable. This works only for variables, including struct fields like p.X and array or slice elements like perim[0]. We cannot call a *Point method on a non-addressable Point receiver, because there’s no way to obtain the address of a temporary value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Point{1, 2}.ScaleBy(2) // compile error: can&#39;t take address of Point literal 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But we can call a Point method like Point.Distance with a *Point receiver, because there is a way to obtain the value from the address: just load the value pointed to by the receiver. The compiler inserts an implicit * operation for us. These two function calls are equivalent:
pptr.Distance(q)
(*pptr).Distance(q)&lt;/p&gt;

&lt;p&gt;Let’s summarize these three cases again, since they are a frequent point of confusion. In every valid method call expression, exactly one of these three statements is true.
Either the receiver argument has the same type as the receiver parameter, for example both have type T or both have type *T:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Point{1, 2}.Distance(q) // Point 
pptr.ScaleBy(2) // *Point 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or the receiver argument is a variable of type T and the receiver parameter has type *T. The compiler implicitly takes the address of the variable:
p.ScaleBy(2) // implicit (&amp;amp;p)
Or the receiver argument has type *T and the receiver parameter has type T. The compiler implicitly dereferences the receiver, in other words, loads the value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;pptr.Distance(q) // implicit (*pptr) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If all the methods of a named type T have a receiver type of T itself (not *T), it is safe to copy instances of that type; calling any of its methods necessarily makes a copy. For example, time.Duration values are liberally copied, including as arguments to functions. But if any method has a pointer receiver, you should avoid copying instances of T because doing so may violate internal invariants. For example, copying an instance of bytes.Buffer would cause the original and the copy to alias (§2.3.2) the same underlying array of bytes. Subsequent method calls would have unpredictable effects.&lt;/p&gt;

&lt;h3 id=&#34;nil-is-a-valid-receiver-value:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Nil Is a Valid Receiver Value&lt;/h3&gt;

&lt;p&gt;Just as some functions allow nil pointers as arguments, so do some methods for their receiver, especially if nil is a meaningful zero value of the type, as with maps and slices. In this simple linked list of integers, nil represents the empty list:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// An IntList is a linked list of integers. 
// A nil *IntList represents the empty list. 
type IntList struct {
Value int 
Tail *IntList 
} 
// Sum returns the sum of the list elements. 
func (list *IntList) Sum() int {
if list == nil { 

return 0 
}
return list.Value + list.Tail.Sum() 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you define a type whose methods allow nil as a receiver value, it’s worth pointing this out explicitly in its documentation comment, as we did above.&lt;/p&gt;

&lt;p&gt;Here’s part of the definition of the Values type from the net/url package:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;net/url 
package url 
// Values maps a string key to a list of values. 
type Values map[string][]string 

// Get returns the first value associated with the given key, 
// or &amp;quot;&amp;quot; if there are none. 
func (v Values) Get(key string) string { 

if vs := v[key]; len(vs) &amp;gt; 0 {
return vs[0] 
}
return &amp;quot;&amp;quot; 

} 

// Add adds the value to key. 
// It appends to any existing values associated with key.
func (v Values) Add(key, value string) { 

v[key] = append(v[key], value) 
} 


It exposes its representation as a map but also provides methods to simplify access to the map, whose values are slices of strings—it’s a multimap. Its clients can use its intrinsic operators (make, slice literals, m[key], and so on), or its methods, or both, as they prefer: 

```go
// gopl.io/ch6/urlvalues 
m := url.Values{&amp;quot;lang&amp;quot;: {&amp;quot;en&amp;quot;}} // direct construction 
m.Add(&amp;quot;item&amp;quot;, &amp;quot;1&amp;quot;) 
m.Add(&amp;quot;item&amp;quot;, &amp;quot;2&amp;quot;) 

fmt.Println(m.Get(&amp;quot;lang&amp;quot;)) // &amp;quot;en&amp;quot; 
fmt.Println(m.Get(&amp;quot;q&amp;quot;)) // &amp;quot;&amp;quot; 
fmt.Println(m.Get(&amp;quot;item&amp;quot;)) // &amp;quot;1&amp;quot; (first value) 
fmt.Println(m[&amp;quot;item&amp;quot;]) // &amp;quot;[1 2]&amp;quot; (direct map 
access) 

m = nil 
fmt.Println(m.Get(&amp;quot;item&amp;quot;)) // &amp;quot;&amp;quot; 
m.Add(&amp;quot;item&amp;quot;, &amp;quot;3&amp;quot;) // panic: assignment to 
entry in nil map 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the final call to Get, the nil receiver behaves like an empty map. We could equivalently have written it as Values(nil).Get(&amp;ldquo;item&amp;rdquo;)), but nil.Get(&amp;ldquo;item&amp;rdquo;) will not compile because the type of nil has not been determined. By contrast, the final call to Add panics as it tries to update a nil map.&lt;/p&gt;

&lt;p&gt;Because url.Values is a map type and a map refers to its key/value pairs indirectly, any updates and deletions that url.Values.Add makes to the map elements are visible to the caller. However, as with ordinary functions, any changes a method makes to the reference itself, like setting it to nil or making it refer to a different map data structure, will not be reflected in the caller.&lt;/p&gt;

&lt;h2 id=&#34;composing-types-by-struct-embedding:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Composing Types by Struct Embedding&lt;/h2&gt;

&lt;p&gt;Consider the type ColoredPoint:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch6/coloredpoint 
import &amp;quot;image/color&amp;quot; 
type Point struct{ X, Y float64 } 
type ColoredPoint struct {
Point 
Color color.RGBA 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could have defined ColoredPoint as a struct of three fields, but instead we embedded a Point to provide the X and Y fields. As we saw in Section 4.4.3, embedding lets us take a syntactic shortcut to defining a ColoredPoint that contains all the fields of Point, plus some more. If we want, we can select the fields of ColoredPoint that were contributed by the embedded Point without mentioning Point:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var cp ColoredPoint 
cp.X = 1 
fmt.Println(cp.Point.X) // &amp;quot;1&amp;quot; 
cp.Point.Y = 2 
fmt.Println(cp.Y) // &amp;quot;2&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A similar mechanism applies to the methods of Point. We can call methods of the embedded Point field using a receiver of type ColoredPoint, even though ColoredPoint has no declared methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;red := color.RGBA{255, 0, 0, 255} 
blue := color.RGBA{0, 0, 255, 255} 

var p = ColoredPoint{Point{1, 1}, red} 
var q = ColoredPoint{Point{5, 4}, blue}
fmt.Println(p.Distance(q.Point)) // &amp;quot;5&amp;quot; 
p.ScaleBy(2)
q.ScaleBy(2)
fmt.Println(p.Distance(q.Point)) // &amp;quot;10&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The methods of Point have been promoted to ColoredPoint. In this way, embedding allows complex types with many methods to be built up by the composition of several fields, each providing a few methods.&lt;/p&gt;

&lt;p&gt;Readers familiar with class-based object-oriented languages may be tempted to view Point as a base class and ColoredPoint as a subclass or derived class, or to interpret the relationship between these types as if a ColoredPoint “is a” Point. But that would be a mistake. Notice the calls to Distance above. Distance has a parameter of type Point, and q is not a Point, so although q does have an embedded field of that type, we must explicitly select it. Attempting to pass q would be an error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;p.Distance(q) // compile error: cannot use q
(ColoredPoint) as Point 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A ColoredPoint is not a Point, but it “has a” Point, and it has two additional methods Distance and ScaleBy promoted from Point. If you prefer to think in terms of implementation, the embedded field instructs the compiler to generate additional wrapper methods that delegate to the declared methods, equivalent to these:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (p ColoredPoint) Distance(q Point) float64 {
return p.Point.Distance(q) 
} 

func (p *ColoredPoint) ScaleBy(factor float64) { 
p.Point.ScaleBy(factor) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When Point.Distance is called by the first of these wrapper methods, its receiver value is p.Point, not p, and there is no way for the method to access the ColoredPoint in which the Point is embedded.&lt;/p&gt;

&lt;p&gt;The type of an anonymous field may be a pointer to a named type, in which case fields and methods are promoted indirectly from the pointed-to object. Adding another level of indirection lets us share common structures and vary the relationships between objects dynamically. The declaration of ColoredPoint below embeds a *Point:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ColoredPoint struct {
*Point 
Color color.RGBA 
} 
p := ColoredPoint{&amp;amp;Point{1, 1}, red} 
q := ColoredPoint{&amp;amp;Point{5, 4}, blue}
fmt.Println(p.Distance(*q.Point)) // &amp;quot;5&amp;quot; 
q.Point = p.Point // p and q now share 
the same Point 
p.ScaleBy(2)
fmt.Println(*p.Point, *q.Point) // &amp;quot;{2 2} {2 2}&amp;quot; 

A struct type may have more than one anonymous field. Had we declared ColoredPoint as 
type ColoredPoint struct {
Point 
color.RGBA 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then a value of this type would have all the methods of Point, all the methods of RGBA, and any additional methods declared on ColoredPoint directly. When the compiler resolves a selector such as p.ScaleBy to a method, it first looks for a directly declared method named ScaleBy, then for methods promoted once from ColoredPoint’s embedded fields, then for methods promoted twice from embedded fields within Point and RGBA, and so on. The compiler reports an error if the selector was ambiguous because two methods were promoted from the same rank.
Methods can be declared only on named types (like Point) and pointers to them (*Point), but thanks to embedding, it’s possible and sometimes useful for unnamed struct types to have methods too.&lt;/p&gt;

&lt;p&gt;Here’s a nice trick to illustrate. This example shows part of a simple cache implemented using two package-level variables, a mutex (§9.2) and the map that it guards:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var     (
mu sync.Mutex // guards mapping 
mapping = make(map[string]string) 

) 
func Lookup(key string) string { 
mu.Lock()
v := mapping[key]
mu.Unlock()
return v 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The version below is functionally equivalent but groups together the two related variables in a single package-level variable, cache:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var     cache = struct {
sync.Mutex
mapping map[string]string 

}{ 
mapping: make(map[string]string), 
} 

func Lookup(key string) string { 
    cache.Lock()
    v := cache.mapping[key]
    cache.Unlock()
    return v 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new variable gives more expressive names to the variables related to the cache, and because the sync.Mutex field is embedded within it, its Lock and Unlock methods are promoted to the unnamed struct type, allowing us to lock the cache with a self-explanatory syntax.&lt;/p&gt;

&lt;h2 id=&#34;method-values-and-expressions:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Method Values and Expressions&lt;/h2&gt;

&lt;p&gt;Usually we select and call a method in the same expression, as in p.Distance(), but it’s possible to separate these two operations. The selector p.Distance yields a method value, a function that binds a method (Point.Distance) to a specific receiver value p. This function can then be invoked without a receiver value; it needs only the non-receiver arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;p := Point{1, 2} 
q := Point{4, 6} 

distanceFromP := p.Distance // method value 
fmt.Println(distanceFromP(q)) // &amp;quot;5&amp;quot; 
var origin Point // {0, 0} 
fmt.Println(distanceFromP(origin)) //
&amp;quot;2.23606797749979&amp;quot;, v5 

scaleP := p.ScaleBy // method value 
scaleP(2) // p becomes (2, 4) 
scaleP(3) // then (6, 12) 
scaleP(10) // then (60, 120) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Method values are useful when a package’s API calls for a function value, and the client’s desired behavior for that function is to call a method on a specific receiver. For example, the function time.AfterFunc calls a function value after a specified delay. This program uses it to launch the rocket r after 10 seconds:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Rocket struct { /* ... */ } 
func (r *Rocket) Launch() { /* ... */ } 

r := new(Rocket)
time.AfterFunc(10 * time.Second, func() { r.Launch() 
}) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method value syntax is shorter: &lt;code&gt;time.AfterFunc(10 * time.Second, r.Launch)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Related to the method value is the method expression. When calling a method, as opposed to an ordinary function, we must supply the receiver in a special way using the selector syntax. A method expression, written T.f or (*T).f where T is a type, yields a function value with a regular first parameter taking the place of the receiver, so it can be called in the usual way.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;p := Point{1, 2} 
q := Point{4, 6} 

distance := Point.Distance // method expression 
fmt.Println(distance(p, q)) // &amp;quot;5&amp;quot; 
fmt.Printf(&amp;quot;%T\n&amp;quot;, distance) // &amp;quot;func(Point, Point) float64&amp;quot; 

scale := (*Point).ScaleBy 
scale(&amp;amp;p, 2)
fmt.Println(p) // &amp;quot;{2 4}&amp;quot; 
fmt.Printf(&amp;quot;%T\n&amp;quot;, scale) // &amp;quot;func(*Point, float64)&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Method expressions can be helpful when you need a value to represent a choice among several methods belonging to the same type so that you can call the chosen method with many different receivers. In the following example, the variable op represents either the addition or the subtraction method of type Point, and Path.TranslateBy calls it for each point in the Path:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Point struct{ X, Y float64 } 

func (p Point) Add(q Point) Point { return Point{p.X + 
q.X, p.Y + q.Y} } 
func (p Point) Sub(q Point) Point { return Point{p.X ­q.X, p.Y -q.Y} } 

type Path []Point 

func (path Path) TranslateBy(offset Point, add bool) { var op func(p, q Point) Point if add {
op = Point.Add 
} else {

op = Point.Sub 
}
for i := range path {

// Call either path[i].Add(offset) or path[i].Sub(offset).path[i] = op(path[i], offset) }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;example-bit-vector-type:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Example: Bit Vector Type&lt;/h2&gt;

&lt;p&gt;Sets in Go are usually implemented as a map[T]bool, where T is the element type. A set represented by a map is very flexible but, for certain problems, a specialized representation may outperform it. For example, in domains such as dataflow analysis where set elements are small non-negative integers, sets have many elements, and set operations like union and intersection are common, a bit vector is ideal.&lt;/p&gt;

&lt;p&gt;A bit vector uses a slice of unsigned integer values or “words,” each bit of which represents a possible element of the set. The set contains i if the i-th bit is set. The following program demonstrates a simple bit vector type with three methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch6/intset 
// An IntSet is a set of small non-negative integers. 
// Its zero value represents the empty set. 
type IntSet struct {
    words []uint64 
} 

// Has reports whether the set contains the non­negative value x. 
func (s *IntSet) Has(x int) bool {

word, bit := x/64, uint(x%64) 
return word &amp;lt; len(s.words) &amp;amp;&amp;amp; s.words[word]&amp;amp; 
(1&amp;lt;&amp;lt;bit) != 0 
} 

// Add adds the non-negative value x to the set. 
func (s *IntSet) Add(x int) { 
word, bit := x/64, uint(x%64) 
for word &amp;gt;= len(s.words) { 

s.words = append(s.words, 0) 
}
s.words[word] |= 1 &amp;lt;&amp;lt; bit 

} 
// UnionWith sets s to the union of s and t. 
func (s *IntSet) UnionWith(t *IntSet) { 
    for i, tword := range t.words {
        if i &amp;lt; len(s.words) {
            s.words[i] |= tword 
        } else {
            s.words = append(s.words, tword) 
        }
    }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since each word has 64 bits, to locate the bit for x, we use the quotient x/64 as the word index and the remainder x%64 as the bit index within that word. The UnionWith operation uses the bitwise OR operator | to compute the union 64 elements at a time. (We’ll revisit the choice of 64-bit words in Exercise 6.5.)
This implementation lacks many desirable features, some of which are posed as exercises below, but one is hard to live without: way to print an IntSet as a string. Let’s give it a String method as we did with Celsius in Section 2.5:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// String returns the set as a string of the form &amp;quot;{1 2 3}&amp;quot;.
func (s *IntSet) String() string { 

var buf bytes.Buffer
buf.WriteByte(&#39;{&#39;)
for i, word := range s.words {

if word == 0 {
continue 
}
for j := 0; j &amp;lt; 64; j++ {

if word&amp;amp;(1&amp;lt;&amp;lt;uint(j)) != 0 {if buf.Len() &amp;gt; len(&amp;quot;{&amp;quot;) {
buf.WriteByte(&#39; &#39;) }fmt.Fprintf(&amp;amp;buf, &amp;quot;%d&amp;quot;, 64*i+j) 
}
}
} 

buf.WriteByte(&#39;}&#39;)
return buf.String() 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the similarity of the String method above with intsToString in Section 3.5.4; bytes.Buffer is often used this way in String methods. The fmt package treats types with a String method specially so that values of complicated types can display themselves in a user-friendly manner. Instead of printing the raw representation of the value (a struct in this case), fmt calls the String method. The mechanism relies on interfaces and type assertions, which we’ll explain in Chapter 7.&lt;/p&gt;

&lt;p&gt;We can now demonstrate IntSet in action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x, y IntSet 
x.Add(1)
x.Add(144)
x.Add(9)
fmt.Println(x.String()) // &amp;quot;{1 9 144}&amp;quot; 
y.Add(9)
y.Add(42)
fmt.Println(y.String()) // &amp;quot;{9 42}&amp;quot; 
x.UnionWith(&amp;amp;y)
fmt.Println(x.String()) // &amp;quot;{1 9 42 144}&amp;quot; 
fmt.Println(x.Has(9), x.Has(123)) // &amp;quot;true false&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A word of caution: we declared String and Has as methods of the pointer type *IntSet not out of necessity, but for consistency with the other two methods, which need a pointer receiver because they assign to s.words. Consequently, an IntSet value does not have a String method, occasionally leading to surprises like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(&amp;amp;x) // &amp;quot;{1 9 42 144}&amp;quot; 
fmt.Println(x.String()) // &amp;quot;{1 9 42 144}&amp;quot; fmt.Println(x) // &amp;quot;{[4398046511618 0 65536]}&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the first case, we print an *IntSet pointer, which does have a String method. In the second case, we call String() on an IntSet variable; the compiler inserts the implicit &amp;amp; operation, giving us a pointer, which has the String method. But in the third case, because the IntSet value does not have a String method, fmt.Println prints the representation of the struct instead. It’s important not to forget the &amp;amp; operator. Making String a method of IntSet, not *IntSet, might
set
be a good idea, but this is a case-by-case judgment.&lt;/p&gt;

&lt;p&gt;Exercise 6.1: Implement these additional methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (*IntSet) Len() elements  int  //  return  the  number  of  
func func from  (*IntSet) Remove(x int) (*IntSet) Clear() the set  // //  remove remove  x from the set all elements  
func  (*IntSet) Copy()  *IntSet  //  return  a  copy  of  the  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exercise 6.2: Define a variadic (*IntSet).AddAll(&amp;hellip;int) method that allows a list of values to be added, such as s.AddAll(1, 2, 3) .&lt;/p&gt;

&lt;p&gt;Exercise 6.3: (*IntSet).UnionWith computes the union of two sets using |, the word-parallel bitwise OR operator. Implement methods for IntersectWith, DifferenceWith, and SymmetricDifference for the corresponding set operations. (The symmetric difference of two sets contains the elements present in one set or the other but not both.)&lt;/p&gt;

&lt;p&gt;Exercise 6.4: Add a method Elems that returns a slice containing the elements of the set, suitable for iterating over with a range loop.&lt;/p&gt;

&lt;p&gt;Exercise 6.5: The type of each word used by IntSet is uint64, but 64-bit arithmetic may be inefficient on a 32-bit platform. Modify the program to use the uint type, which is the most efficient unsigned integer type for the platform. Instead of dividing by 64, define a constant holding the effective size of uint in bits, 32 or
64. You can use the perhaps too-clever expression 32 &amp;lt;&amp;lt; (^uint(0) &amp;gt;&amp;gt; 63) for this purpose.&lt;/p&gt;

&lt;h2 id=&#34;encapsulation:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Encapsulation&lt;/h2&gt;

&lt;p&gt;A variable or method of an object is said to be encapsulated if it is inaccessible to clients of the object. Encapsulation, sometimes called information hiding, is a key aspect of object-oriented programming.&lt;/p&gt;

&lt;p&gt;Gohas only one mechanism to control the visibility of names: capitalized identifiers are exported from the package in which they are defined, and uncapitalized names are not. The same mechanism that limits access to members of a package also limits access to the fields of a struct or the methods of a type. As a consequence, to encapsulate an object, we must make it a struct.
That’s the reason the IntSet type from the previous section was declared as a struct type even though it has only a single field:
type IntSet struct {
words []uint64
}&lt;/p&gt;

&lt;p&gt;We could instead define IntSet as a slice type as follows, though of course we’d have to replace each occurrence of s.words by *s in its methods:
type IntSet []uint64&lt;/p&gt;

&lt;p&gt;Although this version of IntSet would be essentially equivalent, it would allow clients from other packages to read and modify the slice directly. Put another way, whereas the expression *s could be used in any package, s.words may appear only in the package that defines IntSet.&lt;/p&gt;

&lt;p&gt;Another consequence of this name-based mechanism is that the unit of encapsulation is the package, not the type as in many other languages. The fields of a struct type are visible to all code within the same package. Whether the code appears in a function or a method makes no difference.
Encapsulation provides three benefits. First, because clients cannot directly modify the object’s variables, one need inspect fewer statements to understand the possible values of those variables.
Second, hiding implementation details prevents clients from depending on things that might change, which gives the designer greater freedom to evolve the implementation without breaking API compatibility.&lt;/p&gt;

&lt;p&gt;As an example, consider the bytes.Buffer type. It is frequently used to accumulate very short strings, so it is a profitable optimization to reserve a little extra space in the object to avoid memory allocation in this common case. Since Buffer is a struct type, this space takes the form of an extra field of type [64]byte with an uncapitalized name. When this field was added, because it was not exported, clients of Buffer outside the bytes package were unaware of any change except improved performance. Buffer and its Grow method are shown below, simplified for clarity:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Buffer struct {
buf []byte 
initial [64]byte 
/* ... */ 

} 
// Grow expands the buffer&#39;s capacity, if necessary, // to guarantee space for another n bytes. [...] func (b *Buffer) Grow(n int) { 
if b.buf == nil {b.buf = b.initial[:0] // use preallocated 
space initially 
}
if len(b.buf)+n &amp;gt; cap(b.buf) { 

buf := make([]byte, b.Len(), 2*cap(b.buf) + n) 
copy(buf, b.buf) 
b.buf = buf 

}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The third benefit of encapsulation, and in many cases the most important, is that it prevents clients from setting an object’s variables arbitrarily. Because the object’s variables can be set only by functions in the same package, the author of that package can ensure that all those functions maintain the object’s internal invariants. For example, the Counter type below permits clients to increment the counter or to reset it to zero, but not to set it to some arbitrary value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Counter struct { n int } 
func (c *Counter) N() int { return c.n }
func (c *Counter) Increment() { c.n++ }
func (c *Counter) Reset() { c.n = 0 } 
Functions that merely access or modify internal values of a type, such as the methods of the Logger type from log package, below, are called getters and setters. However, when naming a getter method, we usually omit the Get prefix. This preference for brevity extends to all methods, not just field accessors, and to other redundant prefixes as well, such as Fetch, Find, and Lookup. 

```go
package log 
type Logger struct {
flags int 
prefix string 
// ... 
} 
func (l *Logger) Flags() int 
func (l *Logger) SetFlags(flag int) 
func (l *Logger) Prefix() string 
func (l *Logger) SetPrefix(prefix string) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go style does not forbid exported fields. Of course, once exported, a field cannot be unexported without an incompatible change to the API, so the initial choice should be deliberate and should consider the complexity of the invariants that must be maintained, the likelihood of future changes, and the quantity of client code that would be affected by a change.
Encapsulation is not always desirable. By revealing its representation as an int64 number of nanoseconds, time.Duration lets us use all the usual arithmetic and comparison operations with durations, and even to define constants of this type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const day = 24 * time.Hour 
fmt.Println(day.Seconds()) // &amp;quot;86400&amp;quot; 

As another example, contrast IntSet with the geometry.Path type from the beginning of this chapter. Path was defined as a slice type, allowing its clients to construct instances using the slice literal syntax, to iterate over its points using a range loop, and so on, whereas these operations are denied to clients of IntSet. 

Here’s the crucial difference: geometry.Path is intrinsically a sequence of points, no more and no less, and we don’t foresee adding new fields to it, so it makes sense for the geometry package to reveal that Path is a slice. In contrast, an IntSet merely happens to be represented as a []uint64 slice. It could have been represented using []uint, or something completely different for sets that are sparse or very small, and it might perhaps benefit from additional features like an extra field to record the number of elements in the set. For these reasons, it makes sense for IntSet to be opaque. 


In this chapter, we learned how to associate methods with named types, and how to call those methods. Although methods are crucial to object-oriented programming, they’re only half the picture. To complete it, we need interfaces, the subject of the next chapter. 

7. Interfaces 

Interface types express generalizations or abstractions about the behaviors of other types. By generalizing, interfaces let us write functions that are more flexible and adaptable because they are not tied to the details of one particular implementation. 

Many object-oriented languages have some notion of interfaces, but what makes Go’s interfaces so distinctive is that they are satisfied implicitly. In other words, there’s no need to declare all the interfaces that a given concrete type satisfies; simply possessing the necessary methods is enough. This design lets you create new interfaces that are satisfied by existing concrete types without changing the existing types, which is particularly useful for types defined in packages that you don’t control. 

In this chapter, we’ll start by looking at the basic mechanics of interface types and their values. Along the way, we’ll study several important interfaces from the standard library. Many Go programs make as much use of standard interfaces as they do of their own ones. 
Finally, we’ll look at type assertions (§7.10) and type switches (§7.13) and see how they enable a different kind of generality. 


## Interfaces as Contracts 

All the types we’ve looked at so far have been concrete types. A concrete type specifies the exact representation of its values and exposes the intrinsic operations of that representation, such as arithmetic for numbers, or indexing, append, and range for slices. A concrete type may also provide additional behaviors through its methods. When you have a value of a concrete type, you know exactly what it is and what you can do with it. 

There is another kind of type in Go called an interface type. An interface is an abstract type. It doesn’t expose the representation or internal structure of its values, or the set of basic operations they support; it reveals only some of their methods. When you have a value of an interface type, you know nothing about what it is; you know only what it can do, or more precisely, what behaviors are provided by its methods. 
Throughout the book, we’ve been using two similar functions for string formatting: fmt.Printf, which writes the result to the standard output (a file), and fmt.Sprintf, which returns the result as a string. It would be unfortunate if the hard part, formatting the result, had to be duplicated because of these superficial differences in how the result is used. Thanks to interfaces, it does not. Both of these functions are, in effect, wrappers around a third function, fmt.Fprintf, that is agnostic about what happens to the result it computes: 


```go
package fmt 
func Fprintf(w io.Writer, format string, args ...interface{}) (int, error) 
func Printf(format string, args ...interface{}) (int, error) {return Fprintf(os.Stdout, format, args...) } 
func Sprintf(format string, args ...interface{}) string { 
    var buf bytes.Buffer
    Fprintf(&amp;amp;buf, format, args...)
    return buf.String()
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The F prefix of Fprintf stands for file and indicates that the formatted output should be written to the file provided as the first argument. In the Printf case, the argument, os.Stdout, is an *os.File. In the Sprintf case, however, the argument is not a file, though it superficially resembles one: &amp;amp;buf is a pointer to a memory buffer to which bytes can be written.&lt;/p&gt;

&lt;p&gt;The first parameter of Fprintf is not a file either. It’s an io.Writer, which is an interface type with the following declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package io 
// Writer is the interface that wraps the basic Write 
method. 
type Writer interface {
// Write writes len(p) bytes from p to the 
underlying data stream. 
// It returns the number of bytes written from p
(0 &amp;lt;= n &amp;lt;= len(p)) 
// and any error encountered that caused the write 
to stop early. 
// Write must return a non-nil error if it returns 
n &amp;lt; len(p).
// Write must not modify the slice data, even 
temporarily.
//
// Implementations must not retain p. 
Write(p []byte) (n int, err error) } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The io.Writer interface defines the contract between Fprintf and its callers. On the one hand, the contract requires that the caller provide a value of a concrete type like *os.File or *bytes.Buffer that has a method called Write with the appropriate signature and behavior. On the other hand, the contract guarantees that Fprintf will do its job given any value that satisfies the io.Writer
interface. Fprintf may not assume that it is writing to a file or to memory, only that it can call Write.&lt;/p&gt;

&lt;p&gt;Because fmt.Fprintf assumes nothing about the representation of the value and relies only on the behaviors guaranteed by the io.Writer contract, we can safely pass a value of any concrete type that satisfies io.Writer as the first argument to fmt.Fprintf. This freedom to substitute one type for another that satisfies the same interface is called substitutability, and is a hallmark of object-oriented programming.
Let’s test this out using a new type. The Write method of the *ByteCounter type below merely counts the bytes written to it before discarding them. (The conversion is required to make the types of len(p) and *c match in the += assignment statement.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch7/bytecounter 
type ByteCounter int 
func (c *ByteCounter) Write(p []byte) (int, error) { 
    *c += ByteCounter(len(p)) // convert int to ByteCounter
    return len(p), nil 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since *ByteCounter satisfies the io.Writer contract, we can pass it to Fprintf, which does its string formatting oblivious to this change; the ByteCounter correctly accumulates the length of the result.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var c ByteCounter
c.Write([]byte(&amp;quot;hello&amp;quot;))
fmt.Println(c) // &amp;quot;5&amp;quot;, = len(&amp;quot;hello&amp;quot;) 
c = 0 // reset the counter 
var name = &amp;quot;Dolly&amp;quot;
fmt.Fprintf(&amp;amp;c, &amp;quot;hello, %s&amp;quot;, name) 
fmt.Println(c) // &amp;quot;12&amp;quot;, = len(&amp;quot;hello, Dolly&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Besides io.Writer, there is another interface of great importance to the fmt package. Fprintf and Fprintln provide a way for types to control how their values are printed. In Section 2.5, we defined a String method for the Celsius type so that temperatures would print as &amp;ldquo;100°C&amp;rdquo;, and in Section 6.5 we equipped *IntSet with a String method so that sets would be rendered using traditional set notation like &amp;ldquo;{1 2 3}&amp;rdquo; . Declaring a String method makes a type satisfy one of the most widely used interfaces of all, fmt.Stringer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package fmt 
// The String method is used to print values passed 
// as an operand to any format that accepts a string 
// or to an unformatted printer such as Print. 
type Stringer interface {
    String() string 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We’ll explain how the fmt package discovers which values satisfy this interface in Section 7.10.&lt;/p&gt;

&lt;p&gt;Exercise 7.1: Using the ideas from ByteCounter, implement counters for words and for lines. You will find bufio.ScanWords useful.&lt;/p&gt;

&lt;p&gt;Exercise 7.2: Write a function CountingWriter with the signature below that, given an io.Writer, returns a new Writer that wraps the original, and a pointer to an int64 variable that at any moment contains the number of bytes written to the new Writer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func CountingWriter(w io.Writer) (io.Writer, *int64) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exercise 7.3: Write a String method for the *tree type in // gopl.io/ch4/treesort (§4.4) that reveals the sequence of values in the tree.&lt;/p&gt;

&lt;h2 id=&#34;interface-types:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Interface Types&lt;/h2&gt;

&lt;p&gt;Aninterface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface.&lt;/p&gt;

&lt;p&gt;The io.Writer type is one of the most widely used interfaces because it provides an abstraction of all the types to which bytes can be written, which includes files, memory buffers, network connections, HTTP clients, archivers, hashers, and so on. The io package defines many other useful interfaces. A Reader represents any type from which you can read bytes, and a Closer is any value that you can close, such as a file or a network connection. (By now you’ve probably noticed the naming convention for many of Go’s single-method interfaces.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package io 
type Reader interface {
    Read(p []byte) (n int, err error) 
} 

type Closer interface {
    Close() error 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking farther, we find declarations of new interface types as combinations of existing ones. Here are two examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ReadWriter interface {
    Reader 
    Writer 
} 
type ReadWriteCloser interface {
    Reader 
    Writer 
    Closer
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The syntax used above, which resembles struct embedding, lets us name another interface as a shorthand for writing out all of its methods. This is called embedding an interface. We could have written io.ReadWriter without embedding, albeit less succinctly, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ReadWriter interface {
    Read(p []byte) (n int, err error) 
    Write(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or even using a mixture of the two styles:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ReadWriter interface {
    Read(p []byte) (n int, err error) 
    Writer
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All three declarations have the same effect. The order in which the methods appear is&lt;/p&gt;

&lt;p&gt;immaterial. All that matters is the set of methods.&lt;/p&gt;

&lt;p&gt;Exercise 7.4: The strings.NewReader function returns a value that satisfies the
io.Reader interface (and others) by reading from its argument, a string.
Implement a simple version of NewReader yourself, and use it to make the HTML
parser (§5.2) take input from a string.&lt;/p&gt;

&lt;p&gt;Exercise 7.5: The LimitReader function in the io package accepts an
io.Reader r and a number of bytes n, and returns another Reader that reads
from r but reports an end-of-file condition after n bytes. Implement it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
func LimitReader(r io.Reader, n int64) io.Reader 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;interface-satisfaction:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Interface Satisfaction&lt;/h2&gt;

&lt;p&gt;A type satisfies an interface if it possesses all the methods the interface requires. For example, an *os.File satisfies io.Reader, Writer, Closer, and ReadWriter.A *bytes.Buffer satisfies Reader, Writer, and ReadWriter, but does not satisfy Closer because it does not have a Close method. As a shorthand, Go programmers often say that a concrete type “is a” particular interface type, meaning that it satisfies the interface. For example, a *bytes.Buffer is an io.Writer; an *os.File is an io.ReadWriter.&lt;/p&gt;

&lt;p&gt;The assignability rule (§2.4.2) for interfaces is very simple: an expression may be assigned to an interface only if its type satisfies the interface. So:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var w io.Writer w = os.Stdout // OK: *os.File has Write method w = new(bytes.Buffer) // OK: *bytes.Buffer has Write method w = time.Second // compile error: time.Duration lacks Write method 
var rwc io.ReadWriteCloser 
rwc = os.Stdout // OK: *os.File has Read, 
Write, Close methods 
rwc = new(bytes.Buffer) // compile error: 
*bytes.Buffer lacks Close method 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This rule applies even when the right-hand side is itself an interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;w = rwc // OK: io.ReadWriteCloser has Write method rwc = w // compile error: io.Writer lacks Close method 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because ReadWriter and ReadWriteCloser include all the methods of Writer, any type that satisfies ReadWriter or ReadWriteCloser necessarily satisfies Writer.
Before we go further, we should explain one subtlety in what it means for a type to have a method. Recall from Section 6.2 that for each named concrete type T, some of its methods have a receiver of type T itself whereas others require a *T pointer. Recall also that it is legal to call a *T method on an argument of type T so long as the argument is a variable; the compiler implicitly takes its address. But this is mere syntactic sugar: a value of type T does not possess all the methods that a *T pointer does, and as a result it might satisfy fewer interfaces.&lt;/p&gt;

&lt;p&gt;Anexample will make this clear. The String method of the IntSet type from Section 6.5 requires a pointer receiver, so we cannot call that method on a non-addressable IntSet value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type IntSet struct { /* ... */ } 
func (*IntSet) String() string 
var _ = IntSet{}.String() // compile error: String 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;requires *IntSet receiver
but we can call it on an IntSet variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var s IntSet 
var _ = s.String() // OK: s is a variable and &amp;amp;s has a 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;String method&lt;/p&gt;

&lt;p&gt;However, since only *IntSet has a String method, only *IntSet satisfies the fmt.Stringer interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var _ fmt.Stringer = &amp;amp;s // OK 
var _ fmt.Stringer = s // compile error: IntSet lacks 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;String method
Section 12.8 includes a program that prints the methods of an arbitrary value, and the godoc -analysis=type tool (§10.7.4) displays the methods of each type and the relationship between interfaces and concrete types.
Like an envelope that wraps and conceals the letter it holds, an interface wraps and conceals the concrete type and value that it holds. Only the methods revealed by the interface type may be called, even if the concrete type has others:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;os.Stdout.Write([]byte(&amp;quot;hello&amp;quot;)) // OK: *os.File has 
Write method 
os.Stdout.Close() // OK: *os.File has 
Close method 
var w io.Writer 
w = os.Stdout 
w.Write([]byte(&amp;quot;hello&amp;quot;)) // OK: io.Writer has Write 
method 
w.Close() // compile error: io.Writer lacks Close method 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aninterface with more methods, such as io.ReadWriter, tells us more about the values it contains, and places greater demands on the types that implement it, than does an interface with fewer methods such as io.Reader. So what does the type interface{}, which has no methods at all, tell us about the concrete types that satisfy it?
That’s right: nothing. This may seem useless, but in fact the type interface{}, which is called the empty interface type, is indispensable. Because the empty interface type places no demands on the types that satisfy it, we can assign any value to the empty interface.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var any interface{} 
any = true 
any = 12.34 
any = &amp;quot;hello&amp;quot; 
any = map[string]int{&amp;quot;one&amp;quot;: 1} 
any = new(bytes.Buffer) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although it wasn’t obvious, we’ve been using the empty interface type since the very first example in this book, because it is what allows functions like fmt.Println, or errorf in Section 5.7, to accept arguments of any type.&lt;/p&gt;

&lt;p&gt;Of course, having created an interface{} value containing a boolean, float, string, map, pointer, or any other type, we can do nothing directly to the value it holds
since the interface has no methods. We need a way to get the value back out again. We’ll see how to do that using a type assertion in Section 7.10.&lt;/p&gt;

&lt;p&gt;Since interface satisfaction depends only on the methods of the two types involved, there is no need to declare the relationship between a concrete type and the interfaces it satisfies. That said, it is occasionally useful to document and assert the relationship when it is intended but not otherwise enforced by the program. The declaration below asserts at compile time that a value of type *bytes.Buffer satisfies io.Writer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// *bytes.Buffer must satisfy io.Writer 
var w io.Writer = new(bytes.Buffer) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We needn’t allocate a new variable since any value of type *bytes.Buffer will do, even nil, which we write as (*bytes.Buffer)(nil) using an explicit conversion. And since we never intend to refer to w, we can replace it with the blank identifier. Together, these changes give us this more frugal variant:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// *bytes.Buffer must satisfy io.Writer 
var _ io.Writer = (*bytes.Buffer)(nil) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Non-empty interface types such as io.Writer are most often satisfied by a pointer type, particularly when one or more of the interface methods implies some kind of mutation to the receiver, as the Write method does. A pointer to a struct is an especially common method-bearing type.
But pointer types are by no means the only types that satisfy interfaces, and even interfaces with mutator methods may be satisfied by one of Go’s other reference types. We’ve seen examples of slice types with methods (geometry.Path, §6.1) and map types with methods (url.Values, §6.2.1), and later we’ll see a function type with methods (http.HandlerFunc, §7.7). Even basic types may satisfy interfaces; as we saw in Section 7.4, time.Duration satisfies fmt.Stringer.&lt;/p&gt;

&lt;p&gt;A concrete type may satisfy many unrelated interfaces. Consider a program that organizes or sells digitized cultural artifacts like music, films, and books. It might define the following set of concrete types:
Album
Book
Movie
Magazine
Podcast
TVEpisode
Track&lt;/p&gt;

&lt;p&gt;We can express each abstraction of interest as an interface. Some properties are common to all artifacts, such as a title, a creation date, and a list of creators (authors or artists).
type Artifact interface {
Title() string
Creators() []string
Created() time.Time&lt;/p&gt;

&lt;p&gt;}
Other properties are restricted to certain types of artifacts. Properties of the printed word are relevant only to books and magazines, whereas only movies and TV episodes have a screen resolution.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Text interface {
Pages() int 
Words() int 
PageSize() int 

} 
type Audio interface {
Stream() (io.ReadCloser, error) 
RunningTime() time.Duration 
Format() string // e.g., &amp;quot;MP3&amp;quot;, &amp;quot;WAV&amp;quot; 

} 
type Video interface {
Stream() (io.ReadCloser, error) 
RunningTime() time.Duration 
Format() string // e.g., &amp;quot;MP4&amp;quot;, &amp;quot;WMV&amp;quot; 
Resolution() (x, y int) 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These interfaces are but one useful way to group related concrete types together and express the facets they share in common. We may discover other groupings later. For example, if we find we need to handle Audio and Video items in the same way, we can define a Streamer interface to represent their common aspects without changing any existing type declarations.
type Streamer interface {
Stream() (io.ReadCloser, error)
RunningTime() time.Duration
Format() string }&lt;/p&gt;

&lt;p&gt;Each grouping of concrete types based on their shared behaviors can be expressed as an interface type. Unlike class-based languages, in which the set of interfaces satisfied by a class is explicit, in Go we can define new abstractions or groupings of interest when we need them, without modifying the declaration of the concrete type. This is particularly useful when the concrete type comes from a package written by a different author. Of course, there do need to be underlying commonalities in the concrete types.&lt;/p&gt;

&lt;h2 id=&#34;parsing-flags-with-flag-value:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Parsing Flags with flag.Value&lt;/h2&gt;

&lt;p&gt;In this section, we’ll see how another standard interface, flag.Value, helps us define new notations for command-line flags. Consider the program below, which sleeps for a specified period of time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch7/sleep 
var period = flag.Duration(&amp;quot;period&amp;quot;, 1*time.Second, &amp;quot;sleep period&amp;quot;) 
func main() {
flag.Parse()
fmt.Printf(&amp;quot;Sleeping for %v...&amp;quot;, *period) 
time.Sleep(*period)
fmt.Println() 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before it goes to sleep it prints the time period. The fmt package calls the time.Duration’s String method to print the period not as a number of nanoseconds, but in a user-friendly notation:
$ go build gopl.io/ch7/sleep
$ ./sleep
Sleeping for 1s&amp;hellip;&lt;/p&gt;

&lt;p&gt;By default, the sleep period is one second, but it can be controlled through the ­period command-line flag. The flag.Duration function creates a flag variable of type time.Duration and allows the user to specify the duration in a variety of user-friendly formats, including the same notation printed by the String method. This symmetry of design leads to a nice user interface.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ ./sleep -period 50ms 
Sleeping for 50ms... 
$ ./sleep -period 2m30s 
Sleeping for 2m30s... 

$ ./sleep -period 1.5h Sleeping for 1h30m0s... 
$ ./sleep -period &amp;quot;1 day&amp;quot; invalid value &amp;quot;1 day&amp;quot; for flag -period: time: invalid duration 1 day 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because duration-valued flags are so useful, this feature is built into the flagpackage, but it’s easy to define new flag notations for our own data types. We need only define a type that satisfies the flag.Value interface, whose declaration is below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package flag 
// Value is the interface to the value stored in a 
flag.
type Value interface {


String() string
Set(string) error 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The String method formats the flag’s value for use in command-line help messages; thus every flag.Value is also a fmt.Stringer. The Set method parses its string argument and updates the flag value. In effect, the Set method is the inverse of the String method, and it is good practice for them to use the same notation.
Let’s define a celsiusFlag type that allows a temperature to be specified in Celsius, or in Fahrenheit with an appropriate conversion. Notice that celsiusFlag embeds a Celsius (§2.5), thereby getting a String method for free. To satisfy flag.Value, we need only declare the Set method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch7/tempconv 
// *celsiusFlag satisfies the flag.Value interface. type celsiusFlag struct{ Celsius } 
func (f *celsiusFlag) Set(s string) error {
var unit string 

var value float64 fmt.Sscanf(s, &amp;quot;%f%s&amp;quot;, &amp;amp;value, &amp;amp;unit) // no error 
check needed 
switch unit {
case &amp;quot;C&amp;quot;, &amp;quot;°C&amp;quot;: 

f.Celsius = Celsius(value) 
return nil 

case &amp;quot;F&amp;quot;, &amp;quot;°F&amp;quot;: f.Celsius = FToC(Fahrenheit(value)) return nil 
}
return fmt.Errorf(&amp;quot;invalid temperature %q&amp;quot;, s) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call to fmt.Sscanf parses a floating-point number (value) and a string (unit) from the input s. Although one must usually check Sscanf’s error result, in this case we don’t need to because if there was a problem, no switch case will match.&lt;/p&gt;

&lt;p&gt;The CelsiusFlag function below wraps it all up. To the caller, it returns a pointer to the Celsius field embedded within the celsiusFlag variable f. The Celsius field is the variable that will be updated by the Set method during flags processing. The call to Var adds the flag to the application’s set of command-line flags, the global variable flag.CommandLine. Programs with unusually complex command-line interfaces may have several variables of this type. The call to Var assigns a *celsiusFlag argument to a flag.Value parameter, causing the compiler to check that *celsiusFlag has the necessary methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// CelsiusFlag defines a Celsius flag with the 
specified name, 
// default value, and usage, and returns the address 
of the flag variable. 
// The flag argument must have a quantity and a unit, 
e.g., &amp;quot;100C&amp;quot;. 
func CelsiusFlag(name string, value Celsius, usage 
string) *Celsius {

f := celsiusFlag{value}
flag.CommandLine.Var(&amp;amp;f, name, usage) 
return &amp;amp;f.Celsius 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can start using the new flag in our programs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch7/tempflag 
var temp = tempconv.CelsiusFlag(&amp;quot;temp&amp;quot;, 20.0, &amp;quot;the 
temperature&amp;quot;) 

func main() {
flag.Parse()
fmt.Println(*temp) 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here’s a typical session:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch7/tempflag 
$ ./tempflag
20°C 
$ ./tempflag -temp -18C 
-18°C 
$ ./tempflag -temp 212°F 
100°C 
$ ./tempflag -temp 273.15K 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;invalid value &amp;ldquo;273.15K&amp;rdquo; for flag -temp: invalid
temperature &amp;ldquo;273.15K&amp;rdquo;
Usage of ./tempflag:&lt;/p&gt;

&lt;p&gt;-temp   value
the temperature (default 20°C)
$ ./tempflag -help
Usage of ./tempflag:&lt;/p&gt;

&lt;p&gt;-temp   value
the temperature (default 20°C)&lt;/p&gt;

&lt;p&gt;Exercise 7.6: Add support for Kelvin temperatures to tempflag.&lt;/p&gt;

&lt;p&gt;Exercise 7.7: Explain why the help message contains °C when the default value of
20.0 does not.&lt;/p&gt;

&lt;h2 id=&#34;interface-values:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Interface Values&lt;/h2&gt;

&lt;p&gt;Conceptually, a value of an interface type, or interface value, has two components, a concrete type and a value of that type. These are called the interface’s dynamic type and dynamic value.&lt;/p&gt;

&lt;p&gt;For a statically typed language like Go, types are a compile-time concept, so a type is not a value. In our conceptual model, a set of values called type descriptors provide information about each type, such as its name and methods. In an interface value, the type component is represented by the appropriate type descriptor.&lt;/p&gt;

&lt;p&gt;In the four statements below, the variable w takes on three different values. (The initial and final values are the same.)
var w io.Writer
w = os.Stdout
w = new(bytes.Buffer)
w = nil
Let’s take a closer look at the value and dynamic behavior of w after each statement. The first statement declares w:
var w io.Writer&lt;/p&gt;

&lt;p&gt;In Go, variables are always initialized to a well-defined value, and interfaces are no exception. The zero value for an interface has both its type and value components set to nil (Figure 7.1).&lt;/p&gt;

&lt;p&gt;Aninterface value is described as nil or non-nil based on its dynamic type, so this is a nil interface value. You can test whether an interface value is nil using w == nil or w != nil . Calling any method of a nil interface value causes a panic:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;w.Write([]byte(&amp;quot;hello&amp;quot;)) // panic: nil pointer 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dereference&lt;/p&gt;

&lt;p&gt;The second statement assigns a value of type *os.File to w:
w = os.Stdout&lt;/p&gt;

&lt;p&gt;This assignment involves an implicit conversion from a concrete type to an interface type, and is equivalent to the explicit conversion io.Writer(os.Stdout).A conversion of this kind, whether explicit or implicit, captures the type and the value of its operand. The interface value’s dynamic type is set to the type descriptor for the pointer type *os.File, and its dynamic value holds a copy of os.Stdout, which is a pointer to the os.File variable representing the standard output of the process (Figure 7.2).&lt;/p&gt;

&lt;p&gt;Calling the Write method on an interface value containing an *os.File pointer causes the (*os.File).Write method to be called. The call prints &amp;ldquo;hello&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;w.Write([]byte(&amp;quot;hello&amp;quot;)) // &amp;quot;hello&amp;quot; 

In general, we cannot know at compile time what the dynamic type of an interface value will be, so a call through an interface must use dynamic dispatch. Instead of a direct call, the compiler must generate code to obtain the address of the method named Write from the type descriptor, then make an indirect call to that address. The receiver argument for the call is a copy of the interface’s dynamic value, os.Stdout. The effect is as if we had made this call directly: 

```go
os.Stdout.Write([]byte(&amp;quot;hello&amp;quot;)) // &amp;quot;hello&amp;quot; The third statement assigns a value of type *bytes.Buffer to the interface value: 
w = new(bytes.Buffer) 

The dynamic type is now *bytes.Buffer and the dynamic value is a pointer to the newly allocated buffer (Figure 7.3). 


A call to the Write method uses the same mechanism as before: 

```go
w.Write([]byte(&amp;quot;hello&amp;quot;)) // writes &amp;quot;hello&amp;quot; to the 
bytes.Buffer This time, the type descriptor is *bytes.Buffer, so the (*bytes.Buffer).Write method is called, with the address of the buffer as the value of the receiver parameter. The call appends &amp;quot;hello&amp;quot; to the buffer. 

Finally, the fourth statement assigns nil to the interface value: w = nil 

This resets both its components to nil, restoring w to the same state as when it was declared, which was shown in Figure 7.1. An interface value can hold arbitrarily large dynamic values. For example, the 
time.Time type, which represents an instant in time, is a struct type with several unexported fields. If we create an interface value from it, 
var x interface{} = time.Now() 
the result might look like Figure 7.4. Conceptually, the dynamic value always fits inside the interface value, no matter how large its type. (This is only a conceptual model; a realistic implementation is quite different.) 


Figure 7.4. An interface value holding a time.Time struct. 

Interface values may be compared using == and !=. Two interface values are equal if both are nil, or if their dynamic types are identical and their dynamic values are equal according to the usual behavior of == for that type. Because interface values are comparable, they may be used as the keys of a map or as the operand of a switch statement. 

However, if two interface values are compared and have the same dynamic type, but that type is not comparable (a slice, for instance), then the comparison fails with a panic: 

```go
var x interface{} = []int{1, 2, 3} 
fmt.Println(x == x) // panic: comparing uncomparable 
type []int 

In this respect, interface types are unusual. Other types are either safely comparable (like basic types and pointers) or not comparable at all (like slices, maps, and functions), but when comparing interface values or aggregate types that contain interface values, we must be aware of the potential for a panic. A similar risk exists when using interfaces as map keys or switch operands. Only compare interface values if you are certain that they contain dynamic values of comparable types. 

When handling errors, or during debugging, it is often helpful to report the dynamic type of an interface value. For that, we use the fmt package’s %T verb: 


```go
var w io.Writer 
fmt.Printf(&amp;quot;%T\n&amp;quot;, w) // &amp;quot;&amp;lt;nil&amp;gt;&amp;quot; 
w = os.Stdout 
fmt.Printf(&amp;quot;%T\n&amp;quot;, w) // &amp;quot;*os.File&amp;quot; 
w = new(bytes.Buffer)
fmt.Printf(&amp;quot;%T\n&amp;quot;, w) // &amp;quot;*bytes.Buffer&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Internally, fmt uses reflection to obtain the name of the interface’s dynamic type. We’ll look at reflection in Chapter 12.&lt;/p&gt;

&lt;h3 id=&#34;caveat-an-interface-containing-a-nil-pointer-is-non-nil:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Caveat: An Interface Containing a Nil Pointer Is Non-Nil&lt;/h3&gt;

&lt;p&gt;A nil interface value, which contains no value at all, is not the same as an interface value containing a pointer that happens to be nil. This subtle distinction creates a trap into which every Go programmer has stumbled.
Consider the program below. With debug set to true, the main function collects the output of the function f in a bytes.Buffer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const debug = true 
func main() {
var buf *bytes.Buffer 
if debug {

buf = new(bytes.Buffer) // enable collection 
of output
}
f(buf) // NOTE: subtly incorrect! 
if debug {

// ...use buf... 
}
} 

// If out is non-nil, output will be written to it. 
func f(out io.Writer) { 
// ...do something... 
if out != nil {

out.Write([]byte(&amp;quot;done!\n&amp;quot;)) 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We might expect that changing debug to false would disable the collection of the output, but in fact it causes the program to panic during the out.Write call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if out != nil {
out.Write([]byte(&amp;quot;done!\n&amp;quot;)) // panic: nil pointer 
dereference 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When main calls f, it assigns a nil pointer of type *bytes.Buffer to the out parameter, so the dynamic value of out is nil. However, its dynamic type is *bytes.Buffer, meaning that out is a non-nil interface containing a nil pointer value (Figure 7.5), so the defensive check out != nil is still true.&lt;/p&gt;

&lt;p&gt;As before, the dynamic dispatch mechanism determines that (*bytes.Buffer).Write must be called but this time with a receiver value that is nil. For some types, such as *os.File, nil is a valid receiver (§6.2.1), but *bytes.Buffer is not among them. The method is called, but it panics as it tries to access the buffer.&lt;/p&gt;

&lt;p&gt;The problem is that although a nil *bytes.Buffer pointer has the methods needed to satisfy the interface, it doesn’t satisfy the behavioral requirements of the interface. In particular, the call violates the implicit precondition of (*bytes.Buffer).Write that its receiver is not nil, so assigning the nil pointer to the interface was a mistake. The solution is to change the type of buf in main to io.Writer, thereby avoiding the assignment of the dysfunctional value to the interface in the first place:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var buf io.Writer 
if debug {
buf = new(bytes.Buffer) // enable collection of 
output
}
f(buf) // OK 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we’ve covered the mechanics of interface values, let’s take a look at some more important interfaces from Go’s standard library. In the next three sections, we’ll see how interfaces are used for sorting, web serving, and error handling.&lt;/p&gt;

&lt;h2 id=&#34;sorting-with-sort-interface:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Sorting with sort.Interface&lt;/h2&gt;

&lt;p&gt;Like string formatting, sorting is a frequently used operation in many programs. Although a minimal Quicksort can be written in about 15 lines, a robust implementation is much longer, and it is not the kind of code we should wish to write anew or copy each time we need it.
Fortunately, the sort package provides in-place sorting of any sequence according to any ordering function. Its design is rather unusual. In many languages, the sorting algorithm is associated with the sequence data type, while the ordering function is associated with the type of the elements. By contrast, Go’s sort.Sort function assumes nothing about the representation of either the sequence or its elements. Instead, it uses an interface, sort.Interface, to specify the contract between the generic sort algorithm and each sequence type that may be sorted. An implementation of this interface determines both the concrete representation of the sequence, which is often a slice, and the desired ordering of its elements.&lt;/p&gt;

&lt;p&gt;Anin-place sort algorithm needs three things—the length of the sequence, a means of comparing two elements, and a way to swap two elements—so they are the three methods of sort.Interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package sort 
type Interface interface {
Len() int 
Less(i, j int) bool // i, j are indices of 
sequence elements 
Swap(i, j int) } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To sort any sequence, we need to define a type that implements these three methods, then apply sort.Sort to an instance of that type. As perhaps the simplest example, consider sorting a slice of strings. The new type StringSlice and its Len, Less, and Swap methods are shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type StringSlice []string 
func (p StringSlice) Len() int { return 
len(p) }
func (p StringSlice) Less(i, j int) bool { return p[i] 
&amp;lt; p[j] }
func (p StringSlice) Swap(i, j int) { p[i], p[j] 
= p[j], p[i] } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can sort a slice of strings, names, by converting the slice to a StringSlice like this:
sort.Sort(StringSlice(names))&lt;/p&gt;

&lt;p&gt;The conversion yields a slice value with the same length, capacity, and underlying array as names but with a type that has the three methods required for sorting.
Sorting a slice of strings is so common that the sort package provides the StringSlice type, as well as a function called Strings so that the call above can be simplified to sort.Strings(names).&lt;/p&gt;

&lt;p&gt;The technique here is easily adapted to other sort orders, for instance, to ignore capitalization or special characters. (The Go program that sorts index terms and page numbers for this book does this, with extra logic for Roman numerals.) For more complicated sorting, we use the same idea, but with more complicated data structures or more complicated implementations of the sort.Interface methods.&lt;/p&gt;

&lt;p&gt;Our running example for sorting will be a music playlist, displayed as a table. Each track is a single row, and each column is an attribute of that track, like artist, title, and running time. Imagine that a graphical user interface presents the table, and that clicking the head of a column causes the playlist to be sorted by that attribute; clicking the same column head again reverses the order. Let’s look at what might happen in response to each click.&lt;/p&gt;

&lt;p&gt;The variable tracks below contains a playlist. (One of the authors apologizes for the other author’s musical tastes.) Each element is indirect, a pointer to a Track. Although the code below would work if we stored the Tracks directly, the sort function will swap many pairs of elements, so it will run faster if each element is a pointer, which is a single machine word, instead of an entire Track, which might be eight words or more.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch7/sorting 
type Track struct {
Title string 
Artist string 
Album string 
Year int 
Length time.Duration 

} 
var     tracks = []*Track{ 
{&amp;quot;Go&amp;quot;, &amp;quot;Delilah&amp;quot;, &amp;quot;From the Roots Up&amp;quot;, 2012, 

length(&amp;quot;3m38s&amp;quot;)},
{&amp;quot;Go&amp;quot;, &amp;quot;Moby&amp;quot;, &amp;quot;Moby&amp;quot;, 1992, length(&amp;quot;3m37s&amp;quot;)}, 
{&amp;quot;Go Ahead&amp;quot;, &amp;quot;Alicia Keys&amp;quot;, &amp;quot;As I Am&amp;quot;, 2007, 

length(&amp;quot;4m36s&amp;quot;)},
{&amp;quot;Ready 2 Go&amp;quot;, &amp;quot;Martin Solveig&amp;quot;, &amp;quot;Smash&amp;quot;, 2011, length(&amp;quot;4m24s&amp;quot;)},} 
func length(s string) time.Duration {
d, err := time.ParseDuration(s) 
if err != nil {

panic(s) 
}
return d 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The printTracks function prints the playlist as a table. A graphical display would be nicer, but this little routine uses the text/tabwriter package to produce a table whose columns are neatly aligned and padded as shown below. Observe that *tabwriter.Writer satisfies io.Writer. It collects each piece of data written to it; its Flush method formats the entire table and writes it to os.Stdout.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func printTracks(tracks []*Track) { const format = &amp;quot;%v\t%v\t%v\t%v\t%v\t\n&amp;quot; tw := new(tabwriter.Writer).Init(os.Stdout, 0, 8, 
2, &#39; &#39;, 0)fmt.Fprintf(tw, format, &amp;quot;Title&amp;quot;, &amp;quot;Artist&amp;quot;, &amp;quot;Album&amp;quot;, &amp;quot;Year&amp;quot;, &amp;quot;Length&amp;quot;)fmt.Fprintf(tw, format, &amp;quot;-----&amp;quot;, &amp;quot;------&amp;quot;, &amp;quot;----­&amp;quot;, &amp;quot;----&amp;quot;, &amp;quot;------&amp;quot;) for _, t := range tracks {fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length) 
}
tw.Flush() // calculate column widths and print table } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To sort the playlist by the Artist field, we define a new slice type with the necessary Len, Less, and Swap methods, analogous to what we did for StringSlice.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type byArtist []*Track 
func (x byArtist) Len() int { return len(x) 
}
func (x byArtist) Less(i, j int) bool { return 
x[i].Artist &amp;lt; x[j].Artist }
func (x byArtist) Swap(i, j int) { x[i], x[j] = 
x[j], x[i] } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To call the generic sort routine, we must first convert tracks to the new type, byArtist, that defines the order:
sort.Sort(byArtist(tracks))&lt;/p&gt;

&lt;p&gt;After sorting the slice by artist, the output from printTracks is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Title  Artist  Album  Year  
Length----­ -----­ ----­ ---­ - 
----­ 

Go Ahead  Alicia  Keys  As  I  Am  2007  

4m36s Go Delilah From the Roots Up 2012 3m38s Ready 2 Go Martin Solveig Smash 2011 4m24s Go Moby Moby 1992 3m37s 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user requests “sort by artist” a second time, we’ll sort the tracks in reverse. We needn’t define a new type byReverseArtist with an inverted Less method, however, since the sort package provides a Reverse function that transforms any sort order to its inverse.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sort.Sort(sort.Reverse(byArtist(tracks))) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After reverse-sorting the slice by artist, the output from printTracks is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;4m36s 
Title  Artist  Album  Year  
Length - 

Go 3m37s  Moby  Moby  1992  
Ready 4m24s  2  Go  Martin  Solveig  Smash  2011  
Go 3m38s  Delilah  From  the  Roots  Up  2012  
Go  Ahead  Alicia  Keys  As  I  Am  2007  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The sort.Reverse function deserves a closer look since it uses composition (§6.3), which is an important idea. The sort package defines an unexported type reverse, which is a struct that embeds a sort.Interface. The Less method for reverse calls the Less method of the embedded sort.Interface value, but with the indices flipped, reversing the order of the sort results.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package sort 
type reverse struct{ Interface } // that is, 
sort.Interface 
func (r reverse) Less(i, j int) bool { return 
r.Interface.Less(j, i) } 
func Reverse(data Interface) Interface { return 
reverse{data} } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Len and Swap, the other two methods of reverse, are implicitly provided by the original sort.Interface value because it is an embedded field. The exported function Reverse returns an instance of the reverse type that contains the original sort.Interface value.&lt;/p&gt;

&lt;p&gt;To sort by a different column, we must define a new type, such as byYear:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type byYear []*Track 
func (x byYear) Len() int { return len(x) } 
func (x byYear) Less(i, j int) bool { return x[i].Year 
&amp;lt; x[j].Year }
func (x byYear) Swap(i, j int) { x[i], x[j] = 
x[j], x[i] } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After sorting tracks by year using sort.Sort(byYear(tracks)), printTracks shows a chronological listing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Title  Artist  Album  Year  
Length----­ -----­ ----­ ---­ - 
----­ 
Go 3m37s  Moby  Moby  1992  
Go Ahead 4m36s  Alicia  Keys  As  I  Am  2007  
Ready  2  Go  Martin  Solveig  Smash  2011  

4m24s Go Delilah From the Roots Up 2012 3m38s 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For every slice element type and every ordering function we need, we declare a new implementation of sort.Interface. As you can see, the Len and Swapmethods have identical definitions for all slice types. In the next example, the concrete type customSort combines a slice with a function, letting us define a new sort order by writing only the comparison function. Incidentally, the concrete types that implement sort.Interface are not always slices; customSort is a struct type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type customSort struct {
t []*Track 
less func(x, y *Track) bool 

} 
func (x customSort) Len() int { return 
len(x.t) }
func (x customSort) Less(i, j int) bool { return 
x.less(x.t[i], x.t[j]) } 
func (x customSort) Swap(i, j int) { x.t[i], 
x.t[j] = x.t[j], x.t[i] } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s define a multi-tier ordering function whose primary sort key is the Title, whose secondary key is the Year, and whose tertiary key is the running time, Length. Here’s the call to Sort using an anonymous ordering function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sort.Sort(customSort{tracks, func(x, y *Track) bool {if x.Title != y.Title {
return x.Title &amp;lt; y.Title 
}
if x.Year != y.Year {

return x.Year &amp;lt; y.Year 
}
if x.Length != y.Length {

return x.Length &amp;lt; y.Length 
}return false }}) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here’s the result. Notice that the tie between the two tracks titled “Go” is broken
in favor of the older one.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Title  Artist  Album  Year  
Length----­ -----­ ----­ ---­ - 
----­ 
Go 3m37s  Moby  Moby  1992  
Go 3m38s  Delilah  From the Roots Up  2012  
Go Ahead 4m36s  Alicia Keys  As I Am  2007  
Ready 2 Go 4m24s  Martin Solveig  Smash  2011  


Although sorting a sequence of length n requires O(n log n) comparison operations, testing whether a sequence is already sorted requires at most n-1 comparisons. The IsSorted function from the sort package checks this for us. Like sort.Sort, it abstracts both the sequence and its ordering function using sort.Interface, but it never calls the Swap method: This code demonstrates the IntsAreSorted and Ints functions and the IntSlice type: 

```go
values := []int{3, 1, 4, 1}
fmt.Println(sort.IntsAreSorted(values)) // &amp;quot;false&amp;quot; 
sort.Ints(values)
fmt.Println(values) // &amp;quot;[1 1 3 4]&amp;quot; 
fmt.Println(sort.IntsAreSorted(values)) // &amp;quot;true&amp;quot; 
sort.Sort(sort.Reverse(sort.IntSlice(values)))
fmt.Println(values) // &amp;quot;[4 3 1 1]&amp;quot; 
fmt.Println(sort.IntsAreSorted(values)) // &amp;quot;false&amp;quot; 

For convenience, the sort package provides versions of its functions and types specialized for []int, []string, and []float64 using their natural orderings. 

For other types, such as []int64 or []uint, we’re on our own, though the path is short. 

Exercise 7.8: Many GUIs provide a table widget with a stateful multi-tier sort: the primary sort key is the most recently clicked column head, the secondary sort key is the second-most recently clicked column head, and so on. Define an implementation of sort.Interface for use by such a table. Compare that approach with repeated sorting using sort.Stable. 

Exercise 7.9: Use the html/template package (§4.6) to replace printTrackswith a function that displays the tracks as an HTML table. Use the solution to the previous exercise to arrange that each click on a column head makes an HTTP request to sort the table. 

Exercise 7.10: The sort.Interface type can be adapted to other uses. Write a function IsPalindrome(s sort.Interface) bool that reports whether the sequence s is a palindrome, in other words, reversing the sequence would not change it. Assume that the elements at indices i and j are equal if !s.Less(i, 
j) &amp;amp;&amp;amp; !s.Less(j, i) . 

## The http.Handler Interface 

In Chapter 1, we saw a glimpse of how to use the net/http package to implement web clients (§1.5) and servers (§1.7). In this section, we’ll look more closely at the server API, whose foundation is the http.Handler interface: 

```go
net/http 
package http 
type Handler interface {
ServeHTTP(w ResponseWriter, r *Request) 
} 

func ListenAndServe(address string, h Handler) error 

The ListenAndServe function requires a server address, such as &amp;quot;localhost:8000&amp;quot;, and an instance of the Handler interface to which all requests should be dispatched. It runs forever, or until the server fails (or fails to start) with an error, always non-nil, which it returns. 
Imagine an e-commerce site with a database mapping the items for sale to their prices in dollars. The program below shows the simplest imaginable implementation. It models the inventory as a map type, database, to which we’ve attached a ServeHTTP method so that it satisfies the http.Handler interface. The handler ranges over the map and prints the items. 

```go
// gopl.io/ch7/http1 
func main() {
db := database{&amp;quot;shoes&amp;quot;: 50, &amp;quot;socks&amp;quot;: 5}
log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;, 
db))
} 
type dollars float32 
func (d dollars) String() string { return 
fmt.Sprintf(&amp;quot;$%.2f&amp;quot;, d) } 

type database map[string]dollars 
func (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) {for item, price := range db {fmt.Fprintf(w, &amp;quot;%s: %s\n&amp;quot;, item, price) }} 

If we start the server, 
$ go build gopl.io/ch7/http1 
$ ./http1 &amp;amp; 

then connect to it with the fetch program from Section 1.5 (or a web browser if you prefer), we get the following output: 

```go
$ go build gopl.io/ch1/fetch 
$ ./fetch http://localhost:8000 
shoes: $50.00 
socks: $5.00 

So far, the server can only list its entire inventory and will do this for every request, regardless of URL. A more realistic server defines multiple different URLs, each triggering a different behavior. Let’s call the existing one /list and add another one called /price that reports the price of a single item, specified as a request parameter like /price?item=socks. 

```go
// gopl.io/ch7/http2 
func (db database) ServeHTTP(w http.ResponseWriter, 
req     *http.Request) {
switch req.URL.Path {
case &amp;quot;/list&amp;quot;:

for     item, price := range db { 
fmt.Fprintf(w, &amp;quot;%s: %s\n&amp;quot;, item, price) }
case &amp;quot;/price&amp;quot;:item := req.URL.Query().Get(&amp;quot;item&amp;quot;) price, ok := db[item] if !ok {
w.WriteHeader(http.StatusNotFound) // 404 fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item) return 
}
fmt.Fprintf(w, &amp;quot;%s\n&amp;quot;, price) 

default: w.WriteHeader(http.StatusNotFound) // 404 fmt.Fprintf(w, &amp;quot;no such page: %s\n&amp;quot;, req.URL) 
}
} 


Now the handler decides what logic to execute based on the path component of the URL, req.URL.Path. If the handler doesn’t recognize the path, it reports an HTTP error to the client by calling w.WriteHeader(http.StatusNotFound); this must be done before writing any text to w. (Incidentally, http.ResponseWriter is another interface. It augments io.Writer with methods for sending HTTP response headers.) Equivalently, we could use the http.Error utility function: 

```go
msg := fmt.Sprintf(&amp;quot;no such page: %s\n&amp;quot;, req.URL) 
http.Error(w, msg, http.StatusNotFound) // 404 


The case for /price calls the URL’s Query method to parse the HTTP request parameters as a map, or more precisely, a multimap of type url.Values (§6.2.1) from the net/url package. It then finds the first item parameter and looks up its price. If the item wasn’t found, it reports an error. 

Here’s an example session with the new server: 

```go
$ go build gopl.io/ch7/http2 
$ go build gopl.io/ch1/fetch 

$ ./http2 &amp;amp; 
$ ./fetch http://localhost:8000/list 
shoes: $50.00 
socks: $5.00 
$ ./fetch http://localhost:8000/price?item=socks 
$5.00 
$ ./fetch http://localhost:8000/price?item=shoes 
$50.00 
$ ./fetch http://localhost:8000/price?item=hat 
no such item: &amp;quot;hat&amp;quot; 
$ ./fetch http://localhost:8000/help 
no such page: /help 
Obviously we could keep adding cases to ServeHTTP, but in a realistic application, it’s convenient to define the logic for each case in a separate function or method. Furthermore, related URLs may need similar logic; several image files may have URLs of the form /images/*.png, for instance. For these reasons, net/http provides ServeMux,a request multiplexer, to simplify the association between URLs and handlers. A ServeMux aggregates a collection of http.Handlers into a single http.Handler. Again, we see that different types satisfying the same interface are substitutable: the web server can dispatch requests to any http.Handler, regardless of which concrete type is behind it. 

For a more complex application, several ServeMuxes may be composed to handle more intricate dispatching requirements. Go doesn’t have a canonical web framework analogous to Ruby’s Rails or Python’s Django. This is not to say that such frameworks don’t exist, but the building blocks in Go’s standard library are flexible enough that frameworks are often unnecessary. Furthermore, although frameworks are convenient in the early phases of a project, their additional complexity can make longer-term maintenance harder. 

In the program below, we create a ServeMux and use it to associate the URLs with the corresponding handlers for the /list and /price operations, which have been split into separate methods. We then use the ServeMux as the main handler in the call to ListenAndServe. 

```go
// gopl.io/ch7/http3 
func main() { 
db := database{&amp;quot;shoes&amp;quot;: 50, &amp;quot;socks&amp;quot;: 5} 
mux := http.NewServeMux()
mux.Handle(&amp;quot;/list&amp;quot;, http.HandlerFunc(db.list)) 
mux.Handle(&amp;quot;/price&amp;quot;, http.HandlerFunc(db.price))
log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;,

mux))
} 

type database map[string]dollars 
func (db database) list(w http.ResponseWriter, req 
*http.Request) {
for item, price := range db {
fmt.Fprintf(w, &amp;quot;%s: %s\n&amp;quot;, item, price) 
}
} 

func (db database) price(w http.ResponseWriter, req 
*http.Request) {
item := req.URL.Query().Get(&amp;quot;item&amp;quot;) 
price, ok := db[item] 
if !ok {

w.WriteHeader(http.StatusNotFound) // 404 fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item) return 
}
fmt.Fprintf(w, &amp;quot;%s\n&amp;quot;, price) 
} 

Let’s focus on the two calls to mux.Handle that register the handlers. In the first one, db.list is a method value (§6.4), that is, a value of type 

```go
func(w http.ResponseWriter, req *http.Request) 
that, when called, invokes the database.list method with the receiver value db. So db.list is a function that implements handler-like behavior, but since it has no methods, it doesn’t satisfy the http.Handler interface and can’t be passed directly to mux.Handle. 

The expression http.HandlerFunc(db.list) is a conversion, not a function call, since http.HandlerFunc is a type. It has the following definition: 

```go
net/http 
package http 
type HandlerFunc func(w ResponseWriter, r *Request) 
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r 
*Request) {
f(w, r) 
} 

HandlerFunc demonstrates some unusual features of Go’s interface mechanism. It is a function type that has methods and satisfies an interface, http.Handler. The behavior of its ServeHTTP method is to call the underlying function. HandlerFunc is thus an adapter that lets a function value satisfy an interface, where the function and the interface’s sole method have the same signature. In effect, this trick lets a single type such as database satisfy the http.Handler interface several different ways: once through its list method, once through its price method, and so on. 

Because registering a handler this way is so common, ServeMux has a convenience method called HandleFunc that does it for us, so we can simplify the handler registration code to this: 

```go
// gopl.io/ch7/http3a 
mux.HandleFunc(&amp;quot;/list&amp;quot;, db.list) 
mux.HandleFunc(&amp;quot;/price&amp;quot;, db.price) 

It’s easy to see from the code above how one would construct a program in which there are two different web servers, listening on different ports, defining different URLs, and dispatching to different handlers. We would just construct another ServeMux and make another call to ListenAndServe, perhaps concurrently. But in most programs, one web server is plenty. Also, it’s typical to define HTTP handlers across many files of an application, and it would be a nuisance if they all had to be explicitly registered with the application’s ServeMux instance. 
So, for convenience, net/http provides a global ServeMux instance called DefaultServeMux and package-level functions called http.Handle and http.HandleFunc. To use DefaultServeMux as the server’s main handler, we needn’t pass it to ListenAndServe; nil will do. 

The server’s main function can then be simplified to 

```go
// gopl.io/ch7/http4 
func main() {
db := database{&amp;quot;shoes&amp;quot;: 50, &amp;quot;socks&amp;quot;: 5} 
http.HandleFunc(&amp;quot;/list&amp;quot;, db.list) 
http.HandleFunc(&amp;quot;/price&amp;quot;, db.price)
log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;,
nil))
} 

Finally, an important reminder: as we mentioned in Section 1.7, the web server invokes each handler in a new goroutine, so handlers must take precautions such as locking when accessing variables that other goroutines, including other requests to the same handler, may be accessing. We’ll talk about concurrency in the next two chapters. 

Exercise 7.11: Add additional handlers so that clients can create, read, update, and delete database entries. For example, a request of the form /update? item=socks&amp;amp;price=6 will update the price of an item in the inventory and report an error if the item does not exist or if the price is invalid. (Warning: this change introduces concurrent variable updates.) 

Exercise 7.12: Change the handler for /list to print its output as an HTML table, not text. You may find the html/template package (§4.6) useful. 

## The error Interface 

Since the beginning of this book, we’ve been using and creating values of the mysterious predeclared error type without explaining what it really is. In fact, it’s just an interface type with a single method that returns an error message: 
type error interface {
Error() string 
} 


The simplest way to create an error is by calling errors.New, which returns a new error for a given error message. The entire errors package is only four lines long: 

```go
package errors 
func New(text string) error { return 
&amp;amp;errorString{text} } 
type errorString struct { text string } 
func (e *errorString) Error() string { return e.text } 

The underlying type of errorString is a struct, not a string, to protect its representation from inadvertent (or premeditated) updates. And the reason that the pointer type *errorString, not errorString alone, satisfies the error interface is so that every call to New allocates a distinct error instance that is equal to no other. We would not want a distinguished error such as io.EOF to compare equal to one that merely happened to have the same message. 

```go
fmt.Println(errors.New(&amp;quot;EOF&amp;quot;) == errors.New(&amp;quot;EOF&amp;quot;)) // 
&amp;quot;false&amp;quot; 
Calls to errors.New are relatively infrequent because there’s a convenient wrapper function, fmt.Errorf, that does string formatting too. We used it several times in Chapter 5. 

```go
package fmt 
import &amp;quot;errors&amp;quot; 
func Errorf(format string, args ...interface{}) error { return errors.New(Sprintf(format, args...)) } 

Although *errorString may be the simplest type of error, it is far from the only one. For example, the syscall package provides Go’s low-level system call API. On many platforms, it defines a numeric type Errno that satisfies error, and on Unix platforms, Errno’s Error method does a lookup in a table of strings, as shown below: 

```go
package syscall 
type Errno uintptr // operating system error code 
var errors = [...]string{ 
1: &amp;quot;operation not permitted&amp;quot;, // EPERM 
2: &amp;quot;no such file or directory&amp;quot;, // ENOENT 
3: &amp;quot;no such process&amp;quot;, // ESRCH 
// ... 
} 

func (e Errno) Error() string { 
if 0 &amp;lt;= int(e) &amp;amp;&amp;amp; int(e) &amp;lt; len(errors) { 
return errors[e] }
return fmt.Sprintf(&amp;quot;errno %d&amp;quot;, e) } 

The following statement creates an interface value holding the Errno value 2, signifying the POSIX ENOENT condition: 

```go
var err error = syscall.Errno(2)
fmt.Println(err.Error()) // &amp;quot;no such file or 
directory&amp;quot;
fmt.Println(err) // &amp;quot;no such file or 
directory&amp;quot; 


The value of err is shown graphically in Figure 7.6. 

Errno is an efficient representation of system call errors drawn from a finite set, and it satisfies the standard error interface. We’ll see other types that satisfy this interface in Section 7.11. 

## Example: Expression Evaluator 

In this section, we’ll build an evaluator for simple arithmetic expressions. We’ll use an interface, Expr, to represent any expression in this language. For now, this interface needs no methods, but we’ll add some later. 

```go
// An Expr is an arithmetic expression. 
type Expr interface{} 


Our expression language consists of floating-point literals; the binary operators +, -, *, and /; the unary operators -x and +x; function calls pow(x,y), sin(x), and sqrt(x); variables such as x and pi; and of course parentheses and standard operator precedence. All values are of type float64. Here are some example expressions: 
sqrt(A / pi) 
pow(x, 3) + pow(y, 3) 
(F -32) * 5 / 9 


The five concrete types below represent particular kinds of expression. A Var represents a reference to a variable. (We’ll soon see why it is exported.) A literal represents a floating-point constant. The unary and binary types represent operator expressions with one or two operands, which can be any kind of Expr.A call represents a function call; we’ll restrict its fn field to pow, sin, or sqrt. 

```go
// gopl.io/ch7/eval 
// A Var identifies a variable, e.g., x. 
type Var string 

// A literal is a numeric constant, e.g., 3.141. 
type literal float64 

// A unary represents a unary operator expression, 
e.g., -x. 
type unary struct { 

op rune // one of &#39;+&#39;, &#39;-&#39; 
x Expr 
} 

// A binary represents a binary operator expression, 
e.g., x+y. 
type binary struct {

op rune // one of &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39; 
x, y Expr 
} 


// A call represents a function call expression, e.g., 
sin(x).
type call struct {

fn string // one of &amp;quot;pow&amp;quot;, &amp;quot;sin&amp;quot;, &amp;quot;sqrt&amp;quot; 
args []Expr 
} 


To evaluate an expression containing variables, we’ll need an environment that maps variable names to values: 
type Env map[Var]float64 

We’ll also need each kind of expression to define an Eval method that returns the expression’s value in a given environment. Since every expression must provide this method, we add it to the Expr interface. The package exports only the types Expr, Env, and Var; clients can use the evaluator without access to the other expression types. 

```go
type Expr interface {
// Eval returns the value of this Expr in the 
environment env. 
Eval(env Env) float64 
} 


The concrete Eval methods are shown below. The method for Var performs an environment lookup, which returns zero if the variable is not defined, and the method for literal simply returns the literal value. 

```go
func (v Var) Eval(env Env) float64 {
return env[v] 
} 

func (l literal) Eval(_ Env) float64 {
return float64(l) 
} 


The Eval methods for unary and binary recursively evaluate their operands, then apply the operation op to them. We don’t consider divisions by zero or infinity to be errors, since they produce a result, albeit non-finite. 
Finally, the method for call evaluates the arguments to the pow, sin, or sqrt function, then calls the corresponding function in the math package. 

```go
func (u unary) Eval(env Env) float64 {
switch u.op { 
case &#39;+&#39;: 

return +u.x.Eval(env) 
case &#39;-&#39;: 

return -u.x.Eval(env) }panic(fmt.Sprintf(&amp;quot;unsupported unary operator: 
%q&amp;quot;, u.op)) 
} 

func (b binary) Eval(env Env) float64 {
switch b.op { 
case &#39;+&#39;: 

return b.x.Eval(env) + b.y.Eval(env) case &#39;-&#39;: return b.x.Eval(env) -b.y.Eval(env) case &#39;*&#39;: return b.x.Eval(env) * b.y.Eval(env) case &#39;/&#39;:
return b.x.Eval(env) / b.y.Eval(env) }panic(fmt.Sprintf(&amp;quot;unsupported binary operator: 
%q&amp;quot;, b.op)) 
} 
func (c call) Eval(env Env) float64 {
switch c.fn {
case &amp;quot;pow&amp;quot;:
return math.Pow(c.args[0].Eval(env),
c.args[1].Eval(env))
case &amp;quot;sin&amp;quot;: 
return math.Sin(c.args[0].Eval(env)) 
case &amp;quot;sqrt&amp;quot;:
return math.Sqrt(c.args[0].Eval(env)) 
}
panic(fmt.Sprintf(&amp;quot;unsupported function call: %s&amp;quot;, c.fn))
} 
Several of these methods can fail. For example, a call expression could have an unknown function or the wrong number of arguments. It’s also possible to construct a unary or binary expression with an invalid operator such as ! or &amp;lt; (although the Parse function mentioned below will never do this). These errors cause Eval to panic. Other errors, like evaluating a Var not present in the environment, merely cause Eval to return the wrong result. All of these errors could be detected by inspecting the Expr before evaluating it. That will be the job of the Check method, which we will show soon, but first let’s test Eval. 

The TestEval function below is a test of the evaluator. It uses the testing package, which we’ll explain in Chapter 11, but for now it’s enough to know that calling t.Errorf reports an error. The function loops over a table of inputs that defines three expressions and different environments for each one. The first expression computes the radius of a circle given its area A, the second computes the sum of the cubes of two variables x and y, and the third converts a Fahrenheit temperature F to Celsius. 

```go
func TestEval(t *testing.T) { 
tests := []struct {
expr string 
env Env 
want string 
}{ {&amp;quot;sqrt(A / pi)&amp;quot;, Env{&amp;quot;A&amp;quot;: 87616, &amp;quot;pi&amp;quot;: math.Pi}, &amp;quot;167&amp;quot;},{&amp;quot;pow(x, 3) + pow(y, 3)&amp;quot;, Env{&amp;quot;x&amp;quot;: 12, &amp;quot;y&amp;quot;: 1}, &amp;quot;1729&amp;quot;},{&amp;quot;pow(x, 3) + pow(y, 3)&amp;quot;, Env{&amp;quot;x&amp;quot;: 9, &amp;quot;y&amp;quot;: 
10}, &amp;quot;1729&amp;quot;},{&amp;quot;5 / 9 * (F -32)&amp;quot;, Env{&amp;quot;F&amp;quot;: -40}, &amp;quot;-40&amp;quot;}, {&amp;quot;5 / 9 * (F -32)&amp;quot;, Env{&amp;quot;F&amp;quot;: 32}, &amp;quot;0&amp;quot;}, {&amp;quot;5 / 9 * (F -32)&amp;quot;, Env{&amp;quot;F&amp;quot;: 212}, &amp;quot;100&amp;quot;}, 
}
var prevExpr string 
for _, test := range tests {

// Print expr only when it changes. 
if test.expr != prevExpr {fmt.Printf(&amp;quot;\n%s\n&amp;quot;, test.expr) prevExpr = test.expr 
}
expr, err := Parse(test.expr) 
if err != nil {

t.Error(err) // parse error 
continue 
}
got := fmt.Sprintf(&amp;quot;%.6g&amp;quot;,

expr.Eval(test.env))
fmt.Printf(&amp;quot;\t%v =&amp;gt; %s\n&amp;quot;, test.env, got) 
if got != test.want {

t.Errorf(&amp;quot;%s.Eval() in %s = %q, want %q\n&amp;quot;, test.expr, test.env, got, test.want) }}} 

For each entry in the table, the test parses the expression, evaluates it in the environment, and prints the result. We don’t have space to show the Parse function here, but you’ll find it if you download the package using go get . 

The go test command (§11.1) runs a package’s tests: 
$ go test -v // gopl.io/ch7/eval 

The -v flag lets us see the printed output of the test, which is normally suppressed for a successful test like this one. Here is the output of the test’s fmt.Printf statements: 

```go
sqrt(A / pi)
map[A:87616 pi:3.141592653589793] =&amp;gt; 167 

pow(x, 3) + pow(y, 3) 
map[x:12 y:1] =&amp;gt; 1729 
map[x:9 y:10] =&amp;gt; 1729 

5 /     9 * (F -32)
map[F:-40] =&amp;gt; -40 
map[F:32] =&amp;gt; 0 
map[F:212] =&amp;gt; 100 

Fortunately the inputs so far have all been well formed, but our luck is unlikely to last. Even in interpreted languages, it is common to check the syntax for static errors, that is, mistakes that can be detected without running the program. By separating the static checks from the dynamic ones, we can detect errors sooner and perform many checks only once instead of each time an expression is evaluated. 
Let’s add another method to the Expr interface. The Check method checks for static errors in an expression syntax tree. We’ll explain its vars parameter in a moment. 

```go
type Expr interface {
Eval(env Env) float64 
// Check reports errors in this Expr and adds its 
Vars to the set. 
Check(vars map[Var]bool) error 
} 

The concrete Check methods are shown below. Evaluation of literal and Var cannot fail, so the Check methods for these types return nil. The methods for unary and binary first check that the operator is valid, then recursively check the operands. Similarly, the method for call first checks that the function is known and has the right number of arguments, then recursively checks each argument. 

```go
func (v Var) Check(vars map[Var]bool) error {
vars[v] = true 
return nil 

} 
func (literal) Check(vars map[Var]bool) error {
return nil 
} 

func (u unary) Check(vars map[Var]bool) error {if !strings.ContainsRune(&amp;quot;+-&amp;quot;, u.op) { return fmt.Errorf(&amp;quot;unexpected unary op %q&amp;quot;, 
u.op)
}
return u.x.Check(vars) 

} 
func (b binary) Check(vars map[Var]bool) error {if !strings.ContainsRune(&amp;quot;+-*/&amp;quot;, b.op) { return fmt.Errorf(&amp;quot;unexpected binary op %q&amp;quot;, 
b.op)
}
if err := b.x.Check(vars); err != nil {

return err 
}
return b.y.Check(vars) 

} 
func (c call) Check(vars map[Var]bool) error {
arity, ok := numParams[c.fn] 
if !ok {

return fmt.Errorf(&amp;quot;unknown function %q&amp;quot;, c.fn) }if len(c.args) != arity { 
return fmt.Errorf(&amp;quot;call to %s has %d args, want %d&amp;quot;, 
c.fn, len(c.args), arity) }for _, arg := range c.args {
if err := arg.Check(vars); err != nil {return err 
}}return nil 
} 
var numParams = map[string]int{&amp;quot;pow&amp;quot;: 2, &amp;quot;sin&amp;quot;: 1, &amp;quot;sqrt&amp;quot;: 1} 

We’ve listed a selection of flawed inputs and the errors they elicit, in two groups. The Parse function (not shown) reports syntax errors and the Check function reports 
semantic errors.  

```go 
x % 2 math.Pi !true &amp;quot;hello&amp;quot;  unexpected unexpected unexpected unexpected  &#39;%&#39; &#39;.&#39; &#39;!&#39; &#39;&amp;quot;&#39;  
log(10) sqrt(1, 2)  unknown call to  function sqrt has  &amp;quot;log&amp;quot; 2 args,  want  1  

Check’s argument, a set of Vars, accumulates the set of variable names found within the expression. Each of these variables must be present in the environment for evaluation to succeed. This set is logically the result of the call to Check, but because the method is recursive, it is more convenient for Check to populate a set passed as a parameter. The client must provide an empty set in the initial call. 

In Section 3.2, we plotted a function f(x,y) that was fixed at compile time. Now that we can parse, check, and evaluate expressions in strings, we can build a web application that receives an expression at run time from the client and plots the surface of that function. We can use the vars set to check that the expression is a function of only two variables, x and y—three, actually, since we’ll provide r, the radius, as a convenience. And we’ll use the Check method to reject ill-formed expressions before evaluation begins so that we don’t repeat those checks during the 40,000 evaluations (100×100 cells, each with four corners) of the function that follow. 

The parseAndCheck function combines these parsing and checking steps: 

```go
// gopl.io/ch7/surface 
import &amp;quot;// gopl.io/ch7/eval&amp;quot; 
func parseAndCheck(s string) (eval.Expr, error) { 
if s == &amp;quot;&amp;quot; {

return nil, fmt.Errorf(&amp;quot;empty expression&amp;quot;) }expr, err := eval.Parse(s) if err != nil {
return nil, err }vars := make(map[eval.Var]bool) if err := expr.Check(vars); err != nil {
return nil, err 
}
for v := range vars {

if v != &amp;quot;x&amp;quot; &amp;amp;&amp;amp; v != &amp;quot;y&amp;quot; &amp;amp;&amp;amp; v != &amp;quot;r&amp;quot; {
return nil, fmt.Errorf(&amp;quot;undefined 
variable: %s&amp;quot;, v) 

}
}
return expr, nil 

} 

To make this a web application, all we need is the plot function below, which has the familiar signature of an http.HandlerFunc: 

```go
func plot(w http.ResponseWriter, r *http.Request) { r.ParseForm()expr, err := parseAndCheck(r.Form.Get(&amp;quot;expr&amp;quot;)) if err != nil {
http.Error(w, &amp;quot;bad expr: &amp;quot;+err.Error(), 
http.StatusBadRequest)
return }w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;image/svg+xml&amp;quot;) surface(w, func(x, y float64) float64 {
r := math.Hypot(x, y) // distance from (0,0) return expr.Eval(eval.Env{&amp;quot;x&amp;quot;: x, &amp;quot;y&amp;quot;: y, &amp;quot;r&amp;quot;: r}) }) } 


Figure 7.7. The surfaces of three functions: (a) sin(-x)*pow(1.5,-r); (b) pow(2,sin(y))*pow(2,sin(x))/12; (c) sin(x*y/10)/10. 

The plot function parses and checks the expression specified in the HTTP request and uses it to create an anonymous function of two variables. The anonymous function has the same signature as the fixed function f from the original surface-plotting program, but it evaluates the user-supplied expression. The environment defines x, y, and the radius r. 
Finally, plot calls surface, which is just the main function from // gopl.io/ch3/surface, modified to take the function to plot and the output io.Writer as parameters, instead of using the fixed function f and os.Stdout. Figure 7.7 shows three surfaces produced by the program. 

Exercise 7.13: Add a String method to Expr to pretty-print the syntax tree. Check that the results, when parsed again, yield an equivalent tree. 

Exercise 7.14: Define a new concrete type that satisfies the Expr interface and provides a new operation such as computing the minimum value of its operands. Since the Parse function does not create instances of this new type, to use it you will need to construct a syntax tree directly (or extend the parser). 

Exercise 7.15: Write a program that reads a single expression from the standard input, prompts the user to provide values for any variables, then evaluates the expression in the resulting environment. Handle all errors gracefully. 

Exercise 7.16: Write a web-based calculator program. 
7.10 Type Assertions 

A type assertion is an operation applied to an interface value. Syntactically, it looks like x.(T), where x is an expression of an interface type and T is a type, called the “asserted” type. A type assertion checks that the dynamic type of its operand matches the asserted type. 

There are two possibilities. First, if the asserted type T is a concrete type, then the type assertion checks whether x’s dynamic type is identical to T. If this check succeeds, the result of the type assertion is x’s dynamic value, whose type is of course T. In other words, a type assertion to a concrete type extracts the concrete value from its operand. If the check fails, then the operation panics. For example: 

```go
var w io.Writer 
w = os.Stdout 
f := w.(*os.File) // success: f == os.Stdout 
c := w.(*bytes.Buffer) // panic: interface holds 
*os.File, not *bytes.Buffer 
Second, if instead the asserted type T is an interface type, then the type assertion checks whether x’s dynamic type satisfies T. If this check succeeds, the dynamic value is not extracted; the result is still an interface value with the same type and value components, but the result has the interface type T. In other words, a type assertion to an interface type changes the type of the expression, making a different (and usually larger) set of methods accessible, but it preserves the dynamic type and value components inside the interface value. 

After the first type assertion below, both w and rw hold os.Stdout so each has a dynamic type of *os.File, but w, an io.Writer, exposes only the file’s Write method, whereas rw exposes its Read method too. 

```go
var w io.Writer 
w = os.Stdout 
rw := w.(io.ReadWriter) // success: *os.File has both 
Read and Write w = new(ByteCounter) 
rw = w.(io.ReadWriter) // panic: *ByteCounter has no 
Read method 
No matter what type was asserted, if the operand is a nil interface value, the type assertion fails. A type assertion to a less restrictive interface type (one with fewer methods) is rarely needed, as it behaves just like an assignment, except in the nil case. 

```go
w = rw // io.ReadWriter is assignable to 
io.Writer 
w = rw.(io.Writer) // fails only if rw == nil 
Often we’re not sure of the dynamic type of an interface value, and we’d like to test whether it is some particular type. If the type assertion appears in an assignment in which two results are expected, such as the following declarations, the operation does not panic on failure but instead returns an additional second result, a boolean indicating success: 

```go
var w io.Writer = os.Stdout 
f, ok := w.(*os.File) // success: ok, f == 
os.Stdout 
b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil 

The second result is conventionally assigned to a variable named ok. If the operation failed, ok is false, and the first result is equal to the zero value of the asserted type, which in this example is a nil *bytes.Buffer. 

The ok result is often immediately used to decide what to do next. The extended form of the if statement makes this quite compact: 
if f, ok := w.(*os.File); ok {
// ...use f... 
} 


When the operand of a type assertion is a variable, rather than invent another name for the new local variable, you’ll sometimes see the original name reused, shadowing the original, like this: 
if w, ok := w.(*os.File); ok { 
// ...use w... 
} 
7.11 Discriminating Errors with Type Assertions 
Consider the set of errors returned by file operations in the os package. I/O can fail for any number of reasons, but three kinds of failure often must be handled differently: file already exists (for create operations), file not found (for read operations), and permission denied. The os package provides these three helper functions to classify the failure indicated by a given error value: 

```go
package os 
func IsExist(err error) bool 
func IsNotExist(err error) bool 
func IsPermission(err error) bool 

A naïve implementation of one of these predicates might check that the error message contains a certain substring, 

```go
func IsNotExist(err error) bool {
// NOTE: not robust! 
return strings.Contains(err.Error(), &amp;quot;file does 
not exist&amp;quot;) 
} 
but because the logic for handling I/O errors can vary from one platform to another, this approach is not robust and the same failure may be reported with a variety of different error messages. Checking for substrings of error messages may be useful during testing to ensure that functions fail in the expected manner, but it’s inadequate for production code. 


A more reliable approach is to represent structured error values using a dedicated type. The os package defines a type called PathError to describe failures involving an operation on a file path, like Open or Delete, and a variant called LinkError to describe failures of operations involving two file paths, like 
Symlink and Rename. Here’s os.PathError: 

```go
package os 
// PathError records an error and the operation and 
file path that caused it. 
type PathError struct {

Op string 
Path string 
Err error 

} 
func (e *PathError) Error() string { return e.Op + &amp;quot; &amp;quot; + e.Path + &amp;quot;: &amp;quot; + e.Err.Error() } 
Most clients are oblivious to PathError and deal with all errors in a uniform way by calling their Error methods. Although PathError’s Error method forms a message by simply concatenating the fields, PathError’s structure preserves the underlying components of the error. Clients that need to distinguish one kind of failure from another can use a type assertion to detect the specific type of the error; the specific type provides more detail than a simple string. 


```go
_, err := os.Open(&amp;quot;/no/such/file&amp;quot;)
fmt.Println(err) // &amp;quot;open /no/such/file: No such file 
or directory&amp;quot;
fmt.Printf(&amp;quot;%#v\n&amp;quot;, err) 
// Output: 
// &amp;amp;os.PathError{Op:&amp;quot;open&amp;quot;, Path:&amp;quot;/no/such/file&amp;quot;, 
Err:0x2} 

That’s how the three helper functions work. For example, IsNotExist, shown below, reports whether an error is equal to syscall.ENOENT (§7.8) or to the distinguished error os.ErrNotExist (see io.EOF in §5.4.2), or is a *PathError whose underlying error is one of those two. 

```go
import (
&amp;quot;errors&amp;quot; 
&amp;quot;syscall&amp;quot; 

) 
var ErrNotExist = errors.New(&amp;quot;file does not exist&amp;quot;) 
// IsNotExist returns a boolean indicating whether the error is known to // report that a file or directory does not exist. It is satisfied by // ErrNotExist as well as some syscall errors. func IsNotExist(err error) bool {
if pe, ok := err.(*PathError); ok {
err = pe.Err }return err == syscall.ENOENT || err == ErrNotExist } 

And here it is in action: 

```go
_, err := os.Open(&amp;quot;/no/such/file&amp;quot;)
fmt.Println(os.IsNotExist(err)) // &amp;quot;true&amp;quot; 

Of course, PathError’s structure is lost if the error message is combined into a larger string, for instance by a call to fmt.Errorf. Error discrimination must usually be done immediately after the failing operation, before an error is propagated to the caller. 
7.12 Querying Behaviors with Interface Type Assertions 

The logic below is similar to the part of the net/http web server responsible for writing HTTP header fields such as &amp;quot;Content-type: text/html&amp;quot; . The io.Writer w represents the HTTP response; the bytes written to it are ultimately sent to someone’s web browser. 

```go
func writeHeader(w io.Writer, contentType string) 
error {
if _, err := w.Write([]byte(&amp;quot;Content-Type: &amp;quot;)); 
err != nil {return err 
}
if _, err := w.Write([]byte(contentType)); err != 
nil { return err 
}
// ... 
} 

Because the Write method requires a byte slice, and the value we wish to write is a string, a []byte(...) conversion is required. This conversion allocates memory and makes a copy, but the copy is thrown away almost immediately after. Let’s pretend that this is a core part of the web server and that our profiling has revealed that this memory allocation is slowing it down. Can we avoid allocating memory here? 


The io.Writer interface tells us only one fact about the concrete type that w holds: that bytes may be written to it. If we look behind the curtains of the net/http package, we see that the dynamic type that w holds in this program also has a WriteString method that allows strings to be efficiently written to it, avoiding the need to allocate a temporary copy. (This may seem like a shot in the dark, but a number of important types that satisfy io.Writer also have a WriteString method, including *bytes.Buffer, *os.File and *bufio.Writer.) 


We cannot assume that an arbitrary io.Writer w also has the WriteStringmethod. But we can define a new interface that has just this method and use a type assertion to test whether the dynamic type of w satisfies this new interface. 

```go
// writeString writes s to w. 
// If w has a WriteString method, it is invoked 
instead of w.Write. 
func writeString(w io.Writer, s string) (n int, err 
error) {type stringWriter interface {
WriteString(string) (n int, err error) 
}
if sw, ok := w.(stringWriter); ok {
return sw.WriteString(s) // avoid a copy }
return w.Write([]byte(s)) // allocate temporary copy
} 
func writeHeader(w io.Writer, contentType string) 
error {if _, err := writeString(w, &amp;quot;Content-Type: &amp;quot;); err != nil {return err 
}
if _, err := writeString(w, contentType); err != 
nil { return err 
}
// ... 
} 

To avoid repeating ourselves, we’ve moved the check into the utility function writeString, but it is so useful that the standard library provides it as io.WriteString. It is the recommended way to write a string to an io.Writer. 

What’s curious in this example is that there is no standard interface that defines the WriteString method and specifies its required behavior. Furthermore, whether or not a concrete type satisfies the stringWriter interface is determined only by its methods, not by any declared relationship between it and the interface type. What this means is that the technique above relies on the assumption that if a type satisfies the interface below, then WriteString(s) must have the same effect as Write([]byte(s)). 

```go
interface {
io.Writer 
WriteString(s string) (n int, err error) } 

Although io.WriteString documents its assumption, few functions that call it are likely to document that they too make the same assumption. Defining a method of a particular type is taken as an implicit assent for a certain behavioral contract. Newcomers to Go, especially those from a background in strongly typed languages, may find this lack of explicit intention unsettling, but it is rarely a problem in practice. With the exception of the empty interface interface{}, interface types are seldom satisfied by unintended coincidence. 


The writeString function above uses a type assertion to see whether a value of a general interface type also satisfies a more specific interface type, and if so, it uses the behaviors of the specific interface. This technique can be put to good use whether or not the queried interface is standard like io.ReadWriter or user-defined like stringWriter. 

It’s also how fmt.Fprintf distinguishes values that satisfy error or fmt.Stringer from all other values. Within fmt.Fprintf, there is a step that converts a single operand to a string, something like this: 

```go
package fmt 
func formatOneValue(x interface{}) string { 
if err, ok := x.(error); ok {
return err.Error() 
}
if str, ok := x.(Stringer); ok { return str.String() 
}
// ...all other types... 
} 

If x satisfies either of the two interfaces, that determines the formatting of the value. If not, the default case handles all other types more or less uniformly using reflection; we’ll find out how in Chapter 12. 

Again, this makes the assumption that any type with a String method satisfies the behavioral contract of fmt.Stringer, which is to return a string suitable for printing. 

7.13 Type Switches 

Interfaces are used in two distinct styles. In the first style, exemplified by io.Reader, io.Writer, fmt.Stringer, sort.Interface, http.Handler, and error, an interface’s methods express the similarities of the concrete types that satisfy the interface but hide the representation details and intrinsic operations of those concrete types. The emphasis is on the methods, not on the concrete types. 


The second style exploits the ability of an interface value to hold values of a variety of concrete types and considers the interface to be the union of those types. Type assertions are used to discriminate among these types dynamically and treat each case differently. In this style, the emphasis is on the concrete types that satisfy the interface, not on the interface’s methods (if indeed it has any), and there is no hiding of information. We’ll describe interfaces used this way as discriminated unions. 


If you’re familiar with object-oriented programming, you may recognize these two styles as subtype polymorphism and ad hoc polymorphism, but you needn’t remember those terms. For the remainder of this chapter, we’ll present examples of the second style. 

Go’s API for querying an SQL database, like those of other languages, lets us cleanly separate the fixed part of a query from the variable parts. An example client might look like this: 

```go
import &amp;quot;database/sql&amp;quot; 
func listTracks(db sql.DB, artist string, minYear, maxYear int) {result, err := db.Exec( &amp;quot;SELECT * FROM tracks WHERE artist = ? AND ? &amp;lt;= year AND year &amp;lt;= ?&amp;quot;, artist, minYear, maxYear) // ... } 

The Exec method replaces each &#39;?&#39; in the query string with an SQL literal denoting the corresponding argument value, which may be a boolean, a number, a string, or nil. Constructing queries this way helps avoid SQL injection attacks, in which an adversary takes control of the query by exploiting improper quotation of input data. Within Exec, we might find a function like the one below, which converts each argument value to its literal SQL notation. 

```go
func sqlQuote(x interface{}) string { 
if x == nil {
return &amp;quot;NULL&amp;quot; 
} else if _, ok := x.(int); ok {
return fmt.Sprintf(&amp;quot;%d&amp;quot;, x) 
} else if _, ok := x.(uint); ok {
return fmt.Sprintf(&amp;quot;%d&amp;quot;, x) 
} else if b, ok := x.(bool); ok {
if b {return &amp;quot;TRUE&amp;quot; 
}
return &amp;quot;FALSE&amp;quot; 
} else if s, ok := x.(string); ok {
return sqlQuoteString(s) // (not shown) 
} else {
panic(fmt.Sprintf(&amp;quot;unexpected type %T: %v&amp;quot;, x, x)) }} 

A switch statement simplifies an if-else chain that performs a series of value equality tests. An analogous type switch statement simplifies an if-else chain of type assertions. 

In its simplest form, a type switch looks like an ordinary switch statement in which the operand is x.(type)—that’s literally the keyword type—and each case has one or more types. A type switch enables a multi-way branch based on the interface value’s dynamic type. The nil case matches if x == nil , and the default case matches if no other case does. A type switch for sqlQuote would have these cases: 
switch x.(type) { 
case nil: // ... 
case int, uint: // ... 
case bool: // ... 
case string: // ... 
default: // ... 
} 


As with an ordinary switch statement (§1.8), cases are considered in order and, when a match is found, the case’s body is executed. Case order becomes significant when one or more case types are interfaces, since then there is a possibility of two cases matching. The position of the default case relative to the others is immaterial. No fallthrough is allowed. 

Notice that in the original function, the logic for the bool and string cases needs access to the value extracted by the type assertion. Since this is typical, the type switch statement has an extended form that binds the extracted value to a new variable within each case: 


```go
switch x := x.(type) { /* ... */ } 

Here we’ve called the new variables x too; as with type assertions, reuse of variable names is common. Like a switch statement, a type switch implicitly creates a lexical block, so the declaration of the new variable called x does not conflict with a variable x in an outer block. Each case also implicitly creates a separate lexical block. 
Rewriting sqlQuote to use the extended form of type switch makes it significantly clearer: 

```go
func sqlQuote(x interface{}) string { 
switch x := x.(type) { 
case nil: 
return &amp;quot;NULL&amp;quot; 
case int, uint: 
return fmt.Sprintf(&amp;quot;%d&amp;quot;, x) // x has type 
interface{} here. 
case bool: 
if x {return &amp;quot;TRUE&amp;quot; 
} 
return &amp;quot;FALSE&amp;quot; case string:return sqlQuoteString(x) // (not shown) default: 
panic(fmt.Sprintf(&amp;quot;unexpected type %T: %v&amp;quot;, x, x)) }} 

In this version, within the block of each single-type case, the variable x has the same type as the case. For instance, x has type bool within the bool case and string within the string case. In all other cases, x has the (interface) type of the switch operand, which is interface{} in this example. When the same action is required for multiple cases, like int and uint, the type switch makes it easy to combine them. 

Although sqlQuote accepts an argument of any type, the function runs to completion only if the argument’s type matches one of the cases in the type switch; otherwise it panics with an “unexpected type” message. Although the type of x is interface{}, we consider it a discriminated union of int, uint, bool, string, and nil. 

7.14 Example: Token-Based XML Decoding 

Section 4.5 showed how to decode JSON documents into Go data structures with the Marshal and Unmarshal functions from the encoding/json package. The encoding/xml package provides a similar API. This approach is convenient when we want to construct a representation of the document tree, but that’s unnecessary for many programs. The encoding/xml package also provides a lower-level token-based API for decoding XML. In the token-based style, the parser consumes the input and produces a stream of tokens, primarily of four kinds —StartElement, EndElement, CharData, and Comment—each being a concrete type in the encoding/xml package. Each call to (*xml.Decoder).Token returns a token. 


The relevant parts of the API are shown here: 

```go
encoding/xml 
package xml 
type Name struct {
Local string // e.g., &amp;quot;Title&amp;quot; or &amp;quot;id&amp;quot; 
} 

type Attr struct { // e.g., name=&amp;quot;value&amp;quot; 
Name Name 
Value string } 
// A Token includes StartElement, EndElement, CharData,
// and Comment, plus a few esoteric types (not shown). 
type Token interface{} 
type StartElement struct { // e.g., &amp;lt;name&amp;gt; 
Name Name 
Attr []Attr 
}
type EndElement struct { Name Name } // e.g., &amp;lt;/name&amp;gt; 
type CharData []byte // e.g., &amp;lt;p&amp;gt;CharData&amp;lt;/p&amp;gt;
type Comment []byte // e.g., &amp;lt;!-­Comment --&amp;gt; 
type Decoder struct{ /* ... */ } 
func NewDecoder(io.Reader) 
*Decoder func (*Decoder) Token() (Token, error) // returns next Token in sequence 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Token interface, which has no methods, is also an example of a discriminated union. The purpose of a traditional interface like io.Reader is to hide details of the concrete types that satisfy it so that new implementations can be created; each concrete type is treated uniformly. By contrast, the set of concrete types that satisfy a discriminated union is fixed by the design and exposed, not hidden. Discriminated union types have few methods; functions that operate on them are expressed as a set of cases using a type switch, with different logic in each case.&lt;/p&gt;

&lt;p&gt;The xmlselect program below extracts and prints the text found beneath certain elements in an XML document tree. Using the API above, it can do its job in a single pass over the input without ever materializing the tree.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch7/xmlselect 
// Xmlselect prints the text of selected elements of an XML document. package main 
import (
&amp;quot;encoding/xml&amp;quot;
&amp;quot;fmt&amp;quot; 
&amp;quot;io&amp;quot; 
&amp;quot;os&amp;quot; 
&amp;quot;strings&amp;quot; 

) func main() {
dec := xml.NewDecoder(os.Stdin) 
var stack []string // stack of element names 
for {
tok, err := dec.Token() if err == io.EOF {break } else if err != nil {fmt.Fprintf(os.Stderr, &amp;quot;xmlselect: %v\n&amp;quot;, err) 
os.Exit(1) 
}
switch tok := tok.(type) { 
case xml.StartElement: stack = append(stack, tok.Name.Local) // push 
case xml.EndElement: stack = stack[:len(stack)-1] // pop 
case xml.CharData: 
 if containsAll(stack, os.Args[1:]) 
 { fmt.Printf(&amp;quot;%s: %s\n&amp;quot;, strings.Join(stack, &amp;quot; &amp;quot;), tok) }}}} 
// containsAll reports whether x contains the elements of y, in order. 
func containsAll(x, y []string) bool {

for len(y) &amp;lt;= len(x) { 
if len(y) == 0 {
return true 
}
if x[0] == y[0] { 
y = y[1:] 
}
x = x[1:] 
}
return false 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each time the loop in main encounters a StartElement, it pushes the element’s name onto a stack, and for each EndElement it pops the name from the stack. The API guarantees that the sequence of StartElement and EndElement tokens will be properly matched, even in ill-formed documents. Comments are ignored. When xmlselect encounters a CharData, it prints the text only if the stack contains all the elements named by the command-line arguments, in order.&lt;/p&gt;

&lt;p&gt;The command below prints the text of any h2 elements appearing beneath two levels of div elements. Its input is the XML specification, itself an XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch1/fetch 
$ ./fetch http://www.w3.org/TR/2006/REC-xml11-20060816 
| ./xmlselect div div h2 
html body div div h2: 1 Introduction 
html body div div h2: 2 Documents 
html body div div h2: 3 Logical Structures 
html body div div h2: 4 Physical Structures 
html body div div h2: 5 Conformance 
html body div div h2: 6 Notation 
html body div div h2: A References 
html body div div h2: B Definitions for Character 
Normalization 
... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exercise 7.17: Extend xmlselect so that elements may be selected not just by name, but by their attributes too, in the manner of CSS, so that, for instance, an element like &lt;div id=&#34;page&#34; class=&#34;wide&#34;&gt; could be selected by a matching id or class as well as its name.&lt;/p&gt;

&lt;p&gt;Exercise 7.18: Using the token-based decoder API, write a program that will read an arbitrary XML document and construct a tree of generic nodes that represents it. Nodes are of two kinds: CharData nodes represent text strings, and Element nodes represent named elements and their attributes. Each element node has a slice of child nodes.&lt;/p&gt;

&lt;p&gt;You may find the following declarations helpful.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;encoding/xml&amp;quot; 
type Node interface{} // CharData or *Element 
type CharData string 
type Element struct {
Type xml.Name 
Attr []xml.Attr 
Children []Node 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.15 A Few Words of Advice&lt;/p&gt;

&lt;p&gt;When designing a new package, novice Go programmers often start by creating a set of interfaces and only later define the concrete types that satisfy them. This approach results in many interfaces, each of which has only a single implementation. Don’t do that. Such interfaces are unnecessary abstractions; they also have a run-time cost. You can restrict which methods of a type or fields of a struct are visible outside a package using the export mechanism (§6.6). Interfaces are only needed when there are two or more concrete types that must be dealt with in a uniform way.&lt;/p&gt;

&lt;p&gt;We make an exception to this rule when an interface is satisfied by a single concrete type but that type cannot live in the same package as the interface because of its dependencies. In that case, an interface is a good way to decouple two packages.&lt;/p&gt;

&lt;p&gt;Because interfaces are used in Go only when they are satisfied by two or more types, they necessarily abstract away from the details of any particular implementation. The result is smaller interfaces with fewer, simpler methods, often just one as with io.Writer or fmt.Stringer. Small interfaces are easier to satisfy when new types come along. A good rule of thumb for interface design is ask only for what you need.&lt;/p&gt;

&lt;p&gt;This concludes our tour of methods and interfaces. Go has great support for the object-oriented style of programming, but this does not mean you need to use it exclusively. Not everything need be an object; standalone functions have their place, as do unencapsulated data types. Observe that together, the examples in the first five chapters of this book call no more than two dozen methods, like input.Scan, as opposed to ordinary function calls like fmt.Printf.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Goroutines and Channels
Concurrent programming, the expression of a program as a composition of several autonomous activities, has never been more important than it is today. Web servers handle requests for thousands of clients at once. Tablet and phone apps render animations in the user interface while simultaneously performing computation and network requests in the background. Even traditional batch problems—read some data, compute, write some output—use concurrency to hide the latency of I/O operations and to exploit a modern computer’s many processors, which every year grow in number but not in speed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Go enables two styles of concurrent programming. This chapter presents goroutines and channels, which support communicating sequential processes or CSP, a model of concurrency in which values are passed between independent activities (goroutines) but variables are for the most part confined to a single activity. Chapter 9 covers some aspects of the more traditional model of shared memory multithreading, which will be familiar if you’ve used threads in other mainstream languages. Chapter 9 also points out some important hazards and pitfalls of concurrent programming that we won’t delve into in this chapter.&lt;/p&gt;

&lt;p&gt;Even though Go’s support for concurrency is one of its great strengths, reasoning about concurrent programs is inherently harder than about sequential ones, and intuitions acquired from sequential programming may at times lead us astray. If this is your first encounter with concurrency, we recommend spending a little extra time thinking about the examples in these two chapters.&lt;/p&gt;

&lt;h2 id=&#34;goroutines:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Goroutines&lt;/h2&gt;

&lt;p&gt;In Go, each concurrently executing activity is called a goroutine. Consider a program that has two functions, one that does some computation and one that writes some output, and assume that neither function calls the other. A sequential program may call one function and then call the other, but in a concurrent program with two or more goroutines, calls to both functions can be active at the same time. We’ll see such a program in a moment.&lt;/p&gt;

&lt;p&gt;If you have used operating system threads or threads in other languages, then you can assume for now that a goroutine is similar to a thread, and you’ll be able to write correct programs. The differences between threads and goroutines are essentially quantitative, not qualitative, and will be described in Section 9.8.&lt;/p&gt;

&lt;p&gt;When a program starts, its only goroutine is the one that calls the main function, so we call it the main goroutine. New goroutines are created by the go statement. Syntactically, a go statement is an ordinary function or method call prefixed by the keyword go.A go statement causes the function to be called in a newly created goroutine. The go statement itself completes immediately:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f() // call f(); wait for it to return 
go f() // create a new goroutine that calls f(); don&#39;t 
wait 

In the example below, the main goroutine computes the 45th Fibonacci number. Since it uses the terribly inefficient recursive algorithm, it runs for an appreciable time, during which we’d like to provide the user with a visual indication that the program is still running, by displaying an animated textual “spinner.” 

```go
// gopl.io/ch8/spinner 
func main() {
go spinner(100 * time.Millisecond) 
const n = 45 
fibN := fib(n) // slow 
fmt.Printf(&amp;quot;\rFibonacci(%d) = %d\n&amp;quot;, n, fibN) 

} 
func spinner(delay time.Duration) { 
for {

for     _, r := range `-\|/` {
fmt.Printf(&amp;quot;\r%c&amp;quot;, r) 
time.Sleep(delay) 

}
}
} 

func fib(x int) int {
if x &amp;lt; 2 {

return x 
}
return fib(x-1) + fib(x-2) 

} 

After several seconds of animation, the fib(45) call returns and the main function prints its result: 
Fibonacci(45) = 1134903170 


The main function then returns. When this happens, all goroutines are abruptly terminated and the program exits. Other than by returning from main or exiting the program, there is no programmatic way for one goroutine to stop another, but as we will see later, there are ways to communicate with a goroutine to request that it stop itself. 
Notice how the program is expressed as the composition of two autonomous activities, spinning and Fibonacci computation. Each is written as a separate function but both make progress concurrently. 


## Example: Concurrent Clock Server 
Networking is a natural domain in which to use concurrency since servers typically handle many connections from their clients at once, each client being essentially independent of the others. In this section, we’ll introduce the net package, which provides the components for building networked client and server programs that communicate over TCP, UDP, or Unix domain sockets. The net/http package we’ve been using since Chapter 1 is built on top of functions from the net package. 

Our first example is a sequential clock server that writes the current time to the client once per second: 


```go
// gopl.io/ch8/clock1 
// Clock1 is a TCP server that periodically writes the time. package main 
import (
&amp;quot;io&amp;quot; 
&amp;quot;log&amp;quot;
&amp;quot;net&amp;quot; 
&amp;quot;time&amp;quot; 

) 
func main() {
listener, err := net.Listen(&amp;quot;tcp&amp;quot;, 
&amp;quot;localhost:8000&amp;quot;)
if err != nil {

log.Fatal(err) 
}
for {

conn, err := listener.Accept() 
if err != nil {log.Print(err) // e.g., connection aborted continue 
} 
handleConn(conn) // handle one connection at a time }} 
func handleConn(c net.Conn) { 
defer c.Close() 
for { _, err := io.WriteString(c,
time.Now().Format(&amp;quot;15:04:05\n&amp;quot;))
if err != nil {
return // e.g., client disconnected }
time.Sleep(1 * time.Second) 
}} 

The Listen function creates a net.Listener, an object that listens for incoming connections on a network port, in this case TCP port localhost:8000. The listener’s Accept method blocks until an incoming connection request is made, then returns a net.Conn object representing the connection. 


The handleConn function handles one complete client connection. In a loop, it writes the current time, time.Now(), to the client. Since net.Conn satisfies the io.Writer interface, we can write directly to it. The loop ends when the write fails, most likely because the client has disconnected, at which point handleConn closes its side of the connection using a deferred call to Close and goes back to waiting for another connection request. 


The time.Time.Format method provides a way to format date and time information by example. Its argument is a template indicating how to format a reference time, specifically Mon Jan 2 03:04:05PM 2006 UTC-0700. The reference time has eight components (day of the week, month, day of the month, and so on). Any collection of them can appear in the Format string in any order and in a number of formats; the selected components of the date and time will be displayed in the selected formats. Here we are just using the hour, minute, and second of the time. The time package defines templates for many standard time formats, such as time.RFC1123. The same mechanism is used in reverse when parsing a time using time.Parse. 

To connect to the server, we’ll need a client program such as nc (“netcat”), a standard utility program for manipulating network connections: 

```go
$ go build gopl.io/ch8/clock1 
$ ./clock1 &amp;amp; 
$ nc localhost 8000 
13:58:54 
13:58:55 
13:58:56 
13:58:57 
^C 


The client displays the time sent by the server each second until we interrupt the client with Control-C, which on Unix systems is echoed as ^C by the shell. If nc or netcat is not installed on your system, you can use telnet or this simple Go version of netcat that uses net.Dial to connect to a TCP server: 

```go
// gopl.io/ch8/netcat1 
// Netcat1 is a read-only TCP client. 
package main 

import (
&amp;quot;io&amp;quot; 
&amp;quot;log&amp;quot;
&amp;quot;net&amp;quot; 
&amp;quot;os&amp;quot; 

) 
func main() {
conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;) 
if err != nil {

log.Fatal(err) 
}
defer conn.Close()
mustCopy(os.Stdout, conn) 

} 
func mustCopy(dst io.Writer, src io.Reader) { 
if _, err := io.Copy(dst, src); err != nil {
log.Fatal(err) 
}
} 

This program reads data from the connection and writes it to the standard output until an end-of-file condition or an error occurs. The mustCopy function is a utility used in several examples in this section. Let’s run two clients at the same time on different terminals, one shown to the left and one to the right: 

```go
$ go build gopl.io/ch8/netcat1 
$ ./netcat1
13:58:54 $ ./netcat1 
13:58:55 
13:58:56 
^C 

13:58:57 13:58:58 13:58:59 ^C 
$ killall clock1 

The killall command is a Unix utility that kills all processes with the given name. 

The second client must wait until the first client is finished because the server is sequential; it deals with only one client at a time. Just one small change is needed to make the server concurrent: adding the go keyword to the call to handleConn causes each call to run in its own goroutine. 

```go
// gopl.io/ch8/clock2 
for     {
conn, err := listener.Accept() 
if err != nil {

log.Print(err) // e.g., connection aborted continue }
go handleConn(conn) // handle connections 
concurrently
} 


Now, multiple clients can receive the time at once: 

```go
$ go build gopl.io/ch8/clock2 
$ ./clock2 &amp;amp; 
$ go build gopl.io/ch8/netcat1 
$ ./netcat1
14:02:54 $ ./netcat1 
14:02:55 14:02:55 
14:02:56 14:02:56 

14:02:57 ^C 
14:02:58 
14:02:59 $ ./netcat1 
14:03:00 14:03:00 
14:03:01 14:03:01 
^C 14:03:02 

^C 
$ killall clock2 


Exercise 8.1: Modify clock2 to accept a port number, and write a program, clockwall, that acts as a client of several clock servers at once, reading the times from each one and displaying the results in a table, akin to the wall of clocks seen in some business offices. If you have access to geographically distributed computers, run instances remotely; otherwise run local instances on different ports with fake time zones. 

```go
$ TZ=US/Eastern ./clock2 -port 8010 &amp;amp; 
$ TZ=Asia/Tokyo ./clock2 -port 8020 &amp;amp; 
$ TZ=Europe/London ./clock2 -port 8030 &amp;amp; 
$ clockwall NewYork=localhost:8010 
London=localhost:8020 Tokyo=localhost:8030 


Exercise 8.2: Implement a concurrent File Transfer Protocol (FTP) server. The server should interpret commands from each client such as cd to change directory, 
ls to list a directory, get to send the contents of a file, and close to close the 
connection. You can use the standard ftp command as the client, or write your own. 


## Example: Concurrent Echo Server 

The clock server used one goroutine per connection. In this section, we’ll build an echo server that uses multiple goroutines per connection. Most echo servers merely write whatever they read, which can be done with this trivial version of handleConn: 

```go
func handleConn(c net.Conn) { 
io.Copy(c, c) // NOTE: ignoring errors 
c.Close() 

} 

A more interesting echo server might simulate the reverberations of a real echo, with the response loud at first (&amp;quot;HELLO!&amp;quot;), then moderate (&amp;quot;Hello!&amp;quot;) after a delay, then quiet (&amp;quot;hello!&amp;quot;) before fading to nothing, as in this version of handleConn: 

```go
// gopl.io/ch8/reverb1 
func echo(c net.Conn, shout string, delay 
time.Duration) {
fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToUpper(shout)) 
time.Sleep(delay)
fmt.Fprintln(c, &amp;quot;\t&amp;quot;, shout) 
time.Sleep(delay)
fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToLower(shout)) 

} 
func handleConn(c net.Conn) { 
input := bufio.NewScanner(c) 
for input.Scan() {

echo(c, input.Text(), 1*time.Second) }// NOTE: ignoring potential errors from 
input.Err() 
c.Close() 
} 


We’ll need to upgrade our client program so that it sends terminal input to the server while also copying the server response to the output, which presents another opportunity to use concurrency: 

```go
// gopl.io/ch8/netcat2 
func main() {
conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;) 
if err != nil {

log.Fatal(err) 
}
defer conn.Close() 
go mustCopy(os.Stdout, conn) 
mustCopy(conn, os.Stdin) 

} 

While the main goroutine reads the standard input and sends it to the server, a second goroutine reads and prints the server’s response. When the main goroutine encounters the end of the input, for example, after the user types Control-D (^D) at the terminal (or the equivalent Control-Z on Microsoft Windows), the program stops, even if the other goroutine still has work to do. (We’ll see how to make the program wait for both sides to finish once we’ve introduced channels in Section 8.4.1.) 

In the session below, the client’s input is left-aligned and the server’s responses are indented. The client shouts at the echo server three times: 
$ go build gopl.io/ch8/reverb1 
$ ./reverb1 &amp;amp; 
$ go build gopl.io/ch8/netcat2 
$ ./netcat2
Hello? 

HELLO? 
Hello? 
hello? 

Is there anybody there? 
IS THERE ANYBODY THERE? 
Yooo-hooo! 

Is there anybody there? 
is there anybody there? 
YOOO-HOOO! 
Yooo-hooo! 
yooo-hooo! 

^D 
$ killall reverb1 

Notice that the third shout from the client is not dealt with until the second shout has petered out, which is not very realistic. A real echo would consist of the composition of the three independent shouts. To simulate it, we’ll need more goroutines. Again, all we need to do is add the go keyword, this time to the call to echo: 

```go
// gopl.io/ch8/reverb2 
func handleConn(c net.Conn) { 
input := bufio.NewScanner(c) 
for input.Scan() {

go echo(c, input.Text(), 1*time.Second) }// NOTE: ignoring potential errors from 
input.Err()
c.Close() 
} 


The arguments to the function started by go are evaluated when the go statement itself is executed; thus input.Text() is evaluated in the main goroutine. 

Now the echoes are concurrent and overlap in time: 
$ go build gopl.io/ch8/reverb2 
$ ./reverb2 &amp;amp; 
$ ./netcat2 
Is there anybody there? 

IS THERE ANYBODY THERE? 
Yooo-hooo! 
Is there anybody there? 
YOOO-HOOO! 
is there anybody there? 

Yooo-hooo! 
yooo-hooo! 
^D 
$ killall reverb2 
All that was required to make the server use concurrency, not just to handle connections from multiple clients but even within a single connection, was the insertion of two go keywords. 

However in adding these keywords, we had to consider carefully that it is safe to call methods of net.Conn concurrently, which is not true for most types. We’ll discuss the crucial concept of concurrency safety in the next chapter. 

## Channels 

If goroutines are the activities of a concurrent Go program, channels are the connections between them. A channel is a communication mechanism that lets one goroutine send values to another goroutine. Each channel is a conduit for values of a particular type, called the channel’s element type. The type of a channel whose elements have type int is written chan int . 

To create a channel, we use the built-in make function: 

```go
ch := make(chan int) // ch has type &#39;chan int&#39; 

As with maps, a channel is a reference to the data structure created by make. When we copy a channel or pass one as an argument to a function, we are copying a reference, so caller and callee refer to the same data structure. As with other reference types, the zero value of a channel is nil. 

Two channels of the same type may be compared using ==. The comparison is true if both are references to the same channel data structure. A channel may also be compared to nil. 


A channel has two principal operations, send and receive, collectively known as communications. A send statement transmits a value from one goroutine, through the channel, to another goroutine executing a corresponding receive expression. Both operations are written using the &amp;lt;-operator. In a send statement, the &amp;lt;-separates the channel and value operands. In a receive expression, &amp;lt;-precedes the channel operand. A receive expression whose result is not used is a valid statement. 

```go
ch &amp;lt;-x // a send statement 
x = &amp;lt;-ch // a receive expression in an assignment 
statement 
&amp;lt;-ch // a receive statement; result is discarded 
Channels support a third operation, close, which sets a flag indicating that no more values will ever be sent on this channel; subsequent attempts to send will panic. 
Receive operations on a closed channel yield the values that have been sent until no more values are left; any receive operations thereafter complete immediately and yield the zero value of the channel’s element type. 

To close a channel, we call the built-in close function: 
close(ch) 

A channel created with a simple call to make is called an unbuffered channel, but make accepts an optional second argument, an integer called the channel’s capacity. If the capacity is non-zero, make creates a buffered channel. 

```go
ch = make(chan int) // unbuffered channel 
ch = make(chan int, 0) // unbuffered channel 
ch = make(chan int, 3) // buffered channel with 
capacity 3 

We’ll look at unbuffered channels first and buffered channels in Section 8.4.4. 


### Unbuffered Channels 

A send operation on an unbuffered channel blocks the sending goroutine until another goroutine executes a corresponding receive on the same channel, at which point the value is transmitted and both goroutines may continue. Conversely, if the receive operation was attempted first, the receiving goroutine is blocked until another goroutine performs a send on the same channel. 

Communication over an unbuffered channel causes the sending and receiving goroutines to synchronize. Because of this, unbuffered channels are sometimes called synchronous channels. When a value is sent on an unbuffered channel, the receipt of the value happens before the reawakening of the sending goroutine. 

In discussions of concurrency, when we say x happens before y, we don’t mean merely that x occurs earlier in time than y; we mean that it is guaranteed to do so and that all its prior effects, such as updates to variables, are complete and that you may rely on them. 


When x neither happens before y nor after y, we say that x is concurrent with y. This doesn’t mean that x and y are necessarily simultaneous, merely that we cannot assume anything about their ordering. As we’ll see in the next chapter, it’s necessary to order certain events during the program’s execution to avoid the problems that arise when two goroutines access the same variable concurrently. 

The client program in Section 8.3 copies input to the server in its main goroutine, so the client program terminates as soon as the input stream closes, even if the background goroutine is still working. To make the program wait for the background goroutine to complete before exiting, we use a channel to synchronize the two goroutines: 

```go
// gopl.io/ch8/netcat3 
func main() {
conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;) 
if err != nil {
log.Fatal(err) 
}
done := make(chan struct{}) 
go func() {
io.Copy(os.Stdout, conn) // NOTE: ignoring errors log.Println(&amp;quot;done&amp;quot;)
done &amp;lt;-struct{}{} // signal the main goroutine
}()
mustCopy(conn, os.Stdin) 
conn.Close()
&amp;lt;-done // wait for background goroutine to finish } 

When the user closes the standard input stream, mustCopy returns and the main goroutine calls conn.Close(), closing both halves of the network connection. Closing the write half of the connection causes the server to see an end-of-file condition. Closing the read half causes the background goroutine’s call to io.Copy to return a “read from closed connection” error, which is why we’ve removed the error logging; Exercise 8.3 suggests a better solution. (Notice that the go statement calls a literal function, a common construction.) 

Before it returns, the background goroutine logs a message, then sends a value on the done channel. The main goroutine waits until it has received this value before returning. As a result, the program always logs the &amp;quot;done&amp;quot; message before exiting. 
Messages sent over channels have two important aspects. Each message has a value, but sometimes the fact of communication and the moment at which it occurs are just as important. We call messages events when we wish to stress this aspect. When the event carries no additional information, that is, its sole purpose is synchronization, we’ll emphasize this by using a channel whose element type is struct{}, though it’s common to use a channel of bool or int for the same purpose since done &amp;lt;­1 is shorter than done &amp;lt;-struct{}{}. 


Exercise 8.3: In netcat3, the interface value conn has the concrete type *net.TCPConn, which represents a TCP connection. A TCP connection consists of two halves that may be closed independently using its CloseRead and CloseWrite methods. Modify the main goroutine of netcat3 to close only the write half of the connection so that the program will continue to print the final echoes from the reverb1 server even after the standard input has been closed. (Doing this for the reverb2 server is harder; see Exercise 8.4.) 


### Pipelines 

Channels can be used to connect goroutines together so that the output of one is the input to another. This is called a pipeline. The program below consists of three goroutines connected by two channels, as shown schematically in Figure 8.1. 


The first goroutine, counter, generates the integers 0, 1, 2, ..., and sends them over a channel to the second goroutine, squarer, which receives each value, squares it, and sends the result over another channel to the third goroutine, printer, which receives the squared values and prints them. For clarity of this example, we have intentionally chosen very simple functions, though of course they are too computationally trivial to warrant their own goroutines in a realistic program. 

```go
// gopl.io/ch8/pipeline1 
func main() {
naturals := make(chan int) 
squares := make(chan int) 

// Counter 
go func() {
for x := 0; ; x++ {
naturals &amp;lt;-x 
}
}() 

// Squarer 
go func() {

for     {
x := &amp;lt;-naturals 
squares &amp;lt;-x * x 

}
}() 

// Printer (in main goroutine) 
for {
fmt.Println(&amp;lt;-squares) 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you might expect, the program prints the infinite series of squares 0, 1, 4, 9, and so on. Pipelines like this may be found in long-running server programs where channels are used for lifelong communication between goroutines containing infinite loops. But what if we want to send only a finite number of values through the pipeline?&lt;/p&gt;

&lt;p&gt;If the sender knows that no further values will ever be sent on a channel, it is useful to communicate this fact to the receiver goroutines so that they can stop waiting. This is accomplished by closing the channel using the built-in close function:
close(naturals)&lt;/p&gt;

&lt;p&gt;After a channel has been closed, any further send operations on it will panic. After the closed channel has been drained, that is, after the last sent element has been received, all subsequent receive operations will proceed without blocking but will yield a zero value. Closing the naturals channel above would cause the squarer’s loop to spin as it receives a never-ending stream of zero values, and to send these zeros to the printer.&lt;/p&gt;

&lt;p&gt;There is no way to test directly whether a channel has been closed, but there is a variant of the receive operation that produces two results: the received channel element, plus a boolean value, conventionally called ok, which is true for a successful receive and false for a receive on a closed and drained channel. Using this feature, we can modify the squarer’s loop to stop when the naturals channel is drained and close the squares channel in turn.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Squarer 
go func() {
for {x, ok := &amp;lt;-naturals 
if !ok {
break // channel was closed and drained }
squares &amp;lt;-x * x }
close(squares) }() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because the syntax above is clumsy and this pattern is common, the language lets us use a range loop to iterate over channels too. This is a more convenient syntax for receiving all the values sent on a channel and terminating the loop after the last one.&lt;/p&gt;

&lt;p&gt;In the pipeline below, when the counter goroutine finishes its loop after 100 elements, it closes the naturals channel, causing the squarer to finish its loop and close the squares channel. (In a more complex program, it might make sense for the counter and squarer functions to defer the calls to close at the outset.)
Finally, the main goroutine finishes its loop and the program exits.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch8/pipeline2 
func main() {
naturals := make(chan int) 
squares := make(chan int) 

// Counter 
go func() {
for x := 0; x &amp;lt; 100; x++ {

naturals &amp;lt;-x 
}
close(naturals) 

}() 
// Squarer 
go func() {
for x := range naturals {

squares &amp;lt;-x * x 
}
close(squares) 

}() 
// Printer (in main goroutine) 
for x := range squares {
fmt.Println(x) 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You needn’t close every channel when you’ve finished with it. It’s only necessary to close a channel when it is important to tell the receiving goroutines that all data have been sent. A channel that the garbage collector determines to be unreachable will have its resources reclaimed whether or not it is closed. (Don’t confuse this with the close operation for open files. It is important to call the Close method on every file when you’ve finished with it.)&lt;/p&gt;

&lt;p&gt;Attempting to close an already-closed channel causes a panic, as does closing a nil channel. Closing channels has another use as a broadcast mechanism, which we’ll cover in Section 8.9.&lt;/p&gt;

&lt;h3 id=&#34;unidirectional-channel-types:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Unidirectional Channel Types&lt;/h3&gt;

&lt;p&gt;As programs grow, it is natural to break up large functions into smaller pieces. Our previous example used three goroutines, communicating over two channels, which were local variables of main. The program naturally divides into three functions:
func counter(out chan int)
func squarer(out, in chan int)
func printer(in chan int)&lt;/p&gt;

&lt;p&gt;The squarer function, sitting in the middle of the pipeline, takes two parameters, the input channel and the output channel. Both have the same type, but their intended uses are opposite: in is only to be received from, and out is only to be sent to. The names in and out convey this intention, but still, nothing prevents squarer from sending to in or receiving from out.&lt;/p&gt;

&lt;p&gt;This arrangement is typical. When a channel is supplied as a function parameter, it is nearly always with the intent that it be used exclusively for sending or exclusively for receiving.&lt;/p&gt;

&lt;p&gt;To document this intent and prevent misuse, the Go type system provides unidirectional channel types that expose only one or the other of the send and receive operations. The type chan&amp;lt;-int ,a send-only channel of int, allows sends but not receives. Conversely, the type &amp;lt;-chan int ,a receive-only channel of int, allows receives but not sends. (The position of the &amp;lt;-arrow relative to the chan keyword is a mnemonic.) Violations of this discipline are detected at compile time.&lt;/p&gt;

&lt;p&gt;Since the close operation asserts that no more sends will occur on a channel, only the sending goroutine is in a position to call it, and for this reason it is a compile-time error to attempt to close a receive-only channel.&lt;/p&gt;

&lt;p&gt;Here’s the squaring pipeline once more, this time with unidirectional channel types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch8/pipeline3 
func counter(out chan&amp;lt;-int) { 
for x := 0; x &amp;lt; 100; x++ {
out &amp;lt;-x 
}
close(out) } 
func squarer(out chan&amp;lt;-int, in &amp;lt;-chan int) { 
for v := range in {

out &amp;lt;-v * v 
}
close(out) 

} 
func printer(in &amp;lt;-chan int) { 
for v := range in {
fmt.Println(v) 
}
} 

func main() {
naturals := make(chan int) 
squares := make(chan int) 

go counter(naturals) 
go squarer(squares, naturals) 
printer(squares) 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thee call counter(naturals) implicitly converts naturals, a value of type chan int , to the type of the parameter, chan&amp;lt;-int . The printer(squares) call does a similar implicit conversion to &amp;lt;-chan int . Conversions from bidirectional to unidirectional channel types are permitted in any assignment. There is no going back, however: once you have a value of a unidirectional type such as chan&amp;lt;-int , there is no way to obtain from it a value of type chan int that refers to the same channel data structure.&lt;/p&gt;

&lt;h3 id=&#34;buffered-channels:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Buffered Channels&lt;/h3&gt;

&lt;p&gt;A buffered channel has a queue of elements. The queue’s maximum size is determined when it is created, by the capacity argument to make. The statement below creates a buffered channel capable of holding three string values. Figure 8.2 is a graphical representation of ch and the channel to which it refers.&lt;/p&gt;

&lt;p&gt;ch = make(chan string, 3)&lt;/p&gt;

&lt;p&gt;A send operation on a buffered channel inserts an element at the back of the queue, and a receive operation removes an element from the front. If the channel is full, the send operation blocks its goroutine until space is made available by another goroutine’s receive. Conversely, if the channel is empty, a receive operation blocks until a value is sent by another goroutine.&lt;/p&gt;

&lt;p&gt;We can send up to three values on this channel without the goroutine blocking:
ch &amp;lt;-&amp;ldquo;A&amp;rdquo;
ch &amp;lt;-&amp;ldquo;B&amp;rdquo;
ch &amp;lt;-&amp;ldquo;C&amp;rdquo;&lt;/p&gt;

&lt;p&gt;At this point, the channel is full (Figure 8.3), and a fourth send statement would block.&lt;/p&gt;

&lt;p&gt;If we receive one value,
fmt.Println(&amp;lt;-ch) // &amp;ldquo;A&amp;rdquo;
the channel is neither full nor empty (Figure 8.4), so either a send operation or a receive operation could proceed without blocking. In this way, the channel’s buffer decouples the sending and receiving goroutines.&lt;/p&gt;

&lt;p&gt;Figure 8.4. A partially full buffered channel.&lt;/p&gt;

&lt;p&gt;In the unlikely event that a program needs to know the channel’s buffer capacity, it can be obtained by calling the built-in cap function:
fmt.Println(cap(ch)) // &amp;ldquo;3&amp;rdquo;&lt;/p&gt;

&lt;p&gt;When applied to a channel, the built-in len function returns the number of elements currently buffered. Since in a concurrent program this information is likely to be stale as soon as it is retrieved, its value is limited, but it could conceivably be useful during fault diagnosis or performance optimization.
fmt.Println(len(ch)) // &amp;ldquo;2&amp;rdquo;&lt;/p&gt;

&lt;p&gt;After two more receive operations the channel is empty again, and a fourth would block:
fmt.Println(&amp;lt;-ch) // &amp;ldquo;B&amp;rdquo;
fmt.Println(&amp;lt;-ch) // &amp;ldquo;C&amp;rdquo;&lt;/p&gt;

&lt;p&gt;In this example, the send and receive operations were all performed by the same goroutine, but in real programs they are usually executed by different goroutines. Novices are sometimes tempted to use buffered channels within a single goroutine as a queue, lured by their pleasingly simple syntax, but this is a mistake. Channels are deeply connected to goroutine scheduling, and without another goroutine receiving from the channel, a sender—and perhaps the whole program—risks becoming blocked forever. If all you need is a simple queue, make one using a slice.&lt;/p&gt;

&lt;p&gt;The example below shows an application of a buffered channel. It makes parallel requests to three mirrors, that is, equivalent but geographically distributed servers. It sends their responses over a buffered channel, then receives and returns only the first response, which is the quickest one to arrive. Thus mirroredQuery returns a result even before the two slower servers have responded. (Incidentally, it’s quite normal for several goroutines to send values to the same channel concurrently, as in this example, or to receive from the same channel.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func mirroredQuery() string { 
responses := make(chan string, 3) 
go func() { responses &amp;lt;-request(&amp;quot;asia.gopl.io&amp;quot;) } () go func() { responses &amp;lt;-request(&amp;quot;europe.gopl.io&amp;quot;) 
}() go func() { responses &amp;lt;­request(&amp;quot;americas.gopl.io&amp;quot;) }()return &amp;lt;-responses // return the quickest response } 
func request(hostname string) (response string) { /* 
... */ } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Had we used an unbuffered channel, the two slower goroutines would have gotten stuck trying to send their responses on a channel from which no goroutine will ever receive. This situation, called a goroutine leak, would be a bug. Unlike garbage variables, leaked goroutines are not automatically collected, so it is important to make sure that goroutines terminate themselves when no longer needed.&lt;/p&gt;

&lt;p&gt;The choice between unbuffered and buffered channels, and the choice of a buffered channel’s capacity, may both affect the correctness of a program. Unbuffered channels give stronger synchronization guarantees because every send operation is synchronized with its corresponding receive; with buffered channels, these operations are decoupled. Also, when we know an upper bound on the number of values that will be sent on a channel, it’s not unusual to create a buffered channel of that size and perform all the sends before the first value is received. Failure to allocate sufficient buffer capacity would cause the program to deadlock.&lt;/p&gt;

&lt;p&gt;Channel buffering may also affect program performance. Imagine three cooks in a cake shop, one baking, one icing, and one inscribing each cake before passing it on to the next cook in the assembly line. In a kitchen with little space, each cook that has finished a cake must wait for the next cook to become ready to accept it; this rendezvous is analogous to communication over an unbuffered channel.&lt;/p&gt;

&lt;p&gt;If there is space for one cake between each cook, a cook may place a finished cake there and immediately start work on the next; this is analogous to a buffered channel with capacity 1. So long as the cooks work at about the same rate on average, most of these handovers proceed quickly, smoothing out transient differences in their respective rates. More space between cooks—larger buffers—can smooth out bigger transient variations in their rates without stalling the assembly line, such as happens when one cook takes a short break, then later rushes to catch up.&lt;/p&gt;

&lt;p&gt;On the other hand, if an earlier stage of the assembly line is consistently faster than the following stage, the buffer between them will spend most of its time full. Conversely, if the later stage is faster, the buffer will usually be empty. A buffer provides no benefit in this case.&lt;/p&gt;

&lt;p&gt;The assembly line metaphor is a useful one for channels and goroutines. For example, if the second stage is more elaborate, a single cook may not be able to keep up with the supply from the first cook or meet the demand from the third. To solve the problem, we could hire another cook to help the second, performing the same task but working independently. This is analogous to creating another goroutine communicating over the same channels.&lt;/p&gt;

&lt;p&gt;We don’t have space to show it here, but the // gopl.io/ch8/cake package simulates this cake shop, with several parameters you can vary. It includes benchmarks (§11.4) for a few of the scenarios described above.&lt;/p&gt;

&lt;h2 id=&#34;looping-in-parallel:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Looping in Parallel&lt;/h2&gt;

&lt;p&gt;In this section, we’ll explore some common concurrency patterns for executing all the iterations of a loop in parallel. We’ll consider the problem of producing thumbnail-size images from a set of full-size ones. The // gopl.io/ch8/thumbnail package provides an ImageFile function that can scale a single image. We won’t show its implementation but it can be downloaded from gopl.io.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch8/thumbnail 
package thumbnail 
// ImageFile reads an image from infile and writes 
// a thumbnail-size version of it in the same 
directory.
// It returns the generated file name, e.g., 
&amp;quot;foo.thumb.jpg&amp;quot;.
func ImageFile(infile string) (string, error) 

The program below loops over a list of image file names and produces a thumbnail for each one: 

```go
// gopl.io/ch8/thumbnail 
// makeThumbnails makes thumbnails of the specified 
files. 
func makeThumbnails(filenames []string) { 
for _, f := range filenames {
if _, err := thumbnail.ImageFile(f); err != 
nil { log.Println(err) 
}}} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously the order in which we process the files doesn’t matter, since each scaling operation is independent of all the others. Problems like this that consist entirely of subproblems that are completely independent of each other are described as embarrassingly parallel. Embarrassingly parallel problems are the easiest kind to implement concurrently and enjoy performance that scales linearly with the amount of parallelism.
Let’s execute all these operations in parallel, thereby hiding the latency of the file I/O and using multiple CPUs for the image-scaling computations. Our first attempt at a concurrent version just adds a go keyword. We’ll ignore errors for now and address them later.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// NOTE: incorrect! func makeThumbnails2(filenames []string) { for _, f := range filenames {go thumbnail.ImageFile(f) // NOTE: ignoring errors }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version runs really fast—too fast, in fact, since it takes less time than the original, even when the slice of file names contains only a single element. If there’s no parallelism, how can the concurrent version possibly run faster? The answer is that makeThumbnails returns before it has finished doing what it was supposed to do. It starts all the goroutines, one per file name, but doesn’t wait for them to finish.&lt;/p&gt;

&lt;p&gt;There is no direct way to wait until a goroutine has finished, but we can change the inner goroutine to report its completion to the outer goroutine by sending an event on a shared channel. Since we know that there are exactly len(filenames) inner goroutines, the outer goroutine need only count that many events before it returns:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// makeThumbnails3 makes thumbnails of the specified 
files in parallel. 
func makeThumbnails3(filenames []string) { 
ch := make(chan struct{}) 
for _, f := range filenames {
go func(f string) {
thumbnail.ImageFile(f) // NOTE: ignoring 
errors 
ch &amp;lt;-struct{}{} 
}(f) 
} 

// Wait for goroutines to complete. 
for range filenames {
&amp;lt;-ch 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we passed the value of f as an explicit argument to the literal function instead of using the declaration of f from the enclosing for loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for _, f := range filenames {
go func() {
thumbnail.ImageFile(f) // NOTE: incorrect! 
// ... 
}() } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Recall the problem of loop variable capture inside an anonymous function, described in Section 5.6.1. Above, the single variable f is shared by all the anonymous function values and updated by successive loop iterations. By the time the new goroutines start executing the literal function, the for loop may have updated f and started another iteration or (more likely) finished entirely, so when these goroutines read the value of f, they all observe it to have the value of the final element of the slice. By adding an explicit parameter, we ensure that we use the value of f that is current when the go statement is executed.
What if we want to return values from each worker goroutine to the main one? If the call to thumbnail.ImageFile fails to create a file, it returns an error. The next version of makeThumbnails returns the first error it receives from any of the scaling operations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// makeThumbnails4 makes thumbnails for the specified 
files in parallel. 
// It returns an error if any step failed. 
func makeThumbnails4(filenames []string) error {
errors := make(chan error) 

for _, f := range filenames {
go func(f string) { _, err := thumbnail.ImageFile(f) errors &amp;lt;-err 
}(f) 
} 

for range filenames {if err := &amp;lt;-errors; err != nil {return err // NOTE: incorrect: goroutine leak! }} 
return nil 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function has a subtle bug. When it encounters the first non-nil error, it returns the error to the caller, leaving no goroutine draining the errors channel. Each remaining worker goroutine will block forever when it tries to send a value on that channel, and will never terminate. This situation, a goroutine leak (§8.4.4), may cause the whole program to get stuck or to run out of memory.&lt;/p&gt;

&lt;p&gt;The simplest solution is to use a buffered channel with sufficient capacity that no worker goroutine will block when it sends a message. (An alternative solution is to create another goroutine to drain the channel while the main goroutine returns the first error without delay.)&lt;/p&gt;

&lt;p&gt;The next version of makeThumbnails uses a buffered channel to return the names of the generated image files along with any errors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// makeThumbnails5 makes thumbnails for the specified 
files in parallel. 
// It returns the generated file names in an arbitrary 
order, 

// or an error if any step failed. func makeThumbnails5(filenames []string) (thumbfiles []string, err error) { 
type item struct {
thumbfile string 
err error 

} 
ch := make(chan item, len(filenames)) 
for _, f := range filenames {

go func(f string) { 
var it item 
it.thumbfile, it.err = 

thumbnail.ImageFile(f)
ch &amp;lt;-it 
}(f) 
} 

for     range filenames {
it := &amp;lt;-ch 
if it.err != nil {

return nil, it.err }thumbfiles = append(thumbfiles, it.thumbfile) 
} 
return thumbfiles, nil 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our final version of makeThumbnails, below, returns the total number of bytes occupied by the new files. Unlike the previous versions, however, it receives the file names not as a slice but over a channel of strings, so we cannot predict the number of loop iterations.&lt;/p&gt;

&lt;p&gt;To know when the last goroutine has finished (which may not be the last one to start), we need to increment a counter before each goroutine starts and decrement it as each goroutine finishes. This demands a special kind of counter, one that can be safely manipulated from multiple goroutines and that provides a way to wait until it becomes zero. This counter type is known as sync.WaitGroup, and the code below shows how to use it: ```go
// makeThumbnails6 makes thumbnails for each file
received from the channel.
// It returns the number of bytes occupied by the
files it creates.
func makeThumbnails6(filenames &amp;lt;-chan string) int64 {&lt;/p&gt;

&lt;p&gt;sizes := make(chan int64)
var wg sync.WaitGroup // number of working
goroutines&lt;/p&gt;

&lt;p&gt;for     f := range filenames {
wg.Add(1)
// worker
go func(f string) {&lt;/p&gt;

&lt;p&gt;defer wg.Done()
thumb, err := thumbnail.ImageFile(f)
if err != nil {&lt;/p&gt;

&lt;p&gt;log.Println(err)
return }info, _ := os.Stat(thumb) // OK to ignore
error
sizes &amp;lt;-info.Size()
}(f)
}&lt;/p&gt;

&lt;p&gt;// closer
go func() {
wg.Wait()
close(sizes)&lt;/p&gt;

&lt;p&gt;}()
var total int64
for size := range sizes {&lt;/p&gt;

&lt;p&gt;total += size
}
return total&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Note the asymmetry in the Add and Done methods. Add, which increments the counter, must be called before the worker goroutine starts, not within it; otherwise we would not be sure that the Add happens before the “closer” goroutine calls Wait. Also, Add takes a parameter, but Done does not; it’s equivalent to Add(-1). We use defer to ensure that the counter is decremented even in the error case. The structure of the code above is a common and idiomatic pattern for looping in parallel when we don’t know the number of iterations. 

The sizes channel carries each file size back to the main goroutine, which receives them using a range loop and computes the sum. Observe how we create a closer goroutine that waits for the workers to finish before closing the sizes channel. These two operations, wait and close, must be concurrent with the loop over sizes. Consider the alternatives: if the wait operation were placed in the main goroutine before the loop, it would never end, and if placed after the loop, it would be unreachable since with nothing closing the channel, the loop would never terminate. 


Figure 8.5 illustrates the sequence of events in the makeThumbnails6 function. 

The vertical lines represent goroutines. The thin segments indicate sleep, the thick 
segments activity. The diagonal arrows indicate events that synchronize one goroutine 

with another. Time flows down. Notice how the main goroutine spends most of its time in the range loop asleep, waiting for a worker to send a value or the closer to close the channel. 

Exercise 8.4: Modify the reverb2 server to use a sync.WaitGroup per connection to count the number of active echo goroutines. When it falls to zero, close the write half of the TCP connection as described in Exercise 8.3. Verify that your modified netcat3 client from that exercise waits for the final echoes of multiple concurrent shouts, even after the standard input has been closed. 

Exercise 8.5: Take an existing CPU-bound sequential program, such as the Mandelbrot program of Section 3.3 or the 3-D surface computation of Section 3.2, and execute its main loop in parallel using channels for communication. How much faster does it run on a multiprocessor machine? What is the optimal number of goroutines to use? 

## Example: Concurrent Web Crawler 

In Section 5.6, we made a simple web crawler that explored the link graph of the web in breadth-first order. In this section, we’ll make it concurrent so that independent calls to crawl can exploit the I/O parallelism available in the web. The crawl function remains exactly as it was in // gopl.io/ch5/findlinks3: 

```go
// gopl.io/ch8/crawl1 
func crawl(url string) []string {
fmt.Println(url)
list, err := links.Extract(url) 
if err != nil {

log.Print(err) 
}
return list 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main function resembles breadthFirst (§5.6). As before, a worklist records the queue of items that need processing, each item being a list of URLs to crawl, but this time, instead of representing the queue using a slice, we use a channel. Each call to crawl occurs in its own goroutine and sends the links it discovers back to the worklist.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
worklist := make(chan []string) 

// Start with the command-line arguments. go func() { worklist &amp;lt;-os.Args[1:] }() 
// Crawl the web concurrently. 
seen := make(map[string]bool) 
for list := range worklist {

for     _, link := range list {if !seen[link] { 
seen[link] = true 
go func(link string) { 
worklist &amp;lt;-crawl(link) 
}(link) 
}
}
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the crawl goroutine takes link as an explicit parameter to avoid the problem of loop variable capture we first saw in Section 5.6.1. Also notice that the initial send of the command-line arguments to the worklist must run in its own goroutine to avoid deadlock, a stuck situation in which both the main goroutine and a crawler goroutine attempt to send to each other while neither is receiving. An alternative solution would be to use a buffered channel.&lt;/p&gt;

&lt;p&gt;The crawler is now highly concurrent and prints a storm of URLs, but it has two problems. The first problem manifests itself as error messages in the log after a few seconds of operation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch8/crawl1 
$ ./crawl1 http://gopl.io/
http://gopl.io/
https://golang.org/help/ 

https://golang.org/doc/
https://golang.org/blog/ 
... 
2015/07/15 18:22:12 Get ...: dial tcp: lookup 
blog.golang.org: no such host 
2015/07/15 18:22:12 Get ...: dial tcp 

23.21.222.120:443: socket: 
too many open files 
... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The initial error message is a surprising report of a DNS lookup failure for a reliable domain. The subsequent error message reveals the cause: the program created so many network connections at once that it exceeded the per-process limit on the number of open files, causing operations such as DNS lookups and calls to net.Dial to start failing.&lt;/p&gt;

&lt;p&gt;The program is too parallel. Unbounded parallelism is rarely a good idea since there is always a limiting factor in the system, such as the number of CPU cores for compute-bound workloads, the number of spindles and heads for local disk I/O operations, the bandwidth of the network for streaming downloads, or the serving capacity of a web service. The solution is to limit the number of parallel uses of the resource to match the level of parallelism that is available. A simple way to do that in our example is to ensure that no more than n calls to links.Extract are active at once, where n is comfortably less than the file descriptor limit—20, say. This is analogous to the way a doorman at a crowded nightclub admits a guest only when some other guest leaves.&lt;/p&gt;

&lt;p&gt;We can limit parallelism using a buffered channel of capacity n to model a concurrency primitive called a counting semaphore. Conceptually, each of the n vacant slots in the channel buffer represents a token entitling the holder to proceed. Sending a value into the channel acquires a token, and receiving a value from the channel releases a token, creating a new vacant slot. This ensures that at most n sends can occur without an intervening receive. (Although it might be more intuitive to treat filled slots in the channel buffer as tokens, using vacant slots avoids the need to fill the channel buffer after creating it.) Since the channel element type is not important, we’ll use struct{}, which has size zero.
Let’s rewrite the crawl function so that the call to links.Extract is bracketed by operations to acquire and release a token, thus ensuring that at most 20 calls to it are active at one time. It’s good practice to keep the semaphore operations as close as possible to the I/O operation they regulate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch8/crawl2 
// tokens is a counting semaphore used to 
// enforce a limit of 20 concurrent requests. 
var tokens = make(chan struct{}, 20) 
func crawl(url string) []string {
fmt.Println(url)
tokens &amp;lt;-struct{}{} // acquire a token 
list, err := links.Extract(url) 
&amp;lt;-tokens // release the token 

if err != nil {
log.Print(err) 
}
return list 

} 

The second problem is that the program never terminates, even when it has discovered all the links reachable from the initial URLs. (Of course, you’re unlikely to notice this problem unless you choose the initial URLs carefully or implement the depth-limiting feature of Exercise 8.6.) For the program to terminate, we need to break out of the main loop when the worklist is empty and no crawl goroutines are active. 

```go
func main() {worklist := make(chan []string) var n int // number of pending sends to worklist 
// Start with the command-line arguments. 
n++ 
go func() { worklist &amp;lt;-os.Args[1:] }() 

// Crawl the web concurrently. 
seen := make(map[string]bool) 
for ; n &amp;gt; 0; n--{

list := &amp;lt;-worklist for _, link := range list {
if !seen[link] {seen[link] = true n++ go func(link string) { 
worklist &amp;lt;-crawl(link) 
}(link) 
}
}
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this version, the counter n keeps track of the number of sends to the worklist that are yet to occur. Each time we know that an item needs to be sent to the worklist, we increment n, once before we send the initial command-line arguments, and again each time we start a crawler goroutine. The main loop terminates when n falls to zero, since there is no more work to be done.&lt;/p&gt;

&lt;p&gt;Now the concurrent crawler runs about 20 times faster than the breadth-first crawler from Section 5.6, without errors, and terminates correctly if it should complete its task.&lt;/p&gt;

&lt;p&gt;The program below shows an alternative solution to the problem of excessive concurrency. This version uses the original crawl function that has no counting semaphore, but calls it from one of 20 long-lived crawler goroutines, thus ensuring that at most 20 HTTP requests are active concurrently.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch8/crawl3 
func main() {worklist := make(chan []string) // lists of URLs, may have duplicatesunseenLinks := make(chan string) // de-duplicated URLs 
// Add command-line arguments to worklist. 
go func() { worklist &amp;lt;-os.Args[1:] }() 
// Create 20 crawler goroutines to fetch each 
unseen link. 
for i := 0; i &amp;lt; 20; i++ {
go func() {
for link := range unseenLinks {
foundLinks := crawl(link) 
go func() { worklist &amp;lt;-foundLinks }() }}() } 
// The main goroutine de-duplicates worklist items 
// and sends the unseen ones to the crawlers. 
seen := make(map[string]bool) for list := range worklist {
for _, link := range list {
if !seen[link] {
seen[link] = true 
unseenLinks &amp;lt;-link 
}}}} 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The crawler goroutines are all fed by the same channel, unseenLinks. The main goroutine is responsible for de-duplicating items it receives from the worklist, and then sending each unseen one over the unseenLinks channel to a crawler goroutine.&lt;/p&gt;

&lt;p&gt;The seen map is confined within the main goroutine; that is, it can be accessed only by that goroutine. Like other forms of information hiding, confinement helps us reason about the correctness of a program. For example, local variables cannot be mentioned by name from outside the function in which they are declared; variables that do not escape (§2.3.4) from a function cannot be accessed from outside that function; and encapsulated fields of an object cannot be accessed except by the methods of that object. In all cases, information hiding helps to limit unintended interactions between parts of the program.
Links found by crawl are sent to the worklist from a dedicated goroutine to avoid deadlock.&lt;/p&gt;

&lt;p&gt;To save space, we have not addressed the problem of termination in this example.&lt;/p&gt;

&lt;p&gt;Exercise 8.6: Add depth-limiting to the concurrent crawler. That is, if the user sets ­depth=3, then only URLs reachable by at most three links will be fetched.&lt;/p&gt;

&lt;p&gt;Exercise 8.7: Write a concurrent program that creates a local mirror of a web site, fetching each reachable page and writing it to a directory on the local disk. Only pages within the original domain (for instance, golang.org) should be fetched. URLs within mirrored pages should be altered as needed so that they refer to the mirrored page, not the original.&lt;/p&gt;

&lt;h2 id=&#34;multiplexing-with-select:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Multiplexing with select&lt;/h2&gt;

&lt;p&gt;The program below does the countdown for a rocket launch. The time.Tick function returns a channel on which it sends events periodically, acting like a metronome. The value of each event is a timestamp, but it is rarely as interesting as the fact of its delivery.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch8/countdown1 
func main() {
fmt.Println(&amp;quot;Commencing countdown.&amp;quot;) 
tick := time.Tick(1 * time.Second) 
for countdown := 10; countdown &amp;gt; 0; countdown--{
fmt.Println(countdown)
&amp;lt;-tick 
}
launch() } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let’s add the ability to abort the launch sequence by pressing the return key during the countdown. First, we start a goroutine that tries to read a single byte from the standard input and, if it succeeds, sends a value on a channel called abort.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch8/countdown2 
abort := make(chan struct{}) go func() {os.Stdin.Read(make([]byte, 1)) // read a single byteabort &amp;lt;-struct{}{} }() 

Now each iteration of the countdown loop needs to wait for an event to arrive on one of the two channels: the ticker channel if everything is fine (“nominal” in NASA jargon) or an abort event if there was an “anomaly.” We can’t just receive from each channel because whichever operation we try first will block until completion. We need to multiplex these operations, and to do that, we need a select statement. 
select {
case &amp;lt;-ch1: 
// ... 
case x := &amp;lt;-ch2: 
// ...use x... 
case ch3 &amp;lt;-y: 
// ... 
default: 
// ... 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The general form of a select statement is shown above. Like a switch statement, it has a number of cases and an optional default. Each case specifies a communication (a send or receive operation on some channel) and an associated block of statements. A receive expression may appear on its own, as in the first case, or within a short variable declaration, as in the second case; the second form lets you refer to the received value.&lt;/p&gt;

&lt;p&gt;A select waits until a communication for some case is ready to proceed. It then performs that communication and executes the case’s associated statements; the other communications do not happen. A select with no cases, select{}, waits forever.
Let’s return to our rocket launch program. The time.After function immediately returns a channel, and starts a new goroutine that sends a single value on that channel after the specified time. The select statement below waits until the first of two events arrives, either an abort event or the event indicating that 10 seconds have elapsed. If 10 seconds go by with no abort, the launch proceeds.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
// ...create abort channel... 

fmt.Println(&amp;quot;Commencing countdown. Press return 
to abort.&amp;quot;)
select {
case &amp;lt;-time.After(10 * time.Second): 
// Do nothing. 
case &amp;lt;-abort: fmt.Println(&amp;quot;Launch aborted!&amp;quot;) return 
}launch() } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example below is more subtle. The channel ch, whose buffer size is 1, is alternately empty then full, so only one of the cases can proceed, either the send when i is even, or the receive when i is odd. It always prints 02468 .&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := make(chan int, 1) 
for     i := 0; i &amp;lt; 10; i++ {select {case x := &amp;lt;-ch: 
fmt.Println(x) // &amp;quot;0&amp;quot; &amp;quot;2&amp;quot; &amp;quot;4&amp;quot; &amp;quot;6&amp;quot; &amp;quot;8&amp;quot; case ch &amp;lt;-i: }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If multiple cases are ready, select picks one at random, which ensures that every channel has an equal chance of being selected. Increasing the buffer size of the previous example makes its output nondeterministic, because when the buffer is neither full nor empty, the select statement figuratively tosses a coin.
Let’s make our launch program print the countdown. The select statement below causes each iteration of the loop to wait up to 1 second for an abort, but no longer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch8/countdown3  
func main() {// ...create  abort  channel...  
to  fmt.Println(&amp;quot;Commencing countdown. abort.&amp;quot;)tick := time.Tick(1 * time.Second) for countdown := 10; countdown &amp;gt; 0; fmt.Println(countdown)  Press return countdown-­{  

select {
case &amp;lt;-tick: 
// Do nothing. 
case &amp;lt;-abort: 
fmt.Println(&amp;quot;Launch aborted!&amp;quot;) 
return 
}}
launch() } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The time.Tick function behaves as if it creates a goroutine that calls time.Sleep in a loop, sending an event each time it wakes up. When the countdown function above returns, it stops receiving events from tick, but the ticker goroutine is still there, trying in vain to send on a channel from which no goroutine is receiving—a goroutine leak (§8.4.4).&lt;/p&gt;

&lt;p&gt;The Tick function is convenient, but it’s appropriate only when the ticks will be needed throughout the lifetime of the application. Otherwise, we should use this pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ticker := time.NewTicker(1 * time.Second) 
&amp;lt;-ticker.C // receive from the ticker&#39;s channel 
ticker.Stop() // cause the ticker&#39;s goroutine to 
terminate 
Sometimes we want to try to send or receive on a channel but avoid blocking if the channel is not ready—a non-blocking communication. A select statement can do that too. A select may have a default, which specifies what to do when none of the other communications can proceed immediately. 

The select statement below receives a value from the abort channel if there is one to receive; otherwise it does nothing. This is a non-blocking receive operation; doing it repeatedly is called polling a channel. 

```go
select { case &amp;lt;-abort: 
fmt.Printf(&amp;quot;Launch aborted!\n&amp;quot;) 
return 
default: 
// do nothing } 

The zero value for a channel is nil. Perhaps surprisingly, nil channels are sometimes useful. Because send and receive operations on a nil channel block forever, a case in a select statement whose channel is nil is never selected. This lets us use nil to enable or disable cases that correspond to features like handling timeouts or cancellation, responding to other input events, or emitting output. We’ll see an example in the next section. 

Exercise 8.8: Using a select statement, add a timeout to the echo server from Section 8.3 so that it disconnects any client that shouts nothing within 10 seconds. 

## Example: Concurrent Directory Traversal 
In this section, we’ll build a program that reports the disk usage of one or more directories specified on the command line, like the Unix du command. Most of its work is done by the walkDir function below, which enumerates the entries of the directory dir using the dirents helper function. 

```go
// gopl.io/ch8/du1 
// walkDir recursively walks the file tree rooted at 
dir 
// and sends the size of each found file on fileSizes. 
func walkDir(dir string, fileSizes chan&amp;lt;-int64) { 

for _, entry := range dirents(dir) { 
if entry.IsDir() {subdir := filepath.Join(dir, entry.Name()) walkDir(subdir, fileSizes) 
} else {
fileSizes &amp;lt;-entry.Size() 
}
}
} 

// dirents returns the entries of directory dir. 
func dirents(dir string) []os.FileInfo {
entries, err := ioutil.ReadDir(dir) 
if err != nil {

fmt.Fprintf(os.Stderr, &amp;quot;du1: %v\n&amp;quot;, err) 
return nil 
}
return entries 

} 

The ioutil.ReadDir function returns a slice of os.FileInfo—the same information that a call to os.Stat returns for a single file. For each subdirectory, walkDir recursively calls itself, and for each file, walkDir sends a message on the fileSizes channel. The message is the size of the file in bytes. 

The main function, shown below, uses two goroutines. The background goroutine calls walkDir for each directory specified on the command line and finally closes the fileSizes channel. The main goroutine computes the sum of the file sizes it receives from the channel and finally prints the total. 

```go
// The du1 command computes the disk usage of the 
files in a directory. 
package main 

import (
&amp;quot;flag&amp;quot;
&amp;quot;fmt&amp;quot; 
&amp;quot;io/ioutil&amp;quot;
&amp;quot;os&amp;quot; 
&amp;quot;path/filepath&amp;quot; 

) 
func main() {
// Determine the initial directories. 
flag.Parse()
roots := flag.Args() 
if len(roots) == 0 {

roots = []string{&amp;quot;.&amp;quot;} 
} 

// Traverse the file tree. 
fileSizes := make(chan int64) 
go func() {

for _, root := range roots {
walkDir(root, fileSizes) }close(fileSizes) }() 
// Print the results. 
var nfiles, nbytes int64 
for size := range fileSizes {
nfiles++ 
nbytes += size }
printDiskUsage(nfiles, nbytes) } 
func printDiskUsage(nfiles, nbytes int64) { 
fmt.Printf(&amp;quot;%d files %.1f GB\n&amp;quot;, nfiles, 
float64(nbytes)/1e9)
} 
This program pauses for a long while before printing its result: 
$ go build gopl.io/ch8/du1 
$ ./du1 $HOME /usr /bin /etc 
213201 files 62.7 GB 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The program would be nicer if it kept us informed of its progress. However, simply moving the printDiskUsage call into the loop would cause it to print thousands of lines of output.&lt;/p&gt;

&lt;p&gt;The variant of du below prints the totals periodically, but only if the -v flag is specified since not all users will want to see progress messages. The background goroutine that loops over roots remains unchanged. The main goroutine now uses a ticker to generate events every 500ms, and a select statement to wait for either a file size message, in which case it updates the totals, or a tick event, in which case it prints the current totals. If the -v flag is not specified, the tick channel remains nil, and its case in the select is effectively disabled.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch8/du2 
var verbose = flag.Bool(&amp;quot;v&amp;quot;, false, &amp;quot;show verbose 
progress messages&amp;quot;) 
func main() {
// ...start background goroutine... 

// Print the results periodically. 
var tick &amp;lt;-chan time.Time 

if *verbose {
tick = time.Tick(500 * time.Millisecond) }var nfiles, nbytes int64 loop:
for     {select {case size, ok := &amp;lt;-fileSizes: 
if !ok {
break loop // fileSizes was closed }nfiles++ nbytes += size 
case &amp;lt;-tick: printDiskUsage(nfiles, nbytes) 
}}printDiskUsage(nfiles, nbytes) // final totals } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the program no longer uses a range loop, the first select case must explicitly test whether the fileSizes channel has been closed, using the two-result form of receive operation. If the channel has been closed, the program breaks out of the loop. The labeled break statement breaks out of both the select and the for loop; an unlabeled break would break out of only the select, causing the loop to begin the next iteration.&lt;/p&gt;

&lt;p&gt;The program now gives us a leisurely stream of updates:
$ go build gopl.io/ch8/du2 $ ./du2 -v $HOME /usr /bin /etc
28608  files  8.3 GB&lt;br /&gt;
54147  files  10.3  GB&lt;br /&gt;
93591  files  15.1  GB&lt;br /&gt;
127169  files  52.9  GB&lt;br /&gt;
175931  files  62.2  GB&lt;br /&gt;
213201  files  62.7  GB&lt;/p&gt;

&lt;p&gt;However, it still takes too long to finish. There’s no reason why all the calls to
walkDir can’t be done concurrently, thereby exploiting parallelism in the disk&lt;/p&gt;

&lt;p&gt;system. The third version of du, below, creates a new goroutine for each call to walkDir. It uses a sync.WaitGroup (§8.5) to count the number of calls to walkDir that are still active, and a closer goroutine to close the fileSizes channel when the counter drops to zero.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch8/du3 
func main() {
// ...determine roots... 

// Traverse each root of the file tree in 
parallel.
fileSizes := make(chan int64) 
var n sync.WaitGroup 
for _, root := range roots {

n.Add(1)
go walkDir(root, &amp;amp;n, fileSizes) 
}
go func() {

n.Wait()
close(fileSizes) 
}()
// ...select loop... 

} 

```go
func walkDir(dir string, n *sync.WaitGroup, fileSizes 
chan&amp;lt;-int64) {
defer n.Done() 
for _, entry := range dirents(dir) { 

if entry.IsDir() {n.Add(1)subdir := filepath.Join(dir, entry.Name()) go walkDir(subdir, n, fileSizes) 
} else {
fileSizes &amp;lt;-entry.Size() 
}
} 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since this program creates many thousands of goroutines at its peak, we have to change dirents to use a counting semaphore to prevent it from opening too many files at once, just as we did for the web crawler in Section 8.6:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// sema is a counting semaphore for limiting 
concurrency in dirents. 
var sema = make(chan struct{}, 20) 

// dirents returns the entries of directory dir. 
func dirents(dir string) []os.FileInfo {
sema &amp;lt;-struct{}{} // acquire token 
defer func() { &amp;lt;-sema }() // release token 
// ... 

This version runs several times faster than the previous one, though there is a lot of variability from system to system. 

Exercise 8.9: Write a version of du that computes and periodically displays separate totals for each of the root directories. 

## Cancellation 
Sometimes we need to instruct a goroutine to stop what it is doing, for example, in a web server performing a computation on behalf of a client that has disconnected. 

There is no way for one goroutine to terminate another directly, since that would leave all its shared variables in undefined states. In the rocket launch program (§8.7) we sent a single value on a channel named abort, which the countdown goroutine interpreted as a request to stop itself. But what if we need to cancel two goroutines, or an arbitrary number? 

One possibility might be to send as many events on the abort channel as there are goroutines to cancel. If some of the goroutines have already terminated themselves, however, our count will be too large, and our sends will get stuck. On the other hand, if those goroutines have spawned other goroutines, our count will be too small, and some goroutines will remain unaware of the cancellation. In general, it’s hard to know how many goroutines are working on our behalf at any given moment. Moreover, when a goroutine receives a value from the abort channel, it consumes that value so that other goroutines won’t see it. For cancellation, what we need is a reliable mechanism to broadcast an event over a channel so that many goroutines can see it as it occurs and can later see that it has occurred. 
Recall that after a channel has been closed and drained of all sent values, subsequent receive operations proceed immediately, yielding zero values. We can exploit this to create a broadcast mechanism: don’t send a value on the channel, close it. 

We can add cancellation to the du program from the previous section with a few simple changes. First, we create a cancellation channel on which no values are ever sent, but whose closure indicates that it is time for the program to stop what it is doing. We also define a utility function, cancelled, that checks or polls the cancellation state at the instant it is called. 

```go
// gopl.io/ch8/du4 
var done = make(chan struct{}) 
func cancelled() bool {
select { 

case &amp;lt;-done: 
return true 
default: 
return false 
}
} 

Next, we create a goroutine that will read from the standard input, which is typically connected to the terminal. As soon as any input is read (for instance, the user presses the return key), this goroutine broadcasts the cancellation by closing the done channel. 

```go
// Cancel traversal when input is detected. go func() {os.Stdin.Read(make([]byte, 1)) // read a single byteclose(done) }() 

Now we need to make our goroutines respond to the cancellation. In the main goroutine, we add a third case to the select statement that tries to receive from the done channel. The function returns if this case is ever selected, but before it returns it must first drain the fileSizes channel, discarding all values until the channel is closed. It does this to ensure that any active calls to walkDir can run to completion without getting stuck sending to fileSizes. 

```go
for     {
select {
case &amp;lt;-done: 

// Drain fileSizes to allow existing 
goroutines to finish. 
for range fileSizes {

// Do nothing. 
}
return 


case size, ok := &amp;lt;-fileSizes: 
// ... 

}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The walkDir goroutine polls the cancellation status when it begins, and returns without doing anything if the status is set. This turns all goroutines created after cancellation into no-ops:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func walkDir(dir string, n *sync.WaitGroup, fileSizes 
chan&amp;lt;-int64) {
defer n.Done() 
if cancelled() {

return 
}
for _, entry := range dirents(dir) { 

// ... 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It might be profitable to poll the cancellation status again within walkDir’s loop, to avoid creating goroutines after the cancellation event. Cancellation involves a trade-off; a quicker response often requires more intrusive changes to program logic. Ensuring that no expensive operations ever occur after the cancellation event may require updating many places in your code, but often most of the benefit can be obtained by checking for cancellation in a few important places.&lt;/p&gt;

&lt;p&gt;A little profiling of this program revealed that the bottleneck was the acquisition of a semaphore token in dirents. The select below makes this operation cancellable and reduces the typical cancellation latency of the program from hundreds of milliseconds to tens:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func dirents(dir string) []os.FileInfo {
select {
case sema &amp;lt;-struct{}{}: // acquire token 
case &amp;lt;-done: 

return nil // cancelled }defer func() { &amp;lt;-sema }() // release token 
// ...read directory... 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, when cancellation occurs, all the background goroutines quickly stop and the main function returns. Of course, when main returns, a program exits, so it can be hard to tell a main function that cleans up after itself from one that does not. There’s a handy trick we can use during testing: if instead of returning from main in the event of cancellation, we execute a call to panic, then the runtime will dump the stack of every goroutine in the program.&lt;/p&gt;

&lt;p&gt;If the main goroutine is the only one left, then it has cleaned up after itself. But if other goroutines remain, they may not have been properly cancelled, or perhaps they have been cancelled but the cancellation takes time; a little investigation may be worthwhile. The panic dump often contains sufficient information to distinguish these cases.&lt;/p&gt;

&lt;p&gt;Exercise 8.10: HTTP requests may be cancelled by closing the optional Cancel channel in the http.Request struct. Modify the web crawler of Section 8.6 to support cancellation.
Hint: the http.Get convenience function does not give you an opportunity to customize a Request. Instead, create the request using http.NewRequest, set its Cancel field, then perform the request by calling http.DefaultClient.Do(req).&lt;/p&gt;

&lt;p&gt;Exercise 8.11: Following the approach of mirroredQuery in Section 8.4.4, implement a variant of fetch that requests several URLs concurrently. As soon as the first response arrives, cancel the other requests.
8.10 Example: Chat Server&lt;/p&gt;

&lt;p&gt;We’ll finish this chapter with a chat server that lets several users broadcast textual messages to each other. There are four kinds of goroutine in this program. There is one instance apiece of the main and broadcaster goroutines, and for each client connection there is one handleConn and one clientWriter goroutine. The broadcaster is a good illustration of how select is used, since it has to respond to three different kinds of messages.&lt;/p&gt;

&lt;p&gt;The job of the main goroutine, shown below, is to listen for and accept incoming network connections from clients. For each one, it creates a new handleConn goroutine, just as in the concurrent echo server we saw at the start of this chapter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch8/chat 
func main() {
listener, err := net.Listen(&amp;quot;tcp&amp;quot;, 
&amp;quot;localhost:8000&amp;quot;)
if err != nil {
log.Fatal(err) 
} 

go broadcaster() 
for {conn, err := listener.Accept() 
if err != nil {
log.Print(err)
continue 
}
go handleConn(conn) }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next is the broadcaster. Its local variable clients records the current set of connected clients. The only information recorded about each client is the identity of its outgoing message channel, about which more later.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type client chan&amp;lt;-string // an outgoing message 
channel 

var     (
entering = make(chan client) 
leaving = make(chan client) 
messages = make(chan string) // all incoming 

client messages 
) 

func broadcaster() {clients := make(map[client]bool) // all connected clients 
for     {
select {
case msg := &amp;lt;-messages: 

// Broadcast incoming message to all // clients&#39; outgoing message channels. for cli := range clients {
cli &amp;lt;-msg 
} 

case cli := &amp;lt;-entering:
clients[cli] = true 

case cli := &amp;lt;-leaving:
delete(clients, cli) 
close(cli) 

}
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The broadcaster listens on the global entering and leaving channels for announcements of arriving and departing clients. When it receives one of these events, it updates the clients set, and if the event was a departure, it closes the client’s outgoing message channel. The broadcaster also listens for events on the global messages channel, to which each client sends all its incoming messages. When the broadcaster receives one of these events, it broadcasts the message to every connected client.&lt;/p&gt;

&lt;p&gt;Now let’s look at the per-client goroutines. The handleConn function creates a new outgoing message channel for its client and announces the arrival of this client to the broadcaster over the entering channel. Then it reads every line of text from the client, sending each line to the broadcaster over the global incoming message channel, prefixing each message with the identity of its sender. Once there is nothing more to read from the client, handleConn announces the departure of the client over the leaving channel and closes the connection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func handleConn(conn net.Conn) { 
ch := make(chan string) // outgoing client 
messages
go clientWriter(conn, ch) 

who := conn.RemoteAddr().String() 
ch &amp;lt;-&amp;quot;You are &amp;quot; + who 
messages &amp;lt;-who + &amp;quot; has arrived&amp;quot; 
entering &amp;lt;-ch 

input := bufio.NewScanner(conn) 
for input.Scan() {

messages &amp;lt;-who + &amp;quot;: &amp;quot; + input.Text() }// NOTE: ignoring potential errors from 
input.Err() 
leaving &amp;lt;-ch 
messages &amp;lt;-who + &amp;quot; has left&amp;quot; 
conn.Close() 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;func clientWriter(conn net.Conn, ch &amp;lt;-chan string) { for msg := range ch {fmt.Fprintln(conn, msg) // NOTE: ignoring network errors }}&lt;/p&gt;

&lt;p&gt;In addition, handleConn creates a clientWriter goroutine for each client that receives messages broadcast to the client’s outgoing message channel and writes them to the client’s network connection. The client writer’s loop terminates when the broadcaster closes the channel after receiving a leaving notification.&lt;/p&gt;

&lt;p&gt;The display below shows the server in action with two clients in separate windows on the same computer, using netcat to chat:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch8/chat $ go build gopl.io/ch8/netcat3 $ ./chat &amp;amp; $ ./netcat3You are 127.0.0.1:64208 $ ./netcat3 127.0.0.1:64211 has arrived You are 127.0.0.1:64211 Hi! 127.0.0.1:64208: Hi! 127.0.0.1:64208: Hi! 
Hi yourself. 127.0.0.1:64211: Hi yourself. 127.0.0.1:64211: Hi yourself. ^C 
127.0.0.1:64208 has left $ ./netcat3You are 127.0.0.1:64216 127.0.0.1:64216 has arrived 
Welcome. 127.0.0.1:64211: Welcome. 127.0.0.1:64211: Welcome. 
^C 
127.0.0.1:64211 has left 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While hosting a chat session for n clients, this program runs 2n+2 concurrently communicating goroutines, yet it needs no explicit locking operations (§9.2). The clients map is confined to a single goroutine, the broadcaster, so it cannot be accessed concurrently. The only variables that are shared by multiple goroutines are channels and instances of net.Conn, both of which are concurrency safe. We’ll talk more about confinement, concurrency safety, and the implications of sharing variables across goroutines in the next chapter.&lt;/p&gt;

&lt;p&gt;Exercise 8.12: Make the broadcaster announce the current set of clients to each new arrival. This requires that the clients set and the entering and leaving channels record the client name too.&lt;/p&gt;

&lt;p&gt;Exercise 8.13: Make the chat server disconnect idle clients, such as those that have sent no messages in the last five minutes. Hint: calling conn.Close() in another goroutine unblocks active Read calls such as the one done by input.Scan().&lt;/p&gt;

&lt;p&gt;Exercise 8.14: Change the chat server’s network protocol so that each client provides its name on entering. Use that name instead of the network address when prefixing each message with its sender’s identity.&lt;/p&gt;

&lt;p&gt;Exercise 8.15: Failure of any client program to read data in a timely manner ultimately causes all clients to get stuck. Modify the broadcaster to skip a message rather than wait if a client writer is not ready to accept it. Alternatively, add buffering to each client’s outgoing message channel so that most messages are not dropped; the broadcaster should use a non-blocking send to this channel.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Concurrency with Shared Variables&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In the previous chapter, we presented several programs that use goroutines and channels to express concurrency in a direct and natural way. However, in doing so, we glossed over a number of important and subtle issues that programmers must bear in mind when writing concurrent code.&lt;/p&gt;

&lt;p&gt;In this chapter, we’ll take a closer look at the mechanics of concurrency. In particular, we’ll point out some of the problems associated with sharing variables among multiple goroutines, the analytical techniques for recognizing those problems, and the patterns for solving them.
Finally, we’ll explain some of the technical differences between goroutines and operating system threads.&lt;/p&gt;

&lt;h2 id=&#34;race-conditions:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Race Conditions&lt;/h2&gt;

&lt;p&gt;In a sequential program, that is, a program with only one goroutine, the steps of the program happen in the familiar execution order determined by the program logic. For instance, in a sequence of statements, the first one happens before the second one, and so on. In a program with two or more goroutines, the steps within each goroutine happen in the familiar order, but in general we don’t know whether an event x in one goroutine happens before an event y in another goroutine, or happens after it, or is simultaneous with it. When we cannot confidently say that one event happens before the other, then the events x and y are concurrent.&lt;/p&gt;

&lt;p&gt;Consider a function that works correctly in a sequential program. That function is concurrency-safe if it continues to work correctly even when called concurrently, that is, from two or more goroutines with no additional synchronization. We can generalize this notion to a set of collaborating functions, such as the methods and operations of a particular type. A type is concurrency-safe if all its accessible methods and operations are concurrency-safe.&lt;/p&gt;

&lt;p&gt;We can make a program concurrency-safe without making every concrete type in that program concurrency-safe. Indeed, concurrency-safe types are the exception rather than the rule, so you should access a variable concurrently only if the documentation for its type says that this is safe. We avoid concurrent access to most variables either by confining them to a single goroutine or by maintaining a higher-level invariant of mutual exclusion. We’ll explain these terms in this chapter.&lt;/p&gt;

&lt;p&gt;In contrast, exported package-level functions are generally expected to be concurrency-safe. Since package-level variables cannot be confined to a single goroutine, functions that modify them must enforce mutual exclusion.&lt;/p&gt;

&lt;p&gt;There are many reasons a function might not work when called concurrently, including deadlock, livelock, and resource starvation. We don’t have space to discuss all of them, so we’ll focus on the most important one, the race condition.&lt;/p&gt;

&lt;p&gt;A race condition is a situation in which the program does not give the correct result for some interleavings of the operations of multiple goroutines. Race conditions are pernicious because they may remain latent in a program and appear infrequently, perhaps only under heavy load or when using certain compilers, platforms, or architectures. This makes them hard to reproduce and diagnose.&lt;/p&gt;

&lt;p&gt;It is traditional to explain the seriousness of race conditions through the metaphor of financial loss, so we’ll consider a simple bank account program.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Package bank implements a bank with only one 
account. 
package bank 
var balance int 
func Deposit(amount int) { balance = balance + amount 
} 
func Balance() int { return balance } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(We could have written the body of the Deposit function as balance += amount, which is equivalent, but the longer form will simplify the explanation.)&lt;/p&gt;

&lt;p&gt;For a program this trivial, we can see at a glance that any sequence of calls to Deposit and Balance will give the right answer, that is, Balance will report the sum of all amounts previously deposited. However, if we call these functions not in a sequence but concurrently, Balance is no longer guaranteed to give the right answer. Consider the following two goroutines, which represent two transactions on a joint bank account:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Alice: 
go func() {
bank.Deposit(200) // A1 
fmt.Println(&amp;quot;=&amp;quot;, bank.Balance()) // A2 }() 
// Bob: 
go bank.Deposit(100) // B 
Alice deposits $200, then checks her balance, while Bob deposits $100. Since the steps A1 and A2 occur concurrently with B, we cannot predict the order in which they happen. Intuitively, it might seem that there are only three possible orderings, which we’ll call “Alice first,” “Bob first,” and “Alice/Bob/Alice.” The following table shows the value of the balance variable after each step. The quoted strings represent the printed balance slips. 

```go
Alice first Bob first 
Alice/Bob/Alice
00 

A1 200 B 100 A1 200 A2 &amp;quot;= 200&amp;quot; A1 300 B 300 B 300 A2 &amp;quot;= 300&amp;quot; A2 &amp;quot;= 300&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In all cases the final balance is $300. The only variation is whether Alice’s balance slip includes Bob’s transaction or not, but the customers are satisfied either way.&lt;/p&gt;

&lt;p&gt;But this intuition is wrong. There is a fourth possible outcome, in which Bob’s deposit occurs in the middle of Alice’s deposit, after the balance has been read (balance + amount) but before it has been updated (balance = &amp;hellip; ), causing Bob’s transaction to disappear. This is because Alice’s deposit operation A1 is really a sequence of two operations, a read and a write; call them A1r and A1w. Here’s the problematic interleaving:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Data race 
0 
A1r 0 ... = balance + amount 
B 100 
A1w 200 balance = ... 
A2 &amp;quot;= 200&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After A1r, the expression balance + amount evaluates to 200, so this is the value written during A1w, despite the intervening deposit. The final balance is only $200. The bank is $100 richer at Bob’s expense.&lt;/p&gt;

&lt;p&gt;This program contains a particular kind of race condition called a data race. A data race occurs whenever two goroutines access the same variable concurrently and at least one of the accesses is a write.
Things get even messier if the data race involves a variable of a type that is larger than a single machine word, such as an interface, a string, or a slice. This code updates x concurrently to two slices of different lengths:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x []int 
go func() { x = make([]int, 10) }() 
go func() { x = make([]int, 1000000) }() 
x[999999] = 1 // NOTE: undefined behavior; memory 
corruption possible! 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The value of x in the final statement is not defined; it could be nil, or a slice of length 10, or a slice of length 1,000,000. But recall that there are three parts to a slice: the pointer, the length, and the capacity. If the pointer comes from the first call to make and the length comes from the second, x would be a chimera, a slice whose nominal length is 1,000,000 but whose underlying array has only 10 elements. In this eventuality, storing to element 999,999 would clobber an arbitrary faraway memory location, with consequences that are impossible to predict and hard to debug and localize. This semantic minefield is called undefined behavior and is well known to C programmers; fortunately it is rarely as troublesome in Go as in C.
Even the notion that a concurrent program is an interleaving of several sequential programs is a false intuition. As we’ll see in Section 9.4, data races may have even stranger outcomes. Many programmers—even some very clever ones—will occasionally offer justifications for known data races in their programs: “the cost of mutual exclusion is too high,” “this logic is only for logging,” “I don’t mind if I drop some messages,” and so on. The absence of problems on a given compiler and platform may give them false confidence. A good rule of thumb is that there is no such thing as a benign data race. So how do we avoid data races in our programs?&lt;/p&gt;

&lt;p&gt;We’ll repeat the definition, since it is so important: A data race occurs whenever two goroutines access the same variable concurrently and at least one of the accesses is a write. It follows from this definition that there are three ways to avoid a data race.&lt;/p&gt;

&lt;p&gt;The first way is not to write the variable. Consider the map below, which is lazily populated as each key is requested for the first time. If Icon is called sequentially, the program works fine, but if Icon is called concurrently, there is a data race accessing the map.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var     icons = make(map[string]image.Image) 
func loadIcon(name string) image.Image 
// NOTE: not concurrency-safe! 
func Icon(name string) image.Image {
icon, ok := icons[name] 
if !ok {

icon = loadIcon(name)
icons[name] = icon 
}
return icon 

} 

If instead we initialize the map with all necessary entries before creating additional goroutines and never modify it again, then any number of goroutines may safely call Icon concurrently since each only reads the map. 

```go
var     icons = map[string]image.Image{
&amp;quot;spades.png&amp;quot;: loadIcon(&amp;quot;spades.png&amp;quot;), 
&amp;quot;hearts.png&amp;quot;: loadIcon(&amp;quot;hearts.png&amp;quot;), 
&amp;quot;diamonds.png&amp;quot;: loadIcon(&amp;quot;diamonds.png&amp;quot;), 
&amp;quot;clubs.png&amp;quot;: loadIcon(&amp;quot;clubs.png&amp;quot;), 

} 
// Concurrency-safe.
func Icon(name string) image.Image { return 
icons[name] } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above, the icons variable is assigned during package initialization, which happens before the program’s main function starts running. Once initialized, icons is never modified. Data structures that are never modified or are immutable are inherently concurrency-safe and need no synchronization. But obviously we can’t use this approach if updates are essential, as with a bank account.&lt;/p&gt;

&lt;p&gt;The second way to avoid a data race is to avoid accessing the variable from multiple goroutines. This is the approach taken by many of the programs in the previous chapter. For example, the main goroutine in the concurrent web crawler (§8.6) is the sole goroutine that accesses the seen map, and the broadcaster goroutine in the chat server (§8.10) is the only goroutine that accesses the clients map. These variables are confined to a single goroutine.&lt;/p&gt;

&lt;p&gt;Since other goroutines cannot access the variable directly, they must use a channel to send the confining goroutine a request to query or update the variable. This is what is meant by the Go mantra “Do not communicate by sharing memory; instead, share memory by communicating.” A goroutine that brokers access to a confined variable using channel requests is called a monitor goroutine for that variable. For example, the broadcaster goroutine monitors access to the clients map.&lt;/p&gt;

&lt;p&gt;Here’s the bank example rewritten with the balance variable confined to a monitor goroutine called teller:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch9/bank1 
// Package bank provides a concurrency-safe bank with one account. package bank 
var deposits = make(chan int) // send amount to 
deposit
var balances = make(chan int) // receive balance 

func Deposit(amount int) { deposits &amp;lt;-amount }
func Balance() int { return &amp;lt;-balances } 

func teller() {var balance int // balance is confined to teller goroutine
for     {
select {
case amount := &amp;lt;-deposits: 

balance += amount 
case balances &amp;lt;-balance: 
}

}
} 

func init() { 
go teller() // start the monitor goroutine 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even when a variable cannot be confined to a single goroutine for its entire lifetime, confinement may still be a solution to the problem of concurrent access. For example, it’s common to share a variable between goroutines in a pipeline by passing its address from one stage to the next over a channel.&lt;/p&gt;

&lt;p&gt;If each stage of the pipeline refrains from accessing the variable after sending it to the next stage, then all accesses to the variable are sequential. In effect, the variable is confined to one stage of the pipeline, then confined to the next, and so on. This discipline is sometimes called serial confinement.&lt;/p&gt;

&lt;p&gt;In the example below, Cakes are serially confined, first to the baker goroutine, then to the icer goroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Cake struct{ state string } 
func baker(cooked chan&amp;lt;-*Cake) { 
for {cake := new(Cake)
cake.state = &amp;quot;cooked&amp;quot; 
cooked &amp;lt;-cake // baker never touches this cake again 
}} 
func icer(iced chan&amp;lt;-*Cake, cooked &amp;lt;-chan *Cake) { 
for cake := range cooked {
cake.state = &amp;quot;iced&amp;quot; 
iced &amp;lt;-cake // icer never touches this cake again
}} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The third way to avoid a data race is to allow many goroutines to access the variable, but only one at a time. This approach is known as mutual exclusion and is the subject of the next section.&lt;/p&gt;

&lt;p&gt;Exercise 9.1: Add a function Withdraw(amount int) bool to the
// gopl.io/ch9/bank1 program. The result should indicate whether the transaction succeeded or failed due to insufficient funds. The message sent to the monitor goroutine must contain both the amount to withdraw and a new channel over which the monitor goroutine can send the boolean result back to Withdraw.&lt;/p&gt;

&lt;h2 id=&#34;mutual-exclusion-sync-mutex:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Mutual Exclusion: sync.Mutex&lt;/h2&gt;

&lt;p&gt;In Section 8.6, we used a buffered channel as a counting semaphore to ensure that no more than 20 goroutines made simultaneous HTTP requests. With the same idea, we can use a channel of capacity 1 to ensure that at most one goroutine accesses a shared variable at a time. A semaphore that counts only to 1 is called a binary semaphore.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch9/bank2 
var (
sema = make(chan struct{}, 1) // a binary 
semaphore guarding balance 
balance int 
) 

func Deposit(amount int) { 
sema &amp;lt;-struct{}{} // acquire token 
balance = balance + amount 
&amp;lt;-sema // release token } 
func Balance() int {
sema &amp;lt;-struct{}{} // acquire token 
b := balance 
&amp;lt;-sema // release token 
return b 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This pattern of mutual exclusion is so useful that it is supported directly by the Mutex type from the sync package. Its Lock method acquires the token (called a lock) and its Unlock method releases it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch9/bank3 
import &amp;quot;sync&amp;quot; var (mu sync.Mutex // guards balance 
balance int 
) 
func Deposit(amount int) { 
mu.Lock()
balance = balance + amount 
mu.Unlock() 
} 
func Balance() int {
mu.Lock()
b := balance 
mu.Unlock()
return b 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each time a goroutine accesses the variables of the bank (just balance here), it must call the mutex’s Lock method to acquire an exclusive lock. If some other goroutine has acquired the lock, this operation will block until the other goroutine calls Unlock and the lock becomes available again. The mutex guards the shared variables. By convention, the variables guarded by a mutex are declared immediately after the declaration of the mutex itself. If you deviate from this, be sure to document it.&lt;/p&gt;

&lt;p&gt;The region of code between Lock and Unlock in which a goroutine is free to read and modify the shared variables is called a critical section. The lock holder’s call to Unlock happens before any other goroutine can acquire the lock for itself. It is essential that the goroutine release the lock once it is finished, on all paths through the function, including error paths.&lt;/p&gt;

&lt;p&gt;The bank program above exemplifies a common concurrency pattern. A set of exported functions encapsulates one or more variables so that the only way to access the variables is through these functions (or methods, for the variables of an object). Each function acquires a mutex lock at the beginning and releases it at the end, thereby ensuring that the shared variables are not accessed concurrently. This arrangement of functions, mutex lock, and variables is called a monitor. (This older use of the word “monitor” inspired the term “monitor goroutine.” Both uses share the meaning of a broker that ensures variables are accessed sequentially.)&lt;/p&gt;

&lt;p&gt;Since the critical sections in the Deposit and Balance functions are so short—a single line, no branching—calling Unlock at the end is straightforward. In more complex critical sections, especially those in which errors must be dealt with by returning early, it can be hard to tell that calls to Lock and Unlock are strictly paired on all paths. Go’s defer statement comes to the rescue: by deferring a call to Unlock, the critical section implicitly extends to the end of the current function, freeing us from having to remember to insert Unlock calls in one or more places far from the call to Lock.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Balance() int {

mu.Lock()
defer mu.Unlock() 
return balance 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above, the Unlock executes after the return statement has read the value of balance, so the Balance function is concurrency-safe. As a bonus, we no longer need the local variable b.&lt;/p&gt;

&lt;p&gt;Furthermore, a deferred Unlock will run even if the critical section panics, which may be important in programs that make use of recover (§5.10). A defer is marginally more expensive than an explicit call to Unlock, but not enough to justify less clear code. As always with concurrent programs, favor clarity and resist premature optimization. Where possible, use defer and let critical sections extend to the end of a function.&lt;/p&gt;

&lt;p&gt;Consider the Withdraw function below. On success, it reduces the balance by the specified amount and returns true. But if the account holds insufficient funds for the transaction, Withdraw restores the balance and returns false.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// NOTE: not atomic! 
func Withdraw(amount int) bool {
Deposit(-amount)
if Balance() &amp;lt; 0 {
Deposit(amount)
return false // insufficient funds } 
return true 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function eventually gives the correct result, but it has a nasty side effect. When an excessive withdrawal is attempted, the balance transiently dips below zero. This may cause a concurrent withdrawal for a modest sum to be spuriously rejected.&lt;/p&gt;

&lt;p&gt;So if Bob tries to buy a sports car, Alice can’t pay for her morning coffee. The problem is that Withdraw is not atomic: it consists of a sequence of three separate operations, each of which acquires and then releases the mutex lock, but nothing locks the whole sequence.&lt;/p&gt;

&lt;p&gt;Ideally, Withdraw should acquire the mutex lock once around the whole operation. However, this attempt won’t work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// NOTE: incorrect! 
func Withdraw(amount int) bool {
mu.Lock()
defer mu.Unlock()
Deposit(-amount)
if Balance() &amp;lt; 0 {
Deposit(amount)
return false // insufficient funds }
return true 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Deposit tries to acquire the mutex lock a second time by calling mu.Lock(), but because mutex locks are not re-entrant—it’s not possible to lock a mutex that’s already locked—this leads to a deadlock where nothing can proceed, and Withdraw blocks forever.&lt;/p&gt;

&lt;p&gt;There is a good reason Go’s mutexes are not re-entrant. The purpose of a mutex is to ensure that certain invariants of the shared variables are maintained at critical points during program execution.&lt;/p&gt;

&lt;p&gt;One of the invariants is “no goroutine is accessing the shared variables,” but there may be additional invariants specific to the data structures that the mutex guards. When a goroutine acquires a mutex lock, it may assume that the invariants hold.&lt;/p&gt;

&lt;p&gt;While it holds the lock, it may update the shared variables so that the invariants are temporarily violated. However, when it releases the lock, it must guarantee that order has been restored and the invariants hold once again. Although a re-entrant mutex would ensure that no other goroutines are accessing the shared variables, it cannot protect the additional invariants of those variables.&lt;/p&gt;

&lt;p&gt;A common solution is to divide a function such as Deposit into two: an unexported function, deposit, that assumes the lock is already held and does the real work, and an exported function Deposit that acquires the lock before calling deposit. We can then express Withdraw in terms of deposit like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Withdraw(amount int) bool {
mu.Lock()
defer mu.Unlock()
deposit(-amount)
if balance &amp;lt; 0 {

deposit(amount)
return false // insufficient funds 
}
return true 

} 
func Deposit(amount int) { 
mu.Lock()
defer mu.Unlock()
deposit(amount) 

} 
func Balance() int {
mu.Lock()
defer mu.Unlock() 
return balance 

} 
// This function requires that the lock be held. 
func deposit(amount int) { balance += amount } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, the deposit function shown here is so trivial that a realistic Withdraw function wouldn’t bother calling it, but nonetheless it illustrates the principle.&lt;/p&gt;

&lt;p&gt;Encapsulation (§6.6), by reducing unexpected interactions in a program, helps us maintain data structure invariants. For the same reason, encapsulation also helps us maintain concurrency invariants. When you use a mutex, make sure that both it and the variables it guards are not exported, whether they are package-level variables or the fields of a struct.&lt;/p&gt;

&lt;h2 id=&#34;read-write-mutexes:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Read/Write Mutexes:&lt;/h2&gt;

&lt;p&gt;sync.RWMutex
In a fit of anxiety after seeing his $100 deposit vanish without a trace, Bob writes a program to check his bank balance hundreds of times a second. He runs it at home, at work, and on his phone. The bank notices that the increased traffic is delaying deposits and withdrawals, because all the Balance requests run sequentially, holding the lock exclusively and temporarily preventing other goroutines from running.&lt;/p&gt;

&lt;p&gt;Since the Balance function only needs to read the state of the variable, it would in fact be safe for multiple Balance calls to run concurrently, so long as no Deposit or Withdraw call is running. In this scenario we need a special kind of lock that allows read-only operations to proceed in parallel with each other, but write operations to have fully exclusive access. This lock is called a multiple readers, single writer lock, and in Go it’s provided by sync.RWMutex:
var mu sync.RWMutex
var balance int
func Balance() int {
mu.RLock() // readers lock
defer mu.RUnlock()
return balance
}&lt;/p&gt;

&lt;p&gt;The Balance function now calls the RLock and RUnlock methods to acquire and release a readers or shared lock. The Deposit function, which is unchanged, calls the mu.Lock and mu.Unlock methods to acquire and release a writer or exclusive lock.&lt;/p&gt;

&lt;p&gt;After this change, most of Bob’s Balance requests run in parallel with each other and finish more quickly. The lock is available for more of the time, and Deposit requests can proceed in a timely manner.&lt;/p&gt;

&lt;p&gt;RLock can be used only if there are no writes to shared variables in the critical section. In general, we should not assume that logically read-only functions or methods don’t also update some variables. For example, a method that appears to be a simple accessor might also increment an internal usage counter, or update a cache so that repeat calls are faster. If in doubt, use an exclusive Lock.&lt;/p&gt;

&lt;p&gt;It’s only profitable to use an RWMutex when most of the goroutines that acquire the lock are readers, and the lock is under contention, that is, goroutines routinely have to wait to acquire it. An RWMutex requires more complex internal bookkeeping, making it slower than a regular mutex for uncontended locks.&lt;/p&gt;

&lt;h2 id=&#34;memory-synchronization:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Memory Synchronization&lt;/h2&gt;

&lt;p&gt;You may wonder why the Balance method needs mutual exclusion, either channel-based or mutex-based. After all, unlike Deposit, it consists only of a single operation, so there is no danger of another goroutine executing “in the middle” of it.&lt;/p&gt;

&lt;p&gt;There are two reasons we need a mutex. The first is that it’s equally important that Balance not execute in the middle of some other operation like Withdraw. The second (and more subtle) reason is that synchronization is about more than just the order of execution of multiple goroutines; synchronization also affects memory.&lt;/p&gt;

&lt;p&gt;In a modern computer there may be dozens of processors, each with its own local cache of the main memory.&lt;/p&gt;

&lt;p&gt;For efficiency, writes to memory are buffered within each processor and flushed out to main memory only when necessary. They may even be committed to main memory in a different order than they were written by the writing goroutine.&lt;/p&gt;

&lt;p&gt;Synchronization primitives like channel communications and mutex operations cause the processor to flush out and commit all its accumulated writes so that the effects of goroutine execution up to that point are guaranteed to be visible to goroutines running on other processors.
Consider the possible outputs of the following snippet of code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x, y int 
go func() {
x=1 // A1 
fmt.Print(&amp;quot;y:&amp;quot;, y, &amp;quot; &amp;quot;) // A2 }()
go func() {
y=1 // B1 
fmt.Print(&amp;quot;x:&amp;quot;, x, &amp;quot; &amp;quot;) // B2 }() 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since these two goroutines are concurrent and access shared variables without mutual exclusion, there is a data race, so we should not be surprised that the program is not deterministic. We might expect it to print any one of these four results, which correspond to intuitive interleavings of the labeled statements of the program:
y:0 x:1 x:0 y:1
x:1 y:1
y:1 x:1&lt;/p&gt;

&lt;p&gt;The fourth line could be explained by the sequence A1,B1,A2,B2 or by B1,A1,A2,B2, for example. However, these two outcomes might come as a surprise:
x:0 y:0
y:0 x:0
but depending on the compiler, CPU, and many other factors, they can happen too. What possible interleaving of the four statements could explain them?&lt;/p&gt;

&lt;p&gt;Within a single goroutine, the effects of each statement are guaranteed to occur in the order of execution; goroutines are sequentially consistent. But in the absence of explicit synchronization using a channel or mutex, there is no guarantee that events are seen in the same order by all goroutines. Although goroutine A must observe the effect of the write x=1 before it reads the value of y, it does not necessarily observe the write to y done by goroutine B, so A may print a stale value of y.&lt;/p&gt;

&lt;p&gt;It is tempting to try to understand concurrency as if it corresponds to some interleaving of the statements of each goroutine, but as the example above shows, this is not how a modern compiler or CPU works. Because the assignment and the Print refer to different variables, a compiler may conclude that the order of the two statements cannot affect the result, and swap them. If the two goroutines execute on different CPUs, each with its own cache, writes by one goroutine are not visible to the other goroutine’s Print until the caches are synchronized with main memory.&lt;/p&gt;

&lt;p&gt;All these concurrency problems can be avoided by the consistent use of simple, established patterns. Where possible, confine variables to a single goroutine; for all other variables, use mutual exclusion.&lt;/p&gt;

&lt;h2 id=&#34;lazy-initialization-sync-once:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Lazy Initialization: sync.Once&lt;/h2&gt;

&lt;p&gt;It is good practice to defer an expensive initialization step until the moment it is needed. Initializing a variable up front increases the start-up latency of a program and is unnecessary if execution doesn’t always reach the part of the program that uses that variable. Let’s return to the icons variable we saw earlier in the chapter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var icons map[string]image.Image 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version of Icon uses lazy initialization:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func loadIcons() {
icons = map[string]image.Image{&amp;quot;spades.png&amp;quot;: loadIcon(&amp;quot;spades.png&amp;quot;), &amp;quot;hearts.png&amp;quot;: loadIcon(&amp;quot;hearts.png&amp;quot;), &amp;quot;diamonds.png&amp;quot;: loadIcon(&amp;quot;diamonds.png&amp;quot;), &amp;quot;clubs.png&amp;quot;: loadIcon(&amp;quot;clubs.png&amp;quot;), 
}
} 

// NOTE: not concurrency-safe! 
func Icon(name string) image.Image {
if icons == nil {

loadIcons() // one-time initialization }return icons[name] } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For a variable accessed by only a single goroutine, we can use the pattern above, but this pattern is not safe if Icon is called concurrently. Like the bank’s original Deposit function, Icon consists of multiple steps: it tests whether icons is nil, then it loads the icons, then it updates icons to a non-nil value. Intuition might suggest that the worst possible outcome of the race condition above is that the loadIcons function is called several times. While the first goroutine is busy loading the icons, another goroutine entering Icon would find the variable still equal to nil, and would also call loadIcons.&lt;/p&gt;

&lt;p&gt;But this intuition is also wrong. (We hope that by now you are developing a new intuition about concurrency, that intuitions about concurrency are not to be trusted!) Recall the discussion of memory from Section 9.4. In the absence of explicit synchronization, the compiler and CPU are free to reorder accesses to memory in any number of ways, so long as the behavior of each goroutine is sequentially consistent. One possible reordering of the statements of loadIcons is shown below. It stores the empty map in the icons variable before populating it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func loadIcons() {icons = make(map[string]image.Image)icons[&amp;quot;spades.png&amp;quot;] = loadIcon(&amp;quot;spades.png&amp;quot;) icons[&amp;quot;hearts.png&amp;quot;] = loadIcon(&amp;quot;hearts.png&amp;quot;) icons[&amp;quot;diamonds.png&amp;quot;] = loadIcon(&amp;quot;diamonds.png&amp;quot;) icons[&amp;quot;clubs.png&amp;quot;] = loadIcon(&amp;quot;clubs.png&amp;quot;) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Consequently, a goroutine finding icons to be non-nil may not assume that the initialization of the variable is complete.&lt;/p&gt;

&lt;p&gt;The simplest correct way to ensure that all goroutines observe the effects of loadIcons is to synchronize them using a mutex:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var mu sync.Mutex // guards icons 
var icons map[string]image.Image 

// Concurrency-safe.
func Icon(name string) image.Image {
mu.Lock()
defer mu.Unlock() 
if icons == nil {

loadIcons() 
}
return icons[name] 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, the cost of enforcing mutually exclusive access to icons is that two goroutines cannot access the variable concurrently, even once the variable has been safely initialized and will never be modified again. This suggests a multiple-readers lock:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var mu sync.RWMutex // guards icons 
var icons map[string]image.Image 
// Concurrency-safe.
func Icon(name string) image.Image {
mu.RLock()
if icons != nil {
icon := icons[name]
mu.RUnlock()
return icon 
}
mu.RUnlock() 
// acquire an exclusive lock 
mu.Lock()
if icons == nil { // NOTE: must recheck for nil 
loadIcons() }
icon := icons[name]
mu.Unlock()
return icon 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are now two critical sections. The goroutine first acquires a reader lock, consults the map, then releases the lock. If an entry was found (the common case), it is returned. If no entry was found, the goroutine acquires a writer lock. There is no way to upgrade a shared lock to an exclusive one without first releasing the shared lock, so we must recheck the icons variable in case another goroutine already initialized it in the interim.&lt;/p&gt;

&lt;p&gt;The pattern above gives us greater concurrency but is complex and thus error-prone. Fortunately, the sync package provides a specialized solution to the problem of one­time initialization: sync.Once. Conceptually, a Once consists of a mutex and a boolean variable that records whether initialization has taken place; the mutex guards both the boolean and the client’s data structures. The sole method, Do, accepts the initialization function as its argument. Let’s use Once to simplify the Icon function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var loadIconsOnce sync.Once 
var icons map[string]image.Image 
// Concurrency-safe.
func Icon(name string) image.Image {
loadIconsOnce.Do(loadIcons)
return icons[name] } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each call to Do(loadIcons) locks the mutex and checks the boolean variable. In the first call, in which the variable is false, Do calls loadIcons and sets the variable to true. Subsequent calls do nothing, but the mutex synchronization ensures that the effects of loadIcons on memory (specifically, icons) become visible to all goroutines. Using sync.Once in this way, we can avoid sharing variables with other goroutines until they have been properly constructed.&lt;/p&gt;

&lt;p&gt;Exercise 9.2: Rewrite the PopCount example from Section 2.6.2 so that it initializes the lookup table using sync.Once the first time it is needed. (Realistically, the cost of synchronization would be prohibitive for a small and highly optimized function like PopCount.)&lt;/p&gt;

&lt;h2 id=&#34;the-race-detector:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;The Race Detector&lt;/h2&gt;

&lt;p&gt;Even with the greatest of care, it’s all too easy to make concurrency mistakes. Fortunately, the Go runtime and toolchain are equipped with a sophisticated and easy­to-use dynamic analysis tool, the race detector.&lt;/p&gt;

&lt;p&gt;Just add the -race flag to your go build , go run , or go test command. This causes the compiler to build a modified version of your application or test with additional instrumentation that effectively records all accesses to shared variables that occurred during execution, along with the identity of the goroutine that read or wrote the variable. In addition, the modified program records all synchronization events, such as go statements, channel operations, and calls to (*sync.Mutex).Lock, (*sync.WaitGroup).Wait, and so on. (The complete set of synchronization events is specified by the The Go Memory Model document that accompanies the language specification.)&lt;/p&gt;

&lt;p&gt;The race detector studies this stream of events, looking for cases in which one goroutine reads or writes a shared variable that was most recently written by a different goroutine without an intervening synchronization operation. This indicates a concurrent access to the shared variable, and thus a data race. The tool prints a report that includes the identity of the variable, and the stacks of active function calls in the reading goroutine and the writing goroutine. This is usually sufficient to pinpoint the problem. Section 9.7 contains an example of the race detector in action.&lt;/p&gt;

&lt;p&gt;The race detector reports all data races that were actually executed. However, it can only detect race conditions that occur during a run; it cannot prove that none will ever occur. For best results, make sure that your tests exercise your packages using concurrency.&lt;/p&gt;

&lt;p&gt;Due to extra bookkeeping, a program built with race detection needs more time and memory to run, but the overhead is tolerable even for many production jobs. For infrequently occurring race conditions, letting the race detector do its job can save hours or days of debugging.&lt;/p&gt;

&lt;h2 id=&#34;example-concurrent-non-blocking-cache:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Example: Concurrent Non-Blocking Cache&lt;/h2&gt;

&lt;p&gt;In this section, we’ll build a concurrent non-blocking cache, an abstraction that solves a problem that arises often in real-world concurrent programs but is not well addressed by existing libraries. This is the problem of memoizing a function, that is, caching the result of a function so that it need be computed only once. Our solution will be concurrency-safe and will avoid the contention associated with designs based on a single lock for the whole cache.&lt;/p&gt;

&lt;p&gt;We’ll use the httpGetBody function below as an example of the type of function we might want to memoize. It makes an HTTP GET request and reads the request body. Calls to this function are relatively expensive, so we’d like to avoid repeating them unnecessarily.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func httpGetBody(url string) (interface{}, error) { 
resp, err := http.Get(url) 
if err != nil {
return nil, err }
defer resp.Body.Close() 
return ioutil.ReadAll(resp.Body) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final line hides a minor subtlety. ReadAll returns two results, a []byte and an error, but since these are assignable to the declared result types of httpGetBody—interface{} and error, respectively—we can return the result of the call without further ado. We chose this return type for httpGetBodyso that it conforms to the type of functions that our cache is designed to memoize.&lt;/p&gt;

&lt;p&gt;Here’s the first draft of the cache:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch9/memo1 
// Package memo provides a concurrency-unsafe 
// memoization of a function of type Func. 
package memo 

// A Memo caches the results of calling a Func. 
type Memo struct {
f Func 
cache map[string]result 

} 
// Func is the type of the function to memoize. 
type Func func(key string) (interface{}, error) 

type result struct {
value interface{} 
err error 

} 
func New(f Func) *Memo {return &amp;amp;Memo{f: f, cache: make(map[string]result)} } 
// NOTE: not concurrency-safe! 
func (memo *Memo) Get(key string) (interface{}, error) 
{ 

res, ok := memo.cache[key] 
if !ok {
res.value, res.err = memo.f(key) 
memo.cache[key] = res 

}
return res.value, res.err 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Memo instance holds the function f to memoize, of type Func, and the cache, which is a mapping from strings to results. Each result is simply the pair of results returned by a call to f—a value and an error. We’ll show several variations of Memo as the design progresses, but all will share these basic aspects.&lt;/p&gt;

&lt;p&gt;Anexample of how to use Memo appears below. For each element in a stream of incoming URLs, we call Get, logging the latency of the call and the amount of data it returns:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := memo.New(httpGetBody) 
for     url := range incomingURLs() { 
start := time.Now() 
value, err := m.Get(url) 
if err != nil {

log.Print(err) 
}
fmt.Printf(&amp;quot;%s, %s, %d bytes\n&amp;quot;, 

url, time.Since(start), len(value.([]byte))) } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use the testing package (the topic of Chapter 11) to systematically investigate the effect of memoization. From the test output below, we see that the URL stream contains duplicates, and that although the first call to (*Memo).Getfor each URL takes hundreds of milliseconds, the second request returns the same amount of data in under a millisecond.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test -v // gopl.io/ch9/memo1 
=== RUN Test 
https://golang.org, 175.026418ms, 7537 bytes 
https://godoc.org, 172.686825ms, 6878 bytes 
https://play.golang.org, 115.762377ms, 5767 bytes 
http://gopl.io, 749.887242ms, 2856 bytes 

https://golang.org, 721ns, 7537 bytes 
https://godoc.org, 152ns, 6878 bytes 
https://play.golang.org, 205ns, 5767 bytes 
http://gopl.io, 326ns, 2856 bytes 
---PASS: Test (1.21s) 
PASS 
ok // gopl.io/ch9/memo1 1.257s 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This test executes all calls to Get sequentially.&lt;/p&gt;

&lt;p&gt;Since HTTP requests are a great opportunity for parallelism, let’s change the test so that it makes all requests concurrently. The test uses a sync.WaitGroup to wait until the last request is complete before returning.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := memo.New(httpGetBody) 
var n sync.WaitGroup 
for url := range incomingURLs() { 
n.Add(1)
go func(url string) { 
start := time.Now() 
value, err := m.Get(url) 
if err != nil {
log.Print(err) 
}
fmt.Printf(&amp;quot;%s, %s, %d bytes\n&amp;quot;, 
url, time.Since(start), len(value. 
([]byte)))n.Done()
}(url) }
n.Wait() 

The test runs much faster, but unfortunately it is unlikely to work correctly all the time. We may notice unexpected cache misses, or cache hits that return incorrect values, or even crashes. 
Worse, it is likely to work correctly some of the time, so we may not even notice that it has a problem. But if we run it with the -race flag, the race detector (§9.6) often prints a report such as this one: 

```go
$ go test -run=TestConcurrent -race -v 
// gopl.io/ch9/memo1
=== RUN TestConcurrent 
... 
WARNING: DATA RACE 
Write by goroutine 36: 
runtime.mapassign1()
~/go/src/runtime/hashmap.go:411 +0x0 
// gopl.io/ch9/memo1.(*Memo).Get()
~/gobook2/src/// gopl.io/ch9/memo1/memo.go:32 
+0x205 ... 
Previous write by goroutine 35: 
runtime.mapassign1()
~/go/src/runtime/hashmap.go:411 +0x0 
// gopl.io/ch9/memo1.(*Memo).Get()

~/gobook2/src/// gopl.io/ch9/memo1/memo.go:32 
+0x205 
... 
Found 1 data race(s) 
FAIL // gopl.io/ch9/memo1 2.393s 


The reference to memo.go:32 tells us that two goroutines have updated the cache map without any intervening synchronization. Get is not concurrency-safe: it has a data race. 

```go
28 func (memo *Memo) Get(key string) (interface{}, 
error) {
29 res, ok := memo.cache[key] 
30 if !ok {
31 res.value, res.err = memo.f(key) 
32 memo.cache[key] = res 

33 
}
34 return res.value, res.err 


35 
} 



The simplest way to make the cache concurrency-safe is to use monitor-based synchronization. All we need to do is add a mutex to the Memo, acquire the mutex lock at the start of Get, and release it before Get returns, so that the two cache operations occur within the critical section: 

```go
// gopl.io/ch9/memo2 
type Memo struct {
f Func 
mu sync.Mutex // guards cache 
cache map[string]result 

} // Get is concurrency-safe. 
func (memo *Memo) Get(key string) (value interface{}, 
err error) {
memo.mu.Lock()
res, ok := memo.cache[key] 
if !ok {
res.value, res.err = memo.f(key) 
memo.cache[key] = res }
memo.mu.Unlock()
return res.value, res.err 
} 

Now the race detector is silent, even when running the tests concurrently. Unfortunately this change to Memo reverses our earlier performance gains. By holding the lock for the duration of each call to f, Get serializes all the I/O operations we intended to parallelize. What we need is a non-blocking cache, one that does not serialize calls to the function it memoizes. 
In the next implementation of Get, below, the calling goroutine acquires the lock twice: once for the lookup, and then a second time for the update if the lookup returned nothing. In between, other goroutines are free to use the cache. 

```go
// gopl.io/ch9/memo3 
func (memo *Memo) Get(key string) (value interface{}, 
err error) {
memo.mu.Lock()
res, ok := memo.cache[key]
memo.mu.Unlock()
if !ok {
res.value, res.err = memo.f(key) 
// Between the two critical sections, several goroutines// may race to compute f(key) and update the map. memo.mu.Lock() 
memo.cache[key] = res 
memo.mu.Unlock() 
}
return res.value, res.err 
} 

The performance improves again, but now we notice that some URLs are being fetched twice. This happens when two or more goroutines call Get for the same URL at about the same time. Both consult the cache, find no value there, and then call the slow function f. Then both of them update the map with the result they obtained. One of the results is overwritten by the other. 

Ideally we’d like to avoid this redundant work. This feature is sometimes called duplicate suppression. In the version of Memo below, each map element is a pointer to an entry struct. Each entry contains the memoized result of a call to the function f, as before, but it additionally contains a channel called ready. Just after the entry’s result has been set, this channel will be closed, to broadcast (§8.9) to any other goroutines that it is now safe for them to read the result from the entry. 

```go
// gopl.io/ch9/memo4 
type entry struct {
res result 
ready chan struct{} // closed when res is ready } 
func New(f Func) *Memo {return &amp;amp;Memo{f: f, cache: make(map[string]*entry)} } 
type Memo struct {
f Func 
mu sync.Mutex // guards cache 
cache map[string]*entry } 
func (memo *Memo) Get(key string) (value interface{}, 
err error) { memo.mu.Lock()
e := memo.cache[key] 
if e == nil {
// This is the first request for this key. 
// This goroutine becomes responsible for computing
// the value and broadcasting the ready 
condition. 
e = &amp;amp;entry{ready: make(chan struct{})} 
memo.cache[key] = e 
memo.mu.Unlock() 
e.res.value, e.res.err = memo.f(key) 
close(e.ready) // broadcast ready condition 
} else {
// This is a repeat request for this key. 
memo.mu.Unlock() 
&amp;lt;-e.ready // wait for ready condition }
return e.res.value, e.res.err 
} 

A call to Get now involves acquiring the mutex lock that guards the cache map, looking in the map for a pointer to an existing entry, allocating and inserting a new entry if none was found, then releasing the lock. If there was an existing entry, its value is not necessarily ready yet—another goroutine could still be calling the slow function f—so the calling goroutine must wait for the entry’s “ready” condition before it reads the entry’s result. It does this by reading a value from the ready channel, since this operation blocks until the channel is closed. 

If there was no existing entry, then by inserting a new “not ready” entry into the map, the current goroutine becomes responsible for invoking the slow function, updating the entry, and broadcasting the readiness of the new entry to any other goroutines that might (by then) be waiting for it. 

Notice that the variables e.res.value and e.res.err in the entry are shared among multiple goroutines. The goroutine that creates the entry sets their values, and other goroutines read their values once the “ready” condition has been broadcast. 

Despite being accessed by multiple goroutines, no mutex lock is necessary. The closing of the ready channel happens before any other goroutine receives the broadcast event, so the write to those variables in the first goroutine happens before they are read by subsequent goroutines. There is no data race. 

Our concurrent, duplicate-suppressing, non-blocking cache is complete. The implementation of Memo above uses a mutex to guard a map variable that is shared by each goroutine that calls Get. It’s interesting to contrast this design with an alternative one in which the map variable is confined to a monitor goroutine to which callers of Get must send a message. 

The declarations of Func, result, and entry remain as before: 

```go
// Func is the type of the function to memoize. 
type Func func(key string) (interface{}, error) 
// A result is the result type result struct {value interface{} err error  of  calling  a  Func.  
}  
type entry struct res result  {  
}  ready  chan  struct{} //  closed  when  res  is  ready  


However, the Memo type now consists of a channel, requests, through which the caller of Get communicates with the monitor goroutine. The element type of the channel is a request. Using this structure, the caller of Get sends the monitor goroutine both the key, that is, the argument to the memoized function, and another channel, response, over which the result should be sent back when it becomes available. This channel will carry only a single value. 

```go
// gopl.io/ch9/memo5 
// A request is a message requesting that the Func be 
applied to key. 
type request struct {
key string 
response chan&amp;lt;-result // the client wants a 
single }  result  
type  Memo  struct{ requests  chan  request }  
// New returns a memoization subsequently call Close. func New(f Func) *Memo {  of  f.  Clients  must  

memo := &amp;amp;Memo{requests: make(chan request)} 
go memo.server(f)return memo } 
func (memo *Memo) Get(key string) (interface{}, error) 
{ response := make(chan result) memo.requests &amp;lt;-request{key, response} res := &amp;lt;-response return res.value, res.err 
} 
func (memo *Memo) Close() { close(memo.requests) } 

The Get method, above, creates a response channel, puts it in the request, sends it to the monitor goroutine, then immediately receives from it. 

The cache variable is confined to the monitor goroutine (*Memo).server, shown below. The monitor reads requests in a loop until the request channel is closed by the Close method. For each request, it consults the cache, creating and inserting a new entry if none was found. 

```go
func (memo *Memo) server(f Func) { cache := make(map[string]*entry) for req := range memo.requests {
e := cache[req.key] 
if e == nil {// This is the first request for this key. e = &amp;amp;entry{ready: make(chan struct{})} cache[req.key] = e go e.call(f, req.key) // call f(key) 
}
go e.deliver(req.response) 
}
} 

func (e *entry) call(f Func, key string) { 
// Evaluate the function. 
e.res.value, e.res.err = f(key) 
// Broadcast the ready condition. 
close(e.ready) 

} 
func (e *entry) deliver(response chan&amp;lt;-result) { 
// Wait for the ready condition. 
&amp;lt;-e.ready
// Send the result to the client. 
response &amp;lt;-e.res 

} 
In a similar manner to the mutex-based version, the first request for a given key becomes responsible for calling the function f on that key, storing the result in the entry, and broadcasting the readiness of the entry by closing the ready channel. This is done by (*entry).call. 

A subsequent request for the same key finds the existing entry in the map, waits for the result to become ready, and sends the result through the response channel to the client goroutine that called Get. This is done by (*entry).deliver. The call and deliver methods must be called in their own goroutines to ensure that the monitor goroutine does not stop processing new requests. 

This example shows that it’s possible to build many concurrent structures using either of the two approaches—shared variables and locks, or communicating sequential processes—without excessive complexity. 

It’s not always obvious which approach is preferable in a given situation, but it’s worth knowing how they correspond. Sometimes switching from one approach to the 
other can make your code simpler. 

Exercise 9.3: Extend the Func type and the (*Memo).Get method so that callers 
may provide an optional done channel through which they can cancel the operation 
(§8.9). The results of a cancelled Func call should not be cached. 

##Goroutines and Threads 

In the previous chapter we said that the difference between goroutines and operating system (OS) threads could be ignored until later. Although the differences between them are essentially quantitative, a big enough quantitative difference becomes a qualitative one, and so it is with goroutines and threads. The time has now come to distinguish them. 

### Growable Stacks 

Each OS thread has a fixed-size block of memory (often as large as 2MB) for its stack, the work area where it saves the local variables of function calls that are in progress or temporarily suspended while another function is called. This fixed-size stack is simultaneously too much and too little. A 2MB stack would be a huge waste of memory for a little goroutine, such as one that merely waits for a WaitGroupthen closes a channel. 

It’s not uncommon for a Go program to create hundreds of thousands of goroutines at one time, which would be impossible with stacks this large. Yet despite their size, fixed-size stacks are not always big enough for the most complex and deeply recursive of functions. Changing the fixed size can improve space efficiency and allow more threads to be created, or it can enable more deeply recursive functions, but it cannot do both. 

In contrast, a goroutine starts life with a small stack, typically 2KB. A goroutine’s stack, like the stack of an OS thread, holds the local variables of active and suspended function calls, but unlike an OS thread, a goroutine’s stack is not fixed; it grows and shrinks as needed. The size limit for a goroutine stack may be as much as 1GB, orders of magnitude larger than a typical fixed-size thread stack, though of course few goroutines use that much. 

Exercise 9.4: Construct a pipeline that connects an arbitrary number of goroutines with channels. What is the maximum number of pipeline stages you can create without running out of memory? How long does a value take to transit the entire pipeline? 

### Goroutine Scheduling 
OS threads are scheduled by the OS kernel. Every few milliseconds, a hardware timer interrupts the processor, which causes a kernel function called the scheduler to be invoked. This function suspends the currently executing thread and saves its registers in memory, looks over the list of threads and decides which one should run next, restores that thread’s registers from memory, then resumes the execution of that thread. 

Because OS threads are scheduled by the kernel, passing control from one thread to another requires a full context switch, that is, saving the state of one user thread to memory, restoring the state of another, and updating the scheduler’s data structures. This operation is slow, due to its poor locality and the number of memory accesses required, and has historically only gotten worse as the number of CPU cycles required to access memory has increased. 

The Go runtime contains its own scheduler that uses a technique known as m:n scheduling, because it multiplexes (or schedules) m goroutines on n OS threads. The job of the Go scheduler is analogous to that of the kernel scheduler, but it is concerned only with the goroutines of a single Go program. 


Unlike the operating system’s thread scheduler, the Go scheduler is not invoked periodically by a hardware timer, but implicitly by certain Go language constructs. For example, when a goroutine calls time.Sleep or blocks in a channel or mutex operation, the scheduler puts it to sleep and runs another goroutine until it is time to wake the first one up. Because it doesn’t need a switch to kernel context, rescheduling a goroutine is much cheaper than rescheduling a thread. 

Exercise 9.5: Write a program with two goroutines that send messages back and forth over two unbuffered channels in ping-pong fashion. How many communications per second can the program sustain? 

### GOMAXPROCS 

The Go scheduler uses a parameter called GOMAXPROCS to determine how many OS threads may be actively executing Go code simultaneously. Its default value is the number of CPUs on the machine, so on a machine with 8 CPUs, the scheduler will schedule Go code on up to 8 OS threads at once. (GOMAXPROCS is the n in m:n scheduling.) 

Goroutines that are sleeping or blocked in a communication do not need a thread at all. 

Goroutines that are blocked in I/O or other system calls or are calling non-Go functions, do need an OS thread, but GOMAXPROCS need not account for them. 

You can explicitly control this parameter using the GOMAXPROCS environment variable or the runtime.GOMAXPROCS function. We can see the effect of GOMAXPROCS on this little program, which prints an endless stream of zeros and ones: 

```go
for {go fmt.Print(0)
fmt.Print(1) 
} 
$ GOMAXPROCS=1 go run hacker-cliché.go
111111111111111111110000000000000000000011111... 
$ GOMAXPROCS=2 go run hacker-cliché.go
010101010101010101011001100101011010010100110... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the first run, at most one goroutine was executed at a time. Initially, it was the main goroutine, which prints ones. After a period of time, the Go scheduler put it to sleep and woke up the goroutine that prints zeros, giving it a turn to run on the OS thread.&lt;/p&gt;

&lt;p&gt;In the second run, there were two OS threads available, so both goroutines ran simultaneously, printing digits at about the same rate. We must stress that many factors are involved in goroutine scheduling, and the runtime is constantly evolving, so your results may differ from the ones above.&lt;/p&gt;

&lt;p&gt;Exercise 9.6: Measure how the performance of a compute-bound parallel program (see Exercise 8.5) varies with GOMAXPROCS. What is the optimal value on your computer? How many CPUs does your computer have?&lt;/p&gt;

&lt;h3 id=&#34;goroutines-have-no-identity:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Goroutines Have No Identity&lt;/h3&gt;

&lt;p&gt;In most operating systems and programming languages that support multithreading, the current thread has a distinct identity that can be easily obtained as an ordinary value, typically an integer or pointer. This makes it easy to build an abstraction called thread-local storage, which is essentially a global map keyed by thread identity, so that each thread can store and retrieve values independent of other threads.&lt;/p&gt;

&lt;p&gt;Goroutines have no notion of identity that is accessible to the programmer. This is by design, since thread-local storage tends to be abused. For example, in a web server implemented in a language with thread-local storage, it’s common for many functions to find information about the HTTP request on whose behalf they are currently working by looking in that storage.&lt;/p&gt;

&lt;p&gt;However, just as with programs that rely excessively on global variables, this can lead to an unhealthy “action at a distance” in which the behavior of a function is not determined by its arguments alone, but by the identity of the thread in which it runs. Consequently, if the identity of the thread should change—some worker threads are enlisted to help, say—the function misbehaves mysteriously.&lt;/p&gt;

&lt;p&gt;Goencourages a simpler style of programming in which parameters that affect the behavior of a function are explicit. Not only does this make programs easier to read, but it lets us freely assign subtasks of a given function to many different goroutines without worrying about their identity.&lt;/p&gt;

&lt;p&gt;You’ve now learned about all the language features you need for writing Go programs. In the next two chapters, we’ll step back to look at some of the practices and tools that support programming in the large: how to structure a project as a set of packages, and how to obtain, build, test, benchmark, profile, document, and share those packages.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Packages and the Go Tool&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A modest-size program today might contain 10,000 functions. Yet its author need think about only a few of them and design even fewer, because the vast majority were written by others and made available for reuse through packages.&lt;/p&gt;

&lt;p&gt;Gocomes with over 100 standard packages that provide the foundations for most applications. The Go community, a thriving ecosystem of package design, sharing, reuse, and improvement, has published many more, and you can find a searchable index of them at &lt;a href=&#34;http://godoc.org&#34;&gt;http://godoc.org&lt;/a&gt;. In this chapter, we’ll show how to use existing packages and create new ones.&lt;/p&gt;

&lt;p&gt;Goalso comes with the go tool, a sophisticated but simple-to-use command for managing workspaces of Go packages. Since the beginning of the book, we’ve been showing how to use the go tool to download, build, and run example programs. In this chapter, we’ll look at the tool’s underlying concepts and tour more of its capabilities, which include printing documentation and querying metadata about the packages in the workspace. In the next chapter we’ll explore its testing features.&lt;/p&gt;

&lt;h2 id=&#34;introduction:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;The purpose of any package system is to make the design and maintenance of large programs practical by grouping related features together into units that can be easily understood and changed, independent of the other packages of the program. This modularity allows packages to be shared and reused by different projects, distributed within an organization, or made available to the wider world.&lt;/p&gt;

&lt;p&gt;Each package defines a distinct name space that encloses its identifiers. Each name is associated with a particular package, letting us choose short, clear names for the types, functions, and so on that we use most often, without creating conflicts with other parts of the program.&lt;/p&gt;

&lt;p&gt;Packages also provide encapsulation by controlling which names are visible or exported outside the package. Restricting the visibility of package members hides the helper functions and types behind the package’s API, allowing the package maintainer to change the implementation with confidence that no code outside the package will be affected. Restricting visibility also hides variables so that clients can access and update them only through exported functions that preserve internal invariants or enforce mutual exclusion in a concurrent program.&lt;/p&gt;

&lt;p&gt;When we change a file, we must recompile the file’s package and potentially all the packages that depend on it. Go compilation is notably faster than most other compiled languages, even when building from scratch. There are three main reasons for the compiler’s speed. First, all imports must be explicitly listed at the beginning of each source file, so the compiler does not have to read and process an entire file to determine its dependencies. Second, the dependencies of a package form a directed acyclic graph, and because there are no cycles, packages can be compiled separately and perhaps in parallel.
Finally, the object file for a compiled Go package records export information not just for the package itself, but for its dependencies too. When compiling a package, the compiler must read one object file for each import but need not look beyond these files.&lt;/p&gt;

&lt;h2 id=&#34;import-paths:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Import Paths&lt;/h2&gt;

&lt;p&gt;Each package is identified by a unique string called its import path. Import paths are the strings that appear in import declarations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
&amp;quot;fmt&amp;quot; 
&amp;quot;math/rand&amp;quot;
&amp;quot;encoding/json&amp;quot; 

&amp;quot;golang.org/x/net/html&amp;quot; 
&amp;quot;github.com/go-sql-driver/mysql&amp;quot; 
) 


As we mentioned in Section 2.6.1, the Go language specification doesn’t define the meaning of these strings or how to determine a package’s import path, but leaves these issues to the tools. In this chapter, we’ll take a detailed look at how the go tool interprets them, since that’s what the majority of Go programmers use for building, testing, and so on. Other tools do exist, though. For example, Go programmers using Google’s internal multi-language build system follow different rules for naming and locating packages, specifying tests, and so on, that more closely match the conventions of that system. 

For packages you intend to share or publish, import paths should be globally unique. To avoid conflicts, the import paths of all packages other than those from the standard library should start with the Internet domain name of the organization that owns or hosts the package; this also makes it possible to find packages. For example, the declaration above imports an HTML parser maintained by the Go team and a popular third-party MySQL database driver. 

## The Package Declaration 

A package declaration is required at the start of every Go source file. Its main purpose is to determine the default identifier for that package (called the package name) when it is imported by another package. 

For example, every file of the math/rand package starts with package rand , so when you import this package, you can access its members as rand.Int, rand.Float64, and so on. 
package main 
import (
&amp;quot;fmt&amp;quot; 
&amp;quot;math/rand&amp;quot; ) 
func main() {
fmt.Println(rand.Int()) 
} 

Conventionally, the package name is the last segment of the import path, and as a result, two packages may have the same name even though their import paths necessarily differ. For example, the packages whose import paths are math/rand and crypto/rand both have the name rand. We’ll see how to use both in the same program in a moment. 

There are three major exceptions to the “last segment” convention. The first is that a package defining a command (an executable Go program) always has the name main, regardless of the package’s import path. This is a signal to go build (§10.7.3) that it must invoke the linker to make an executable file. 

The second exception is that some files in the directory may have the suffix _test on their package name if the file name ends with _test.go. Such a directory may define two packages: the usual one, plus another one called an external test package. The _test suffix signals to go test that it must build both packages, and it indicates which files belong to each package. External test packages are used to avoid cycles in the import graph arising from dependencies of the test; they are covered in more detail in Section 11.2.4. 

The third exception is that some tools for dependency management append version number suffixes to package import paths, such as &amp;quot;gopkg.in/yaml.v2&amp;quot;. The package name excludes the suffix, so in this case it would be just yaml. 

## Import Declarations 

A Go source file may contain zero or more import declarations immediately after the package declaration and before the first non-import declaration. Each import declaration may specify the import path of a single package, or multiple packages in a parenthesized list. The two forms below are equivalent but the second form is more common. 

import &amp;quot;fmt&amp;quot; 
import &amp;quot;os&amp;quot; 
import (
&amp;quot;fmt&amp;quot; 
&amp;quot;os&amp;quot; 
) 

Imported packages may be grouped by introducing blank lines; such groupings usually indicate different domains. The order is not significant, but by convention the lines of each group are sorted alphabetically. (Both gofmt and goimports will group and sort for you.)

import (
&amp;quot;fmt&amp;quot; 
&amp;quot;html/template&amp;quot;
&amp;quot;os&amp;quot; 

&amp;quot;golang.org/x/net/html&amp;quot;
&amp;quot;golang.org/x/net/ipv4&amp;quot; 
) 


If we need to import two packages whose names are the same, like math/rand and crypto/rand, into a third package, the import declaration must specify an alternative name for at least one of them to avoid a conflict. This is called a renaming import. 

```go
import (&amp;quot;crypto/rand&amp;quot;mrand &amp;quot;math/rand&amp;quot; // alternative name mrand avoids conflict 
) 

The alternative name affects only the importing file. Other files, even ones in the same package, may import the package using its default name, or a different name. 

A renaming import may be useful even when there is no conflict. If the name of the imported package is unwieldy, as is sometimes the case for automatically generated code, an abbreviated name may be more convenient. The same short name should be used consistently to avoid confusion. Choosing an alternative name can help avoid conflicts with common local variable names. For example, in a file with many local variables named path, we might import the standard &amp;quot;path&amp;quot; package as pathpkg. 

Each import declaration establishes a dependency from the current package to the imported package. The go build tool reports an error if these dependencies form a cycle. 

## Blank Imports 

It is an error to import a package into a file but not refer to the name it defines within that file. However, on occasion we must import a package merely for the side effects of doing so: evaluation of the initializer expressions of its package-level variables and execution of its init functions (§2.6.2). To suppress the “unused import” error we would otherwise encounter, we must use a renaming import in which the alternative name is _, the blank identifier. As usual, the blank identifier can never be referenced. 

```go
import _ &amp;quot;image/png&amp;quot; // register PNG decoder 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is known as a blank import. It is most often used to implement a compile-time mechanism whereby the main program can enable optional features by blank-importing additional packages. First we’ll see how to use it, then we’ll see how it works.&lt;/p&gt;

&lt;p&gt;The standard library’s image package exports a Decode function that reads bytes from an io.Reader, figures out which image format was used to encode the data, invokes the appropriate decoder, then returns the resulting image.Image. Using image.Decode, it’s easy to build a simple image converter that reads an image in one format and writes it out in another:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch10/jpeg 
// The jpeg command reads a PNG image from the 
standard input 
// and writes it as a JPEG image to the standard 
output.
package main 
import (
&amp;quot;fmt&amp;quot; 
&amp;quot;image&amp;quot;
&amp;quot;image/jpeg&amp;quot; 
_ &amp;quot;image/png&amp;quot; // register PNG decoder 
&amp;quot;io&amp;quot; 

&amp;quot;os&amp;quot; 
) 

func main() {if err := toJPEG(os.Stdin, os.Stdout); err != nil 
{ 
fmt.Fprintf(os.Stderr, &amp;quot;jpeg: %v\n&amp;quot;, err) 
os.Exit(1) 

}
} 

func toJPEG(in io.Reader, out io.Writer) error {
img, kind, err := image.Decode(in) 
if err != nil {

return err }fmt.Fprintln(os.Stderr, &amp;quot;Input format =&amp;quot;, kind) return jpeg.Encode(out, img, 
&amp;amp;jpeg.Options{Quality: 95}) 
} 


If we feed the output of // gopl.io/ch3/mandelbrot (§3.3) to the converter program, it detects the PNG input format and writes a JPEG version of Figure 3.3. 

```go
$ go build gopl.io/ch3/mandelbrot 
$ go build gopl.io/ch10/jpeg 
$ ./mandelbrot | ./jpeg &amp;gt;mandelbrot.jpg 
Input format = png 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the blank import of image/png. Without that line, the program compiles and links as usual but can no longer recognize or decode input in PNG format:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch10/jpeg 
$ ./mandelbrot | ./jpeg &amp;gt;mandelbrot.jpg 
jpeg: image: unknown format 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here’s how it works. The standard library provides decoders for GIF, PNG, and JPEG, and users may provide others, but to keep executables small, decoders are not included in an application unless explicitly requested. The image.Decode function consults a table of supported formats. Each entry in the table specifies four things: the name of the format; a string that is a prefix of all images encoded this way, used to detect the encoding; a function Decode that decodes an encoded image; and another function DecodeConfig that decodes only the image metadata, such as its size and color space. An entry is added to the table by calling image.RegisterFormat, typically from within the package initializer of the supporting package for each format, like this one in image/png:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package png // image/png 
func Decode(r io.Reader) (image.Image, error) 
func DecodeConfig(r io.Reader) (image.Config, error) 
func init() {
const pngHeader = &amp;quot;\x89PNG\r\n\x1a\n&amp;quot; 
image.RegisterFormat(&amp;quot;png&amp;quot;, pngHeader, Decode, 
DecodeConfig)
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The effect is that an application need only blank-import the package for the format it needs to make the image.Decode function able to decode it.&lt;/p&gt;

&lt;p&gt;The database/sql package uses a similar mechanism to let users install just the database drivers they need. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (&amp;quot;database/mysql&amp;quot; 
_ &amp;quot;github.com/lib/pq&amp;quot; // enable 
support for Postgres 
_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot; // enable 
support for MySQL 
) 
db, err = sql.Open(&amp;quot;postgres&amp;quot;, dbname) // OK 
db, err = sql.Open(&amp;quot;mysql&amp;quot;, dbname) // OK 
db, err = sql.Open(&amp;quot;sqlite3&amp;quot;, dbname) // returns 
error: 

unknown 

driver &amp;quot;sqlite3&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exercise 10.1: Extend the jpeg program so that it converts any supported input format to any output format, using image.Decode to detect the input format and a flag to select the output format.&lt;/p&gt;

&lt;p&gt;Exercise 10.2: Define a generic archive file-reading function capable of reading ZIP files (archive/zip) and POSIX tar files (archive/tar). Use a registration mechanism similar to the one described above so that support for each file format can be plugged in using blank imports.&lt;/p&gt;

&lt;h2 id=&#34;packages-and-naming:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Packages and Naming&lt;/h2&gt;

&lt;p&gt;In this section, we’ll offer some advice on how to follow Go’s distinctive conventions for naming packages and their members.&lt;/p&gt;

&lt;p&gt;When creating a package, keep its name short, but not so short as to be cryptic. The most frequently used packages in the standard library are named bufio, bytes, flag, fmt, http, io, json, os, sort, sync, and time.&lt;/p&gt;

&lt;p&gt;Be descriptive and unambiguous where possible. For example, don’t name a utility package util when a name such as imageutil or ioutil is specific yet still concise. Avoid choosing package names that are commonly used for related local variables, or you may compel the package’s clients to use renaming imports, as with the path package.&lt;/p&gt;

&lt;p&gt;Package names usually take the singular form. The standard packages bytes, errors, and strings use the plural to avoid hiding the corresponding predeclared types and, in the case of go/types, to avoid conflict with a keyword.&lt;/p&gt;

&lt;p&gt;Avoid package names that already have other connotations. For example, we originally used the name temp for the temperature conversion package in Section 2.5, but that didn’t last long. It was a terrible idea because “temp” is an almost universal synonym for “temporary.” We went through a brief period with the name temperature, but that was too long and didn’t say what the package did. In the end, it became tempconv, which is shorter and parallel with strconv.&lt;/p&gt;

&lt;p&gt;Now let’s turn to the naming of package members. Since each reference to a member of another package uses a qualified identifier such as fmt.Println, the burden of describing the package member is borne equally by the package name and the member name. We need not mention the concept of formatting in Println because the package name fmt does that already. When designing a package, consider how the two parts of a qualified identifier work together, not the member name alone. Here are some characteristic examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;bytes.Equal flag.Int http.Get 
json.Marshal 

We can identify some common naming patterns. The strings package provides a number of independent functions for manipulating strings: 

```go
package strings 
func Index(needle, haystack string) int 
type Replacer struct{ /* ... */ } 
func NewReplacer(oldnew ...string) *Replacer 
type Reader struct{ /* ... */ } 
func NewReader(s string) *Reader The word string does not appear in any of their names. Clients refer to them as strings.Index, strings.Replacer, and so on. 
Other packages that we might describe as single-type packages, such as html/template and math/rand, expose one principal data type plus its methods, and often a New function to create instances. 
package rand // &amp;quot;math/rand&amp;quot; 
type Rand struct{ /* ... */ } 
func New(source Source) *Rand This can lead to repetition, as in template.Template or rand.Rand, which is why the names of these kinds of packages are often especially short. 
At the other extreme, there are packages like net/http that have a lot of names without a lot of structure, because they perform a complicated task. Despite having over twenty types and many more functions, the package’s most important members have the simplest names: Get, Post, Handle, Error, Client, Server. 

## The Go Tool 

The rest of this chapter concerns the go tool, which is used for downloading, querying, formatting, building, testing, and installing packages of Go code. 

The go tool combines the features of a diverse set of tools into one command set. It is a package manager (analogous to apt or rpm) that answers queries about its inventory of packages, computes their dependencies, and downloads them from remote version-control systems. It is a build system that computes file dependencies and invokes compilers, assemblers, and linkers, although it is intentionally less complete than the standard Unix make. And it is a test driver, as we will see in Chapter 11. 

Its command-line interface uses the “Swiss army knife” style, with over a dozen subcommands, some of which we have already seen, like get, run, build, and fmt. You can run go help to see the index of its built-in documentation, but for reference, we’ve listed the most commonly used commands below: 

```go
$ go 
... 
build compile packages and dependencies 
clean remove object files 
doc show documentation for package or symbolenv print Go environment information 
fmt run gofmt on package sources 
get download and install packages and 
dependencies
install compile and install packages and 
dependencies
list list packages 
run compile and run Go program 
test test packages 
version print Go version 
vet run go tool vet on packages 
Use &amp;quot;go help [command]&amp;quot; for more information about a 
command. 
... 


To keep the need for configuration to a minimum, the go tool relies heavily on conventions. For example, given the name of a Go source file, the tool can find its enclosing package, because each directory contains a single package and the import path of a package corresponds to the directory hierarchy in the workspace. Given the import path of a package, the tool can find the corresponding directory in which it stores object files. It can also find the URL of the server that hosts the source code repository. 

###Workspace Organization 

The only configuration most users ever need is the GOPATH environment variable, which specifies the root of the workspace. When switching to a different workspace, users update the value of GOPATH. For instance, we set GOPATH to $HOME/gobook while working on this book: 
$ export GOPATH=$HOME/gobook 
$ go get gopl.io/... 


After you download all the programs for this book using the command above, your workspace will contain a hierarchy like this one: 
GOPATH/
src/

gopl.io/
.git/
ch1/

helloworld/main.go dup/main.go ... 
golang.org/x/net/
.git/
html/

parse.go 
node.go ... 
bin/
helloworld 
dup 

pkg/
darwin_amd64/ 
... 

GOPATH has three subdirectories. The src subdirectory holds source code. Each package resides in a directory whose name relative to $GOPATH/src is the package’s import path, such as // gopl.io/ch1/helloworld. Observe that a single GOPATH workspace contains multiple version-control repositories beneath src, such as gopl.io or golang.org. The pkg subdirectory is where the build tools store compiled packages, and the bin subdirectory holds executable programs like helloworld. 

A second environment variable, GOROOT, specifies the root directory of the Go distribution, which provides all the packages of the standard library. The directory structure beneath GOROOT resembles that of GOPATH, so, for example, the source files of the fmt package reside in the $GOROOT/src/fmt directory. Users never need to set GOROOT since, by default, the go tool will use the location where it was installed. 

The go env command prints the effective values of the environment variables relevant to the toolchain, including the default values for the missing ones. GOOS specifies the target operating system (for example, android, linux, darwin, or windows) and GOARCH specifies the target processor architecture, such as amd64, 386, or arm. Although GOPATH is the only variable you must set, the others occasionally appear in our explanations. 

$ go env 
GOPATH=&amp;quot;/home/gopher/gobook&amp;quot;
GOROOT=&amp;quot;/usr/local/go&amp;quot;
GOARCH=&amp;quot;amd64&amp;quot; 
GOOS=&amp;quot;darwin&amp;quot; 
... 

###Downloading Packages 

When using the go tool, a package’s import path indicates not only where to find it in the local workspace, but where to find it on the Internet so that go get can retrieve and update it. 

The go get command can download a single package or an entire subtree or repository using the ... notation, as in the previous section. The tool also computes and downloads all the dependencies of the initial packages, which is why the golang.org/x/net/html package appeared in the workspace in the previous example. 

Once go get has downloaded the packages, it builds them and then installs the libraries and commands. We’ll look at the details in the next section, but an example will show how straightforward the process is. The first command below gets the golint tool, which checks for common style problems in Go source code. The second command runs golint on // gopl.io/ch2/popcount from Section 2.6.2. It helpfully reports that we have forgotten to write a doc comment for the package: 

```go
$ go get github.com/golang/lint/golint 
$ $GOPATH/bin/golint // gopl.io/ch2/popcount
src/// gopl.io/ch2/popcount/main.go:1:1:
package comment should be of the form &amp;quot;Package 
popcount ...&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The go get command has support for popular code-hosting sites like GitHub, Bitbucket, and Launchpad and can make the appropriate requests to their version-control systems. For less well-known sites, you may have to indicate which version-control protocol to use in the import path, such as Git or Mercurial. Run go help importpath for the details.&lt;/p&gt;

&lt;p&gt;The directories that go get creates are true clients of the remote repository, not just copies of the files, so you can use version-control commands to see a diff of local edits you’ve made or to update to a different revision. For example, the golang.org/x/net directory is a Git client:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ cd $GOPATH/src/golang.org/x/net 
$ git remote -v 
origin https://go.googlesource.com/net (fetch) 
origin https://go.googlesource.com/net (push) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the apparent domain name in the package’s import path, golang.org, differs from the actual domain name of the Git server, go.googlesource.com. This is a feature of the go tool that lets packages use a custom domain name in their import path while being hosted by a generic service such as googlesource.com or github.com. HTML pages beneath &lt;a href=&#34;https://golang.org/x/net/html&#34;&gt;https://golang.org/x/net/html&lt;/a&gt; include the metadata shown below, which redirects the go tool to the Git repository at the actual hosting site:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch1/fetch 
$ ./fetch https://golang.org/x/net/html | grep go-
import
&amp;lt;meta name=&amp;quot;go-import&amp;quot;
content=&amp;quot;golang.org/x/net git
https://go.googlesource.com/net&amp;quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you specify the -u flag, go get will ensure that all packages it visits, including dependencies, are updated to their latest version before being built and installed. Without that flag, packages that already exist locally will not be updated.&lt;/p&gt;

&lt;p&gt;The go get -u command generally retrieves the latest version of each package, which is convenient when you’re getting started but may be inappropriate for deployed projects, where precise control of dependencies is critical for release hygiene. The usual solution to this problem is to vendor the code, that is, to make a persistent local copy of all the necessary dependencies, and to update this copy carefully and deliberately. Prior to Go 1.5, this required changing those packages’ import paths, so our copy of golang.org/x/net/html would become gopl.io/vendor/golang.org/x/net/html. More recent versions of the go tool support vendoring directly, though we don’t have space to show the details here. See Vendor Directories in the output of the go help gopath command.&lt;/p&gt;

&lt;p&gt;Exercise 10.3: Using fetch http://// gopl.io/ch1/helloworld?go­get=1, find out which service hosts the code samples for this book. (HTTP requests from go get include the go-get parameter so that servers can distinguish them from ordinary browser requests.)&lt;/p&gt;

&lt;p&gt;###Building Packages&lt;/p&gt;

&lt;p&gt;The go build command compiles each argument package. If the package is a library, the result is discarded; this merely checks that the package is free of compile errors. If the package is named main, go build invokes the linker to create an executable in the current directory; the name of the executable is taken from the last segment of the package’s import path.&lt;/p&gt;

&lt;p&gt;Since each directory contains one package, each executable program, or command in Unix terminology, requires its own directory. These directories are sometimes children of a directory named cmd, such as the golang.org/x/tools/cmd/godoc command which serves Go package documentation through a web interface (§10.7.4).&lt;/p&gt;

&lt;p&gt;Packages may be specified by their import paths, as we saw above, or by a relative directory name, which must start with a . or .. segment even if this would not ordinarily be required. If no argument is provided, the current directory is assumed. Thus the following commands build the same package, though each writes the executable to the directory in which go build is run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ cd $GOPATH/src/// gopl.io/ch1/helloworld 
$ go build 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ cd anywhere 
$ go build gopl.io/ch1/helloworld 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ cd $GOPATH 
$ go build ./src/// gopl.io/ch1/helloworld 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but not:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ cd $GOPATH 
$ go build src/// gopl.io/ch1/helloworld 
Error: cannot find package
&amp;quot;src/// gopl.io/ch1/helloworld&amp;quot;. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Packages may also be specified as a list of file names, though this tends to be used only for small programs and one-off experiments. If the package name is main, the executable name comes from the basename of the first .go file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ cat quoteargs.go
package main 

import (
&amp;quot;fmt&amp;quot; 
&amp;quot;os&amp;quot; 

) 
func main() {
fmt.Printf(&amp;quot;%q\n&amp;quot;, os.Args[1:]) 
}
$ go build quoteargs.go 
$ ./quoteargs one &amp;quot;two three&amp;quot; four\ five 
[&amp;quot;one&amp;quot; &amp;quot;two three&amp;quot; &amp;quot;four five&amp;quot;] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Particularly for throwaway programs like this one, we want to run the executable as soon as we’ve built it. The go run command combines these two steps:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go run quoteargs.go one &amp;quot;two three&amp;quot; four\ five 
[&amp;quot;one&amp;quot; &amp;quot;two three&amp;quot; &amp;quot;four five&amp;quot;] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first argument that doesn’t end in .go is assumed to be the beginning of the list of arguments to the Go executable.&lt;/p&gt;

&lt;p&gt;By default, the go build command builds the requested package and all its dependencies, then throws away all the compiled code except the final executable, if any. Both the dependency analysis and the compilation are surprisingly fast, but as projects grow to dozens of packages and hundreds of thousands of lines of code, the time to recompile dependencies can become noticeable, potentially several seconds, even when those dependencies haven’t changed at all.&lt;/p&gt;

&lt;p&gt;The go install command is very similar to go build , except that it saves the compiled code for each package and command instead of throwing it away. Compiled packages are saved beneath the $GOPATH/pkg directory corresponding to the src directory in which the source resides, and command executables are saved in the $GOPATH/bin directory. (Many users put $GOPATH/bin on their executable search path.) Thereafter, go build and go install do not run the compiler for those packages and commands if they have not changed, making subsequent builds much faster. For convenience, go build -i installs the packages that are dependencies of the build target.&lt;/p&gt;

&lt;p&gt;Since compiled packages vary by platform and architecture, go install saves them beneath a subdirectory whose name incorporates the values of the GOOS and GOARCH environment variables. For example, on a Mac the golang.org/x/net/html package is compiled and installed in the file golang.org/x/net/html.a under $GOPATH/pkg/darwin_amd64.&lt;/p&gt;

&lt;p&gt;It is straightforward to cross-compile a Go program, that is, to build an executable intended for a different operating system or CPU. Just set the GOOS or GOARCH variables during the build. The cross program prints the operating system and architecture for which it was built:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch10/cross 
func main() {
fmt.Println(runtime.GOOS, runtime.GOARCH) 
} 


The following commands produce 64-bit and 32-bit executables respectively: 

```go
$ go build gopl.io/ch10/cross 
$ ./cross
darwin amd64 
$ GOARCH=386 go build gopl.io/ch10/cross 
$ ./cross
darwin 386 

Some packages may need to compile different versions of the code for certain platforms or processors, to deal with low-level portability issues or to provide optimized versions of important routines, for instance. If a file name includes an operating system or processor architecture name like net_linux.go or asm_amd64.s, then the go tool will compile the file only when building for that target. Special comments called build tags give more fine-grained control. For example, if a file contains this comment: 

// +build linux darwin 

before the package declaration (and its doc comment), go build will compile it only when building for Linux or Mac OS X, and this comment says never to compile the file: 
// +build ignore 

For more details, see the Build Constraints section of the go/build package’s documentation: 
$ go doc go/build 

###Documenting Packages 

Go style strongly encourages good documentation of package APIs. Each declaration of an exported package member and the package declaration itself should be immediately preceded by a comment explaining its purpose and usage. 


Godoc comments are always complete sentences, and the first sentence is usually a summary that starts with the name being declared. Function parameters and other identifiers are mentioned without quotation or markup. For example, here’s the doc comment for fmt.Fprintf: 

```go
// Fprintf formats according to a format specifier and 
writes to w. 
// It returns the number of bytes written and any 
write error encountered. 
func Fprintf(w io.Writer, format string, a 
...interface{}) (int, error) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The details of Fprintf’s formatting are explained in a doc comment associated with the fmt package itself. A comment immediately preceding a package declaration is considered the doc comment for the package as a whole. There must be only one, though it may appear in any file. Longer package comments may warrant a file of their own; fmt’s is over 300 lines. This file is usually called doc.go.&lt;/p&gt;

&lt;p&gt;Good documentation need not be extensive, and documentation is no substitute for simplicity. Indeed, Go’s conventions favor brevity and simplicity in documentation as in all things, since documentation, like code, requires maintenance too. Many declarations can be explained in one well-worded sentence, and if the behavior is truly obvious, no comment is needed.&lt;/p&gt;

&lt;p&gt;Throughout the book, as space permits, we’ve preceded many declarations by doc comments, but you will find better examples as you browse the standard library. Two tools can help you do that.&lt;/p&gt;

&lt;p&gt;The go doc tool prints the declaration and doc comment of the entity specified on the command line, which may be a package:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go doc time 
package time // import &amp;quot;time&amp;quot; 
Package time provides functionality for measuring and 
displaying time. 
const Nanosecond Duration = 1 ... 
func After(d Duration) &amp;lt;-chan Time 
func Sleep(d Duration) 
func Since(t Time) Duration 
func Now() Time 
type Duration int64 
type Time struct { ... } 
...many more... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or a package member:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go doc time.Since 
func Since(t Time) Duration Since returns the time elapsed since t. 

It is shorthand for time.Now().Sub(t). 
or a method: 

```go
$ go doc time.Duration.Seconds 
func (d Duration) Seconds() float64 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seconds returns the duration as a floating-point number of seconds.&lt;/p&gt;

&lt;p&gt;The tool does not need complete import paths or correct identifier case. This command prints the documentation of (*json.Decoder).Decode from the encoding/json package:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go doc json.decode 
func (dec *Decoder) Decode(v interface{}) error 
Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v. 

The second tool, confusingly named godoc, serves cross-linked HTML pages that provide the same information as go doc and much more. The godoc server at https://golang.org/pkg covers the standard library. Figure 10.1 shows the documentation for the time package, and in Section 11.6 we’ll see godoc’s interactive display of example programs. The godoc server at https://godoc.org has a searchable index of thousands of open-source packages. 


You can also run an instance of godoc in your workspace if you want to browse your own packages. Visit http://localhost:8000/pkg in your browser while running this command: 
$ godoc -http :8000 

Its -analysis=type and -analysis=pointer flags augment the documentation and the source code with the results of advanced static analysis. 

###Internal Packages 


The package is the most important mechanism for encapsulation in Go programs. Unexported identifiers are visible only within the same package, and exported identifiers are visible to the world. 

Sometimes, though, a middle ground would be helpful, a way to define identifiers that are visible to a small set of trusted packages, but not to everyone. For example, when we’re breaking up a large package into more manageable parts, we may not want to reveal the interfaces between those parts to other packages. Or we may want to share utility functions across several packages of a project without exposing them more widely. Or perhaps we just want to experiment with a new package without prematurely committing to its API, by putting it “on probation” with a limited set of clients. 


To address these needs, the go build tool treats a package specially if its import path contains a path segment named internal. Such packages are called internal packages. An internal package may be imported only by another package that is inside the tree rooted at the parent of the internal directory. For example, given the packages below, net/http/internal/chunked can be imported from net/http/httputil or net/http, but not from net/url. However, net/url may import net/http/httputil. 

net/http
net/http/internal/chunked
net/http/httputil
net/url 
###Querying Packages 

The go list tool reports information about available packages. In its simplest form, go list tests whether a package is present in the workspace and prints its import path if so: 

```go
$ go list github.com/go-sql-driver/mysql
github.com/go-sql-driver/mysql 

Anargument to go list may contain the “...” wildcard, which matches any substring of a package’s import path. We can use it to enumerate all the packages within a Go workspace: 
$ go list ... 
archive/tar 
archive/zip
bufio 
bytes
cmd/addr2line
cmd/api 
...many more... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or within a specific subtree:
$ go list // gopl.io/ch3/&amp;hellip;
// gopl.io/ch3/basename1
// gopl.io/ch3/basename2
// gopl.io/ch3/comma
// gopl.io/ch3/mandelbrot
// gopl.io/ch3/netflag
// gopl.io/ch3/printints
// gopl.io/ch3/surface&lt;/p&gt;

&lt;p&gt;or related to a particular topic:
$ go list &amp;hellip;xml&amp;hellip;
encoding/xml
// gopl.io/ch7/xmlselect&lt;/p&gt;

&lt;p&gt;The go list command obtains the complete metadata for each package, not just the import path, and makes this information available to users or other tools in a variety of formats. The -json flag causes go list to print the entire record of each package in JSON format:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go list -json hash 
{ &amp;quot;Dir&amp;quot;: &amp;quot;/home/gopher/go/src/hash&amp;quot;,&amp;quot;ImportPath&amp;quot;: &amp;quot;hash&amp;quot;, &amp;quot;Name&amp;quot;: &amp;quot;hash&amp;quot;, &amp;quot;Doc&amp;quot;: &amp;quot;Package hash provides interfaces for hash 
functions.&amp;quot;,
&amp;quot;Target&amp;quot;:

&amp;quot;/home/gopher/go/pkg/darwin_amd64/hash.a&amp;quot;,
&amp;quot;Goroot&amp;quot;: true,
&amp;quot;Standard&amp;quot;: true, 

&amp;quot;Root&amp;quot;: &amp;quot;/home/gopher/go&amp;quot;,
&amp;quot;GoFiles&amp;quot;: [

&amp;quot;hash.go&amp;quot; 
],
&amp;quot;Imports&amp;quot;: [

&amp;quot;io&amp;quot; 
],
&amp;quot;Deps&amp;quot;: [

&amp;quot;errors&amp;quot;,
&amp;quot;io&amp;quot;,
&amp;quot;runtime&amp;quot;,
&amp;quot;sync&amp;quot;,
&amp;quot;sync/atomic&amp;quot;,
&amp;quot;unsafe&amp;quot; 

]
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The -f flag lets users customize the output format using the template language of package text/template (§4.6). This command prints the transitive dependencies of the strconv package, separated by spaces:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go list -f &#39;{{join .Deps &amp;quot; &amp;quot;}}&#39; strconv 
errors math runtime unicode/utf8 unsafe 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and this command prints the direct imports of each package in the compress subtree of the standard library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go list -f &#39;{{.ImportPath}} -&amp;gt; {{join .Imports &amp;quot; &amp;quot;}}&#39; compress/...compress/bzip2 -&amp;gt; bufio io sort compress/flate -&amp;gt; bufio fmt io math sort strconv compress/gzip -&amp;gt; bufio compress/flate errors fmt hash hash/crc32 io time compress/lzw -&amp;gt; bufio errors fmt io compress/zlib -&amp;gt; bufio compress/flate errors fmt hash hash/adler32 io 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The go list command is useful for both one-off interactive queries and for build and test automation scripts. We’ll use it again in Section 11.2.4. For more information, including the set of available fields and their meaning, see the output of go help list .&lt;/p&gt;

&lt;p&gt;In this chapter, we’ve explained all the important subcommands of the go tool— except one. In the next chapter, we’ll see how the go test command is used for testing Go programs.&lt;/p&gt;

&lt;p&gt;Exercise 10.4: Construct a tool that reports the set of all packages in the workspace that transitively depend on the packages specified by the arguments. Hint: you will need to run go list twice, once for the initial packages and once for all packages. You may want to parse its JSON output using the encoding/json package (§4.5).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Testing&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Maurice Wilkes, the developer of EDSAC, the first stored-program computer, had a startling insight while climbing the stairs of his laboratory in 1949. In Memoirs of a Computer Pioneer, he recalled, “The realization came over me with full force that a good part of the remainder of my life was going to be spent in finding errors in my own programs.” Surely every programmer of a stored-program computer since then can sympathize with Wilkes, though perhaps not without some bemusement at his naïveté about the difficulties of software construction.&lt;/p&gt;

&lt;p&gt;Programs today are far larger and more complex than in Wilkes’s time, of course, and a great deal of effort has been spent on techniques to make this complexity manageable. Two techniques in particular stand out for their effectiveness. The first is routine peer review of programs before they are deployed. The second, the subject of this chapter, is testing.&lt;/p&gt;

&lt;p&gt;Testing, by which we implicitly mean automated testing, is the practice of writing small programs that check that the code under test (the production code) behaves as expected for certain inputs, which are usually either carefully chosen to exercise certain features or randomized to ensure broad coverage.&lt;/p&gt;

&lt;p&gt;The field of software testing is enormous. The task of testing occupies all programmers some of the time and some programmers all of the time. The literature on testing includes thousands of printed books and millions of words of blog posts. In every mainstream programming language, there are dozens of software packages intended for test construction, some with a great deal of theory, and the field seems to attract more than a few prophets with cult-like followings. It is almost enough to convince programmers that to write effective tests they must acquire a whole new set of skills.&lt;/p&gt;

&lt;p&gt;Go’s approach to testing can seem rather low-tech in comparison. It relies on one command, go test , and a set of conventions for writing test functions that go test can run. The comparatively lightweight mechanism is effective for pure testing, and it extends naturally to benchmarks and systematic examples for documentation.&lt;/p&gt;

&lt;p&gt;In practice, writing test code is not much different from writing the original program itself. We write short functions that focus on one part of the task. We have to be careful of boundary conditions, think about data structures, and reason about what results a computation should produce from suitable inputs. But this is the same process as writing ordinary Go code; it needn’t require new notations, conventions, and tools.&lt;/p&gt;

&lt;h2 id=&#34;the-go-test-tool:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;The go test Tool&lt;/h2&gt;

&lt;p&gt;The go test subcommand is a test driver for Go packages that are organized according to certain conventions. In a package directory, files whose names end with _test.go are not part of the package ordinarily built by go build but are a part of it when built by go test .&lt;/p&gt;

&lt;p&gt;Within *_test.go files, three kinds of functions are treated specially: tests, benchmarks, and examples. A test function, which is a function whose name begins with Test, exercises some program logic for correct behavior; go test calls the test function and reports the result, which is either PASS or FAIL.A benchmark function has a name beginning with Benchmark and measures the performance of some operation; go test reports the mean execution time of the operation. And an example function, whose name starts with Example, provides machine-checked documentation. We will cover tests in detail in Section 11.2, benchmarks in Section 11.4, and examples in Section 11.6.&lt;/p&gt;

&lt;p&gt;The go test tool scans the *_test.go files for these special functions, generates a temporary main package that calls them all in the proper way, builds and runs it, reports the results, and then cleans up.&lt;/p&gt;

&lt;h2 id=&#34;test-functions:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Test Functions&lt;/h2&gt;

&lt;p&gt;Each test file must import the testing package. Test functions have the following signature:
func TestName(t *testing.T) {
// &amp;hellip;
}&lt;/p&gt;

&lt;p&gt;Test function names must begin with Test; the optional suffix Name must begin with a capital letter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestSin(t *testing.T) { /* ... */ } 
func TestCos(t *testing.T) { /* ... */ } 
func TestLog(t *testing.T) { /* ... */ } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The t parameter provides methods for reporting test failures and logging additional information. Let’s define an example package // gopl.io/ch11/word1, containing a single function IsPalindrome that reports whether a string reads the same forward and backward. (This implementation tests every byte twice if the string is a palindrome; we’ll come back to that shortly.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch11/word1 
// Package word provides utilities for word games. 
package word 

// IsPalindrome reports whether s reads the same 
forward and backward. 
// (Our first attempt.) 
func IsPalindrome(s string) bool {

for i := range s {
if s[i] != s[len(s)-1-i] { 
return false 
}
} 

return true 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the same directory, the file word_test.go contains two test functions named TestPalindrome and TestNonPalindrome. Each checks that IsPalindrome gives the right answer for a single input and reports failures using t.Error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package word 
import &amp;quot;testing&amp;quot; 
func TestPalindrome(t *testing.T) { 
if !IsPalindrome(&amp;quot;detartrated&amp;quot;) {

t.Error(`IsPalindrome(&amp;quot;detartrated&amp;quot;) = false`) }if !IsPalindrome(&amp;quot;kayak&amp;quot;) {
t.Error(`IsPalindrome(&amp;quot;kayak&amp;quot;) = false`) 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;func TestNonPalindrome(t *testing.T) { if IsPalindrome(&amp;ldquo;palindrome&amp;rdquo;) {t.Error(&lt;code&gt;IsPalindrome(&amp;quot;palindrome&amp;quot;) = true&lt;/code&gt;) }}&lt;/p&gt;

&lt;p&gt;A go test (or go build ) command with no package arguments operates on the package in the current directory. We can build and run the tests with the following command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ cd $GOPATH/src/// gopl.io/ch11/word1 
$ go test 
ok // gopl.io/ch11/word1 0.008s 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Satisfied, we ship the program, but no sooner have the launch party guests departed than the bug reports start to arrive. A French user named Noelle Eve Elleon complains that IsPalindrome doesn’t recognize “été.” Another, from Central America, is disappointed that it rejects “A man, a plan, a canal: Panama.” These specific and small bug reports naturally lend themselves to new test cases.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestFrenchPalindrome(t *testing.T) { 
if !IsPalindrome(&amp;quot;été&amp;quot;) {
t.Error(`IsPalindrome(&amp;quot;été&amp;quot;) = false`) 
}
} 

func TestCanalPalindrome(t *testing.T) { 
input := &amp;quot;A man, a plan, a canal: Panama&amp;quot; 
if !IsPalindrome(input) {

t.Errorf(`IsPalindrome(%q) = false`, input) }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To avoid writing the long input string twice, we use Errorf, which provides formatting like Printf.&lt;/p&gt;

&lt;p&gt;When the two new tests have been added, the go test command fails with informative error messages.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test 
---FAIL: TestFrenchPalindrome (0.00s) 
word_test.go:28: IsPalindrome(&amp;quot;été&amp;quot;) = false 
---FAIL: TestCanalPalindrome (0.00s) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;word_test.go:35: IsPalindrome(&amp;ldquo;A man, a plan, a canal: Panama&amp;rdquo;) = false FAIL FAIL // gopl.io/ch11/word1 0.014s&lt;/p&gt;

&lt;p&gt;It’s good practice to write the test first and observe that it triggers the same failure described by the user’s bug report. Only then can we be confident that whatever fix we come up with addresses the right problem.&lt;/p&gt;

&lt;p&gt;As a bonus, running go test is usually quicker than manually going through the steps described in the bug report, allowing us to iterate more rapidly. If the test suite contains many slow tests, we may make even faster progress if we’re selective about which ones we run.&lt;/p&gt;

&lt;p&gt;The -v flag prints the name and execution time of each test in the package:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test -v 
=== RUN TestPalindrome 
---PASS: TestPalindrome (0.00s) 
=== RUN TestNonPalindrome 
---PASS: TestNonPalindrome (0.00s) 
=== RUN TestFrenchPalindrome 
---FAIL: TestFrenchPalindrome (0.00s) 

word_test.go:28: IsPalindrome(&amp;quot;été&amp;quot;) = false 
=== RUN TestCanalPalindrome 
---FAIL: TestCanalPalindrome (0.00s) 

word_test.go:35: IsPalindrome(&amp;quot;A man, a plan, a canal: Panama&amp;quot;) = false FAIL exit status 1 FAIL // gopl.io/ch11/word1 0.017s 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the -run flag, whose argument is a regular expression, causes go test to run only those tests whose function name matches the pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test -v -run=&amp;quot;French|Canal&amp;quot; 
=== RUN TestFrenchPalindrome 
---FAIL: TestFrenchPalindrome (0.00s) 

word_test.go:28: IsPalindrome(&amp;quot;été&amp;quot;) = false 
=== RUN TestCanalPalindrome 
---FAIL: TestCanalPalindrome (0.00s) 

word_test.go:35: IsPalindrome(&amp;quot;A man, a plan, a canal: Panama&amp;quot;) = false FAIL exit status 1 FAIL // gopl.io/ch11/word1 0.014s 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, once we’ve gotten the selected tests to pass, we should invoke go test with no flags to run the entire test suite one last time before we commit the change.&lt;/p&gt;

&lt;p&gt;Now our task is to fix the bugs. A quick investigation reveals the cause of the first bug to be IsPalindrome’s use of byte sequences, not rune sequences, so that non-ASCII characters such as the é in &amp;ldquo;été&amp;rdquo; confuse it. The second bug arises from not ignoring spaces, punctuation, and letter case.
Chastened, we rewrite the function more carefully:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch11/word2 
// Package word provides utilities for word games. 
package word 

import &amp;quot;unicode&amp;quot; 
// IsPalindrome reports whether s reads the same 
forward and backward. 
// Letter case is ignored, as are non-letters. 
func IsPalindrome(s string) bool {

var letters []rune 
for _, r := range s {
if unicode.IsLetter(r) {
letters = append(letters, 
unicode.ToLower(r))

}
}
for i := range letters {

if letters[i] != letters[len(letters)-1-i] { return false 
}
}
return true 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also write a more comprehensive set of test cases that combines all the previous ones and a number of new ones into a table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestIsPalindrome(t *testing.T) { 
var tests = []struct { 

input string 
want bool 

}{ {&amp;quot;&amp;quot;, true}, {&amp;quot;a&amp;quot;, true}, {&amp;quot;aa&amp;quot;, true}, {&amp;quot;ab&amp;quot;, false},{&amp;quot;kayak&amp;quot;, true},{&amp;quot;detartrated&amp;quot;, true}, {&amp;quot;A man, a plan, a canal: Panama&amp;quot;, true}, {&amp;quot;Evil I did dwell; lewd did I live.&amp;quot;, true}, {&amp;quot;Able was I ere I saw Elba&amp;quot;, true}, {&amp;quot;été&amp;quot;, true}, {&amp;quot;Et se resservir, ivresse reste.&amp;quot;, true}, {&amp;quot;palindrome&amp;quot;, false}, // non-palindrome {&amp;quot;desserts&amp;quot;, false}, // semi-palindrome 
}
for _, test := range tests {
if got := IsPalindrome(test.input); got != 
test.want { 
t.Errorf(&amp;quot;IsPalindrome(%q) = %v&amp;quot;, 
test.input, got) 
}
}
} 


Our new tests pass: 

```go
$ go test // gopl.io/ch11/word2 
ok // gopl.io/ch11/word2 0.015s 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This style of table-driven testing is very common in Go. It is straightforward to add new table entries as needed, and since the assertion logic is not duplicated, we can invest more effort in producing a good error message.&lt;/p&gt;

&lt;p&gt;The output of a failing test does not include the entire stack trace at the moment of the call to t.Errorf. Nor does t.Errorf cause a panic or stop the execution of the test, unlike assertion failures in many test frameworks for other languages. Tests are independent of each other. If an early entry in the table causes the test to fail, later table entries will still be checked, and thus we may learn about multiple failures during a single run.&lt;/p&gt;

&lt;p&gt;When we really must stop a test function, perhaps because some initialization code failed or to prevent a failure already reported from causing a confusing cascade of others, we use t.Fatal or t.Fatalf. These must be called from the same goroutine as the Test function, not from another one created during the test.&lt;/p&gt;

&lt;p&gt;Test failure messages are usually of the form &amp;ldquo;f(x) = y, want z&amp;rdquo; , where f(x) explains the attempted operation and its input, y is the actual result, and z the expected result. Where convenient, as in our palindrome example, actual Go syntax is used for the f(x) part. Displaying x is particularly important in a table-driven test, since a given assertion is executed many times with different values.&lt;/p&gt;

&lt;p&gt;Avoid boilerplate and redundant information. When testing a boolean function such as IsPalindrome, omit the want z part since it adds no information. If x, y, or z is lengthy, print a concise summary of the relevant parts instead. The author of a test should strive to help the programmer who must diagnose a test failure.&lt;/p&gt;

&lt;p&gt;Exercise 11.1: Write tests for the charcount program in Section 4.3.&lt;/p&gt;

&lt;p&gt;Exercise 11.2: Write a set of tests for IntSet (§6.5) that checks that its behavior after each operation is equivalent to a set based on built-in maps. Save your implementation for benchmarking in Exercise 11.7.&lt;/p&gt;

&lt;h3 id=&#34;randomized-testing:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Randomized Testing&lt;/h3&gt;

&lt;p&gt;Table-driven tests are convenient for checking that a function works on inputs carefully selected to exercise interesting cases in the logic. Another approach, randomized testing, explores a broader range of inputs by constructing inputs at random.&lt;/p&gt;

&lt;p&gt;How do we know what output to expect from our function, given a random input? There are two strategies. The first is to write an alternative implementation of the function that uses a less efficient but simpler and clearer algorithm, and check that both implementations give the same result. The second is to create input values according to a pattern so that we know what output to expect.&lt;/p&gt;

&lt;p&gt;The example below uses the second approach: the randomPalindrome function generates words that are known to be palindromes by construction.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;math/rand&amp;quot; 
// randomPalindrome returns a palindrome whose length and contents // are derived from the pseudo-random number generator rng.func randomPalindrome(rng *rand.Rand) string { 
n := rng.Intn(25) // random length up to 24 
runes := make([]rune, n) 
for i := 0; i &amp;lt; (n+1)/2; i++ {

r := rune(rng.Intn(0x1000)) // random rune up 
to &#39;\u0999&#39; 
runes[i] = r 
runes[n-1-i] = r 

}
return string(runes) 
} 

func TestRandomPalindromes(t *testing.T) { // Initialize a pseudo-random number generator. seed := time.Now().UTC().UnixNano()t.Logf(&amp;quot;Random seed: %d&amp;quot;, seed) rng := rand.New(rand.NewSource(seed)) 
for     i := 0; i &amp;lt; 1000; i++ {
p := randomPalindrome(rng) 
if !IsPalindrome(p) {

t.Errorf(&amp;quot;IsPalindrome(%q) = false&amp;quot;, p) }}} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since randomized tests are nondeterministic, it is critical that the log of the failing test record sufficient information to reproduce the failure. In our example, the input p to IsPalindrome tells us all we need to know, but for functions that accept more complex inputs, it may be simpler to log the seed of the pseudo-random number generator (as we do above) than to dump the entire input data structure. Armed with that seed value, we can easily modify the test to replay the failure deterministically.&lt;/p&gt;

&lt;p&gt;By using the current time as a source of randomness, the test will explore novel inputs each time it is run, over the entire course of its lifetime. This is especially valuable if your project uses an automated system to run all its tests periodically.&lt;/p&gt;

&lt;p&gt;Exercise 11.3: TestRandomPalindromes only tests palindromes. Write a randomized test that generates and verifies non-palindromes.&lt;/p&gt;

&lt;p&gt;Exercise 11.4: Modify randomPalindrome to exercise IsPalindrome’s handling of punctuation and spaces.
###Testing a Command&lt;/p&gt;

&lt;p&gt;The go test tool is useful for testing library packages, but with a little effort we can use it to test commands as well. A package named main ordinarily produces an executable program, but it can be imported as a library too.
Let’s write a test for the echo program of Section 2.3.2. We’ve split the program into two functions: echo does the real work, while main parses and reads the flag values and reports any errors returned by echo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch11/echo 
// Echo prints its command-line arguments. 
package main 

import (
&amp;quot;flag&amp;quot;
&amp;quot;fmt&amp;quot; 
&amp;quot;io&amp;quot; 
&amp;quot;os&amp;quot; 
&amp;quot;strings&amp;quot; 

) 
var     (n = flag.Bool(&amp;quot;n&amp;quot;, false, &amp;quot;omit trailing newline&amp;quot;) s = flag.String(&amp;quot;s&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;separator&amp;quot;) 
) 
var out io.Writer = os.Stdout // modified during 
testing 

func main() {flag.Parse()if err := echo(!*n, *s, flag.Args()); err != nil {
fmt.Fprintf(os.Stderr, &amp;quot;echo: %v\n&amp;quot;, err) 
os.Exit(1) 
}
} 

func echo(newline bool, sep string, args []string) 
error {
fmt.Fprint(out, strings.Join(args, sep)) 
if newline {

fmt.Fprintln(out) 
}
return nil 

} 
From the test, we will call echo with a variety of arguments and flag settings and check that it prints the correct output in each case, so we’ve added parameters to echo to reduce its dependence on global variables. That said, we’ve also introduced another global variable, out, the io.Writer to which the result will be written. By having echo write through this variable, not directly to os.Stdout, the tests can substitute a different Writer implementation that records what was written for later inspection. Here’s the test, in file echo_test.go: 

```go
package main 
import (
&amp;quot;bytes&amp;quot;
&amp;quot;fmt&amp;quot; 
&amp;quot;testing&amp;quot; 

) 
func TestEcho(t *testing.T) { var tests = []struct {newline bool 
sep string 
args []string 
want string 

}{ {true, &amp;quot;&amp;quot;, []string{}, &amp;quot;\n&amp;quot;}, {false, &amp;quot;&amp;quot;, []string{}, &amp;quot;&amp;quot;}, {true, &amp;quot;\t&amp;quot;, []string{&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;}, 
&amp;quot;one\ttwo\tthree\n&amp;quot;},
{true, &amp;quot;,&amp;quot;, []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}, 
&amp;quot;a,b,c\n&amp;quot;},
{false, &amp;quot;:&amp;quot;, []string{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;}, 
&amp;quot;1:2:3&amp;quot;},
} 

for _, test := range tests {
    descr := fmt.Sprintf(&amp;quot;echo(%v, %q, %q)&amp;quot;, test.newline, test.sep, test.args) 
out = new(bytes.Buffer) // captured output 
if err := echo(test.newline, test.sep, 
test.args);     err != nil {
t.Errorf(&amp;quot;%s failed: %v&amp;quot;, descr, err) 
continue 

}
got := out.(*bytes.Buffer).String() 
if got != test.want {
t.Errorf(&amp;quot;%s = %q, want %q&amp;quot;, descr, got, test.want)}}} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the test code is in the same package as the production code. Although the package name is main and it defines a main function, during testing this package acts as a library that exposes the function TestEcho to the test driver; its main function is ignored.
By organizing the test as a table, we can easily add new test cases. Let’s see what happens when the test fails, by adding this line to the table:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{true, &amp;quot;,&amp;quot;, []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}, &amp;quot;a b c\n&amp;quot;}, // 
NOTE: wrong expectation! 
go test prints 

```go
$ go test // gopl.io/ch11/echo 
---FAIL: TestEcho (0.00s)
echo_test.go:31: echo(true, &amp;quot;,&amp;quot;, [&amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;]) = 
&amp;quot;a,b,c&amp;quot;, want &amp;quot;a b c\n&amp;quot; 
FAIL 
FAIL // gopl.io/ch11/echo 0.006s 

The error message describes the attempted operation (using Go-like syntax), the actual behavior, and the expected behavior, in that order. With an informative error message such as this, you may have a pretty good idea about the root cause before you’ve even located the source code of the test. 


It’s important that code being tested not call log.Fatal or os.Exit, since these will stop the process in its tracks; calling these functions should be regarded as the exclusive right of main. If something totally unexpected happens and a function panics, the test driver will recover, though the test will of course be considered a failure. Expected errors such as those resulting from bad user input, missing files, or improper configuration should be reported by returning a non-nil error value. Fortunately (though unfortunate as an illustration), our echo example is so simple that it will never return a non-nil error. 

###White-Box Testing 


One way of categorizing tests is by the level of knowledge they require of the internal workings of the package under test. A black-box test assumes nothing about the package other than what is exposed by its API and specified by its documentation; the package’s internals are opaque. In contrast, a white-box test has privileged access to the internal functions and data structures of the package and can make observations and changes that an ordinary client cannot. For example, a white-box test can check that the invariants of the package’s data types are maintained after every operation. (The name white box is traditional, but clear box would be more accurate.) 

The two approaches are complementary. Black-box tests are usually more robust, needing fewer updates as the software evolves. They also help the test author empathize with the client of the package and can reveal flaws in the API design. In contrast, white-box tests can provide more detailed coverage of the trickier parts of the implementation. 

We’ve already seen examples of both kinds. TestIsPalindrome calls only the exported function IsPalindrome and is thus a black-box test. TestEcho calls the echo function and updates the global variable out, both of which are unexported, making it a white-box test. 


While developing TestEcho, we modified the echo function to use the package-level variable out when writing its output, so that the test could replace the standard output with an alternative implementation that records the data for later inspection. Using the same technique, we can replace other parts of the production code with easy-to-test “fake” implementations. The advantage of fake implementations is that they can be simpler to configure, more predictable, more reliable, and easier to observe. They can also avoid undesirable side effects such as updating a production database or charging a credit card. 


The code below shows the quota-checking logic in a web service that provides networked storage to users. When users exceed 90% of their quota, the system sends them a warning email. 

```go
// gopl.io/ch11/storage1 
package storage 
import (
&amp;quot;fmt&amp;quot; 
&amp;quot;log&amp;quot;
&amp;quot;net/smtp&amp;quot; ) 
var usage = make(map[string]int64) 
func bytesInUse(username string) int64 { return 
usage[username] } 

// Email sender configuration. 
// NOTE: never put passwords in source code! 
const sender = &amp;quot;notifications@example.com&amp;quot; 
const password = &amp;quot;correcthorsebatterystaple&amp;quot; 
const hostname = &amp;quot;smtp.example.com&amp;quot; 

const template = `Warning: you are using %d bytes of 
storage,
%d%% of your quota.` 

func CheckQuota(username string) { 
used := bytesInUse(username) 
const quota = 1000000000 // 1GB 
percent := 100 * used / quota 
if percent &amp;lt; 90 {

return // OK }msg := fmt.Sprintf(template, used, percent) auth := smtp.PlainAuth(&amp;quot;&amp;quot;, sender, password, 
hostname)
err := smtp.SendMail(hostname+&amp;quot;:587&amp;quot;, auth, 
sender, 
[]string{username}, []byte(msg)) 
if err != nil {
log.Printf(&amp;quot;smtp.SendMail(%s) failed: %s&amp;quot;, 
username, err) 
}
} 


We’d like to test it, but we don’t want the test to send out real email. So we move the email logic into its own function and store that function in an unexported package-level variable, notifyUser. 

```go
// gopl.io/ch11/storage2 
var notifyUser = func(username, msg string) { 
auth := smtp.PlainAuth(&amp;quot;&amp;quot;, sender, password, hostname)err := smtp.SendMail(hostname+&amp;quot;:587&amp;quot;, auth, sender, []string{username}, []byte(msg)) if err != nil {log.Printf(&amp;quot;smtp.SendEmail(%s) failed: %s&amp;quot;, username, err) }} 
func CheckQuota(username string) { 
used := bytesInUse(username) 
const quota = 1000000000 // 1GB 
percent := 100 * used / quota 
if percent &amp;lt; 90 {

return // OK }msg := fmt.Sprintf(template, used, percent) notifyUser(username, msg) 
} 

We can now write a test that substitutes a simple fake notification mechanism instead of sending real email. This one records the notified user and the contents of the message. 

```go
package storage 
import (
&amp;quot;strings&amp;quot;
&amp;quot;testing&amp;quot; 

) 
func TestCheckQuotaNotifiesUser(t *testing.T) { 
var notifiedUser, notifiedMsg string 
notifyUser = func(user, msg string) { 

notifiedUser, notifiedMsg = user, msg } 
const user = &amp;quot;joe@example.org&amp;quot; usage[user]= 980000000 // simulate a 980MB-used condition 
CheckQuota(user)
if notifiedUser == &amp;quot;&amp;quot; &amp;amp;&amp;amp; notifiedMsg == &amp;quot;&amp;quot; {
t.Fatalf(&amp;quot;notifyUser not called&amp;quot;) 
}
if notifiedUser != user {
t.Errorf(&amp;quot;wrong user (%s) notified, want %s&amp;quot;, 
notifiedUser, user) }
const wantSubstring = &amp;quot;98% of your quota&amp;quot; 
if !strings.Contains(notifiedMsg, wantSubstring) { 
t.Errorf(&amp;quot;unexpected notification message 
&amp;lt;&amp;lt;%s&amp;gt;&amp;gt;, &amp;quot;+ 
&amp;quot;want substring %q&amp;quot;, notifiedMsg, 
wantSubstring)
}
} 

There’s one problem: after this test function has returned, CheckQuota no longer works as it should because it’s still using the test’s fake implementation of notifyUsers. (There is always a risk of this kind when updating global variables.) We must modify the test to restore the previous value so that subsequent tests observe no effect, and we must do this on all execution paths, including test failures and panics. This naturally suggests defer. 

```go
func TestCheckQuotaNotifiesUser(t *testing.T) { 
// Save and restore original notifyUser. 
saved := notifyUser 
defer func() { notifyUser = saved }() 

// Install the test&#39;s fake notifyUser. 
var notifiedUser, notifiedMsg string 
notifyUser = func(user, msg string) { 
notifiedUser, notifiedMsg = user, msg 
}
// ...rest of test... 
} 

This pattern can be used to temporarily save and restore all kinds of global variables, including command-line flags, debugging options, and performance parameters; to install and remove hooks that cause the production code to call some test code when something interesting happens; and to coax the production code into rare but important states, such as timeouts, errors, and even specific interleavings of concurrent activities. 
Using global variables in this way is safe only because go test does not normally run multiple tests concurrently. 

### External Test Packages 
Consider the packages net/url, which provides a URL parser, and net/http, which provides a web server and HTTP client library. As we might expect, the higher-level net/http depends on the lower-level net/url. However, one of the tests in net/url is an example demonstrating the interaction between URLs and the HTTP client library. In other words, a test of the lower-level package imports the higher-level package. 

Declaring this test function in the net/url package would create a cycle in the package import graph, as depicted by the upwards arrow in Figure 11.1, but as we explained in Section 10.1, the Go specification forbids import cycles. 

We resolve the problem by declaring the test function in an external test package, that is, in a file in the net/url directory whose package declaration reads package url_test. The extra suffix _test is a signal to go test that it should build an additional package containing just these files and run its tests. It may be helpful to think of this external test package as if it had the import path net/url_test, but it cannot be imported under this or any other name. 

Because external tests live in a separate package, they may import helper packages that also depend on the package being tested; an in-package test cannot do this. In terms of the design layers, the external test package is logically higher up than both of the packages it depends upon, as shown in Figure 11.2. 

By avoiding import cycles, external test packages allow tests, especially integration tests (which test the interaction of several components), to import other packages freely, exactly as an application would. 

We can use the go list tool to summarize which Go source files in a package directory are production code, in-package tests, and external tests. We’ll use the fmt package as an example. GoFiles is the list of files that contain the production code; these are the files that go build will include in your application: 

```go
$ go list -f={{.GoFiles}} fmt 
[doc.go format.go print.go scan.go] 
TestGoFiles is the list of files that also belong to the fmt package, but these files, whose names all end in _test.go, are included only when building tests: 

```go
$ go list -f={{.TestGoFiles}} fmt 
[export_test.go] 

The package’s tests would usually reside in these files, though unusually fmt has none; we’ll explain the purpose of export_test.go in a moment. 
XTestGoFiles is the list of files that constitute the external test package, fmt_test, so these files must import the fmt package in order to use it. Again, they are included only during testing: 

```go
$ go list -f={{.XTestGoFiles}} fmt 
[fmt_test.go scan_test.go stringer_test.go] 
Sometimes an external test package may need privileged access to the internals of the package under test, if for example a white-box test must live in a separate package to avoid an import cycle. In such cases, we use a trick: we add declarations to an in-package _test.go file to expose the necessary internals to the external test. This file thus offers the test a “back door” to the package. If the source file exists only for this purpose and contains no tests itself, it is often called export_test.go. 

For example, the implementation of the fmt package needs the functionality of unicode.IsSpace as part of fmt.Scanf. To avoid creating an undesirable dependency, fmt does not import the unicode package and its large tables of data; instead, it contains a simpler implementation, which it calls isSpace. 

To ensure that the behaviors of fmt.isSpace and unicode.IsSpace do not drift apart, fmt prudently contains a test. It is an external test, and thus it cannot access isSpace directly, so fmt opens a back door to it by declaring an exported variable that holds the internal isSpace function. This is the entirety of the fmt package’s export_test.go file. 
package fmt 
var IsSpace = isSpace 

This test file defines no tests; it just declares the exported symbol fmt.IsSpace for use by the external test. This trick can also be used whenever an external test needs to use some of the techniques of white-box testing. 


### Writing Effective Tests 

Many newcomers to Go are surprised by the minimalism of Go’s testing framework. Other languages’ frameworks provide mechanisms for identifying test functions (often using reflection or metadata), hooks for performing “setup” and “teardown” operations before and after the tests run, and libraries of utility functions for asserting common predicates, comparing values, formatting error messages, and aborting a failed test (often using exceptions). 

Although these mechanisms can make tests very concise, the resulting tests often seem like they are written in a foreign language. Furthermore, although they may report PASS or FAIL correctly, their manner may be unfriendly to the unfortunate maintainer, with cryptic failure messages like &amp;quot;assert: 0 == 1&amp;quot; or page after page of stack traces. 

Go’s attitude to testing stands in stark contrast. It expects test authors to do most of this work themselves, defining functions to avoid repetition, just as they would for ordinary programs. The process of testing is not one of rote form filling; a test has a user interface too, albeit one whose only users are also its maintainers. 

A good test does not explode on failure but prints a clear and succinct description of the symptom of the problem, and perhaps other relevant facts about the context. Ideally, the maintainer should not need to read the source code to decipher a test failure. A good test should not give up after one failure but should try to report several errors in a single run, since the pattern of failures may itself be revealing. 

The assertion function below compares two values, constructs a generic error message, and stops the program. It’s easy to use and it’s correct, but when it fails, the error message is almost useless. It does not solve the hard problem of providing a good user interface. 

```go
import (
&amp;quot;fmt&amp;quot; 
&amp;quot;strings&amp;quot;
&amp;quot;testing&amp;quot; ) 
// A poor assertion function. 
func assertEqual(x, y int) { 
if x != y {
panic(fmt.Sprintf(&amp;quot;%d != %d&amp;quot;, x, y)) 
}
} 

func TestSplit(t *testing.T) { words := strings.Split(&amp;quot;a:b:c&amp;quot;, &amp;quot;:&amp;quot;) 
assertEqual(len(words), 3) 
// ... 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this sense, assertion functions suffer from premature abstraction: by treating the failure of this particular test as a mere difference of two integers, we forfeit the opportunity to provide meaningful context. We can provide a better message by starting from the concrete details, as in the example below. Only once repetitive patterns emerge in a given test suite is it time to introduce abstractions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestSplit(t *testing.T) { 
s, sep := &amp;quot;a:b:c&amp;quot;, &amp;quot;:&amp;quot; 
words := strings.Split(s, sep) 
if got, want := len(words), 3; got != want {
t.Errorf(&amp;quot;Split(%q, %q) returned %d words, want %d&amp;quot;, s, sep, got, want) }
// ... 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the test reports the function that was called, its inputs, and the significance of the result; it explicitly identifies the actual value and the expectation; and it continues to execute even if this assertion should fail. Once we’ve written a test like this, the natural next step is often not to define a function to replace the entire if statement, but to execute the test in a loop in which s, sep, and want vary, like the table-driven test of IsPalindrome.&lt;/p&gt;

&lt;p&gt;The previous example didn’t need any utility functions, but of course that shouldn’t stop us from introducing functions when they help make the code simpler. (We’ll look at one such utility function, reflect.DeepEqual, in Section 13.3.) The key to a good test is to start by implementing the concrete behavior that you want and only then use functions to simplify the code and eliminate repetition. Best results are rarely obtained by starting with a library of abstract, generic testing functions.&lt;/p&gt;

&lt;p&gt;Exercise 11.5: Extend TestSplit to use a table of inputs and expected outputs.&lt;/p&gt;

&lt;h3 id=&#34;avoiding-brittle-tests:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Avoiding Brittle Tests&lt;/h3&gt;

&lt;p&gt;An application that often fails when it encounters new but valid inputs is called buggy; a test that spuriously fails when a sound change was made to the program is called brittle. Just as a buggy program frustrates its users, a brittle test exasperates its maintainers. The most brittle tests, which fail for almost any change to the production code, good or bad, are sometimes called change detector or status quo tests, and the time spent dealing with them can quickly deplete any benefit they once seemed to provide.&lt;/p&gt;

&lt;p&gt;When a function under test produces a complex output such as a long string, an elaborate data structure, or a file, it’s tempting to check that the output is exactly equal to some “golden” value that was expected when the test was written. But as the program evolves, parts of the output will likely change, probably in good ways, but change nonetheless. And it’s not just the output; functions with complex inputs often break because the input used in a test is no longer valid.&lt;/p&gt;

&lt;p&gt;The easiest way to avoid brittle tests is to check only the properties you care about. Test your program’s simpler and more stable interfaces in preference to its internal functions. Be selective in your assertions. Don’t check for exact string matches, for example, but look for relevant substrings that will remain unchanged as the program evolves. It’s often worth writing a substantial function to distill a complex output down to its essence so that assertions will be reliable. Even though that may seem like a lot of up-front effort, it can pay for itself quickly in time that would otherwise be spent fixing spuriously failing tests.&lt;/p&gt;

&lt;h2 id=&#34;coverage:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Coverage&lt;/h2&gt;

&lt;p&gt;By its nature, testing is never complete. As the influential computer scientist Edsger Dijkstra put it, “Testing shows the presence, not the absence of bugs.” No quantity of tests can ever prove a package free of bugs. At best, they increase our confidence that the package works well in a wide range of important scenarios.&lt;/p&gt;

&lt;p&gt;The degree to which a test suite exercises the package under test is called the test’s coverage. Coverage can’t be quantified directly—the dynamics of all but the most trivial programs are beyond precise measurement—but there are heuristics that can help us direct our testing efforts to where they are more likely to be useful.&lt;/p&gt;

&lt;p&gt;Statement coverage is the simplest and most widely used of these heuristics. The statement coverage of a test suite is the fraction of source statements that are executed at least once during the test. In this section, we’ll use Go’s cover tool, which is integrated into go test , to measure statement coverage and help identify obvious gaps in the tests.&lt;/p&gt;

&lt;p&gt;The code below is a table-driven test for the expression evaluator we built back in Chapter 7:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch7/eval 
func TestCoverage(t *testing.T) { 
var tests = []struct {
input string 
env Env 
want string // expected error from 
Parse/Check or result from Eval 
}{ {&amp;quot;x % 2&amp;quot;, nil, &amp;quot;unexpected &#39;%&#39;&amp;quot;}, 
{&amp;quot;!true&amp;quot;, nil, &amp;quot;unexpected &#39;!&#39;&amp;quot;}, 
{&amp;quot;log(10)&amp;quot;, nil, `unknown function &amp;quot;log&amp;quot;`}, 
{&amp;quot;sqrt(1, 2)&amp;quot;, nil, &amp;quot;call to sqrt has 2 args, want 1&amp;quot;},
{&amp;quot;sqrt(A / pi)&amp;quot;, Env{&amp;quot;A&amp;quot;: 87616, &amp;quot;pi&amp;quot;: 
math.Pi}, &amp;quot;167&amp;quot;},
{&amp;quot;pow(x, 3) + pow(y, 3)&amp;quot;, Env{&amp;quot;x&amp;quot;: 9, &amp;quot;y&amp;quot;: 
10}, &amp;quot;1729&amp;quot;},{&amp;quot;5 / 9 * (F -32)&amp;quot;, Env{&amp;quot;F&amp;quot;: -40}, &amp;quot;-40&amp;quot;}, } 
for     _, test := range tests {
expr, err := Parse(test.input) 
if err == nil {

err = expr.Check(map[Var]bool{}) }if err != nil {
if err.Error() != test.want {t.Errorf(&amp;quot;%s: got %q, want %q&amp;quot;, 
test.input,     err, test.want) 
}
continue 

} 
got := fmt.Sprintf(&amp;quot;%.6g&amp;quot;,expr.Eval(test.env))if got != test.want {t.Errorf(&amp;quot;%s: %v =&amp;gt; %s, want %s&amp;quot;, test.input, test.env, got, test.want) }}} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, let’s check that the test passes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test -v -run=Coverage // gopl.io/ch7/eval 
=== RUN TestCoverage 
---PASS: TestCoverage (0.00s) 
PASS 
ok // gopl.io/ch7/eval 0.011s 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command displays the usage message of the coverage tool:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go tool cover 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usage of &amp;lsquo;go tool cover&amp;rsquo;:&lt;/p&gt;

&lt;p&gt;Given a coverage profile produced by &amp;lsquo;go test&amp;rsquo;:
go test -coverprofile=c.out&lt;/p&gt;

&lt;p&gt;Open a web browser displaying annotated source code: go tool cover -html=c.out &amp;hellip;&lt;/p&gt;

&lt;p&gt;The go tool command runs one of the executables from the Go toolchain. These programs live in the directory $GOROOT/pkg/tool/${GOOS}_${GOARCH}. Thanks to go build , we rarely need to invoke them directly.&lt;/p&gt;

&lt;p&gt;Now we run the test with the -coverprofile flag:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test -run=Coverage -coverprofile=c.out 
// gopl.io/ch7/eval
ok // gopl.io/ch7/eval 0.032s coverage: 68.5% of 
statements 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This flag enables the collection of coverage data by instrumenting the production code. That is, it modifies a copy of the source code so that before each block of statements is executed, a boolean variable is set, with one variable per block. Just before the modified program exits, it writes the value of each variable to the specified log file c.out and prints a summary of the fraction of statements that were executed. (If all you need is the summary, use go test -cover.)&lt;/p&gt;

&lt;p&gt;If go test is run with the -covermode=count flag, the instrumentation for each block increments a counter instead of setting a boolean. The resulting log of execution counts of each block enables quantitative comparisons between “hotter” blocks, which are more frequently executed, and “colder” ones.&lt;/p&gt;

&lt;p&gt;Having gathered the data, we run the cover tool, which processes the log, generates an HTML report, and opens it in a new browser window (Figure 11.3).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ go tool cover -html=c.out&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Each statement is colored green if it was covered or red if it was not covered. For clarity, we’ve shaded the background of the red text. We can see immediately that none of our inputs exercised the unary operator Eval method. If we add this new test case to the table and re-run the previous two commands, the unary expression code becomes green:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;{&amp;quot;-x * -x&amp;quot;, eval.Env{&amp;quot;x&amp;quot;: 2}, &amp;quot;4&amp;quot;} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two panic statements remain red, however. This should not be surprising, because these statements are supposed to be unreachable.&lt;/p&gt;

&lt;p&gt;Achieving 100% statement coverage sounds like a noble goal, but it is not usually feasible in practice, nor is it likely to be a good use of effort. Just because a statement is executed does not mean it is bug-free; statements containing complex expressions must be executed many times with different inputs to cover the interesting cases.&lt;/p&gt;

&lt;p&gt;Some statements, like the panic statements above, can never be reached. Others, such as those that handle esoteric errors, are hard to exercise but rarely reached in practice. Testing is fundamentally a pragmatic endeavor, a trade-off between the cost of writing tests and the cost of failures that could have been prevented by tests. Coverage tools can help identify the weakest spots, but devising good test cases demands the same rigorous thinking as programming in general.&lt;/p&gt;

&lt;h2 id=&#34;benchmark-functions:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Benchmark Functions&lt;/h2&gt;

&lt;p&gt;Benchmarking is the practice of measuring the performance of a program on a fixed workload.&lt;/p&gt;

&lt;p&gt;In Go, a benchmark function looks like a test function, but with the Benchmark prefix and a *testing.B parameter that provides most of the same methods as a *testing.T, plus a few extra related to performance measurement. It also exposes an integer field N, which specifies the number of times to perform the operation being measured.&lt;/p&gt;

&lt;p&gt;Here’s a benchmark for IsPalindrome that calls it N times in a loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;testing&amp;quot; 
func BenchmarkIsPalindrome(b *testing.B) { for i := 0; i &amp;lt; b.N; i++ {IsPalindrome(&amp;quot;A man, a plan, a canal: Panama&amp;quot;) }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We run it with the command below. Unlike tests, by default no benchmarks are run. The argument to the -bench flag selects which benchmarks to run. It is a regular expression matching the names of Benchmark functions, with a default value that matches none of them. The “.” pattern causes it to match all benchmarks in the word package, but since there’s only one, -bench=IsPalindrome would have been equivalent.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ cd $GOPATH/src/// gopl.io/ch11/word2 
$ go test -bench=. 

PASS 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BenchmarkIsPalindrome-8 1000000 1035
ns/op
ok // gopl.io/ch11/word2 2.179s&lt;/p&gt;

&lt;p&gt;The benchmark name’s numeric suffix, 8 here, indicates the value of GOMAXPROCS, which is important for concurrent benchmarks.&lt;/p&gt;

&lt;p&gt;The report tells us that each call to IsPalindrome took about 1.035 microseconds, averaged over 1,000,000 runs. Since the benchmark runner initially has no idea how long the operation takes, it makes some initial measurements using small values of N and then extrapolates to a value large enough for a stable timing measurement to be made.&lt;/p&gt;

&lt;p&gt;The reason the loop is implemented by the benchmark function, and not by the calling code in the test driver, is so that the benchmark function has the opportunity to execute any necessary one-time setup code outside the loop without this adding to the measured time of each iteration. If this setup code is still perturbing the results, the testing.B parameter provides methods to stop, resume, and reset the timer, but these are rarely needed.&lt;/p&gt;

&lt;p&gt;Now that we have a benchmark and tests, it’s easy to try out ideas for making the program faster. Perhaps the most obvious optimization is to make IsPalindrome’s second loop stop checking at the midpoint, to avoid doing each comparison twice:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;n := len(letters)/2 
for i := 0; i &amp;lt; n; i++ {
if letters[i] != letters[len(letters)-1-i] { 
return false 
}}
return true 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But as is often the case, an obvious optimization doesn’t always yield the expected benefit. This one delivered a mere 4% improvement in one experiment.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test -bench=. 
PASS 
BenchmarkIsPalindrome-8 1000000 
992 
ns/op
ok // gopl.io/ch11/word2 2.093s 


Another idea is to pre-allocate a sufficiently large array for use by letters, rather than expand it by successive calls to append. Declaring letters as an array of the right size, like this, 

```go
letters := make([]rune, 0, len(s)) for _, r := range s {if unicode.IsLetter(r) {letters = append(letters, unicode.ToLower(r)) }} 
yields an improvement of nearly 35%, and the benchmark runner now reports the average over 2,000,000 iterations. 

```go
$ go test -bench=. PASS BenchmarkIsPalindrome-8 2000000 697 ns/opok // gopl.io/ch11/word2 1.468s 

As this example shows, the fastest program is often the one that makes the fewest memory allocations. The -benchmem command-line flag will include memory allocation statistics in its report. Here we compare the number of allocations before 
the optimization:  

```go 
$ go PASS  test  -bench=.  -benchmem  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BenchmarkIsPalindrome B/op 4 allocs/op  1000000  1026  ns/op  304&lt;br /&gt;
and after it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go PASS  test  -bench=.  -benchmem  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BenchmarkIsPalindrome B/op 1 allocs/op  2000000  807 ns/op  128&lt;br /&gt;
Consolidating the allocations in  a  single call  to  make  eliminated  75% of  the allocations and halved the quantity of allocated memory.&lt;/p&gt;

&lt;p&gt;Benchmarks like this tell us the absolute time required for a given operation, but in many settings the interesting performance questions are about the relative timings of two different operations.&lt;/p&gt;

&lt;p&gt;For example, if a function takes 1ms to process 1,000 elements, how long will it take to process 10,000 or a million? Such comparisons reveal the asymptotic growth of the running time of the function.&lt;/p&gt;

&lt;p&gt;Another example: what is the best size for an I/O buffer? Benchmarks of application throughput over a range of sizes can help us choose the smallest buffer that delivers satisfactory performance. A third example: which algorithm performs best for a given job? Benchmarks that evaluate two different algorithms on the same input data can often show the strengths and weaknesses of each one on important or representative workloads.&lt;/p&gt;

&lt;p&gt;Comparative benchmarks are just regular code. They typically take the form of a single parameterized function, called from several Benchmark functions with different values, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func benchmark(b *testing.B, size int) { /* ... */ } 
func Benchmark10(b *testing.B) { benchmark(b, 10) } 
func Benchmark100(b *testing.B) { benchmark(b, 100) } 
func Benchmark1000(b *testing.B) { benchmark(b, 1000) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parameter size, which specifies the size of the input, varies across benchmarks but is constant within each benchmark. Resist the temptation to use the parameter b.N as the input size. Unless you interpret it as an iteration count for a fixed-size input, the results of your benchmark will be meaningless.&lt;/p&gt;

&lt;p&gt;Patterns revealed by comparative benchmarks are particularly useful during program design, but we don’t throw the benchmarks away when the program is working. As the program evolves, or its input grows, or it is deployed on new operating systems or processors with different characteristics, we can reuse those benchmarks to revisit design decisions.&lt;/p&gt;

&lt;p&gt;Exercise 11.6: Write benchmarks to compare the PopCount implementation in Section 2.6.2 with your solutions to Exercise 2.4 and Exercise 2.5. At what point does the table-based approach break even?&lt;/p&gt;

&lt;p&gt;Exercise 11.7: Write benchmarks for Add, UnionWith, and other methods of *IntSet (§6.5) using large pseudo-random inputs. How fast can you make these methods run? How does the choice of word size affect performance? How fast is IntSet compared to a set implementation based on the built-in map type?&lt;/p&gt;

&lt;h2 id=&#34;profiling:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Profiling&lt;/h2&gt;

&lt;p&gt;Benchmarks are useful for measuring the performance of specific operations, but when we’re trying to make a slow program faster, we often have no idea where to begin. Every programmer knows Donald Knuth’s aphorism about premature optimization, which appeared in “Structured Programming with go to Statements” in 1974. Although often misinterpreted to mean performance doesn’t matter, in its original context we can discern a different meaning:&lt;/p&gt;

&lt;p&gt;There is no doubt that the grail of efficiency leads to abuse. Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered.&lt;/p&gt;

&lt;p&gt;We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. A good programmer will not be lulled into complacency by such reasoning, he will be wise to look carefully at the critical code; but only after that code has been identified. It is often a mistake to make a priori judgments about what parts of a program are really critical, since the universal experience of programmers who have been using measurement tools has been that their intuitive guesses fail.&lt;/p&gt;

&lt;p&gt;When we wish to look carefully at the speed of our programs, the best technique for identifying the critical code is profiling. Profiling is an automated approach to performance measurement based on sampling a number of profile events during execution, then extrapolating from them during a post-processing step; the resulting statistical summary is called a profile.&lt;/p&gt;

&lt;p&gt;Go supports many kinds of profiling, each concerned with a different aspect of performance, but all of them involve recording a sequence of events of interest, each of which has an accompanying stack trace—the stack of function calls active at the moment of the event. The go test tool has built-in support for several kinds of profiling.&lt;/p&gt;

&lt;p&gt;A CPU profile identifies the functions whose execution requires the most CPU time. The currently running thread on each CPU is interrupted periodically by the operating system every few milliseconds, with each interruption recording one profile event before normal execution resumes.&lt;/p&gt;

&lt;p&gt;A heap profile identifies the statements responsible for allocating the most memory. The profiling library samples calls to the internal memory allocation routines so that on average, one profile event is recorded per 512KB of allocated memory.&lt;/p&gt;

&lt;p&gt;A blocking profile identifies the operations responsible for blocking goroutines the longest, such as system calls, channel sends and receives, and acquisitions of locks. The profiling library records an event every time a goroutine is blocked by one of these operations.
Gathering a profile for code under test is as easy as enabling one of the flags below. Be careful when using more than one flag at a time, however: the machinery for gathering one kind of profile may skew the results of others.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test -cpuprofile=cpu.out 
$ go test -blockprofile=block.out 
$ go test -memprofile=mem.out 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It’s easy to add profiling support to non-test programs too, though the details of how we do that vary between short-lived command-line tools and long-running server applications. Profiling is especially useful in long-running applications, so the Go runtime’s profiling features can be enabled under programmer control using the runtime API.&lt;/p&gt;

&lt;p&gt;Once we’ve gathered a profile, we need to analyze it using the pprof tool. This is a standard part of the Go distribution, but since it’s not an everyday tool, it’s accessed indirectly using go tool pprof . It has dozens of features and options, but basic use requires only two arguments, the executable that produced the profile and the profile log.&lt;/p&gt;

&lt;p&gt;To make profiling efficient and to save space, the log does not include function names; instead, functions are identified by their addresses. This means that pprof needs the executable in order to make sense of the log. Although go test usually discards the test executable once the test is complete, when profiling is enabled it saves the executable as foo.test, where foo is the name of the tested package.&lt;/p&gt;

&lt;p&gt;The commands below show how to gather and display a simple CPU profile. We’ve selected one of the benchmarks from the net/http package. It is usually better to profile specific benchmarks that have been constructed to be representative of workloads one cares about. Benchmarking test cases is almost never representative, which is why we disabled them by using the filter -run=NONE.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test -run=NONE -bench=ClientServerParallelTLS64 \ 
-cpuprofile=cpu.log net/http PASS 
BenchmarkClientServerParallelTLS64-8 1000 
3141325 ns/op 143010 B/op 1747 allocs/op 
ok net/http 3.395s 
$ go tool pprof -text -nodecount=10 ./http.test 
cpu.log
2570ms of 3590ms total (71.59%) 
Dropped 129 nodes (cum &amp;lt;= 17.95ms) 
Showing top 10 nodes out of 166 (cum &amp;gt;= 60ms) 
flat flat% sum% cum cum% 
1730ms 48.19% 48.19% 1750ms 48.75% 
crypto/elliptic.p256ReduceDegree
230ms 6.41% 54.60% 250ms 6.96% 
crypto/elliptic.p256Diff
120ms 3.34% 57.94% 120ms 3.34% 
math/big.addMulVVW
110ms 3.06% 61.00% 110ms 3.06% syscall.Syscall 
90ms 2.51% 63.51% 1130ms 31.48% 
crypto/elliptic.p256Square
70ms 1.95% 65.46% 120ms 3.34% 
runtime.scanobject
60ms 1.67% 67.13% 830ms 23.12% 
crypto/elliptic.p256Mul
60ms 1.67% 68.80% 190ms 5.29% 
math/big.nat.montgomery
50ms 1.39% 70.19% 50ms 1.39% 
crypto/elliptic.p256ReduceCarry
50ms 1.39% 71.59% 60ms 1.67% 
crypto/elliptic.p256Sum 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The -text flag specifies the output format, in this case, a textual table with one row per function, sorted so the “hottest” functions—those that consume the most CPU cycles—appear first. The -nodecount=10 flag limits the result to 10 rows. For gross performance problems, this textual format may be enough to pinpoint the cause.&lt;/p&gt;

&lt;p&gt;This profile tells us that elliptic-curve cryptography is important to the performance of this particular HTTPS benchmark. By contrast, if a profile is dominated by memory allocation functions from the runtime package, reducing memory consumption may be a worthwhile optimization.&lt;/p&gt;

&lt;p&gt;For more subtle problems, you may be better off using one of pprof’s graphical displays. These require GraphViz, which can be downloaded from www.graphviz.org. The -web flag then renders a directed graph of the functions of the program, annotated by their CPU profile numbers and colored to indicate the hottest functions.&lt;/p&gt;

&lt;p&gt;We’ve only scratched the surface of Go’s profiling tools here. To find out more, read the “Profiling Go Programs” article on the Go Blog.&lt;/p&gt;

&lt;h2 id=&#34;example-functions:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Example Functions&lt;/h2&gt;

&lt;p&gt;The third kind of function treated specially by go test is an example function, one whose name starts with Example. It has neither parameters nor results. Here’s an example function for IsPalindrome:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ExampleIsPalindrome() {fmt.Println(IsPalindrome(&amp;quot;A man, a plan, a canal: 
Panama&amp;quot;))
fmt.Println(IsPalindrome(&amp;quot;palindrome&amp;quot;))
// Output: 
// true 
// false 

} 


Figure 11.4. An interactive example of strings.Join in godoc. 

Example functions serve three purposes. The primary one is documentation: a good example can be a more succinct or intuitive way to convey the behavior of a library function than its prose description, especially when used as a reminder or quick reference. An example can also demonstrate the interaction between several types and functions belonging to one API, whereas prose documentation must always be attached to one place, like a type or function declaration or the package as a whole. And unlike examples within comments, example functions are real Go code, subject to compile-time checking, so they don’t become stale as the code evolves. 

Based on the suffix of the Example function, the web-based documentation server godoc associates example functions with the function or package they exemplify, so ExampleIsPalindrome would be shown with the documentation for the IsPalindrome function, and an example function called just Example would be associated with the word package as a whole. 


The second purpose is that examples are executable tests run by go test . If the example function contains a final // Output: comment like the one above, the test driver will execute the function and check that what it printed to its standard output matches the text within the comment. 


The third purpose of an example is hands-on experimentation. The godoc server at golang.org uses the Go Playground to let the user edit and run each example function from within a web browser, as shown in Figure 11.4. This is often the fastest way to get a feel for a particular function or language feature. 

The final two chapters of the book examine the reflect and unsafe packages, which few Go programmers regularly use—and even fewer need to use. If you haven’t written any substantial Go programs yet, now would be a good time to do that. 

12. Reflection 

Go provides a mechanism to update variables and inspect their values at run time, to call their methods, and to apply the operations intrinsic to their representation, all without knowing their types at compile time. This mechanism is called reflection. Reflection also lets us treat types themselves as first-class values. 

In this chapter, we’ll explore Go’s reflection features to see how they increase the expressiveness of the language, and in particular how they are crucial to the implementation of two important APIs: string formatting provided by fmt, and protocol encoding provided by packages like encoding/json and encoding/xml. Reflection is also essential to the template mechanism provided by the text/template and html/template packages we saw in Section 4.6. However, reflection is complex to reason about and not for casual use, so although these packages are implemented using reflection, they do not expose reflection in their own APIs. 


## Why Reflection? 

Sometimes we need to write a function capable of dealing uniformly with values of types that don’t satisfy a common interface, don’t have a known representation, or don’t exist at the time we design the function—or even all three. 


A familiar example is the formatting logic within fmt.Fprintf, which can usefully print an arbitrary value of any type, even a user-defined one. Let’s try to implement a function like it using what we know already. For simplicity, our function will accept one argument and will return the result as a string like fmt.Sprint does, so we’ll call it Sprint. 

We start with a type switch that tests whether the argument defines a Stringmethod, and call it if so. We then add switch cases that test the value’s dynamic type against each of the basic types—string, int, bool, and so on—and perform the appropriate formatting operation in each case. 

```go
func Sprint(x interface{}) string { 
type stringer interface {

String() string }
switch x := x.(type) { 
case stringer:
return x.String() 
case string:
return x 
case int: 
return strconv.Itoa(x) 
// ...similar cases for int16, uint32, and so 
on... 
case bool: 
if x {return &amp;quot;true&amp;quot; 
}
return &amp;quot;false&amp;quot; 
default: 
// array, chan, func, map, pointer, slice, struct 
return &amp;quot;???&amp;quot; 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But how do we deal with other types, like []float64, map[string] []string, and so on? We could add more cases, but the number of such types is infinite. And what about named types, like url.Values? Even if the type switch had a case for its underlying type map[string][]string, it wouldn’t match url.Values because the two types are not identical, and the type switch cannot
include a case for each type like url.Values because that would require this library to depend upon its clients. Without a way to inspect the representation of values of unknown types, we quickly get stuck. What we need is reflection.&lt;/p&gt;

&lt;h2 id=&#34;reflect-type-and-reflect-value:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;reflect.Type and reflect.Value&lt;/h2&gt;

&lt;p&gt;Reflection is provided by the reflect package. It defines two important types, Type and Value.A Type represents a Go type. It is an interface with many methods for discriminating among types and inspecting their components, like the fields of a struct or the parameters of a function. The sole implementation of reflect.Type is the type descriptor (§7.5), the same entity that identifies the dynamic type of an interface value.&lt;/p&gt;

&lt;p&gt;The reflect.TypeOf function accepts any interface{} and returns its dynamic type as a reflect.Type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;t := reflect.TypeOf(3) // a reflect.Type 
fmt.Println(t.String()) // &amp;quot;int&amp;quot; 
fmt.Println(t) // &amp;quot;int&amp;quot; 

The TypeOf(3) call above assigns the value 3 to the interface{} parameter. Recall from Section 7.5 that an assignment from a concrete value to an interface type performs an implicit interface conversion, which creates an interface value consisting of two components: its dynamic type is the operand’s type (int) and its dynamic value is the operand’s value (3). 


Because reflect.TypeOf returns an interface value’s dynamic type, it always returns a concrete type. So, for example, the code below prints &amp;quot;*os.File&amp;quot;, not &amp;quot;io.Writer&amp;quot;. Later, we will see that reflect.Type is capable of representing interface types too. 

```go
var w io.Writer = os.Stdout 
fmt.Println(reflect.TypeOf(w)) // &amp;quot;*os.File&amp;quot; 
Notice that reflect.Type satisfies fmt.Stringer. Because printing the dynamic type of an interface value is useful for debugging and logging, fmt.Printf provides a shorthand, %T, that uses reflect.TypeOf internally: 
fmt.Printf(&amp;quot;%T\n&amp;quot;, 3) // &amp;quot;int&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other important type in the reflect package is Value.A reflect.Value can hold a value of any type. The reflect.ValueOf function accepts any interface{} and returns a reflect.Value containing the interface’s dynamic value. As with reflect.TypeOf, the results of reflect.ValueOf are always concrete, but a reflect.Value can hold interface values too.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;v := reflect.ValueOf(3) // a reflect.Value 
fmt.Println(v) // &amp;quot;3&amp;quot; 
fmt.Printf(&amp;quot;%v\n&amp;quot;, v) // &amp;quot;3&amp;quot; 
fmt.Println(v.String()) // NOTE: &amp;quot;&amp;lt;int Value&amp;gt;&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like reflect.Type, reflect.Value also satisfies fmt.Stringer, but unless the Value holds a string, the result of the String method reveals only the type. Instead, use the fmt package’s %v verb, which treats reflect.Values specially.
Calling the Type method on a Value returns its type as a reflect.Type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;t := v.Type() // a reflect.Type 
fmt.Println(t.String()) // &amp;quot;int&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The inverse operation to reflect.ValueOf is the reflect.Value.Interface method. It returns an interface{} holding the same concrete value as the reflect.Value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;v := reflect.ValueOf(3) // a reflect.Value 
x := v.Interface() // an interface{} 
i := x.(int) // an int 
fmt.Printf(&amp;quot;%d\n&amp;quot;, i) // &amp;quot;3&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A reflect.Value and an interface{} can both hold arbitrary values. The difference is that an empty interface hides the representation and intrinsic operations of the value it holds and exposes none of its methods, so unless we know its dynamic type and use a type assertion to peer inside it (as we did above), there is little we can do to the value within. In contrast, a Value has many methods for inspecting its contents, regardless of its type. Let’s use them for our second attempt at a general formatting function, which we’ll call format.Any.&lt;/p&gt;

&lt;p&gt;Instead of a type switch, we use reflect.Value’s Kind method to discriminate the cases. Although there are infinitely many types, there are only a finite number of kinds of type: the basic types Bool, String, and all the numbers; the aggregate types Array and Struct; the reference types Chan, Func, Ptr, Slice, and Map; Interface types; and finally Invalid, meaning no value at all. (The zero value of a reflect.Value has kind Invalid.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch12/format 
package format 
import (
&amp;quot;reflect&amp;quot; 
&amp;quot;strconv&amp;quot; 

) 
// Any formats any value as a string. 
func Any(value interface{}) string { 
return formatAtom(reflect.ValueOf(value)) 
} 

// formatAtom formats a value without inspecting its 
internal structure. 
func formatAtom(v reflect.Value) string { 

switch v.Kind() { 
case reflect.Invalid: 
return &amp;quot;invalid&amp;quot; 

case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: return strconv.FormatInt(v.Int(), 10) 
case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:return strconv.FormatUint(v.Uint(), 10) // ...floating-point and complex cases omitted for brevity... 
case reflect.Bool: return strconv.FormatBool(v.Bool()) 
case reflect.String:return strconv.Quote(v.String()) 
case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map: 
return v.Type().String() + &amp;quot; 0x&amp;quot; + strconv.FormatUint(uint64(v.Pointer()), 16) 
default: // reflect.Array, reflect.Struct, reflect.Interface 
    return v.Type().String() + &amp;quot; value&amp;quot; }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, our function treats each value as an indivisible thing with no internal structure —hence formatAtom. For aggregate types (structs and arrays) and interfaces it prints only the type of the value, and for reference types (channels, functions, pointers, slices, and maps), it prints the type and the reference address in hexadecimal. This is less than ideal but still a major improvement, and since Kind is concerned only with the underlying representation, format.Any works for named types too. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x int64 = 1 
var d time.Duration = 1 * time.Nanosecond 
fmt.Println(format.Any(x)) // &amp;quot;1&amp;quot; 
fmt.Println(format.Any(d)) // &amp;quot;1&amp;quot; 
fmt.Println(format.Any([]int64{x})) // &amp;quot; 
[]int64 0x8202b87b0&amp;quot; 
fmt.Println(format.Any([]time.Duration{d})) // &amp;quot; 
[]time.Duration 0x8202b87e0&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;display-a-recursive-value-printer:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Display, a Recursive Value Printer&lt;/h2&gt;

&lt;p&gt;Next we’ll take a look at how to improve the display of composite types. Rather than try to copy fmt.Sprint exactly, we’ll build a debugging utility function called Display that, given an arbitrarily complex value x, prints the complete structure of that value, labeling each element with the path by which it was found. Let’s start with an example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;e, _ := eval.Parse(&amp;quot;sqrt(A / pi)&amp;quot;) 
Display(&amp;quot;e&amp;quot;, e) 

In the call above, the argument to Display is a syntax tree from the expression evaluator in Section 7.9. The output of Display is shown below: 

```go
Display e (eval.call): 
e.fn = &amp;quot;sqrt&amp;quot;
e.args[0].type = eval.binary
e.args[0].value.op = 47 
e.args[0].value.x.type = eval.Var 
e.args[0].value.x.value = &amp;quot;A&amp;quot; 
e.args[0].value.y.type = eval.Var 
e.args[0].value.y.value = &amp;quot;pi&amp;quot; 

Where possible, you should avoid exposing reflection in the API of a package. We’ll define an unexported function display to do the real work of the recursion, and export Display, a simple wrapper around it that accepts an interface{} parameter: 

```go
// gopl.io/ch12/display 
func Display(name string, x interface{}) { 
fmt.Printf(&amp;quot;Display %s (%T):\n&amp;quot;, name, x) 

display(name, reflect.ValueOf(x)) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In display, we’ll use the formatAtom function we defined earlier to print elementary values—basic types, functions, and channels—but we’ll use the methods of reflect.Value to recursively display each component of a more complex type. As the recursion descends, the path string, which initially describes the starting value (for instance, &amp;ldquo;e&amp;rdquo;), will be augmented to indicate how we reached the current value (for instance, &amp;ldquo;e.args[0].value&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Since we’re no longer pretending to implement fmt.Sprint, we will use the fmt package to keep our example short.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func display(path string, v reflect.Value) { 
switch v.Kind() { 
case reflect.Invalid: 
fmt.Printf(&amp;quot;%s = invalid\n&amp;quot;, path) 
case reflect.Slice, reflect.Array: 
for i := 0; i &amp;lt; v.Len(); i++ {
display(fmt.Sprintf(&amp;quot;%s[%d]&amp;quot;, path, i), v.Index(i))
}
case reflect.Struct: 
for i := 0; i &amp;lt; v.NumField(); i++ {
fieldPath := fmt.Sprintf(&amp;quot;%s.%s&amp;quot;, path, v.Type().Field(i).Name)
display(fieldPath, v.Field(i)) 
}
case reflect.Map:
for _, key := range v.MapKeys() {
display(fmt.Sprintf(&amp;quot;%s[%s]&amp;quot;, path, 
formatAtom(key)), v.MapIndex(key)) 
}
case reflect.Ptr: 
if v.IsNil() {
fmt.Printf(&amp;quot;%s = nil\n&amp;quot;, path) 
} else {
display(fmt.Sprintf(&amp;quot;(*%s)&amp;quot;, path), 
v.Elem())}case reflect.Interface: if v.IsNil() {fmt.Printf(&amp;quot;%s = nil\n&amp;quot;, path) } else {fmt.Printf(&amp;quot;%s.type = %s\n&amp;quot;, path, v.Elem().Type())display(path+&amp;quot;.value&amp;quot;, v.Elem()) }default: // basic types, channels, funcs fmt.Printf(&amp;quot;%s = %s\n&amp;quot;, path, formatAtom(v)) }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s discuss the cases in order.
Slices and arrays: The logic is the same for both. The Len method returns the number of elements of a slice or array value, and Index(i) retrieves the element at index i, also as a reflect.Value; it panics if i is out of bounds. These are analogous to the built-in len(a) and a[i] operations on sequences. The display function recursively invokes itself on each element of the sequence, appending the subscript notation &amp;ldquo;[i]&amp;rdquo; to the path.&lt;/p&gt;

&lt;p&gt;Although reflect.Value has many methods, only a few are safe to call on any given value. For example, the Index method may be called on values of kind Slice, Array, or String, but panics for any other kind.&lt;/p&gt;

&lt;p&gt;Structs: The NumField method reports the number of fields in the struct, and Field(i) returns the value of the i-th field as a reflect.Value. The list of fields includes ones promoted from anonymous fields. To append the field selector notation &amp;ldquo;.f&amp;rdquo; to the path, we must obtain the reflect.Type of the struct and access the name of its i-th field.&lt;/p&gt;

&lt;p&gt;Maps: The MapKeys method returns a slice of reflect.Values, one per map key. As usual when iterating over a map, the order is undefined. MapIndex(key) returns the value corresponding to key. We append the subscript notation &amp;ldquo;[key]&amp;ldquo;to the path. (We’re cutting a corner here. The type of a map key isn’t restricted to the types formatAtom handles best; arrays, structs, and interfaces can also be valid map keys. Extending this case to print the key in full is Exercise 12.1.)&lt;/p&gt;

&lt;p&gt;Pointers: The Elem method returns the variable pointed to by a pointer, again as a reflect.Value. This operation would be safe even if the pointer value is nil, in which case the result would have kind Invalid, but we use IsNil to detect nil pointers explicitly so we can print a more appropriate message. We prefix the path with a &amp;ldquo;*&amp;rdquo; and parenthesize it to avoid ambiguity.&lt;/p&gt;

&lt;p&gt;Interfaces: Again, we use IsNil to test whether the interface is nil, and if not, we retrieve its dynamic value using v.Elem() and print its type and value.&lt;/p&gt;

&lt;p&gt;Now that our Display function is complete, let’s put it to work. The Movie type below is a slight variation on the one in Section 4.5:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Movie struct {
Title, Subtitle string 
Year int 
Color bool 
Actor map[string]string 
Oscars []string 
Sequel *string } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s declare a value of this type and see what Display does with it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;strangelove := Movie{ 
Title: &amp;quot;Dr. Strangelove&amp;quot;, 
Subtitle: &amp;quot;How I Learned to Stop Worrying and Love 
the Bomb&amp;quot;,
Year: 1964, 
Color: false, 
Actor: map[string]string{
&amp;quot;Dr. Strangelove&amp;quot;: &amp;quot;Peter Sellers&amp;quot;, 
&amp;quot;Grp. Capt. Lionel Mandrake&amp;quot;: &amp;quot;Peter Sellers&amp;quot;, 
&amp;quot;Pres. Merkin Muffley&amp;quot;: &amp;quot;Peter Sellers&amp;quot;, 
&amp;quot;Gen. Buck Turgidson&amp;quot;: &amp;quot;George C. 
Scott&amp;quot;, 
&amp;quot;Brig. Gen. Jack D. Ripper&amp;quot;: &amp;quot;Sterling 
Hayden&amp;quot;, 
`Maj. T.J. &amp;quot;King&amp;quot; Kong`: &amp;quot;Slim Pickens&amp;quot;, }, 
Oscars: []string{&amp;quot;Best Actor (Nomin.)&amp;quot;, &amp;quot;Best Adapted Screenplay (Nomin.)&amp;quot;, &amp;quot;Best Director (Nomin.)&amp;quot;, &amp;quot;Best Picture (Nomin.)&amp;quot;, 
}, 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call Display(&amp;ldquo;strangelove&amp;rdquo;, strangelove) prints:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Display strangelove (display.Movie): 
strangelove.Title = &amp;quot;Dr. Strangelove&amp;quot; 
strangelove.Subtitle = &amp;quot;How I Learned to Stop Worrying 
and Love the Bomb&amp;quot; 
strangelove.Year = 1964 
strangelove.Color = false 
strangelove.Actor[&amp;quot;Gen. Buck Turgidson&amp;quot;] = &amp;quot;George C. 
Scott&amp;quot; 
strangelove.Actor[&amp;quot;Brig. Gen. Jack D. Ripper&amp;quot;] = 
&amp;quot;Sterling Hayden&amp;quot;
strangelove.Actor[&amp;quot;Maj. T.J. \&amp;quot;King\&amp;quot; Kong&amp;quot;] = &amp;quot;Slim 
Pickens&amp;quot; 
strangelove.Actor[&amp;quot;Dr. Strangelove&amp;quot;] = &amp;quot;Peter Sellers&amp;quot; 
strangelove.Actor[&amp;quot;Grp. Capt. Lionel Mandrake&amp;quot;] = 
&amp;quot;Peter Sellers&amp;quot; 
strangelove.Actor[&amp;quot;Pres. Merkin Muffley&amp;quot;] = &amp;quot;Peter 
Sellers&amp;quot; 
strangelove.Oscars[0] = &amp;quot;Best Actor (Nomin.)&amp;quot; 
strangelove.Oscars[1] = &amp;quot;Best Adapted Screenplay 
(Nomin.)&amp;quot;
strangelove.Oscars[2] = &amp;quot;Best Director (Nomin.)&amp;quot; 
strangelove.Oscars[3] = &amp;quot;Best Picture (Nomin.)&amp;quot; 
strangelove.Sequel = nil 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use Display to display the internals of library types, such as *os.File:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Display(&amp;quot;os.Stderr&amp;quot;, os.Stderr) 
// Output: 
// Display os.Stderr (*os.File):
// (*(*os.Stderr).file).fd = 2 
// (*(*os.Stderr).file).name = &amp;quot;/dev/stderr&amp;quot; 
// (*(*os.Stderr).file).nepipe = 0 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that even unexported fields are visible to reflection. Beware that the particular output of this example may vary across platforms and may change over time as libraries evolve. (Those fields are private for a reason!) We can even apply Display to a reflect.Value and watch it traverse the internal representation of the type descriptor for *os.File. The output of the call Display(&amp;ldquo;rV&amp;rdquo;, reflect.ValueOf(os.Stderr)) is shown below, though of course your mileage may vary:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Display rV (reflect.Value):
(*rV.typ).size = 8 
(*rV.typ).hash = 871609668 
(*rV.typ).align = 8 
(*rV.typ).fieldAlign = 8 
(*rV.typ).kind = 22 
(*(*rV.typ).string) = &amp;quot;*os.File&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;(*(*(*rV.typ).uncommonType).methods[0].name) = &amp;quot;Chdir&amp;quot; 
(*(*(*(*rV.typ).uncommonType).methods[0].mtyp).string)
= &amp;quot;func() error&amp;quot; 
(*(*(*(*rV.typ).uncommonType).methods[0].typ).string)
= &amp;quot;func(*os.File) error&amp;quot; 
... 

Observe the difference between these two examples: 
var i interface{} = 3 
Display(&amp;quot;i&amp;quot;, i) 
// Output: 

// Display i (int): 
// i = 3 

Display(&amp;quot;&amp;amp;i&amp;quot;, &amp;amp;i) 
// Output: 
// Display &amp;amp;i (*interface {}): 
// (*&amp;amp;i).type = int 
// (*&amp;amp;i).value = 3 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the first example, Display calls reflect.ValueOf(i), which returns a value of kind Int. As we mentioned in Section 12.2, reflect.ValueOf always returns a Value of a concrete type since it extracts the contents of an interface value.&lt;/p&gt;

&lt;p&gt;In the second example, Display calls reflect.ValueOf(&amp;amp;i), which returns a pointer to i, of kind Ptr. The switch case for Ptr calls Elem on this value, which returns a Value representing the variable i itself, of kind Interface.A Value obtained indirectly, like this one, may represent any value at all, including interfaces. The display function calls itself recursively and this time, it prints separate components for the interface’s dynamic type and value.&lt;/p&gt;

&lt;p&gt;As currently implemented, Display will never terminate if it encounters a cycle in the object graph, such as this linked list that eats its own tail:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// a struct that points to itself 
type Cycle struct{ Value int; Tail *Cycle }
var c Cycle 
c = Cycle{42, &amp;amp;c} 
Display(&amp;quot;c&amp;quot;, c) 

Display prints this ever-growing expansion: 

```go
Display c (display.Cycle): 
c.Value = 42 
(*c.Tail).Value = 42 
(*(*c.Tail).Tail).Value = 42 
(*(*(*c.Tail).Tail).Tail).Value = 42 
...ad infinitum... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Many Go programs contain at least some cyclic data. Making Display robust against such cycles is tricky, requiring additional bookkeeping to record the set of references that have been followed so far; it is costly too. A general solution requires unsafe language features, as we will see in Section 13.3.&lt;/p&gt;

&lt;p&gt;Cycles pose less of a problem for fmt.Sprint because it rarely tries to print the complete structure. For example, when it encounters a pointer, it breaks the recursion by printing the pointer’s numeric value. It can get stuck trying to print a slice or map that contains itself as an element, but such rare cases do not warrant the considerable extra trouble of handling cycles.&lt;/p&gt;

&lt;p&gt;Exercise 12.1: Extend Display so that it can display maps whose keys are structs or arrays.&lt;/p&gt;

&lt;p&gt;Exercise 12.2: Make display safe to use on cyclic data structures by bounding the number of steps it takes before abandoning the recursion. (In Section 13.3, we’ll see another way to detect cycles.)&lt;/p&gt;

&lt;h2 id=&#34;example-encoding-s-expressions:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Example: Encoding S-Expressions&lt;/h2&gt;

&lt;p&gt;Display is a debugging routine for displaying structured data, but it’s not far short of being able to encode or marshal arbitrary Go objects as messages in a portable notation suitable for inter-process communication.&lt;/p&gt;

&lt;p&gt;As we saw in Section 4.5, Go’s standard library supports a variety of formats, including JSON, XML, and ASN.1. Another notation that is still widely used is S-expressions, the syntax of Lisp. Unlike the other notations, S-expressions are not supported by the Go standard library, not least because they have no universally accepted definition, despite several attempts at standardization and the existence of many implementations.&lt;/p&gt;

&lt;p&gt;In this section, we’ll define a package that encodes arbitrary Go objects using an S-expression notation that supports the following constructs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;42 integer 
&amp;quot;hello&amp;quot; string (with Go-style quotation) 
foo symbol (an unquoted name) 
(1 2 3) list (zero or more items enclosed in parentheses) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Booleans are traditionally encoded using the symbol t for true, and the empty list () or the symbol nil for false, but for simplicity, our implementation ignores them. It also ignores channels and functions, since their state is opaque to reflection. And it ignores real and complex floating-point numbers and interfaces. Adding support for them is Exercise 12.3.&lt;/p&gt;

&lt;p&gt;We’ll encode the types of Go using S-expressions as follows. Integers and strings are encoded in the obvious way. Nil values are encoded as the symbol nil. Arrays and slices are encoded using list notation.&lt;/p&gt;

&lt;p&gt;Structs are encoded as a list of field bindings, each field binding being a two-element list whose first element (a symbol) is the field name and whose second element is the field value. Maps too are encoded as a list of pairs, with each pair being the key and value of one map entry. Traditionally, S-expressions represent lists of key/value pairs using a single cons cell (key . value) for each pair, rather than a two-element list, but to simplify the decoding we’ll ignore dotted list notation.&lt;/p&gt;

&lt;p&gt;Encoding is done by a single recursive function, encode, shown below. Its structure is essentially the same as that of Display in the previous section:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch12/sexpr 
func encode(buf *bytes.Buffer, v reflect.Value) error 
{ 
switch v.Kind() { 
case reflect.Invalid: 

buf.WriteString(&amp;quot;nil&amp;quot;) 
case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: fmt.Fprintf(buf, &amp;quot;%d&amp;quot;, v.Int()) 
case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:fmt.Fprintf(buf, &amp;quot;%d&amp;quot;, v.Uint()) 
case reflect.String:
fmt.Fprintf(buf, &amp;quot;%q&amp;quot;, v.String()) 

case reflect.Ptr: 
return encode(buf, v.Elem()) 

case reflect.Array, reflect.Slice: // (value ...) buf.WriteByte(&#39;(&#39;)for i := 0; i &amp;lt; v.Len(); i++ {
if i &amp;gt; 0 {
buf.WriteByte(&#39; &#39;) }if err := encode(buf, v.Index(i)); err != 
nil { 
return err 

}}buf.WriteByte(&#39;)&#39;) 
case reflect.Struct: // ((name value) ...) 
buf.WriteByte(&#39;(&#39;)
for i := 0; i &amp;lt; v.NumField(); i++ {
if i &amp;gt; 0 {
buf.WriteByte(&#39; &#39;) 
}
fmt.Fprintf(buf, &amp;quot;(%s &amp;quot;, v.Type().Field(i).Name)
if err := encode(buf, v.Field(i)); err != nil { 
return err 
}
buf.WriteByte(&#39;)&#39;) 
}
buf.WriteByte(&#39;)&#39;) 
case reflect.Map: // ((key value) ...) 
buf.WriteByte(&#39;(&#39;)
for i, key := range v.MapKeys() { 
if i &amp;gt; 0 {
buf.WriteByte(&#39; &#39;) 
}
buf.WriteByte(&#39;(&#39;)
if err := encode(buf, key); err != nil {
return err 
}
buf.WriteByte(&#39; &#39;) 
if err := encode(buf, v.MapIndex(key)); err != nil { 
return err 
}
buf.WriteByte(&#39;)&#39;) 
}
buf.WriteByte(&#39;)&#39;) 
default: // float, complex, bool, chan, func, interface return fmt.Errorf(&amp;quot;unsupported type: %s&amp;quot;, 
v.Type())
}
return nil 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Marshal function wraps the encoder in an API similar to those of the other encoding/&amp;hellip; packages:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Marshal encodes a Go value in S-expression form. 
func Marshal(v interface{}) ([]byte, error) { 
var buf bytes.Buffer 
if err := encode(&amp;amp;buf, reflect.ValueOf(v)); err != 
nil { return nil, err }
return buf.Bytes(), nil } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here’s the output of Marshal applied to the strangelove variable from Section 12.3:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;((Title &amp;quot;Dr. Strangelove&amp;quot;) (Subtitle &amp;quot;How I Learned to 
Stop Worrying and Lo 
ve the Bomb&amp;quot;) (Year 1964) (Actor ((&amp;quot;Grp. Capt. Lionel 
Mandrake&amp;quot; &amp;quot;Peter Sell 
ers&amp;quot;) (&amp;quot;Pres. Merkin Muffley&amp;quot; &amp;quot;Peter Sellers&amp;quot;) (&amp;quot;Gen. 
Buck Turgidson&amp;quot; &amp;quot;Geor 
ge C. Scott&amp;quot;) (&amp;quot;Brig. Gen. Jack D. Ripper&amp;quot; &amp;quot;Sterling 
Hayden&amp;quot;) (&amp;quot;Maj. T.J. \ 
&amp;quot;King\&amp;quot; Kong&amp;quot; &amp;quot;Slim Pickens&amp;quot;) (&amp;quot;Dr. Strangelove&amp;quot; 
&amp;quot;Peter Sellers&amp;quot;))) (Oscars 
(&amp;quot;Best Actor (Nomin.)&amp;quot; &amp;quot;Best Adapted Screenplay 
(Nomin.)&amp;quot; &amp;quot;Best Director (N 
omin.)&amp;quot; &amp;quot;Best Picture (Nomin.)&amp;quot;)) (Sequel nil)) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The whole output appears on one long line with minimal spaces, making it hard to read. Here’s the same output manually formatted according to S-expression conventions. Writing a pretty-printer for S-expressions is left as a (challenging) exercise; the download from gopl.io includes a simple version.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;((Title &amp;quot;Dr. Strangelove&amp;quot;) 
(Subtitle &amp;quot;How I Learned to Stop Worrying and Love 
the Bomb&amp;quot;)
(Year 1964) 
(Actor ((&amp;quot;Grp. Capt. Lionel Mandrake&amp;quot; &amp;quot;Peter 
Sellers&amp;quot;)(&amp;quot;Pres. Merkin Muffley&amp;quot; &amp;quot;Peter Sellers&amp;quot;) 
(&amp;quot;Gen. Buck Turgidson&amp;quot; &amp;quot;George C. Scott&amp;quot;) 
(&amp;quot;Brig. Gen. Jack D. Ripper&amp;quot; &amp;quot;Sterling Hayden&amp;quot;) (&amp;quot;Maj. T.J. \&amp;quot;King\&amp;quot; Kong&amp;quot; &amp;quot;Slim Pickens&amp;quot;) 
(&amp;quot;Dr. Strangelove&amp;quot; &amp;quot;Peter Sellers&amp;quot;))) 
(Oscars (&amp;quot;Best Actor (Nomin.)&amp;quot; 
&amp;quot;Best Adapted Screenplay (Nomin.)&amp;quot; 
&amp;quot;Best Director (Nomin.)&amp;quot; 
&amp;quot;Best Picture (Nomin.)&amp;quot;)) 
(Sequel nil)) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the fmt.Print, json.Marshal, and Display functions, sexpr.Marshal will loop forever if called with cyclic data.
In Section 12.6, we’ll sketch out the implementation of the corresponding S-expression decoding function, but before we get there, we’ll first need to understand how reflection can be used to update program variables.&lt;/p&gt;

&lt;p&gt;Exercise 12.3: Implement the missing cases of the encode function. Encode booleans as t and nil, floating-point numbers using Go’s notation, and complex numbers like 1+2i as #C(1.0 2.0) . Interfaces can be encoded as a pair of a type name and a value, for instance (&amp;rdquo;[]int&amp;rdquo; (1 2 3)) , but beware that this notation is ambiguous: the reflect.Type.String method may return the same string for different types.&lt;/p&gt;

&lt;p&gt;Exercise 12.4: Modify encode to pretty-print the S-expression in the style shown above.&lt;/p&gt;

&lt;p&gt;Exercise 12.5: Adapt encode to emit JSON instead of S-expressions. Test your encoder using the standard decoder, json.Unmarshal.&lt;/p&gt;

&lt;p&gt;Exercise 12.6: Adapt encode so that, as an optimization, it does not encode a field&lt;/p&gt;

&lt;p&gt;whose value is the zero value of its type.&lt;/p&gt;

&lt;p&gt;Exercise 12.7: Create a streaming API for the S-expression decoder, following the
style of json.Decoder (§4.5).&lt;/p&gt;

&lt;h2 id=&#34;setting-variables-with:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Setting Variables with&lt;/h2&gt;

&lt;p&gt;reflect.Value
So far, reflection has only interpreted values in our program in various ways. The point of this section, however, is to change them.
Recall that some Go expressions like x, x.f[1], and *p denote variables, but others like x+1 and f(2) do not. A variable is an addressable storage location that contains a value, and its value may be updated through that address.&lt;/p&gt;

&lt;p&gt;A similar distinction applies to reflect.Values. Some are addressable; others are not. Consider the following declarations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x := 2 // value type variable? a := reflect.ValueOf(2) // 2 int no b := reflect.ValueOf(x) // 2 int no c := reflect.ValueOf(&amp;amp;x) // &amp;amp;x *int no d := c.Elem() // 2 int yes (x) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The value within a is not addressable. It is merely a copy of the integer 2. The same is true of b. The value within c is also non-addressable, being a copy of the pointer value &amp;amp;x. In fact, no reflect.Value returned by reflect.ValueOf(x) is addressable. But d, derived from c by dereferencing the pointer within it, refers to a variable and is thus addressable. We can use this approach, calling reflect.ValueOf(&amp;amp;x).Elem(), to obtain an addressable Value for any variable x.
Wecanask a reflect.Value whether it is addressable through its CanAddr method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(a.CanAddr()) // &amp;quot;false&amp;quot; 
fmt.Println(b.CanAddr()) // &amp;quot;false&amp;quot; 
fmt.Println(c.CanAddr()) // &amp;quot;false&amp;quot; 
fmt.Println(d.CanAddr()) // &amp;quot;true&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We obtain an addressable reflect.Value whenever we indirect through a pointer, even if we started from a non-addressable Value. All the usual rules for addressability have analogs for reflection. For example, since the slice indexing expression e[i] implicitly follows a pointer, it is addressable even if the expression e is not. By analogy, reflect.ValueOf(e).Index(i) refers to a variable, and is thus addressable even if reflect.ValueOf(e) is not.&lt;/p&gt;

&lt;p&gt;To recover the variable from an addressable reflect.Value requires three steps. First, we call Addr(), which returns a Value holding a pointer to the variable. Next, we call Interface() on this Value, which returns an interface{}value containing the pointer.
Finally, if we know the type of the variable, we can use a type assertion to retrieve the contents of the interface as an ordinary pointer. We can then update the variable through the pointer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x := 2 
d := reflect.ValueOf(&amp;amp;x).Elem() // d refers to the 
variable x 
px := d.Addr().Interface().(*int) // px := &amp;amp;x 
*px =3 // x=3 
fmt.Println(x) // &amp;quot;3&amp;quot; 
Or, we can update the variable referred to by an addressable reflect.Value directly, without using a pointer, by calling the reflect.Value.Set method: 
d.Set(reflect.ValueOf(4))
fmt.Println(x) // &amp;quot;4&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same checks for assignability that are ordinarily performed by the compiler are done at run time by the Set methods. Above, the variable and the value both have type int, but if the variable had been an int64, the program would panic, so it’s crucial to make sure the value is assignable to the type of the variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;d.Set(reflect.ValueOf(int64(5))) // panic: int64 is 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;not assignable to int&lt;/p&gt;

&lt;p&gt;And of course calling Set on a non-addressable reflect.Value panics too:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x := 2 
b := reflect.ValueOf(x)
b.Set(reflect.ValueOf(3)) // panic: Set using 
unaddressable value 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are variants of Set specialized for certain groups of basic types: SetInt, SetUint, SetString, SetFloat, and so on:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;d := reflect.ValueOf(&amp;amp;x).Elem()
d.SetInt(3)
fmt.Println(x) // &amp;quot;3&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In some ways these methods are more forgiving. SetInt, for example, will succeed so long as the variable’s type is some kind of signed integer, or even a named type whose underlying type is a signed integer, and if the value is too large it will be quietly truncated to fit. But tread carefully: calling SetInt on a reflect.Value that refers to an interface{} variable will panic, even though Set would succeed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x := 1 
rx := reflect.ValueOf(&amp;amp;x).Elem()
rx.SetInt(2) // OK, x = 2 
rx.Set(reflect.ValueOf(3)) // OK, x = 3 
rx.SetString(&amp;quot;hello&amp;quot;) // panic: string is 
not assignable to int 
rx.Set(reflect.ValueOf(&amp;quot;hello&amp;quot;)) // panic: string is 
not assignable to int 

var y interface{} 
ry := reflect.ValueOf(&amp;amp;y).Elem()
ry.SetInt(2) // panic: SetInt 
called on interface Value 
ry.Set(reflect.ValueOf(3)) // OK, y = int(3) 
ry.SetString(&amp;quot;hello&amp;quot;) // panic: SetString 
called on interface Value 
ry.Set(reflect.ValueOf(&amp;quot;hello&amp;quot;)) // OK, y = &amp;quot;hello&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we applied Display to os.Stdout, we found that reflection can read the values of unexported struct fields that are inaccessible according to the usual rules of the language, like the fd int field of an os.File struct on a Unix-like platform. However, reflection cannot update such values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;stdout := reflect.ValueOf(os.Stdout).Elem() //
*os.Stdout, an os.File var 
fmt.Println(stdout.Type()) // 
&amp;quot;os.File&amp;quot; 
fd := stdout.FieldByName(&amp;quot;fd&amp;quot;)
fmt.Println(fd.Int()) // &amp;quot;1&amp;quot; 
fd.SetInt(2) // panic: unexported field 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An addressable reflect.Value records whether it was obtained by traversing an unexported struct field and, if so, disallows modification. Consequently, CanAddr is not usually the right check to use before setting a variable. The related method CanSet reports whether a reflect.Value is addressable and settable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(fd.CanAddr(), fd.CanSet()) // &amp;quot;true false&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;example-decoding-s-expressions:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Example: Decoding S-Expressions&lt;/h2&gt;

&lt;p&gt;For each Marshal function provided by the standard library’s encoding/&amp;hellip; packages, there is a corresponding Unmarshal function that does decoding. For example, as we saw in Section 4.5, given a byte slice containing JSON-encoded data for our Movie type (§12.3), we can decode it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;data := []byte{/* ... */} 
var movie Movie 
err := json.Unmarshal(data, &amp;amp;movie) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Unmarshal function uses reflection to modify the fields of the existing movie variable, creating new maps, structs, and slices as determined by the type Movie and the content of the incoming data.&lt;/p&gt;

&lt;p&gt;Let’s now implement a simple Unmarshal function for S-expressions, analogous to the standard json.Unmarshal function used above, and the inverse of our earlier sexpr.Marshal. We must caution you that a robust and general implementation requires substantially more code than will comfortably fit in this example, which is already long, so we have taken many shortcuts. We support only a limited subset of S-expressions and do not handle errors gracefully. The code is intended to illustrate reflection, not parsing.&lt;/p&gt;

&lt;p&gt;The lexer uses the Scanner type from the text/scanner package to break an input stream into a sequence of tokens such as comments, identifiers, string literals, and numeric literals. The scanner’s Scan method advances the scanner and returns the kind of the next token, which has type rune. Most tokens, like &amp;lsquo;(&amp;rsquo;, consist of a single rune, but the text/scanner package represents the kinds of the multi-character tokens Ident, String, and Int using small negative values of type rune. Following a call to Scan that returns one of these kinds of token, the scanner’s TokenText method returns the text of the token.&lt;/p&gt;

&lt;p&gt;Since a typical parser may need to inspect the current token several times, but the Scan method advances the scanner, we wrap the scanner in a helper type called lexer that keeps track of the token most recently returned by Scan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch12/sexpr 
type lexer struct {
scan scanner.Scanner 
token rune // the current token 

} 
func (lex *lexer) next() { lex.token = 
lex.scan.Scan() }
func (lex *lexer) text() string { return 
lex.scan.TokenText() } 

func (lex *lexer) consume(want rune) { if lex.token != want { // NOTE: Not an example of good error handling.panic(fmt.Sprintf(&amp;quot;got %q, want %q&amp;quot;, 
lex.text(), want)) 
}
lex.next() 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let’s turn to the parser. It consists of two principal functions. The first of these, read, reads the S-expression that starts with the current token and updates the variable referred to by the addressable reflect.Value v.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func read(lex *lexer, v reflect.Value) { 
switch lex.token {
case scanner.Ident: 

// The only valid identifiers are // &amp;quot;nil&amp;quot; and struct field names. if lex.text() == &amp;quot;nil&amp;quot; {
v.Set(reflect.Zero(v.Type()))
lex.next()
return 

}case scanner.String:s, _ := strconv.Unquote(lex.text()) // NOTE: ignoring errors v.SetString(s) 
lex.next()return 
case scanner.Int: 
i, _ := strconv.Atoi(lex.text()) // NOTE: ignoring errors v.SetInt(int64(i))
lex.next()
return 
case &#39;(&#39;:
lex.next()
readList(lex, v) 
lex.next() // consume &#39;)&#39; 
return 
}
panic(fmt.Sprintf(&amp;quot;unexpected token %q&amp;quot;, 
lex.text()))
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our S-expressions use identifiers for two distinct purposes, struct field names and the nil value for a pointer. The read function only handles the latter case. When it encounters the scanner.Ident &amp;ldquo;nil&amp;rdquo;, it sets v to the zero value of its type using the reflect.Zero function. For any other identifier, it reports an error. The readList function, which we’ll see in a moment, handles identifiers used as struct field names.&lt;/p&gt;

&lt;p&gt;A &amp;lsquo;(&amp;rsquo; token indicates the start of a list. The second function, readList, decodes a list into a variable of composite type—a map, struct, slice, or array—depending on what kind of Go variable we’re currently populating. In each case, the loop keeps parsing items until it encounters the matching close parenthesis, &amp;lsquo;)&amp;rsquo;, as detected by the endList function.&lt;/p&gt;

&lt;p&gt;The interesting part is the recursion. The simplest case is an array. Until the closing &amp;lsquo;)&amp;rsquo; is seen, we use Index to obtain the variable for each array element and make a recursive call to read to populate it. As in many other error cases, if the input data causes the decoder to index beyond the end of the array, the decoder panics. A similar approach is used for slices, except we must create a new variable for each element, populate it, then append it to the slice.&lt;/p&gt;

&lt;p&gt;The loops for structs and maps must parse a (key value) sublist on each iteration. For structs, the key is a symbol identifying the field. Analogous to the case for arrays, we obtain the existing variable for the struct field using FieldByNameand make a recursive call to populate it. For maps, the key may be of any type, and analogous to the case for slices, we create a new variable, recursively populate it, and finally insert the new key/value pair into the map.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func readList(lex *lexer, v reflect.Value) { 
switch v.Kind() { 
case reflect.Array: // (item ...) 

for i := 0; !endList(lex); i++ {read(lex, v.Index(i)) } 
case reflect.Slice: // (item ...) 
for !endList(lex) {
item := 

reflect.New(v.Type().Elem()).Elem()
read(lex, item)
v.Set(reflect.Append(v, item)) 

} 
case reflect.Struct: // ((name value) ...) 
for     !endList(lex) {lex.consume(&#39;(&#39;)if lex.token != scanner.Ident {
panic(fmt.Sprintf(&amp;quot;got token %q, want 
field name&amp;quot;, lex.text())) 
}
name := lex.text()
lex.next()
read(lex, v.FieldByName(name))
lex.consume(&#39;)&#39;) 

} 
case reflect.Map: // ((key value) ...)
v.Set(reflect.MakeMap(v.Type()))
for !endList(lex) {

lex.consume(&#39;(&#39;)key := reflect.New(v.Type().Key()).Elem() 
read(lex, key) 
value := 

reflect.New(v.Type().Elem()).Elem()
read(lex, value)
v.SetMapIndex(key, value) 
lex.consume(&#39;)&#39;) 

} 
default: 
panic(fmt.Sprintf(&amp;quot;cannot decode list into 
%v&amp;quot;, v.Type())) 
}
} 

func endList(lex *lexer) bool {
switch lex.token {
case scanner.EOF: 

panic(&amp;quot;end of file&amp;quot;) 
case &#39;)&#39;:

return true 
}
return false 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we wrap up the parser in an exported function Unmarshal, shown below, that hides some of the rough edges of the implementation. Errors encountered during parsing result in a panic, so Unmarshal uses a deferred call to recover from the panic (§5.10) and return an error message instead.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Unmarshal parses S-expression data and populates the variable // whose address is in the non-nil pointer out. func Unmarshal(data []byte, out interface{}) (err error) {
lex := &amp;amp;lexer{scan: scanner.Scanner{Mode: 
scanner.GoTokens}}
lex.scan.Init(bytes.NewReader(data))
lex.next() // get the first token 

defer func() { 
// NOTE: this is not an example of ideal error handling.
if x := recover(); x != nil {
err = fmt.Errorf(&amp;quot;error at %s: %v&amp;quot;, lex.scan.Position, x) 
}}()
read(lex, reflect.ValueOf(out).Elem()) 
return nil 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A production-quality implementation should never panic for any input and should report an informative error for every mishap, perhaps with a line number or offset. Nonetheless, we hope this example conveys some idea of what’s happening under the hood of the packages like encoding/json, and how you can use reflection to populate data structures.&lt;/p&gt;

&lt;p&gt;Exercise 12.8: The sexpr.Unmarshal function, like json.Marshal, requires the complete input in a byte slice before it can begin decoding. Define a sexpr.Decoder type that, like json.Decoder, allows a sequence of values to be decoded from an io.Reader. Change sexpr.Unmarshal to use this new type.&lt;/p&gt;

&lt;p&gt;Exercise 12.9: Write a token-based API for decoding S-expressions, following the style of xml.Decoder (§7.14). You will need five types of tokens: Symbol, String, Int, StartList, and EndList.&lt;/p&gt;

&lt;p&gt;Exercise 12.10: Extend sexpr.Unmarshal to handle the booleans, floating-point numbers, and interfaces encoded by your solution to Exercise 12.3. (Hint: to decode interfaces, you will need a mapping from the name of each supported type to its reflect.Type.)&lt;/p&gt;

&lt;h2 id=&#34;accessing-struct-field-tags:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Accessing Struct Field Tags&lt;/h2&gt;

&lt;p&gt;In Section 4.5 we used struct field tags to modify the JSON encoding of Go struct values. The json field tag lets us choose alternative field names and suppress the output of empty fields. In this section, we’ll see how to access field tags using reflection.
In a web server, the first thing most HTTP handler functions do is extract the request parameters into local variables. We’ll define a utility function, params.Unpack, that uses struct field tags to make writing HTTP handlers (§7.7) more convenient.&lt;/p&gt;

&lt;p&gt;First, we’ll show how it’s used. The search function below is an HTTP handler. It defines a variable called data of an anonymous struct type whose fields correspond to the HTTP request parameters. The struct’s field tags specify the parameter names, which are often short and cryptic since space is precious in a URL. The Unpackfunction populates the struct from the request so that the parameters can be accessed conveniently and with an appropriate type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch12/search 
import &amp;quot;// gopl.io/ch12/params&amp;quot; 
// search implements the /search URL endpoint. 
func search(resp http.ResponseWriter, req 
*http.Request) {
var data struct {
Labels []string `http:&amp;quot;l&amp;quot;` 
MaxResults int `http:&amp;quot;max&amp;quot;` 
Exact bool `http:&amp;quot;x&amp;quot;` }
data.MaxResults = 10 // set default 
if err := params.Unpack(req, &amp;amp;data); err != nil {
http.Error(resp, err.Error(), 
http.StatusBadRequest) // 400 
return 
} 
// ...rest of handler... 
fmt.Fprintf(resp, &amp;quot;Search: %+v\n&amp;quot;, data) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Unpack function below does three things. First, it calls req.ParseForm() to parse the request. Thereafter, req.Form contains all the parameters, regardless of whether the HTTP client used the GET or the POST request method.&lt;/p&gt;

&lt;p&gt;Next, Unpack builds a mapping from the effective name of each field to the variable for that field. The effective name may differ from the actual name if the field has a tag. The Field method of reflect.Type returns a reflect.StructField that provides information about the type of each field such as its name, type, and optional tag. The Tag field is a reflect.StructTag, which is a string type that provides a Get method to parse and extract the substring for a particular key, such as http:&amp;ldquo;&amp;hellip;&amp;rdquo; in this case.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch12/params 
// Unpack populates the fields of the struct pointed to by ptr // from the HTTP request parameters in req. func Unpack(req *http.Request, ptr interface{}) error { 
if err := req.ParseForm(); err != nil {return err } 
// Build map of fields keyed by effective name. fields := make(map[string]reflect.Value) v := reflect.ValueOf(ptr).Elem() // the struct 
variable 
for i := 0; i &amp;lt; v.NumField(); i++ {
fieldInfo := v.Type().Field(i) // a 
reflect.StructField 
tag := fieldInfo.Tag // a 

reflect.StructTag
name := tag.Get(&amp;quot;http&amp;quot;) 
if name == &amp;quot;&amp;quot; {

name = strings.ToLower(fieldInfo.Name) 
}
fields[name] = v.Field(i) 
} 

// Update struct field for each parameter in the request.
for name, values := range req.Form {
f := fields[name] 
if !f.IsValid() {
continue // ignore unrecognized HTTP parameters
}
for _, value := range values {
if f.Kind() == reflect.Slice {
elem := 
reflect.New(f.Type().Elem()).Elem()
if err := populate(elem, value); err != nil { return fmt.Errorf(&amp;quot;%s: %v&amp;quot;, name, err) }
f.Set(reflect.Append(f, elem)) 
} else {
if err := populate(f, value); err != 
nil { return fmt.Errorf(&amp;quot;%s: %v&amp;quot;, name, err) }}}}
return nil 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, Unpack iterates over the name/value pairs of the HTTP parameters and updates the corresponding struct fields. Recall that the same parameter name may appear more than once. If this happens, and the field is a slice, then all the values of that parameter are accumulated into the slice. Otherwise, the field is repeatedly overwritten so that only the last value has any effect.&lt;/p&gt;

&lt;p&gt;The populate function takes care of setting a single field v (or a single element of a slice field) from a parameter value. For now, it supports only strings, signed integers, and booleans. Supporting other types is left as an exercise.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func populate(v reflect.Value, value string) error {switch v.Kind() { case reflect.String:
v.SetString(value) 
case reflect.Int: i, err := strconv.ParseInt(value, 10, 64) if err != nil {
return err 
}
v.SetInt(i) 

case reflect.Bool: 
b, err := strconv.ParseBool(value) 
if err != nil {

return err 
}
v.SetBool(b) 

default: return fmt.Errorf(&amp;quot;unsupported kind %s&amp;quot;, 
v.Type())
}
return nil 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we add the server handler to a web server, this might be a typical session:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch12/search 
$ ./search &amp;amp; 
$ ./fetch &#39;http://localhost:12345/search&#39; 
Search: {Labels:[] MaxResults:10 Exact:false} 
$ ./fetch &#39;http://localhost:12345/search? 

l=golang&amp;amp;l=programming&#39;
Search: {Labels:[golang programming] MaxResults:10 
Exact:false}
$ ./fetch &#39;http://localhost:12345/search?
l=golang&amp;amp;l=programming&amp;amp;max=100&#39;
Search: {Labels:[golang programming] MaxResults:100 
Exact:false}
$ ./fetch &#39;http://localhost:12345/search?
x=true&amp;amp;l=golang&amp;amp;l=programming&#39;
Search: {Labels:[golang programming] MaxResults:10 
Exact:true}
$ ./fetch &#39;http://localhost:12345/search?
q=hello&amp;amp;x=123&#39;

x: strconv.ParseBool: parsing &amp;quot;123&amp;quot;: invalid syntax 
$ ./fetch &#39;http://localhost:12345/search?
q=hello&amp;amp;max=lots&#39;
max: strconv.ParseInt: parsing &amp;quot;lots&amp;quot;: invalid syntax 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exercise 12.11: Write the corresponding Pack function. Given a struct value, Pack should return a URL incorporating the parameter values from the struct.&lt;/p&gt;

&lt;p&gt;Exercise 12.12: Extend the field tag notation to express parameter validity requirements. For example, a string might need to be a valid email address or credit-card number, and an integer might need to be a valid US ZIP code. Modify Unpack to check these requirements.&lt;/p&gt;

&lt;p&gt;Exercise 12.13: Modify the S-expression encoder (§12.4) and decoder (§12.6) so that they honor the sexpr:&amp;ldquo;&amp;hellip;&amp;rdquo; field tag in a similar manner to encoding/json (§4.5).&lt;/p&gt;

&lt;h2 id=&#34;displaying-the-methods-of-a-type:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Displaying the Methods of a Type&lt;/h2&gt;

&lt;p&gt;Our final example of reflection uses reflect.Type to print the type of an arbitrary value and enumerate its methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch12/methods 
// Print prints the method set of the value x. 
func Print(x interface{}) { 
v := reflect.ValueOf(x) 
t := v.Type()
fmt.Printf(&amp;quot;type %s\n&amp;quot;, t) 

for     i := 0; i &amp;lt; v.NumMethod(); i++ {
methType := v.Method(i).Type()
fmt.Printf(&amp;quot;func (%s) %s%s\n&amp;quot;, t, 

t.Method(i).Name,
strings.TrimPrefix(methType.String(), 
&amp;quot;func&amp;quot;))
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both reflect.Type and reflect.Value have a method called Method. Each t.Method(i) call returns an instance of reflect.Method, a struct type that describes the name and type of a single method. Each v.Method(i) call returns a reflect.Value representing a method value (§6.4), that is, a method bound to its receiver. Using the reflect.Value.Call method (which we don’t have space to show here), it’s possible to call Values of kind Func like this one, but this program needs only its Type.&lt;/p&gt;

&lt;p&gt;Here are the methods belonging to two types, time.Duration and *strings.Replacer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;methods.Print(time.Hour)
// Output: 
// type time.Duration 

// func (time.Duration) Hours() float64 
// func (time.Duration) Minutes() float64 
// func (time.Duration) Nanoseconds() int64 
// func (time.Duration) Seconds() float64 
// func (time.Duration) String() string 

methods.Print(new(strings.Replacer))
// Output: 
// type *strings.Replacer 
// func (*strings.Replacer) Replace(string) string 
// func (*strings.Replacer) WriteString(io.Writer, 
string) (int, error) 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-word-of-caution:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;A Word of Caution&lt;/h2&gt;

&lt;p&gt;There is a lot more to the reflection API than we have space to show, but the preceding examples give an idea of what is possible. Reflection is a powerful and expressive tool, but it should be used with care, for three reasons.&lt;/p&gt;

&lt;p&gt;The first reason is that reflection-based code can be fragile. For every mistake that would cause a compiler to report a type error, there is a corresponding way to misuse reflection, but whereas the compiler reports the mistake at build time, a reflection error is reported during execution as a panic, possibly long after the program was written or even long after it has started running.&lt;/p&gt;

&lt;p&gt;If the readList function (§12.6), for example, should read a string from the input while populating a variable of type int, the call to reflect.Value.SetString will panic. Most programs that use reflection have similar hazards, and considerable care is required to keep track of the type, addressability, and settability of each reflect.Value.&lt;/p&gt;

&lt;p&gt;The best way to avoid this fragility is to ensure that the use of reflection is fully encapsulated within your package and, if possible, avoid reflect.Value in favor of specific types in your package’s API, to restrict inputs to legal values. If this is not possible, perform additional dynamic checks before each risky operation. As an example from the standard library, when fmt.Printf applies a verb to an inappropriate operand, it does not panic mysteriously but prints an informative error message. The program still has a bug, but it is easier to diagnose.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Printf(&amp;quot;%d %s\n&amp;quot;, &amp;quot;hello&amp;quot;, 42) // 
&amp;quot;%!d(string=hello) %!s(int=42)&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reflection also reduces the safety and accuracy of automated refactoring and analysis tools, because they can’t determine or rely on type information.&lt;/p&gt;

&lt;p&gt;The second reason to avoid reflection is that since types serve as a form of documentation and the operations of reflection cannot be subject to static type checking, heavily reflective code is often hard to understand. Always carefully document the expected types and other invariants of functions that accept an interface{} or a reflect.Value.&lt;/p&gt;

&lt;p&gt;The third reason is that reflection-based functions may be one or two orders of magnitude slower than code specialized for a particular type. In a typical program, the majority of functions are not relevant to the overall performance, so it’s fine to use reflection when it makes the program clearer. Testing is a particularly good fit for reflection since most tests use small data sets. But for functions on the critical path, reflection is best avoided.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Low-Level Programming&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The design of Go guarantees a number of safety properties that limit the ways in which a Go program can “go wrong.” During compilation, type checking detects most attempts to apply an operation to a value that is inappropriate for its type, for instance, subtracting one string from another. Strict rules for type conversions prevent direct access to the internals of built-in types like strings, maps, slices, and channels.&lt;/p&gt;

&lt;p&gt;For errors that cannot be detected statically, such as out-of-bounds array accesses or nil pointer dereferences, dynamic checks ensure that the program immediately terminates with an informative error whenever a forbidden operation occurs. Automatic memory management (garbage collection) eliminates “use after free” bugs, as well as most memory leaks.&lt;/p&gt;

&lt;p&gt;Many implementation details are inaccessible to Go programs. There is no way to discover the memory layout of an aggregate type like a struct, or the machine code for a function, or the identity of the operating system thread on which the current goroutine is running. Indeed, the Go scheduler freely moves goroutines from one thread to another. A pointer identifies a variable without revealing the variable’s numeric address. Addresses may change as the garbage collector moves variables; pointers are transparently updated.&lt;/p&gt;

&lt;p&gt;Together, these features make Go programs, especially failing ones, more predictable and less mysterious than programs in C, the quintessential low-level language. By hiding the underlying details, they also make Go programs highly portable, since the language semantics are largely independent of any particular compiler, operating system, or CPU architecture. (Not entirely independent: some details leak through, such as the word size of the processor, the order of evaluation of certain expressions, and the set of implementation restrictions imposed by the compiler.)&lt;/p&gt;

&lt;p&gt;Occasionally, we may choose to forfeit some of these helpful guarantees to achieve the highest possible performance, to interoperate with libraries written in other languages, or to implement a function that cannot be expressed in pure Go.
In this chapter, we’ll see how the unsafe package lets us step outside the usual rules, and how to use the cgo tool to create Go bindings for C libraries and operating system calls.&lt;/p&gt;

&lt;p&gt;The approaches described in this chapter should not be used frivolously. Without careful attention to detail, they may cause the kinds of unpredictable, inscrutable, non-local failures with which C programmers are unhappily acquainted. Use of unsafe also voids Go’s warranty of compatibility with future releases, since, whether intended or inadvertent, it is easy to depend on unspecified implementation details that may change unexpectedly.&lt;/p&gt;

&lt;p&gt;The unsafe package is rather magical. Although it appears to be a regular package and is imported in the usual way, it is actually implemented by the compiler. It provides access to a number of built-in language features that are not ordinarily available because they expose details of Go’s memory layout. Presenting these features as a separate package makes the rare occasions on which they are needed more conspicuous. Also, some environments may restrict the use of the unsafe package for security reasons.
Package unsafe is used extensively within low-level packages like runtime, os, syscall, and net that interact with the operating system, but is almost never needed by ordinary programs.&lt;/p&gt;

&lt;h2 id=&#34;unsafe-sizeof-alignof-and-offsetof:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;unsafe.Sizeof, Alignof, and Offsetof&lt;/h2&gt;

&lt;p&gt;The unsafe.Sizeof function reports the size in bytes of the representation of its operand, which may be an expression of any type; the expression is not evaluated. A call to Sizeof is a constant expression of type uintptr, so the result may be used as the dimension of an array type, or to compute other constants.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;unsafe&amp;quot; 
fmt.Println(unsafe.Sizeof(float64(0))) // &amp;quot;8&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sizeof reports only the size of the fixed part of each data structure, like the pointer and length of a string, but not indirect parts like the contents of the string. Typical sizes for all non-aggregate Go types are shown below, though the exact sizes may vary by toolchain. For portability, we’ve given the sizes of reference types (or types containing references) in terms of words, where a word is 4 bytes on a 32-bit platform and 8 bytes on a 64-bit platform.&lt;/p&gt;

&lt;p&gt;Computers load and store values from memory most efficiently when those values are properly aligned. For example, the address of a value of a two-byte type such as int16 should be an even number, the address of a four-byte value such as a rune should be a multiple of four, and the address of an eight-byte value such as a float64, uint64, or 64-bit pointer should be a multiple of eight. Alignment requirements of higher multiples are unusual, even for larger data types such as complex128.&lt;/p&gt;

&lt;p&gt;For this reason, the size of a value of an aggregate type (a struct or array) is at least the sum of the sizes of its fields or elements but may be greater due to the presence of “holes.” Holes are unused spaces added by the compiler to ensure that the following field or element is properly aligned relative to the start of the struct or array.
Type Size
bool 1 byte
intN, uintN, floatN, complexNN / 8 bytes (for example, float64 is
int, uint, uintptr 1 word
*T 1 word
string 2 words (data, len)
[]T 3 words (data, len, cap)
map 1 word
func 1 word
chan 1 word
interface 2 words (type, value)&lt;/p&gt;

&lt;p&gt;The language specification does not guarantee that the order in which fields are declared is the order in which they are laid out in memory, so in theory a compiler is free to rearrange them, although as we write this, none do. If the types of a struct’s fields are of different sizes, it may be more space-efficient to declare the fields in an order that packs them as tightly as possible. The three structs below have the same fields, but the first requires up to 50% more memory than the other two:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 64-bit 32-bit struct{ bool; float64; int16 } // 3 words 4 words struct{ float64; int16; bool } // 2 words 3 words struct{ bool; int16; float64 } // 2 words 3 words 

The details of the alignment algorithm are beyond the scope of this book, and it’s certainly not worth worrying about every struct, but efficient packing may make frequently allocated data structures more compact and therefore faster. 

The unsafe.Alignof function reports the required alignment of its argument’s type. Like Sizeof, it may be applied to an expression of any type, and it yields a constant. Typically, boolean and numeric types are aligned to their size (up to a maximum of 8 bytes) and all other types are word-aligned. 

The unsafe.Offsetof function, whose operand must be a field selector x.f, computes the offset of field f relative to the start of its enclosing struct x, accounting for holes, if any. 

Figure 13.1 shows a struct variable x and its memory layout on typical 32-and 64-bit Go implementations. The gray regions are holes. 
var     x struct {
a bool 
b int16 
c []int 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The table below shows the results of applying the three unsafe functions to x itself and to each of its three fields:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Typical 32-bit platform: 
Sizeof(x) = 16 Alignof(x) = 4 
Sizeof(x.a) = 1 Alignof(x.a) = 1 Offsetof(x.a) = 0 
Sizeof(x.b) = 2 Alignof(x.b) = 2 Offsetof(x.b) = 2 
Sizeof(x.c) = 12 Alignof(x.c) = 4 Offsetof(x.c) = 4 

Typical 64-bit platform: 
Sizeof(x) = 32 Alignof(x) = 8 
Sizeof(x.a) = 1 Alignof(x.a) = 1 Offsetof(x.a) = 0 
Sizeof(x.b) = 2 Alignof(x.b) = 2 Offsetof(x.b) = 2 
Sizeof(x.c) = 24 Alignof(x.c) = 8 Offsetof(x.c) = 8 

Despite their names, these functions are not in fact unsafe, and they may be helpful for understanding the layout of raw memory in a program when optimizing for space. 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;unsafe-pointer:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;unsafe.Pointer&lt;/h2&gt;

&lt;p&gt;Most pointer types are written *T, meaning “a pointer to a variable of type T.” The unsafe.Pointer type is a special kind of pointer that can hold the address of any variable. Of course, we can’t indirect through an unsafe.Pointer using *p because we don’t know what type that expression should have. Like ordinary pointers, unsafe.Pointers are comparable and may be compared with nil, which is the zero value of the type.
An ordinary *T pointer may be converted to an unsafe.Pointer, and an unsafe.Pointer may be converted back to an ordinary pointer, not necessarily of the same type *T. By converting a *float64 pointer to a *uint64, for instance, we can inspect the bit pattern of a floating-point variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package math 
func Float64bits(f float64) uint64 { return *(*uint64) 
(unsafe.Pointer(&amp;amp;f)) } 
fmt.Printf(&amp;quot;%#016x\n&amp;quot;, Float64bits(1.0)) // 
&amp;quot;0x3ff0000000000000&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Through the resulting pointer, we can update the bit pattern too. This is harmless for a floating-point variable since any bit pattern is legal, but in general, unsafe.Pointer conversions let us write arbitrary values to memory and thus subvert the type system.&lt;/p&gt;

&lt;p&gt;An unsafe.Pointer may also be converted to a uintptr that holds the pointer’s numeric value, letting us perform arithmetic on addresses. (Recall from Chapter 3 that a uintptr is an unsigned integer wide enough to represent an address.) This conversion too may be applied in reverse, but again, converting from a uintptr to an unsafe.Pointer may subvert the type system since not all numbers are valid addresses.&lt;/p&gt;

&lt;p&gt;Many unsafe.Pointer values are thus intermediaries for converting ordinary pointers to raw numeric addresses and back again. The example below takes the address of variable x, adds the offset of its b field, converts the resulting address to *int16, and through that pointer updates x.b:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch13/unsafeptr 
var x struct {
a bool 
b int16 
c []int } 
// equivalent to pb := &amp;amp;x.b 
pb := (*int16)(unsafe.Pointer(
uintptr(unsafe.Pointer(&amp;amp;x)) + 
unsafe.Offsetof(x.b)))
*pb = 42 
fmt.Println(x.b) // &amp;quot;42&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the syntax is cumbersome—perhaps no bad thing since these features should be used sparingly—do not be tempted to introduce temporary variables of type uintptr to break the lines. This code is incorrect:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// NOTE: subtly incorrect! 
tmp := uintptr(unsafe.Pointer(&amp;amp;x)) + 
unsafe.Offsetof(x.b)
pb := (*int16)(unsafe.Pointer(tmp)) 
*pb = 42 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason is very subtle. Some garbage collectors move variables around in memory to reduce fragmentation or bookkeeping. Garbage collectors of this kind are known as moving GCs. When a variable is moved, all pointers that hold the address of the old location must be updated to point to the new one.&lt;/p&gt;

&lt;p&gt;From the perspective of the garbage collector, an unsafe.Pointer is a pointer and thus its value must change as the variable moves, but a uintptr is just a number so its value must not change. The incorrect code above hides a pointer from the garbage collector in the non-pointer variable tmp. By the time the second statement executes, the variable x could have moved and the number in tmp would no longer be the address &amp;amp;x.b. The third statement clobbers an arbitrary memory location with the value 42.&lt;/p&gt;

&lt;p&gt;There are myriad pathological variations on this theme. After this statement has executed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;pT := uintptr(unsafe.Pointer(new(T))) // NOTE: wrong! 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;there are no pointers that refer to the variable created by new, so the garbage collector is entitled to recycle its storage when this statement completes, after which pT contains the address where the variable was but is no longer.&lt;/p&gt;

&lt;p&gt;No current Go implementation uses a moving garbage collector (though future implementations might), but this is no reason for complacency: current versions of Go do move some variables around in memory. Recall from Section 5.2 that goroutine stacks grow as needed. When this happens, all variables on the old stack may be relocated to a new, larger stack, so we cannot rely on the numeric value of a variable’s address remaining unchanged throughout its lifetime.&lt;/p&gt;

&lt;p&gt;At the time of writing, there is little clear guidance on what Go programmers may rely upon after an unsafe.Pointer to uintptr conversion (see Go issue 7192), so we strongly recommend that you assume the bare minimum. Treat all uintptr values as if they contain the former address of a variable, and minimize the number of operations between converting an unsafe.Pointer to a uintptr and using that uintptr. In our first example above, the three operations—conversion to a uintptr, addition of the field offset, conversion back—all appeared within a single expression.&lt;/p&gt;

&lt;p&gt;When calling a library function that returns a uintptr, such as those below from the reflect package, the result should be immediately converted to an unsafe.Pointer to ensure that it continues to point to the same variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package reflect 
func (Value) Pointer() uintptr 
func (Value) UnsafeAddr() uintptr 
func (Value) InterfaceData() [2]uintptr // (index 1) 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;example-deep-equivalence:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Example: Deep Equivalence&lt;/h2&gt;

&lt;p&gt;The DeepEqual function from the reflect package reports whether two values are “deeply” equal. DeepEqual compares basic values as if by the built-in == operator; for composite values, it traverses them recursively, comparing corresponding elements. Because it works for any pair of values, even ones that are not comparable with ==, it finds widespread use in tests. The following test uses DeepEqual to compare two []string values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestSplit(t *testing.T) { 
got := strings.Split(&amp;quot;a:b:c&amp;quot;, &amp;quot;:&amp;quot;) 
want := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}; 
if !reflect.DeepEqual(got, want) { /* ... */ } } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although DeepEqual is convenient, its distinctions can seem arbitrary. For example, it doesn’t consider a nil map equal to a non-nil empty map, nor a nil slice equal to a non-nil empty one:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var a, b []string = nil, []string{}
fmt.Println(reflect.DeepEqual(a, b)) // &amp;quot;false&amp;quot; 
var c, d map[string]int = nil, make(map[string]int)
fmt.Println(reflect.DeepEqual(c, d)) // &amp;quot;false&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this section we’ll define a function Equal that compares arbitrary values. Like DeepEqual, it compares slices and maps based on their elements, but unlike DeepEqual, it considers a nil slice (or map) equal to a non-nil empty one. The basic recursion over the arguments can be done with reflection, using a similar approach to the Display program we saw in Section 12.3. As usual, we define an unexported function, equal, for the recursion. Don’t worry about the seen parameter just yet.&lt;/p&gt;

&lt;p&gt;For each pair of values x and y to be compared, equal checks that both (or neither) are valid and checks that they have the same type. The result of the function is defined as a set of switch cases that compare two values of the same type. For reasons of space, we’ve omitted several cases since the pattern should be familiar by now.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch13/equal 
func equal(x, y reflect.Value, seen 
map[comparison]bool) bool {
if !x.IsValid() || !y.IsValid() { 

return x.IsValid() == y.IsValid() }if x.Type() != y.Type() { 
return false 
} 

// ...cycle check omitted (shown later)... 
switch x.Kind() { 
case reflect.Bool: 
return x.Bool() == y.Bool() 

case reflect.String:
return x.String() == y.String() 

// ...numeric cases omitted for brevity... 
case reflect.Chan, reflect.UnsafePointer, 
reflect.Func: 
return x.Pointer() == y.Pointer() 

case reflect.Ptr, reflect.Interface: return equal(x.Elem(), y.Elem(), seen) 
case reflect.Array, reflect.Slice: 
if x.Len() != y.Len() { 

return false }for i := 0; i &amp;lt; x.Len(); i++ {
if !equal(x.Index(i), y.Index(i), seen) { return false 
}
}
return true 

// ...struct and map cases omitted for brevity... 
}
panic(&amp;quot;unreachable&amp;quot;) 

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As usual, we don’t expose the use of reflection in the API, so the exported function Equal must call reflect.ValueOf on its arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Equal reports whether x and y are deeply equal. 
func Equal(x, y interface{}) bool {
seen := make(map[comparison]bool) 
return equal(reflect.ValueOf(x),

reflect.ValueOf(y), seen) 
} 

type comparison struct {
x, y unsafe.Pointer 
t reflect.Type 

} 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To ensure that the algorithm terminates even for cyclic data structures, it must record which pairs of variables it has already compared and avoid comparing them a second time. Equal allocates a set of comparison structs, each holding the address of two variables (represented as unsafe.Pointer values) and the type of the comparison. We need to record the type in addition to the addresses because different variables can have the same address. For example, if x and y are both arrays, x and x[0] have the same address, as do y and y[0], and it is important to distinguish whether we have compared x and y or x[0] and y[0].
Once equal has established that its arguments have the same type, and before it executes the switch, it checks whether it is comparing two variables it has already seen and, if so, terminates the recursion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// cycle check 
if x.CanAddr() &amp;amp;&amp;amp; y.CanAddr() { 
xptr := unsafe.Pointer(x.UnsafeAddr()) 
yptr := unsafe.Pointer(y.UnsafeAddr()) 
if xptr == yptr {

return true // identical references }c := comparison{xptr, yptr, x.Type()} if seen[c] {
return true // already seen 
}
seen[c] = true 

} 

Here’s our Equal function in action: 


```go
fmt.Println(Equal([]int{1, 2, 3}, []int{1, 2, 3})) 
// &amp;quot;true&amp;quot; 
fmt.Println(Equal([]string{&amp;quot;foo&amp;quot;}, []string{&amp;quot;bar&amp;quot;})) 
// &amp;quot;false&amp;quot; 
fmt.Println(Equal([]string(nil), []string{})) 
// &amp;quot;true&amp;quot; 
fmt.Println(Equal(map[string]int(nil),
map[string]int{})) // &amp;quot;true&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It even works on cyclic inputs similar to the one that caused the Display function from Section 12.3 to get stuck in a loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Circular linked lists a -&amp;gt; b -&amp;gt; a and c -&amp;gt; c. 
type link struct {
value string 
tail *link 

}
a, b, c := &amp;amp;link{value: &amp;quot;a&amp;quot;}, &amp;amp;link{value: &amp;quot;b&amp;quot;}, 
&amp;amp;link{value: &amp;quot;c&amp;quot;} 
a.tail, b.tail, c.tail = b, a, c 
fmt.Println(Equal(a, a)) // &amp;quot;true&amp;quot; 

fmt.Println(Equal(b, b)) // &amp;quot;true&amp;quot; 
fmt.Println(Equal(c, c)) // &amp;quot;true&amp;quot; 
fmt.Println(Equal(a, b)) // &amp;quot;false&amp;quot; 
fmt.Println(Equal(a, c)) // &amp;quot;false&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exercise 13.1: Define a deep comparison function that considers numbers (of any type) equal if they differ by less than one part in a billion.&lt;/p&gt;

&lt;p&gt;Exercise 13.2: Write a function that reports whether its argument is a cyclic data structure.&lt;/p&gt;

&lt;h2 id=&#34;calling-c-code-with-cgo:c2bc2461963ade3e4481c4c85a87b85d&#34;&gt;Calling C Code with cgo&lt;/h2&gt;

&lt;p&gt;A Go program might need to use a hardware driver implemented in C, query an embedded database implemented in C++, or use some linear algebra routines implemented in Fortran. C has long been the lingua franca of programming, so many packages intended for widespread use export a C-compatible API, regardless of the language of their implementation.
In this section, we’ll build a simple data compression program that uses cgo, a tool that creates Go bindings for C functions. Such tools are called foreign-function interfaces (FFIs), and cgo is not the only one for Go programs. SWIG (swig.org) is another; it provides more complex features for integrating with C++ classes, but we won’t show it here.&lt;/p&gt;

&lt;p&gt;The compress/&amp;hellip; subtree of the standard library provides compressors and decompressors for popular compression algorithms, including LZW (used by the Unix compress command) and DEFLATE (used by the GNU gzip command). The APIs of these packages vary slightly in details, but they all provide a wrapper for an io.Writer that compresses the data written to it, and a wrapper for an io.Reader that decompresses the data read from it. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package gzip // compress/gzip 
func NewWriter(w io.Writer) io.WriteCloser 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;func NewReader(r io.Reader) (io.ReadCloser, error)&lt;/p&gt;

&lt;p&gt;The bzip2 algorithm, which is based on the elegant Burrows-Wheeler transform, runs slower than gzip but yields significantly better compression. The compress/bzip2 package provides a decompressor for bzip2, but at the moment the package provides no compressor. Building one from scratch is a substantial undertaking, but there is a well-documented and high-performance open-source C implementation, the libbzip2 package from bzip.org.&lt;/p&gt;

&lt;p&gt;If the C library were small, we would just port it to pure Go, and if its performance were not critical for our purposes, we would be better off invoking a C program as a helper subprocess using the os/exec package. It’s when you need to use a complex, performance-critical library with a narrow C API that it may make sense to wrap it using cgo. For the rest of this chapter, we’ll work through an example.
From the libbzip2 C package, we need the bz_stream struct type, which holds the input and output buffers, and three C functions: BZ2_bzCompressInit, which allocates the stream’s buffers; BZ2_bzCompress, which compresses data from the input buffer to the output buffer; and BZ2_bzCompressEnd, which releases the buffers. (Don’t worry about the mechanics of the libbzip2 package; the purpose of this example is to show how the parts fit together.)&lt;/p&gt;

&lt;p&gt;We’ll call the BZ2_bzCompressInit and BZ2_bzCompressEnd C functions directly from Go, but for BZ2_bzCompress, we’ll define a wrapper function in C, to show how it’s done. The C source file below lives alongside the Go code in our package:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch13/bzip 
/* This file is // gopl.io/ch13/bzip/bzip2.c, */ 
/* a simple wrapper for libbzip2 suitable for cgo. */ 
#include &amp;lt;bzlib.h&amp;gt; 
int bz2compress(bz_stream *s, int action, 
char *in, unsigned *inlen, char *out, unsigned *outlen) {
s-&amp;gt;next_in = in; 
s-&amp;gt;avail_in = *inlen; 
s-&amp;gt;next_out = out; 
s-&amp;gt;avail_out = *outlen; 
int r = BZ2_bzCompress(s, action); 
*inlen -= s-&amp;gt;avail_in; 
*outlen -= s-&amp;gt;avail_out; 
return r; } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let’s turn to the Go code, the first part of which is shown below. The import &amp;ldquo;C&amp;rdquo; declaration is special. There is no package C, but this import causes go build to preprocess the file using the cgo tool before the Go compiler sees it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Package bzip provides a writer that uses bzip2 
compression (bzip.org). 
package bzip 

/*
#cgo CFLAGS: -I/usr/include 
#cgo LDFLAGS: -L/usr/lib -lbz2 
#include &amp;lt;bzlib.h&amp;gt; 
int bz2compress(bz_stream *s, int action, 

char *in, unsigned *inlen, char *out, unsigned *outlen); */import &amp;quot;C&amp;quot; 
import (
&amp;quot;io&amp;quot; 
&amp;quot;unsafe&amp;quot; 

) 
type writer struct {
w io.Writer // underlying output stream 
stream *C.bz_stream 
outbuf [64 * 1024]byte 

} 
// NewWriter returns a writer for bzip2-compressed 
streams. 
func NewWriter(out io.Writer) io.WriteCloser {

const (
blockSize = 9 
verbosity = 0 
workFactor = 30 

)
w := &amp;amp;writer{w: out, stream: new(C.bz_stream)}
C.BZ2_bzCompressInit(w.stream, blockSize, 

verbosity, workFactor) 
return w 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;During preprocessing, cgo generates a temporary package that contains Go declarations corresponding to all the C functions and types used by the file, such as C.bz_stream and C.BZ2_bzCompressInit. The cgo tool discovers these types by invoking the C compiler in a special way on the contents of the comment that precedes the import declaration.&lt;/p&gt;

&lt;p&gt;The comment may also contain #cgo directives that specify extra options to the C toolchain. The CFLAGS and LDFLAGS values contribute extra arguments to the compiler and linker commands so that they can locate the bzlib.h header file and the libbz2.a archive library. The example assumes that these are installed beneath /usr on your system. You may need to alter or delete these flags for your installation.
NewWriter makes a call to the C function BZ2_bzCompressInit to initialize the buffers for the stream. The writer type includes another buffer that will be used to drain the decompressor’s output buffer.&lt;/p&gt;

&lt;p&gt;The Write method, shown below, feeds the uncompressed data to the compressor, calling the function bz2compress in a loop until all the data has been consumed. Observe that the Go program may access C types like bz_stream, char, and uint, C functions like bz2compress, and even object-like C preprocessor macros such as BZ_RUN, all through the C.x notation. The C.uint type is distinct from Go’s uint type, even if both have the same width.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (w *writer) Write(data []byte) (int, error) { 
if w.stream == nil {
panic(&amp;quot;closed&amp;quot;) }
var total int // uncompressed bytes written 
for len(data) &amp;gt; 0 {
inlen, outlen := C.uint(len(data)), 
C.uint(cap(w.outbuf))
C.bz2compress(w.stream, C.BZ_RUN,
(*C.char)(unsafe.Pointer(&amp;amp;data[0])), 
&amp;amp;inlen, (*C.char)(unsafe.Pointer(&amp;amp;w.outbuf)), 
&amp;amp;outlen)total += int(inlen) 
data = data[inlen:] if _, err := w.w.Write(w.outbuf[:outlen]); err != nil { return total, err }}
return total, nil } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each iteration of the loop passes bz2compress the address and length of the remaining portion of data, and the address and capacity of w.outbuf. The two length variables are passed by their addresses, not their values, so that the C function can update them to indicate how much uncompressed data was consumed and how much compressed data was produced. Each chunk of compressed data is then written to the underlying io.Writer.&lt;/p&gt;

&lt;p&gt;The Close method has a similar structure to Write, using a loop to flush out any remaining compressed data from the stream’s output buffer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Close flushes the compressed data and closes the 
stream. 
// It does not close the underlying io.Writer. 
func (w *writer) Close() error {
if w.stream == nil {
panic(&amp;quot;closed&amp;quot;) }
defer func() {
C.BZ2_bzCompressEnd(w.stream)
w.stream = nil 
}()
for {inlen, outlen := C.uint(0), 
C.uint(cap(w.outbuf))
r := C.bz2compress(w.stream, C.BZ_FINISH, nil, &amp;amp;inlen, (*C.char)(unsafe.Pointer(&amp;amp;w.outbuf)), 
&amp;amp;outlen)if _, err := w.w.Write(w.outbuf[:outlen]); err != nil { 
return err 
}
if r == C.BZ_STREAM_END {

return nil 
}
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Upon completion, Close calls C.BZ2_bzCompressEnd to release the stream buffers, using defer to ensure that this happens on all return paths. At this point the w.stream pointer is no longer safe to dereference. To be defensive, we set it to nil, and add explicit nil checks to each method, so that the program panics if the user mistakenly calls a method after Close. Not only is writer not concurrency-safe, but concurrent calls to Close and Write could cause the program to crash in C code. Fixing this is Exercise 13.3.&lt;/p&gt;

&lt;p&gt;The program below, bzipper, is a bzip2 compressor command that uses our new package. It behaves like the bzip2 command present on many Unix systems.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// gopl.io/ch13/bzipper 
// Bzipper reads input, bzip2-compresses it, and 
writes it out. 
package main 

import (
&amp;quot;io&amp;quot; 
&amp;quot;log&amp;quot;
&amp;quot;os&amp;quot; 

&amp;quot;// gopl.io/ch13/bzip&amp;quot; 
) 

func main() { w := bzip.NewWriter(os.Stdout) if _, err := io.Copy(w, os.Stdin); err != nil {
log.Fatalf(&amp;quot;bzipper: %v\n&amp;quot;, err) 
}
if err := w.Close(); err != nil { 

log.Fatalf(&amp;quot;bzipper: close: %v\n&amp;quot;, err) 
}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the session below, we use bzipper to compress /usr/share/dict/words, the system dictionary, from 938,848 bytes to 335,405 bytes—about a third of its original size—then uncompress it with the system bunzip2 command. The SHA256 hash is the same before and after, giving us confidence that the compressor is working correctly. (If you don’t have sha256sum on your system, use your solution to Exercise 4.2.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go build gopl.io/ch13/bzipper 
$ wc -c &amp;lt; /usr/share/dict/words 
938848 
$ sha256sum &amp;lt; /usr/share/dict/words
126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3 
-
$ ./bzipper &amp;lt; /usr/share/dict/words | wc -c 
335405 
$ ./bzipper &amp;lt; /usr/share/dict/words | bunzip2 |
sha256sum 
126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3 
-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We’ve demonstrated linking a C library into a Go program. Going in the other direction, it’s also possible to compile a Go program as a static archive that can be linked into a C program or as a shared library that can be dynamically loaded by a C program. We’ve only scratched the surface of cgo here, and there is much more to say about memory management, pointers, callbacks, signal handling, strings, errno, finalizers, and the relationship between goroutines and operating system threads, much of it very subtle. In particular, the rules for correctly passing pointers from Go to C or vice versa are complex, for reasons similar to those we discussed in Section 13.2, and not yet authoritatively specified. For further reading, start with &lt;a href=&#34;https://golang.org/cmd/cgo&#34;&gt;https://golang.org/cmd/cgo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Exercise 13.3: Use sync.Mutex to make bzip2.writer safe for concurrent use by multiple goroutines.&lt;/p&gt;

&lt;p&gt;Exercise 13.4: Depending on C libraries has its drawbacks. Provide an alternative pure-Go implementation of bzip.NewWriter that uses the os/exec package to run /bin/bzip2 as a subprocess.&lt;/p&gt;

&lt;p&gt;##Another Word of Caution&lt;/p&gt;

&lt;p&gt;We ended the previous chapter with a warning about the downsides of the reflection interface. That warning applies with even more force to the unsafe package described in this chapter.&lt;/p&gt;

&lt;p&gt;High-level languages insulate programs and programmers not only from the arcane specifics of individual computer instruction sets, but from dependence on irrelevancies like where in memory a variable lives, how big a data type is, the details of structure layout, and a host of other implementation details. Because of that insulating layer, it’s possible to write programs that are safe and robust and that will run on any operating system without change.&lt;/p&gt;

&lt;p&gt;The unsafe package lets programmers reach through the insulation to use some crucial but otherwise inaccessible feature, or perhaps to achieve higher performance. The cost is usually to portability and safety, so one uses unsafe at one’s peril. Our advice on how and when to use unsafe parallels Knuth’s comments on premature optimization, which we quoted in Section 11.5. Most programmers will never need to use unsafe at all. Nevertheless, there will occasionally be situations where some critical piece of code can be best written using unsafe. If careful study and measurement indicates that unsafe really is the best approach, restrict it to as small a region as possible, so that most of the program is oblivious to its use.&lt;/p&gt;

&lt;p&gt;For now, put the last two chapters in the back of your mind. Write some substantial Go programs. Avoid reflect and unsafe; come back to these chapters only if you must.&lt;/p&gt;

&lt;p&gt;Meanwhile, happy Go programming. We hope you enjoy writing Go as much as we do.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang Notes, Part 1</title>
      <link>https://harryho.github.io/cache/golang/golang-notes/</link>
      <pubDate>Sun, 10 Apr 2016 14:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/cache/golang/golang-notes/</guid>
      <description>

&lt;h2 id=&#34;hello-world:e7e4aa31650f23d2dfe6f4eb4cee2373&#34;&gt;Hello World&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Please find it from &lt;a href=&#34;https://harryho.github.io/#Go&#34;&gt;Home Page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;data-type:e7e4aa31650f23d2dfe6f4eb4cee2373&#34;&gt;Data Type&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>LCTHW</title>
      <link>https://harryho.github.io/cache/c/lcthw/</link>
      <pubDate>Sun, 10 Apr 2016 14:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/cache/c/lcthw/</guid>
      <description>

&lt;p&gt;Acknowledgment&lt;/p&gt;

&lt;p&gt;I would like to thank three kinds of people who helped make this boo kwhat itis today: the haters, the helpers, and the painters.&lt;/p&gt;

&lt;p&gt;The haters helped make this book stronger and more solid through their inflexibility of mind, irrational hero worship of old C gods, and complete lack of pedagogical expertise. Without their shining example of what not to be,I wouldhave never worked so hard to make this book a completeintroduction to becoming a better programmer.&lt;/p&gt;

&lt;p&gt;The helpers are Debra Williams Cauley, Vicki Rowland, Elizabeth Ryan,the whole teamatAddison-Wesley, and everyoneonline who sent in fixes and suggestions. Their work producing,fixing, editing, and improving this bookhas formed it into a more professionaland better piece of writing.&lt;/p&gt;

&lt;p&gt;The painters, Brian, Arthur, Vesta, and Sarah,helped me finda new way to express myself and to distract mefrom deadlines that Deb and Vicki clearly set for mebut that I keptmissing. Without painting andthe gift ofart these artists gaveme,I would have a less meaningful and rich life.
Thankyou to all ofyoufor helping me write this book. It maynotbeperfect,because no bookisperfect, butit&amp;rsquo;s at least asgood asIcan possibly makeit.&lt;/p&gt;

&lt;p&gt;This Book Is Not Really about C&lt;/p&gt;

&lt;p&gt;Please don&amp;rsquo;t feel cheated, but this book is not about teaching you C programming. You&amp;rsquo;ll learnto write programs in C, but the most important lesson you&amp;rsquo;ll get fromthis bookis rigorous defensive programming.&lt;/p&gt;

&lt;p&gt;Today, too many programmerssimply assume thatwhat they write works, butone dayit will fail catastrophically. This is especially true ifyou&amp;rsquo;re the kind ofperson who has learned mostly modern languages that solvemany problems for you. By reading this bookand following my exercises, you&amp;rsquo;ll learn how to createsoftware that defends itself from malicious activity and defects.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m using C for a very specific reason: C is broken. Itis fullof design choices thatmade sense in the 1970s butmakezero sense now. Everything from its unrestricted, wild use of pointersto its severely broken NUL terminatedstrings are to blame for nearly allof the security defects that hit C.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s my belief that C is so broken that, while it&amp;rsquo;s in wide use, it&amp;rsquo;sthe most difficult languageto write securely. I wouldfathomthat Assembly is actually easierto write securely than C. To be honest, and you&amp;rsquo;ll find out thatI&amp;rsquo;m very honest,I don&amp;rsquo;t think that anybody should be writing new C code.&lt;/p&gt;

&lt;p&gt;If that&amp;rsquo;sthe case, then why am Iteaching you C? Because I want you to become a better,stronger programmer, and there are tworeasonswhy C is an excellent language to learn if you want to get better. First, C&amp;rsquo;s lackof nearly every modern safety feature means you have tobe more vigilant and moreaware of what&amp;rsquo;s going on. If you can write secure, solid C code, you can write secure, solid codein any programminglanguage. The techniquesyou learn will translate toeverylanguage you use fromnow on.&lt;/p&gt;

&lt;p&gt;Second, learning C gives you direct accessto amountain of legacycode, and teachesyou the base syntax of alarge number ofdescendant languages. Once youlearn C, you can more easilylearn C++, Java, Objective-C, and JavaScript, and evenother languages becomeeasier to learn.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t want to scare you away by telling you this, because Iplan to makethis book incredibly fun,easy, and devious. I&amp;rsquo;ll makeit fun to learn C bygiving you projects that you mightnot havedone In other programming languages. I&amp;rsquo;ll makethis bookeasyby using myprovenpattern of exercisesthat has you doing C programming andbuilding your skills slowly.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll make it devious by teaching you how to break and thensecure your codeso you understandwhy these issues matter. You&amp;rsquo;ll learn how to cause stack overflows, illegal memory access, ando ther common flawsthat plague C programs so thatyou knowwhat you&amp;rsquo;re up against.&lt;/p&gt;

&lt;p&gt;Getting through this book will be challenging, likeall of mybooks, but when you&amp;rsquo;re done you willbea far better and moreconfident programmer.&lt;/p&gt;

&lt;p&gt;The Undefined Behaviorists&lt;/p&gt;

&lt;p&gt;By the timeyou&amp;rsquo;re done with this book, you&amp;rsquo;ll beable to debug, read, andfixalmost any C program youruninto, and then write new,solid C codeshould youneed to. However, I&amp;rsquo;m notreally going to teach you official C. You&amp;rsquo;ll learn the language, and you&amp;rsquo;ll learn how touseit well, but official C isn&amp;rsquo;t very secure.&lt;/p&gt;

&lt;p&gt;The vast majorityof C programmers out there simplydon&amp;rsquo;t write solid code, and it&amp;rsquo;s becauseof something called Undefined Behavior (UB). UB is apartof the American NationalStandards Institute (ANSI)C standard that lists all of the ways that a C compiler can disregard what you&amp;rsquo;vewritten.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s actually a part of the standard thatsays if you write code like this,thenallbets are off and the compiler doesn&amp;rsquo;thave to do anything consistently. UB occurs when a Cprogram reads offthe end of astring, which is an incredibly common programming error in C.&lt;/p&gt;

&lt;p&gt;For a bitof background, C defines strings as blocks of memory that end inaNUL byte, or a0 byte(to simplify the definition). Since many strings come from outside the program, it&amp;rsquo;s common for a C programto receive astring without thisNULbyte. When it does, the Cprogram attempts to read past the end ofthis string and into the memory of the computer, causing your program to crash. Every other language developed after Cattempts to prevent this, butnot C.&lt;/p&gt;

&lt;p&gt;C does so little toprevent UB thateveryCprogrammer seems to think it meansthey don&amp;rsquo;thave to deal with it. They write code full of potential NUL byte overruns, and when you point themout to theseprogrammers, they say, &amp;ldquo;Well that&amp;rsquo;s UB, andI don&amp;rsquo;thave to prevent it.&amp;rdquo; This reliance onC&amp;rsquo;s largenumber ofUBsiswhy most C codeis so horriblyinsecure.&lt;/p&gt;

&lt;p&gt;I write C codeto try to avoid UB byeither writing code thatdoesn&amp;rsquo;t trigger it, or writing codethat attemptsto preventit. Thisturnsoutto be an impossible task because there is so much UB that it becomes aGordian knot of interconnected pitfallsin your C code. As you go through this book, I&amp;rsquo;llpoint out ways you can trigger UB, how to avoid it if you can, and how to trigger itin other people&amp;rsquo;s codeif possible. However, you should keepin mindthat avoiding thenearly random nature of UB is almost impossible, and you&amp;rsquo;ll just have to do yourbest.&lt;/p&gt;

&lt;p&gt;Warning!&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll find that hardcore C fans frequently will try to beat you up about UB. There&amp;rsquo;s aclass of C programmers who don&amp;rsquo;t write very much C code but have memorized all of the UB just so they could beat up a beginner intellectually. If you run into one of these abusive programmers, please ignore them.&lt;/p&gt;

&lt;p&gt;Often, they aren&amp;rsquo;t practicing C programmers, they are arrogant, abusive, and will only endup asking you endlessquestions in anattempt to prove their superiority rather than helping you with yourcode.&lt;/p&gt;

&lt;p&gt;Should you ever need help with your C code,simply email me at help@learncodethehardway and I willgladly help you.&lt;/p&gt;

&lt;p&gt;C Is a Pretty and Ugly Language&lt;/p&gt;

&lt;p&gt;The presence of UB though is one more reason why learning C is a good move if you want to be a better programmer. If you can write good, solid C code in the way I teach you, then you can survive any language. On the positive side, C is a really elegant language in many ways. Its syntax is actually incrediblysmall given the power it has. There&amp;rsquo;s a reason why so many other languages have copied its syntax over the last 45 or so years.&lt;/p&gt;

&lt;p&gt;C also gives you quite a lot using very little technology. When you&amp;rsquo;re donelearningC, you&amp;rsquo;ll have anappreciation for asomething thatisvery elegant andbeautifulbutalso alittleugly at the same time.&lt;/p&gt;

&lt;p&gt;C is old, so likea beautiful monument,it willlook fantastic from about 20feet away, but when youstep up close, you&amp;rsquo;ll seeallthe cracks and flaws it has. Because ofthis, I&amp;rsquo;m going to teach you themostrecent versionof C thatI can make work with recent compilers. It&amp;rsquo;s apractical, straightforward, simple, yet completesubset of C that works well,works everywhere, andavoidsmany pitfalls.&lt;/p&gt;

&lt;p&gt;This is the C that I use to getreal workdone, and not the encyclopedic version of C that hardcore fans try and fail touse. I know the C that I useis solid because Ispent two decades writing clean,solid C  codethat powered large operations without much failureatall.&lt;/p&gt;

&lt;p&gt;My C code has probably processed trillions of transactions because it powered the operations of companies like Twitter and airbnb. It rarely failed or had security attacks against it. In the many years that my code powered the Ruby on Rails Web world, it&amp;rsquo;s run beautifully and even prevented security attacks, while other Web servers fell repeatedly to the simplest of attacks.&lt;/p&gt;

&lt;p&gt;My style of writingC code is solid, but moreimportantly, m ymind-set when writing C is one every programmer should have. I approach C, and any programming, with the ideaof preventing errors asbest I can andassuming thatnothing willwork right. Other programmers,even supposedly good C programmers, tend to write codeand assumeeverything will work, but rely on UB or the operating systemto save them,neither of which will work as asolution.&lt;/p&gt;

&lt;p&gt;Just remember that ifpeopletry to tellyou that the code I teach in this book isn&amp;rsquo;t &amp;ldquo;real C.&amp;rdquo; If theydon&amp;rsquo;t have the same track record as me, maybe you can use whatI teach you to show them why their code isn&amp;rsquo;t very secure.
Does that meanmycode is perfect? No,not at all. This is C code. Writing perfect C codeis impossible, andin fact, writing perfectcode in any language is impossible.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s half the funand frustration of programming. I could takesomeone else&amp;rsquo;s codeand tearitapart, and someone couldtake mycode and tear it apart. All code is flawed, but the difference is thatItry to assumemy code is always flawedand then prevent the flaws. My gift to you,should you completethis book, is to teachyou the
defensive programming mind-set that hasservedme wellfortwo decades, and has helped memake high-quality, robustsoftware.&lt;/p&gt;

&lt;p&gt;What You Will Learn&lt;/p&gt;

&lt;p&gt;The purpose of this book is to get you strongenough in C thatyou&amp;rsquo;llbeable to write your own software with it or modify someoneelse&amp;rsquo;s C code. Afterthis book, you should read Brian Kernighan and DennisRitchie&amp;rsquo;s The C Programming Language, SecondEdition (Prentice Hall, 1988), a bookby the creators of the C language, also called K&amp;amp;R C. WhatI&amp;rsquo;ll teach you is&lt;/p&gt;

&lt;p&gt;• The basics of Csyntax and idioms&lt;/p&gt;

&lt;p&gt;• Compilation, make files, linkers&lt;/p&gt;

&lt;p&gt;• Findingbugs and preventing them&lt;/p&gt;

&lt;p&gt;• Defensive coding practices&lt;/p&gt;

&lt;p&gt;• Breaking C code&lt;/p&gt;

&lt;p&gt;• Writing basic UNIX systemssoftware&lt;/p&gt;

&lt;p&gt;By the final exercise, you will havemorethanenough ammunition totackle basic systemssoftware, libraries, and othersmaller projects.&lt;/p&gt;

&lt;p&gt;How to Read This Book&lt;/p&gt;

&lt;p&gt;This book is intended for programmers who have learned at least one other programming language. I refer you to my book Learn Python the Hard Way (Addison-Wesley, 2013) if you haven&amp;rsquo;tlearned a programming language yet. It&amp;rsquo;s meant for beginners and works very well as a first book onprogramming. Once you&amp;rsquo;vecompleted Learn Python the Hard Way,then you can comeback andstart this book.&lt;/p&gt;

&lt;p&gt;For those who&amp;rsquo;ve already learned tocode, this book mayseem strange at first. It&amp;rsquo;s notlike otherbookswhere you read paragraph after paragraph of prose and then typein abitof codehere and there. Instead, there are videos oflecturesfor each exercise, you code right away, andthen Iexplain what you just did. This works better becauseit&amp;rsquo;s easierfor me toexplain something you&amp;rsquo;ve already done thanto speak inan abstract sense about something you aren&amp;rsquo;t familiar with at all.&lt;/p&gt;

&lt;p&gt;Because ofthis structure, there are a few rules that you must followin this book:&lt;/p&gt;

&lt;p&gt;• Watch the lecturevideo first,unless the exercise says otherwise.&lt;/p&gt;

&lt;p&gt;• Type in all of the code. Don&amp;rsquo;tcopy-paste!&lt;/p&gt;

&lt;p&gt;• Type in the code exactly asitappears, even the comments.&lt;/p&gt;

&lt;p&gt;• Getit to run andmake sure itprints the same output.&lt;/p&gt;

&lt;p&gt;• If there are bugs,fix them.&lt;/p&gt;

&lt;p&gt;• Dothe Extra Credit, but it&amp;rsquo;sallright toskip anything you can&amp;rsquo;t figure out.&lt;/p&gt;

&lt;p&gt;• Always try tofigure it outfirstbefore trying to get help.&lt;/p&gt;

&lt;p&gt;If youfollowtheserules, do everythingin the book, and stillcan&amp;rsquo;tcode C,then you at least tried. It&amp;rsquo;snotfor everyone, but just trying will make you a better programmer.&lt;/p&gt;

&lt;p&gt;The Videos&lt;/p&gt;

&lt;p&gt;Included in this course are videos for every exercise, and in many cases,more thanone video for an exercise. These videos should beconsidered essentialto get the full impact of the book&amp;rsquo;seducational method. The reason for this is that many of theproblems with writing C codeare interactive issues with failure, debugging, and commands.&lt;/p&gt;

&lt;p&gt;C requires much more interaction toget the code running and to fix problems, unlike languages likePython and Rubywherecode just runs. It&amp;rsquo;s alsomuch easier to show you a videolectureon a topic,such aspointers or memory management, where I can demonstratehowthe machine is actually working.&lt;/p&gt;

&lt;p&gt;I recommend thatas you go through the course, you plan to watch thevideosfirst, and thendo the exercises unless directedto do otherwise. In some of the exercises, I use onevideoto present a problem andthenanother to demonstratethe solution. In most of the other exercises, I use avideo to present a lecture, and then you do the exerciseand complete it to learn the topic.&lt;/p&gt;

&lt;p&gt;The Core Competencies&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to guessthat you haveexperience using a lesser language. One of those usable languages that lets you get away with sloppy thinking and half-baked hackery like Python or Ruby. Or, maybe you use a languagelike LISPthat pretendsthe computer is somepurely functional fantasy land with padded walls forlittlebabies. Maybe you&amp;rsquo;velearned Prolog, and you think the entireworld should just be adatabase where you walkaround in it looking for clues.&lt;/p&gt;

&lt;p&gt;Even worse,I&amp;rsquo;m betting you&amp;rsquo;ve been using anintegrated development environment (IDE), so your brainis riddled with memory holes, and you can&amp;rsquo;t eventypean entire function&amp;rsquo;s name without hitting CTRL­SPACE after every three characters.
No matter what your background is,you could probably use some improvementin these areas:&lt;/p&gt;

&lt;p&gt;Reading and Writing&lt;/p&gt;

&lt;p&gt;This is especially true if you use an IDE, but generally I find programmers do too much skimmingand have problems reading for comprehension. They&amp;rsquo;ll just skim code that theyneed to understand indetailwithout taking the time to understand it. Other languagesprovide tools that let programmers avoid actually writingany code, so when facedwith a languagelike C,they break down.&lt;/p&gt;

&lt;p&gt;The simplest thing to do is just understand that everyone has this problem, and you can fix it by forcing yourself to slow down and be meticulous about your readingand writing. At first, it&amp;rsquo;ll feel painful and annoying, but take frequent breaks, and then eventually it&amp;rsquo;ll be easierto do.&lt;/p&gt;

&lt;p&gt;Attention to Detail&lt;/p&gt;

&lt;p&gt;Everyoneis bad at this, and it&amp;rsquo;sthe biggest cause of bad software. Otherlanguages let you get awaywithnotpaying attention, but C demandsyour full attention becauseit&amp;rsquo;s rightin the machine, and the machine is very picky. With C,there is no &amp;ldquo;kind of similar&amp;rdquo; or &amp;ldquo;close enough,&amp;rdquo; so you need topay attention. Doublecheck your work. Assume everything you write is wronguntil you prove it&amp;rsquo;s right.
Spotting Differences&lt;/p&gt;

&lt;p&gt;A keyproblem thatpeople who are used to other languages have isthat their brains havebeen trainedto spotdifferences in that language, not in C. When you comparecode you&amp;rsquo;ve written to my exercise code, your eyes will jump rightover characters you thinkdon&amp;rsquo;t matter or thataren&amp;rsquo;t familiar. I&amp;rsquo;ll be giving you strategies thatforceyou to see your mistakes, butkeep in mind thatif your code is not exactly like the code in this book, it&amp;rsquo;swrong.&lt;/p&gt;

&lt;p&gt;Planning and Debugging&lt;/p&gt;

&lt;p&gt;I love other, easier languages because I can just hang out. I can type the ideas I have into their interpreter and see results immediately. They&amp;rsquo;re great for just hacking out ideas, buthave you noticed thatif you keep doing hack until it works, eventually nothing works?C is harderon you because itrequires you to first plan outwhat you want to create. Sure, you canhack for abit, but youhave toget serious much earlier in C than in other languages.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll be teaching you ways to plan out key parts of your program before you start coding, and this will likelymake you a better programmer at the same time. Even just a little planning can smooth things outdown the road. ^cise0, is where you set up your computer for therest ofthis book. In this exercise you&amp;rsquo;ll install packagesand softwaredepending on the typeof computeryouhave.&lt;/p&gt;

&lt;p&gt;If youhave problems following this exercise, then simplywatch the Exercise
0
video for yourcomputer and follow along with my setup instructions. Thatvideo should demonstrate how to do each step and helpyousolve any problemsthat might come up.
Linux
Linux ismostlikely the easiest system to configure for C development. For Debian systems yourunthis command from the command line:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ sudo apt-get install build -essential&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how you would install&lt;/p&gt;

&lt;p&gt;the samesetup onan RPM-based Linux like Fedora, RedHat,or CentOS7:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ sudo yum groupinstall development-tools&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If youhave adifferent variant ofLinux, simplysearch for &amp;ldquo;c development tools&amp;rdquo; and your brand of Linux to find out what&amp;rsquo;s required. Once you have that installed, you should beable to type: &lt;code&gt;$ cc --version&lt;/code&gt; to see whatcompiler was installed. You will most likely have the GNU C Compiler (GCC)installed but don&amp;rsquo;tworryif it&amp;rsquo;sa different onefrom what I use in the book. You could also try installing the Clang C compiler using the Clang&amp;rsquo;s Getting Started instructions for yourversion ofLinux, or searching online if those don&amp;rsquo;twork.&lt;/p&gt;

&lt;p&gt;Mac OS X&lt;/p&gt;

&lt;p&gt;On MacOS X, the installis even easier. First,you&amp;rsquo;llneed to either download the latest XCode from Apple,or find your installDVD andinstall it from there. The download will be massive and could take forever, so I recommend installing from the DVD.&lt;/p&gt;

&lt;p&gt;Also, search online for &amp;ldquo;installing xcode&amp;rdquo; for instructionson how to do it. You can also use theApp Storeto install it just as you wouldany other app, and if you do it that wayyou&amp;rsquo;ll receive updates automatically.&lt;/p&gt;

&lt;p&gt;To confirm that your C compiler is working, type this:
&lt;code&gt;$ cc --version&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You should see thatyou are using aversion of the Clang C Compiler, butif your XCode is older you mayhave GCC installed. Either is fine.
Windows&lt;/p&gt;

&lt;p&gt;For Microsoft Windows, I recommend you usethe Cygwin system to acquire many of the standard UNIX software development tools. It should be easy to install and use, but watch the videos for this exercise tosee how I dout C support in their development tools,soyou may have problems using Microsoft&amp;rsquo;s compilers to build the codein this book.  it. An alternative to Cygwin is the MinGW system; it is more minimalist but should also work. I will warn you that Microsoft seems to be phasing.&lt;/p&gt;

&lt;p&gt;A slightly more advanced optionis to use VirtualBoxto install aLinuxdistribution and run a complete Linux systemon yourWindows computer. This has the added advantagethat you can completely destroy this virtualmachine without worrying about destroying your Windows configuration. It&amp;rsquo;s also an opportunity to learn to use Linux, which is both fun andbeneficialto your development as a programmer. Linux is currently deployed as the main operating system for many distributed computer and cloudinfrastructure companies. Learning Linux will definitely improveyour knowledge of the future of computing.&lt;/p&gt;

&lt;p&gt;Text Editor&lt;/p&gt;

&lt;p&gt;The choice of text editor for a programmer is a tough one. For beginners, I say just use Gedit since it&amp;rsquo;s simple andit works for code. However, it doesn&amp;rsquo;t work in certain international situations, and if you&amp;rsquo;ve been programming for a while, chances are you already have a favorite text editor.&lt;/p&gt;

&lt;p&gt;With this in mind, I want you to try out a few of the standard programmer text editors for your platformand then stick with the one that you like best. If you&amp;rsquo;ve been using GEdit and like it, then stick with it. If you want to try something different, then try it out real quick and pick one.&lt;/p&gt;

&lt;p&gt;The mostimportant thing is do not get stuck trying to pick the perfect editor. Text editors alljust kind of suck in odd ways. Just pick one, stick with it, and if youfind something else you like, try it out. Don&amp;rsquo;t spend days onend configuringit and making it perfect.&lt;/p&gt;

&lt;p&gt;Some text editors to try out:&lt;/p&gt;

&lt;p&gt;• GEdit onLinux and OS X.&lt;/p&gt;

&lt;p&gt;• TextWrangler on OS X.&lt;/p&gt;

&lt;p&gt;• Nano, which runs in Terminaland works nearly everywhere.&lt;/p&gt;

&lt;p&gt;• Emacs and Emacs for OSX; be prepared to do somelearning, though.&lt;/p&gt;

&lt;p&gt;• Vim andMacVim.&lt;/p&gt;

&lt;p&gt;There is probablya different editorforeveryperson out there, but theseare just a few of the freeones thatI know work. Try out a few of these —and maybe some commercialones—until you find onethat you like.&lt;/p&gt;

&lt;p&gt;Do Not Use an IDE&lt;/p&gt;

&lt;p&gt;Warning!&lt;/p&gt;

&lt;p&gt;Avoidusing an integrated development environment(IDE) while you are learning a language. They are helpful when you need to get things done, but their help tendsalso to prevent youfrom really learning the language. In my experience,the stronger programmers don&amp;rsquo;tuse an IDE and also have no problem producing codeat the same speed as IDE users. I alsofind that the code produced with an IDEis of lower quality. Ihave noidea why thatis the case, but if you want deep, solid skillsin a programming language, Ihighly recommend thatyou avoid IDEswhile you&amp;rsquo;re learning.&lt;/p&gt;

&lt;p&gt;Knowing how touse a professional programmer&amp;rsquo;s text editor is alsoauseful skill in your professionallife. When you&amp;rsquo;re dependent onan IDE, you have to wait for a new IDE before you can learn the newer programming languages. This addsa costto your career: It preventsyoufrom getting ahead of shifts in language popularity. With a generic text editor, you can code in anylanguage, any time you like, without waiting for anyone to addit to an IDE. A generic text editor meansfreedom to explore on yourown andmanage your career as you see fit.&lt;/p&gt;

&lt;h2 id=&#34;exercise1-dust-off-that-compiler:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise1. Dust Off That Compiler&lt;/h2&gt;

&lt;p&gt;After you haveeverything installed, you needto confirm thatyour compiler works. The easiest way todo that is to writea C program. Since you should alreadyknow at least oneprogramming language, I believeyou can startwith a small but extensive example.&lt;/p&gt;

&lt;p&gt;ex1.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

1 #include &amp;lt;stdio.h&amp;gt; 
2 
3 /* This is a comment. */ 
4 int main(int argc, char *argv[]) 
5 
6  {  int  distance  = 100;7  
8     //  this  is  also  a  comment  
9     printf(&amp;quot;You  are  %d miles  away.\n&amp;quot;, distance); 
11    return 0;
12 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If youhave problems getting the code up and running, watchthe video for this exercise to see me do it first.&lt;/p&gt;

&lt;p&gt;Breaking It Down&lt;/p&gt;

&lt;p&gt;There area few features of the C languagein thiscode thatyou might ormightnot have figured out while you were typing it. I&amp;rsquo;ll break this down, line by line, quickly, and then we can do exercises to understand each partbetter. Don&amp;rsquo;tworryif you don&amp;rsquo;t understand everything in this breakdown. Iam simply giving you a quickdive into C and promise you will learn all of these concepts later in the book.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s aline-by-line description of the code:&lt;/p&gt;

&lt;p&gt;ex1.c:1 An include, and itis the way to import thecontentsof one file into thissource file. C has a convention ofusing .h extensions for header files, which contain listsof functions to usein your program.&lt;/p&gt;

&lt;p&gt;ex1.c:3 This is a multiline comment, and you could put as manylines oftext between the opening &lt;code&gt;/*&lt;/code&gt; and closing &lt;code&gt;*/&lt;/code&gt; characters asyou want.&lt;/p&gt;

&lt;p&gt;ex1.c:4 A morecomplex version of the main function you&amp;rsquo;ve been using so far. How C programs workisthat the operating system loadsyour program, and then itruns the function named main. For the function to be totally complete it needs toreturn an int and take two parameters: an int for the argumentcountand an array of char * strings for the arguments. Didthat just flyoveryour head? Don&amp;rsquo;tworry, we&amp;rsquo;ll cover this soon.&lt;/p&gt;

&lt;p&gt;ex1.c:5 To start the body of any function, you write a &lt;code&gt;{&lt;/code&gt; character that indicates thebeginning ofa block. In Python, you just did a &lt;code&gt;:&lt;/code&gt; and indented. In other languages, you might have a begin or do word tostart.&lt;/p&gt;

&lt;p&gt;ex1.c:6 A variable declaration and assignmentat the same time. This is how you create a variable, with the syntax type name = value;. In C, statements (exceptfor logic) end in a ;(semicolon) character.&lt;/p&gt;

&lt;p&gt;ex1.c:8 Another kind of comment. It works like in Python or Ruby, where the comment starts at the &lt;code&gt;//&lt;/code&gt; and goes untilthe end of the line.&lt;/p&gt;

&lt;p&gt;ex1.c:9 A callto your old friend printf.Likein many languages, function calls workwith the syntax name(arg1, arg2); and canhave no argumentsor any number of them. The printf function is actually kind of weird in that it can take multiple arguments. You&amp;rsquo;ll see that later.&lt;/p&gt;

&lt;p&gt;ex1.c:11 Areturnfrom the main function that gives the operating system (OS)your exitvalue. You maynot be familiar with how UNIX software uses returncodes, sowe&amp;rsquo;ll cover thatas well.&lt;/p&gt;

&lt;p&gt;ex1.c:12 Finally, we end the main functionwith aclosing brace }character, andthat&amp;rsquo;sthe end of the program.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;salot ofinformation in this breakdown, so study it lineby lineand make sure you at least have a grasp of what&amp;rsquo;s going on. Youwon&amp;rsquo;t know everything, butyou can probably guessbefore we continue.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;You can put this into an ex1.c andthen run the commands shown here in this sample shelloutput. If you&amp;rsquo;re notsure how thisworks, watchthe video that goes with this exercise tosee me do it.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 1 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ make ex1 
cc -Wall ­
g ex1.c -o ex1 
$ ./ex1
 You are 100 miles away.
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first command make is a tool thatknows how to build C programs (and many others). When you run it and giveit ex1 you are telling make to look forthe ex1.c file, run thecompiler to build it, and leavethe results in a filenamed ex1. This ex1 file is anexecutable thatyou can run with ./ex1, which outputsyour results.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;In this book, I&amp;rsquo;m going to have a small section for each program teaching you how to break the program if it&amp;rsquo;s possible. I&amp;rsquo;ll have you do odd things to the programs, run them in weird ways,or change code so that you can seecrashes and compiler errors.&lt;/p&gt;

&lt;p&gt;For this program, simplytry removing things at random and still getitto compile. Just make a guessatwhat you can remove, recompileit, and thensee what you get foran error.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Open the ex1 file in your text editorand change or delete random parts. Try running itand see what happens.&lt;/p&gt;

&lt;p&gt;• Print outfivemore lines of textor something more complex than &amp;ldquo;hello world.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;• Run man 3 printf and read about this function andmany others.&lt;/p&gt;

&lt;p&gt;• For each line, write out the symbols you don&amp;rsquo;t understand and see if you can guess what theymean. Write a little chart on paper with your guess so you can check itlater tosee if you gotitright.&lt;/p&gt;

&lt;h2 id=&#34;exercise2-using-makefiles-to-build:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise2. Using Makefiles to Build&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;re going to use aprogram called make to simplify building your exercise code. The make programhas been aroundfor averylongtime, and because ofthis it knows how to buildquitea few typesof software. In this exercise, I&amp;rsquo;llteach you just enough Makefile syntax to continuewith the course, and thenan exerciselater will teach you morecomplete Makefile usage.&lt;/p&gt;

&lt;p&gt;Using Make&lt;/p&gt;

&lt;p&gt;How make works is you declare dependencies, and thendescribe how to build them orrely on the program&amp;rsquo;s internalknowledge ofhow to build most common software. Ithas decades ofknowledge about buildinga wide variety offiles from other files. In the last exercise,you did this already using commands:&lt;/p&gt;

&lt;p&gt;$ make ex1 # or this one too
$ CFLAGS=&amp;ldquo;-Wall&amp;rdquo; make ex1&lt;/p&gt;

&lt;p&gt;In the first command, you&amp;rsquo;re telling make, &amp;ldquo;I want a file named ex1to be created.&amp;rdquo; The programthen asks and does the following:
1. Doesthe file ex1 exist already?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;No. Okay, is there anotherfile that starts with ex1. 3. Yes, it&amp;rsquo;scalled ex1.c. Do I know how to build .c files?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Yes, I run this command cc ex1.c -o ex1 to build them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ishall make youone ex1 by using cc to build itfrom ex1.c.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The secondcommand in the listing above is a way topass modifiers to the make command. If you&amp;rsquo;renot familiar with how the UNIX shellworks, you can create these environment variables thatwillget picked up by programs you run. Sometimes you do this with acommand like export CFLAGS=&amp;ldquo;­Wall&amp;rdquo; depending on the shellyou use. You can, however, alsojust put them beforethe command you want to run, and that environment variable willbe set only while that command runs.&lt;/p&gt;

&lt;p&gt;In this example, I did CFLAGS=&amp;ldquo;-Wall&amp;rdquo; make ex1 so that itwould addthe command line option -Wall to the cc commandthat make normallyruns. That command line optiontells the compiler cc to report all warnings (which, in a sick
twis tof fate,isn&amp;rsquo;tactually all the warnings possible). You can actually getpretty farwithjust using make in thatway, butlet&amp;rsquo;s getinto makinga Makefile soyou can understand make a little better. Tostart off, createa filewithjust the followingin it.&lt;/p&gt;

&lt;p&gt;ex2.1.mak
CFLAGS=-Wall -g
clean:
rm -f ex1&lt;/p&gt;

&lt;p&gt;Save this file as Makefile in your current directory. The programautomatically assumes there&amp;rsquo;sa file called Makefile andwilljust run it.&lt;/p&gt;

&lt;p&gt;Warning!&lt;/p&gt;

&lt;p&gt;Make sure you are only entering TAB characters, not mixtures of TAB and spaces.&lt;/p&gt;

&lt;p&gt;This Makefile is showing you somenew stuff with make.First,weset CFLAGS in the file so weneverhave to set it again,as wellas adding the -g flag to getdebugging. Then, we have a section named clean that tells make how to cleanup our little project.
Make sure it&amp;rsquo;s in the same directory as your ex1.c file, and then run these commands:&lt;/p&gt;

&lt;p&gt;$ make clean
$ make ex1&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;If that worked, thenyou should see this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 2 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ make clean 
rm -f ex1 
$ make ex1 
cc -Wall ­g ex1.c -o ex1 

ex1.c: In function 
&#39;main&#39;: 

ex1.c:3: warning: 
implicit declaration 
of function &#39;puts&#39; 

$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hereyou cansee that I&amp;rsquo;m running make clean, which tells make to run our clean target. Go look at the Makefile again andyou&amp;rsquo;ll see that underthis command, I indentand then putin the shellcommandsIwant make to run for me. You couldput asmanycommands as you wanted in there, so it&amp;rsquo;sa great automationtool.&lt;/p&gt;

&lt;p&gt;Warning!&lt;/p&gt;

&lt;p&gt;If youfixed ex1.c to have &lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/code&gt;, then youroutput won&amp;rsquo;t have thewarning(which shouldreallybe an error) aboutputs. I have the errorhere becauseI didn&amp;rsquo;tfix it.&lt;/p&gt;

&lt;p&gt;Notice thateven though we don&amp;rsquo;tmention ex1 in the Makefile, make still knows how to buildit and use our specialsettings.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;That should beenough toget you started, but firstlet&amp;rsquo;s break this Makefile in a particular waysoyou cansee whathappens. Takethe line rm -f ex1 and remove the indent (move it allthe way left) so you can see what happens. Rerun make clean, and you shouldget something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ make clean Makefile:4: *** missingseparator. Stop. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Always rememberto indent, and if you get weird errors like this,double check that you&amp;rsquo;re consistently using tab characters becausesome make variants areverypicky.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Create an all: ex1 target thatwillbuild ex1 with just the command make.&lt;/p&gt;

&lt;p&gt;• Read man make to find out more informationon how to run it.&lt;/p&gt;

&lt;p&gt;• Read man cc to find outmore information on what the flags ­ Wall and -g do.&lt;/p&gt;

&lt;p&gt;• Research Makefiles online and seeif you can improve this one.&lt;/p&gt;

&lt;p&gt;• Finda Makefile in anotherCproject and try to understandwhat it&amp;rsquo;sdoing.&lt;/p&gt;

&lt;h2 id=&#34;exercise3-formatted-printing:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise3. Formatted Printing&lt;/h2&gt;

&lt;p&gt;Keep that Makefile around since it&amp;rsquo;llhelp you spot errors, andwe&amp;rsquo;ll be adding to it when we needto automate more things.&lt;/p&gt;

&lt;p&gt;Manyprogramming languages use the Cway of formatting output, solet&amp;rsquo;s try it:&lt;/p&gt;

&lt;p&gt;ex3.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 

2 
3 int main() 
4 {
5 int age = 10;
6 int height = 72;
7 

8 printf(&amp;quot;I am %d years old.\n&amp;quot;, age); 
9 printf(&amp;quot;I am %d inches tall.\n&amp;quot;,height); 
1. 11 return 0;
12 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you&amp;rsquo;ve finished that, do the usual make ex3 tobuild and run it. Make sure you fix all warnings.&lt;/p&gt;

&lt;p&gt;This exercisehas awholelot
going on in a small amount of
code, so let&amp;rsquo;sbreak it down:&lt;/p&gt;

&lt;p&gt;• First we&amp;rsquo;reincluding another header file called stdio.h. This tells thecompiler that you&amp;rsquo;re going to use the standard Input/Output functions. One of those is printf.&lt;/p&gt;

&lt;p&gt;• Then we&amp;rsquo;re using a variable named age and setting it to 10.&lt;/p&gt;

&lt;p&gt;• Next we&amp;rsquo;re using a variable height and setting it to72. • Then we&amp;rsquo;re adding the printf function to print the age and height of the tallest 10-year­ old on the planet.&lt;/p&gt;

&lt;p&gt;• In printf,you&amp;rsquo;ll notice we&amp;rsquo;re including a format string, as seen in many other languages.&lt;/p&gt;

&lt;p&gt;• After this format string, we&amp;rsquo;re putting in the variables that should be &amp;ldquo;replaced&amp;rdquo; into the format string by printf.&lt;/p&gt;

&lt;p&gt;The result is giving printf some variables and it&amp;rsquo;s constructing a new string and then printing it to the terminal.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;When you do the whole build, you should see something like this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 3 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ make ex3 
cc -Wall ­g ex3.c -o ex3 
$ ./ex3 
I  am  10  years  old.  
I  am  72  inches  tall.  
$  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty soon I&amp;rsquo;m going to stop telling you to run make and what the build looks like, so please make sure you&amp;rsquo;re getting this rightand that it&amp;rsquo;s working.&lt;/p&gt;

&lt;p&gt;External Research&lt;/p&gt;

&lt;p&gt;In the Extra Credit section of each exercise,you may have you go find information on your own and figure things out. This is an important part of beinga self-sufficient programmer. If you&amp;rsquo;re constantly running toask someone a question before trying to figure things out yourself,then you&amp;rsquo;ll never learn how to solve problems independently.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll never build confidence in your skills and will always need someone else around to do your work. The way to break this habit is to force yourself to try to answer your own question first, and then confirm that your answer is right.&lt;/p&gt;

&lt;p&gt;You do this by trying to break things, experimenting with your answer, and doing your own research. For this exercise, I want you to go online and find out all of the printf escape codes and format sequences. Escape codes are \n or \t that let you print a newline or tab, respectively. Format sequences are the %s or %d that let you print a string or integer.&lt;/p&gt;

&lt;p&gt;Find them all,learn how to modify them, and see whatkind of &amp;ldquo;precisions&amp;rdquo; and widths you can do.&lt;/p&gt;

&lt;p&gt;From now on, these kinds of tasks will be in the Extra Credit sections, and you should do them.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;Try a few of theseways to break this program,which may or may not cause it to crash on your computer:&lt;/p&gt;

&lt;p&gt;• Take the age variable out of the first printf call, then recompile. You should get a couple of warnings.&lt;/p&gt;

&lt;p&gt;• Run this new program and it will either crash or print out a really crazy age.&lt;/p&gt;

&lt;p&gt;• Put the printf back the wayit was, and then don&amp;rsquo;t set age to an initial value by changing that line to int age;, and then rebuild it and run it again.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 3.bad Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
# edit ex3.c to break printf
$ make ex3 
cc -Wall ­g ex3.c -o ex3 ex3.c: In function &#39;main&#39;: ex3.c:8: warning: too few arguments for format ex3.c:5: warning: unused variable &#39;age&#39; 
$ ./ex3 
I am -919092456 years 
old. 
I am 72 inches tall. 

# edit ex3.c again to fix printf, but don&#39;t init age 
$ make ex3 
cc -Wall ­g ex3.c -o ex3 ex3.c: In function &#39;main&#39;: ex3.c:8: warning: &#39;age&#39; is used uninitialized in this function 
$ ./ex3 
I am 0 years old. 
I am 72 inches tall. 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Findas many other ways to break ex3.c asyou can.&lt;/p&gt;

&lt;p&gt;• Run man 3 printfand read about theother % formatcharacters you can use. Theseshould look familiar ifyou used them In other languages (theycome from printf).&lt;/p&gt;

&lt;p&gt;• Add ex3 to the all list in your Makefile. Use this to make clean all andbuild all ofyour exercises thusfar.&lt;/p&gt;

&lt;p&gt;• Add ex3 to the clean list in your Makefile as well. Use make clean to remove it when youneed to.&lt;/p&gt;

&lt;h2 id=&#34;exercise4-using-a-debugger:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise4. Using a Debugger&lt;/h2&gt;

&lt;p&gt;This is a video-focused exercisewhere I show you how to use thedebuggerthat comeswithyour computer to debug yourprograms, detect errors, andeven debug processesthat arecurrently running. Pleasewatch the accompanying video to learn more about this topic.&lt;/p&gt;

&lt;p&gt;GDB Tricks&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s alist ofsimple tricks you can do with GNU Debugger (GDB):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gdb &amp;ndash;args Normally, gdb takes arguments you giveit and assumes they are for itself.

&lt;ul&gt;
&lt;li&gt;Using &amp;ndash;args passes them to the program.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;thread apply allbt Dump abacktrace for all threads. It&amp;rsquo;sveryuseful.&lt;/li&gt;
&lt;li&gt;gdb &amp;ndash;batch &amp;ndash;exr &amp;ndash;ex bt &amp;ndash;ex q &amp;ndash;args Run the programso that ifit bombs, you get a backtrace.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GDB Quick&lt;/p&gt;

&lt;p&gt;Reference&lt;/p&gt;

&lt;p&gt;The video is good for learning how to use a debugger, butyou&amp;rsquo;llneed to refer backto the commands asyou work. Here is aquick referenceto the &lt;code&gt;GDB&lt;/code&gt; commands thatI used in the video so you can use them laterin the book:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;run [args] &amp;ndash; Start your programwith[args].&lt;/li&gt;
&lt;li&gt;break[file:]function Set abreakpoint at [file:]function. You can also use b.&lt;/li&gt;
&lt;li&gt;backtrace Dump a backtrace of the current calling stack. Shorthand is bt.&lt;/li&gt;
&lt;li&gt;print expr Print the value of expr. Shorthand is p.&lt;/li&gt;
&lt;li&gt;continue Continue running theprogram. Shorthand is c.&lt;/li&gt;
&lt;li&gt;next Next line, but step over function calls. Shorthand is n.&lt;/li&gt;
&lt;li&gt;step Nextline, butstep into function calls. Shorthand is s.&lt;/li&gt;
&lt;li&gt;quit Exit &lt;code&gt;GDB&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;help List the types of commands. You can thenget help on the classof commandas wellas thecommand.&lt;/li&gt;
&lt;li&gt;cd, pwd, make This is just like running these commands in your shell.&lt;/li&gt;
&lt;li&gt;shell Quicklystart a shell so you can do other things.&lt;/li&gt;
&lt;li&gt;clear Clear a breakpoint.&lt;/li&gt;
&lt;li&gt;infobreak,info watch Show information about breakpointsand watchpoints.&lt;/li&gt;
&lt;li&gt;attach pid Attachto a running process so you can debug it.&lt;/li&gt;
&lt;li&gt;detach Detach fromthe process.&lt;/li&gt;
&lt;li&gt;list Lis tout thenextten source lines. Add a -to list thepreviousten lines.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LLDB Quick Reference&lt;/p&gt;

&lt;p&gt;In OS X, you no longer have &lt;code&gt;GDB&lt;/code&gt; and instead must use a similarprogram calledLLDB Debugger (LLDB). The commands are almost the same, buthere&amp;rsquo;sa quick referenceforLLDB:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;run [args] Start your programwith[args].&lt;/li&gt;
&lt;li&gt;breakpoint set &amp;ndash;name[file:]function Seta break point at [file:]function. You can also use b, which is way easier.&lt;/li&gt;
&lt;li&gt;thread backtrace Dump a backtrace of the current calling stack. Shorthand is bt.&lt;/li&gt;
&lt;li&gt;print expr Print the value ofexpr. Shorthand is p.&lt;/li&gt;
&lt;li&gt;continue Continue running theprogram. Shorthand is c.&lt;/li&gt;
&lt;li&gt;next Next line, but step over function calls. Shorthand is n.&lt;/li&gt;
&lt;li&gt;step Nextline, but step into function calls. Shorthand is s.&lt;/li&gt;
&lt;li&gt;quit Exit LLDB.&lt;/li&gt;
&lt;li&gt;help List the types of commands. You can thenget help on the classof commandas wellas thecommand itself.&lt;/li&gt;
&lt;li&gt;cd, pwd, make just like running these commands in your shell.&lt;/li&gt;
&lt;li&gt;shell Quicklystart a shell so you can do other things.&lt;/li&gt;
&lt;li&gt;clear Clear a breakpoint.&lt;/li&gt;
&lt;li&gt;infobreak,info watch Show information about break points and watchpoints.&lt;/li&gt;
&lt;li&gt;attach -p pid Attach toa running process so you can debug it.&lt;/li&gt;
&lt;li&gt;detach Detach fromthe process. list Lis tout thenextten source lines. Add a -to list thepreviousten sources.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can also searchonline for quick reference cards and tutorials for both &lt;code&gt;GDB&lt;/code&gt; and LLDB.&lt;/p&gt;

&lt;h2 id=&#34;exercise5-memorizing-c-operators:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise5. Memorizing C Operators&lt;/h2&gt;

&lt;p&gt;When youlearned your first programming language,it most likely involved going through a book, typing in codeyou didn&amp;rsquo;t quite understand, andthen trying to figure outhow itworked.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s how Iwrote mostof myother books, and that works very well for beginners. In thebeginning, there are complex topics you need to understand before you can grasp whatall the symbols and words mean, so it&amp;rsquo;saneasyway to learn.&lt;/p&gt;

&lt;p&gt;However, once you already know oneprogramming language, thismethodof fumbling aroundlearning the syntax byosmosisisn&amp;rsquo;t the most efficientway to learna language. Itworks, but there is amuchfasterway to build both yourskills in a language and your confidence in using it. This methodof learning a programming language might seem like magic, but you&amp;rsquo;ll have to trust me that it works surprisingly well.&lt;/p&gt;

&lt;p&gt;How I want you to learn C is to first memorizeall the basic symbols and syntax, then apply them througha series ofexercises. This methodis very similarto howyou mightlearnhuman languages by memorizing words and grammar, andthen applying what youmemorize in conversations. With just a simple amount of memorization effort in the beginning, you can gain foundational knowledgeand have aneasier time reading
and writingC code.&lt;/p&gt;

&lt;p&gt;Warning!&lt;/p&gt;

&lt;p&gt;Some people are dead against memorization. Usually, they claimit makesyouuncreative andboring. I&amp;rsquo;m proof that memorizing things doesn&amp;rsquo;t make you uncreative and boring. I paint, play and build guitars, sing,code, write books, and I memorize lots of things. This belief is entirely unfounded and detrimental to efficient learning. Please ignore anyone telling you this.&lt;/p&gt;

&lt;p&gt;How to Memorize&lt;/p&gt;

&lt;p&gt;The best way to memorize something is a fairly simple process:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Create a setof flash cards that have a symbolon oneside and the descriptionon the other. Youcould also use aprogram called Anki to do this on your computer. I prefer creating my own because ithelps me memorize them asI makethem.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Randomize the flash cards and startgoing through them on one side. Try yourbest to remember theother side of the cardwithout looking.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you can&amp;rsquo;trecallthe other side of the card, thenlook atit and repeat the answer to yourself,then put that cardintoa separate pile.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once yougo through all thecards you&amp;rsquo;ll have twopiles:one pileof cards you recalled quickly, and another you failed to recall.
Pick up the fail pile and drill yourself on only those cards.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;At the very endof the session, which is usually 15–30 minutes, you&amp;rsquo;ll have a set of cards you just can&amp;rsquo;t recall. Take those cards with you wherever you go, and when you have free time, practice memorizing them.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are many other tricks to memorizing things, but I&amp;rsquo;ve foundthat this is the best way to buildinstant recallon things you needto be ableto use immediately. The symbols, keywords, and syntax of C are things you need instantrecallon,sothis methodis the best onefor this task.&lt;/p&gt;

&lt;p&gt;Also remember that you need to do both sides of the cards. You should be ableto read the description and know whatsymbolmatches it, as wellas knowing the description for a symbol.&lt;/p&gt;

&lt;p&gt;Finally, you don&amp;rsquo;t have to stop whileyou&amp;rsquo;rememorizing these operators. The best approachis to combine this with exercisesin this book so you can apply what you&amp;rsquo;ve memorized. Seethe next exercisefor more onthis.&lt;/p&gt;

&lt;p&gt;The List of Operators&lt;/p&gt;

&lt;p&gt;The first operators are the arithmetic operators, which are very similarto almost every other programming language. When you write the cards, thedescription side should say that it&amp;rsquo;san arithmetic operator, andwhat it does.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operator&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;Adds two operands.&lt;/td&gt;
&lt;td&gt;A + B = 30&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;−&lt;/td&gt;
&lt;td&gt;Subtracts second operand from the first.&lt;/td&gt;
&lt;td&gt;A − B = -10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;Multiplies both operands.&lt;/td&gt;
&lt;td&gt;A * B = 200&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;Divides numerator by de-numerator.&lt;/td&gt;
&lt;td&gt;B / A = 2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;Modulus Operator and remainder of after an integer division.&lt;/td&gt;
&lt;td&gt;B % A = 0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;++&lt;/td&gt;
&lt;td&gt;Increment operator increases the integer value by one.&lt;/td&gt;
&lt;td&gt;A++ = 11&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;ndash;&lt;/td&gt;
&lt;td&gt;Decrement operator decreases the integer value by one.&lt;/td&gt;
&lt;td&gt;A&amp;ndash; = 9&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Relational operators test valuesforequality, andagain, they are very common in programming languages.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operator&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;==&lt;/td&gt;
&lt;td&gt;Checks if the values of two operands are equal or not. If yes, then the condition becomes true.&lt;/td&gt;
&lt;td&gt;(A == B) is not true.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Checks if the values&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;Checks if the value of left operand is greater than the value of right operand. If yes, then the condition becomes true.&lt;/td&gt;
&lt;td&gt;(A &amp;gt; B) is not true.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;Checks if the value of left operand is less than the value of right operand. If yes, then the condition becomes true.&lt;/td&gt;
&lt;td&gt;(A &amp;lt; B) is true.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;Checks if the value of left operand is greater than or equal to the value of right operand. If yes, then the condition becomes true&lt;/td&gt;
&lt;td&gt;. (A &amp;gt;= B) is not true.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;Checks if the value of left operand is less than or equal to the value of right operand. If yes, then the condition becomes true.&lt;/td&gt;
&lt;td&gt;(A&amp;lt;= B) is true.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Logical operators perform logic tests, and you should already knowwhat thesedo.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operator&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;Called Logical AND operator. If both the operands are non-zero, then the condition becomes true.&lt;/td&gt;
&lt;td&gt;(A &amp;amp;&amp;amp; B) is false.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;td&gt;Called Logical OR Operator. If any of the two operands is non-zero, then the condition becomes true.&lt;/td&gt;
&lt;td&gt;(A || B) is true.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;Called Logical NOT Operator. It is used to reverse the logical state of its operand. If a condition is true, then Logical NOT operator will make it false.&lt;/td&gt;
&lt;td&gt;!(A &amp;amp;&amp;amp; B) is true.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The only odd one is the logical ternary, which you&amp;rsquo;ll learn later in this book.&lt;/p&gt;

&lt;p&gt;Bitwise operators do something you likely won&amp;rsquo;t experienceoften in modern code. They alter thebits that makeup bytes and otherdata types in variousways. I won&amp;rsquo;t cover this in mybook, but they are very handy when working with certaintypes of lower-levelsystems.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;p&lt;/th&gt;
&lt;th&gt;q&lt;/th&gt;
&lt;th&gt;p &amp;amp; q&lt;/th&gt;
&lt;th&gt;p|q&lt;/th&gt;
&lt;th&gt;p^q&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Samples:&lt;/p&gt;

&lt;p&gt;Assume A = 60 and B = 13 in binary format, they will be as follows −&lt;/p&gt;

&lt;p&gt;A = 0011 1100&lt;/p&gt;

&lt;p&gt;B = 0000 1101&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;A&amp;amp;B = 0000 1100&lt;/p&gt;

&lt;p&gt;A|B = 0011 1101&lt;/p&gt;

&lt;p&gt;A^B = 0011 0001&lt;/p&gt;

&lt;p&gt;~A = 1100 0011&lt;/p&gt;

&lt;p&gt;The following table lists the bitwise operators supported by C. Assume variable &amp;lsquo;A&amp;rsquo; holds 60 and variable &amp;lsquo;B&amp;rsquo; holds 13.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operator&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;Binary AND Operator copies a bit to the result if it exists in both operands.&lt;/td&gt;
&lt;td&gt;(A &amp;amp; B) = 12, i.e., 0000 1100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;Binary OR Operator copies a bit if it exists in either operand.&lt;/td&gt;
&lt;td&gt;(A | B) = 61, i.e., 0011 1101&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;Binary XOR Operator copies the bit if it is set in one operand but not both.&lt;/td&gt;
&lt;td&gt;(A ^ B) = 49, i.e., 0011 0001&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;Binary Ones Complement Operator is unary and has the effect of &amp;lsquo;flipping&amp;rsquo; bits.&lt;/td&gt;
&lt;td&gt;(~A ) = -61, i.e,. 1100 0011 in 2&amp;rsquo;s complement form.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.&lt;/td&gt;
&lt;td&gt;A &amp;lt;&amp;lt; 2 = 240 i.e., 1111 0000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.&lt;/td&gt;
&lt;td&gt;A &amp;gt;&amp;gt; 2 = 15 i.e., 0000 1111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Assignment operators simply assignexpressions to variables, but Ccombines a large number ofother operators with assignment. So when I say and-equal,I mean the bitwise operators, not the logical operators.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m calling these data operators but theyreally deal with aspects of pointers, member access, andvarious elements ofdata structures in C.&lt;/p&gt;

&lt;p&gt;Finally,there area few miscellaneous symbolsthat are either frequently usedfor differentroles (like ,), or don&amp;rsquo;tfit into any of the previous categories for variousreasons.&lt;/p&gt;

&lt;p&gt;Study your flash cards while you continuewith the book. If youspent 15–30 minutes a day before studying, and another15–30 minutes before bed, you could most likely memorize allof these in a fewweeks.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 6. Memorizing C Syntax&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After learning theoperators, it&amp;rsquo;stime to memorize the keywords andbasic syntax structures you&amp;rsquo;llbe using. Trustme when I tellyou that the small amount oftime spentmemorizing these things will payhuge dividends later as you go through thebook.&lt;/p&gt;

&lt;p&gt;As I mentionedin Exercise5, you don&amp;rsquo;thave to stop reading the book while you memorize these things. You can andshould doboth. Use your flash cardsas a warm up beforecoding thatday. Take them out and drillon them for 15–30minutes, thensitdown and do somemore exercises in thebook. Asyougo through thebook,try to use the code you&amp;rsquo;retypingas more of away to practice what you&amp;rsquo;rememorizing. One trick is to builda pile offlash cards containing operators and keywordsthat you don&amp;rsquo;t immediately recognizewhile you&amp;rsquo;re coding. Afteryou&amp;rsquo;re done for the day,practice thoseflash cards for another 15–30minutes.&lt;/p&gt;

&lt;p&gt;Keep this up and you&amp;rsquo;ll learn C much faster and more solidlythan you wouldif you just stumbled around typing codeuntilyoumemorized it secondhand.&lt;/p&gt;

&lt;p&gt;The Keywords&lt;/p&gt;

&lt;p&gt;The keywords of alanguage are words that augment the symbolssothat thelanguage reads well. There are some languages like APLthat don&amp;rsquo;t really havekeywords. There are otherlanguages likeForth and LISPthat are almost nothing but keywords. In the middleare languages like C, Python, Ruby, and many more that mix setsof keywords with symbolsto createthe basis of the language.&lt;/p&gt;

&lt;p&gt;Warning!&lt;/p&gt;

&lt;p&gt;The technical termfor processing the symbols andkeywordsof a programming language is lexical analysis.The wordforone of these symbolsor keywords is a lexeme.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;auto&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;struct&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;break&lt;/td&gt;
&lt;td&gt;else&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;switch&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;case&lt;/td&gt;
&lt;td&gt;enum&lt;/td&gt;
&lt;td&gt;register&lt;/td&gt;
&lt;td&gt;typedef&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;const&lt;/td&gt;
&lt;td&gt;extern&lt;/td&gt;
&lt;td&gt;return&lt;/td&gt;
&lt;td&gt;union&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;unsigned&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;continue&lt;/td&gt;
&lt;td&gt;for&lt;/td&gt;
&lt;td&gt;signed&lt;/td&gt;
&lt;td&gt;volatile&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;goto&lt;/td&gt;
&lt;td&gt;sizeof&lt;/td&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;do&lt;/td&gt;
&lt;td&gt;if&lt;/td&gt;
&lt;td&gt;statiic&lt;/td&gt;
&lt;td&gt;while&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Operators  Precedence in C&lt;/p&gt;

&lt;p&gt;Operator precedence determines the grouping of terms in an expression and decides how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has a higher precedence than the addition operator.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Category&lt;/th&gt;
&lt;th&gt;Operator&lt;/th&gt;
&lt;th&gt;Associativity&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Postfix&lt;/td&gt;
&lt;td&gt;() [] -&amp;gt; . ++ - -&lt;/td&gt;
&lt;td&gt;Left to right&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Unary&lt;/td&gt;
&lt;td&gt;+ - ! ~ ++ - - (type)* &amp;amp; sizeof&lt;/td&gt;
&lt;td&gt;Right to left&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Multiplicative * / %&lt;/td&gt;
&lt;td&gt;Left to right&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Additive&lt;/td&gt;
&lt;td&gt;+ -&lt;/td&gt;
&lt;td&gt;Left to right&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Shift&lt;/td&gt;
&lt;td&gt;&amp;lt;&amp;lt; &amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;Left to right&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Relational&lt;/td&gt;
&lt;td&gt;&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=&lt;/td&gt;
&lt;td&gt;Left to right&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Equality&lt;/td&gt;
&lt;td&gt;== !=&lt;/td&gt;
&lt;td&gt;Left to right&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Bitwise AND&lt;/td&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;Left to right&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Bitwise XOR&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;Left to right&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Bitwise OR     |&lt;/td&gt;
&lt;td&gt;Left to right&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Logical AND&lt;/td&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;Left to right&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Logical OR&lt;/td&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;td&gt;Left to right&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Conditional&lt;/td&gt;
&lt;td&gt;?:&lt;/td&gt;
&lt;td&gt;Right to left&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Assignment&lt;/td&gt;
&lt;td&gt;= += -= *= /= %=&amp;gt;&amp;gt;= &amp;lt;&amp;lt;= &amp;amp;= ^= |=&lt;/td&gt;
&lt;td&gt;Right to left&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Comma&lt;/td&gt;
&lt;td&gt;,&lt;/td&gt;
&lt;td&gt;Left to right&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Syntax Structures&lt;/p&gt;

&lt;p&gt;I suggest you memorize those keywords,as well as memorizing thesyntax structures. A syntax structure is apattern ofsymbols that makeup a Cprogram code form, such as the formof an if-statement or a while-loop.&lt;/p&gt;

&lt;p&gt;You should find most of these familiar, since you already know one language. The only trouble is thenlearning how Cdoesit.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how youread these:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Anything in ALLCAPS ismeant as a replacement spotor hole.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Seeing [ALLCAPS]meansthat part is optional.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The bestway to test your memoryof syntax structuresis to open a texteditor, and where you see switch-statement, try to write the code form after saying whatit does.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;An if-statement is your basic logic branching control:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if(TEST) {```cCODE; }
else if(TEST) {CODE; } 
else {CODE; } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A switch-statement is like an if-statement but works onsimple integer constants:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;switch (OPERAND) {
    case CONSTANT: CODE;break;
    default: 
    CODE; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A while-loop is your most basic loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;while(TEST) {
CODE; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use continue&lt;/p&gt;

&lt;p&gt;to cause itto loop. Call this form while-continue­loop for now:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;while(TEST) 
{
    if(OTHER_TEST) 
    {
        continue;
    } 
    CODE; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use break to exita loop. Callthis form while-break-loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;while(TEST) { 
    if(OTHER_TEST) 
    {
        break; 
    }
    CODE; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The do-while-loop is an inverted version of a while-loop thatruns the code then tests to see if itshould run again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;do {
    CODE; 
} while(TEST); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It canalso have continue and break inside tocontrol how it operates.&lt;/p&gt;

&lt;p&gt;The for-loop doesa controlledcounted loop through a (hopefully) fixed number o fiterations using a counter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for(INIT; TEST; POST) 
{ 
    CODE; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An enum creates asetof integerconstants: &lt;code&gt;enum { CONST1,CONST2, CONST3 }NAME;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A goto will jump toa label, and is only used in a few useful situations likeerror detectionand exiting:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if(ERROR_TEST) 
{
    goto fail; 
} 
fail: 
CODE; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A function is defined this way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TYPE NAME(ARG1, ARG2, ..) 
{
    ODE; 
    return VALUE; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That may be hard to remember, so try this example tosee what&amp;rsquo;s meant by TYPE, NAME, ARG and VALUE:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int name(arg1, arg2)
{ 
    CODE; 
    return 0; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A typedef defines a new type: &lt;code&gt;typedef DEFINITION IDENTIFIER;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A more concrete form of this is: &lt;code&gt;typedef unsigned char byte;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t let the spaces fool you; the DEFINITION is unsigned char and the IDENTIFIER is byte in that example.&lt;/p&gt;

&lt;p&gt;A struct is apackagingof many base datatypes into a single concept,which are
used heavilyin C:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;struct NAME {ELEMENTS;} [VARIABLE_NAME];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The [VARIABLE_NAME] is optional, and I prefer not to use it except in a few small cases. This is commonly combined with typedef like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct [STRUCT_NAME] {
    ELEMENTS; 
} IDENTIFIER; 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, union creates something like a struct, but the elements will overlap in memory. This is strange to understand, so simply memorize the form for now:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;union NAME {ELEMENTS;} [VARIABLE_NAME];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A Word of Encouragement&lt;/p&gt;

&lt;p&gt;Once you&amp;rsquo;ve created flash cards for each of these, drill on themin the usual way by starting with the nameside, and then reading the description and formon the other side.&lt;/p&gt;

&lt;p&gt;In the video for this exercise, I show you how to use Ankito do this efficiently, but you can replicate the experiencewith simple index cards, too. I&amp;rsquo;ve noticedsome fear or discomfort in students who are askedto memorize something like this. I&amp;rsquo;mnot exactly surewhy, but I encourage you to do it anyway.
Look at this asan opportunityto improve your memorization and learning skills. The moreyou do it,the better at it you get and the easier it gets.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s normal to feel discomfort and frustration. Don&amp;rsquo;t take it personally. You might spend 15 minutes and simply hate doing it and feel like a total failure. This is normal, and it doesn&amp;rsquo;t mean you actually are a failure. Perseverance will get you past the initial frustration, and this little exercisewillteach you two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You can use memorization as a self­evaluation ofyour competence. Nothing tells you how well you really know a subject likea memory test of its concepts.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The way to conquer difficulty is a little piece at a time. Programming is a great way to learnthis because it&amp;rsquo;s so easy to&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;break down into small partsand focus on what&amp;rsquo;s lacking. Take this as an opportunity to build yourconfidence in tackling large tasks in small pieces.&lt;/p&gt;

&lt;p&gt;A Word of Warning&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll adda finalword of warning about memorization. Memorizing alarge quantity offacts doesn&amp;rsquo;t automatically make you good at applying those facts. You can memorize the entire ANSI C standards documentand still be a terrible programmer. I&amp;rsquo;ve encountered many supposed C experts who know every square inch of standard C grammar but still write terrible,buggy, weird code, or don&amp;rsquo;t code at all.&lt;/p&gt;

&lt;p&gt;Never confuse an ability to regurgitatememorized facts with ability to actually do something well. Todo that you need toapply these facts in different situationsuntil you know how to use them. That&amp;rsquo;s what the rest of this book will help you do.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 7. Variablesand Types&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You should be getting agrasp ofhow a simple C programis structured, so let&amp;rsquo;sdo thenext simplest thingand make somevariables ofdifferent types:&lt;/p&gt;

&lt;p&gt;ex7.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1  #include &amp;lt;stdio.h&amp;gt; 
2 
3  int main(intargc, char*argv[]) 
4  {
5  int distance = 100;
6  float power = 2.345f;
7  double super_power = 56789.4532;
8  char initial = &#39;A&#39;;
9  char first_name[] = &amp;quot;Zed&amp;quot;;
10 char last_name[] = &amp;quot;Shaw&amp;quot;;
11 
12 printf(&amp;quot;You are %d miles away.\n&amp;quot;, distance); 
13 printf(&amp;quot;You have %f levels of power.\n&amp;quot;, power); 
14 printf(&amp;quot;You have %f awesome super powers.\n&amp;quot;, super_power);
15 printf(&amp;quot;I have an initial %c.\n&amp;quot;, initial); 
16 printf(&amp;quot;I have a first name %s.\n&amp;quot;, first_name);
17 printf(&amp;quot;I have a last name %s.\n&amp;quot;, last_name); 
18 printf(&amp;quot;My whole name is %s %c. %s.\n&amp;quot;,
19          first_name, initial, last_name); 
20 
21 int bugs = 100;
22 double bug_rate = 1.2;
23
24 printf(&amp;quot;You have %d bugs at the imaginary rate of %f.\n&amp;quot;,
25             bugs, bug_rate); 
26
27 long universe_of_defects = 1L * 1024L * 1024L * 1024L;
28 printf(&amp;quot;The entire universe has %ld bugs.\n&amp;quot;,universe_of_defects); 
29 
30 double expected_bugs = bugs * bug_rate;
31 printf(&amp;quot;You are expected to have %f bugs.\n&amp;quot;,expected_bugs); 
32 
33 double part_of_universe = expected_bugs /universe_of_defects;
34 printf(&amp;quot;That is only a %e portion of the universe.\n&amp;quot;,
35  part_of_universe ); 
36 
37 // this makes no sense, just a demo of something weird 
38 char nul_byte = &#39;\0&#39;;39 int care_percentage = bugs * nul_byte;
40 printf(&amp;quot;Which means you should care %d%%.\n&amp;quot;, care_percentage);
41 
42  return 0;
43 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this program, we&amp;rsquo;re declaring variables of differenttypes andthen printing themusingdifferent printf format strings. I can break it down as follows:&lt;/p&gt;

&lt;p&gt;ex7.c:1-4 The usualstart ofa C program.&lt;/p&gt;

&lt;p&gt;ex7.c:5-6 Declare an int and double forsome fakebug data.&lt;/p&gt;

&lt;p&gt;ex7.c:8-9 Print out those two, so nothing new here.&lt;/p&gt;

&lt;p&gt;ex7.c:11 Declarea huge number using anew type, long, for storing bignumbers.&lt;/p&gt;

&lt;p&gt;ex7.c:12-13 Printout that number using %ld that adds a modifierto the usual %d. Adding l (the letter) tells the program to print the number as a long decimal.&lt;/p&gt;

&lt;p&gt;ex7.c:15-17 This is just more math andprinting.&lt;/p&gt;

&lt;p&gt;ex7.c:19-21 Craft a depiction ofyour bug rate compared to the bugs in the universe, which is a completely inaccurate calculation. It&amp;rsquo;s so small that we have touse %e to print it in scientific notation.&lt;/p&gt;

&lt;p&gt;ex7.c:24 Make a character, with aspecial syntax &amp;lsquo;\0&amp;rsquo; that creates a nul byte character. This is effectively thenumber 0.&lt;/p&gt;

&lt;p&gt;ex7.c:25 Multiply bugsby this character,which produces0, as in how much you should care. This demonstrates an ugly hackyou might seesometimes.&lt;/p&gt;

&lt;p&gt;ex7.c:26-27 Print that out, and noticewe&amp;rsquo;veused %% (two percent signs) so thatwecanprint a % (percent) character.&lt;/p&gt;

&lt;p&gt;ex7.c:28-30 The end of the main function.&lt;/p&gt;

&lt;p&gt;This source filedemonstrates how somemathworks with differenttypes ofvariables. At the end of the program, it also demonstratessomething you seein Cbutnot inmany other languages. To C, a character isjust an integer. It&amp;rsquo;s a reallysmallinteger, but that&amp;rsquo;s all itis. This meansyou can domathon them, and a lotof software does just that —for good orbad.&lt;/p&gt;

&lt;p&gt;This last bitisyour first glanceathow Cgives you direct accessto the machine. We&amp;rsquo;ll be exploring thatmore in later exercises.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;As usual, here&amp;rsquo;s what you should see for the output:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 7 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ make ex7 
cc -Wall ­g ex7.c -o ex7 
$ ./ex7

You have 100 bugs at the imaginary rate of 1.200000. The entire universe has 1073741824 bugs. You are expected to have 120.000000 bugs. That is only a 1.117587e-07 portion of the universe. Which means you 
should care 0%. 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;Again, go throughthis andtry to break the printf by passing in thewrong arguments. See what happens if you try toprint out the nul_byte variable along with %s versus %c. When you break it,runit under the debugger tosee what it says about what you did.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Makethe number you assign to universe_of_defec various sizes untilyou get a warning from the compiler.&lt;/p&gt;

&lt;p&gt;• What do thesereally huge numbersactually printout?&lt;/p&gt;

&lt;p&gt;• Change long to unsigned long and try to find thenumber thatmakes ittoo big.&lt;/p&gt;

&lt;p&gt;• Gosearch onlineto find outwhat unsigned does.&lt;/p&gt;

&lt;p&gt;• Try to explain to yourself (before I doin the next exercise) why you can multiplya char and an int.&lt;/p&gt;

&lt;h2 id=&#34;exercise8-if-else-if-else:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise8. If, Else-If, Else&lt;/h2&gt;

&lt;p&gt;In C, there really isn&amp;rsquo;t a Boolean type. Instead,any integerthat&amp;rsquo;s0is false or otherwise it&amp;rsquo;s true. In the last exercise, the expression argc &amp;gt; 1 actuallyresulted in 1 or 0, not an explicit True or False like in Python. This isanother example of C being closerto how acomputer works, because toacomputer, truth values are just integers.&lt;/p&gt;

&lt;p&gt;However, C doeshave a typical if-statement that uses this numeric ideaof true and false to dobranching. It&amp;rsquo;s fairlysimilar towhat you woulddo in Pythonand Ruby,as you can see in this exercise:&lt;/p&gt;

&lt;p&gt;ex8.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 

2 
3 int main(int argc, char *argv[]) 
4 {
5 int i =0;6 7 if (argc == 1) {
8 printf(&amp;quot;Y only have one argument. You suck.\n&amp;quot;); 
9 } else if (argc &amp;gt; 1 &amp;amp;&amp;amp; argc &amp;lt; 4) {
10 printf(&amp;quot;H your arguments:\n&amp;quot;); 
11
12 for (i = 0; i &amp;lt; argc; i++) {
13 print &amp;quot;, argv[i]); 
14  }
15 printf(&amp;quot;\ 
16 } else {17 printf(&amp;quot;Y have too manyarguments. You suck.\n&amp;quot;); 
18 }
19
20 return 0; 
21 } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The format for the if-statement is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(TEST) {CODE; }
 else if(TEST) {CODE; } 
else {CODE; 
} 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is like most other languages except for some specific C differences:&lt;/p&gt;

&lt;p&gt;• As mentionedbefore, the TEST parts are false if they evaluate to0, or otherwisetrue.&lt;/p&gt;

&lt;p&gt;• You have to put paren theses around the TEST elements, while someother languages let you skipthat.&lt;/p&gt;

&lt;p&gt;• You don&amp;rsquo;t need the {}braces to enclosethe code, but it is very bad formto notusethem. Thebraces make it clear whereone branch ofcode begins and ends. If you don&amp;rsquo;t include them then obnoxiouserrors come up.&lt;/p&gt;

&lt;p&gt;Other than that, the code works the way it doesin most other languages. You don&amp;rsquo;t need to have either else if or else parts.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;This oneis pretty simple to run and try out:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 8 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;

$ make ex8 
cc -Wall ­g ex8.c -o ex8 
$ ./ex8

You only have one argument. You suck. 
$ ./ex8 one 

Here&#39;s your arguments: ./ex8 one 
$ ./ex8 one two 

Here&#39;s your arguments: ./ex8 one two 
$ ./ex8 one two three 

You have too many arguments. You suck. 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;This oneisn&amp;rsquo;teasyto break because it&amp;rsquo;s so simple, but try messing upthe tests in the if-statement:
• Removethe else at the end, and the programwon&amp;rsquo;t catch the edge case.&lt;/p&gt;

&lt;p&gt;• Change the &amp;amp;&amp;amp; to a || so you get an or instead of anand test and see how thatworks.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• You werebriefly introducedto &amp;amp;&amp;amp;,which does an and comparison, so go research online the different Boolean operators.&lt;/p&gt;

&lt;p&gt;• Write a few more test cases forthis program to see what you can come up with.&lt;/p&gt;

&lt;p&gt;• Is the first test really saying the right thing? Toyou, the first argument isn&amp;rsquo;t the same first argument a user entered. Fix it.&lt;/p&gt;

&lt;h2 id=&#34;exercise9-while-loop-and-boolean-expressions:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise9. While-Loop and Boolean Expressions&lt;/h2&gt;

&lt;p&gt;The first looping construct I&amp;rsquo;ll show you is the while­loop, and it&amp;rsquo;sthe simplest, useful loop you could possiblyusein C. Here&amp;rsquo;s this exercise&amp;rsquo;s codefor discussion:&lt;/p&gt;

&lt;p&gt;ex9.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 
2
3 int main(int argc, char *argv[]) 
4 {
5  int i = 0;
6  while (i &amp;lt; 25) {
7  printf(&amp;quot;% i);
8  i++;
9  }
10 
11 return 0;
12 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this code, and from your memorization of the basic syntax, you can see that a while-loop is simply this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(TEST) { 
CODE; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Itsimply runs the CODE as long as TEST istrue (1). So to replicatehowthe for-loop works, we needto do our own initializingand incrementing of i. Remember that i++ increments i with the post-incrementoperator. Refer back to your lis tof tokens if you didn&amp;rsquo;t recognizethat.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;The outputis basically the same, so I just did ita little differently so thatyou can see it run another way.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 9 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ make ex9 
cc -Wall ­
g ex9.c -o ex9 
$ ./ex9
arg 0: ./ex9 
state 0: California 
state 1: Oregon
state 2: Washington 
state 3: Texas 
$
$ ./ex9 test it 
arg 0: ./ex9 
arg 1: test 
arg 2: it 
state 0: California s
tate 1: Oregon 
state 2: Washington 
state 3: Texas 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;There areseveralwaysto get a while-loop wrong,soI don&amp;rsquo;trecommend you use it unlessyou must. Hereare a feweasyways to break it:&lt;/p&gt;

&lt;p&gt;• Forget toinitialize the first int i;. Depending onwhat i starts with, theloop mightnot run at all, or run for an extremely long time.&lt;/p&gt;

&lt;p&gt;• Forget toinitialize the secondloop&amp;rsquo;s i so that it retains thevalue from the endof the first loop. Now your second loop mightor might notrun.&lt;/p&gt;

&lt;p&gt;• Forget todo a i++ increment at the end of the loop and you&amp;rsquo;ll get a forever loop, one of the dreaded problems common in the first decadeor two of programming.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Makethe loop count backwardby using i-­to start at 25 and go to 0.&lt;/p&gt;

&lt;p&gt;• Write a few more complex while-loops using what you know so far.&lt;/p&gt;

&lt;h2 id=&#34;exercise10-switch-statements:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise10. Switch Statements&lt;/h2&gt;

&lt;p&gt;In other languages, likeRuby, you have a switch-statement that can take any expression. Some languages, likePython,don&amp;rsquo;t have a switch-statement because an if­statement with Boolean expressionsisabout the same thing. For these languages, switch-statements are more like alternatives to if-statements and work the same internally.&lt;/p&gt;

&lt;p&gt;In C, the switch-statement is actually quite differentand is really a jump table.Instead of random Boolean expressions,you can only put expressionsthat result in integers. These integers areused to calculate jumps from the top of the switch to the part that matches thatvalue. Here&amp;rsquo;s somecode to help you understand this concept of jump tables:&lt;/p&gt;

&lt;p&gt;ex10.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1  #include &amp;lt;stdio.h&amp;gt;
2 
3  int main(int argc, char *argv[]) 
4  {
5  int i = 0;
6 
7  // go through each string in argv 
8  // why am I skipping argv[0]?
9  for (i =1;i &amp;lt; argc; i++) { 
10   printf(&amp;quot;a %d: %s\n&amp;quot;, i, argv[i]); 
11 }
12 
13 // let&#39;s make our own array of strings 
14 char *states[] = {
15 &amp;quot;Californ &amp;quot;Oregon&amp;quot;,
16 &amp;quot;Texas&amp;quot;  &amp;quot;Washingt  
17 
18  };  
19  int num_states  =  4;
20
21 for (i = 0;i &amp;lt; num_states; i++){
22 printf(&amp;quot;s %d: %s\n&amp;quot;, i,states[i]); 
23 }
24
25 return 0;
26 } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this program, we take a single command line argument and print out all vowels in an incredibly tedious way to demonstratea switch-statement. Here&amp;rsquo;s how the switch-statement works:&lt;/p&gt;

&lt;p&gt;• The compiler marks the place in the program where the switch-statement starts. Let&amp;rsquo;s call this location Y.&lt;/p&gt;

&lt;p&gt;• It then evaluates the expressionin switch(letter) to come up with a number. In this case, thenumber willbe the raw ASCII code of the letter in argv[1].&lt;/p&gt;

&lt;p&gt;• The compiler also translates each of the case blocks like case &amp;lsquo;A&amp;rsquo;: into alocation in the program that&amp;rsquo;s that faraway. Sothe code under case &amp;lsquo;A&amp;rsquo; is at Y +Ain theprogram.&lt;/p&gt;

&lt;p&gt;• It then does the math to figure outwhereY+ letter islocated in the switch- statement, and if it&amp;rsquo;s toofar, then it adjusts it to Y + default.&lt;/p&gt;

&lt;p&gt;• Onceit knows the location, theprogram jumps to that spotin the code, andthen continuesrunning. This iswhy youhave break on some of the case blocks butnoton others.&lt;/p&gt;

&lt;p&gt;• If &amp;lsquo;a&amp;rsquo; isentered,then it jumps to case &amp;lsquo;a&amp;rsquo;. There&amp;rsquo;sno break, so it &amp;ldquo;fallsthrough&amp;rdquo; to the one right under it, case &amp;lsquo;A&amp;rsquo;, which has code and a break.&lt;/p&gt;

&lt;p&gt;• Finally, it runs this code, hitsthe break, and thenexits out of the switch-statement entirely. This is adeep dive into how the switch-statement works, butin practice you just have to remembera few simple rules:&lt;/p&gt;

&lt;p&gt;• Always includea default: branchso thatyou catch any missing inputs.&lt;/p&gt;

&lt;p&gt;• Don&amp;rsquo;t allow fall through unless you really want it. It&amp;rsquo;salso a good idea to add a //fall through comment so people know it&amp;rsquo;s on purpose.&lt;/p&gt;

&lt;p&gt;• Always writethe case and the break before you write the code that goes init.&lt;/p&gt;

&lt;p&gt;• Try to use if-statements instead if you can.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an exampleof me playing with this, and also demonstrating various ways to pass in the argument:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 10 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ make ex1. cc -Wall -gex10.c ­ o ex1.
$ ./ex10
ERROR: You need one argument. 
$ 
$ ./ex10 Zed 
0: Z is not a vowel 
1: &#39;E&#39; 
2: d is not a vowel 
$ 
$ ./ex10 Zed Shaw 
ERROR: You need one argument. 
$ 
$ ./ex10 &amp;quot;Zed Shaw&amp;quot; 

0: Z is not a vowel 
1: &#39;E&#39; 
2: d is not a vowel 
3: is not a vowel 
4: S is not a vowel 
5: h is not a vowel 
6: &#39;A&#39; 
7: w is not a vowel 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that there&amp;rsquo;s an if-statement at the top thatexits with a return 1; when you don&amp;rsquo;tprovide enougharguments. Areturn that&amp;rsquo;s not0 indicates to the OSthat theprogram hadan error. You can testforany valuethat&amp;rsquo;sgreater than 0 in scripts and otherprograms to figure outwhat happened.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s incredibly easy to break a switch-statement.Here are just a few ways you can mess oneof theseup:&lt;/p&gt;

&lt;p&gt;• Forget a break, and it&amp;rsquo;ll run two ormore blocks ofcode you don&amp;rsquo;twant itto run.&lt;/p&gt;

&lt;p&gt;• Forget a default, and it&amp;rsquo;ll silentlyignore valuesyou forgot.&lt;/p&gt;

&lt;p&gt;• Accidentallyput a variableinto the switch thatevaluates to something unexpected,like an int,whichbecomes weird values.&lt;/p&gt;

&lt;p&gt;• Use uninitialized values in the switch.&lt;/p&gt;

&lt;p&gt;You can also break this programin a few otherways. See if you can bustit yourself.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Write another program thatuses math on the letter to convert it to lowercase, and then remove all of the extraneous uppercase letters in theswitch.&lt;/p&gt;

&lt;p&gt;• Use the &amp;lsquo;,&amp;rsquo; (comma) to initialize letter in the for-loop.&lt;/p&gt;

&lt;p&gt;• Makeit handle all of the argumentsyou pass it with yetanother for-loop.&lt;/p&gt;

&lt;p&gt;• Convert this switch-statement toan if-statement. Which do you like better?&lt;/p&gt;

&lt;p&gt;• In the case for &amp;lsquo;Y&amp;rsquo; I have the break outside of the if-statement. What&amp;rsquo;s the impactof this, and whathappens if you move it inside of the if-statement. Proveto yourself that you&amp;rsquo;re right.&lt;/p&gt;

&lt;h2 id=&#34;exercise11-arrays-and-strings:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise11. Arrays and Strings&lt;/h2&gt;

&lt;p&gt;This exerciseshows you that C stores itsstrings simply as an array of bytes, terminated with the &amp;lsquo;\0&amp;rsquo; (nul) byte. You probably clued in to this in thelast exercisesince we didit manually. Here&amp;rsquo;show we do itin another way to makeit even clearerby comparingit to an arrayof numbers:&lt;/p&gt;

&lt;p&gt;ex11.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt;
2 
3 int main(int argc, char *argv[]) 
4 {
5 int numbers[4] = { 0 }; 
6 char name[4] ={ &#39;a&#39; }; 
7 
8 // first, 
print them out raw 
9 printf(&amp;quot;numbe %d %d %d %d\n&amp;quot;,
10 numbe numbers[1], numbers[2], numbers[3]); 
11 
12 printf(&amp;quot;name each: %c %c %c %c\n&amp;quot;, 
13 name[0], name[1], name[2], name[3]); 
14 
15 printf(&amp;quot;name: %s\n&amp;quot;,
16  name);  
17  //  set  up the  numbers  
18 1;
19 2;
20 3;
21 4;  numbers[0] numbers[1] numbers[2] numbers[3]  = = = =  
22 
23 // set up the name 
24 name[0] = &#39;Z&#39;;
25 name[1] = &#39;e&#39;;
26 name[2] = &#39;d&#39;;
27 name[3] = &#39;\0&#39;;
28 
29 // then print them out initialized 
30 printf(&amp;quot;numbe %d %d %d %d\n&amp;quot;, 
31 numbe numbers[1], numbers[2], numbers[3]); 
32 
33 printf(&amp;quot;name each: %c %c %c %c\n&amp;quot;,
34 name[name[1], name[2], name[3]);
35 
36 // print the name like a string 
37 printf(&amp;quot;name: %s\n&amp;quot;, name); 
38 
39 // another way to use name 
40 char *another = &amp;quot;Zed&amp;quot;;
41 
42 printf(&amp;quot;anoth %s\n&amp;quot;, another); 
43 
44 printf(&amp;quot;anoth each: %c %c %c %c\n&amp;quot;,
45 anoth another[1], another[2], another[3]); 
46 
47 return 0;
48 } 

In this code, we set upsome arrays the tediousway, by assigninga value to each element. In numbers, weare setting upnumbers; butin name,we&#39;re actually building a string manually. 


What You Should See 

When yourunthis code, you should firstsee the errays printed with their contents initialized to 0 (zero), thenin its initialized form. 


* Exercise 11 Session 


```bash

$ make ex1. cc -Wall ­g ex11.c -o ex1.
$ ./ex11
numbers: 0 0 0 0 
name each: a 
name: a 
numbers: 1 2 3 4 
name each: Z e d 
name: Zed 
another: Zed 
another each: Z e d 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll notice some interesting thingsabout this program:&lt;/p&gt;

&lt;p&gt;• I didn&amp;rsquo;t have to give all four elementsof the arrays to initialize them. This isashortcut in C. If youset just one element, it&amp;rsquo;ll fill in the rest with 0.&lt;/p&gt;

&lt;p&gt;• When each element of numbers is printed, theyall comeout as 0.&lt;/p&gt;

&lt;p&gt;• When each element of name isprinted, only the firstelement &amp;lsquo;a&amp;rsquo; showsup becausethe &amp;lsquo;\0&amp;rsquo; character is specialand won&amp;rsquo;t display.&lt;/p&gt;

&lt;p&gt;• Then the first time we print name, it only prints thelettera. This isbecause the erraywill be filled with 0afterthe first &amp;lsquo;a&amp;rsquo; in the initializer, sothe string iscorrectly terminated by a &amp;lsquo;\0&amp;rsquo; character.&lt;/p&gt;

&lt;p&gt;• We then set up the arrays with atedious, manual assignment to each thing and print them out again. Look at how theychanged. Now the numbers areset, but do you see how the name string printsmy namecorrectly?&lt;/p&gt;

&lt;p&gt;• there are also two syntaxes for doinga string: char name[4] = {&amp;lsquo;a&amp;rsquo;}on line 6 versus char *another = &amp;ldquo;name&amp;rdquo; online 44. Thefirst one is less common andthe second iswhat you should use for string literalslike this.&lt;/p&gt;

&lt;p&gt;Notice thatI&amp;rsquo;m using the same syntax andstyle of code to interactwithboth an array ofintegers andan array of characters, but printf thinks that the name is just a string. Again, this is because the C languagedoesn&amp;rsquo;t differentiate between a string and an array of characters.&lt;/p&gt;

&lt;p&gt;Finally,when you make string literalsyou should typically use the char *another = &amp;ldquo;Literal&amp;rdquo; syntax. Thisworks outto be the samething, butit&amp;rsquo;s more idiomatic andeasier to write.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;The sourceof almostallbugs in C come fromforgetting to haveenough space, or forgetting to put a &amp;lsquo;\0&amp;rsquo; at the end of a string. In fact, it&amp;rsquo;s so common andhardto get right that themajority ofgood C code just doesn&amp;rsquo;t use C­stylestrings. In later exercises, we&amp;rsquo;llactually learn how to avoid C strings completely.&lt;/p&gt;

&lt;p&gt;In this program, thekey to breaking it is to forget toput the &amp;lsquo;\0&amp;rsquo; characterat the end of the strings. There area few ways todo this:&lt;/p&gt;

&lt;p&gt;• Get rid of the initializers thatsetup name.&lt;/p&gt;

&lt;p&gt;• Accidentallyset name[3] = &amp;lsquo;A&amp;rsquo;; so that there&amp;rsquo;s no terminator.&lt;/p&gt;

&lt;p&gt;• Set the initializer to {&amp;lsquo;a&amp;rsquo;,&amp;lsquo;a&amp;rsquo;,&amp;lsquo;a&amp;rsquo;,&amp;lsquo;a&amp;rsquo;} so that there are too many &amp;lsquo;a&amp;rsquo; characters and no space for the &amp;lsquo;\0&amp;rsquo; terminator.&lt;/p&gt;

&lt;p&gt;Try to come up with some other waysto break this, and run all of these underthe debugger so you can see exactly what&amp;rsquo;s going on and what the errorsare called. Sometimes you&amp;rsquo;ll make these mistakes andeven adebugger can&amp;rsquo;t find them. Try moving where you declare the variables to see if yo uget an error. This is part of the voodoo of C:Sometimes just where the variable is located changes the bug.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Assign thecharacters into numbers, and then use printf to print themone character at atime. What kind of compiler warnings do you get?&lt;/p&gt;

&lt;p&gt;• Do the inverse for name,trying to treat it like an array of int and print it out one int at atime. What does the debugger thinkof that?&lt;/p&gt;

&lt;p&gt;• In howmany other ways can you print this out?&lt;/p&gt;

&lt;p&gt;• If an array of characters is4 byteslong, and an integer is 4 bytes long, thencan you treat the whole name array like it&amp;rsquo;sjust an integer? How mightyou accomplish this crazy hack?&lt;/p&gt;

&lt;p&gt;• Take out apiece of paper and draw each of these arrays as arowof boxes. Thendo the operations you just did on paper tosee if you get them right.&lt;/p&gt;

&lt;p&gt;• Convert name to bein the style of another and see it the code keeps working.&lt;/p&gt;

&lt;h2 id=&#34;exercise12-sizes-andarrays:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise12. Sizes andArrays&lt;/h2&gt;

&lt;p&gt;In the last exercise,you did math butwith, a &amp;lsquo;\0&amp;rsquo; (nul) character. This may seem odd if you&amp;rsquo;re coming from other languages, since they try to treat strings and byte arrays asdifferent beasts. C treats strings as just arrays of bytes, and it&amp;rsquo;s only thedifferent printing functionsthat recognizea difference. Before I canreallyexplain the significance of this, I have to introducea couplemore concepts: sizeof and arrays. Here&amp;rsquo;sthe codewe&amp;rsquo;ll be talkingabout:&lt;/p&gt;

&lt;p&gt;ex12.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt;
2 
3 int main(int argc, char *argv[]) 
4 {
5 int areas[] = { 10, 12, 13, 14,20 }; 
6 char name[] = &amp;quot;Zed&amp;quot;;
7 char full_name[] = {
8 &#39;Z&#39;,&#39;e&#39;, &#39;d&#39;,
9 &#39;&#39;,&#39;A&#39;, &#39;.&#39;, &#39;&#39;,
10 &#39;S&#39;, &#39;h&#39;, &#39;a&#39;, &#39;w&#39;, &#39;\0&#39; 
11 }; 
12 
13 // WARNING: On some systems you may have to change the 
14 // %ld in this code to a %u since it will use unsigned ints 
15 printf(&amp;quot;The size of an int: %ld\n&amp;quot;, sizeof(int)); 
16 printf(&amp;quot;The size of areas (int[]): %ld\n&amp;quot;,sizeof(areas)); 
17 printf(&amp;quot;The number of ints in areas: %ld\n&amp;quot;,
18 sizeo / sizeof(int)); 
19 printf(&amp;quot;The first area is %d, the 2nd %d.\n&amp;quot;, areas[0], areas[1]); 
20 
21 printf(&amp;quot;The size of a char: %ld\n&amp;quot;,sizeof(char)); 
22 printf(&amp;quot;The size of name (char[]): %ld\n&amp;quot;,sizeof(name)); 
23 printf(&amp;quot;The number of chars: %ld\n&amp;quot;, sizeof(name)/ sizeof(char)); 
24 25 printf(&amp;quot;The size of full_name (char[]): %ld\n&amp;quot;,sizeof(full_name)); 
26 printf(&amp;quot;The number of chars: %ld\n&amp;quot;,
27 sizeo / sizeof(char)); 
28
29 printf(&amp;quot;name= and full_name=\&amp;quot;%s\&amp;quot;\n&amp;quot;, name, full_name); 
30 
31 return 0;
32 } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this code, we create a few arrays with differentdata types in them. Because arrays ofdata are so central tohow C works, there are ahuge number of ways to create them. For now,just use the syntax type name[] = {initializer}; and we&amp;rsquo;ll exploremore later. What this syntax means is, &amp;ldquo;I wantan array oftype that is initialized to {..}.&amp;rdquo; When C sees this,it knows to:&lt;/p&gt;

&lt;p&gt;• Look at the type, and in this firstcase, it&amp;rsquo;s int.&lt;/p&gt;

&lt;p&gt;• Look at the [] and see that there&amp;rsquo;s no length given.&lt;/p&gt;

&lt;p&gt;• Look at the initializer {10, 12, 13, 14, 20} and figure out that you want those five integers in your array.&lt;/p&gt;

&lt;p&gt;• Create apiece of memory in the computer that can hold 5 integers one after another.&lt;/p&gt;

&lt;p&gt;• Take thename you want, areas, and assign it this location.&lt;/p&gt;

&lt;p&gt;In the case of areas, it&amp;rsquo;s creatingan array of five integers that contain those numbers. Whenit gets to char name[] = &amp;ldquo;Zed&amp;rdquo;; it&amp;rsquo;sdoing thesamething, exceptit&amp;rsquo;s creating an array ofthreecharactersand assigning that to name. The final array we make is full_name, butwe use the annoying syntax of spellingit outone characterata time.&lt;/p&gt;

&lt;p&gt;To C, name and full_name areidentical methodsof creating achar array.&lt;/p&gt;

&lt;p&gt;In the rest of the file,we&amp;rsquo;re using akeyword called sizeof to ask C how big things arein bytes. C is all about thesize and locationof pieces of memory, and what you do with them. To help you keep this straight, it gives you sizeof so thatyou can ask how bigsomething is
before you workwith it. This is where stuff gets tricky, so let&amp;rsquo;s run this code first andthen explainit later.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 12 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make ex1. cc -Wall ­g ex12.c -o ex1. 
$ ./ex12
The size of an int: 4
The size of areas (int[]): 20 
The number of ints in areas: 5 
The first area is 10, the 2nd 12. 
The size of a char: 1 
The size of name (char[]): 4 
The number of chars: 4 
The size of full_name 
(char[]): 1. 
The number of chars: 
1. name=&amp;quot;Zed&amp;quot; and 
full_name=&amp;quot;Zed A. 
Shaw&amp;quot; 

$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now yousee the outputof these different printf calls and start to get aglimpse of what C is doing. Your output could actually betotally differentfrom mine, since your computer might have differentsize integers. I&amp;rsquo;ll go
through my output:&lt;/p&gt;

&lt;p&gt;5 My computer thinksan int is4bytes insize. Your computer might use adifferent size if it&amp;rsquo;sa 32-bit versus 64­bit CPU.
6 The areas arrayhas five integers init, so it makessensethat my computer requires 20 bytesto storeit.
7 If we divide the size of areas by the sizeof an int,then weget fiveelements. Looking at the code, this matches whatweputin the initializer.
8 Wethen did an array access to get areas[0] and areas[1], which means C is zero indexed likePythonand Ruby.
9-11 We repeat this for the name array, but do you notice something odd about the size of the array? It saysit&amp;rsquo;s 4 byteslong, but we only typed &amp;ldquo;Zed&amp;rdquo; for three characters. Where&amp;rsquo;s the fourth onecoming from?
12-13 We do the same thing with full_name, and now notice it gets this correct.
13 Finally, we just print out the name and full_name toprove that they actuallyare &amp;ldquo;strings&amp;rdquo; according to printf.&lt;/p&gt;

&lt;p&gt;Make sure you can go through and seehow these outputlines match what was created. We&amp;rsquo;llbe building on this, andexploring more about arrays andstorage next.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;Breaking this program is fairlyeasy. Try some of these:&lt;/p&gt;

&lt;p&gt;• Get rid of the &amp;lsquo;\0&amp;rsquo; at the endof full_name and rerun it. Runit under thedebugger too. Now,movethe definitionof full_name to the top of main before areas.&lt;/p&gt;

&lt;p&gt;Try running it under the debugger a fewtimes and see if you get some new errors. In somecases,youmight stillget lucky andnot catch any errors.&lt;/p&gt;

&lt;p&gt;• Change itsothat instead of areas[0]you try to print areas[10]. See what the debuggerthinksof that.&lt;/p&gt;

&lt;p&gt;• Tryother ways to break it like this, doingitto name and full_name, too.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Tryassigning to elements in the areas array with areas[0] = 100; andsimilar.&lt;/p&gt;

&lt;p&gt;• Tryassigning to elements of name and full_name.&lt;/p&gt;

&lt;p&gt;• Trysetting one element of areas to acharacter from name.&lt;/p&gt;

&lt;p&gt;• Searchonline for the differentsizes usedfor integers on different CPUs.&lt;/p&gt;

&lt;h2 id=&#34;exercise13-for-loops-and-arrays-of-strings:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise13. For-Loops and Arrays of Strings&lt;/h2&gt;

&lt;p&gt;You can make an array of varioustypes with theidea thata stringand an array of bytesare the samething. The nextstep is to doanarray that has strings init. We&amp;rsquo;llalso introduce yourfirst looping construct, the for-loop, to helpprint out this new data structure.&lt;/p&gt;

&lt;p&gt;The fun partof this isthat there&amp;rsquo;s beenan array of strings hiding in your programs for a while now:the char *argv[] in the main function arguments. Here&amp;rsquo;s codethat will printout any commandline arguments you passit:&lt;/p&gt;

&lt;p&gt;ex13.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt;
2 
3 int main(int argc, char *argv[]) 
4 {
5 if (argc != 2) {
6 printf(&amp;quot;E You need one argument.\n&amp;quot;); 
7 // this is how you abort a program 
8 return 1;
9 }
10 11 int i = 0;
12 for (i = 0; argv[1][i] != &#39;\0&#39;;i++) { 
13 char letter = argv[1][i]; 
14
15 switch (letter){ 
16 case &#39;a&#39;: 
17 case &#39;A&#39;: 
18 p&#39;A&#39;\n&amp;quot;, i); 
19 b 
20 
21 case &#39;e&#39;: 
22 case &#39;E&#39;: 
23 p&#39;E&#39;\n&amp;quot;, i); 
24 b
25  
26  case &#39;i&#39;:  
27  case &#39;I&#39;:  
28 &#39;I&#39;\n&amp;quot;,
29  i);  p b  
30  
31  case &#39;o&#39;:  
32  case &#39;O&#39;:  
33 &#39;O&#39;\n&amp;quot;,  i);  p
34 b 
35 
36 case &#39;u&#39;: 
37 case &#39;U&#39;: 
38 p&#39;U&#39;\n&amp;quot;, i); 
39 b 
40 
41 case &#39;y&#39;: 
42 case &#39;Y&#39;: 
43 (i &amp;gt; 2) { 
44 it&#39;s only sometimes Y 
45 &#39;Y&#39;\n&amp;quot;, i); 
46 }
47 b 
48 
49 defau 
50 p%c is not a vowel\n&amp;quot;,i, letter);
51 } 
52 }
53 
54 return 0;
55 
} 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The format of a for-loop is this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
for(INITIALIZER;TEST; INCREMENTER) {
    CODE; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s how the for-loop works:&lt;/p&gt;

&lt;p&gt;• The INITIALIZER is code that&amp;rsquo;s run to setup the loop, which in this caseis i=0.&lt;/p&gt;

&lt;p&gt;• Next,the TEST Boolean expression is checked. If it&amp;rsquo;s false (0),then CODE is skipped, doing nothing.&lt;/p&gt;

&lt;p&gt;• The CODE runs and does whatever it does.&lt;/p&gt;

&lt;p&gt;• Afterthe CODE runs, the INCREMENTER partisrun, usually incrementing something, such as in i++.&lt;/p&gt;

&lt;p&gt;• And it continues again with step 2 untilthe TEST isfalse (0).&lt;/p&gt;

&lt;p&gt;This for-loop is going through thecommand line arguments using argc and argv like this:&lt;/p&gt;

&lt;p&gt;• The OS passeseach command lineargument asa stringin the argv array. Theprogram&amp;rsquo;s name(./ex10)is at 0, with the restcoming after it.&lt;/p&gt;

&lt;p&gt;• The OS also sets argc to thenumberof arguments in the argv array,soyou can processthem without going past the end. Remember thatif you giveone argument, the program&amp;rsquo;s nameis the first,so argc is2.&lt;/p&gt;

&lt;p&gt;• The for-loop sets up with i=1 in the initializer.&lt;/p&gt;

&lt;p&gt;• It then tests that i is lessthan argc with the test i &amp;lt; argc. Since $1 &amp;lt; 2$, it&amp;rsquo;ll pass.&lt;/p&gt;

&lt;p&gt;• It then runs the code thatjust prints out the i and uses i to indexinto argv.&lt;/p&gt;

&lt;p&gt;• The incrementer is then run using the i++ syntax,which is ahandy wayof writing i =i+1.&lt;/p&gt;

&lt;p&gt;• This then repeats until i &amp;lt; argc is finally false (0), theloopexits, and theprogram continueson.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;To playwith this program, then, you have to run it two ways. The first wayis topass in some command line arguments so that argc and argv get set.&lt;/p&gt;

&lt;p&gt;Thesecondis to run itwithno arguments so you can see that the first for-loop doesn&amp;rsquo;t run if i &amp;lt; argc is false.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 13 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ make ex1. cc -Wall ­g ex13.c -o ex1. 
$ ./ex13 i am a bunch of arguments
arg 1: i 
arg 2: am 
arg 3: a 
arg 4: bunch 
arg 5: of 
arg 6: arguments 
state 0: California 
state 1: Oregon 
state 2: Washington state 3: Texas
$ 
$ ./ex13

state 0: California 
state 1: Oregon 
state 2: Washington 
state 3: Texas 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Understanding Arrays of Strings&lt;/p&gt;

&lt;p&gt;In C you make an array of strings by combining the char *str = &amp;ldquo;blah&amp;rdquo; syntax with the char str[] = {&amp;lsquo;b&amp;rsquo;,&amp;lsquo;l&amp;rsquo;,&amp;lsquo;a&amp;rsquo;,&amp;lsquo;h&amp;rsquo;} syntax to construct a two­dimensionalarray. The syntax char *states[] = {&amp;hellip;} online 14isthis two-dimensional combination,each string being oneelement, and each character in the stringbeing another. Confusing?The conceptof multiple dimensions is something most people never think about, so what you should do isbuild thisarray ofstrings on paper:&lt;/p&gt;

&lt;p&gt;• Makea gridwith the index ofeach string on the left.&lt;/p&gt;

&lt;p&gt;• Thenput theindex of each character on the top.&lt;/p&gt;

&lt;p&gt;• Thenfillin the squares in themiddle with what single character goesin each square.&lt;/p&gt;

&lt;p&gt;• Once youhave thegrid, trace through the code using this grid of paper.&lt;/p&gt;

&lt;p&gt;Another way to figurethis is outis to build thesame structure in a programming languageyou are more familiar with, likePythonor Ruby.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;• Take yourfavorite other languageand use it to run this program, butinclude asmany command line arguments aspossible. See ifyou canbustit by givingit way too many arguments.&lt;/p&gt;

&lt;p&gt;• Initialize i to 0 and see what that does. Do you have toadjust argc as well, or does itjust work? Why does0­based indexing work here?&lt;/p&gt;

&lt;p&gt;• Set num_states wrongsothat it&amp;rsquo;s a highervalue and see whatit does.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Figure out whatkind of code you can put into the parts ofa for-loop.&lt;/p&gt;

&lt;p&gt;• Look up how tousethe comma character(,) to separatemultiple statements in the parts of the for-loop, but between thesemicolon characters (;).&lt;/p&gt;

&lt;p&gt;• Readaboutwhata NULL isand try to use it in one of the elements fromthe states array to see whatit&amp;rsquo;ll print.&lt;/p&gt;

&lt;p&gt;• Seeif you can assignan element from the states array to the argv array before printing both. Try the inverse.&lt;/p&gt;

&lt;h2 id=&#34;exercise14-writing-and-using-functions:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise14. Writing and Using Functions&lt;/h2&gt;

&lt;p&gt;Up untilnow, we&amp;rsquo;ve just used functions that are part of the stdio.h header file. In this exercise, you&amp;rsquo;ll writesome functions andusesome other functions.&lt;/p&gt;

&lt;p&gt;ex14.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 
2 #include &amp;lt;ctype.h&amp;gt; 

3 
4 // forward declarations 
5 int can_print_it(char ch);
6 void print_letters(char arg[]); 
7 
8 void 
print_arguments(int argc, char *argv[]) 
9 {
10 int i = 0;
11 
12 for (i = 0;i &amp;lt; argc; i++) { 
13 print_let 
1. }

1. }16 17 void print_letters(char 

arg[]) 
18 {
19 int i = 0;
20 
21 for (i = 0; arg[i] != &#39;\0&#39;; i++) {
22 char ch = arg[i]; 
23 
24 if (can_print_it(ch)) { 
25 print == %d &amp;quot;, ch, ch); 
26 } 
27 }
28  
29 printf(&amp;quot;\n&amp;quot;);
30 }
31 
32 int 
can_print_it(char ch)
33 {
34 return isalpha(ch) || isblank(ch);
35 }
36 
37 int main(int 
argc, char *argv[]) 
38 {
39 print_argumen argv); 
40 return 0;
41 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this examplewe&amp;rsquo;re creating functionsto printout the charactersand ASCII codes forany thatare alpha or blanks. Here&amp;rsquo;s the breakdown:&lt;/p&gt;

&lt;p&gt;ex14.c:2 Include a new header file, so wecan gainaccess to isalpha and isblank.&lt;/p&gt;

&lt;p&gt;ex14.c:5-6 Tell C that you&amp;rsquo;ll be using some functions later in your programwithout actually having to define them. This is aforward declaration and itsolves the chicken-and-egg problem of needing to use afunction before you&amp;rsquo;vedefined it.&lt;/p&gt;

&lt;p&gt;ex14.c:8-15 Define the print_arguments function, which knows how to print the same array ofstrings that main typically gets.&lt;/p&gt;

&lt;p&gt;ex14.c:17-30 Definethe nextfunction, print_letters, which is calledby print_arguments and knows how to print each of the characters and theircodes.&lt;/p&gt;

&lt;p&gt;ex14.c:32-35 Define can_print_it, which simplyreturns the truth value(0 or1) of isalpha(ch) ||isblank(ch) back to its caller, print_letters.&lt;/p&gt;

&lt;p&gt;ex14.c:38-42 Finally, main simply calls print_arguments to make the whole chainof functionsgo. I shouldn&amp;rsquo;thave todescribe what&amp;rsquo;s in each function, because they&amp;rsquo;re allthings you&amp;rsquo;verunintobefore. What you should be ableto see, though,is that I&amp;rsquo;ve simply definedfunctions the same way you&amp;rsquo;ve beendefining main.Theonlydifference is you have tohelp C out by tellingitahead of timeif you&amp;rsquo;re going tousefunctions it hasn&amp;rsquo;t encountered yet in the file. That&amp;rsquo;s what the forward declarationsdo.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;To playwith this program, you just feed it different command line arguments, which getpassedthrough your functions. Here&amp;rsquo;s me playing with it to demonstrate:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 14 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ make ex1. cc -Wall ­g ex14.c -o ex1. 
$ ./ex14
&#39;e&#39; == 101 &#39;x&#39; == 12. 
$ ./ex14 hi this is cool 
&#39;e&#39; == 101 &#39;x&#39; == 120 &#39;h&#39; == 104 &#39;i&#39; == 105 &#39;t&#39; == 116 &#39;h&#39; == 104 &#39;i&#39; == 105 &#39;s&#39; == 115 &#39;i&#39; == 105 &#39;s&#39; == 115 &#39;c&#39; == 99 &#39;o&#39; == 111 &#39;o&#39; == 111 &#39;l&#39; == 108 
$ ./ex14 &amp;quot;I go 3 spaces&amp;quot;
&#39;e&#39; == 101 &#39;x&#39; == 120 &#39;I&#39; == 73 &#39; &#39; == 32 &#39;g&#39; == 103 &#39;o&#39; == 111 &#39; &#39; == 32 &#39; &#39; == 32. &#39;s&#39; == 115 &#39;p&#39; == 112 &#39;a&#39; == 97 &#39;c&#39; == 99 &#39;e&#39; == 101 &#39;s&#39; == 115
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The isalpha and isblank doall the workof figuringoutif the given character is a letter ora blank. When I do the last run,it prints everything but the 3 character sincethat&amp;rsquo;sa digit.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;There are two different kinds
of breakingin this program:&lt;/p&gt;

&lt;p&gt;• Removethe forward declarations to confuse&lt;/p&gt;

&lt;p&gt;the compilerand cause it to complainabout can_print_it and print_letters.&lt;/p&gt;

&lt;p&gt;• When you call&lt;/p&gt;

&lt;p&gt;print_argumentsinside main,try adding 1 to argc so that it goes past the end of the argv array.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Rework these functions so thatyou have fewer functions. For example, do you really need can_print_it?&lt;/p&gt;

&lt;p&gt;• Have&lt;/p&gt;

&lt;p&gt;print_arguments
figure outhow long each argumentstringis by using the strlen function, and then pass that length to print_letters. Then, rewrite print_letters soit only processesthis fixed lengthand doesn&amp;rsquo;t relyon the &amp;lsquo;\0&amp;rsquo; terminator. You&amp;rsquo;llneed the #include &lt;string.h&gt; forthis.
• Use man tolookup informationon isalpha and isblank. Use other&lt;/p&gt;

&lt;p&gt;similar functionsto printout only digits or other characters.&lt;/p&gt;

&lt;p&gt;• Goread abouthow other people like to format their functions. Never use the K&amp;amp;R syntax (it&amp;rsquo;s antiquated and confusing) but understand what it&amp;rsquo;s doing in case you run into someone who likes it.&lt;/p&gt;

&lt;h2 id=&#34;exercise15-pointers-dreaded-pointers:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise15. Pointers, Dreaded Pointers&lt;/h2&gt;

&lt;p&gt;Pointers are famous mystical creatures in C. I&amp;rsquo;llattempt to demystify them by teaching you the vocabularyto deal with them. They actually aren&amp;rsquo;t that complex, but they&amp;rsquo;refrequentlyabused in weird waysthat make them hard to use. If you avoidthe stupid waysto use pointers, then they&amp;rsquo;refairly easy.&lt;/p&gt;

&lt;p&gt;To demonstrate pointers in a way that we can talk about them,I&amp;rsquo;ve writtena frivolous programthat printsa group of people&amp;rsquo;s agesin three differentways.&lt;/p&gt;

&lt;p&gt;ex15.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 
2 
3 int main(int argc, char *argv[]) 
4 {
5 // create two arrays we care about 
6 int ages[] = { 23, 43, 12, 89, 2 }; 
7 char *names[] = {8 &amp;quot;Alan&amp;quot;,&amp;quot;Frank&amp;quot;,
9 &amp;quot;Mary&amp;quot;,&amp;quot;John&amp;quot;, &amp;quot;Lisa&amp;quot; 
10 }; 
11 
12 // safely get the size of ages 
13 int count = 
sizeof(ages)/
sizeof(int); 
14 int i = 0;
1. 16 // first way using indexing 
17 for (i = 0;i &amp;lt; count; i++) { 
18 printf(&amp;quot;% has %d yearsalive.\n&amp;quot;, names[i], ages[i]); 
19 
20  }  
21 \n&amp;quot;); 
22  printf(&amp;quot;--­ 
23  // set up the pointers to the start of the arrays 
24 int *cur_age = ages; 
25 char **cur_name = names;
26 
27 // second way using pointers 
28 for (i = 0;i &amp;lt; count; i++) { 
29 printf(&amp;quot;% is %d years old.\n&amp;quot;,
30 * (cur_name + i), * (cur_age + i)); 
31 }
32 
33 printf(&amp;quot;--­\n&amp;quot;); 
34 
35 // third way, pointers are just arrays 
36 for (i = 0;i &amp;lt; count; i++) { 
37 printf(&amp;quot;% is %d years old again.\n&amp;quot;, cur_name[i], cur_age[i]); 
38 }39 40 printf(&amp;quot;--­\n&amp;quot;); 
41 
42 // fourth way with pointers in a stupid complex way 
43 for (cur_name = names, cur_age = ages;
44 (cur_ -ages)&amp;lt; count; cur_name++, cur_age++) { 
45 printf(&amp;quot;% lived %d years so far.\n&amp;quot;,*cur_name,*cur_age); 
46 }
47 
48 return 0;
49 }


Before explaining how pointers work, let&#39;sbreak this programdown line by lineso you get an ideaof what&#39;s going on. Asyougo through this detaileddescription, try to answer thequestions for yourself ona pieceof paper, thensee if what you guessed matches mydescription of pointerslater. 

ex15.c:6-10 Createtwo arrays: ages storing some int data, and names storingan array ofstrings. 

ex15.c:12-13 These are somevariables for our for-loops later. 

ex15.c:16-19 This is just looping throughthe two arrays and printing how old each person is. This isusing i to index into 
the array. 

ex15.c:24 Createa pointer thatpoints at ages. Notice the use of int * to createa pointer to integer type of pointer. That&#39;s similar to char *, whichis a pointer to char, andastring isan array ofchars. Seeing the similarityyet?

ex15.c:25 Createa pointer thatpoints at names.A char * is already a pointer to char,sothat&#39;s just a string. However, you need two levels since names is two-dimensional, which thenmeans you need char ** for a pointer to (apointer tochar) type. Study thatand try to explainit to yourself, too. 

ex15.c:28-31 Loop through ages and names butusethe pointers plus an offset of i instead. Writing * (cur_name+i) is the same aswriting name[i], and you readitas &amp;quot;thevalueof (pointer cur_name plusi).&amp;quot;

ex15.c:35-39 This shows how the syntax to access anelement of an array is the same fora

pointer and an array. 


ex15.c:44-50 This is another admittedly insaneloopthat does the samething asthe other two, butinstead it uses various pointer arithmetic methods: 

ex15.c:44 Initializeour for-loop by setting cur_name and cur_age to the beginning of the names and ages arrays. 

ex15.c:45 Thetest portion of the for-loop then compares the distance of the pointer cur_agefromthe startof ages. Why doesthat work? 

ex15.c:46 The increment partof the 
for-loop then increments both cur_name and cur_age so that they point at the next element of the name and age arrays. 

ex15.c:48-49 The pointers cur_name and cur_age are nowpointing at one element of the arrays that they workon, and we can print themoutusing just *cur_name and *cur_age,which means &amp;quot;thevalueof wherever cur_name is pointing.&amp;quot; 

This seemingly simple programhas a large amount ofinformation, andmy goal is to getyou toattempt to figurepointersout for 
yourself beforeIexplain them. Don&#39;t continue until you&#39;ve written down what you think a pointer does. 


What You Should See 

After you run this program, try to traceback each line printed outto the line in the codethat produced it. If you have to,alter the printf calls to make sureyou&#39;vegot the right linenumber. 


* Exercise 15 Session 


```bash
$ make ex1. cc -Wall ­g ex15.c -o ex1.
$ ./ex15
Alan has 23 years 
alive. 
Frank has 43 years 
alive. 
Mary has 12 years 
alive. 
John has 89 years 
alive. 
Lis ahas 2 years 
alive. 

Alan is 23 years old. 
Frank is 43 years 
old. 
Mary is 12 years old. 
John is 89 years old. 
Lis ais 2 years old. 

Alan is 23 years old 
again. 
Frank is 43 years old 
again. 
Mary is 12 years old 
again. 
John is 89 years old 
again. 
Lis ais 2 years old 
again. 

Alan lived 23 years 
so far. 
Frank lived 43 years 
so far. 
Mary lived 12 years 
so far. 
John lived 89 years 
so far. 
Lis alived 2 years so 
far. 

$ 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Explaining Pointers&lt;/p&gt;

&lt;p&gt;When you typesomething like ages[i],you&amp;rsquo;re indexing into the array ages, and you&amp;rsquo;re using thenumber that&amp;rsquo;s heldin i to do it. If i is set to zero thenit&amp;rsquo;s thesame astyping ages[0]. We&amp;rsquo;ve been calling this number i an index since it&amp;rsquo;sa location inside ages thatwewant. It could also becalled an address, whichis a wayof saying &amp;ldquo;I want the integer in ages that&amp;rsquo;s at address i.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;If i is an index, then what&amp;rsquo;s ages? To C, ages is a locationin the computer&amp;rsquo;s memory where allof these integers start. It&amp;rsquo;s also an address, and the C compiler will replace ages anywhere you typeit with the address of the very first integerin ages. Anotherway to think of ages is that it&amp;rsquo;s the &amp;ldquo;address of the first integerin ages.&amp;rdquo; Buthere&amp;rsquo;s the trick: ages is an address insidethe entire computer. It&amp;rsquo;s notlike i that&amp;rsquo;s just anaddress inside ages.The ages arrayname is actually an address in the computer.
That leads toa certain realization: C thinks your whole computer is one massive array of bytes. Obviously, this isn&amp;rsquo;tvery useful, but then what C does is layeron top ofthis massive array of bytes theconcept of types and sizes of thosetypes. You already saw how this workedin previous exercises, butnow you start to get an idea of how C isdoing the following with your arrays:
• Creating ablock of memory inside your computer&lt;/p&gt;

&lt;p&gt;• Pointing the name ages at the beginning ofthat block&lt;/p&gt;

&lt;p&gt;• Indexing into theblock by taking the base addressof ages and getting the element that&amp;rsquo;s i away from there&lt;/p&gt;

&lt;p&gt;• Converting thataddress at ages+i into avalid int of the right size, such that the index works toreturn what you want: the int at index i&lt;/p&gt;

&lt;p&gt;If you cantake abase address, like ages, and add to itwith another address like i to produce anew address, thencan youjust make something that points rightat this location all the time? Yes, and that thing is calleda pointer. This is what the pointers cur_age and cur_name aredoing: They are variablespointing at the location where ages and names livein your computer&amp;rsquo;smemory. The example program is then moving them around or doing math on them to get values outof the memory.&lt;/p&gt;

&lt;p&gt;In one instance,they just add i to cur_age, which is the same aswhat theprogram does with array[i]. In the last for-loop, though,these two pointers ar ebeing moved on theirown, without i to helpout. Inthat loop, the pointersare treated likea combination ofarray and integeroffsetrolled into one.&lt;/p&gt;

&lt;p&gt;A pointer is simply an addresspointing somewhere inside the computer&amp;rsquo;s memory with a typespecifier so thatyou get the rightsize ofdata with it. It&amp;rsquo;skind of likea combination of ages and i rolledintoone data type. C knows where pointers are pointing, knowsthe data typethey point at,the sizeof thosetypes, and how toget the datafor you. Justlike with i, you can increment, decrement,subtract,or add to them. But, just like ages, you can also getvalues out, putnew values in, and use all of the array operations.&lt;/p&gt;

&lt;p&gt;The purpose of a pointeris to let you manually index data into blocks ormemory when an array won&amp;rsquo;t do itright. In almost all othercases, you actually want to use an array. But, there are times when you have to work with a raw block of memory andthat&amp;rsquo;s where apointercomes in. A pointer gives you raw,direct access to ablockof memory so you can work with it.&lt;/p&gt;

&lt;p&gt;The final thing tograspat this stage is thatyou canuse either syntax for most array orpointeroperations. You can takea pointer to something, butusethe array syntax to access it. You can take an arrayand dopointer arithmetic with it.&lt;/p&gt;

&lt;p&gt;Practical Pointer Usage&lt;/p&gt;

&lt;p&gt;There areprimarilyfour useful things you can do with pointersin C code:&lt;/p&gt;

&lt;p&gt;• Askthe OSfor a chunk of memory and use a pointer to workwith it. This includes strings and something you haven&amp;rsquo;tseenyet, structs.&lt;/p&gt;

&lt;p&gt;• Pass large blocks of memory (like large structs) tofunctions with apointer, so you don&amp;rsquo;thave to pass the whole thing to them.&lt;/p&gt;

&lt;p&gt;• Take the eddress of a function, so you can use it asa dynamic callback.&lt;/p&gt;

&lt;p&gt;• Scan complex chunks of memory,converting bytesoffof a network socketintodata structuresor parsing files.&lt;/p&gt;

&lt;p&gt;For nearlyeverything else, you mightsee people use pointerswhen they should be using arrays. In the earlydays of Cprogramming, people used pointers tospeed up their programs, becausethe compilers werereally bad at optimizing array usage. These days, the syntax to access an array versus apointerare translatedinto the same machine code and optimized in thesame way, so it&amp;rsquo;snotas necessary. Instead, you should go with arrays whenever you can, and then only use pointers asa
performance optimization if you absolutely have to.&lt;/p&gt;

&lt;p&gt;The Pointer Lexicon&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m now going to give you a little lexicon tousefor readingand writing pointers. Whenever yourunintoa complexpointerstatement, just referto thisand break it down bit by bit (or just don&amp;rsquo;t use it since it&amp;rsquo;s probablynot good code.)&lt;/p&gt;

&lt;p&gt;type *ptr Apointerof typenamed ptr
*ptr The valueof whateverptris pointed at
*(ptr + i) The value of(whateverptris pointedatplus i)
&amp;amp;thing The address of thing
type *ptr = &amp;amp;thing A pointer of
typenamed ptrsetto
the address ofthing
ptr++ Incrementwhere&lt;/p&gt;

&lt;p&gt;ptrpoints We&amp;rsquo;ll be using thissimple lexicon to breakdown all of the pointers we use from now on in the book.&lt;/p&gt;

&lt;p&gt;Pointers Aren&amp;rsquo;t Arrays&lt;/p&gt;

&lt;p&gt;No matter what, you should never think that pointers and arrays are thesame thing. They aren&amp;rsquo;t the same thing, even though C lets you work with them in many of the same ways. Forexample,if you do sizeof(cur_age)in the code above, you would get the size of the pointer,not the size of whatitpoints at. If you want the size of the full array, youhave tousethe array&amp;rsquo;sname, age,as I did on line 12. To do:Expandon thissome more with what doesn&amp;rsquo;twork the sameon pointers and arrays.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;You can break this program by simply pointing the pointersat the wrong things:
• Try to make cur_age
point at names. You&amp;rsquo;ll
need touse a C cast&lt;/p&gt;

&lt;p&gt;to force it, so go look thatup andtry tofigure it out.&lt;/p&gt;

&lt;p&gt;• In the final for-loop, try getting the math wrongin weird ways.&lt;/p&gt;

&lt;p&gt;• Tryrewriting theloops so that they start at the end of the arrays and go to thebeginning. This is harder than itlooks.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Rewriteallof the errays in this program as pointers.&lt;/p&gt;

&lt;p&gt;• Rewriteallof the
pointersas arrays.&lt;/p&gt;

&lt;p&gt;• Go back tosome of the other programsthat use arrays and try touse pointersinstead.&lt;/p&gt;

&lt;p&gt;• Process commandline
arguments using just&lt;/p&gt;

&lt;p&gt;pointers, similar to how you did names in this one.&lt;/p&gt;

&lt;p&gt;• Play with combinations ofgetting thevalue of and the eddressof things.&lt;/p&gt;

&lt;p&gt;• Add another for-loop at the endthat prints out the addresses that these pointersare using. You&amp;rsquo;llneed the %p format for printf.&lt;/p&gt;

&lt;p&gt;• Rewritethis programto use afunction for each of the ways you&amp;rsquo;re printing out things. Try to pass pointers to these functions so that they work on the data. Remember you can declare afunction to accept a pointer, but justuse itlike an array.&lt;/p&gt;

&lt;p&gt;• Change the for-loops to while­&lt;/p&gt;

&lt;p&gt;loops and see what
works better forwhich
kind ofpointerusage.&lt;/p&gt;

&lt;h2 id=&#34;exercise16-structs-and-pointersto-them:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise16. Structs And Pointersto Them&lt;/h2&gt;

&lt;p&gt;In this exercise,you&amp;rsquo;lllearn how to make a struct, point a pointer at it, and use it to make sense ofinternal memory structures. We&amp;rsquo;ll also apply theknowledge of pointersfromthe last exercise, and thenget you constructing these structures fromraw memoryusing malloc.&lt;/p&gt;

&lt;p&gt;As usual, here&amp;rsquo;s theprogram we&amp;rsquo;ll talkabout,sotype itin and make itwork.&lt;/p&gt;

&lt;p&gt;ex16.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

1 #include &amp;lt;stdio.h&amp;gt; 
2 #include &amp;lt;assert.h&amp;gt; 
3 #include &amp;lt;stdlib.h&amp;gt; 
4 #include &amp;lt;string.h&amp;gt; 
5  
6
7
8 
9 
10 
11 
12  struct Person {char *name;int age;int height;int weight;};  
13  struct Person *Person_create(char *name, int age, int height,
14 int weight)
15 {
16 struct Person *who = malloc(sizeof(struct Person)); 
17 assert(who != NULL); 
1. 
19 who-&amp;gt;name = strdup(name); 
20 who-&amp;gt;age = age; 
21 who-&amp;gt;height = height;
22 who-&amp;gt;weight = weight;
2. 
24 return who; 
2. }
26 
27 void Person_destroy(struct Person *who)
28 {
29 assert(who != NULL); 
30 
31 free(who­&amp;gt;name); 
32 free(who); 
33 
}
34 
35 void Person_print(struct Person *who) 
36 {
37 printf(&amp;quot;Name: %s\n&amp;quot;, who-&amp;gt;name); 
38 printf(&amp;quot;\tAge %d\n&amp;quot;, who-&amp;gt;age); 
39 printf(&amp;quot;\tHei %d\n&amp;quot;, who-&amp;gt;height); 
40 printf(&amp;quot;\tWei %d\n&amp;quot;, who-&amp;gt;weight); 
41 }
42 
43 int main(int argc, char *argv[]) 
44 {
45 // make two people structures 
46 struct Person *joe = Person_create(&amp;quot;Joe Alex&amp;quot;, 32, 64, 140); 
47

48 struct Person *frank = Person_create(&amp;quot;Frank Blank&amp;quot;, 20, 72, 180); 49 50 // print them out and where 
they are in memory 
51 printf(&amp;quot;Joe is at memory location %p:\n&amp;quot;, joe); 
52 Person_print(
53 
54 printf(&amp;quot;Frank is at memory location %p:\n&amp;quot;, frank); 
55 Person_print(
56 
57 // make everyone age 20 years and print them again 
58 joe-&amp;gt;age += 20;
59 joe-&amp;gt;height -= 2;60 joe-&amp;gt;weight += 40;
61 Person_print(
62 
63 frank-&amp;gt;age += 20;
64 frank­&amp;gt;weight += 20;
65 Person_print(
66 
67 // destroy them both so we clean up 
68 Person_destro 
69 Person_destro 
70 
71 return 0;
72 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To describe this program,I&amp;rsquo;m going to use adifferent approachthanbefore. I&amp;rsquo;m not going to give you a line-by­linebreakdown of the program, I&amp;rsquo;m going to make you writeit. I&amp;rsquo;m giving you a guide of the programbased on the partsit contains, and your job is write out what each linedoes. includes I include some new headerfiles hereto gainaccess tosome new functions.&lt;/p&gt;

&lt;p&gt;What does each give you? struct Person This is where I&amp;rsquo;m creating a structure that has four elements to describea person. Thefinal result isanew compoundtype that letsme reference these elements allas one or each pieceby name.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s similar to a row ofa database table ora class in an object-oriented programming (OOP) language. function Person_create I need a way to create these structures,soI&amp;rsquo;ve madea functionto do that. Here are the important things:&lt;/p&gt;

&lt;p&gt;• I use malloc for memory allocateto ask theOStogive me a piece of raw memory.&lt;/p&gt;

&lt;p&gt;• I pass to malloc the sizeof(structPerson), which calculates the total size of the structure, given allof the fields inside it.&lt;/p&gt;

&lt;p&gt;• I use assert to make surethat I have a valid pieceof memoryback from malloc. There&amp;rsquo;s a special constant called NULL that you use to mean &amp;ldquo;unsetor invalid pointer.&amp;rdquo; This assert is basically checking that malloc didn&amp;rsquo;treturn a NULL invalid pointer.&lt;/p&gt;

&lt;p&gt;• Iinitialize each field of struct Person using the x-&amp;gt;ysyntax, to say what part of the structure I want to set.&lt;/p&gt;

&lt;p&gt;• I usethe strdupfunctionto duplicate thestring for the name, just to make sure that this structure actuallyowns it. The strdup actuallyis like malloc, and it alsocopies the originalstring into the memoryit creates.&lt;/p&gt;

&lt;p&gt;function Person_destroy&lt;/p&gt;

&lt;p&gt;If I have a create function, thenI always need a destroyfunction, and this is whatdestroys Person structures. Iagain use assert to make sure I&amp;rsquo;m not gettingbad input. Then I usethe function free toreturn the memoryI gotwith malloc and strdup. If you don&amp;rsquo;t do this, you get a memory leak.&lt;/p&gt;

&lt;p&gt;function Person_print I thenneed a way toprint outpeople,whichisall this functiondoes. It uses the same x-&amp;gt;ysyntax to get the field fromthe structure to printit.
function main In the main function, I use all of the previous functions andthe struct Person to do the following:&lt;/p&gt;

&lt;p&gt;• Create twopeople, joe and frank.&lt;/p&gt;

&lt;p&gt;• Print them out, but notice I&amp;rsquo;musing the %p format so you can see where theprogram has actuallyput your structure in memory.&lt;/p&gt;

&lt;p&gt;• Age both of them by 20 years with changes the eeir bodies,too.&lt;/p&gt;

&lt;p&gt;• Print each oneafter aging them.&lt;/p&gt;

&lt;p&gt;• Finally, destroy the structures so we can cleanup correctly.&lt;/p&gt;

&lt;p&gt;Go through this description carefully, and do the following:&lt;/p&gt;

&lt;p&gt;• Look up every function and header file you don&amp;rsquo;tknow. Remember thatyou canusually do man 2 function or man 3 function, and it&amp;rsquo;lltell you about it. You can also search online for the information.&lt;/p&gt;

&lt;p&gt;• Write a comment above each andeverysingle linethat says what the   linedoes in English.&lt;/p&gt;

&lt;p&gt;• Trace througheach function calland variableso you know where it comes fromin the program.&lt;/p&gt;

&lt;p&gt;• Look up any symbols you don&amp;rsquo;tunderstand.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;After you augment the programwithyour description comments, make sureitreally runsand producesthis output:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 16 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ make ex1. cc -Wall ­g ex16.c -o ex1.
$ ./ex16
Joe is at memory location 0xeba010: 
Name: Joe Alex 
    Age: 32 
    Height: 64 
    Weight: 140 

Frank is at memory location 0xeba050: 
Name: Frank Blank 
    Age: 2. 
    Height: 72
    Weight: 180 

Name: Joe Alex 
    Age: 52 
    Height: 62 
    Weight: 180 
Name: Frank Blank 
    Age: 40 
    Height: 72 
    Weight: 200 


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Explaining structures&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;vedone thework, then structures should be making sense, but letme explain them explicitly just to make sureyou&amp;rsquo;ve understood it.&lt;/p&gt;

&lt;p&gt;A structure in C is a collection ofotherdata types (variables) that are stored in oneblockof memorywhere you can access eachvariable independently byname. They are similarto a record in a databasetable, ora very simplistic classin an OOP language. We can breakone down thi way:&lt;/p&gt;

&lt;p&gt;• In the above code, we make a struct that has fields for aperson: name, age, weight, and height.&lt;/p&gt;

&lt;p&gt;• Each ofthose fields has atype, like int.&lt;/p&gt;

&lt;p&gt;• C then packs those together so that they can all be contained in one single struct.&lt;/p&gt;

&lt;p&gt;• The struct Person is nowa compound data type, which means you can refer to struct Person using the samekindsof expressionsyou would for other datatypes.&lt;/p&gt;

&lt;p&gt;• This lets you pass the whole cohesive grouping to other functions, as you did with Person_print.&lt;/p&gt;

&lt;p&gt;• You can then accessthe individualparts of a struct by theirnames using x-&amp;gt;y if you&amp;rsquo;re dealing with a pointer.&lt;/p&gt;

&lt;p&gt;• There&amp;rsquo;s also a way to make a struct that doesn&amp;rsquo;tneed apointer, and you use the x.y (period)syntaxto work with it. We&amp;rsquo;ll do this in the Extra Credit section.&lt;/p&gt;

&lt;p&gt;If you didn&amp;rsquo;thave struct, you&amp;rsquo;dneed tofigure out the size,packing, and location of pieces of memory with contents like this. Infact, in most earlyAssemblercode (and even some now), this is what you would do. In C, you can let ithandlethe memory structuring of these compounddata typesand thenfocuson what you do with them.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;The ways inwhichto break this program involve howyou use the pointers andthe malloc system:&lt;/p&gt;

&lt;p&gt;• Trypassing NULL to Person_destroy  see what itdoes. If it doesn&amp;rsquo;tabort, then you must nothave the -g optionin your Makefile&amp;rsquo;s CFLAGS.
• Forget tocall Person_destroy at the end, and thenrunit under thedebugger to seeitreport that you forgot to free the memory. Figure out the optionsyou need to pass to thedebuggerto get itto print how you leakedthis memory.&lt;/p&gt;

&lt;p&gt;• Forget tofree who­&amp;gt;name in Person_destroy and compare the output. Again,usethe right optionsto seehow the debugger tellsyou exactly where you messed up.
• This time, pass NULL to Person_print and see what the debugger thinks of that. You&amp;rsquo;ll figure out that NULL isaquickway to crash your program.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;In this part of the exercise, I wantyou to attempt something difficult for the extra credit: Convert this programto not usepointers and malloc. This will be hard,soyou&amp;rsquo;llwant to research the following:&lt;/p&gt;

&lt;p&gt;• How tocreate a struct on the stack, just like you&amp;rsquo;re making any othervariable.&lt;/p&gt;

&lt;p&gt;• How toinitialize it using the x.y (period) character instead of the x-&amp;gt;y syntax.&lt;/p&gt;

&lt;p&gt;• How topass a structure to otherfunctions without using apointer.&lt;/p&gt;

&lt;h2 id=&#34;exercise17-heap-andstack-memory-allocation:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise17. Heap andStack Memory Allocation&lt;/h2&gt;

&lt;p&gt;In this exercise,you&amp;rsquo;regoing to make a bigleap in difficulty and create an entire smallprogram tomanage a database. This database isn&amp;rsquo;t very efficient and doesn&amp;rsquo;t storeverymuch, but itdoes demonstratemost of what you&amp;rsquo;velearned so far. It also introduces memoryallocation more formally, and gets you started working with files. We use somefileI/O functions, but I won&amp;rsquo;tbe explaining them too well so thatyou cantry to figure them outfirst.&lt;/p&gt;

&lt;p&gt;As usual, type this whole programin and getit working, then we&amp;rsquo;ll discuss it.&lt;/p&gt;

&lt;p&gt;ex17.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 
2 #include &amp;lt;assert.h&amp;gt; 
3 #include &amp;lt;stdlib.h&amp;gt; 
4 #include &amp;lt;errno.h&amp;gt; 
5 #include &amp;lt;string.h&amp;gt; 
6 
7 #define MAX_DATA 512 8 #define MAX_ROWS 100 
9 
10 struct Address {
11 int id;
12 int set;
13 char 
name[MAX_DATA]; 
14 char email[MAX_DATA]; 
15 }; 
1. 
17 struct 
Database {
18 struct Address rows[MAX_ROWS]; 
19 }; 
2. 21 struct Connection {
22 FILE *file;
23 struct Database *db;
24 }; 
2. 
26 void die(const char *message)
27 {
28 if (errno)
{
    
29 perror(
30 } else {
31 printf(%s\n&amp;quot;, message); 
32 
}
33 
34 exit(1); 
35 }
36 
37 void Address_print(struct Address *addr)
38 {
39 printf(&amp;quot;%d %s %s\n&amp;quot;, addr-&amp;gt;id,addr-&amp;gt;name, addr­&amp;gt;email); 
40 }
41 
42 void Database_load(struct Connection *conn)
43 {
44 int rc = fread(conn-&amp;gt;db, sizeof(struct Database), 1, conn­&amp;gt;file);
45 if (rc != 1)
46 die(&amp;quot;Fa to load database.&amp;quot;); 
47 }
48 
49 struct Connection *Database_open(const char *filename, char mode)
50 {
51 struct Connection *conn = malloc(sizeof(struct Connection));
52 if (!conn)
53 die(&amp;quot;Me error&amp;quot;); 
54 
55 conn-&amp;gt;db = malloc(sizeof(struct Database)); 
56 if (!conn­&amp;gt;db)
57 die(&amp;quot;Me error&amp;quot;); 
58 
59 if (mode == &#39;c&#39;){ 
60 conn­&amp;gt;file = 
fopen(filename, &amp;quot;w&amp;quot;); 
61 } else {
62 conn­&amp;gt;file = fopen(filename,&amp;quot;r+&amp;quot;); 
63 
64 if (conn-&amp;gt;file){ 
65 Dat 
66 }
67 }
68
69 if (!conn­&amp;gt;file)
70 die(&amp;quot;Fa 
to open the file&amp;quot;); 
71 72 return 
conn;
73 }
74 
75 void 

Database_close(struct 
Connection *conn)76 {77 if (conn)
{78 if (conn-&amp;gt;file) 
79 fcl &amp;gt;file); 
80 if (conn-&amp;gt;db)
81 fre &amp;gt;db);
82 free(co 
83 
}

84 
}
85 
86 void Database_write(struct 
Connection *conn)
87 {
88 rewind(conn 
&amp;gt;file); 
89 
90 int rc = 
fwrite(conn-&amp;gt;db,sizeof(struct Database), 1, conn­&amp;gt;file); 
91 if (rc != 1)
92 die(&amp;quot;Fa to write database.&amp;quot;); 
93 
94 rc = fflush(conn-&amp;gt;file); 
95 if (rc == -1)
96 die(&amp;quot;Ca flush database.&amp;quot;); 
97 }
98 
99 void Database_create(struct Connection *conn)
100 {
101 int i = 0;
102 
103 for (i = 0; i &amp;lt; MAX_ROWS; i++) {
104 // make a prototype to initialize it 
105 struct Address addr = {.id = i,.set = 0 }; 
106 // then just assign it
107 conn­&amp;gt;db-&amp;gt;rows[i]= addr;
108 } 
109 }
110 
111 void Database_set(struct Connection *conn, int id, const char *name,
112 const char *email)
113 {
114 struct Address *addr = &amp;amp;conn-&amp;gt;db-&amp;gt;rows[id];
115 if (addr­&amp;gt;set)
116 die(&amp;quot;Al set, delete it first&amp;quot;);
11. 
118 addr-&amp;gt;set = 1; 
119 // WARNING: bug, read the &amp;quot;How to Break It&amp;quot; and fix this
120 char *res = strncpy(addr-&amp;gt;name, 
name, MAX_DATA); 121 // demonstrate the strncpy bug 
122 if (!res)
123 die(&amp;quot;Na copy failed&amp;quot;); 
12. 
125 res = strncpy(addr-&amp;gt;email, email, MAX_DATA);
126 if (!res)
127 die(&amp;quot;Em copy failed&amp;quot;);
128 }
12. 
130 void Database_get(struct Connection *conn, int id)
131 {
132 struct Address *addr = &amp;amp;conn-&amp;gt;db-&amp;gt;rows[id]; 
133 
134 if (addr­&amp;gt;set){ 135 Address
136 
} else {
137 die(&amp;quot;ID is not set&amp;quot;); 
138 }
139 }
140 
141 void Database_delete(struct Connection *conn, int id)
142 {
143 struct Address addr = {.id = id,.set = 0 };
144 conn-&amp;gt;db­&amp;gt;rows[id]= addr;
145 }
146 
147 void Database_list(struct Connection *conn)
148 {
149 int i = 0;
150 struct Database *db = conn­&amp;gt;db;
151 
152 for (i = 0; i &amp;lt; MAX_ROWS; i++) {
153 struct Address *cur =&amp;amp;db­&amp;gt;rows[i];
154 
155 if (cur-&amp;gt;set){
156 Add 
157 }
158 }
159 }
160 
161 int main(int argc, char *argv[]) 
162 {
163 if (argc &amp;lt; 3)
164 die(&amp;quot;US ex17 &amp;lt;dbfile&amp;gt; &amp;lt;action&amp;gt; [action params]&amp;quot;);
165 
166 char *filename = argv[1]; 
167 char action = argv[2][0]; 
168 struct Connection *conn = Database_open(filename action); 
169 int id = 0;
170 171 if (argc &amp;gt; 3) id = atoi(argv[3]); 
172 if (id &amp;gt;= MAX_ROWS)die(&amp;quot;There&#39;s not that many records.&amp;quot;); 
173
174 switch (action){ 
175 case &#39;c&#39;:
176 Dat 
177 Dat 
178 bre 
179 
180 case &#39;g&#39;: 
181 if (argc != 4)
182 an id to get&amp;quot;); 183 
184 Dat id);
185 bre 
186 
187 case &#39;s&#39;: 
188 if (argc != 6)
189 id, name, email to set&amp;quot;); 
190 
191 Dat id, argv[4], argv[5]); 
192 Dat 
193 bre
194 
195 case &#39;d&#39;: 
196 if (argc != 4)197 id to delete&amp;quot;); 
198 
199 Dat id);
200 Dat 
201 bre 
202 
203 case &#39;l&#39;: 
204 Dat 
205 bre 
206 default 
207 die action: c=create, g=get, s=set, d=del, l=list&amp;quot;); 
208 }
209 
210 Database_cl 
2
11 
212 return 0;

21. } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this program, we&amp;rsquo;re using a set of structures, orstructs, to createa simple database for an address book. There are somethings you&amp;rsquo;venever seen,soyoushould go through itline byline, explain what each line does, and lookup anyfunctions thatyou don&amp;rsquo;t recognize. There area few key things thatyou should pay attention to, as well:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;#define for constants We use another partof the Cpreprocessor (CPP)to create constant settings of MAX_DATA and MAX_ROWS. I&amp;rsquo;ll cover more of wha t the CPP does later, but this is a way to create a constant that will work reliably. There are other ways, but they don&amp;rsquo;t apply in certain situations.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Fixed sized structs The Address struct then uses these constants to create a pieceof data thatis fixedin size, makingit lessefficient buteasier to store and read. The Database struct is thenalso a fixed size becauseit&amp;rsquo;s a fixed lengtharrayof Address structs. That lets you write the whole thing todisk inone move later.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;die function to abort with an error In a smallprogram like this, you can make a single function that killsthe programwith anerror if there&amp;rsquo;s anything wrong. I call this die, and it&amp;rsquo;s used toexit theprogram with an errorafterany failed function callsor bad inputs.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;errno and perror() for error reporting When you have an error return from a function, it will usually set an external variablecalled errno to say exactly what happened. These are just numbers, so you can use perror to print the error message.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;FILE functions I&amp;rsquo;m using all newfunctions like fopen, fread, fclose, and rewind to workwithfiles. Each of thesefunctions works ona FILE struct that&amp;rsquo;s just like your other structs, butit&amp;rsquo;s definedby the C standard library.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nestedstruct pointers There&amp;rsquo;sa use fornested structuresand getting the address ofarray elements thatyou should study.
Specifically, code like &amp;amp;conn-&amp;gt;db­&amp;gt;rows[i] that reads &amp;ldquo;get the i element of rows,whichisin db, which is in conn, then get the eddress of (&amp;amp;) it.&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;copyingstruct prototypes Best shown in Database_delete, you can seeI&amp;rsquo;m using a temporary local Address, initializing its id and set fields, and then simply&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;copying it into the rows array by assigningitto the element I want. This trick makessure that all fields except set and id are initialized to zeros and it&amp;rsquo;sactually easier towrite. Incidentally, you shouldn&amp;rsquo;tbeusing memcpy to do these kinds ofstructcopying operations. ModernC allows you to simply assign one struct to another and it&amp;rsquo;ll handle the copying for you.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;processing complex arguments I&amp;rsquo;m doing somemore complex argument parsing, but this isn&amp;rsquo;treally the best way todo it. We&amp;rsquo;ll get into abetteroptionfor parsing later in the book.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;converting strings to ints I use the atoi function to takethe string forthe id on the command line and convert it the ee int id variable. Read up on this and similar
functions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;allocating large dataon the heap The whole point of this program is thatI&amp;rsquo;m using malloc to ask theOS for a large amount of memory when I createthe Database. We&amp;rsquo;ll cover this in more detail later.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NULL is 0,so Boolean works In many of the checks, I&amp;rsquo;mtesting that apointeris not NULL by simply doing if(!ptr)die(&amp;ldquo;fail!&amp;rdquo;), because NULLwill evaluate to false.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You could be explicitand say &lt;code&gt;if(ptr == NULL)die(&amp;quot;fail!&amp;quot;)&lt;/code&gt;, as well. In some rare systems, NULL will be stored in the computer (represented) as something not 0, but the C standard says you should still be ableto write codeas ifit has a 0 value. From now on when I say &amp;ldquo;NULL is 0,&amp;rdquo; I mean its value for anyone who is overly pedantic.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;You should spend asmuch time as you can testing that it works, and running it with a debugger toconfirm that you&amp;rsquo;vegotallof thememory usage right. Here&amp;rsquo;sa session ofme testing it normally, and thenusing the debugger to check the operations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 17 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ make ex1. cc -Wall ­g ex17.c -o ex1. 
$ ./ex17 db.dat c 
$ ./ex17 db.dat s 
1 zed zed@zedshaw.com 
$ ./ex17 db.dat s 
2 frank frank@zedshaw.com$ ./ex17 db.dat s 
3 joe joe@zedshaw.com 
$ 
$ ./ex17 db.dat l 
1 zed zed@zedshaw.com 
2 frank 
frank@zedshaw.com 
3 joe joe@zedshaw.com 

$ ./ex17 db.dat d 3 
$ ./ex17 db.dat l 
1 zed zed@zedshaw.com 
2 frank frank@zedshaw.com 

$ ./ex17 db.dat g 2 
2 frank frank@zedshaw.com 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Heap versus Stack Allocation&lt;/p&gt;

&lt;p&gt;You kids have it great these days. You playwithyour Ruby orPythonand just makeobjectsand variables without anycarefor where theylive. You don&amp;rsquo;tcare if it&amp;rsquo;son the stack, and what about on the heap? Fuggedaboutit. You don&amp;rsquo;t even know, and you know what, chances are your languageof choice doesn&amp;rsquo;t even put thevariables on stack at all. It&amp;rsquo;s all heap, and you don&amp;rsquo;teven know if it is.&lt;/p&gt;

&lt;p&gt;C is different becauseit&amp;rsquo;s using the real CPU&amp;rsquo;s actual machinery to do its work, and thatinvolves a chunk of RAM called the stack and another called the heap. What&amp;rsquo;s thedifference? It all depends on where you get the storage.&lt;/p&gt;

&lt;p&gt;The heap is easierto explain since it&amp;rsquo;s just allthe remaining memory in your computer, andyou access it with the function malloc to get more. Each time you call malloc, the OS uses internalfunctions to register thatpiece of memory to you, and then returns apointerto it. When you&amp;rsquo;redonewith it, you use free to return it to the OS so that it can be used by otherprograms.&lt;/p&gt;

&lt;p&gt;Failing to do this will cause your programto leak memory, but Valgrind will help you track these leaks down. The stack is aspecial region of memory thatstores temporary variables, which each function creates as locals to thatfunction.&lt;/p&gt;

&lt;p&gt;How it works is thateach argument to a function is pushed onto the stackand then used inside the function. It&amp;rsquo;s really a stack data structure, so the last thing in is the first thing out.&lt;/p&gt;

&lt;p&gt;This also happens with all local variables like char action and int id in main.The advantage of using astack for this is simplythat when the function exits, the C compilerpops these variables off of the stack toclean up. This is simple andprevents memory leaks it the variableis on the stack.&lt;/p&gt;

&lt;p&gt;The easiest way tokeep this straightis with this mantra: If you didn&amp;rsquo;tget it from malloc, or a function that gotit from malloc,then it&amp;rsquo;s on the stack.&lt;/p&gt;

&lt;p&gt;There are threeprimary problems with stacks and heaps towatchout for:&lt;/p&gt;

&lt;p&gt;• If you get a block of memory from malloc, and have thatpointeron the stack, then when the function exitsthe pointer willget popped off andlost.&lt;/p&gt;

&lt;p&gt;• If you puttoo much data on the stack (like large structsand arrays), then you can cause a stack overflow and theprogram will abort. In this case, use the heap with malloc.&lt;/p&gt;

&lt;p&gt;• If you take a pointer to something on the stack, and then pass orreturn it from your function,   then the function receiving it will  segmentation fault  (segfault), because the actual data will get poppedoffand disappear. You&amp;rsquo;ll be pointing at dead space.&lt;/p&gt;

&lt;p&gt;This is why I created a Database_open that allocatesmemory ordies, and thena Database_close thatfrees everything. If you createa createfunction that makesthe whole thingor nothing, and then a destroy function that safelycleans up everything, then it&amp;rsquo;seasier to keep itall straight.&lt;/p&gt;

&lt;p&gt;Finally, when a program exits, theOS will cleanup all of the resources for you, but sometimesnotimmediately. A common idiom (and one I use in this exercise) is to just abort andlet the OS clean up on error.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;This programhas a lot of places where you can break it, so trysome of these but also come up with your own:&lt;/p&gt;

&lt;p&gt;• The classic wayis to removesome of the safetychecks so that you can pass in arbitrary data. For example, remove the
check on line160 that prevents you from passing in anyrecord number.&lt;/p&gt;

&lt;p&gt;• You can alsotry corrupting the data file. Open it in any editor and change random bytes, andthenclose it.&lt;/p&gt;

&lt;p&gt;• You could alsofind ways topassbad arguments the ee programwhen it&amp;rsquo;s run. For example, getting the file andaction backwardwill make it create a file named after the action, andthen do an action based on the first character.&lt;/p&gt;

&lt;p&gt;• There&amp;rsquo;s abugin this programbecause strncpy is poorly designed. Goread about strncpy andtry to find out whathappens when the name or address you giveis greater than 512 bytes. Fix this by simply forcing thelast character to &amp;lsquo;\0&amp;rsquo; so that it&amp;rsquo;s always setno matter what (whichis what strncpy should do).&lt;/p&gt;

&lt;p&gt;• In the Extra Credit section,Ihave you augment the programto create arbitrary size databases. Try to see what the biggest database is before you cause the program to die dueto lackof memory from malloc.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• The die function needs tobeaugmented to let you pass the conn variable, so it can close itand clean up.&lt;/p&gt;

&lt;p&gt;• Change the code to accept parameters for MAX_DATA and MAX_ROWS, storethem in the Database struct, and write that to the file,thus creating a databasethat can be arbitrarily sized.&lt;/p&gt;

&lt;p&gt;• Add more operations you can do with the database, like find.&lt;/p&gt;

&lt;p&gt;• Read about how C does it&amp;rsquo;sstructpacking, and thentry to see why your fileis the sizeit is. See if you can calculate a new size after adding more fields.&lt;/p&gt;

&lt;p&gt;• Add some more fields   to Address and make them searchable.&lt;/p&gt;

&lt;p&gt;• Write a shell script that willdo yourtesting automatically for you by running commands in theright order. Hint: Use set -e at the top ofa bash to make it abort thewholescriptif any commandhas an error.&lt;/p&gt;

&lt;p&gt;• Tryreworking the  programto use asingle global for the database connection. Howdoes this new version of the programcompare to the other one?&lt;/p&gt;

&lt;p&gt;• Go research stack data structure and writeone in yourfavorite language, then try to do it in C.&lt;/p&gt;

&lt;h2 id=&#34;exercise18-pointersto-functions:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise18. Pointersto Functions&lt;/h2&gt;

&lt;p&gt;Functions in C areactually just pointers toa spot in the programwheresome code exists. Just like you&amp;rsquo;ve been creating pointers tostructs, strings, and arrays, you can point a pointer at afunction, too. The main use for this is to pass callbacks toother functions, orto simulate classesand objects. In this exercise, we&amp;rsquo;lldo some callbacks, and in the next exercise, we&amp;rsquo;llmake a simple object system.&lt;/p&gt;

&lt;p&gt;The format ofa function pointer looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
int (*POINTER_NAME)(int a, int b) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A way to remember how to write oneis to do this:&lt;/p&gt;

&lt;p&gt;• Write a normal function declaration: &lt;code&gt;int callme(int a, int b)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;• Wrap the function name with the pointer syntax: &lt;code&gt;int (*callme) (int a, int b)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;• Change thenameto the pointer name: &lt;code&gt;int (*compare_cb) (int a, int b)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The key thing to rememberis thatwhen you&amp;rsquo;re done with this, the variable nameforthe pointer iscalled compare_cb and you use itjust likeit&amp;rsquo;s a function. This is similar to how pointersto arrays can be used just likethe arrays they point to. Pointers to functions can be usedlike the functions theypoint to but with a differentname.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

int (*tester)(int a, int b) = sorted_order;
printf(&amp;quot;TEST: %d is same as %d\n&amp;quot;,tester(2, 3),sorted_order(2, 3)); 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will work evenif the function pointer returns a pointer to something:&lt;/p&gt;

&lt;p&gt;• Write it: char *make_coolness(in awesome_levels)&lt;/p&gt;

&lt;p&gt;• Wrap it: char * (*make_coolness)(intawesome_levels)&lt;/p&gt;

&lt;p&gt;• Rename it: char * (*coolness_cb)(intawesome_levels)&lt;/p&gt;

&lt;p&gt;The next problem to solve with using function pointers is that it&amp;rsquo;s hard to give them asparametersto afunction, such as when you want to pass the functioncallbackto anotherfunction. The solution is to use typedef, which is a Ckeywordfor making new names for other, more complex types.&lt;/p&gt;

&lt;p&gt;The only thing you needto do is put typedef before the same functionpointersyntax, and then after that you can use the name likeit&amp;rsquo;s a type. I demonstratethis in the following exercise code:&lt;/p&gt;

&lt;p&gt;ex18.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 
2 #include &amp;lt;stdlib.h&amp;gt; 
3 #include &amp;lt;errno.h&amp;gt; 
4 #include &amp;lt;string.h&amp;gt; 
5 
6 /** Our old  friend die from ex17. */ 
7 void die(const char *message)
8 {
9 if (errno){
10 perror(m 
11 } else {
12 printf(&amp;quot; %s\n&amp;quot;, message); 
1. }
1. 
15 exit(1); 
16 } 
17 
18 // a typedef creates a fake type, in this
19 // case for a function pointer 
20 typedef int (*compare_cb) (int a,int b); 
2. 
22 /** 
23 * A classic bubble sort function that uses the 
24 * compare_cb to do the sorting. 
25 */ 
26 int *bubble_sort(int *numbers, int count,compare_cb cmp)
27 {
28 int temp = 0;
29 int i = 0;
30 int j = 0;
31 int *target = malloc(count * sizeof(int)); 
32 
33 if (!target)
34 die(&amp;quot;Me error.&amp;quot;); 
35 
36 memcpy(targnumbers, count * sizeof(int)); 
37 
38 for (i = 0; i &amp;lt; count; i++) { 
39 for (j= 0; j &amp;lt; count -1;j++) {
40 if (cmp(target[j], target[j + 1]) &amp;gt; 0) { 41 
= target[j + 1]; 
42 + 1] = target[j]; 
43 = temp;
44 }
45 }
46 }
47 
48 return target;
49 }
50 
51 int sorted_order(int a, int b)
52 {
53 return a ­b;
54 }
55 
56 int reverse_order(int a, int b)
57 {
58 return b ­ a;
59 }
60 
61 int strange_order(int a, int b)
62 {
63 if (a == 0 || b == 0) { 
64 return 0;
65 } else {
66 return a % b;
67 }
68 }
69 
70 /** 
71 * Used to test that we are sorting things correctly
72 * by doing the sort and printing it out. 
73 */ 
74 void test_sorting(int *numbers, int count,compare_cb cmp)
75 {
76 int i = 0;77 int *sorted = bubble_sort(numbers,count, cmp);
78 
79 if (!sorted)
80 die(&amp;quot;Fa to sort as requested.&amp;quot;); 
81 
82 for (i = 0; i &amp;lt; count; i++) { 
83 printf(&amp;quot;, sorted[i]); 
84 }
85 printf(&amp;quot;\n&amp;quot; 86 87 free(sorted 
88 }
89 
90 int main(int argc, char *argv[]) 
91 {
92 if (argc &amp;lt; 2) die(&amp;quot;USAGE: ex18 4 3 1 5 6&amp;quot;); 
93 
94 int count = argc -1;95 int i = 0;
96 char **inputs = argv + 1;
97 
98 int *numbers = malloc(count * sizeof(int));
99 if (!numbers) die(&amp;quot;Memory error.&amp;quot;);
100 
101 for (i = 0; i &amp;lt; count; i++) {
102 numbers = atoi(inputs[i]);
103 }
104 
105 test_sortin count, sorted_order);
106 test_sortin count, reverse_order);
107 test_sortin count, strange_order);
108 
109 free(number 
110 
111 return 0;
11. } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this program, you&amp;rsquo;re creatinga dynamic sorting algorithm that cansort an array ofintegers using a comparison callback. Here&amp;rsquo;s the breakdown ofthis program, so you can clearly understand it:&lt;/p&gt;

&lt;p&gt;ex18.c:1-6 The usual includes that are needed for all of the functions thatwecall.&lt;/p&gt;

&lt;p&gt;ex18.c:7-17 This is the die function from the previous exercisethat I&amp;rsquo;ll use todo error checking. ex18.c:21 This is where the typedef is used, and later I use compare_cb like it&amp;rsquo;s atype similar to int or char in bubble_sort and test_sorting.&lt;/p&gt;

&lt;p&gt;ex18.c:27-49 A bubble sortimplementation, which is avery inefficientway to sort someintegers. Here&amp;rsquo;sa breakdown:&lt;/p&gt;

&lt;p&gt;ex18.c:27 I use the typedef for compare_cb asthe last parameter cmp. This is now a function thatwill return a comparison between two integers for sorting.&lt;/p&gt;

&lt;p&gt;ex18.c:29-34 The usual creation of variables on thestack, followed bya new array of integers on the heap using malloc.Make sure you understand what count * sizeof(int) is doing.&lt;/p&gt;

&lt;p&gt;ex18.c:38 Theouter loop of the bubble sort.&lt;/p&gt;

&lt;p&gt;ex18.c:39 Theinner loop of the bubble sort.&lt;/p&gt;

&lt;p&gt;ex18.c:40 NowI call the cmp callback just like it&amp;rsquo;s anormal unction, butinstead of being the nameof something thatwe defined, it&amp;rsquo;sjust a pointerto it. This lets the caller passin anything it wantsas long as itmatchesthe signatureof the compare_cb typedef.&lt;/p&gt;

&lt;p&gt;ex18.c:41-43 The actual swappingoperation whereabubble sort needs to do whatit does.&lt;/p&gt;

&lt;p&gt;ex18.c:48 Finally, this returns thenewly createdand sorted resultarray target.&lt;/p&gt;

&lt;p&gt;ex18.c:51-68 Three differentversions of the compare_cb function type, whichneeds to have the same definitionas the typedef thatwe created. The C compiler willcomplain to you if you get thiswrong and say the types don&amp;rsquo;t match.&lt;/p&gt;

&lt;p&gt;ex18.c:74-87 This is a testerforthe bubble_sort function. You can see now howI&amp;rsquo;m also using compare_cb topass to bubble_sort, demonstrating how these can be passed aroundlike any other pointers.&lt;/p&gt;

&lt;p&gt;ex18.c:90-103 A simple main function that sets up anarraybased on integers topasson the command line, and then it calls the test_sorting
function.&lt;/p&gt;

&lt;p&gt;ex18.c:105-107 Finally, you get tosee how the compare_cb function pointer typedef is used. I simplycall test_sorting but giveit the name of sorted_order, reverse_order, and strange_order as the functionto use. The Ccompiler thenfinds the address ofthose functions, and makes it apointerfor test_sorting to use. If you look at test_sorting, you&amp;rsquo;ll see that it then passeseach of theseto bubble_sort, but it actually has noidea what they do. The compiler only knows that they match the compare_cb prototypeand should work.&lt;/p&gt;

&lt;p&gt;ex18.c:109 Last thing we do is free up the array ofnumbers that we made.&lt;/p&gt;

&lt;p&gt;What You Should See Running this program is simple, butyou should try differentcombinationsof numbers,or evenother characters, to see whatit does.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 18 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ make ex1. cc -Wall ­
g ex18.c -o ex1.
$ ./ex18 417320 8 
0123478 
874321. 3427108 

$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to have you do something kind of weird to break this. These function pointersare likeeveryother pointer,sothey pointat blocks of memory. Chas this abilityto take onepointerand convertit to another so you can process the datain differentways. It&amp;rsquo;s usually notnecessary, but to show you how to hackyour computer, I want you to add this at the end of test_sorting:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
unsigned char *data = (unsigned char *)cmp; 
for(i = 0; i &amp;lt; 25; 
i++) {printf(&amp;quot;%02x:&amp;quot;,data[i]);
} 
printf(&amp;quot;\n&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This loop is sortof like converting your function toa string, andthen printing out its contents. This won&amp;rsquo;tbreak your program unless the CPU and OS you&amp;rsquo;re onhas a problem with you doing this. What you&amp;rsquo;llsee after itprints the sorted arrayis a stringof hexadecimal numbers,like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;55:48:89:e5:89:7d:fc:8 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That should bethe raw assembler byte codeof the function itself, and you should see that they start the same but thenhave different endings. It&amp;rsquo;s also possible that this loopisn&amp;rsquo;tgetting allof the function, or it&amp;rsquo;sgetting toomuch and stomping on anotherpiece of the program. Without more analysis you won&amp;rsquo;tknow.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• get a hex editor and open up ex18, andthen find thesequence of hex digitsthat start a function tosee ifyou can find the function in the raw program.&lt;/p&gt;

&lt;p&gt;• Findo ther random things in your hex editor and change them. Rerun yourprogram and see what happens. Strings you find are the easiest things tochange.&lt;/p&gt;

&lt;p&gt;• Pass in the wrong function for the compare_cb and see what the C compiler complains about.&lt;/p&gt;

&lt;p&gt;• Pass inNULLand watchyour program seriouslybite it. Then, run the debuggerand see what that reports.&lt;/p&gt;

&lt;p&gt;• Write another sorting algorithm, then change test_sorting so that ittakes both an arbitrary sort function and thesortfunction&amp;rsquo;s callback comparison. Use it to testbothof your algorithms.&lt;/p&gt;

&lt;h2 id=&#34;exercise19-zed-s-awesome-debug-macros:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise19. Zed&amp;rsquo;s Awesome Debug Macros&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;sareoccurring problem in C that we&amp;rsquo;ve been dancingaround, but I&amp;rsquo;m going to solveitin this exerciseusing aset of macros I developed. You can thank me later when you realize how insanely awesome these macros are.&lt;/p&gt;

&lt;p&gt;Right now, you don&amp;rsquo;t know how awesome they are,soyou&amp;rsquo;lljust have to use them, and then you can walkup tome one day and say, &amp;ldquo;Zed, those debug macros werethe bomb. Iowe you myfirstborn child because you savedme a decadeof heartache and prevented me from killing myself morethan once. Thankyou, good sir,here&amp;rsquo;sa million dollarsand the original Snakehead Telecaster prototypesignedby Leo Fender.&amp;rdquo; Yes,they are that awesome.&lt;/p&gt;

&lt;p&gt;The C Error-Handling Problem&lt;/p&gt;

&lt;p&gt;Handling errors is adifficult activityin almost every programming language. There areentireprogramming languages that try ashardas theycan to avoid even the concept of an error. Other languages invent complex control structureslike exceptionsto pass error conditions around. The problem existsmostly because programmers assume errors don&amp;rsquo;t happen, andthis optimisminfects the types of languages they use and create.
C tackles theproblem by returningerror codes and setting a global errno value thatyou check. Thismakes for complex code that simply exists tocheck ifsomething you didhad an error. Asyou write more and more C code, you&amp;rsquo;ll write codewith this pattern:
• Calla function.&lt;/p&gt;

&lt;p&gt;• Check if thereturn value is anerror (and it must look thatup each time,too).&lt;/p&gt;

&lt;p&gt;• Then, cleanup all the resources created so far.&lt;/p&gt;

&lt;p&gt;• Lastly, printout an errormessage that hopefullyhelps.&lt;/p&gt;

&lt;p&gt;This meansforeveryfunction call (and yes, every function), you are potentiallywriting three or four more linesjust to make sureit worked. That doesn&amp;rsquo;tinclude the problem ofcleaning upallof thejunk you&amp;rsquo;vebuilt to that point. If you have tendifferent structures,three files, and a databaseconnection,you&amp;rsquo;d have14 more lineswhen you get an error.&lt;/p&gt;

&lt;p&gt;In the past, this wasn&amp;rsquo;ta problem because Cprograms did what you&amp;rsquo;ve been doing when therewasan error:die. No point in bothering with cleanup when the OS will do it for you. Today, though, many C programs need to run for weeks, months,or years, and handleerrors from many differentsources gracefully. You can&amp;rsquo;tjust have your Web server die at theslightest touch, and you definitely can&amp;rsquo;t have a library that you&amp;rsquo;vewrittennukethe programit&amp;rsquo;s usedin. That&amp;rsquo;s just rude.&lt;/p&gt;

&lt;p&gt;Other languagessolve this problem with exceptions, but thosehave problems in C (and in otherlanguages,too). In C, you only haveone returnvalue, but exceptions makeup an entirestack-based returnsystemwith arbitrary values. Trying to marshal exceptionsup thestack in C is difficult, andno other librarieswillunderstand it.&lt;/p&gt;

&lt;p&gt;The Debug Macros&lt;/p&gt;

&lt;p&gt;The solutionI&amp;rsquo;ve been using for yearsis a small setof debug macros that implements a basic debuggingand error-handling systemfor C. This system is easy to understand, works with every library, and makes C code moresolid and clearer.&lt;/p&gt;

&lt;p&gt;Itdoes this by adopting the conventionthat whenever there&amp;rsquo;s an error,your function will jump toan error: part of the function that knows how to cleanup everything and return an error code. You can use amacro called check to check returncodes, print an error message, and thenjump to the cleanup section. You cancombine thatwith a set oflogging functions for printing out useful debug messages.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll now show you the entire contents of the most awesome set of brillianceyou&amp;rsquo;ve ever seen .&lt;/p&gt;

&lt;p&gt;dbg.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef __dbg_h__ 
#define __dbg_h__ 
#include &amp;lt;stdio.h&amp;gt; 
#include &amp;lt;errno.h&amp;gt; 
#include &amp;lt;string.h&amp;gt; 
#ifdef NDEBUG #define debug(M, ...) 
#else 
#define debug(M, ...) fprintf(stderr, &amp;quot;DEBUG %s:%d: &amp;quot; M &amp;quot;\n&amp;quot;,\ 
__FILE__, __LINE__, ##__VA_ARGS__) 
#endif 
#define clean_errno() (errno == 0 ? &amp;quot;None&amp;quot; : strerror(errno)) 
#define log_err(M, ...) fprintf(stderr,\ 
&amp;quot;[ERROR] (%s:%d: errno: %s) &amp;quot; M &amp;quot;\n&amp;quot;, __FILE__, __LINE__,\ 
clean_errno(), ##__VA_ARGS__) 
#define log_warn(M, ...) fprintf(stderr,\ 
&amp;quot;[WARN] (%s:%d: errno: %s) &amp;quot; M &amp;quot;\n&amp;quot;,\ 
__FILE__, __LINE__, clean_errno(), ##__VA_ARGS__) 
#define log_info(M, ...) fprintf(stderr, &amp;quot;[INFO] (%s:%d) &amp;quot; M &amp;quot;\n&amp;quot;,\ 
__FILE__, __LINE__, ##__VA_ARGS__) 
#define check(A, M, ...) if(!(A)) {\ 
log_err(M, ##__VA_ARGS__); errno=0; goto error; } 
#define sentinel(M, ...) { log_err(M, ##__VA_ARGS__);\ 
errno=0; goto error; } 
#define check_mem(A) check((A), &amp;quot;Out of memory.&amp;quot;) 
#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\ 
errno=0; goto 
error; } 
#endif 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes,that&amp;rsquo;sit, and here&amp;rsquo;s a
breakdownof every line:&lt;/p&gt;

&lt;p&gt;dbg.h:1-2 Theusual defense against accidentally including the file twice, which you saw in thelast exercise.&lt;/p&gt;

&lt;p&gt;dbg.h:4-6 Includesfor the functions that these macros need.&lt;/p&gt;

&lt;p&gt;dbg.h:8 The start of a #ifdef that lets you recompile yourprogram so thatallof thedebug logmessages are removed.&lt;/p&gt;

&lt;p&gt;dbg.h:9 If you compile with NDEBUG defined, then &amp;ldquo;no debug&amp;rdquo; messages will remain.&lt;/p&gt;

&lt;p&gt;You can seein this case the #define debug() is just replaced with nothing (theright sideis empty).&lt;/p&gt;

&lt;p&gt;dbg.h:10 The matching #else for the ebove #ifdef.&lt;/p&gt;

&lt;p&gt;dbg.h:11 The alternative #define debug that translates anyuseof debug(&amp;ldquo;format&amp;rdquo;,
arg1, arg2) into an fprintf call to stderr.ManyC programmersdon&amp;rsquo;t know this, but you can create macrosthat actually worklike printf andtake variablearguments. Some C compilers (actuallyCPP) don&amp;rsquo;t support this, but the ones that matter do. The magic hereis theuseof ##&lt;strong&gt;VA_ARGS&lt;/strong&gt; that says &amp;ldquo;putwhatever they had forextra arguments (&amp;hellip;)here.&amp;rdquo; Also notice the use of &lt;strong&gt;FILE&lt;/strong&gt; and &lt;strong&gt;LINE&lt;/strong&gt; to get the current file:line for the debug message. Very helpful.&lt;/p&gt;

&lt;p&gt;dbg.h:12 The endof the #ifdef.&lt;/p&gt;

&lt;p&gt;dbg.h:14 The clean_errno macro that&amp;rsquo;s used in the others to get a safe, readable version of errno. That strange syntax in the middleis a ternary operator andyou&amp;rsquo;ll learn whatitdoes later.&lt;/p&gt;

&lt;p&gt;dbg.h:16-20 The log_err, log_warn, and log_info, macros for logging messages that are meant for the end user. They work like debug but can&amp;rsquo;t be compiled out.&lt;/p&gt;

&lt;p&gt;dbg.h:22 The best macro ever, check, will make sure thecondition A is true, and if not, it logs the error M (with variableargumentsfor log_err), and then jumps to the function&amp;rsquo;s error: for cleanup.&lt;/p&gt;

&lt;p&gt;dbg.h:24 The second best macro ever, sentinel, isplaced in anypartof a function thatshouldn&amp;rsquo;t run, and if itdoes,it prints an errormessage andthen jumps to the error: label. You put this in if-statements and switch-statements tocatch conditions that shouldn&amp;rsquo;thappen,like the default:.&lt;/p&gt;

&lt;p&gt;dbg.h:26 A shorthand macro called check_mem that makessure a pointeris valid, and ifit isn&amp;rsquo;t,it reportsit as anerror with &amp;ldquo;Outof memory.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;dbg.h:28 Analternative macro, check_debug, which stillchecks and handles an error, but it the error iscommon,then it doesn&amp;rsquo;tbother reporting it. In this one, it will use debug instead of log_err to report the message. So when you define NDEBUG, the check still happens, and the error jump goesoff, but the messageisn&amp;rsquo;t printed.&lt;/p&gt;

&lt;p&gt;Using dbg.h&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an exampleof using all of dbg.h in a small program. This doesn&amp;rsquo;t actually doanything but demonstratehow touseeach macro. However, we&amp;rsquo;llbe using these macros inall of the programswe write from now on, so be sureto understand how tousethem.&lt;/p&gt;

&lt;p&gt;ex19.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;dbg.h&amp;quot; 
2 #include &amp;lt;stdlib.h&amp;gt; 
3 #include &amp;lt;stdio.h&amp;gt; 
4 
5 void test_debug() 
6 {
7   // notice you don&#39;t need the \n 
8   debug(&amp;quot;I have Brown Hair.&amp;quot;); 
9 
10  // passing in arguments like printf 
11  debug(&amp;quot;I am %d years old.&amp;quot;, 37); 
12 }
13 
14 void test_log_err() 
15 {
16      log_err(&amp;quot;I believe everything is broken.&amp;quot;); 
17      log_err(&amp;quot;The are %d problems in %s.&amp;quot;, 0, &amp;quot;space&amp;quot;); 
18 }
1. 
20 void test_log_warn() 
21 {
22      log_warn(&amp;quot;Yo can safely ignore this.&amp;quot;); 
23      log_warn(&amp;quot;Ma consider looking at: %s.&amp;quot;, &amp;quot;/etc/passwd&amp;quot;); 
24 }
2. 
26 void test_log_info() 
27 {
28      log_info(&amp;quot;We I did something mundane.&amp;quot;); 
29      log_info(&amp;quot;It happened %f times today.&amp;quot;, 1.3f); 
30 }
31 
32 int test_check(char *file_name)
33 {
34      FILE *input = NULL;
35      char *block = NULL;
36      
37      block = malloc(100); 
38      check_mem(bl should work 
39      
40      input = fopen(file_name,&amp;quot;r&amp;quot;);
41      check(input,&amp;quot;Failed to open %s.&amp;quot;,file_name); 
42      
43      free(block);
44      fclose(input 
45      return 0;
46      
47  error: 
48      if (block)free(block); 
49      if (input)fclose(input); 
50      return -1;
51 }
52 
53 int test_sentinel(int code)
54 {
55      char *temp = malloc(100); 
56      check_mem(te 
57      
58      switch (code){ 
59          case 1: 
60              log_ worked.&amp;quot;); 
61              brea 
62          default: 
63              sent shouldn&#39;t run.&amp;quot;); 
64      }
65 
66      free(temp); 
67      return 0;
68      
69      error: 
70      if (temp)
71      free(tem 
72      return -1; 
73 }
74 
75 int test_check_mem() 
76 {
77 char *test = NULL;
78 check_mem(te 
79 
80 free(test); 
81 return 1 ;
82 
83 error: 
84 return -1;
85 }
86 
87 int test_check_debug() 
88 {
89 int i = 0;
90 check_debug( != 0, &amp;quot;Oops, I was 
0.&amp;quot;);
91 
92 return 0;
93 error: 
94 return -1;
95 } 
96 
97 int main(int argc, char *argv[]) 
98 {
99 check(argc == 2, &amp;quot;Need an argument.&amp;quot;); 
100 
101 test_debug()
102 test_log_err 
103 test_log_war 
104 test_log_inf 
105 
106 check(test_c == 0, &amp;quot;failed with ex19.c&amp;quot;); 
107 check(test_c == -1, &amp;quot;failed with argv&amp;quot;); 
108 check(test_s == 0, &amp;quot;test_sentinel failed.&amp;quot;); 
109 check(test_s == -1, &amp;quot;test_sentinel failed.&amp;quot;); 
110 check(test_c == -1, &amp;quot;test_check_mem failed.&amp;quot;); 
111 check(test_c == -1, &amp;quot;test_check_debugfailed.&amp;quot;); 
11. 
113 return 0;
11. 
115 error: 
116 return 1; 
117 } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pay attention to how check is used, and when it&amp;rsquo;s false,it jumps to the error: labelto doa cleanup. The way to read thoselines is, &amp;ldquo;check that A is true, and ifnot, say M and jump out.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;When yourunthis, giveit somebogusfirst parameter to see this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Exercise 19 Session&lt;/p&gt;

&lt;p&gt;$ make ex1. cc -Wall -g ­DNDEBUG ex19.c ­o ex1.
$ ./ex19 test
&lt;a href=&#34;ex19.c:16: errno: None&#34;&gt;ERROR&lt;/a&gt; I believe everything is broken.
&lt;a href=&#34;ex19.c:17: errno: None&#34;&gt;ERROR&lt;/a&gt; There are 0 problems in space.
&lt;a href=&#34;ex19.c:22: errno: None&#34;&gt;WARN&lt;/a&gt; You can safely ignore this.
&lt;a href=&#34;ex19.c:23: errno: None&#34;&gt;WARN&lt;/a&gt; Maybe consider looking at: /etc/passwd.
&lt;a href=&#34;ex19.c:28&#34;&gt;INFO&lt;/a&gt; Well I did something mundane.
&lt;a href=&#34;ex19.c:29&#34;&gt;INFO&lt;/a&gt; It happened 1.300000 times today.
&lt;a href=&#34;ex19.c:38: errno: No such file or directory&#34;&gt;ERROR&lt;/a&gt; Failed to open test.
&lt;a href=&#34;ex19.c:57&#34;&gt;INFO&lt;/a&gt; It worked. &lt;a href=&#34;ex19.c:60: errno: None&#34;&gt;ERROR&lt;/a&gt; I shouldn&amp;rsquo;t run.
&lt;a href=&#34;ex19.c:74: errno: None&#34;&gt;ERROR&lt;/a&gt; Out of memory.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See how itreports the exact linenumberwherethe check failed? That&amp;rsquo;sgoing to save you hours of debugginglater. Also, see how it prints the error messagefor you when errno is set?Again,that will save youhours of debugging.
How the CPP Expands Macros&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s nowtimefor you to get a short introductionto the CPP so thatyou know howthese macros actually work. To do this, I&amp;rsquo;m going to break down the most complex macro from dbg.h, and have yourun cpp so you can see what it&amp;rsquo;s actually doing.
Imagine thatIhave a function&lt;/p&gt;

&lt;p&gt;called dosomething()thatreturns the typical 0 for successand -1 for an error. EverytimeI call dosomething, I have to check forthis errorcode, so I&amp;rsquo;d write codelike this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int rc = dosomething();
if(rc != 0) 
{
    fprintf(stderr,&amp;quot;There was an error: %s\n&amp;quot;, strerror());goto error; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What I want to use the CPP for is to encapsulatethis if-statement into a more readable andmemorable line ofcode. I wantwhat you&amp;rsquo;ve been doing in dbg.h with the check macro:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt; int rc = dosomething();
check(rc == 0, &amp;quot;There was an error.&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is much clearer and explains exactly what&amp;rsquo;s going on:Check that the function worked, and if not, reportan error. To do this, we need somespecial CPP tricks that makethe CPP usefulas a codegeneration tool. Take a look at the check and log_err macros again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define log_err(M, ...) fprintf(stderr,\
&amp;quot;[ERROR] (%s:%d:errno: %s) &amp;quot; M &amp;quot;\n&amp;quot;, __FILE__, __LINE__,\
clean_errno(),##__VA_ARGS__)#define check(A, M, ...) if(!(A)) {\
log_err(M,##__VA_ARGS__);errno=0; goto error; } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first macro, log_err, is simpler. It simply replaces itself with acall to fprintf to stderr. The only tricky part of this macro is the use of &amp;hellip; in the definition log_err(M, &amp;hellip;). What this does islet you pass variableargumentsto the macro, so you can pass in the arguments that should goto fprintf. Howdo they get injected into the fprintf call? Look at the endfor the
&lt;code&gt;##__VA_ARGS__&lt;/code&gt;, which is&lt;/p&gt;

&lt;p&gt;telling the CPP to takethe args enteredwhere the &amp;hellip; is, and inject them at thatpart of the fprintf call. You can then do thingslike this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
log_err(&amp;quot;Age: %d, 
name: %s&amp;quot;, age, 
name); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The arguments age, name are the &amp;hellip; part of the definition, and thoseget injected into the fprintf output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
fprintf(stderr, &amp;quot; [ERROR] (%s:%d:errno: %s) Age %d: name %d\n&amp;quot;,
__FILE__,__LINE__,clean_errno(), age, name); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See the age, name at the end? That&amp;rsquo;s how &lt;code&gt;...&lt;/code&gt; and &lt;code&gt;##__VA_ARGS__&lt;/code&gt; work together,whichwillwork in macros that call other variable argument macros. Look at the check macro now and see that it calls &lt;code&gt;log_err&lt;/code&gt;, but check is also using the &lt;code&gt;...&lt;/code&gt; and &lt;code&gt;##__VA_ARGS__&lt;/code&gt; todo the call. That&amp;rsquo;s howyou can pass full printf style format strings to check, which goto log_err, and thenmakebothwork like printf.&lt;/p&gt;

&lt;p&gt;The next thing to study is how check crafts the if-statement for the error checking. If we strip out the log_err usage, we see this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
if(!(A))
{
 errno=0; goto error; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which means: If A is false, thenclear errno and goto the error label. The check macro is being replacedwith the if-statement,so if we manually expand out the macro check(rc == 0, &amp;ldquo;There was an error.&amp;rdquo;), we get this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
if(!(rc == 0)) {
    log_err(&amp;quot;There was an error.&amp;quot;);
    errno=0; goto error; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What you should be getting from this trip throughthese twomacros isthat the CPP replacesmacros with the expandedversion of their definition, and it will do this recursively, expanding allof the macros in macros. The CPP, then, is just a recursive templating system, asI mentioned before. Its power comesfromits ability to generate whole blocks of parameterizedcode, thus becoming a handy code generation tool.&lt;/p&gt;

&lt;p&gt;That leaves one question: Why notjust use a function like die?The reason is that you want file:line numbers and the gotooperation for anerror handling exit. If you did this inside afunction,you wouldn&amp;rsquo;tget aline number where the error actually happened, and the goto would be much morecomplicated.&lt;/p&gt;

&lt;p&gt;Another reason isthatyou still have to writethe raw if-statement, which looks likeall of the other if-statements in your code, so it&amp;rsquo;snot as clear that this oneis an error check. By wrapping the if-statement in a macro called check, you make it clearthat this is just error checking, andnotpart of the main flow.&lt;/p&gt;

&lt;p&gt;Finally,CPP hasthe abilityto conditionally compile portions ofcode, so you can havecode that&amp;rsquo;s only present when youbuild a developer ordebug version of the program. You can see this already in the dbg.h file where the debug macroonly has abody if thecompiler asks for it. Without this ability, you&amp;rsquo;d needa wasted if-statement that checks for debug mode, andthen wastes CPU capacity doing that check for novalue.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Put #define NDEBUG at the top of the file and check that all of the debug messages go away.&lt;/p&gt;

&lt;p&gt;• Undo that line, and add -DNDEBUG to CFLAGS at the top of the Makefile, and then recompile to see the same thing.&lt;/p&gt;

&lt;p&gt;• Modify theloggingso that itincludes the function name,as well asthe file:line.&lt;/p&gt;

&lt;h2 id=&#34;exercise20-advanced-debugging-techniques:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise20. Advanced Debugging Techniques&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve already taught you about myawesomedebug macros, and you&amp;rsquo;ve beenusing them. When I debug code I use the debug() macro almost exclusively to analyze what&amp;rsquo;s going on and track down the problem.&lt;/p&gt;

&lt;p&gt;In this exercise,I&amp;rsquo;m going to teach you thebasics ofusing&lt;code&gt;GDB&lt;/code&gt; toinspecta simple programthat runs and doesn&amp;rsquo;texit. You&amp;rsquo;lllearn how to use &lt;code&gt;GDB&lt;/code&gt; to attach to a running process, stopit, and see what&amp;rsquo;shappening. After that, I&amp;rsquo;llgive you some little tips and tricks thatyou can use with &lt;code&gt;GDB&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is anothervideo-focused exercisewhere I show you advanced debugging tricks with mytechnique. The discussion belowreinforces the video, so watch the video first. Debugging willbemuch easier to learnby watching me do it first.&lt;/p&gt;

&lt;p&gt;Debug Printing versus &lt;code&gt;GDB&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;I approach debugging primarily with a &amp;ldquo;scientific method&amp;rdquo; style:I come up with possible causes and then rule them outor provet hat they causethe defect. The problem many programmers have with this approach is that they feel likeit willslow them down. They panic and rush to solve the bug, butin their rush theyfailto notice that they&amp;rsquo;re reallyjust flailing aroundand gathering no useful information. Ifind that logging (debug printing) forces me tosolve a bug scientifically, andit&amp;rsquo;s also just easier to gather informationin most situations.&lt;/p&gt;

&lt;p&gt;In addition, Ihave these reasonsfor using debug printingas my primary debugging tool:
• You seean entire tracing of aprogram&amp;rsquo;s executionwithdebug&lt;/p&gt;

&lt;p&gt;printing of variables, which lets you track how things are going wrong. With &lt;code&gt;GDB&lt;/code&gt;,you have toplace watch and debug statements all over theplace for everything you want, and it&amp;rsquo;s difficult to get a solid trace of the execution.&lt;/p&gt;

&lt;p&gt;• The debug prints can stay in the code, and when youneed them, you can recompile and theycomeback. With &lt;code&gt;GDB&lt;/code&gt;, you have to configurethe same informationuniquely for every defect you have tohunt down.&lt;/p&gt;

&lt;p&gt;• It&amp;rsquo;s easierto turn on debug logging on a server that&amp;rsquo;s not working right, and then inspect the logs while it runs to see what&amp;rsquo;s going on. System administrators know how to handle logging, but they don&amp;rsquo;t know how to use &lt;code&gt;GDB&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;• Printing things is just easier. Debuggers are alwaysobtuse and weird with their own quirky interfacesand inconsistencies. There&amp;rsquo;s nothing complicated about debug(&amp;ldquo;Yo, dis right? %d&amp;rdquo;, my_stuff);.&lt;/p&gt;

&lt;p&gt;• When you write debug prints to find adefect, you&amp;rsquo;re forced to actually analyze the code and use the scientificmethod. You can think of debug usage as, &amp;ldquo;I hypothesize that the code is broken here.&amp;rdquo; Thenwhen you run it, you get your hypothesis tested, andif it&amp;rsquo;snot broken,then you can move to anotherpartwhereit could be. This may seem like it takes longer, but it&amp;rsquo;sactually faster because you go through a process of differential diagnosis and rule out possible causes until you find the realone.&lt;/p&gt;

&lt;p&gt;• Debugprinting works better with unit testing. You can actually just compilethe debugs while you work, and when aunittest explodes, just go look at the logs at any time. With &lt;code&gt;GDB&lt;/code&gt;, you&amp;rsquo;d have to rerun the unit test under &lt;code&gt;GDB&lt;/code&gt; and then trace through it to see what&amp;rsquo;s going on. Despite all of these reasons thatIrelyon debug over &lt;code&gt;GDB&lt;/code&gt;,Istilluse &lt;code&gt;GDB&lt;/code&gt; in a few situations, and I think you should have any toolthat helpsyou get your work done. Sometimes,youjust have to connect to a broken programand poke around. Or, maybe you&amp;rsquo;ve got a server that&amp;rsquo;s crashingand you can only get atcore files to see why. In these anda few other cases, &lt;code&gt;GDB&lt;/code&gt; is the way to go, and it&amp;rsquo;salways goodto have as many tools as possible tohelp solve problems.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s abreakdown of when I use &lt;code&gt;GDB&lt;/code&gt; versusValgrind versusdebug printing:&lt;/p&gt;

&lt;p&gt;• I useValgrindto catch all memory errors. I use &lt;code&gt;GDB&lt;/code&gt;if Valgrind is having problemsor if using Valgrind would slowthe programdown toomuch.&lt;/p&gt;

&lt;p&gt;• I useprint with debug to diagnoseand fix defectsrelated to logic orusage. Thisamounts to about90% of the defectsafteryoustart using Valgrind.&lt;/p&gt;

&lt;p&gt;• I use&lt;code&gt;GDB&lt;/code&gt; for the remaining mysteriously weird stuff or emergency situationsto gather information. If Valgrind isn&amp;rsquo;t turning anything up, and I can&amp;rsquo;t even print out the informationthat Ineed, thenI bustout &lt;code&gt;GDB&lt;/code&gt; and start poking around. My use of &lt;code&gt;GDB&lt;/code&gt;in this caseis entirely togather information. Once I have anidea of what&amp;rsquo;s going on,I&amp;rsquo;ll go back to writing a unit test to cause the defect, and thendo printstatements to find out why.&lt;/p&gt;

&lt;p&gt;A Debugging Strategy&lt;/p&gt;

&lt;p&gt;This processwillactually work with any debugging technique you&amp;rsquo;re using. I&amp;rsquo;m going to describe it interms ofusing &lt;code&gt;GDB&lt;/code&gt; sinceit seems people skipthis process the most whenusing debuggers. Use this foreverybug until you only neediton thevery difficultones.&lt;/p&gt;

&lt;p&gt;• Starta little text file called notes.txt and use it asa kindof lab notesforideas,bugs, problems, and so on.&lt;/p&gt;

&lt;p&gt;• Beforeyou use &lt;code&gt;GDB&lt;/code&gt;, write out the bug you&amp;rsquo;re going to fixand what could be causing it.&lt;/p&gt;

&lt;p&gt;• For each cause, write out the filesand functions where you think thecauseis coming from, or just write thatyou don&amp;rsquo;t know.&lt;/p&gt;

&lt;p&gt;• Now start &lt;code&gt;GDB&lt;/code&gt; and pick the firstpossiblecause with good file and function variablesand setbreakpoints there.&lt;/p&gt;

&lt;p&gt;• Use &lt;code&gt;GDB&lt;/code&gt; to then run the programand confirm whetherthat is the cause. Thebestway is to see if you can use the set command to either fix the programeasily orcausethe error immediately.&lt;/p&gt;

&lt;p&gt;• If this isn&amp;rsquo;t the cause, thenmark in the notes.txt that it wasn&amp;rsquo;t, and why. Move on to the next possible cause that&amp;rsquo;s easiest to debug, and keep adding information.&lt;/p&gt;

&lt;p&gt;In case you haven&amp;rsquo;tnoticed, this is basically the scientific method. You writedownaset ofhypotheses, thenyouuse debugging to proveor disprove them. This gives you insight into more possible causes and eventually you find it. This process helpsyou avoid goingoverthe same possible causes repeatedly after you&amp;rsquo;vefoundthat they aren&amp;rsquo;t possible.&lt;/p&gt;

&lt;p&gt;You can also do this with debug printing,the only difference is thatyou actually write out your hypotheses in the source codeinsteadof in the notes.txt. In away, debug printing forces you to tacklebugs scientifically because you have to write out hypothesesas print statements.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Finda graphical debugger and compare using it toraw &lt;code&gt;GDB&lt;/code&gt;. Theseare useful when the program you&amp;rsquo;re looking at is local, but they are pointless if you have todebug a programon aserver.&lt;/p&gt;

&lt;p&gt;• You can enable core dumps on your OS, and when aprogram crashes, you&amp;rsquo;ll get a corefile. This corefile islike a postmortem of the program thatyou can load up tosee what happenedright at the crash and whatcaused it. Change ex18.c so that itcrashes after a fewiterations, then try to get a core dumpand analyzeit.&lt;/p&gt;

&lt;h2 id=&#34;exercise21-advanced-data-types-and-flow-control:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise21. Advanced Data Types and Flow Control&lt;/h2&gt;

&lt;p&gt;This exercisewillbea completecompendium of the available C datatypes and flow control structures you can use. It will workas a referenceto completeyour knowledge, andwon&amp;rsquo;t have any code for you to enter. I&amp;rsquo;ll have you memorizesome of the information bycreating flashcards so you can get the important concepts solidin your mind.&lt;/p&gt;

&lt;p&gt;For this exerciseto be useful, you should spend at least a week hammering in the contentand filling out all of the elementsthat are missing here. You&amp;rsquo;ll be writing out whateach one means, and thenwriting aprogram to confirmwhat you&amp;rsquo;ve researched.
Available Data Types&lt;/p&gt;

&lt;p&gt;Type Modifiers&lt;/p&gt;

&lt;p&gt;// TO DO&lt;/p&gt;

&lt;p&gt;Type Qualifiers&lt;/p&gt;

&lt;p&gt;// TO DO&lt;/p&gt;

&lt;p&gt;Type Conversion&lt;/p&gt;

&lt;p&gt;// TO DO&lt;/p&gt;

&lt;p&gt;C usesa sort ofstepped type promotion mechanism, where it looks at two operandson either side of an expression, and promotesthe smaller side to match thelarger side beforedoing the operation. If onesideof an expression is on this list, then the other side is converted to that type beforethe operation is done. Itgoes in thisorder:
1. long double&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;double&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;float&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;int (butonly char
and short int);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;long&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If youfind yourself trying to figure outhow your conversions are working in an expression,then don&amp;rsquo;t leave it to thecompiler. Useexplicit casting operations to make it exactly what you want. For example, ifyou have&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
long + char -int * double 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rather than trying to figure out if it will be converted to double correctly, just use casts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;(double)long ­(double)char ­(double)int * double 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting the type you want in paren theses before the variablename is how you force it into the type you really need. The important thing, though,is always promote up, not down. Don&amp;rsquo;t cast long into char unless you know what you&amp;rsquo;re doing.
Type Sizes&lt;/p&gt;

&lt;p&gt;The stdint.h defines both asetof typdefs forexact­sized integertypes, as well as asetof macros for thesizes ofallthe types. This is easier to workwith than the older limits.h sinceitis consistent. Hereare the types defined: The pattern here is in the form(u)int(BITS)_twherea u is putin frontto indicate &amp;ldquo;unsigned,&amp;rdquo; and BITS is a number for thenumberof bits. This patternis then repeated for macrosthat return the maximum values of these types:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;INT(N)_MAX Maximum positivenumberof the signed integerof bits (N), such as INT16_MAX.
INT(N)_MIN Minimum negative number of signed integerof bits (N).
UINT(N)_MAXMaximum positive number ofunsigned integer of bits (N). Since it&amp;rsquo;sunsigned, the minimum is0 and it can&amp;rsquo;t have a negative value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Warning!
Pay attention! Don&amp;rsquo;t go looking for a literal
INT(N)_MAX
definition in any header file. I&amp;rsquo;m using the (N) as a placeholderforany number of bits your platform currently supports. This (N)could be any number— 8, 16, 32, 64, maybe even128. I use this notation in this exercise so thatIdon&amp;rsquo;t have to literally write out every possible combination.&lt;/p&gt;

&lt;p&gt;There are also macros in stdint.h for sizes of the size_t type,integers large enoughto hold pointers, and other handysize defining macros. Compilers have to at least have these, and then theycan allow other, larger types.&lt;/p&gt;

&lt;p&gt;Hereis a full list that should&lt;/p&gt;

&lt;p&gt;be in stdint.h:&lt;/p&gt;

&lt;p&gt;Available Operators&lt;/p&gt;

&lt;p&gt;This is acomprehensivelist ofallthe operators in the C language. In this list, I&amp;rsquo;m indicating the following:&lt;/p&gt;

&lt;p&gt;Math Operators&lt;/p&gt;

&lt;p&gt;Theseperformyour basic math operations, plusI include () sinceitcalls a function andisclose to a math operation.&lt;/p&gt;

&lt;p&gt;Data Operators&lt;/p&gt;

&lt;p&gt;Theseare used toaccess data
in different ways andforms.&lt;/p&gt;

&lt;p&gt;Logic Operators&lt;/p&gt;

&lt;p&gt;Thesehandle testing equality
and inequality of variables.&lt;/p&gt;

&lt;p&gt;Bit Operators&lt;/p&gt;

&lt;p&gt;Theseare more advancedand are for shifting and modifying the raw bits in integers.&lt;/p&gt;

&lt;p&gt;Boolean Operators&lt;/p&gt;

&lt;p&gt;Theseare used intruth testing. Study the ternary operator carefully. It&amp;rsquo;svery handy.&lt;/p&gt;

&lt;p&gt;Assignment
Operators&lt;/p&gt;

&lt;p&gt;Hereare compound assignment operators that assigna value, and/or performanoperation at the same time. Most of the above operations can alsobe combined into a compound assignment operator.&lt;/p&gt;

&lt;p&gt;Available Control Structures&lt;/p&gt;

&lt;p&gt;There area few control structures thatyou haven&amp;rsquo;t encountered yet.
do-while do { &amp;hellip; }while(X); Firstdoes the code in theblock, thenteststhe X expressionbefore exiting.
break Puts a break in a loop,ending itearly.&lt;/p&gt;

&lt;p&gt;continue Stops thebody ofa loop and jumps to the testso itcan continue.
goto Jumps to aspot in the code where you&amp;rsquo;ve placeda label:, and you&amp;rsquo;ve been using this in the dbg.h macros to go to the error: label.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Read stdint.h or a description of it, and write out all the available size identifiers.&lt;/p&gt;

&lt;p&gt;• Gothrough each item hereand write out what it doesin code. Researchit online so you know you gotit right.&lt;/p&gt;

&lt;p&gt;• Get this information memorizedby making flashcards and spending15 minutes a day practicingit.&lt;/p&gt;

&lt;p&gt;• Create aprogram that prints out examples of each type, and confirm thatyour research is right.&lt;/p&gt;

&lt;h2 id=&#34;exercise22-the-stack-scope-and-globals:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise22. The Stack, Scope, and Globals&lt;/h2&gt;

&lt;p&gt;The concept ofscope seems to confusequitea few people when theyfirststart programming. Itoriginally came from theuseof the systemstack (whichwe lightly covered earlier), and how it was used to store temporary variables. In this exercise, we&amp;rsquo;lllearnabout scope by learning howa stack data structure works, andthen feeding that conceptback in to how modern C does scoping.&lt;/p&gt;

&lt;p&gt;The real purpose ofthis exercise, though, is to learn where the hell things live in C. When someone doesn&amp;rsquo;t grasp the conceptof scope,&lt;/p&gt;

&lt;p&gt;it&amp;rsquo;salmostalways a failurein understanding where variables arecreated, exist, and die. Once you know where things are, theconcept ofscope becomes easier.&lt;/p&gt;

&lt;p&gt;This exercisewillrequire three files:&lt;/p&gt;

&lt;p&gt;ex22.h A headerfile that setsup some external variables and some functions.&lt;/p&gt;

&lt;p&gt;ex22.c This isn&amp;rsquo;tyour&lt;/p&gt;

&lt;p&gt;main likenormal, but instead asourcefile that willbecome the object file ex22.o,which will have some functions andvariables in itdefined from ex22.h.&lt;/p&gt;

&lt;p&gt;ex22_main.c The actual main thatwillinclude the othertwo, and demonstrate what they contain, as well as other
scope concepts.&lt;/p&gt;

&lt;p&gt;ex22.h and ex22.c&lt;/p&gt;

&lt;p&gt;Your firststepis to create your own header file named ex22.h thatdefines the functions andextern variables:&lt;/p&gt;

&lt;p&gt;ex22.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

#ifndef _ex22_h #define _ex22_h 
// makes THE_SIZE in ex22.c available to other .c files 

extern int THE_SIZE; 
// gets and sets an internal static variable in ex22.c 
int get_age(); void set_age(int age); 
// updates a static variable that&#39;s inside update_ratio 
double update_ratio(double ratio); 
void print_size(); 
#endif 

The important thing to see hereis the use of extern int THE_SIZE, which I&#39;ll explain after you createthis matching ex22.c: 



ex22.c 


```c

1 #include &amp;lt;stdio.h&amp;gt; 
2 #include &amp;quot;ex22.h&amp;quot; 
3 #include &amp;quot;dbg.h&amp;quot; 
4 
5 int THE_SIZE = 1000;
6 
7 static int THE_AGE = 37; 
8 
9 int get_age() 
10 {
11 return THE_AGE;
12 }
1. 
14 void set_age(int age)
15 {
16 THE_AGE = age;
17 }
1. 
19 double update_ratio(double new_ratio)
20 {
21 static double ratio = 1.0;
2. 
23 double old_ratio = ratio;
24 ratio = new_ratio;
2.
 26 return old_ratio;
27 }
2. 
29 void print_size() 
30 {
31 log_info(&amp;quot;I think size is: %d&amp;quot;, THE_SIZE); 
32 } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These two files introduce some new kinds of storage for variables:&lt;/p&gt;

&lt;p&gt;extern This keyword is a way to tell the compiler &amp;ldquo;the variable exists, but it&amp;rsquo;sin another ‘external&amp;rsquo; location.&amp;rdquo; Typicallythis meansthat one .c file is going to use avariable that&amp;rsquo;s been defined in another .c file. In this case, we&amp;rsquo;re saying ex22.c has avariable THE_SIZE that willbe accessed from ex22_main.c.
static (file) This keyword iskind of the inverse of extern, and says that the variable isonly used in this .c file and should notbeavailable to other partsof theprogram. Keep inmind that static at the file level(aswith THE_AGE here) is different than In other places.
static (function) If you declare avariable in a function static, then thatvariable acts likea static definedin the file, but it&amp;rsquo;sonly accessible from that function. It&amp;rsquo;s away of creating constantstate for afunction, butin reality it&amp;rsquo;s rarely used in modern C programming because they are hard to use with threads.&lt;/p&gt;

&lt;p&gt;In these twofiles, you should&lt;/p&gt;

&lt;p&gt;understand the following
variables and functions:
THE_SIZE This is the variableyou declared extern thatyou&amp;rsquo;ll playwithfrom ex22_main.c.
get_age and set_age Theseare taking the static variable THE_AGE, but exposingit to other partsof theprogram through functions. You can&amp;rsquo;t access THE_AGE directly, but these
functions can.
update_ratio Thistakes a new ratio value, and returnsthe oldone. It uses afunction level static variable ratio to keeptrackof what the ratio currently is.
print_size This prints out what ex22.c thinks THE_SIZE is currently.&lt;/p&gt;

&lt;p&gt;ex22_main.c&lt;/p&gt;

&lt;p&gt;Once you have thatfile written, you can then make the main function, which uses all of these and demonstrates some more scope conventions.&lt;/p&gt;

&lt;p&gt;ex22_main.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;ex22.h&amp;quot; 
2 #include &amp;quot;dbg.h&amp;quot; 
3 
4 const char *MY_NAME = &amp;quot;Zed A. Shaw&amp;quot;; 
5 
6 void scope_demo(int count)
7 {
8 log_info(&amp;quot;co is: %d&amp;quot;, count); 
9 
10 if (count &amp;gt; 
10) {
11 int count = 100; // BAD! BUGS! 
1.
 13 log_info in this scope is %d&amp;quot;,count); 
14 }
15 
16 log_info(&amp;quot;co is at exit: %d&amp;quot;, count); 
1. 
18 count = 3000;
19 
20 log_info(&amp;quot;co after assign: %d&amp;quot;,count); 
21 }
2. 
23 int main(int argc, char *argv[]) 
24 {
25 // test out THE_AGE accessors 
26 log_info(&amp;quot;Myname: %s, age: %d&amp;quot;,MY_NAME, get_age()); 
27 
28 set_age(100)
29 
30 log_info(&amp;quot;My
age is now: %d&amp;quot;, get_age()); 
31 
32 // test out THE_SIZE extern 
33 log_info(&amp;quot;TH is: %d&amp;quot;, THE_SIZE); 
SIZE is now: %d&amp;quot;, 
34 35  print_size()  
36 9;37  THE_SIZE =  
38  log_info(&amp;quot;TH  

THE_SIZE); 
39 print_size()40 
41 // test the ratio function static 
42 log_info(&amp;quot;Ra at first: %f&amp;quot;,update_ratio(2.0)); 
43 log_info(&amp;quot;Ra again: %f&amp;quot;,update_ratio(10.0)); 
44 log_info(&amp;quot;Ra once more: %f&amp;quot;,update_ratio(300.0)); 
45  
46  //  test  the scope 
47  demo int  count  = 
4;
48  scope_demo(c   
49 scope_demo(c * 20); 
50 
51 log_info(&amp;quot;co after callingscope_demo: %d&amp;quot;,count); 
52 
53 return 0;

54 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ll break this file downline by line, butas I do,you should find eachvariable and where it lives.&lt;/p&gt;

&lt;p&gt;ex22_main.c:4 A const, which standsfor constant, and is an alternative to using a define to create a constant variable.&lt;/p&gt;

&lt;p&gt;ex22_main.c:6 A simple function that demonstrates more scope issues in a function.&lt;/p&gt;

&lt;p&gt;ex22_main.c:8 This prints out the value of count asitisat the top of the function.&lt;/p&gt;

&lt;p&gt;ex22_main.c:10 An if-statement that starts anew scope block, and thenhas another count variablein it. This version of count isactually awhole new variable. It&amp;rsquo;s kind of likethe if-statement started a new minifunction.&lt;/p&gt;

&lt;p&gt;ex22_main.c:11 The count thatis local to this blockis actually differentfrom theone in the function&amp;rsquo;s parameter list.&lt;/p&gt;

&lt;p&gt;ex22_main.c:13 This prints itout so you can seeit&amp;rsquo;s actually 100 here, not whatwas passed to scope_demo.&lt;/p&gt;

&lt;p&gt;ex22_main.c:16 Nowfor the freaky part. You have count in two places:the parameters to thisfunction, and in the if-statement. The if-statement created anew block, so the count on line1. does not impact the parameter with the same name. This line prints itout, and you&amp;rsquo;ll see that it printsthe valueof theparameter, not100.&lt;/p&gt;

&lt;p&gt;ex22_main.c:18-20 Then, I set the parameter count to 3000and print that out,which willdemonstrate that you can change function parameters and theydon&amp;rsquo;t impact the caller&amp;rsquo;s versionof the variable.&lt;/p&gt;

&lt;p&gt;Make sure thatyou trace through this function, but don&amp;rsquo;t think thatyou understand scopequiteyet. Just startto realize thatif you make a variable inside a block (as in if-statements or while-loops), then thosevariables are new variables thatexist only in that block. This is crucial to understand, and is also a source of many bugs. We&amp;rsquo;ll address why you shouldn&amp;rsquo;tmake a variable
inside ablockshortly. The rest of the ex22_main.c then demonstrates allof these by manipulating and printing them out:&lt;/p&gt;

&lt;p&gt;ex22_main.c:26 This prints out the current valuesof MY_NAME, and gets THE_AGE from ex22.c by using the accessorfunction
get_age.&lt;/p&gt;

&lt;p&gt;ex22_main.c:27-30 This uses set_age in ex22.c to change THE_AGE andthen printitout.&lt;/p&gt;

&lt;p&gt;ex22_main.c:33-39 Then I do the same thing to THE_SIZE from ex22.c, but this time I&amp;rsquo;m accessing it directly. I&amp;rsquo;m also demonstrating that it&amp;rsquo;s
actually changing in thatfile byprinting it hereand with print_size.&lt;/p&gt;

&lt;p&gt;ex22_main.c:42-44 Here, I show how the static variable ratio inside update_ratio is maintained between function calls.&lt;/p&gt;

&lt;p&gt;ex22_main.c:46-51&lt;/p&gt;

&lt;p&gt;Finally,I&amp;rsquo;m running scope_demo a few times soyou cansee the scope inaction. The big thing to noticeisthat the local count variableremains unchanged. You must understand that passing in a variablelike this won&amp;rsquo;tlet youchangeit in the function. Todo that, you needourold friendthe pointer. If you were topassa pointer to this count, then the calledfunction would have the address ofitand could change it.&lt;/p&gt;

&lt;p&gt;That explains what&amp;rsquo;sgoing on, but youshould trace through thesefiles and make sureyou knowwhere everythingisas you study it.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;This time,instead of using your Makefile, Iwant you to buildthese twofiles manually so you can seehow the compileractually puts them together. Here&amp;rsquo;swhat you should doand see for output:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 22 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ cc -Wall -g ­DNDEBUG -c -o ex22.o ex22.c 
$ cc -Wall -g ­DNDEBUG ex22_main.c ex22.o -o ex22_main 
$ ./ex22_main
[INFO] (ex22_main.c:26) My name: Zed A. Shaw, age: 37
[INFO] (ex22_main.c:30) My age is now: 100
[INFO] (ex22_main.c:33) THE_SIZE is: 1000 
[INFO] (ex22.c:32) I think size is: 1000 
[INFO] (ex22_main.c:38) THE SIZE is now: 9 
[INFO] (ex22.c:32) I think size is: 9 
[INFO] (ex22_main.c:42) Ratio at first: 1.000000 
[INFO] (ex22_main.c:43) Ratio again: 2.000000
[INFO] (ex22_main.c:44) Ratio once more: 10.000000
[INFO] (ex22_main.c:8) count is: 4
[INFO] (ex22_main.c:16) count is at exit: 4
[INFO] (ex22_main.c:20) count after assign: 3000
[INFO] (ex22_main.c:8) count is: 80 
[INFO] (ex22_main.c:13) count in this scope is 100
[INFO] (ex22_main.c:16) count is at exit: 80
[INFO] (ex22_main.c:20) count after assign: 3000
[INFO] (ex22_main.c:51. count after calling scope_demo: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure you trace how each variableis changing and match it to the linethat gets output. I&amp;rsquo;m using log_info fromthe dbg.h macros so you can get the exact line number where each variable is printed, and find itin the filesfortracing.
Scope, Stack, and Bugs&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;vedone this right, you should now see many of the differentways you can place variables in your C code. You can use extern or access functions like get_age to createglobals. You canmake new variables inside any blocks, and they&amp;rsquo;ll retain their own valuesuntilthatblock exits, leaving the outer variables alone. Youalso can pass avalue toa function, and change the parameter but without changing the caller&amp;rsquo;s versionof it.&lt;/p&gt;

&lt;p&gt;The mostimportant thing to realizeisthat allof this causes bugs. C&amp;rsquo;sability to place thingsin many places in your machine, and thenlet you access itin thoseplaces, meansthat you can geteasily confusedabout where something lives. If you don&amp;rsquo;t know where itlives,then there&amp;rsquo;s a chanceyou won&amp;rsquo;t manage it properly.&lt;/p&gt;

&lt;p&gt;With thatin mind, hereare somerules tofollowwhen writing C codeso you can avoid bugs related to the stack:
• Donotshadowa variablelike I&amp;rsquo;ve done herewith count in scope_demo. It leaves you open to subtle and hidden bugs where you think you&amp;rsquo;re changing avalue but&lt;/p&gt;

&lt;p&gt;you&amp;rsquo;re actually not.&lt;/p&gt;

&lt;p&gt;• Avoid using toomany globals, especially if across multiplefiles. If you have tousethem, then use accessor functions likeI&amp;rsquo;ve done with get_age. This doesn&amp;rsquo;tapplyto constants, since those are read-only. I&amp;rsquo;m talkingaboutvariables like THE_SIZE.If you wantpeople to modify orset this variable, then make accessor functions.&lt;/p&gt;

&lt;p&gt;• When indoubt,putit on the heap. Don&amp;rsquo;trely on thesemantics of the stack orspecialized locations. Just create things with malloc.&lt;/p&gt;

&lt;p&gt;• Don&amp;rsquo;t use function static variableslike I didin update_ratio. They&amp;rsquo;re rarelyuseful and end up beinga huge painwhen you need to make your code concurrentin threads. They&amp;rsquo;re also hard as hellto find compared to awell-done global variable.&lt;/p&gt;

&lt;p&gt;• Avoid re using function parameters. It&amp;rsquo;s confusing as to whether you&amp;rsquo;re just re using it or if you thinkyou&amp;rsquo;re changing the caller&amp;rsquo;s version of it.&lt;/p&gt;

&lt;p&gt;As with all things, theserules can be broken when it&amp;rsquo;s practical. Infact, I guarantee you&amp;rsquo;ll run into code that breaks all of these rulesand is perfectly fine. Theconstraints ofdifferent platformseven makeit necessarysometimes.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;For this exercise, try to access orchangesome things you can&amp;rsquo;t to break theprogram.&lt;/p&gt;

&lt;p&gt;• Try to directlyaccess variables in ex22.c from ex22_main.c thatyou think you can&amp;rsquo;t access. For example, can you get at ratio inside update_ratio? Whatif you had a pointer to it?&lt;/p&gt;

&lt;p&gt;• Ditch the extern declaration in ex22.h to see whaterrors or warnings you get.&lt;/p&gt;

&lt;p&gt;• Add static or const specifiers to differentvariables, and thentry to change them.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Research the conceptof pass by value versus pass by reference. Write an exampleof both.&lt;/p&gt;

&lt;p&gt;• Use pointers to gain access to things you shouldn&amp;rsquo;thave access to.&lt;/p&gt;

&lt;p&gt;• Use yourdebugger to see what this kind of access looks like when you do itwrong.&lt;/p&gt;

&lt;p&gt;• Write a recursive function that causesa stack overflow. Don&amp;rsquo;t know what arecursive function is? Try calling scope_demo at the bottom of scope_demo itself so that itloops.&lt;/p&gt;

&lt;p&gt;• Rewritethe Makefile so that itcan build this.&lt;/p&gt;

&lt;h2 id=&#34;exercise23-meet-duff-s-device:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise23. Meet Duff&amp;rsquo;s Device&lt;/h2&gt;

&lt;p&gt;This exercise is abrainteaser where I introduceyou toone of the most famous hacksin C called Duff&amp;rsquo;s device, named after TomDuff, its inventor. This little slice of awesome (evil?)hasnearly everything you&amp;rsquo;ve been learning wrappedin onetiny, little package. Figuringout how it works is also a good, fun puzzle.&lt;/p&gt;

&lt;p&gt;Warning!&lt;/p&gt;

&lt;p&gt;Part of the fun of C is thatyou cancome up with crazyhacks like this, but this is also what makes C annoying to use. It&amp;rsquo;s good to learnabout these tricks because it gives you a deeper understandingof the languageand your computer. Butyou shouldneverusethis. Always strive for easy-to-read code.&lt;/p&gt;

&lt;p&gt;Discovered by Tom Duff, Duff&amp;rsquo;s deviceis atrick with the C compiler that actually shouldn&amp;rsquo;twork. I won&amp;rsquo;ttell you whatit does yetsince this is meant to be a puzzle for you to ponder andtry to solve. You&amp;rsquo;ll get this code running and thentry to figure outwhatitdoes, and why it does it this way.&lt;/p&gt;

&lt;p&gt;ex23.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 
2 #include &amp;lt;string.h&amp;gt; 
3 #include &amp;quot;dbg.h&amp;quot; 
4 
5 int normal_copy(char *from, char *to, int count)
6 {
7 int i = 0;
8 
9 for (i = 0; i &amp;lt; count; i++) { 
10 to[i]= from[i];
11 }
12 
13 return i;
1. }
1. 
16 int duffs_device(char *from, char *to, int count)
17 {
18 {
19 int n = (count + 7) / 8;
20 
21 switch (count % 8) { 
22 case 0: 
2. {
2. =*from++;
2. 7: 
2. =*from++;
2. 6: 
2. =*from++;
2. 5: 
30 =*from++;
31 4: 
32 =*from++;
33 
3: 
34 
=*from++;
35 
2: 
36 
=*from++;
37 
1. 
38 =*from++;
39 while (--n &amp;gt; 0); 
40 
41 
42  }  }  
43  return  
count;
44 } 
45 
46 int zeds_device(char *from, char *to, int count)
47 { 
48 {
49 int n =(count + 7) / 8;
50 
51 switch (count % 8) { 
52 cas 
0: 
53 again:*to++ 
=*from++;
54 
55 cas 7: 
56 *to++ =*from++;
57 cas 6: 
58  *to++  
= *from++;59  cas  
5:  
60  *to++  
= *from++;
61  cas  
4:  
62  *to++  
= *from++;
63  cas  
3:  
64  *to++  
= *from++;
65  cas  
2:  

66 *to++ =*from++;
67 cas 1. 

68 *to++ =*from++;
69 if (--n &amp;gt; 0)
70 gagain;
71 }
72 }
73 
74 return count;
75 } 

76 

77 int 
valid_copy(char *data, int count,char expects)
78 {
79 int i = 0;
80 for (i = 0; i &amp;lt; count; i++) { 
81 if (data[i] != expects){
82 log[%d] %c != %c&amp;quot;, i,data[i], expects); 
83 ret 0; 
84 
85 
86 
87 
88 }
89 
90 int argc, char 
91 { 
92 from[1000]93 to[1000] = 
94 0;
95 }} 
return 1. main(int *argv[]) char ={ &#39;a&#39; }; char { &#39;c&#39; }; int rc = 
96 // set up the from to have some stuff 
97 memset(from &#39;x&#39;, 1000);

98 // set it to a failure mode 
99 memset(to,&#39;y&#39;, 1000); 
100 check(valid 1000, &#39;y&#39;), &amp;quot;Not initialized right.&amp;quot;); 
101 
102 // use normal copy to 
103 rc = normal_copy(from, to,1000); 
104 check(rc == 1000, &amp;quot;Normal copy failed: %d&amp;quot;, rc); 
105 check(valid 1000, &#39;x&#39;), &amp;quot;Normal copy failed.&amp;quot;); 
106 
107 // reset 
108 memset(to,&#39;y&#39;, 1000); 
109 
110 // duffs version 
111 rc = duffs_device(from,to, 1000); 
112 check(rc == 1000, &amp;quot;Duff&#39;s device failed: %d&amp;quot;, rc);
113 check(valid 1000, &#39;x&#39;), &amp;quot;Duff&#39;s device failed copy.&amp;quot;); 
114 
115 // reset 
116 memset(to,&#39;y&#39;, 1000); 
117 
118 // my version 
119 rc = 
zeds_device(from, to,
1000); 
120 check(rc 
== 1000, &amp;quot;Zed&#39;s 
device failed: %d&amp;quot;, 
rc);
121 check(valid 
1000, &#39;x&#39;), &amp;quot;Zed&#39;s 
device failed 
copy.&amp;quot;); 
12. 
123 return 0;
124 error: 
125 return 1;

126 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this code, Ihave three versions of acopyfunction:
normal_copy This is just aplain for-loop that copiescharacters from one arrayto another.
duffs_device This is calledDuff&amp;rsquo;s device, named after TomDuff, the personto blame for this delicious evil.
zeds_device A versionof
Duff&amp;rsquo;s devicethat just&lt;/p&gt;

&lt;p&gt;uses a goto soyou can clue into what&amp;rsquo;s happening with the weird do-while placementin duffs_device.
Study these three functions beforecontinuing. Try to explain what&amp;rsquo;sgoing onto yourself.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;sno output from this program, itjust runs and exits. Run it under your debugger tosee ifyou can catch any more errors. Try causing some of yourown, as I showed you in Exercise
4.
Solving the Puzzle&lt;/p&gt;

&lt;p&gt;The first thing tounderstand&lt;/p&gt;

&lt;p&gt;is that C is ratherloose regardingsome of its syntax. This is why you canputhalf ofa do-while in one part ofa switch-statement, then the other half somewhere else, and the code will stillwork. If you look at myversion with the goto again,it&amp;rsquo;s actuallymore clearwhat&amp;rsquo;sgoing on, but makesure you understand how thatpart works.&lt;/p&gt;

&lt;p&gt;The secondthing is howthe defaultfallthrough semantics of switch-statements let you jump to aparticular case, andthenit willjust keep running untilthe endof the switch.&lt;/p&gt;

&lt;p&gt;The final clue is the count %8 and thecalculationof n at the top.&lt;/p&gt;

&lt;p&gt;Now,to solvehow these functions work, do the following:
• Print thiscode outso thatyou canwriteon somepaper.&lt;/p&gt;

&lt;p&gt;• Write each of the variables in a table as theylook when they get initialized rightbefore the switch-statement.&lt;/p&gt;

&lt;p&gt;• Follow thelogicto the switch,then do the jump to the rightcase.&lt;/p&gt;

&lt;p&gt;• Update the variables, including the to, from, and the errays theypoint at.&lt;/p&gt;

&lt;p&gt;• When you getto the while part ormy goto alternative,check your variables, and then follow the logic either back to the top of the do-while or to where the again label is located.&lt;/p&gt;

&lt;p&gt;• Follow throughthis manual tracing, updating thevariables, until you&amp;rsquo;re sureyou seehow this flows.&lt;/p&gt;

&lt;p&gt;Why Bother?&lt;/p&gt;

&lt;p&gt;When you&amp;rsquo;vefigured outhow it actually works, the final questionis:Why would you ever want todo this? The purpose of this trick is to manually do loop unrolling. Large, long loops can be slow, so oneway to speed them up is to find somefixed chunk of the loop, and then just duplicate the code in the loop thatmany times sequentially. For example, if you know a loop runs a minimum of 20 times, then you can put the contents of the loop 20 timesin the source code.&lt;/p&gt;

&lt;p&gt;Duff&amp;rsquo;s device is basically doing this automatically by chunking upthe loop into eight iteration chunks.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s clever and actually works, but these days a good compiler will do this for you. You shouldn&amp;rsquo;t need this except in the rare casewhere you have proven it would improve your speed.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Never use thisagain.&lt;/p&gt;

&lt;p&gt;• Go look at the Wikipedia entry for Duff&amp;rsquo;s deviceand seeif you can spot the error. Read the erticle, compareit to the version Ihave here, and try to understandwhy the Wikipedia code won&amp;rsquo;twork for you but workedfor Tom Duff.&lt;/p&gt;

&lt;p&gt;• Create asetof macros that letsyoucreate any length of devicelike this. For example,what if you wanted to have 32 case statements and didn&amp;rsquo;t want to write out all of them?Can you do amacro that laysdown eight at atime?&lt;/p&gt;

&lt;p&gt;• Change the main to conductsome speed tests to see which oneis really the fastest.&lt;/p&gt;

&lt;p&gt;• Readabout memcpy, memmove, and memset, and also compare their speed.&lt;/p&gt;

&lt;p&gt;• Never use this again!&lt;/p&gt;

&lt;h2 id=&#34;exercise24-input-output-files:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise24. Input, Output, Files&lt;/h2&gt;

&lt;p&gt;You&amp;rsquo;ve been using printfto print things, and that&amp;rsquo;s great and all, but you need more. In this exercise,you&amp;rsquo;ll be using the functions fscanf and fgets to build informationabout aperson in astructure.&lt;/p&gt;

&lt;p&gt;After this simple introduction about reading input, you&amp;rsquo;ll get a full lis tof the functionsthat C has for I/O. Some of these you&amp;rsquo;ve already seen andused, so this will be another memorization exercise.&lt;/p&gt;

&lt;p&gt;ex24.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 
2 #include &amp;quot;dbg.h&amp;quot; 
3 
4 #define MAX_DATA 100 
5 
6 typedef enum EyeColor {
7 BLUE_EYES,GREEN_EYES,BROWN_EYES,
8 BLACK_EYES,OTHER_EYES 
9 } EyeColor;
1. 
11 const char *EYE_COLOR_NAMES[] = {
12 &amp;quot;Blue&amp;quot;,&amp;quot;Green&amp;quot;, &amp;quot;Brown&amp;quot;,&amp;quot;Black&amp;quot;, &amp;quot;Other&amp;quot; 
13 }; 
1. 
15 typedef struct Person {
16 int age;
17 char first_name[MAX_DATA]; 
18 char last_name[MAX_DATA]; 
19 EyeColor eyes;
20 float income;
21 } Person;
2. 
23 int main(int argc, char *argv[]) 
24 {
25 Person you = {.age = 0 }; 
26 int i = 0;
27 char *in = NULL;
2. 
29 printf(&amp;quot;What your First Name? &amp;quot;); 
30 in = fgets(you.first_name,MAX_DATA -1, stdin); 
31 check(in != NULL, &amp;quot;Failed to read first name.&amp;quot;); 
32 
33 printf(&amp;quot;What your Last Name? &amp;quot;); 
34 in = fgets(you.last_name,MAX_DATA -1, stdin); 
35 check(in != NULL, &amp;quot;Failed to read last name.&amp;quot;); 
36 
37 printf(&amp;quot;How old are you? &amp;quot;); 
38 int rc = fscanf(stdin, &amp;quot;%d&amp;quot;,&amp;amp;you.age); 
39 check(rc &amp;gt; 0, &amp;quot;You have to enter a number.&amp;quot;); 
40 
41 printf(&amp;quot;What color are your eyes:\n&amp;quot;); 
42 for (i = 0;i &amp;lt;= OTHER_EYES; i++){
43 printf(&amp;quot; %s\n&amp;quot;, i + 1,EYE_COLOR_NAMES[i]); 
44 }
45 printf(&amp;quot;&amp;gt; &amp;quot;);
46 
47 int eyes = -1;
48 rc = fscanf(stdin, &amp;quot;%d&amp;quot;,&amp;amp;eyes); 
49 check(rc &amp;gt; 0, &amp;quot;You have to enter a number.&amp;quot;); 
50 51 you.eyes = eyes -1;
52 check(you.ey&amp;lt;= OTHER_EYES 
53 &amp;amp;&amp;amp; you.eyes &amp;gt;= 0, &amp;quot;Do it right, that&#39;s not an option.&amp;quot;); 
54 
55 printf(&amp;quot;How much do you make an hour? &amp;quot;); 
56 rc = fscanf(stdin, &amp;quot;%f&amp;quot;,&amp;amp;you.income); 
57 check(rc &amp;gt; 0, &amp;quot;Enter a floating point number.&amp;quot;); 
58 
59 printf(&amp;quot;--­--RESULTS -----\n&amp;quot;); 
60 
61 printf(&amp;quot;Firs Name: %s&amp;quot;, you.first_name); 
62 printf(&amp;quot;Last Name: %s&amp;quot;, you.last_name); 
63 printf(&amp;quot;Age: %d\n&amp;quot;, you.age); 
64 printf(&amp;quot;Eyes %s\n&amp;quot;,EYE_COLOR_NAMES[you.ey
65 printf(&amp;quot;Inco %f\n&amp;quot;, you.income); 
66 
67 return 0;
68 error: 
69 
70 return -1;
71 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This programis deceptively simple, and introducesa function called fscanf, which is the file scanf. The scanf family of functions are theinverseof the printf versions. Where printf printed outdata based on aformat, scanf reads (orscans) inputbased on a format.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s nothing original in the beginning of the file, so here&amp;rsquo;s what the main is doingin the program:&lt;/p&gt;

&lt;p&gt;ex24.c:24-28 Sets up&lt;/p&gt;

&lt;p&gt;somevariables we&amp;rsquo;ll
need.&lt;/p&gt;

&lt;p&gt;ex24.c:30-32 Getsyour&lt;/p&gt;

&lt;p&gt;first name using the&lt;/p&gt;

&lt;p&gt;fgets function, which reads a string from the input (in thiscase stdin), but makes sure itdoesn&amp;rsquo;t overflow the given buffer.&lt;/p&gt;

&lt;p&gt;ex24.c:34-36 Same thing for you.last_name, againusing fgets.&lt;/p&gt;

&lt;p&gt;ex24.c:38-39 Uses fscanf to read an integer from stdin and put it into you.age. You can see that the same format string is usedas printf to print an integer. You should also see thatyou have to give the address of you.age so that fscanf has apointer to itand can modify it. This isagoodexample ofusing a pointer toa piece of data as an out parameter.&lt;/p&gt;

&lt;p&gt;ex24.c:41-45 Prints out all of the optionsavailable for eye color, with a matching number that works with the EyeColor enum above.&lt;/p&gt;

&lt;p&gt;ex24.c:47-50 Using fscanf again,getsa number for the you.eyes, butmake sure theinput is valid.&lt;/p&gt;

&lt;p&gt;This isimportant because someone can enter avalue outside the EYE&lt;em&gt;COLOR&lt;/em&gt; NAMES array and cause a
segmentationfault.&lt;/p&gt;

&lt;p&gt;ex24.c:52-53 Getshow much you make as a float for the you.income.&lt;/p&gt;

&lt;p&gt;ex24.c:55-61 Prints everythingoutso you can seeif you haveit right. Notice that
EYE_COLOR_NAMES&lt;/p&gt;

&lt;p&gt;isused toprint outwhat the EyeColor enumis actually called.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;When yourunthis program, you should see your inputs being properlyconverted. Make sure you try to giveit bogus inputtoo, so you can seehow itprotects against the input.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 24 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ make ex2. cc -Wall -g ­DNDEBUG ex24.c ­o ex2.
$ ./ex24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s your First Name? Zed What&amp;rsquo;s your Last Name? Shaw How old are you? 37 What color are your eyes:
1) Blue
2) Green
3) Brown
4) Black
5) Other
&amp;gt;1
How much do you make an hour? 1.2345 &amp;mdash;&amp;ndash;RESULTS &amp;mdash;-­First Name: Zed Last Name: Shaw Age: 37 Eyes: Blue Income: 1.234500&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;This is all fine and good, but
the really important part of&lt;/p&gt;

&lt;p&gt;this exercise is how scanf actually sucks. It&amp;rsquo;s fine for a simple conversion of numbers, but fails for strings because it&amp;rsquo;s difficult to tell scanf how biga buffer is before you read it. There&amp;rsquo;s also a problem with the function gets (not fgets, the non-f version), which we avoided. That functionhasno idea how big the inputbuffer is atall andwill just trash your program. To demonstrate theproblems with fscanf andstrings, change the linesthatuse fgets so they are fscanf(stdin,&amp;ldquo;%50s&amp;rdquo;,you.first_name), and thentry to use it again. Notice it seems to read too much and theneatyour enter key?This doesn&amp;rsquo;tdo what you think it does, andrather thandeal with weird scanf issues,
you should justuse fgets. Next, change the fgets to use gets,then run your debugger on ex24. Do this inside:
&amp;ldquo;run &amp;lt;&amp;lt; /dev/urandom&amp;rdquo;&lt;/p&gt;

&lt;p&gt;This feeds randomgarbage into your program. This is calledfuzzing yourprogram, and it&amp;rsquo;s agood way to find input bugs. In this case, you&amp;rsquo;re feedinggarbage from the /dev/urandom file (device), and thenwatchingit crash. Insome platforms,you mayhave todo this a few times, or evenadjust the MAX_DATA definesoit&amp;rsquo;s smallenough.&lt;/p&gt;

&lt;p&gt;The gets function is so bad thatsome platforms actually warn you when the program runs thatyou&amp;rsquo;re using gets. You should never use this function, ever. Finally,take the inputfor you.eyes andremove the check that thenumberis within the rightrange. Then, feedit bad numbers like -1 or 1000. Do this under the debugger so you can see what happens there,too.&lt;/p&gt;

&lt;p&gt;The I/O Functions&lt;/p&gt;

&lt;p&gt;This is ashortlist ofvarious I/O functions thatyoushould look up. Create flashcards thathave the functionname and allthe variants similar to it.&lt;/p&gt;

&lt;p&gt;• fscanf  • fgets  • fopen  • freopen  • fdopen  • fclose  • fcloseall   • fgetpos   • fseek  • ftell  • rewind  • fprintf   • fwrite  • fread&lt;/p&gt;

&lt;p&gt;Go through these and
memorize thedifferent&lt;/p&gt;

&lt;p&gt;variants and what they do. For example, forthe card fscanf, you&amp;rsquo;ll have scanf, sscanf, vscanf, etc., and thenwhat each of thosedoes on the back.&lt;/p&gt;

&lt;p&gt;Finally,use man to read the helpfor each variantto get the information you need for the flash cards. Forexample, the page for fscanf comes from man fscanf.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Rewritethis to not use fscanf at all. You&amp;rsquo;ll need tousefunctions like atoi to convert the inputstrings to numbers.&lt;/p&gt;

&lt;p&gt;• Change this to use plain scanf instead of fscanf to see what the differenceis.&lt;/p&gt;

&lt;p&gt;• Fix itso that their input namesget strippedof the trailing newline characters andany white space.&lt;/p&gt;

&lt;p&gt;• Use scanf towrite a function that reads one character at a time and fillsin thenames but doesn&amp;rsquo;tgo past the end. Make this function generic so itcantake a sizefor the string, but just make sureyouend&lt;/p&gt;

&lt;p&gt;the string with &amp;lsquo;\0&amp;rsquo; no matter what.&lt;/p&gt;

&lt;h2 id=&#34;exercise25-variable-argument-functions:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise25. Variable Argument Functions&lt;/h2&gt;

&lt;p&gt;In C, you can createyour own versions of functions like printf and scanf by creatinga variable argument function, orvararg function.&lt;/p&gt;

&lt;p&gt;Thesefunctions use the header stdarg.h, and with them,you cancreate nicer interfacesto your library. They arehandyfor certain typesof builder functions, formatting functions, and anything thattakes variable arguments.
Understanding vararg functions is not essentialto creatingC programs. Ithink I&amp;rsquo;ve used itmaybe 20 times in my codein all of the years I&amp;rsquo;ve beenprogramming. However, knowing howa varargfunction works will helpyou debug the programs you use and gives you a better understandingof the computer.&lt;/p&gt;

&lt;p&gt;ex25.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

1 
2 
3 #include &amp;lt;stdlib.h&amp;gt; 
4 #include &amp;lt;stdio.h&amp;gt; 
5 #include &amp;lt;stdarg.h&amp;gt; 
6 #include &amp;quot;dbg.h&amp;quot; 
7 
8 #define MAX_DATA 100 
9 
10 int read_string(char **out_string, int max_buffer)
11 {
12 *out_string = calloc(1,max_buffer + 1); 
13 check_mem(*o 
1. 
15 char *result = fgets(*out_string,max_buffer, stdin); 
16 check(result != NULL, &amp;quot;Input error.&amp;quot;); 
1. 
18 return 0; 
1. 
20 error: 
21 if (*out_string)free(*out_string); 
22 *out_string = NULL;
23 return -1;
24 }
2. 
26 int read_int(int *out_int)
27 {
28 char *input = NULL; 
29 int rc = read_string(&amp;amp;input,MAX_DATA); 
30 check(rc == 0, &amp;quot;Failed to read number.&amp;quot;); 
31 
32 *out_int = atoi(input); 
free(input); 
33  
34 
35 
36  free(input);return 0;  
37  error:  
38  if (input) 
39 return -1;
40 }
41 
42 int read_scan(const char *fmt, ...) 
43 {
44 int i = 0;
45 int rc = 0;
46 int *out_int = NULL;
47 char *out_char = NULL;
48 char **out_string = NULL;
49 int max_buffer = 0;
50 
51 va_list argp;
52 va_start(arg fmt);
53 
54 for (i = 0; fmt[i] != &#39;\0&#39;; i++){
55 if (fmt[i] == &#39;%&#39;){ 
56 i++;
57 swit (fmt[i]) { 
58 &#39;\0&#39;: 
59 format, you ended with %%.&amp;quot;); 
60 
61 
62 
&#39;d&#39;: 
63 = va_arg(argp, int *);
64 = read_int(out_int); 
65 == 0, &amp;quot;Failed to read int.&amp;quot;); 
66 
67 
68 &#39;c&#39;: 
69 = va_arg(argp, char *);
70 = fgetc(stdin); 
71 
72 
73 &#39;s&#39;: 
74 = va_arg(argp, int); 
75 = va_arg(argp, char **); 
76 = read_string(out_string max_buffer); 
77 == 0, &amp;quot;Failed to read string.&amp;quot;); 
78 
79 
80 
81 format.&amp;quot;); 
82 }
83 } else { 
85 }
86 
84 fget 
87 check(!f &amp;amp;&amp;amp; !ferror(stdin), &amp;quot;Input error.&amp;quot;); 
88 
89  }  
90 
91 
92  va_end(argp)return 0;  
93  error:  
94 
95 
96 
97  }  va_end(argp)return -1;  
98  int main(int argc, char *argv[]) 
99 {
100 char *first_name = NULL;
101 char initial = &#39;&#39;;
102 char *last_name = NULL;
103 int age = 0;
104 
105 printf(&amp;quot;What your first name? &amp;quot;); 106 int rc = read_scan(&amp;quot;%s&amp;quot;,MAX_DATA, &amp;amp;first_name); 
107 check(rc == 0, &amp;quot;Failed first name.&amp;quot;); 
108 
109 printf(&amp;quot;What your initial? &amp;quot;); 
110 rc = read_scan(&amp;quot;%c\n&amp;quot;, &amp;amp;initial); 
111 check(rc == 0, &amp;quot;Failed initial.&amp;quot;); 
11. 
113 printf(&amp;quot;What your last name? &amp;quot;); 
114 rc = read_scan(&amp;quot;%s&amp;quot;, MAX_DATA, &amp;amp;last_name); 
115 check(rc == 0, &amp;quot;Failed last name.&amp;quot;); 
11. 
117 printf(&amp;quot;How old are you? &amp;quot;); 
118 rc = read_scan(&amp;quot;%d&amp;quot;, &amp;amp;age); 
11. 
120 printf(&amp;quot;--­-RESULTS ----\n&amp;quot;); 
121 printf(&amp;quot;Firs Name: %s&amp;quot;,first_name); 
122 printf(&amp;quot;Init &#39;%c&#39;\n&amp;quot;, initial); 
123 printf(&amp;quot;Last Name: %s&amp;quot;,last_name); 
124 printf(&amp;quot;Age: %d\n&amp;quot;, age); 
125 
126 free(first_n 
127 free(last_na 
128 return 0;
129 error: 
130 return -1. 
131 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This programis similar to the previous exercise, except I havewritten my own scanf function tohandle strings the way Iwant. The main function should be clear to you,as wellas the two functions read_string and read_int, sincethey do nothing new.&lt;/p&gt;

&lt;p&gt;The varargs functionis called
read_scan, anditdoes the&lt;/p&gt;

&lt;p&gt;same thing that scanf is doing using the va_list data structure andsupporting macros andfunctions. Here&amp;rsquo;s how:
• Iset as the last parameter of the function thekeyword &amp;hellip; to indicateto C that this function will take any number of arguments after the fmt argument. I could put&lt;/p&gt;

&lt;p&gt;many other arguments
beforethis, but Ican&amp;rsquo;t
putany more after this.&lt;/p&gt;

&lt;p&gt;• Aftersetting up some variables, I createa va_list variableand initializeit with va_start. This configures thegear in stdarg.h that handles variable arguments.&lt;/p&gt;

&lt;p&gt;• Ithen use a for-loop to loop through the format string fmt and processthe same kind offormats that scanf has,onlymuch simpler. I just have integers, characters, and strings.&lt;/p&gt;

&lt;p&gt;• When I hit aformat, I use the switch-statement tofigure outwhattodo.&lt;/p&gt;

&lt;p&gt;• Now, to get a variable fromthe va_list argp,I use the macro va_arg(argp,TYPE) where TYPE is the exacttype of what I willassign this function parameter to. The downsideto thisdesign isthatyou&amp;rsquo;re flying blind, so ifyou don&amp;rsquo;t have enough parameters,then oh well, you&amp;rsquo;ll most likely crash.&lt;/p&gt;

&lt;p&gt;• The interesting difference from scanf isI&amp;rsquo;m assuming that people want read_scan tocreate the stringsit reads when it hitsan &amp;rsquo;s&amp;rsquo; format sequence. When you givethis sequence,the function takestwo parameters off the va_list argp stack:the maxfunction sizeto read, and the outputcharacter string pointer. Using that information, itjust runs read_string todo the realwork.&lt;/p&gt;

&lt;p&gt;• This makes read_scan more consistent than scanf, since you always give an address-of &amp;amp; on variables tohave them setappropriately.&lt;/p&gt;

&lt;p&gt;• Finally, if the function encounters acharacter that&amp;rsquo;s notin the correct format,it just reads one charto skipit. It doesn&amp;rsquo;tcarewhat that charis, just that it should skip it.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;When yourunthis one, it&amp;rsquo;s similarto the last one.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 25 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ make ex2. cc -Wall -g ­DNDEBUG ex25.c ­o ex2.
$ ./ex25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s your first name? Zed What&amp;rsquo;s your initial? A What&amp;rsquo;s your last name? Shaw How old are you? 37 &amp;mdash;-RESULTS &amp;mdash;­First Name: Zed Initial: &amp;lsquo;A&amp;rsquo; Last Name: Shaw Age: 37&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;This programshould be more robustagainstbuffer overflows, but it doesn&amp;rsquo;t handle the formatted inputas wellas scanf. To try to break this, change the code so thatyou forget topass in the initial size for ‘%s&amp;rsquo; formats. Try giving it moredata than MAX_DATA, and then see how omitting calloc in read_string changes how it works. Finally,there&amp;rsquo;s a problem where fgets eats the newlines, so try tofix that using fgetc, butleave out the \0 that ends thestring.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Makedouble andtriple sure that you know whateach of the out_ variables is doing. Most importantly, you should know what out_string is and how it&amp;rsquo;s a pointer to a pointer,sothat you understand when you&amp;rsquo;re setting thepointer versusthe contents is important.&lt;/p&gt;

&lt;p&gt;• Write a similarfunction to printf that uses the varargssystem, and rewrite main to use it.
• As usual,read theman page on all ofthis so thatyou knowwhatit does on your platform. Some platforms willuse macros,others will use functions, and some will have thesedo nothing. It alldepends on thecompiler and the platformyouuse.&lt;/p&gt;

&lt;h2 id=&#34;exercise26-project:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise26. Project&lt;/h2&gt;

&lt;p&gt;logfind&lt;/p&gt;

&lt;p&gt;This is asmall project for you to attempt on yourown. To be effective at C, you&amp;rsquo;ll need to learn toapplywhat you know toproblems. In this exercise, Idescribe atoolI wantyou to implement, andI describe it in a vague way on purpose. This is done so that you willtry to implement whateveryou can, however you can. When you&amp;rsquo;redone, you can thenwatcha video for the exercise that shows you how I didit, and then you can get the code and compare it to yours.&lt;/p&gt;

&lt;p&gt;Think ofthis projectas a real­worldpuzzle that you might have to solve.&lt;/p&gt;

&lt;p&gt;The logfind
Specification&lt;/p&gt;

&lt;p&gt;I want atoolcalled logfind that lets me search through log filesfor text. This tool is aspecializedversion of another tool called grep, butdesigned only for log files on a system. Theidea isthatI can type:
logfind zedshaw&lt;/p&gt;

&lt;p&gt;And,it willsearch allthe common places that log files are stored, andprint out every filethat has theword &amp;ldquo;zedshaw&amp;rdquo; in it.&lt;/p&gt;

&lt;p&gt;The logfind tool should
have thesebasic features:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This tool takesany sequenceof wordsand assumes Imean &amp;ldquo;and&amp;rdquo; for them. So logfind zedshaw smart guy willfind all files thathave zedshaw and smart and guy in them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ittakes an optional argument of -o if the parameters are meant to be or logic.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Itloads thelist of allowed log filesfrom ~/.logfind.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The lis tof file names can be anything that the glob function allows. Refer to man 3 globto see howthis works. I suggest starting with just a flat list of exact files, andthenadd glob functionality.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You shouldoutput the matching linesas you scan, and try to match them asfast aspossible.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That&amp;rsquo;s the entire description.&lt;/p&gt;

&lt;p&gt;Remember that this may be
very hard, so takeit atinybit&lt;/p&gt;

&lt;p&gt;at atime. Write some code, test it, write more, test that, and so on in little chunks until you haveit working. Start with thesimplest thing thatgets it working, andthen slowly add to it and refine it until every featureisdone.&lt;/p&gt;

&lt;h2 id=&#34;exercise27-creative-and-defensive-programming:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise27. Creative and Defensive Programming&lt;/h2&gt;

&lt;p&gt;You have now learnedmost of the basics of C programming andare ready to start becoming a serious programmer. This is where you go from beginner to expert, both with C and hopefullywithcore computer science concepts. I will be teaching you a few of the coredata structures and algorithmsthat every programmershould know, and then a fewvery interesting onesI&amp;rsquo;ve used in realsoftware for years.&lt;/p&gt;

&lt;p&gt;Before I cando that, Ihave to teach you some basic skills and ideasthat will help you makebetter software. Exercises 2. through 31
will teach you advancedconcepts, featuring moretalking than coding. Afterthat, you&amp;rsquo;ll apply what you&amp;rsquo;velearned to make a core library ofuseful data structures.&lt;/p&gt;

&lt;p&gt;The first step in getting better at writing C code(and really any language)is to learn a new mind-set called defensive programming. Defensive programming assumes that you are going to make many mistakes, and then attempts to prevent thematevery possible step. In this exercise, I&amp;rsquo;m going to teachyouhow to thinkabout programming defensively.&lt;/p&gt;

&lt;p&gt;The Creative Programmer Mind-Set&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s notpossibleto show you how to be creativein ashort exerciselike this, but Iwill tellyou that creativity involvestaking risksand being open-minded. Fear will quicklykillcreativity, so the mind-set I adopt, andmany programmerscopy, is that accidents are designedto make youunafraid of taking chances and looking like an idiot. Here&amp;rsquo;s mymind-set:
• I can&amp;rsquo;t make a mistake.&lt;/p&gt;

&lt;p&gt;• It doesn&amp;rsquo;t matter what people think.&lt;/p&gt;

&lt;p&gt;• Whatever mybrain comesup with is going to be a great idea.&lt;/p&gt;

&lt;p&gt;I only adopt this mind-set temporarily, andeven have little tricks to turnit on. By doing this,I can come up with ideas, find creative solutions,open my thoughts to odd connections, andjust generally invent weirdness without fear. In thismind-set, I&amp;rsquo;ll typically write a horrible first versionof something just to get the idea out.&lt;/p&gt;

&lt;p&gt;However, when I&amp;rsquo;vefinished mycreative prototype, Iwill throwit out and getserious about making it solid. Where other people make a mistake is carrying the creativemind­set into their implementation phase. This then leads to a very different, destructive mind-set: thedarkside of the creative mind-set:
• It&amp;rsquo;s possible towrite perfect software.&lt;/p&gt;

&lt;p&gt;• Mybrain tells methe truth, andit can&amp;rsquo;tfind any errors: I have therefore written perfect software.&lt;/p&gt;

&lt;p&gt;• Mycode is who I am and peoplewho criticize its perfection are criticizing me.&lt;/p&gt;

&lt;p&gt;Theseare lies. Youwill frequently run into programmers who feel intense pride about what they&amp;rsquo;vecreated, which is natural, but this pridegets in the way of theirability to objectively improvetheir craft. Because of this pride and attachmenttowhat they&amp;rsquo;vewritten, they can continueto believe that what theywrite isperfect. As long asthey ignore other people&amp;rsquo;s criticismof theircode,they can protect theirfragile egos and neverimprove.&lt;/p&gt;

&lt;p&gt;The trick to being creative and makingsolidsoftware is the ability to adopt a defensiveprogramming mind-set.&lt;/p&gt;

&lt;p&gt;The Defensive Programmer Mind-Set&lt;/p&gt;

&lt;p&gt;After you have aworking, creative prototype and you&amp;rsquo;re feelinggoodabout the idea, it&amp;rsquo;stime to switchto being a defensiveprogrammer. The defensiveprogrammer basically hates your code and believes these things:
• Softwarehaserrors.&lt;/p&gt;

&lt;p&gt;• You aren&amp;rsquo;tyour software, yetyou&amp;rsquo;re responsible for the errors.&lt;/p&gt;

&lt;p&gt;• You can never remove the errors,onlyreduce their probability.&lt;/p&gt;

&lt;p&gt;This mind-set lets you be honest about yourwork and critically analyzeit for improvements. Notice that it doesn&amp;rsquo;tsay you are full of errors?It says your code is full oferrors. This is asignificant thing to understand becauseit gives you the powerof objectivity for the next implementation.&lt;/p&gt;

&lt;p&gt;Just likethe creative mind-set,the defensive programming mind-set has a dark side, as well. Defensive programmersare paranoid, and this fearprevents them fromever possibly being wrongor making mistakes.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s greatwhen you&amp;rsquo;re trying to be ruthlessly consistentand correct, butit&amp;rsquo;s murder oncreative energy and concentration.&lt;/p&gt;

&lt;p&gt;The Eight Defensive Programmer Strategies&lt;/p&gt;

&lt;p&gt;Once you&amp;rsquo;ve adopted this mind-set,you can then rewriteyour prototypeand follow asetof eight strategies to make yourcode assolidas possible. While I workon the realversion,I ruthlessly follow these strategies and try to remove as many errors as I can, thinking like someone who wantsto break the software.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Never Trust Input &amp;ndash; Never trust the datayou&amp;rsquo;re given andalways validate it.
Prevent Errors If an erroris possible, no matter how probable, try to prevent it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;FailEarly and Openly &amp;ndash; Failearly, cleanly, and openly, stating what happened, where, and how to fix it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Document Assumptions &amp;ndash; Clearly state the pre­conditions, post­conditions, and invariants.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Prevention over Documentation. &amp;ndash; Don&amp;rsquo;t do with documentation that whichcan be done with code or avoided completely.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;AutomateEverything &amp;ndash; Automate everything, especially testing.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Simplify and Clarify &amp;ndash; Always simplify the code to the smallest, cleanestform that works without sacrificing safety.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Question Authority &amp;ndash;  Don&amp;rsquo;t blindly follow or reject rules.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thesearen&amp;rsquo;t the only strategies, but they&amp;rsquo;re the core things Ifeel programmers have to focus on when trying to make good, solid code. Notice that I don&amp;rsquo;treallysay exactly how to do these. I&amp;rsquo;ll go into each of thesein more detail, and some of the exerciseswillactually cover them extensively.&lt;/p&gt;

&lt;p&gt;Applying the Eight Strategies&lt;/p&gt;

&lt;p&gt;These ideas are all as great pop-psychology platitudes, buthow do you actually apply them to working code? I&amp;rsquo;m now going to give you a set of thingsto alwaysdo in this book&amp;rsquo;s codethat demonstrates each one with a concrete example. The ideas aren&amp;rsquo;t limited tojust these examples, so you should use these as aguideto making your own codemore solid.&lt;/p&gt;

&lt;p&gt;Never Trust Input&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at an exampleof bad designand better design. I won&amp;rsquo;t say good design because this could be done even better. Take a look at these two functions that both copy astring and a simple main to testout thebetter one.&lt;/p&gt;

&lt;p&gt;ex27_1.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1
2 #undef NDEBUG #include &amp;quot;dbg.h&amp;quot; 
3 #include &amp;lt;stdio.h&amp;gt; 
4 #include &amp;lt;assert.h&amp;gt; 
/* 
7
5
6 * Naive copy that assumes all inputs are always valid 
8 * taken from K&amp;amp;R C and cleaned up A bit. 
9 */ 
10 void copy(char to[], char from[]) 
11 {
12 int i = 0;
1. 14 // while loop will not end if from isn&#39;t &#39;\0&#39; terminated 
15 while ((to[i]= from[i]) != &#39;\0&#39;){ 
16 ++i;
1. } 
1. }
1. 
20 /* 
21 * A safer version that checks for many common errors using the
22 * length of each string to control the loops and termination. 
23 */ 
24 int safercopy(int from_len, char *from,int to_len, char *to)
 25 {
26 assert(from != NULL &amp;amp;&amp;amp; to != NULL &amp;amp;&amp;amp; &amp;quot;from and to can&#39;t be NULL&amp;quot;); 
27 int i = 0;
28 int max = from_len &amp;gt; to_len -1 ? to_len -1: from_len;
2. 
30 // to_len must have at least 1 byte 
31 if (from_len &amp;lt; 0 || to_len &amp;lt;= 0)
32 return -1;
33 
34 for (i = 0;i &amp;lt; max; i++) { 
35 to[i]= from[i]; 
36 }
37 
38 to[to_len ­
1] = &#39;\0&#39;;
39 
40 return i;
41 }
42 

43 int main(int argc, char *argv[]) 
44 {
45 // careful to understand why we can get these sizes 
46 char from[] = &amp;quot;0123456789&amp;quot;;
47 int from_len = sizeof(from); 
48 
49 // notice that it&#39;s 7 chars + \0 
50 char to[] = &amp;quot;0123456&amp;quot;; 
51 int to_len = sizeof(to); 
52 
53 debug(&amp;quot;Copyi &#39;%s&#39;:%d to &#39;%s&#39;:%d&amp;quot;,from, from_len, to,to_len); 
54 
55 int rc = safercopy(from_len,from, to_len, to); 
56 check(rc &amp;gt; 0, &amp;quot;Failed to safercopy.&amp;quot;); 
57 check(to[to_ -1] == &#39;\0&#39;, &amp;quot;String not terminated.&amp;quot;); 
58 

59 debug(&amp;quot;Resul is: &#39;%s&#39;:%d&amp;quot;, to,to_len); 
60 
61 // now try to break it 
62 rc = safercopy(from_len * -1, from, to_len,to);
63 check(rc == -1, &amp;quot;safercopy should fail #1&amp;quot;); 
64 check(to[to_ -1] == &#39;\0&#39;, &amp;quot;String not terminated.&amp;quot;); 
65 
66 rc = 
safercopy(from_len,from, 0, to); 
67 check(rc == -1, &amp;quot;safercopy should fail #2&amp;quot;); 
68 check(to[to_ -1] == &#39;\0&#39;, &amp;quot;String not terminated.&amp;quot;); 
69  
70 
71  return 0;  
72  error:  
73 
74  }  return 1;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The copy function is typical C code and it&amp;rsquo;s the sourceof ahugenumberof buffer overflows. It&amp;rsquo;s flawed because itassumes that it will alwaysreceive a valid, terminated C string(with &amp;lsquo;\0&amp;rsquo;), andjust uses a while-loop to processit. Problem is, to ensure that is incredibly difficult, and if it&amp;rsquo;s not handled right, itcauses the while-loop to loop infinitely. A cornerstone of writing solid code is never writing loops that can possibly loop forever.&lt;/p&gt;

&lt;p&gt;The safercopy function triesto solvethis byrequiring the caller to give thelengths of the twostrings it must deal with. By doing this,it can makecertain checks about these stringsthat the copy function can&amp;rsquo;t. It can check that the lengths areright, and that the to string has enough space, and it will always terminate. It&amp;rsquo;simpossiblefor this functionto run onforever likethe copy function.&lt;/p&gt;

&lt;p&gt;This is the ideabehind never trusting the inputsyou receive. If you assumethat your functionisgoing to get a string that&amp;rsquo;s not terminated (whichis common), thenyou can design yourfunction so that it doesn&amp;rsquo;t rely onit to work properly. If you need the argumentsto never be NULL,then you shouldcheck for that, too. Ifthe sizes should bewithin sane levels, thencheck that. You simply assumethat whoever is calling you got it wrong, and thentry to makeit difficult for them to give you another bad state.&lt;/p&gt;

&lt;p&gt;This extends to software you write thatgets input from the externaluniverse. The famouslastwords of the programmerare, &amp;ldquo;Nobody&amp;rsquo;s going to do that.&amp;rdquo; I&amp;rsquo;ve seen them say thatand then the next day someone does exactly that, crashing or hacking theirapplication. If you say nobody isgoing todo that, just throw in the codeto makesure they simplycan&amp;rsquo;t hack your application. You&amp;rsquo;ll be glad you did.&lt;/p&gt;

&lt;p&gt;There is a diminishing return on this, buthere&amp;rsquo;s a lis tof things Itry todo inallof the functions I writein C:&lt;/p&gt;

&lt;p&gt;• For eachparameter, identify what its preconditions are, and whetherthe precondition should cause afailure or return an error. If you are writing a library,favor errors over failures.&lt;/p&gt;

&lt;p&gt;• Add assert calls at the beginning that check for each failure precondition using assert(test &amp;amp;&amp;amp; &amp;ldquo;message&amp;rdquo;);. This little hack does the test, and when itfails, the OSwilltypically print the assert line for you thatincludesthat message. This is very helpful when you&amp;rsquo;re trying to figure outwhy that assert is there.&lt;/p&gt;

&lt;p&gt;• Forthe other preconditions, return the error code or use my check macro togive an errormessage. I didn&amp;rsquo;t use check in this example since it would confusethe comparison.&lt;/p&gt;

&lt;p&gt;• Document why these preconditions existso thatwhen a programmerhits the error, he or she can figure outif they&amp;rsquo;re really necessary ornot.&lt;/p&gt;

&lt;p&gt;• If you&amp;rsquo;re modifying the inputs, makesure that they are correctly formed when the function exits, or abort if they aren&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;• Always check the error codes of functions you use. For example, people frequently forget to check the return codes from fopen or fread,which causes them to use the resources thereturn codes give despite the error. This causes your programto crash or open an avenue for an attack.&lt;/p&gt;

&lt;p&gt;• You also need to be returning consistent errorcodes so thatyou can do this for all of your functions. Once you get in this habit, you&amp;rsquo;ll thenunderstand why my check macros work the way they do.&lt;/p&gt;

&lt;p&gt;Just doing these simple things will improve yourresource handling andprevent quite a fewerrors.
Prevent Errors&lt;/p&gt;

&lt;p&gt;Inresponseto theprevious example, you mighthe er people say, &amp;ldquo;Well, it&amp;rsquo;snot very likely someonewilluse copy wrong.&amp;rdquo; Despite the mountain of attacksmade against this very kindof function, Some people still believe that the probability of this error is very low. Probability is a funnything because peopleare incredibly bad atguessing the probability of any event. People are, however, much better at determining if something is possible. They mightsay the errorin copy is not probable, but they can&amp;rsquo;t denythat it&amp;rsquo;s possible.&lt;/p&gt;

&lt;p&gt;The key reason is thatfor something tobeprobable,it first has to be possible. Determining thepossibility is easy,since we can all imaginesomething happening. What&amp;rsquo;s not so easy is determining its probability after that. Isthe chancethat someonemight use copy wrong20%, 10%, or1%?Who knows?You&amp;rsquo;d need to gather evidence, look at rates of failurein many softwarepackages, and probably surveyreal programmersabouthowthey use the function.&lt;/p&gt;

&lt;p&gt;This means, if you&amp;rsquo;regoing to prevent errors, you still need to try to preventwhat&amp;rsquo;s possible but first focus your energies on what&amp;rsquo;s most probable.&lt;/p&gt;

&lt;p&gt;It may notbe feasible to handleallof the possible ways your software can be broken, butyou have to attempt it. But at thesame time,if you don&amp;rsquo;tconstrain your efforts to the most probable events, then you&amp;rsquo;ll be wasting time onirrelevant attacks. Here&amp;rsquo;s aprocessfor determining what to prevent in yoursoftware:&lt;/p&gt;

&lt;p&gt;• List all the possible errors that can happen, no matter how probable (within reason,of course). Nopoint listing &amp;ldquo;aliens sucking your memories outto steal your passwords.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;• Give each possible errora probabilitythat&amp;rsquo;s apercentage of the operations that can be vulnerable. If you are handling requests from the Internet, thenit&amp;rsquo;s the percentage of requests that cancause the error. If they are function calls, then it&amp;rsquo;s whatpercentage of function calls can cause the error.&lt;/p&gt;

&lt;p&gt;• Calculate the effortin number ofhours or amount of code to preventit. You could also just give aneasyor hard metric, orany metric that preventsyou fromworking on the impossible when there are easierthings to fix stillon the list.&lt;/p&gt;

&lt;p&gt;• Rank them by effort (lowest tohighest), and probability (highest to lowest). This is now your tasklist.&lt;/p&gt;

&lt;p&gt;• Prevent allof the errors you can in this list, aiming forremoving the possibility, then reducing the probability if you can&amp;rsquo;t make it impossible.&lt;/p&gt;

&lt;p&gt;• If there are errorsyou can&amp;rsquo;t fix, then document them so someone else can fix them.&lt;/p&gt;

&lt;p&gt;This little processwillgive you anice list of things todo, butmore importantly, keep you fromworking onuseless things when there are other more important things to work on. You canalso be more or lessformalwith this process.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re doinga full security audit, thiswillbe better done with awhole team and a nicespreadsheet. If you&amp;rsquo;re just writinga function, thensimply reviewthe code and scratch theseout into somecomments. What&amp;rsquo;s important isthat you stop assuming that errorsdon&amp;rsquo;t happen, and you workon removing them when you can without wasting effort.&lt;/p&gt;

&lt;p&gt;Fail Early and Openly&lt;/p&gt;

&lt;p&gt;If youencounteranerror in C you have two choices:
• Returnanerror code.&lt;/p&gt;

&lt;p&gt;• Abort the process.&lt;/p&gt;

&lt;p&gt;This is just how itis, so what you need todo is make sure the failures happen quickly, are clearly documented,give an errormessage, and are easy for theprogrammer to avoid. This iswhy the check macros I&amp;rsquo;ve given you work the way they do. For every error youfind,it prints a message, the file and linenumberwhereit happened, and forces are turn code. If youjust use my macros, you&amp;rsquo;llend updoing the right thing anyway.&lt;/p&gt;

&lt;p&gt;I tend to prefer returningan errorcode to aborting the program. If it&amp;rsquo;scatastrophic, thenI will, but very few errors are truly catastrophic. A good exampleof when I&amp;rsquo;ll abort a programis if I&amp;rsquo;m given an invalid pointer,as I didin safercopy. Instead ofhaving theprogrammer experiencea segmentation fault explosion somewhere, I catch itright awayand abort. However, if it&amp;rsquo;scommonto pass in a NULL,then I&amp;rsquo;ll probably change that to a check instead so that the callercan adaptand keep running.&lt;/p&gt;

&lt;p&gt;In libraries, however,I try my hardest to never abort. The software using my library can decideif itshould abort, and I&amp;rsquo;ll typically abortonlyif the library is very badly used.&lt;/p&gt;

&lt;p&gt;Finally,a big part of being open about errors is not using the samemessage orerror codeformore thanone possible error. You typically see this with errorsin external resources. A library will receive an erroron a socket, and then simplyreport &amp;ldquo;bad socket.&amp;rdquo; What they should do is return the erroron the socketsothat itcanbe properlydebuggedand fixed. When designing your error reporting, make sureyougive adifferent error message for the different possible errors.&lt;/p&gt;

&lt;p&gt;Document Assumptions&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;refollowingalongand using this advice, thenwhat you&amp;rsquo;re doing is buildinga contractof how your functions expect the world to be. You&amp;rsquo;vecreated preconditions for each argument, you&amp;rsquo;vehandled possible errors, and you&amp;rsquo;re failingelegantly. The next step is to complete the contractand add invariants and post conditions.&lt;/p&gt;

&lt;p&gt;An invariantis a condition thatmustbeheld true insome state while the function runs. This isn&amp;rsquo;t very common in simple functions, butwhen you&amp;rsquo;re dealing with complex structures,itbecomesmore necessary. Agood example of an invariant is a condition where astructureis always initialized properlywhileit&amp;rsquo;s being used. Another example wouldbethat a sorted data structure is always sorted during processing.&lt;/p&gt;

&lt;p&gt;A postcondition is a guaranteeon the exit value or result ofa functionrunning. This can blend together with invariants, but this is something as simple as &amp;ldquo;function always returns0or -1on error.&amp;rdquo; Usually these are documented, but ifyour function returns an allocated resource, you can adda postcondition that checks to makesure it&amp;rsquo;s returning something, andnot NULL. Or, you can use NULL to indicate an error,sothat your postcondition checksthat the resource is deallocated on any errors.&lt;/p&gt;

&lt;p&gt;In Cprogramming, invariants and postconditionsare usually usedmore in documentationthan actual codeor assertions. The best way to handle them is to add assert calls for theones you can,then document the rest. If you do that, when people hitan errorthey can see what assumptions you madewhenwriting the function.&lt;/p&gt;

&lt;p&gt;Prevention over Documentation&lt;/p&gt;

&lt;p&gt;A common problem when programmers write code is that they will document a common bug rather than simply fix it. My favorite is when the Ruby on Rails system simply assumed that all months had 30 days. Calendars are hard, so rather than fix it, programmers threw a tiny little comment somewhere thatsaid this was on purpose, and then they refused tofix it for years.&lt;/p&gt;

&lt;p&gt;Everytimesomeone would complain,theywould bluster and yell, &amp;ldquo;But it&amp;rsquo;s documented!&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Documentation doesn&amp;rsquo;t matter if you can actually fix the problem, and if the function has a fatalflaw, then just don&amp;rsquo;t includeituntil you can fix it. In the case of Ruby on Rails, not havingdate functions wouldhave been better than including
purposefully broken onesthat nobody could use.&lt;/p&gt;

&lt;p&gt;As you go through your defensive programming cleanups,try to fix everything you can. If you findyourself documenting moreand more problems you can&amp;rsquo;t fix,then considerredesigning the feature or simplyremoving it. If you really have to keep this horriblybrokenfeature,then I suggest you write it, document it, andthen finda new job before you are blamed forit.&lt;/p&gt;

&lt;p&gt;Automate Everything&lt;/p&gt;

&lt;p&gt;You are a programmer, and that means your job is putting other people out ofjobs with automation. The pinnacleof this is putting yourself out of ajob with your own automation. Obviously,you won&amp;rsquo;tcompletely eliminate what you do, butif you&amp;rsquo;re spending your whole day rerunning manual tests in your terminal, then your job isn&amp;rsquo;t programming. You are doing QA, and you should automateyourselfoutof this QA job that you probably don&amp;rsquo;t really want any way.&lt;/p&gt;

&lt;p&gt;The easiest way todo this is to writeautomatedtests, or unit tests. In this book I&amp;rsquo;m going to get into how to do this easily, but I&amp;rsquo;llavoid most of the dogmaaboutwhen you should writetests. I&amp;rsquo;llfocus on how towrite them,what to test, and how tobeefficientat the testing.&lt;/p&gt;

&lt;p&gt;Hereare common things programmersfail toautomate when theyshould:&lt;/p&gt;

&lt;p&gt;• Testing and validation&lt;/p&gt;

&lt;p&gt;• Build processes&lt;/p&gt;

&lt;p&gt;• Deployment of software&lt;/p&gt;

&lt;p&gt;• System administration&lt;/p&gt;

&lt;p&gt;• Errorreporting&lt;/p&gt;

&lt;p&gt;Try todevote some of your time to automating this and you&amp;rsquo;ll have more time to work on the fun stuff. Or, if this is fun to you, then maybe you should workon software
thatmakes automating these things easier.&lt;/p&gt;

&lt;p&gt;Simplify and Clarify&lt;/p&gt;

&lt;p&gt;The concept ofsimplicity is a slipperyone tomanypeople, especially smart people. They generally confuse comprehension with simplicity. Ifthey understand it, clearly it&amp;rsquo;ssimple. The actualtestof simplicityis comparingsomething with something else that could be simpler. But you&amp;rsquo;llsee people who write codego running to the most complex,obtuse structures possible because theythink thesimpler version of the same thingis dirty. A love affair with complexity is aprogramming sickness.&lt;/p&gt;

&lt;p&gt;You can fight this disease by first telling yourself, &amp;ldquo;Simple and clear is notdirty,no matter what everyone else is doing.&amp;rdquo; If everyoneelseis writing insane visitorpatterns involving 19 classes over 12 interfaces, andyou cando it with twostring operations, thenyou win. They are wrong, no matter how elegant theythink their complex monstrosity is.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the simplesttest of which function is better:&lt;/p&gt;

&lt;p&gt;• Make sure both functions haveno errors. Itdoesn&amp;rsquo;t matter how fast orsimple a function is ifit has errors.&lt;/p&gt;

&lt;p&gt;• If you can&amp;rsquo;tfixone, thenpick the other.&lt;/p&gt;

&lt;p&gt;• Dotheyproduce the same result? If not, then pickthe onethat has the result you need.&lt;/p&gt;

&lt;p&gt;• If theyproducethe same result, thenpick the onethateitherhas fewer features, fewer branches, oryou just think is simpler.&lt;/p&gt;

&lt;p&gt;• Make sure you&amp;rsquo;re not just picking theone that ismostimpressive.&lt;/p&gt;

&lt;p&gt;Simple and dirty beats complexand cleanany day.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll notice thatImostly giveup at the end andtell you to use yourjudgment. Simplicity is ironically a very complex thing, so using your taste asa guideis thebest way to go. Just make sure that you adjustyour view of what&amp;rsquo;s &amp;ldquo;good&amp;rdquo; as you grow and gain moreexperience.&lt;/p&gt;

&lt;p&gt;Question Authority&lt;/p&gt;

&lt;p&gt;The final strategy is themost important because itbreaks you outof thedefensive programming mind-set and lets you transition into the creative mind-set. Defensive programming is authoritarian and canbecruel. The job of this mind-setis to make you follow rules, becausewithout them you&amp;rsquo;ll miss something orget distracted.&lt;/p&gt;

&lt;p&gt;This authoritarian attitude has the disadvantageof disabling independentcreativethought. Rules arenecessary for getting things done, but being aslave to them will kill your creativity.&lt;/p&gt;

&lt;p&gt;This final strategymeans you should periodically question the rules you follow and assumethat they could be wrong, just likethe software you are reviewing. What I will typicallydo is gotake a nonprogramming break and let therules go after asession ofdefensive programming. Then I&amp;rsquo;llbereadyto do some creative workor more defensivecoding ifIneed to.&lt;/p&gt;

&lt;p&gt;Order Is Not Important&lt;/p&gt;

&lt;p&gt;The final thing I&amp;rsquo;llsayon this philosophy isthat I&amp;rsquo;mnot telling you todo thisin a strict order of &amp;ldquo;CREATE! DEFEND!CREATE! DEFEND!&amp;rdquo; At first you mightwant todo that, but I&amp;rsquo;d actually doeither in varying amountsdepending onwhat I wanted to do, and I might even meldthem together with no defined boundary.&lt;/p&gt;

&lt;p&gt;I also don&amp;rsquo;t think one mind­set isbetter thananother, or that there&amp;rsquo;s astrictseparation between them. Youneed both creativity andstrictnessto do programming well,sowork on bothif you want to improve.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• The codein the bookup to this point (and for the rest of it)potentially violates these rules. Go back and apply what you&amp;rsquo;velearned to one exerciseto seeif you can improve itor find bugs.&lt;/p&gt;

&lt;p&gt;• Findanopensource projectand givesome of the filesa similar code review. Submita patchthat fixes abug.&lt;/p&gt;

&lt;h2 id=&#34;exercise28-intermediate-makefiles:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise28. Intermediate Makefiles&lt;/h2&gt;

&lt;p&gt;In the next threeexercises you&amp;rsquo;ll create a skeleton projectdirectory to use in building your Cprograms later. This skeletondirectory will be used for the rest of the book. In this exercise,I&amp;rsquo;ll
cover just the Makefile so&lt;/p&gt;

&lt;p&gt;you can understand it. The purpose of thisstructure is to make it easy tobuild medium-sized programs without having to resort to configuretools. If doneright, you can get very far with just GNU make and somesmall shell scripts.&lt;/p&gt;

&lt;p&gt;The Basic Project Structure&lt;/p&gt;

&lt;p&gt;The first thing todo is make a c-skeleton directory, and thenputa set of basic files and directoriesin it that many projects have. Here&amp;rsquo;smy starter:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 28 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;

$ mkdir c-skeleton 
$ cd c-skeleton/
$ touch LICENSE README.md Makefile
$ mkdir bin src tests
$ cp dbg.h src/ # this is from Ex1.
$ ls -l 
total 8 -rw-r--r--1 zedshaw staff 31 16:38 LICENSE -rw-r--r--1 zedshaw staff 1168 
17:00 Makefile -rw-r--r--1 
zedshaw staff 
31 16:38 README.md drwxr-xr-x 2 zedshaw staff 68 31 16:38 bin drwxr-xr-x 2 zedshaw staff 68 
10:07 build drwxr-xr-x 3 zedshaw staff 102 
16:28 src drwxr-xr-x 2 zedshaw staff 68 31 16:38 tests 
$ ls -l src 
total 8 -rw-r--r--1 zedshaw staff 982 
16:28 dbg.h 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end you see me doa ls -l so thatyou cansee the finalresults.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s abreakdown: LICENSE If you release the source of your projects, you&amp;rsquo;ll want to include a license. If you don&amp;rsquo;t, though, the code iscopyrightby you and nobody else has rights
to it by default.&lt;/p&gt;

&lt;p&gt;README.md Basic instructionsfor using your project go here. It ends in .md sothat it willbe interpretedas markdown.&lt;/p&gt;

&lt;p&gt;Makefile The main build fileforthe project.&lt;/p&gt;

&lt;p&gt;bin/ Where programs that users can run go. This is usually empty, and the Makefile will create it ifit&amp;rsquo;s not there.
build/ Wherelibraries and other buildartifacts go. Alsoempty, and the Makefile will create it ifit&amp;rsquo;s not there.
src/ Where the source code goes,usually .c and .h files.
tests/ Where automated tests go.
src/dbg.h I copied the dbg.h from * Exercise 1. into src/
forlater.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll now break down each of the components of this skeleton project so thatyou can understand how itworks.&lt;/p&gt;

&lt;p&gt;Makefile&lt;/p&gt;

&lt;p&gt;The first thing I&amp;rsquo;llcoveris the Makefile, because from thatyou canunderstand how everythingelseworks.&lt;/p&gt;

&lt;p&gt;The Makefile in this exercise is much more detailedthan ones you&amp;rsquo;veused so far,soI&amp;rsquo;ll break it down afteryou type it in:&lt;/p&gt;

&lt;p&gt;Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;
1 CFLAGS=-g -O2 ­Wall -Wextra -Isrc ­rdynamic -DNDEBUG $(OPTFLAGS)
2 LIBS=-ldl $(OPTLIBS)
3 PREFIX? =/usr/local
4 
5 SOURCES=$(wildca src/**/*.c src/*.c)
6 OBJECTS=$(patsub %.c,%.o,$(SOURCES)) 
7 
8 TEST_SRC=$(wildc tests/*_tests.c)
9 TESTS=$(patsubst %.c,%,$(TEST_SRC)) 
10 
11 TARGET=build/lib 
12 SO_TARGET=$(pats %.a,%.so,$(TARGET))
13 
14 # The Target Build 
15 all: $(TARGET) $(SO_TARGET) tests 
16 17 dev: CFLAGS=-g 
-Wall -Isrc -Wall -Wextra $(OPTFLAGS) 
18  dev:  all 
19 
20  $(TARGET): CFLAGS += -fPIC 
21 $(TARGET): build $(OBJECTS) 
22 ar rcs $@ $(OBJECTS) 
23 ranlib $@ 
24 $(SO_TARGET): $(TARGET) $(OBJECTS) 
25 $(CC) ­shared -o $@ $(OBJECTS) 
2. 27 build:
28 build  @mkdir -p  
29 bin  @mkdir -p  
30
31 # The Unit Tests 
32 .PHONY: tests 33 tests: CFLAGS += $(TARGET)
34 tests: $(TESTS)
35 sh ./tests/runtests.sh
36 
37 # The Cleaner 
38 clean:
39 rm -rf build $(OBJECTS)$(TESTS)
40 rm -f tests/tests.log
41 find .­name &amp;quot;*.gc*&amp;quot; -exec rm {} \;
42 rm -rf `find . -name &amp;quot;*.dSYM&amp;quot; -print` 
43  
44  #  The  Install  
45  install:  all  
46  install  -d $(DESTDIR)/$(PREFIX)/l
47 install $(TARGET)$(DESTDIR)/$(PREFIX)/l with potentially
48  
49  #  The Checker  
50  check:  
51  @echo  Files dangerous functions.
52 @egrep&#39;[^_.&amp;gt;a-zA-Z0-9](str(n?cpy|n?cat|xfrm|n?dup|str|pbrk|tok|_)\
53 cpy|a?sn? printf|byte_)&#39;$(SOURCES) || true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember thatyouneed to consistently indent the Makefile with tab characters. Your text editor should knowthat and do the right thing. If itdoesn&amp;rsquo;t,get a differenttext editor. No programmershould use an editorthat failsatsomething so simple.&lt;/p&gt;

&lt;p&gt;The Header&lt;/p&gt;

&lt;p&gt;This Makefile is designed to builda library reliably on almost anyplatform using specialfeatures of GNU make.We&amp;rsquo;ll be working on this librarylater, so I&amp;rsquo;ll break down each part insections, starting with the header.&lt;/p&gt;

&lt;p&gt;Makefile:1 These are the usual CFLAGS that you setin all of your projects, along with a few othersthat may be needed to build libraries. You may need to adjust these for different platforms. Notice the OPTFLAGS variableat the end that lets people augment the build options asneeded.&lt;/p&gt;

&lt;p&gt;Makefile:2 These options are usedwhen linkinga library. Someone else can then augment the linking optionsusing the OPTLIBS variable.&lt;/p&gt;

&lt;p&gt;Makefile:3 This codesets an optional variable called PREFIX that willonly have this valueif theperson running theMakefile didn&amp;rsquo;t already give a PREFIX setting. That&amp;rsquo;s what the ?= does.&lt;/p&gt;

&lt;p&gt;Makefile:5 This fancy lineof awesomeness dynamically creates the SOURCES variableby doing a wildcard search forall *.c files in the src/ directory. You have togive both src/*&lt;em&gt;/&lt;/em&gt;.c and src/*.c so that GNU make willinclude the filesin src and the filesbelowit.&lt;/p&gt;

&lt;p&gt;Makefile:6 Once you have the list ofsource files, you can then use the patsubst to take the SOURCES list of *.c files and make a new lis tof all theobject files. You do this by telling patsubst to change all %.c extensionsto %.o, and thenthose extensions are assigned to OBJECTS.&lt;/p&gt;

&lt;p&gt;Makefile:8 We&amp;rsquo;re using the wildcard again to find allof the test source files forthe unit tests. These areseparate fromthe library&amp;rsquo;s source files.&lt;/p&gt;

&lt;p&gt;Makefile:9 Then, we&amp;rsquo;re using the same patsubst trick to dynamically get all the TEST targets. In this case, I&amp;rsquo;mstripping away the .c extension so thata full program willbe madewith the same name. Previously, I hadreplaced the .c with {.o}soan object fileiscreated.&lt;/p&gt;

&lt;p&gt;Makefile:11 Finally, we say the ultimate target is build/libYOUR_LIB which you will change to be whatever library you&amp;rsquo;re actually trying to build. This completesthe top of the Makefile, but I should explain what I mean by &amp;ldquo;lets people augment the build.&amp;rdquo; When yourun Make, you can do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
# WARNING! Just a demonstration, won&#39;t really work right now. 
# this installs the library into /tmp
$ make PREFIX=/tmpinstall # this tells it to add pthreads
$ make OPTFLAGS=­pthread 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you pass in options that match the samekindof variables you have in your Makefile, thenthose will showup in your build. You can then use this tochange how the Makefile runs.&lt;/p&gt;

&lt;p&gt;The first variablealters the PREFIX so that it installs into /tmp instead. The secondone sets OPTFLAGS so that the -pthread option is present.&lt;/p&gt;

&lt;p&gt;The Target Build Continuing with the breakdownof the Makefile, I&amp;rsquo;mactually building theobject files and targets:&lt;/p&gt;

&lt;p&gt;Makefile:14 Remember that the first target is what make runsby defaultwhen no target isgiven. In this, it&amp;rsquo;s called all: and it gives $(TARGET)tests asthe targets to build. Lookup at the TARGET variableand you see that&amp;rsquo;s the library,so all: will first build the library.&lt;/p&gt;

&lt;p&gt;The tests target is further downin the Makefile andbuilds the unit tests.&lt;/p&gt;

&lt;p&gt;Makefile:16 Here&amp;rsquo;s anothertargetfor making &amp;ldquo;developer builds&amp;rdquo; that introduces a techniquefor changing optionsfor just one target. IfIdo a &amp;ldquo;dev build,&amp;rdquo; I want the CFLAGS to include optionslike -Wextra thatareuseful for finding bugs. If you place them on the target lineas options like this, thengive another line thatsays the original target (in this case all), then it will change the options you set. I usethis for setting differentflags on differentplatforms that need it.&lt;/p&gt;

&lt;p&gt;Makefile:19 This builds the TARGET library, whatever that is. It also uses the same trick fromline 15,giving a target with just options and ways to alter them for thisrun. In this case, I&amp;rsquo;m adding -fPIC just for the library build, using the += syntax to add it on.&lt;/p&gt;

&lt;p&gt;Makefile:20 Nowwesee the realtarget,whereI say first make the build directory, and thencompile allof the OBJECTS.&lt;/p&gt;

&lt;p&gt;Makefile:21 Thisrunsthe ar command that actually makes the TARGET.Thesyntax $@ $(OBJECTS) is a way of saying, &amp;ldquo;put the target for this Makefile source here and allthe OBJECTS after that.&amp;rdquo; In this case, the $@ mapsback to the $(TARGET) online 19, which maps to build/libYOUR_LIB&lt;/p&gt;

&lt;p&gt;It seemslike a lotto keep track of in this indirection, and it can be, butonce you get it working, you just change TARGET at the topand builda whole new library.&lt;/p&gt;

&lt;p&gt;Makefile:22 Finally, to makethe library,you run ranlib on the TARGET andit&amp;rsquo;s built.&lt;/p&gt;

&lt;p&gt;Makefile:23-24 This just makesthe build/ or bin/ directories it they don&amp;rsquo;texist. This is then referenced fromline 19 when it gives the build target to make sure the build/ directory is made. You nowhave allof thestuff you need tobuild the software, so we&amp;rsquo;llcreate a way to build andrununit tests to do automated testing.&lt;/p&gt;

&lt;p&gt;The Unit Tests&lt;/p&gt;

&lt;p&gt;C is different from other languages because it&amp;rsquo;s easier to create one tiny little programfor each thing you&amp;rsquo;re testing. Some testing frameworks try to emulatethe moduleconcept other languages have and do dynamic loading, but this doesn&amp;rsquo;twork wellin C. It&amp;rsquo;s also unnecessary,because you can just make a single programthat&amp;rsquo;srunfor each test instead.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll cover this partof the Makefile, and thenlater you&amp;rsquo;ll see the contents of the tests/ directorythat make it actually work.&lt;/p&gt;

&lt;p&gt;Makefile:29 If you have a target that&amp;rsquo;s not real, but thereis a directory orfile with that name, thenyouneed to tagthe target with .PHONY: so make willignore the fileand always run. Makefile:30 I use the same trick for modifying the CFLAGS
variableto add the TARGET to thebuild so thateach of the test programs will be linked with the TARGET library. In thiscase, it willadd build/libYOUR_LIB to thelinking.&lt;/p&gt;

&lt;p&gt;Makefile:31 Then I have the actual tests: target,which depends on allof theprograms
listedin the TESTS variablethat we created in theheader. This one lineactually says, &amp;ldquo;Make, use what you know about building programs and the current CFLAGS settings to build each programin TESTS.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Makefile:32 Finally, when all of the TESTS are built, there&amp;rsquo;s a simple shell scriptI&amp;rsquo;ll create later that knows how to run them alland report their output. This lineactually runsit so you can see the test results.&lt;/p&gt;

&lt;p&gt;For the unit testing to work, you&amp;rsquo;ll need tocreate a little shell script that knows how to run the programs. Go ahead and create this tests/runtests.sh script: runtests.sh&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 echo &amp;quot;Running unit tests:&amp;quot; 
2 3 for i in tests/*_tests
4  do  
5  if test -f $i
6  then
7 if $VALGRIND ./$i 2&amp;gt;&amp;gt; tests/tests.log
8  then  
9  echo $i  PASS
10  else  
11  ech &amp;quot;ERROR  in  test  $i: here&#39;s tests/tests.log&amp;quot;
12 ech &amp;quot;------&amp;quot;
13 tai tests/tests.log
14 exi 
1. 
15  fi  
16  fi  
17  done  
18  
19  echo  &amp;quot;&amp;quot;  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ll be using this laterwhen I cover how unit tests work.&lt;/p&gt;

&lt;p&gt;The Cleaner&lt;/p&gt;

&lt;p&gt;I now havefully working unit tests,sonextup ismaking things cleanwhen Ineed to reset everything.&lt;/p&gt;

&lt;p&gt;Makefile:38 The clean: target startsthings off when we need to clean up theproject.&lt;/p&gt;

&lt;p&gt;Makefile:39-42 This cleans out most of the junk thatvarious compilers andtools leave behind. It also gets rid of the build/directory and usesa trick at the end to cleanly erase theweird *.dSYM directories thatApple&amp;rsquo;s XCode leaves behindfor debugging purposes.&lt;/p&gt;

&lt;p&gt;If yourunintojunkthat you need to clean out,simply augment the lis tof things being deleted in this target.&lt;/p&gt;

&lt;p&gt;The Install&lt;/p&gt;

&lt;p&gt;After that,I&amp;rsquo;ll need a way to install the project, and for a Makefile that&amp;rsquo;s buildinga library,I just need to put something in the common PREFIX directory, usually /usr/local/lib.&lt;/p&gt;

&lt;p&gt;Makefile:45 Thismakes install: dependon the all: target, so that when yourun make install, it will be sure tobuild everything.&lt;/p&gt;

&lt;p&gt;Makefile:46 I then usethe program install to create the target lib directory if it doesn&amp;rsquo;t exist. In this case,I&amp;rsquo;m trying to make the install asflexible as possible byusing two variables that are conventions for installers. DESTDIR is handed to make by installers, which do their builds insecure or odd locations, to build packages. PREFIX is used when people want the project to be installed insomeplace other than /usr/local.&lt;/p&gt;

&lt;p&gt;Makefile:47 After that, I&amp;rsquo;m justusing install to actually install the library where it needsto go.&lt;/p&gt;

&lt;p&gt;The purpose of the install programis to makesure things have the right permissions set. When you run make install, you usually have to do it as the root user, so the typical build processis make &amp;amp;&amp;amp; sudo make install.&lt;/p&gt;

&lt;p&gt;The Checker&lt;/p&gt;

&lt;p&gt;The very last part of this Makefile is a bonus thatI include In my C projectsto helpme dig out any attempts to use thebad functions in C. Theseare namely thestring functions ando ther unprotectedbufferfunctions.&lt;/p&gt;

&lt;p&gt;Makefile:50 Thissets a variablethat&amp;rsquo;s a big regex looking for bad functions like strcpy.&lt;/p&gt;

&lt;p&gt;Makefile:51 The check: target allows you to run acheck whenever you need to.&lt;/p&gt;

&lt;p&gt;Makefile:52 This is just a way toprint a message, butdoing @echo tells make to not print the command, just its output.&lt;/p&gt;

&lt;p&gt;Makefile:53 Run the egrep command on the source files to look for anybad patterns. The || true at the end is a way to prevent make fromthinking that egrep failedif it doesn&amp;rsquo;tfinderrors.&lt;/p&gt;

&lt;p&gt;When yourunthis, it will have the oddeffectof returningan errorwhen there&amp;rsquo;s nothing bad going on.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;I have two moreexercises to go before I&amp;rsquo;m done building the project skeleton directory, buthere&amp;rsquo;sme testing out the features of the Makefile.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 28 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ make clean 
rm -rf build rm -f tests/tests.log find . -name &amp;quot;*.gc*&amp;quot; -exec rm {} \; rm -rf `find . -name &amp;quot;*.dSYM&amp;quot; -print` 
$ make check 
$ make 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I run the clean: target, it works, butbecause I don&amp;rsquo;thave anysourcefiles in the src/ directory, none of the othercommandsreally work. I&amp;rsquo;ll finishthat up in the nextexercises.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Try to get the Makefile toactually work by putting a source and header file in src/ andmaking the library. You shouldn&amp;rsquo;tneed a main function in the source file.&lt;/p&gt;

&lt;p&gt;• Research what functions the check: target is looking for in the BADFUNCS regular expressionthat it&amp;rsquo;s using.&lt;/p&gt;

&lt;p&gt;• If you don&amp;rsquo;tdo automated unit testing, thengo read about it so you&amp;rsquo;re preparedlater.&lt;/p&gt;

&lt;h2 id=&#34;exercise29-libraries-and-linking:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise29. Libraries and Linking&lt;/h2&gt;

&lt;p&gt;A central part of any C programis the ebility tolink it tolibraries that your OS provides. Linking is how you get additionalfeatures for your program thatsomeone else createdand packagedon the system. You&amp;rsquo;vebeen using somestandard libraries thatare automatically included, but I&amp;rsquo;m going to explain thedifferent types of librariesand what they do.&lt;/p&gt;

&lt;p&gt;First off, libraries are poorly designed inevery programming language. I haveno idea why, butit seems languagedesigners think of linking assomething theyjust slap on later.&lt;/p&gt;

&lt;p&gt;Libraries areusually confusing, hard to dealwith, can&amp;rsquo;t do versioning right, and end up being linked differently everywhere.&lt;/p&gt;

&lt;p&gt;C is no different, but the way linking andlibraries aredone in C is an artifactof how the UNIX operating system and executable formats were designed years ago. Learning how Clinksthings helpsyou understand how yourOS works andhowit runsyour programs.&lt;/p&gt;

&lt;p&gt;To startoff, there are two basic types oflibraries: static You made oneof these when you used ar and ranlib to create the lib YOUR_LIBRARY.a in the lastexercise. This kind oflibraryis nothing more than a container for a setof .o object files and their functions, and you can treatit likeone big .o filewhenbuilding your programs.&lt;/p&gt;

&lt;p&gt;dynamic These typically end in .so, .dll or about onemillionother endings on OSX, depending on the version and who happenedto be working thatday. Seriously though,OS X adds .dylib, .bundle, and .framework with notmuch distinction among the three.&lt;/p&gt;

&lt;p&gt;These files are built and then placed in acommon location. When you run your program,the OS dynamicallyloads these filesand links them to your program on the fly.&lt;/p&gt;

&lt;p&gt;I tend to like static libraries for small-tomedium-sized projects, becausethey are easier todeal with andwork on moreoperating systems. I also like to put all of the code I can into a static library so thatIcan thenlinkit to unit tests and to the file programs asneeded.&lt;/p&gt;

&lt;p&gt;Dynamiclibrariesare good for largersystems, when space is tight, or if youhave a large number ofprograms thatusecommon functionality. In this case, you don&amp;rsquo;twant tostatically link all of the codeforthe common features to every program, so you put it in a dynamic library so that itis loaded only oncefor all of them.&lt;/p&gt;

&lt;p&gt;In the previous exercise, I laidout how to make a static library (a .a file), andthat&amp;rsquo;s whatI&amp;rsquo;ll use in therest of the book. In this exercise,I&amp;rsquo;m going to show youhow to make a simple .so library, and how to dynamically loadit with the UNIX dlopen system. I&amp;rsquo;ll have you do this manually so thatyou understand everything that&amp;rsquo;s actually happening, then for extra credit you&amp;rsquo;ll use the c-skeleton skeletonto create it.&lt;/p&gt;

&lt;p&gt;Dynamically Loading a Shared Library&lt;/p&gt;

&lt;p&gt;To do this,Iwillcreate two source files:One will be used to make a libex29.so library,the other will be a programcalled ex29 that can loadthis library andrun functions from it.&lt;/p&gt;

&lt;p&gt;libex29.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 
2 #include &amp;lt;ctype.h&amp;gt; 
3 #include &amp;quot;dbg.h&amp;quot;
4 
5 
6 int print_a_message(const char *msg) 
7 {
8 printf(&amp;quot;A STRING: %s\n&amp;quot;, msg); 
9 
10 return 0; 
11 } 
1. 1. 14 int uppercase(const char *msg)
15 {16 int i = 0;17 18 // BUG: \0 termination problems 
19 for(i = 0; msg[i] != &#39;\0&#39;; i++){
20 printf(&amp;quot; toupper(msg[i])); 
2. }
2. 23 printf(&amp;quot;\n&amp;quot;)
2. 25 return 0;
2. }
2. 28 int lowercase(const char *msg)
29 {30 int i = 0;31 32 // BUG: \0 termination problems
33 for(i = 0; msg[i] != &#39;\0&#39;; i++){
34 printf(&amp;quot; tolower(msg[i])); 
35 } 
36 
37 printf(&amp;quot;\n&amp;quot;)
38 
39 return 0; 
40 } 
41
42 int fail_on_purpose(const char *msg)43 {
44 return 1;
45 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s nothing fancy in there,althoughthere are some bugsI&amp;rsquo;m leavingin on purposeto seeif you&amp;rsquo;ve been payingattention. You&amp;rsquo;ll fix thoselater.&lt;/p&gt;

&lt;p&gt;Whatwe want to do is use the functions dlopen, dlsym, and dlclose to work with the above functions.&lt;/p&gt;

&lt;p&gt;ex29.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 
2 #include &amp;quot;dbg.h&amp;quot; 
3 #include &amp;lt;dlfcn.h&amp;gt; 
4 
5 typedef int (*lib_function)(const char *data); 
6 
7 int main(int 
argc, char *argv[]) 
8 {
9 int rc = 0;
10 check(argc == 4, &amp;quot;USAGE: ex29 libex29.so function data&amp;quot;); 
1. 12 char *lib_file = argv[1]; 
13 char *func_to_run = argv[2]; 
14 char *data = argv[3]; 
1. 16 void *lib = dlopen(lib_file,RTLD_NOW); 
17 check(lib != NULL, &amp;quot;Failed to open the library %s: %s&amp;quot;, lib_file, 
func_to_run); 
18  dler  
19  
20 func  =  lib_function dlsym(lib,
21 check(func != NULL,
22 &amp;quot;Did not find %s function in the library %s: 
26 check(rc %s&amp;quot;, func_to_run, 23 dlerror()); 24  lib_ 
25  rc  =
func(data);  ==  

0, &amp;quot;Function %s return %d for data: %s&amp;quot;, func_to_run,
27 rc,data); 
2. 
29 rc = dlclose(lib); 
30 check(rc == 0, &amp;quot;Failed to close %s&amp;quot;, lib_file); 
31. 32 33  return 0;  
34  error:  
35 36  }  return 1;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ll now break thisdown so you can see what&amp;rsquo;sgoing on in this smallbit of useful code:&lt;/p&gt;

&lt;p&gt;ex29.c:5 I&amp;rsquo;ll use this&lt;/p&gt;

&lt;p&gt;function pointer definitionlaterto call functions in the library. This is nothing new, but makesure you understand what it&amp;rsquo;s doing.&lt;/p&gt;

&lt;p&gt;ex29.c:17 After theusual setupfor a small program, I use the dlopen function to loadup thelibrary that&amp;rsquo;s indicatedby lib_file. This function returns a handle thatwe use later, which works a lotlike opening afile.&lt;/p&gt;

&lt;p&gt;ex29.c:18 Ifthere&amp;rsquo;s an error, I do the usual check and exit, but notice at thenend that I&amp;rsquo;m using dlerror to find out what the library-related error was.&lt;/p&gt;

&lt;p&gt;ex29.c:20 I use dlsym to get a function out of the lib by its string name in func_to_run. This is the powerful part, sinceI&amp;rsquo;m dynamically getting a pointer to a function based on astring I got fromthe command line argv.&lt;/p&gt;

&lt;p&gt;ex29.c:23 I then call the func function that was returned, and check its returnvalue.&lt;/p&gt;

&lt;p&gt;ex29.c:26 Finally,I close the library up just like I would a file. Usually, you keep theseopen the whole time the program isrunning, so closing it at the endisn&amp;rsquo;tas useful, but I&amp;rsquo;m demonstrating ithere.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;Now thatyou knowwhat this filedoes,here&amp;rsquo;s ashell session of me building the libex29.so, ex29 and thenworking with it. Follow along so you learn howthese things are manuallybuilt.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 29 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
# compile the lib file and make the .so # you may need -fPIC here on some platforms. add that if you get an error
$ cc -c libex29.c -o libex29.o
$ cc -shared -o libex29.so libex29.o 
# make the loader program$ cc -Wall -g ­DNDEBUG ex29.c -ldl ­o ex2. # try it out with some things that work
$ ex29 ./libex29.soprint_a_message
&amp;quot;hello there&amp;quot; 
-bash: ex29: command not found 
$ ./ex29 ./libex29.soprint_a_message
&amp;quot;hello there&amp;quot; 

A STRING: hello there 
$ ./ex29 ./libex29.souppercase &amp;quot;hello there&amp;quot; 
HELLO THERE 
$ ./ex29 ./libex29.solowercase &amp;quot;HELLO tHeRe&amp;quot; 
hello there 
$ ./ex29 ./libex29.sofail_on_purpose &amp;quot;i fail&amp;quot; 
[ERROR] (ex29.c:23: errno: None) Function fail_on_purpose return 1 for\ 
data: i fail 
# try to give it bad args
$ ./ex29 ./libex29.sofail_on_purpose
[ERROR] (ex29.c:11: errno: None) USAGE: ex29 libex29.so function data 
# try calling a function that is not there
$ ./ex29 ./libex29.soadfasfasdf asdfadff 
[ERROR] (ex29.c:20: errno: None) Did not find adfasfasdf 
function in the library libex29.so: dlsym(0x1076009b0, adfasfasdf):\ 
symbol not found 
# try loading a .so that is not there
$ ./ex29 ./libex.soadfasfasdf asdfadfas 
[ERROR] (ex29.c:17: errno: No such file or directory) Failed to open 
the library libex.so: 
dlopen(libex.so, 2): image not found 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Onething thatyou may run into is thatevery OS, every versionof every OS, and every compiler onevery versionof every OS,seemsto want to change the way you build a shared library every time somenew programmer thinks it&amp;rsquo;s wrong. If the line I use to make the libex29.so file is wrong, thenlet me knowand I&amp;rsquo;ll add somecommentsforother platforms.&lt;/p&gt;

&lt;p&gt;Warning!&lt;/p&gt;

&lt;p&gt;Sometimes you&amp;rsquo;lldo what you think is normal, and run this command cc -Wall -g -DNDEBUG ­ldl ex29.c -o ex29 thinking everything willwork, but nope. You see,on someplatforms the orderof where libraries gomakes them work ornot, andforno real reason.&lt;/p&gt;

&lt;p&gt;In Debianor Ubuntu,youhave todo cc -Wall -g ­DNDEBUG ex29.c -ldl -o ex29 for noreasonatall. It&amp;rsquo;s just the wayitis. So since this works onOS X I&amp;rsquo;m doing it here, but in the future, ifyou link against adynamic library andit can&amp;rsquo;tfind a function, try shuffling things around.&lt;/p&gt;

&lt;p&gt;The irritationhere is there&amp;rsquo;s an actual platform difference on nothing morethan the orderof command line arguments. Onno rational planet should putting wan -ldl at one position be different from another. It&amp;rsquo;s an option, and having to know thesethings is incrediblyannoying.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;Open libex29.so and edit it with an editor that can handle binary files. Change a couple of bytes, then close itlibex29.so. Try to see if you can get the dlopenfunction toload iteven though you&amp;rsquo;vecorrupted it.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Were you paying attention to thebad code Ihave in the libex29.c functions? Do yousee how,even though I use a for-loop theystill check for &amp;lsquo;\0&amp;rsquo; endings? Fix this so that the functions always take a length forthe string towork with inside the function.&lt;/p&gt;

&lt;p&gt;• Take the c ­skeleton skeleton, and create anew project for this exercise. Put the libex29.c file in the src/ directory. Change the Makefile so that itbuilds this as build/libex29.so.&lt;/p&gt;

&lt;p&gt;• Take the ex29.c file and put it in   tests/ex29_tests. so that itrunsas a unit
test. Make this all work,&lt;/p&gt;

&lt;p&gt;which meansthat you&amp;rsquo;ll have tochangeit so that it loadsthe build/libex29.so file and runs tests similar to whatI didmanually above.
• Readthe man dlopen documentation and read about all of the related functions. Try some of the other options to
dlopen beside RTLD_NOW.&lt;/p&gt;

&lt;h2 id=&#34;exercise30-automated-testing:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise30. Automated Testing&lt;/h2&gt;

&lt;p&gt;Automated testingis used frequently in other languages likePythonand Ruby, but rarely usedin C. Partof the reason comesfrom the difficulty ofautomatically loadingand testing piecesof C code. In this chapter, we&amp;rsquo;ll createa very small testing framework andget your skeleton directoryto build an example testcase.&lt;/p&gt;

&lt;p&gt;The framework I&amp;rsquo;m going to use, and you&amp;rsquo;ll includein your c-skeleton skeleton, is called minunit which started with atinysnippet of codeby Jera Design. I evolveditfurther,to be this:
minunit.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #undef NDEBUG 
2 #ifndef _minunit_h
3 #define _minunit_h
4 
5 #include &amp;lt;stdio.h&amp;gt;
6 #include &amp;lt;dbg.h&amp;gt;
7 #include &amp;lt;stdlib.h&amp;gt;
8 
9 #define mu_suite_start() char *message = NULL 
1. 11 #define mu_assert(test, message) if (!(test)) {\ 
12 log_err(mess return message; } 
13 #define mu_run_test(test) debug(&amp;quot;\n-----%s&amp;quot;, &amp;quot; &amp;quot; #test); \ 
14 message = test(); tests_run++; if (message) return message; 
16 #define RUN_TESTS(name) int main(int argc, char *argv[]) {\ 
17 argc = 1; \ 
18 debug(&amp;quot;---­-RUNNING: %s&amp;quot;, argv[0]);\ 
19 printf(&amp;quot;--­-\nRUNNING: %s\n&amp;quot;, argv[0]);\ 
20 char *result = name();\ 
21 if (result != 0) {\ 
22 printf(&amp;quot; %s\n&amp;quot;, result);\ 
23 }\ 
24 else {\ 
25 printf(&amp;quot; TESTS PASSED\n&amp;quot;);\ 
26 }\ 
27 printf(&amp;quot;Test run: %d\n&amp;quot;, tests_run);\ 
28 exit(result != 0);\ 
29 } 
30 

31 int tests_run;32 33 #endif 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;spractically nothing leftof theoriginal,since now I&amp;rsquo;m using the dbg.h macros and a large macro that I created at the endfor the boilerplate testrunner. Even with this tiny amount of code, we&amp;rsquo;ll createa fully functioning unit testsystem thatyou canusein your C
codeonce it&amp;rsquo;scombined with ashell script torun the tests.&lt;/p&gt;

&lt;p&gt;Wiring Up the Test Framework&lt;/p&gt;

&lt;p&gt;To continuethis exercise,you should have your src/libex29.c working. You should have also completed the Exercise
2. Extra Credit
to get the ex29.c loader program to properlyrun. In Exercise
29,I ask you to make it worklike a unit test, but I&amp;rsquo;m going to startoverand show youhow to do thatwith minunit.h.&lt;/p&gt;

&lt;p&gt;The first thing todo is create asimple empty unit test name,
tests/libex29_tests.c&lt;/p&gt;

&lt;p&gt;with this in it:&lt;/p&gt;

&lt;p&gt;ex30.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

1 #include &amp;quot;minunit.h&amp;quot; 
2 
3 char *test_dlopen() 
4 {
5 
6 return NULL;
7 }
8 
9 char *test_functions()
10 {
1. 
12 return NULL; 
13 }
14 
15 char
*test_failures() 
16 {
17 
18 return NULL;
19 }
2. 
21 char
*test_dlclose() 
22 {
23 
24 return NULL;
25 } 
2. 
27 char *all_tests() 
38 
2. 
29  {  mu_suite_sta  
30  
31 
32 
33 
34 
35  mu_run_test(mu_run_test(mu_run_test(mu_run_test(  
36  return  NULL;
37  }  

39 RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This codeis demonstrating the RUN_TESTS macro in tests/minunit.h and how to use theother test runner macros. I have the actualtestfunctions stubbed outsothat you can see how to structure aunittest. I&amp;rsquo;llbreak this file down first:
libex29_tests.c:1 This includes the minunit.h framework.
libex29_tests.c:3-7 A first test. Tests arestructured so that they takeno arguments andreturn a char * that&amp;rsquo;s NULL on success. This is importantbecause the other macros will be used toreturn anerror messageto the test runner.
libex29_tests.c:9-2. Theseare more tests
thatare the same as the first.
libex29_tests.c:27 The runner function thatwill control all of the other tests. It has thesame formas anyother test case, but it gets configured with some additional gear.
libex29_tests.c:28 This setsup some common stuff for a test with mu_suite_start.&lt;/p&gt;

&lt;p&gt;libex29_tests.c:30 This is how yousaywhattests to run, using the mu_run_test macro.
libex29_tests.c:35 After you say whatteststo run,you then return NULL just like anormal test function.
libex29_tests.c:38 Finally,you just use the big RUN_TESTS macro&lt;/p&gt;

&lt;p&gt;to wire upthe main methodwith all of the goodies, andtell it to run the all_tests starter.
That&amp;rsquo;s allthereis to running a test, and now you should try getting just this to run within the project skeleton. Here&amp;rsquo;s whatit looks likewhen Ido it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 30 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;not printable
I first did a make clean and then I ran the build, which remade the template libYOUR_LIBRARY. a
and
libYOUR_LIBRARY.so
files. Remember that you did this in the Extra Credit for Exercise29, butjust in case you didn&amp;rsquo;tget it, here&amp;rsquo;s the diff for the Makefile I&amp;rsquo;m using now:&lt;/p&gt;

&lt;p&gt;ex30.Makefile.diff&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
diff --git a/code/c-skeleton/Makefileb/code/c-skeleton/Makefileindex 135d538..21b92bf 100644 
---a/code/c-
skeleton/Makefile +++ b/code/c-skeleton/Makefile
@@ -9,9 +9,10 @@TEST_SRC=$(wildcardtests/*_tests.c)
TESTS=$(patsubst%.c,%,$(TEST_SRC)) 
TARGET=build/libYOUR_+SO_TARGET=$(patsubst%.a,%.so,$(TARGET)) 
# The Target Build 
-all: $(TARGET) tests +all: $(TARGET)$(SO_TARGET) tests

dev: CFLAGS=-g -Wall -Isrc -Wall -Wextra $(OPTFLAGS)
dev: all @@ -21,6 +22,9 @@$(TARGET): build $(OBJECTS)
ar rcs $@ $(OBJECTS)
ranlib $@ 
+$(SO_TARGET):$(TARGET) $(OBJECTS) 
+ $(CC) -shared -o $@ 
$(OBJECTS)
+ 

build: 
@mkdir -p build 
@mkdir -p bin 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With thosechanges you should now be building everythingand finally be able to fill in the remaining unit test functions:
libex29_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;minunit.h&amp;quot; 
2 #include &amp;lt;dlfcn.h&amp;gt; 
3 
4 typedef int (*lib_function)(const char *data); 
5 char *lib_file = &amp;quot;build/libYOUR_LIBRARY 
6 void *lib = NULL;
7 
8 int check_function(const char *func_to_run,const char *data, 
9 int expected)
10 {
11 lib_function func = dlsym(lib,func_to_run); 
12 check(func != NULL,
13 &amp;quot;Did not find %s function in the library %s: %s&amp;quot;, func_to_run, 
14 lib_ dlerror()); 
1. 
16 int rc = func(data); 
17 check(rc == expected, &amp;quot;Function dlopen(lib_file,RTLD_NOW); %s  return  %d  for data: 
18  %s&amp;quot;,  func rc, 
19  data);  
20 
21  return error:  1;  
22 
23 
24  }  return  0;  
25  char  
*test_dlopen() 
26 {
27 lib =  

28 mu_assert(li != NULL, &amp;quot;Failed to open the library to test.&amp;quot;); 
2. 
30 return NULL;
31 }
32 
33 char 

*test_functions() 
34 {
35 mu_assert(ch 
&amp;quot;Hello&amp;quot;, 0), 
36 &amp;quot;pri failed.&amp;quot;); 
37 mu_assert(ch &amp;quot;Hello&amp;quot;, 0), 
38 &amp;quot;uppfailed.&amp;quot;); 
39 mu_assert(ch &amp;quot;Hello&amp;quot;, 0), 
40 &amp;quot;low failed.&amp;quot;); 
41 
42 return NULL;
43 }
44 
45 char 

*test_failures() 
46 {
47 mu_assert(ch &amp;quot;Hello&amp;quot;, 1), 
48 &amp;quot;fai should fail.&amp;quot;); 
49 
50 return NULL;
51 }
52 
53 char 

*test_dlclose() 
54 {
55 int rc = 
dlclose(lib); 56 mu_assert(rc == 0, &amp;quot;Failed to 
close lib.&amp;quot;); 
57 
58 return NULL;
59 }
60 
61 char 
*all_tests() 
62 
63  {  mu_suite_sta  
64  
65 
66 
67 
68 
69  mu_run_test(mu_run_test(mu_run_test(mu_run_test( 
70 return NULL;
71 }
72 
73 RUN_TESTS(all_te 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hopefullyby now you can figure out what&amp;rsquo;sgoing on, since there&amp;rsquo;s nothing new in this except for the
check_function function. This is acommon patternwhereI use a chunk ofcode repeatedly, and then simplyautomate it by either creatinga functionor a macro for it. In this case, I&amp;rsquo;m going to run functionsin the .so thatIload, so I just madea little function todo it.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• This worksbut it&amp;rsquo;s probably a bitmessy. Clean the c-skeleton directory up so that it has allof these files, but remove&lt;/p&gt;

&lt;p&gt;any of the code related to Exercise
29. You should beable to copy this directory over and kick-start newprojects without much editing.&lt;/p&gt;

&lt;p&gt;• Study the runtests.sh, and thengo read about bash syntax so you know what it does. Do you think you could write a C version of this script?&lt;/p&gt;

&lt;h2 id=&#34;exercise31-common-undefined-behavior:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise31. Common Undefined Behavior&lt;/h2&gt;

&lt;p&gt;At this point in the book, it&amp;rsquo;s time to introduceyou to the most common kinds of UB that you will encounter. C has 191 behaviors that the standards committee has decided aren&amp;rsquo;t defined by the standard, and therefore anything goes. Some of these behaviors are legitimately not the compiler&amp;rsquo;s job, but the vast majority are simply lazy capitulations by the standards committee that cause annoyances, or worse, defects. An example of laziness:&lt;/p&gt;

&lt;p&gt;An unmatched &amp;ldquo;or&amp;rdquo; character is encountered on a logical source line during tokenization.&lt;/p&gt;

&lt;p&gt;In this instance,the C99 standard actually allows a compiler writer to fail at a parsing task that a junior in college could get right. Why is this? Who knows, but most likely someoneon the standards committeewas working on a Ccompilerwith this defect and managed to get this in thestandard rather thanfix theircompiler. Or, as I said, simple laziness.&lt;/p&gt;

&lt;p&gt;The crux of the issue with UB is the differencebetween the C abstract machine, defined in thestandard andreal computers. The C standard describes the C language according to a strictlydefined abstract machine. This is a perfectly valid way to design alanguage, exceptwherethe C standard goeswrong: It doesn&amp;rsquo;trequire compilers to implement this abstract machine and enforceits specification.&lt;/p&gt;

&lt;p&gt;Instead, a compiler writer can completely ignore the abstract machine in191instances of the standard. It should really be calledan &amp;ldquo;abstract machine, but&amp;rdquo;,as in, &amp;ldquo;It&amp;rsquo;s a strictlydefined abstract machine, but&amp;hellip;&amp;rdquo; This allows the standards committee and compiler implementers to have their cake andeatit, too. They can have a standardthat is full of omissions, lax specification, and errors, but when you encounter oneof these, they can pointat the abstract machine and simply say in their best robot voice, &amp;ldquo;THE ABSTRACT MACHINEIS ALLTHATMATTERS. YOU DO NOT CONFORM!&amp;rdquo; Yet,in 191 instancesthat compiler writers don&amp;rsquo;t have to conform, you do. You are a secondclasscitizen, even though the language isreally writtenfor you to use.&lt;/p&gt;

&lt;p&gt;This meansthat you, not the compiler writer,areleftto enforcethe rulesof an abstract computational machine, andwhen you inevitably fail,it&amp;rsquo;s yourfault. The compiler doesn&amp;rsquo;thave to flag the UB, doanything reasonable, andit&amp;rsquo;s yourfault for not memorizing all 191 rulesthat should be avoided. You are just stupid for not memorizing 191 complex potholeson the road to C.&lt;/p&gt;

&lt;p&gt;This is a wonderful situation for the classic know-it-all type who can memorize these 191 finer points of annoyance with which to beat beginners to intellectual death. There&amp;rsquo;s an additional hypocrisy with UB that is doubly infuriating. If you show a C fanatic code that properlyu ses C strings but can overwrite the string terminator,they will say, &amp;ldquo;That&amp;rsquo;s UB. It&amp;rsquo;s not the C language&amp;rsquo;s fault!&amp;rdquo; However, if you show them UB that has while(x) x &amp;lt;&amp;lt;= 1 in it, they will say, &amp;ldquo;That&amp;rsquo;s UB idiot!Fix your damn code!&amp;rdquo; This lets the C fanatic simultaneously use UB to defend the purity of C&amp;rsquo;s design, and also beat you up for being an idiot who writes bad code. Some UB is meant as, &amp;ldquo;you can ignore the security of this since it&amp;rsquo;s not C&amp;rsquo;s fault&amp;rdquo;, and other UB is meant as, &amp;ldquo;you are an idiot for writing this code,&amp;rdquo; and the distinction between the two is not specified in the standard.&lt;/p&gt;

&lt;p&gt;As you can see, Iam not a fan of the huge list of UB. I had to memorize all of these before the C99 standard, and just didn&amp;rsquo;t bother to memorize the changes. I&amp;rsquo;d simply moved onto away and found a way to avoid as much UB as I possibly could, trying to stay within the abstract machine specification while also working with real machines. This turns out to be almost impossible, so I just don&amp;rsquo;twritenew codein C anymore because of its glaringly obvious problems.&lt;/p&gt;

&lt;p&gt;Warning!&lt;/p&gt;

&lt;p&gt;The technical explanationas towhy C UB is wrong comes from AlanTuring:
1. C UB contains behaviors thatare&lt;/p&gt;

&lt;p&gt;lexical,semantic, and executionbased.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The lexical and semantic behaviors can be detected by the compiler.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The execution-based behaviors fallinto Turing&amp;rsquo;sdefinitionof the halting problem, and are therefore NP-complete.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This means that to avoid CUB, it requires solving one of the oldest proven unsolvable problems in computer science, making UB effectively impossible for a computer to avoid.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To put it more succinctly: &amp;ldquo;If the only way to knowthat you&amp;rsquo;veviolated the abstract machine with UBis to run your C program, then you will never be able to completely avoid UB.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;UB 2. Because ofthis, I&amp;rsquo;m going to list the top 20 undefined behaviors in C, and tell you how to avoid them as best I can.&lt;/p&gt;

&lt;p&gt;In general, the way to avoid UB is towriteclean code, but some of these behaviors are impossible to avoid. For example, writing past the end ofa C stringis an undefinedbehavior, yet it&amp;rsquo;seasily done by accident and externallyaccessible to an attacker. This list will also include relatedUB thatall fallinto the same category butwithdiffering contexts.&lt;/p&gt;

&lt;p&gt;Common UBs&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;An object isreferred to outside of its lifetime (6.2.4).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;• The value of a pointerto an object whoselifetime has endedis used (6.2.4).&lt;/p&gt;

&lt;p&gt;• The value of an objectwith automatic storage duration is used while it is indeterminate (6.2.4, 6.7.8,6.8).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Conversionto orfrom an integertype producesa value outside therangethat can be represented (6.3.1.4).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;• Demotion of one real floating typeto another produces a valueoutside the rangethat can be represented (6.3.1.5).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Two declarations of the same object or function specify typesthat are notcompatible (6.2.7).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Anlvalue having array typeisconvertedto a pointer to theinitial element of the array, and the erray object has registerstorageclass (6.3.2.1).&lt;/p&gt;

&lt;p&gt;• An attemptismade to use the value of a void expression, or an implicit orexplicit conversion (except to void) is appliedto a void expression (6.3.2.2).&lt;/p&gt;

&lt;p&gt;• Conversion of a pointerto an integer typeproduces a value outside the range that can be represented (6.3.2.3).&lt;/p&gt;

&lt;p&gt;• Conversion between two pointer types produces a result that isincorrectly aligned (6.3.2.3).&lt;/p&gt;

&lt;p&gt;• A pointerisused to call afunction whose typeis not compatible with the pointed-totype (6.3.2.3).&lt;/p&gt;

&lt;p&gt;• Theoperand of the unary * operator has an invalid value (6.5.3.2).&lt;/p&gt;

&lt;p&gt;• A pointeris converted to other than aninteger or pointertype (6.5.4).&lt;/p&gt;

&lt;p&gt;• Addition or subtraction of a pointerinto, or just beyond, an array objectand an integer typeproduces a result that doesnotpoint into, or just beyond, the same array object (6.5.6).&lt;/p&gt;

&lt;p&gt;• Addition or subtraction of a pointerinto, or just beyond, an array objectand an integer typeproduces a result that pointsjust beyond the erray objectand is used as the operand ofa unary * operator that isevaluated (6.5.6).&lt;/p&gt;

&lt;p&gt;• Pointers thatdo not point into, or just beyond, thesame array object are subtracted(6.5.6).&lt;/p&gt;

&lt;p&gt;• An array subscript is outof range,even if an object is apparently accessible with the given subscript(asin the lvalue expression a[1][7] given the declaration int a[4][5]) (6.5.6).&lt;/p&gt;

&lt;p&gt;• Theresultof subtracting two pointersis not representable in an objectof type ptrdiff_t(6.5.6).&lt;/p&gt;

&lt;p&gt;• Pointers thatdo not point to the same aggregate or union (nor just beyond the same array object) are compared using relationaloperators (6.5.8).&lt;/p&gt;

&lt;p&gt;• An attemptismade to access, or generate a pointer tojust past, a flexible array memberof a structurewhen the referencedobject providesno elements for thatarray (6.7.2.1).&lt;/p&gt;

&lt;p&gt;• Two pointer types that arerequiredto be compatible are not identically qualified, or arenot pointers to compatible types (6.7.5.1).&lt;/p&gt;

&lt;p&gt;• The sizeexpression in an array declaration is nota constant expression and evaluates at program execution time to anonpositive value(6.7.5.2).&lt;/p&gt;

&lt;p&gt;• Thepointerpassed to a library function array parameter does nothave avaluesuch that alladdress computationsand objectaccesses are valid(7.1.4).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The programattempts to modifya stringliteral (6.4.5).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Anobject has its stored valueaccessedo ther thanby an lvalue of an allowablet ype (6.5).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Anattempt is made to modify theresultof a function call, a conditionaloperator,an assignmentoperator,or acomma operator, orto access itafterthe next sequencepoint (6.5.2.2, 6.5.15, 6.5.16,6.5.17).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The value of the second operandof the/or % operator is zero(6.5.5).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Anobject is assignedto an inexactly overlapping object orto an exactly overlapping object with incompatible type (6.5.16.1).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A constant expression in an initializeris not, ordoes notevaluateto, one of the following:an arithmetic constant expression, a null pointer constant, an addressconstant,or an addressconstant for an object typeplus or minus an integer constant expression (6.6).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;• An arithmetic constant expression does not have arithmetic type; has operands that are not integer constants, floating constants, enumeration constants,character constants,or sizeof expressions;or contains casts (outsideoperands to sizeofoperators) other than conversions of arithmetic typesto arithmetic types (6.6).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;An attempt is madeto modify an object definedwith a const­qualified type through use of anlvaluewith non-const-qualified type(6.7.3).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A function with externallinkage is declared with an inline function specifier, but is notalso definedin the same translationunit (6.7.4).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The valueof an unnamed member of a structure orunion is used (6.7.8).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The }that terminates a function is reached, and the value of the function callis usedby the caller (6.9.1).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A filewith the same nameas one of the standard headers, not provided as part of the implementation,is placedin anyof the standard placesthatare searched for included source files (7.1.2).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The valueof an argument toa character handling function is neither equal to the valueof EOF nor representable as an unsignedchar (7.4).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The valueof theresult of aninteger arithmetic orconversion function cannot be represented (7.8.2.1,7.8.2.2, 7.8.2.3, 7.8.2.4, 7.20.6.1, 7.20.6.2, 7.20.1).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The valueof a pointer to a FILEobjectis used after the associated file isclosed (7.19.3).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;• The streamforthe fflush function points to an input streamor toan update stream in which the most recentoperation was input (7.19.5.2).&lt;/p&gt;

&lt;p&gt;• The string pointed to by the mode argument in a call to the fopen function does not exactly matchone of the specified character sequences (7.19.5.3).&lt;/p&gt;

&lt;p&gt;• An output operation on an updatestream isfollowed by an input operation without an intervening call to the fflush function or A file positioning function,or an input operation onan update stream is followed byan outputoperation with an intervening call to a file positioning function (7.19.5.3).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A conversion specification for a formattedoutput function uses a # or0 flag with aconversion specifierotherthan thosedescribed (7.19.6.1, 7.24.2.1).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An s conversion specifieris encountered by one of the formatted outputfunctions, and the argumentis missing the null terminator (unless aprecisionis specified that does not requirenull termination)(7.19.6.1, 7.24.2.1).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The contents of the array suppliedin acall to the fgets, gets, or fgetws function are used after a readerror occurred (7.19.7.2, 7.19.7.7, 7.24.3.2).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A non-nullpointer returned bya callto the calloc, malloc,or realloc function with azero requested sizeisused to access an object (7.20.3).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The valueof a pointer that refers to space deallocatedby a call to the free or realloc function is used (7.20.3).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The pointer argument to the free or realloc function does not match a pointer earlier returned by calloc, malloc, or realloc, or the space has been deallocatedby a call to free or realloc (7.20.3.2, 7.20.3.4).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are manymore, but these seemto be the onesthat I run into themostoftenor that come up the most often in C code. Theyare also the most difficult to avoid,so if you at least remember these, you&amp;rsquo;ll be able to avoid the majorones.&lt;/p&gt;

&lt;h2 id=&#34;exercise32-double-linked-lists:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise32. Double Linked Lists&lt;/h2&gt;

&lt;p&gt;The purpose of this book is to teach you how yourcomputer really works, andincluded in thatis how various data structures and algorithms function. Computers by themselves don&amp;rsquo;t doa lot of useful processing. Tomake them do usefulthings,you need to structurethe dataand thenorganize theprocessing of these structures.&lt;/p&gt;

&lt;p&gt;Other programming languages either includelibraries that implementallof these structures,or they have direct syntax for them. Cmakes you implementallof the data structures thatyou need yourself,which makesit the perfect language to learn how theyactually work.&lt;/p&gt;

&lt;p&gt;My goal is to help you do three things:&lt;/p&gt;

&lt;p&gt;• Understandwhat&amp;rsquo;s really going on in Python, Ruby,or JavaScript codelike this: data = {&amp;ldquo;name&amp;rdquo;: &amp;ldquo;Zed&amp;rdquo;}&lt;/p&gt;

&lt;p&gt;• Geteven better at C code by using data structuresto apply what you know to a set of&lt;/p&gt;

&lt;p&gt;solved problems.&lt;/p&gt;

&lt;p&gt;• Learna core set ofdata structuresand algorithmssothat you are better informed about what works best in certain situations.&lt;/p&gt;

&lt;p&gt;What Are Data Structures&lt;/p&gt;

&lt;p&gt;The name data structure is self-explanatory. It&amp;rsquo;s an organization ofdata thatfits a certain model. Maybe the model is designedto allow processing the datain anew way. Maybe it&amp;rsquo;sjust organized to store it on disk efficiently. In this book, I&amp;rsquo;ll follow asimplepattern for makingdata structures that work reliably:&lt;/p&gt;

&lt;p&gt;• Definea structure for the main outer structure.&lt;/p&gt;

&lt;p&gt;• Definea structure for the contents, usually nodeswithlinks between them.&lt;/p&gt;

&lt;p&gt;• Create functions that operate on these two structures.&lt;/p&gt;

&lt;p&gt;There areother styles of data structures in C, but this patternworks welland is consistentformaking most data structures.&lt;/p&gt;

&lt;p&gt;Making the Library&lt;/p&gt;

&lt;p&gt;For therest ofthis book, you&amp;rsquo;ll be creatinga library thatyou canusewhen you&amp;rsquo;re done. Thislibrarywill have the following elements:&lt;/p&gt;

&lt;p&gt;• Header (.h) filesfor each data structure.&lt;/p&gt;

&lt;p&gt;• Implementation (.c) filesforthe algorithms.&lt;/p&gt;

&lt;p&gt;• Unit tests that test all of them to make surethey keep working.&lt;/p&gt;

&lt;p&gt;• Documentation that we&amp;rsquo;ll auto-generate fromthe header files.&lt;/p&gt;

&lt;p&gt;You already have the c-skeleton, so use it to createa liblcthw project:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 32 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ cp -r c-skeleton 
liblcthw 
$ cd liblcthw/
$ ls 
LICENSE Makefile 
$ vim Makefile
$ ls src/
dbg.h libe 
$ mkdir src/lcthw
$ mv src/dbg.hsrc/lcthw$ vim tests/minunit.h
$ rm src/libex29.*tests/libex29*$ make clean 
rm -rf build tests/libex29_tests rm -f tests/tests.log find . -name &amp;quot;*.gc*&amp;quot; 
-exec rm {} \; rm -rf `find . -name &amp;quot;*.dSYM&amp;quot; -print` 
$ ls tests/
minunit.h runtests.sh 
$ 

In this sessionIdo the following: 
• Copy the c-skeleton over. 

• Edit the Makefile to change libYOUR_LIBRARY.a to liblcthw.a as the new TARGET.

• Makethe src/lcthwdirectory, where we&#39;ll putourcode. 

• Move the src/dbg.h into this new directory.

• Edit tests/minunit.h so that ituses

#include &amp;lt;lcthw/dbg.h&amp;gt; as the include. 

• Get rid of thesource and testfiles thatwe don&#39;tneed for libex29.*. 

• Cleanup everything that&#39;s leftover. Now thatyou&#39;re ready tostart building thelibrary,the first data structure that I&#39;ll buildis the doubly linkedlist.

Doubly Linked Lists 


The first data structure that we&#39;ll add to liblcthw is a doubly linked list. This is the simplest data structureyou can make, and it has useful properties for certain operations. A linked list works bynodeshaving pointersto their next or previous element. A doubly linked listcontains pointers to both, while asingly linked list only pointsat the next element. 

Because each node has pointersto thenext and previous elements, and because you keeptrackof the first andlastelements of the list, you can dosome operations very quickly with doubly linked lists. Anything thatinvolves inserting or deletinganelement will be very fast. They&#39;re alsoeasyto implementby most programmers. 

The main disadvantage ofa linked lististhat traversingit involvesprocessingevery single pointer along the way. This meansthat searching, most sorting, and iterating over the elementswillbe slow. 

It also means that you can&#39;t really jump torandom partsof thelist. If you had an array ofelements,you could justindexright into the middleof thelist, buta linked list uses a stream of pointers. 


That meansif you want the tenth element, you have togo through the first nine elements. 

Definition 

As I said in the introduction to this exercise, firstwritea header filewith the right C structure statements init. 
list.h 

```c

#ifndef lcthw_List_h 
#define lcthw_List_h 
#include &amp;lt;stdlib.h&amp;gt; 
struct ListNode;typedef struct 
ListNode {struct ListNode *next;struct ListNode *prev;void *value;} ListNode; 
typedef struct List {int count;ListNode *first;ListNode *last;
} List; 
List *List_create(); 
void List_destroy(List * list);void List_clear(List * list); 
void List_clear_destroy(Lis * list); 
#define List_count(A) ((A)-&amp;gt;count) #define List_first(A) ((A)-&amp;gt;first != NULL ? (A)-&amp;gt;first-&amp;gt;value : NULL) #define List_last(A) ((A)-&amp;gt;last != NULL ? (A)-&amp;gt;last-&amp;gt;value : NULL) 
void List_push(List * list, void *value); void *List_pop(List * list); 
void List_unshift(List * list, void *value); void *List_shift(List * list); 
void *List_remove(List * list, ListNode * node); 
#define LIST_FOREACH(L, S, M, V) ListNode *_node = NULL;\ *V = NULL;\ for(V = _node = L-&amp;gt;S; _node != NULL; V = _node = _node-&amp;gt;M) 
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing Ido is create twostructuresforthe ListNode andthe List thatwillcontain thosenodes. This creates the data structure,whichI&amp;rsquo;ll use in the functions andmacros thatI define after that. If you read these functions, you&amp;rsquo;ll see that they&amp;rsquo;re rathersimple. I&amp;rsquo;ll be explaining them when I cover the implementation, but hopefullyyou canguess what theydo.
Each ListNode has three components within the data structure:&lt;/p&gt;

&lt;p&gt;• A value, which is a pointer to anything, and storesthe thing wewant to put in thelist.&lt;/p&gt;

&lt;p&gt;• A ListNode *next pointer,whichpoints at anotherListNodethat holds the next element in thelist.&lt;/p&gt;

&lt;p&gt;• A ListNode *prevthatholdsthe previous element.&lt;/p&gt;

&lt;p&gt;Complex, right? Calling the previous thing &amp;ldquo;previous.&amp;rdquo; I could have used &amp;ldquo;anterior&amp;rdquo; and &amp;ldquo;posterior,&amp;rdquo; but only ajerkwould do that. The List struct is then nothing more than a container for these ListNode structs thathave beenlinked together in a chain.&lt;/p&gt;

&lt;p&gt;It keeps track of the count, first, and last elements of the list. Finally,take a look at src/lcthw/list.h:37
where I definethe LIST_FOREACH macro.&lt;/p&gt;

&lt;p&gt;This is acommon programming idiom where you make a macrothat generates iteration codeso people can&amp;rsquo;t mess it up.&lt;/p&gt;

&lt;p&gt;Getting this kind of processing right can be difficultwithdata structures, so writing macros helps people out. You&amp;rsquo;llsee how I use this when I talk about the implementation.&lt;/p&gt;

&lt;p&gt;Implementation&lt;/p&gt;

&lt;p&gt;You should mostly understand how a doubly linked listworks. It&amp;rsquo;s nothing more than nodeswithtwo pointersto thenext and previous elements of the list. You can thenwrite the&lt;/p&gt;

&lt;p&gt;src/lcthw /list.c
codeto see how each operation is implemented.&lt;/p&gt;

&lt;p&gt;list.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

1 #include &amp;lt;lcthw/list.h&amp;gt; 
2 #include &amp;lt;lcthw/dbg.h&amp;gt; 
3 
4 List *List_create() 
5 {
6 return calloc(1,sizeof(List)); 
7 }
8 
9 void List_destroy(List * list) 
10 {11 LIST_FOREACH first, next, cur){
12 if (cur-&amp;gt;prev){
13 free &amp;gt;prev); 
1. } 
1. }16 17 free(list-&amp;gt;last); 18 free(list); 
19 } 2. 21 void List_clear(List * list) 
22 {
23 LIST_FOREACH first, next, cur){
24 free(cur &amp;gt;value); 
2. } 
2. } 
2. 28 void List_clear_destroy(Lis * list)
29 { 30 List_clear(l 31 List_destroy 
32 } 33 
34 void List_push(List * list, void *value)35 {
36 ListNode *node = calloc(1, sizeof(ListNode)); 
37 check_mem(no 
38 39 node-&amp;gt;value = value;40 
41 if (list­&amp;gt;last == NULL){
42 list­&amp;gt;first = node;
43 list­&amp;gt;last = node;
44 } else {45 list­&amp;gt;last-&amp;gt;next = node;46 node­&amp;gt;prev = list-&amp;gt;last;
47 list­&amp;gt;last = node;
48 }
49 
50 list-&amp;gt;count++; 
51. 52  error: 53 54 55  }  return; 
56  void *List_pop(List * list)
57 {
58 ListNode *node = list-&amp;gt;last;
59 return node != NULL ? List_remove(list,node): NULL; 
60 }
61 
62 void List_unshift(List * list, void *value)
63 {64 ListNode *node = calloc(1, sizeof(ListNode)); 65 check_mem(no 
66 67 node-&amp;gt;value = value;68 69 if (list-&amp;gt;first == NULL){
70 list­&amp;gt;first = node;
71 list­&amp;gt;last = node;
72 } else {
73 node­&amp;gt;next = list-&amp;gt;first;
74 list­&amp;gt;first-&amp;gt;prev = node;

75 list­&amp;gt;first = node;
76 }
77 
78 list­
&amp;gt;count++;79 *List_shift(List * 
80  error:  
81 82 83  }  return;  
84  void  

list)
85 {
86 ListNode *node = list-&amp;gt;first;
87 return node != NULL ? List_remove(list,node): NULL;
88 }89 
90 void *List_remove(List * list, ListNode * node)
91 {
92 void *result = NULL;
93 
94 check(list­&amp;gt;first &amp;amp;&amp;amp; list-&amp;gt;last,&amp;quot;List is empty.&amp;quot;); 
95 check(node,&amp;quot;node can&#39;t be NULL&amp;quot;); 
96 
97 if (node == list-&amp;gt;first &amp;amp;&amp;amp; node == list-&amp;gt;last){ 
98 list­&amp;gt;first = NULL;
99 list­&amp;gt;last = NULL;
100 } else if (node == list-&amp;gt;first){
101 list­&amp;gt;first = node-&amp;gt;next;
102 check(li &amp;gt;first != NULL,
103 list, somehow got a first that is NULL.&amp;quot;); 
104 list­&amp;gt;first-&amp;gt;prev = NULL;
105 } else if (node == list-&amp;gt;last){
106 list­&amp;gt;last = node-&amp;gt;prev;107 check(li &amp;gt;last != NULL,108

list, somehow got a next that is NULL.&amp;quot;); 109 list­&amp;gt;last-&amp;gt;next = NULL;

11. } else {111 ListNode *after = node-&amp;gt;next;112 ListNode *before = node-&amp;gt;prev;113 after­&amp;gt;prev = before;114 before­&amp;gt;next = after; 
11. } 
11. 117 list­&amp;gt;count--; 118 result = node-&amp;gt;value; 
119 free(node); 
12. 121 error: 
122 return result;

12. } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then implementallof the operations ona doubly linked list that can&amp;rsquo;t be done with simple macros. Rather than cover every tiny,littleline of this file, I&amp;rsquo;m going to give a high-leveloverviewof every operation inboththe list.h and list.c files, and then leaveyou to read the code. list.h:List_count Returns the number of elements in thelist,which is maintained as elements are added andremoved. list.h:List_first Returns the firstelement of the list, butdoesn&amp;rsquo;t remove it. list.h:List_last Returns the lastelement of the list, butdoesn&amp;rsquo;t remove it.&lt;/p&gt;

&lt;p&gt;list.h:LIST_FOREACH&lt;/p&gt;

&lt;p&gt;Iterates over the elements in the list.&lt;/p&gt;

&lt;p&gt;list.c:List_create Simply creates themain List struct.&lt;/p&gt;

&lt;p&gt;list.c:List_destroy Destroys a List and any elementsit might have.&lt;/p&gt;

&lt;p&gt;list.c:List_clear A convenient function for freeing the values in each node,not the nodes.&lt;/p&gt;

&lt;p&gt;list.c:List_clear_destroy Clears and destroys a list. It&amp;rsquo;s notvery efficient since it loops through them twice.&lt;/p&gt;

&lt;p&gt;list.c:List_push The first operation that demonstrates the advantageof a linked list. It adds anew element to the end of the list, and because that&amp;rsquo;s just a couple of pointer assignments, it does itveryfast.&lt;/p&gt;

&lt;p&gt;list.c:List_pop The inverse of List_push, this takes the lastelement off and returnsit.&lt;/p&gt;

&lt;p&gt;list.c:List_unshift The other thing you can easily do to a linked list is add elements to the front of the list very quickly. In thiscase, I call that List_unshift for lack of abetterterm.&lt;/p&gt;

&lt;p&gt;list.c:List_shift Just like List_pop, this removes the first element andreturns it.&lt;/p&gt;

&lt;p&gt;list.c:List_remove This is actually doingall of the removal when you do List&lt;em&gt;pop or List&lt;/em&gt; shift.&lt;/p&gt;

&lt;p&gt;Something that seems to always be difficultin data structuresisremoving things, and this function is no different. It has to handle quite a few conditions depending on if the elementbeing removed is at the front, the end, boththe front and the end, orthe middle.&lt;/p&gt;

&lt;p&gt;Mostof these functionsare nothing special, and you should beable to easilydigest this and understand itfrom just the code. You should definitely focus on howthe LIST_FOREACH macro is used in List_destroy so thatyou canunderstand how much it simplifies this common operation.&lt;/p&gt;

&lt;p&gt;Tests&lt;/p&gt;

&lt;p&gt;After you have those compiling, it&amp;rsquo;s time to create the test that makessure they operate correctly.&lt;/p&gt;

&lt;p&gt;list_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;minunit.h&amp;quot; 
2 #include &amp;lt;lcthw/list.h&amp;gt; 
3 #include &amp;lt;assert.h&amp;gt; 
4 
5 static List *list = NULL;
6 char *test1 = &amp;quot;test1 data&amp;quot;;
7 char *test2 = &amp;quot;test2 data&amp;quot;;
8 char *test3 = &amp;quot;test3 data&amp;quot;;
9 10 char *test_create()
11 {
12 list = List_create(); 
13 mu_assert(li != NULL, &amp;quot;Failed to create list.&amp;quot;); 
1. 
15 return NULL;
16 }
17 
18 char 
*test_destroy() 
19 
20  {  List_clear_d  
21. 
22  return  

NULL;
2. 
24 }
2. 
26 char *test_push_pop()
27 {
28 List_push(li test1); 
29 mu_assert(Li == test1, &amp;quot;Wrong last value.&amp;quot;); 
30 
31 List_push(li test2); 
32 mu_assert(Li == test2, &amp;quot;Wrong last value&amp;quot;); 
33 
34 List_push(li test3); 
35 mu_assert(Li == test3, &amp;quot;Wrong last value.&amp;quot;); 
36 mu_assert(Li == 3, &amp;quot;Wrong count on push.&amp;quot;); 
37 
38 char *val = List_pop(list); 
39 mu_assert(va == test3, &amp;quot;Wrong value on pop.&amp;quot;); 
40 
41 val = List_pop(list); 
42 mu_assert(va == test2, &amp;quot;Wrong value on pop.&amp;quot;); 
43 
44 val = List_pop(list); 
45 mu_assert(va == test1, &amp;quot;Wrong value on pop.&amp;quot;); 
46 mu_assert(Li == 0, &amp;quot;Wrong count 
50 
51 char after 
47  pop.&amp;quot;);  
48  return NULL;
49  } *test_unshift()
52 {
53 List_unshift test1); 
54 mu_assert(Li == test1, &amp;quot;Wrong first value.&amp;quot;); 
55 
56 List_unshift test2); 
57 mu_assert(Li == test2, &amp;quot;Wrong first value&amp;quot;); 
58 
59 List_unshift test3); 
60 mu_assert(Li == test3, &amp;quot;Wrong last value.&amp;quot;); 
61 mu_assert(Li == 3, &amp;quot;Wrong count on unshift.&amp;quot;); 
62 
63 return NULL;
64 }
65 
66 char *test_remove() 
67 {
68 // we only need to test the middle remove case since push/shift
69 // already tests the other cases 
70 
71 char *val = List_remove(list,list-&amp;gt;first-&amp;gt;next); 
72 mu_assert(va == test2, &amp;quot;Wrong removed element.&amp;quot;); 
73 mu_assert(Li == 2, &amp;quot;Wrong count after remove.&amp;quot;); 
74 mu_assert(Li == test3, &amp;quot;Wrong first after remove.&amp;quot;); 
75 mu_assert(Li == test1, &amp;quot;Wrong last after remove.&amp;quot;); 
76 
77 return NULL;
78 }
79 
80 char *test_shift()
81 {
82 mu_assert(Li != 0, &amp;quot;Wrong count before shift.&amp;quot;);
83 
84 char *val = List_shift(list); 
85 mu_assert(va == test3, &amp;quot;Wrong value on shift.&amp;quot;); 
86 
87 val = List_shift(list); 
88 mu_assert(va == test1, &amp;quot;Wrong value on shift.&amp;quot;); 
89 mu_assert(Li == 0, &amp;quot;Wrong count after shift.&amp;quot;); 
90 
91 return NULL;
92 }
93 
94 char *all_tests() 
95 {
96 mu_suite_sta 
97 
98 mu_run_test(99 mu_run_test(
100 mu_run_test(
101 mu_run_test(
102 mu_run_test(
103 mu_run_test(
104 
105 return NULL;
106 }
107 
108 


RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This test simplygoes through every operation and makes sureitworks. I use a simplification in the test where I createjust one List *list for thewhole program, andthen have the tests work on it. Thissaves the trouble of building a List for every test, butit could mean thatsome tests only pass because of how the previous test ran. In this case, I try to make each testkeep the listclear or actually use the results from the previous test.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;If you did everything right, thenwhen you do abuild and run the unit tests, it should look like this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 32.build Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ make 
cc -g -O2 -Wall -Wextra -Isrc ­rdynamic -DNDEBUG ­fPIC -c -o\ 
src/lcthw/list. src/lcthw/list.c ar rcs build/liblcthw.a src/lcthw/list.o ranlib build/liblcthw.a cc -shared -o build/liblcthw.so src/lcthw/list.o cc -g -O2 -Wall -Wextra -Isrc ­rdynamic ­
DNDEBUG build/liblcth tests/list_tests.c 
o tests/list_tests sh ./tests/runtests.sh Running unit tests: 
RUNNING: ./tests/list_tests 
ALL TESTS PASSED Tests run: 6 tests/list_tests PASS 
$ 
RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure six tests ran, it builds without warnings or errors, andit&amp;rsquo;s making the build /liblcthw.a and build/liblcthw.so files.&lt;/p&gt;

&lt;p&gt;How to Improve It&lt;/p&gt;

&lt;p&gt;Instead of breaking this, I&amp;rsquo;m going to tell you how to improve the code:&lt;/p&gt;

&lt;p&gt;• You can make List_clear_destro more efficient byusing LIST_FOREACH and doing both free calls inside one loop.&lt;/p&gt;

&lt;p&gt;• You can addasserts for preconditions so that the program isn&amp;rsquo;t given a NULL value forthe List *list parameters.&lt;/p&gt;

&lt;p&gt;• You can addinvariants that check that the list&amp;rsquo;s contents are always correct, such as count isnever &lt;0, and if count &gt; 0, then first isn&amp;rsquo;t NULL.&lt;/p&gt;

&lt;p&gt;• You can add documentation to the header filein the form ofcomments before each struct,function, and macrothat describes whatit does.&lt;/p&gt;

&lt;p&gt;Theseimprovements speakto the defensive programming practices I talked about earlier, hardening this code against flawsand improving usability. Go aheadand do these things, andthen findas many other waysto improve the code as you can.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Research doubly versus singly linkedlists and when one is preferred over the other.&lt;/p&gt;

&lt;p&gt;• Research the limitations ofa doubly linkedlist. For example, while they are efficient for inserting anddeleting elements, they are very slowforiteratingover them all.&lt;/p&gt;

&lt;p&gt;• What operations are missing that you can imagineneeding? Some examples arecopying, joining, and splitting. Implement these operations andwritethe unit tests for them.&lt;/p&gt;

&lt;h2 id=&#34;exercise33-linkedlist-algorithms:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise33. LinkedList Algorithms&lt;/h2&gt;

&lt;p&gt;Im going tocovertwo algorithmsfor alinked list thatinvolve sorting. I&amp;rsquo;m going to warn youfirst thatif you need tosort the data, then don&amp;rsquo;tuse a linkedlist. These are horribleforsorting things, and there are muchbetter data structures you can use if that&amp;rsquo;s arequirement. I&amp;rsquo;m covering these two algorithms because they are slightly difficult to pull off with a linked list, and to getyou thinking abouthow to efficientlymanipulate them.&lt;/p&gt;

&lt;p&gt;In the interest of writing this book, I&amp;rsquo;m going to put the algorithmsin twodifferent files list_algos.h and list_algos.c then write atestin list_algos_test.c.For now,just follow mystructure, since itkeeps things clean, butif you everwork onother libraries, remember that this isn&amp;rsquo;t acommon structure.&lt;/p&gt;

&lt;p&gt;In this exercise,I&amp;rsquo;m also going to give you anextra challenge and I want you to try not to cheat. I&amp;rsquo;m going to give you the unit test first, and Iwantyou totype itin. Then, I want you to try and implement the twoalgorithms based on their descriptions in Wikipedia beforeseeing if your code looks likemy code.&lt;/p&gt;

&lt;p&gt;Bubble and Merge Sorts&lt;/p&gt;

&lt;p&gt;You know what&amp;rsquo;s awesome about theInternet?Ican just refer you to the &amp;ldquo;bubble sort&amp;rdquo; and &amp;ldquo;mergesort&amp;rdquo; pages on Wikipedia andtell you to readthose. Man, thatsaves me a boatload oftyping. Now I can tellyouhow to actually implementeach of these using the pseudo-code they have there. Here&amp;rsquo;s how you can tacklean algorithmlike this:&lt;/p&gt;

&lt;p&gt;• Readthe description and look atany visualizations it has.&lt;/p&gt;

&lt;p&gt;• Either draw the algorithmon paper using boxesand lines, oractually take a deck ofplaying cards (or cards with numbers) and try todo the algorithmmanually. This gives you a concrete demonstration ofhow the elgorithm works.&lt;/p&gt;

&lt;p&gt;• Create the skeleton functions in your list_algos.c file and make a working list_algos.h file, thensetup your test harness.&lt;/p&gt;

&lt;p&gt;• Write your first failing test andget everything to compile.&lt;/p&gt;

&lt;p&gt;• Go back to the Wikipedia pageand copy-paste the pseudo-code (not the C code!) into the guts of the first function that you&amp;rsquo;re making.&lt;/p&gt;

&lt;p&gt;• Translate this pseudo­code into good C  code the wayI&amp;rsquo;ve taught you, using your unit testto makesure it&amp;rsquo;s working.&lt;/p&gt;

&lt;p&gt;• Fill out somemore tests for edgecases like empty lists, already sorted lists, andthe like.&lt;/p&gt;

&lt;p&gt;• Repeat this for thenext algorithm and test it.&lt;/p&gt;

&lt;p&gt;I just gave you the secret to figuringoutmostof the algorithmsout there—until you get tosome of the more insaneones,that is. In this case, you&amp;rsquo;re just doing the bubbleand merge sorts from Wikipedia, but those will be good starters.&lt;/p&gt;

&lt;p&gt;The Unit Test&lt;/p&gt;

&lt;p&gt;Hereis the unit test you should use forthe pseudo-code:&lt;/p&gt;

&lt;p&gt;list_algos_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;minunit.h&amp;quot; 2 #include &amp;lt;lcthw/list_algos.h&amp;gt; 3 #include 
&amp;lt;assert.h&amp;gt; 
4 #include &amp;lt;string.h&amp;gt; 
5 
6 char *values[] ={ &amp;quot;XXXX&amp;quot;, &amp;quot;1234&amp;quot;,&amp;quot;abcd&amp;quot;, &amp;quot;xjvef&amp;quot;,&amp;quot;NDSS&amp;quot; }; 
7 
8 #define NUM_VALUES 5 
9 
10 List *create_words() 
11 {
12 int i = 0;
13 List *words = List_create(); 
1. 15 for (i = 0;i &amp;lt; NUM_VALUES; i++){
16 List_pus values[i]); 
17 }
1. 19 return words;
20 }
2. 
22 int is_sorted(List * words) 
23 {
24 LIST_FOREACH first, next, cur){ 
25 if (cur-&amp;gt;next &amp;amp;&amp;amp; strcmp(cur-&amp;gt;value, cur-&amp;gt;next-&amp;gt;value)&amp;gt; 
0) {
26 debu %s&amp;quot;, (char *)cur­&amp;gt;value,
27 *)cur-&amp;gt;next-&amp;gt;value); 
28 retu 0;
2. }
30 
} 


31 

32 return 1;
33 }
34 
35 char *test_bubble_sort() 
36 {37 List *words = create_words(); 
38 39 // should work on a list that needs sorting
40 int rc = List_bubble_sort(words (List_compare) strcmp); 
41 mu_assert(rc == 0, &amp;quot;Bubble sort failed.&amp;quot;); 
42 mu_assert(is 
43 &amp;quot;Wor are not sorted after bubble sort.&amp;quot;); 
44 
45 // should work on an already sorted list 
46 rc = List_bubble_sort(words (List_compare)strcmp); 
47 mu_assert(rc == 0, &amp;quot;Bubble sort of 
already sorted 
failed.&amp;quot;); 
48 mu_assert(is 
49 &amp;quot;Wor should be sort if already bubble sorted.&amp;quot;); 
50  
51 52  List_destroy  
53  //  should work  on  an  empty  list
54  words  = List_create(words); 55 rc = List_bubble_sort(words (List_compare)strcmp); 
56 mu_assert(rc == 0, &amp;quot;Bubble sort failed on empty list.&amp;quot;);
57 mu_assert(is &amp;quot;Words should be sorted if empty.&amp;quot;); 
58 
59 List_destroy
60 
61 return NULL;
62 }
63
64 char *test_merge_sort()
65 {
66 List *words = create_words(); 
67 
68 // should work on a list that needs sorting 
69 List *res = List_merge_sort(words,(List_compare)strcmp); 
70 mu_assert(is 
&amp;quot;Words are not sorted after merge sort.&amp;quot;); 
71 
72 List *res2 = List_merge_sort(res,(List_compare)strcmp); 
73 mu_assert(is 
74 &amp;quot;Sho still be sorted after merge sort.&amp;quot;); 
75 List_destroy
76 List_destroy
77 
78 List_destroy
79 return 
NULL;
80 } 
81 82 char *all_tests()
83 84  {  mu_suite_sta  
85  
86 87 88  mu_run_test(mu_run_test(  
89  return  
NULL;90  } 

91 
92 RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I suggest thatyoustart with&lt;/p&gt;

&lt;p&gt;the bubble sortand get that working, andthen moveon to the mergesort. What I would do is layout the function prototypesand skeletons that get allthree files compiling, butnotpassing the test. Then, I&amp;rsquo;d just fillin the implementation until it starts working.&lt;/p&gt;

&lt;p&gt;The Implementation&lt;/p&gt;

&lt;p&gt;Areyou cheating? Infuture exercises, I&amp;rsquo;lljust give you a unit test andtell you to implementit, so it&amp;rsquo;s good practice for you to not look at this code until you getyour own working. Here&amp;rsquo;s the code for the list_algos.c and list_algos.h:
list_algos.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef lcthw_List_algos_h 
#define lcthw_List_algos_h 
#include &amp;lt;lcthw/list.h&amp;gt;

typedef int (*List_compare)(const void *a, const void *b); 
int List_bubble_sort(List * list, List_compare cmp); 
List *List_merge_sort(List * list, List_compare cmp);


#endif 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;list_algos.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;lcthw/list_algos.h&amp;gt; 
2 #include &amp;lt;lcthw/dbg.h&amp;gt; 
3 
4 inline void ListNode_swap(ListNode * a, ListNode * b)
5 {
6 void *temp = a-&amp;gt;value;
7a-&amp;gt;value = b-&amp;gt;value;
8b-&amp;gt;value = temp; 
9 } 
1. 
11 int List_bubble_sort(List * list, List_compare cmp) 
12 
13  {  int  sorted = 1;
14 
15  if (List_count(list) &amp;lt;= 1) { 
16 return 0; // already sorted 
17 } 
1. 
19 do { 
20 sorted = 1; 
21 LIST_FOR first, next, cur){ 
22 if (cur-&amp;gt;next){ 
23 (cmp(cur-&amp;gt;value, cur­&amp;gt;next-&amp;gt;value) &amp;gt; 0) { 24 cur-&amp;gt;next); 
2. = 0; 
2. 
2. } 
2. } 
2. } while (!sorted); 
30 
31 return 0; 
32 } 
33 
34 inline List *List_merge(List * left, List * right,List_compare cmp) 
35 { 
36 List *result = List_create(); 
37 void *val = NULL; 
38 
39 while (List_count(left)&amp;gt;0 || List_count(right)&amp;gt; 0) { 
40 if (List_count(left)&amp;gt;0 &amp;amp;&amp;amp; List_count(right)&amp;gt; 0) { 
41 if (cmp(List_first(left),List_first(right)) &amp;lt;= 0) { 
42 = List_shift(left); 
43 } else { 
44 = List_shift(right); 
45 }
46 
47 List val); 
48 } else if (List_count(left)&amp;gt; 0) { 
49 val = List_shift(left); 
50 List val); 
51 } else if (List_count(right) &amp;gt; 0) {

52 val = List_shift(right); 
53 List val); 
54 } 
55 } 
56 
57 return result; 
58 }

59 
60 List *List_merge_sort(List * list, List_compare cmp) 
61 {
62 if (List_count(list) &amp;lt;= 1) {
63  return list;
64 
65  } 
66  List *left = List_create(); 
67 List *right = List_create(); 
68 int middle = List_count(list)/2;
69 
70 LIST_FOREACH first, next, cur){ 
71 if (middle &amp;gt; 0) { 
72 List cur-&amp;gt;value); 
73 } else {
74 List cur-&amp;gt;value); 
75 
76  }  
77  middle­ -;
78 
79  } 
80 List *sort_left = List_merge_sort(left, cmp); 
81 List *sort_right = List_merge_sort(right, cmp); 
82 
83 if (sort_left != left)
84 List_des 
85 if (sort_right != right)86 List_des 
87 
88 return List_merge(sort_left,sort_right, cmp);
89 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The bubble sort isn&amp;rsquo;t too hard to figure out,althoughit&amp;rsquo;s really slow. The mergesort is much more complicated, and honestly, Icouldprobably spendabit more time optimizing this code if I wanted to sacrificeclarity.&lt;/p&gt;

&lt;p&gt;There is another way to implementa mergesort using abottom-up method, but it&amp;rsquo;s alittleharder tounderstand, so I didn&amp;rsquo;t do it. As I&amp;rsquo;ve already said, sorting algorithmson linkedlists are entirelypointless. You could spendall day trying to make this faster and it will stillbe slower than almost anyother sortable data structure. Simply don&amp;rsquo;t use linked lists if you need to sort things.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;Ifeverything works, then you should getsomething like this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 33 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ make clean all 
rm -rf build src/lcthw/list.o src/lcthw/list_algos.o 
tests/list_algo tests/list_tests rm -f tests/tests.log find . -name &amp;quot;*.gc*&amp;quot; -exec rm {} \; rm -rf `find . -name &amp;quot;*.dSYM&amp;quot; -print` cc -g -O2 -Wall -Wextra -Isrc ­rdynamic -DNDEBUG ­fPIC -c -o\ 
src/lcthw/list. src/lcthw/list.c cc -g -O2 -Wall -Wextra -Isrc ­rdynamic -DNDEBUG ­fPIC -c -o\ 
src/lcthw/list_ src/lcthw/list_algos.c ar rcs build/liblcthw.a src/lcthw/list.o src/lcthw/list_algos.o ranlib build/liblcthw.a cc -shared -o build/liblcthw.so src/lcthw/list.o src/lcthw/list_algos.o cc -g -O2 -Wall -Wextra -Isrc ­rdynamic ­DNDEBUG build/liblcth 
tests/list_algo o tests/list_algos_tests cc -g -O2 -Wall -Wextra -Isrc ­rdynamic ­DNDEBUG build/liblcth 
tests/list_test 
o tests/list_tests sh ./tests/runtests.sh Running unit tests: 
RUNNING: ./tests/list_algos_tes ALL TESTS PASSED 
Tests run: 2 

tests/list_algos_tests PASS 
RUNNING: ./tests/list_tests ALL TESTS PASSED Tests run: 6 tests/list_tests PASS 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this exercise, I&amp;rsquo;mnot going to show you this output unlessit&amp;rsquo;s necessary to show you howit works. From now on, you should knowthat I ran the tests and that they all passed andeverything compiled.
How to Improve It
Goingback to thedescription of the algorithms, there are severalways toimprove these implementations. Here are a few obvious ones:&lt;/p&gt;

&lt;p&gt;• The merge sort doesa crazyamount of copying and creating lists, so find waysto reduce this.&lt;/p&gt;

&lt;p&gt;• The bubble sort description in Wikipedia mentions a few optimizations. Try to implement them.&lt;/p&gt;

&lt;p&gt;• Canyou use the List_split and List_join (if you implemented them) to improve mergesort?&lt;/p&gt;

&lt;p&gt;• Gothrough allof the defensiveprogramming checks and improve the robustnessof this implementation, protectingagainstbad NULL pointers, and thencreate an optional debug level invariant thatworks like is_sorted doesafter asort.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Create aunittest that comparesthe performance of the two algorithms. You&amp;rsquo;ll want to look at man 3 time for abasic timer function, and run enoughiterationsto at least have a few secondsof samples.&lt;/p&gt;

&lt;p&gt;• Play with the emount of data in the lists that need tobe sorted and seeif that changes your timing.&lt;/p&gt;

&lt;p&gt;• Finda way to simulate filling differentsized random lists, measuring how long theytake. Then, graph theresult to see howit compares to thedescription of the algorithm.&lt;/p&gt;

&lt;p&gt;• Try to explain why sortinglinked lists is a really badidea.&lt;/p&gt;

&lt;p&gt;• Implement a List_insert_sorte that will take a given value, and using the List_compare, insert the elementat the rightposition so that the list is always sorted. How does using this methodcompare to sortinga list after you&amp;rsquo;vebuilt it?&lt;/p&gt;

&lt;p&gt;• Try implementing the bottom-up mergesort describedon the Wikipedia page. The code there is already C, so it should beeasyto recreate, but try to understand how it&amp;rsquo;s working compared to the slower one I have here.&lt;/p&gt;

&lt;h2 id=&#34;exercise34-dynamic-array:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise34. Dynamic Array&lt;/h2&gt;

&lt;p&gt;This is an array thatgrows on its own and has most of the same featuresas a linked list. it will usuallytake up less space,runfaster, andhas other beneficial properties. This exercisewillcovera few of the disadvantages,like very slowremovalfrom the front, with a solution to just do itat the end. A dynamic array is simply an array of void ** pointers that&amp;rsquo;s pre-allocatedin one shotand thatpoint at the data.&lt;/p&gt;

&lt;p&gt;In the linked list, you hada full structure thatstored the void *value pointer, but in a dynamic array,there&amp;rsquo;s just a single array with allof them. Thismeans you don&amp;rsquo;t need any other pointers for nextand previous records since you can justindex into the dynamic array directly.&lt;/p&gt;

&lt;p&gt;To start, I&amp;rsquo;llgive you the header fileyoushould type in for the implementation:
darray.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef _DArray_h 
#define _DArray_h 
#include &amp;lt;stdlib.h&amp;gt; 
#include &amp;lt;assert.h&amp;gt; 
#include &amp;lt;lcthw/dbg.h&amp;gt; 
typedef struct DArray 
{ 
int end;
int max;
size_t element_size;
size_t expand_rate;
void **contents;} DArray; 

DArray*DArray_create(size_t element_size, size_t initial_max); 
void DArray_destroy(DArray * array);
void DArray_clear(DArray * array); 
int DArray_expand(DArray * array);
int DArray_contract(DArray * array);
int DArray_push(DArray * array, void *el);
void *DArray_pop(DArray * array);
void DArray_clear_destroy(D * array);

#define DArray_last(A) ((A)-&amp;gt;contents[(A)-&amp;gt;end ­1])
#define DArray_first(A) ((A)­&amp;gt;contents[0])
#define DArray_end(A) ((A)-&amp;gt;end)
#define DArray_count(A) DArray_end(A)
#define DArray_max(A) ((A)-&amp;gt;max)

#define DEFAULT_EXPAND_RATE 300

static inline void DArray_set(DArray * array, int i, void *el)
{ 

check(i &amp;lt; array­&amp;gt;max, &amp;quot;darray attempt to set past max&amp;quot;); 
if (i &amp;gt; array­&amp;gt;end) array-&amp;gt;end = i; 
array­&amp;gt;contents[i]= el; 

error: 
return;
} 

static inline void *DArray_get(DArray * array, int i)
{ 

check(i &amp;lt; array­&amp;gt;max, &amp;quot;darray attempt to get past max&amp;quot;); 
return array­&amp;gt;contents[i]; 

error: 
return NULL;
} 

static inline void *DArray_remove(DArray * array, int i){
void *el = array­&amp;gt;contents[i]; 
array­&amp;gt;contents[i]= NULL; 
return el;} 
static inline void *DArray_new(DArray * array)
{ 

check(array­&amp;gt;element_size &amp;gt; 0, &amp;quot;Can&#39;t use DArray_new on 0 size darrays.&amp;quot;);
return calloc(1, array-&amp;gt;element_size); 
error: 
return NULL;

} 

#define DArray_free(E) free((E)) 
#endif 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This header fileisshowing you anew technique where I put static inline functions rightin the header. Thesefunction definitions will work similarly to the #define macros that you&amp;rsquo;ve been making, but they&amp;rsquo;recleanerand easierto write. If you need to createa block ofcode for a macro and you don&amp;rsquo;tneed code generation, then use a static inline function.&lt;/p&gt;

&lt;p&gt;Compare this technique to the LIST_FOREACH that generates aproper for-loop for alist. This would be impossible todo with a static inline function because itactually has to generate theinner block of codeforthe loop. Theonly way to do that iswith a callback function, but that&amp;rsquo;s notas fastand it&amp;rsquo;s harder to use.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll then change things upand have you create the unit test for &lt;code&gt;DArray&lt;/code&gt;:
darray_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;minunit.h&amp;quot; 
2 #include &amp;lt;lcthw/darray.h&amp;gt;
3 
4 static DArray *array = NULL;
5 static int *val1 = NULL;
6 static int *val2 = NULL;
7 
8 char *test_create() 
9 {
10 array = DArray_create(sizeof(i 100);
11 mu_assert(ar != NULL, &amp;quot;DArray_createfailed.&amp;quot;); 
12 mu_assert(ar &amp;gt;contents != NULL,&amp;quot;contents are wrong in darray&amp;quot;); 
13 mu_assert(ar &amp;gt;end == 0, &amp;quot;end isn&#39;t at the right spot&amp;quot;); 
14 mu_assert(ar &amp;gt;element_size == sizeof(int),
15 &amp;quot;ele size is wrong.&amp;quot;); 
16 mu_assert(ar &amp;gt;max == 100, &amp;quot;wrong max length on initial size&amp;quot;);
1. 18 return NULL;
19 }
20 
21 char *test_destroy() *test_new()
22 
23 
24  {  DArray_destr  
25  return NULL;
26 
27  }
28  char  
29 {
30 val1 = DArray_new(array); 
31 mu_assert(va != NULL, &amp;quot;failed to make a new element&amp;quot;); 
32 
33 val2 = DArray_new(array); 
34 mu_assert(va != NULL, &amp;quot;failed to make a new element&amp;quot;); 
35 
36 return NULL; 
37 }
38 
39 char *test_set()
40 {
41 DArray_set(a 0, val1); 
42 DArray_set(a 1, val2); 
43 
44 return 
NULL;
45 }
46 
47 char *test_get() 

48 { 

49 mu_assert(DA 0) == val1, &amp;quot;Wrong first value.&amp;quot;); 

50 mu_assert(DA 1) == val2, &amp;quot;Wrong second value.&amp;quot;); 

51 

52 return NULL; 

53 } 

54 

55 char *test_remove() 

56 {

57 int *val_check = DArray_remove(array,0); 

58 mu_assert(va != NULL, &amp;quot;Should not get NULL.&amp;quot;); 

59 mu_assert(*v == *val1, &amp;quot;Should get the first value.&amp;quot;); 

60 mu_assert(DA 
0) == NULL, &amp;quot;Should be gone.&amp;quot;); 
61 DArray_free(
62 
63 val_check = DArray_remove(array,1);

64 mu_assert(va != NULL, &amp;quot;Should not get NULL.&amp;quot;); 

65 mu_assert(*v == *val2, &amp;quot;Should get the first value.&amp;quot;); 

66 mu_assert(DA 1) == NULL, &amp;quot;Should be gone.&amp;quot;); 

67 

68  DArray_free( 

69  return NULL;

70 

71  } 

72  char *test_expand_contract( 
73 {
74 int old_max = array-&amp;gt;max;
75 DArray_expan 
76 mu_assert((u int)array-&amp;gt;max == old_max + array­&amp;gt;expand_rate,
77 &amp;quot;Wro size after expand.&amp;quot;); 
78 
79 DArray_contr 
80 mu_assert((u int)array-&amp;gt;max == array-&amp;gt;expand_rate + 1,
81 &amp;quot;Sho stay at the expand_rate at least.&amp;quot;); 
82 
83 DArray_contr 
84 mu_assert((u int)array-&amp;gt;max == array-&amp;gt;expand_rate + 1,
85 &amp;quot;Sho stay at the expand_rate at least.&amp;quot;); 
86 
87 return NULL; 
88 }
89 
90 char *test_push_pop() 
91 {
92 int i = 0;
93 for (i = 0; i &amp;lt; 1000; i++) {
94 int *val = DArray_new(array); 
95 *val = i * 333;
96 DArray_pval);
97 }
98 
99 mu_assert(ar &amp;gt;max == 1201, &amp;quot;Wrong max size.&amp;quot;); 
100 
101 for (i = 999; i &amp;gt;= 0; i--) { 
102 int *val = DArray_pop(array); 
103 mu_asser != NULL, &amp;quot;Shouldn&#39;t get a NULL.&amp;quot;); 
104 mu_asser == i * 333, &amp;quot;Wrong value.&amp;quot;); 
105 DArray_f
106 }
107 
108 return NULL;
109 }
11. 
111 char *all_tests()
112 {
113 mu_suite_sta 
11. 115 mu_run_test(
116 mu_run_test(
117 mu_run_test(
118 mu_run_test(
119 mu_run_test(
120 mu_run_test(
121 mu_run_test(
122 mu_run_test(
12. 
124 return NULL; 
12. }
126 
127 RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This shows youhow allof the operations are used,which thenmakes implementing the &lt;code&gt;DArray&lt;/code&gt; much easier:
darray.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;lcthw/darray.h&amp;gt; 
2 #include &amp;lt;assert.h&amp;gt;
3 
4 DArray *DArray_create(size_t element_size, size_t initial_max)
5 {
6 DArray *array = malloc(sizeof(DArray))
7 check_mem(ar 
8 array-&amp;gt;max = initial_max;
9 check(array­&amp;gt;max &amp;gt; 0, &amp;quot;You must set an initial_max &amp;gt; 0.&amp;quot;);
1. 
11 array­&amp;gt;contents = calloc(initial_max,sizeof(void *)); 
12 check_mem(ar &amp;gt;contents); 
1. 
14 array-&amp;gt;end = 0;
15 array­&amp;gt;element_size = element_size;
16 array­&amp;gt;expand_rate = DEFAULT_EXPAND_RATE;
1. 
18 return array;
19 
20 error: 
21 if (array)
22 free(arr 
23 return NULL;
24 }
2. 
26 void DArray_clear(DArray * array)
27 {
28 int i = 0;
29 if (array­&amp;gt;element_size &amp;gt; 0) { 
30 for (i = 0; i &amp;lt; array-&amp;gt;max;i++) {
31 if (array-&amp;gt;contents[i]!= NULL){ 
32 &amp;gt;contents[i]); 
33 }
34 }
35 }
36 
37  }  
38  static inline int DArray_resize(DArray * array, size_t newsize)
39 {
40 array-&amp;gt;max = newsize;
41 check(array­&amp;gt;max &amp;gt; 0, &amp;quot;The newsize must be &amp;gt; 0.&amp;quot;);
42 
43 void *contents = realloc( 
44 arra &amp;gt;contents, array-&amp;gt;max * sizeof(void *));
45 // check contents and assume realloc doesn&#39;t harm the original on error 
46 
47 check_mem(co 
48 
49 array-&amp;gt;contents = contents;
50 
51 return 0;
52 error: 
53 return -1;
54 } 
55 
56 int DArray_expand(DArray * array)
57 {
58 size_t old_max = array-&amp;gt;max;
59 check(DArrayarray-&amp;gt;max + array­&amp;gt;expand_rate) == 0,
60 &amp;quot;Fai to expand array to new size: %d&amp;quot;,
61 arra &amp;gt;max + (int)array­&amp;gt;expand_rate); 
62 
63 memset(array&amp;gt;contents + old_max,0, array-&amp;gt;expand_rate + 1);
64 
65  return  0;  
66  error:  
67 
68 
69  }  return  -1;  
70  int DArray_contract(DArray * array)
71 {
72 int new_size = array-&amp;gt;end &amp;lt; (int)array­&amp;gt;expand_rate ?
73 (int &amp;gt;expand_rate : array­&amp;gt;end;
74 
75 return DArray_resize(array,new_size + 1); 
76 }
77 
78 void DArray_destroy(DArray * array)
79 {
80 if (array)
{
81 if (array-&amp;gt;contents)
82 free &amp;gt;contents); 
83 free(arr 
84 }
85 }
86 
87 void DArray_clear_destroy(D * array)
88 {
89 DArray_clear 
90 DArray_destr
91 }
92 
93 int DArray_push(DArray * array, void *el) 
94 {
95 array­&amp;gt;contents[array-&amp;gt;end]= el;
96 array­&amp;gt;end++;
97 
98 if (DArray_end(array) &amp;gt;= DArray_max(array)) { 
99 return DArray_expand(array); 
100 } else {
101 return 0;
102 } 
103 }
104 
105 void *DArray_pop(DArray * array)
106 {
107 check(array­&amp;gt;end -1 &amp;gt;= 0, &amp;quot;Attempt to pop from empty array.&amp;quot;);
108 
109 void *el = DArray_remove(array, array-&amp;gt;end -1);
110 array-&amp;gt;end­-;
11. 
112 if (DArray_end(array)&amp;gt; (int)array­&amp;gt;expand_rate
113 &amp;amp;&amp;amp; DArray_end(array)% array-&amp;gt;expand_rate){ 
114 DArray_c
11. }
11. 
117 return el;
118 error: 
119 return NULL; 
12. } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This shows you another way to tackle complexcode. Instead of diving right into the .c implementation, look at the header file, and then readthe unit test. This gives you an abstract-to-concrete understanding of how the pieces worktogether, making it easierto remember.&lt;/p&gt;

&lt;p&gt;Advantages and Disadvantages&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;DArray&lt;/code&gt; is better when you need tooptimizethese operations:&lt;/p&gt;

&lt;p&gt;• Iteration: You can just use abasic for-loop and &lt;code&gt;DArray_count&lt;/code&gt; with &lt;code&gt;DArray_get&lt;/code&gt;, and you&amp;rsquo;re done. No specialmacrosneeded, and
it&amp;rsquo;s faster because you aren&amp;rsquo;t walking through pointers.&lt;/p&gt;

&lt;p&gt;• Indexing: You can use &lt;code&gt;DArray_get&lt;/code&gt; and &lt;code&gt;DArray_set&lt;/code&gt; to access any element at random, butwith a List you have togo through N elementsto get toN+1. • Destroying: You can just free thestructand the contents in two operations. A List requiresa seriesof free calls andwalking every element.&lt;/p&gt;

&lt;p&gt;• Cloning:You can also cloneit in just two operations (plus whateverit&amp;rsquo;s storing) by copying thestruct and contents. Again, alist requireswalking through thewhole thing and copying every ListNode plus its value.&lt;/p&gt;

&lt;p&gt;• Sorting: As you saw, List ishorrible ifyou need tokeep the data sorted. A &lt;code&gt;DArray&lt;/code&gt;opensup a whole class ofgreatsorting algorithms, because now you can access elements randomly.&lt;/p&gt;

&lt;p&gt;• LargeData: If you need to keeparounda lot of data, thena &lt;code&gt;DArray&lt;/code&gt;winssince its base, contents, takes up lessmemory than the same number of ListNode structs.&lt;/p&gt;

&lt;p&gt;However, the List wins on these operations:&lt;/p&gt;

&lt;p&gt;• Insertand removeon the front (what Icalled shift):A &lt;code&gt;DArray&lt;/code&gt; needs specialtreatmentto be able todo this efficiently, andusually it has to do some copying.&lt;/p&gt;

&lt;p&gt;• Splitting orjoining: A List can just copy somepointers and it&amp;rsquo;s done, but with a &lt;code&gt;DArray&lt;/code&gt;,youhave copy all of the arrays involved.&lt;/p&gt;

&lt;p&gt;• SmallData:If you only need tostorea few elements, thentypically the storagewill be smaller in a List than ageneric &lt;code&gt;DArray&lt;/code&gt;.This isbecause the &lt;code&gt;DArray&lt;/code&gt;needs toexpand the backing store to accommodate future inserts,while a List only makes what it needs.&lt;/p&gt;

&lt;p&gt;With this, I prefer to use a &lt;code&gt;DArray&lt;/code&gt; for most of the things you see other people use a List for. Ireserve using List for anydata structure thatrequires a small number ofnodes tobe added and removed from either end. I&amp;rsquo;ll show you twosimilar data structures called a Stack and Queue wherethis is important.&lt;/p&gt;

&lt;p&gt;How to Improve It&lt;/p&gt;

&lt;p&gt;As usual, got hrough each function andoperation and add the defensive programming checks, pre­conditions, invariants, and anything else you can find to makethe implementation more bullet proof.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Improve the unit tests to cover moreof the operations, and test them using a for-loop to ensure that theywork.&lt;/p&gt;

&lt;p&gt;• Research whatit would take toimplement bubble sort andmerge sortfor&lt;code&gt;DArray&lt;/code&gt;, but don&amp;rsquo;tdo it yet. I&amp;rsquo;llbe implementing&lt;code&gt;DArray&lt;/code&gt; algorithmsnext, so you&amp;rsquo;ll do this then.&lt;/p&gt;

&lt;p&gt;• Write some performance tests for common operations and compare them to the same operations in List.Youdid some of this already, but this time,writea unit test thatrepeatedlydoes the operation inquestion and then, in themain runner,do the timing.&lt;/p&gt;

&lt;p&gt;• Look at howthe &lt;code&gt;DArray&lt;/code&gt;_expand is implemented using a constant increase (size +300). Typically, dynamicarraysare implemented with a multiplicative increase (size × 2), but I&amp;rsquo;ve foundthis tocost needless memory for no realperformancegain.&lt;/p&gt;

&lt;p&gt;Test my assertionand see when you&amp;rsquo;d want a multiplicative increase instead of a constant increase.&lt;/p&gt;

&lt;h2 id=&#34;exercise35-sorting-and-searching:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise35. Sorting and Searching&lt;/h2&gt;

&lt;p&gt;In this exercise,I&amp;rsquo;m going to cover foursorting algorithms and one searchalgorithm. The sortingalgorithms are going to be quick sort,heap sort, mergesort, andradix sort. I&amp;rsquo;mthengoing to show you how do a to binary search after you&amp;rsquo;vedonea radixsort.&lt;/p&gt;

&lt;p&gt;However, I&amp;rsquo;m alazy guy, and in most standard C libraries you have existing implementationsof the heapsort, quicksort, and merge sort algorithms. Here&amp;rsquo;s how youusethem:&lt;/p&gt;

&lt;p&gt;darray_algos.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

1 #include &amp;lt;lcthw/darray_algos.h&amp;gt; 
2 #include &amp;lt;stdlib.h&amp;gt; 
3 
4 int DArray_qsort(DArray * array, DArray_compare cmp)
5 {
6 qsort(array­&amp;gt;contents,DArray_count(array), sizeof(void *), cmp); 
7 return 0;
8 }
9 
10 int DArray_heapsort(DArray * array, DArray_compare cmp)
11 {
12 return heapsort(
array­&amp;gt;contents,DArray_count(array), 
13 size *), cmp); 
14 } 
1. 
16 int DArray_mergesort(DArra * array,DArray_compare cmp) 
17 {
18 return mergesort(array­&amp;gt;contents,DArray_count(array), 
19 size *), cmp); 
20 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s the whole implementation of the darray_algos.c file, and it shouldwork onmost modern UNIX systems. What each of these does is sort the contents store ofvoid pointersusing the
&lt;code&gt;DArray_compare&lt;/code&gt; that you giveit. I&amp;rsquo;ll show you the header filefor this, too:
darray_algos.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef darray_algos_h 
#define darray_algos_h 
#include &amp;lt;lcthw/darray.h&amp;gt; 
typedef int (*DArray_compare)(const void *a, const void *b); 
int DArray_qsort(DArray * array, DArray_compare cmp); 
int DArray_heapsort(DArray * array, DArray_compare cmp); 
int DArray_mergesort(DArra * array,DArray_compare cmp); 
#endif 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s about the samesizeand should bewhat you expect. Next, you can see how these functions are used in theunit test for thesethree:
darray_algos_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;minunit.h&amp;quot; 
2 #include &amp;lt;lcthw/darray_algos.h&amp;gt; 
3 
4 int testcmp(char **a,char **b)
5 {
6 return strcmp(*a,*b); 
7 } 
8 
9 DArray *create_words() 
10 {
11 DArray *result = DArray_create(0, 5); 
12 char *words[] = {&amp;quot;asdfasfd&amp;quot;,
13 &amp;quot;werwar&amp;quot; &amp;quot;13234&amp;quot;, &amp;quot;asdfasfd&amp;quot;,&amp;quot;oioj&amp;quot; }; 
14 int i = 0;
1. 
16 for (i = 0; i &amp;lt; 5; i++) {
17 DArray_pwords[i]); 
18 }
1. 
20 return result;
21 }
2. 
23 int is_sorted(DArray * array)
24 {
25 int i = 0;
26 
27 for (i = 0; i &amp;lt; DArray_count(array)­1; i++) {
28 if (strcmp(DArray_get(arr i), DArray_get(array,*run_sort_test(int (*func)(DArray *,DArray_compare), 
i + 1)) 
29  &amp;gt;  0) {  retu 0;

30 
31 
32  }  }
33 
34 
35  }  return  1;  
36  char  

37 const char *name)
38 {
39 DArray *words = create_words(); 
40 mu_assert(!i &amp;quot;Words should start not sorted.&amp;quot;); 
41 
42 debug(&amp;quot;--­Testing %s sorting algorithm&amp;quot;, name); 
43 int rc = func(words,(DArray_compare)testcmp);
44 mu_assert(rc == 0, &amp;quot;sort failed&amp;quot;); 45 mu_assert(is &amp;quot;didn&#39;t sort it&amp;quot;); 
46 
47 DArray_destr 
48 
49 return NULL;
50 }
51 
52 char *test_qsort()
53 {
54 return run_sort_test(DArray_q&amp;quot;qsort&amp;quot;); 
55 }
56 
57 char *test_heapsort()
58 {
59 return 
run_sort_test(DArray_h &amp;quot;heapsort&amp;quot;); 
60 }
61 
62 char *test_mergesort() 
63 {
64 return run_sort_test(DArray_m &amp;quot;mergesort&amp;quot;);
65 }
66 
67 char *all_tests()
68 
69  {  mu_suite_sta  
70  
71 
72 
73 
74  mu_run_test(mu_run_test(mu_run_test( 
75 return NULL;
76 }
77 
78 RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The thing to notice, and actually what tripped me up for awhole day, is the definition of testcmp on line4. You have to use a char ** and not a char * because qsort gives you a pointer to the pointers in the contents array.&lt;/p&gt;

&lt;p&gt;The function qsort and friends are scanning the array, and handing pointers to each element in the array to your comparisonfunction. Since whatI havein the contents array are pointers, that meansyou get a pointer to a pointer.&lt;/p&gt;

&lt;p&gt;With thatout of the way,you havejust implemented three difficultsorting algorithms in about 20lines ofcode. You could stopthere, but part of this bookislearning how these algorithms work, so the Extra Credit section isgoing to involve implementingeach of these.&lt;/p&gt;

&lt;p&gt;Radix Sort and Binary Search&lt;/p&gt;

&lt;p&gt;Since you&amp;rsquo;re going to implementquicksort, heapsort, andmerge sorton your own, I&amp;rsquo;m going to show you afunky algorithm called radix sort. It has a slightly narrow usefulness insorting arrays ofintegers, butseems to worklike magic. In this case, I&amp;rsquo;m going tocreate a specialdata structure called a RadixMap that&amp;rsquo;s usedto mapone integerto another.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the header file for the new algorithm, which is both algorithm and data structure in one:
radixmap.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef _radixmap_h
#include &amp;lt;stdint.h&amp;gt; 

typedef union RMElement {
    uint64_t raw;
    struct {
        uint32_t key;
        uint32_t value;
    } data;
} RMElement; 

typedef struct RadixMap {
    size_t max;
    size_t end;
    uint32_t counter;
    RMElement *contents;
    RMElement *temp;
} RadixMap; 

RadixMap*RadixMap_create(size_ max); 
void RadixMap_destroy(Radix * map);
void RadixMap_sort(RadixMap * map);
RMElement *RadixMap_find(RadixMa * map, uint32_t key);
int RadixMap_add(RadixMap * map, uint32_t key,uint32_t value);
int RadixMap_delete(RadixM * map, RMElement * el);

#endif 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You see that I have alot of the sameoperations as in a Dynamic Array or a List data structure, but the difference is I&amp;rsquo;mworking only with fixed size 32-bit uin32_t integers. I&amp;rsquo;m also introducing you toa new C
concept calledthe union here.&lt;/p&gt;

&lt;p&gt;C Unions&lt;/p&gt;

&lt;p&gt;A unionis a way to refer to the samepiece of memory in anumberof different ways. You define it like a struct, excepteveryelement is sharing the same space with all of the others. You can think of aunion as apicture of the memory, and the elements in the union as differentcolored lenses to viewthe picture.&lt;/p&gt;

&lt;p&gt;What they areused for is to either save memory or convertchunks of memory between formats. Thefirst usage is typically done with varianttypes, where you createa structure that hastag for the type, and then a union inside it for each type. When used forconverting between formats of memory,you can simplydefine the two structures, and thenaccess the rightone.&lt;/p&gt;

&lt;p&gt;First, let meshow you how to make a variant typewithC unions:&lt;/p&gt;

&lt;p&gt;ex35.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 
2 
3 typedef enum {
4 TYPE_INT,
5 TYPE_FLOAT,
6 TYPE_STRING, 
7 
8  } VariantType;  
9  struct Variant {
10  VariantType type;
11 union {
12 int as_integer;
13 float as_float;
14 char *as_string;
15 } data;
16 }; 
1. 
18 typedef struct Variant Variant;
1. 
20 void Variant_print(Variant * var)
21 {
22 switch (var-&amp;gt;type){
23 case TYPE_INT: 
24 prin %d\n&amp;quot;, var­&amp;gt;data.as_integer); 
25 brea 
26 case TYPE_FLOAT: 
27 prin %f\n&amp;quot;, var­&amp;gt;data.as_float); 
28 brea 
29 case TYPE_STRING: 
30 prin %s\n&amp;quot;, var­&amp;gt;data.as_string); 
31 brea 
32 default: 
33 prin 
TYPE: %d&amp;quot;, var­&amp;gt;type); 
34 }
35 }
36
37 int main(int argc, char *argv[]) 
38 {
39 Variant a_int = {.type = TYPE_INT, .data.as_integer = 100 }; 
40 Variant a_float = {.type = TYPE_FLOAT, .data.as_float = 100.
34 }; 
41 Variant a_string = {.type = TYPE_STRING,
42 .data.as = &amp;quot;YO DUDE!&amp;quot; }; 
43 
44 Variant_prin 45 Variant_prin 
46 Variant_prin 
47 
48 // here&#39;s how you access them
49 a_int.data.a = 200;
50 a_float.data = 2.345;
51 a_string.dat = &amp;quot;Hi there.&amp;quot;; 
52 
53 Variant_prin 
54 Variant_prin 
55 Variant_prin 
56 
57 return 0;
58 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You find thisin many implementationsof dynamic languages. The languagewill define some base varianttype with tags for allthe base typesof thelanguage, and thenusually there&amp;rsquo;s a generic object tag forthe types you can create.&lt;/p&gt;

&lt;p&gt;The advantageof doing this is that the Variant only takesup as much space asthe VariantType type tag and the largest member of the union. This is because C is layering each element of the Variant.data union together,sothey overlap. To do that,C sizes theunion big enoughto hold the largest element.&lt;/p&gt;

&lt;p&gt;In the radixmap.h file, I have the RMElement union, which demonstratesusing a unionto convertblocksof memory between types. In this case,I want to store a uint64_t-sized integer for sorting purposes, but I want two uint32_t integers for the datato representa key and value pair. By using a union, I&amp;rsquo;mable to cleanly access the same block of memory in the twodifferent ways Ineed.&lt;/p&gt;

&lt;p&gt;The Implementation&lt;/p&gt;

&lt;p&gt;I next have the actual RadixMap implementation for each of these operations:
radixmap.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

1 
2  /* * Based  on  code by AheavZed  ndre Reinald ily modified A. Shaw.  then by
3 
4  */  
5  #include &amp;lt;stdio.h&amp;gt;
6 #include &amp;lt;stdlib.h&amp;gt; 
7 #include &amp;lt;assert.h&amp;gt; 
8 #include &amp;lt;lcthw/radixmap.h&amp;gt; 
9 #include &amp;lt;lcthw/dbg.h&amp;gt; 
1. 
11 RadixMap *RadixMap_create(size_ max)
12 {
13 RadixMap *map = calloc(sizeof(RadixMap1);
14 check_mem(ma 
1. 
16 map­&amp;gt;contents = calloc(sizeof(RMElemen max + 1); 
17 check_mem(ma &amp;gt;contents); 
1. 
19 map-&amp;gt;temp = calloc(sizeof(RMElemen 
26 error: max + 1); 
20 &amp;gt;temp);
 21  check_mem(ma 
22 max;
23 0;
24  map-&amp;gt;max map-&amp;gt;end  = = 
25  return  map; 
27 return NULL; 
28 } 
2. 
30 void RadixMap_destroy(Radix * map)
31 {
32 if (map){ 
33 free(map &amp;gt;contents); 
34 free(map&amp;gt;temp); 
35 free(map 
36 }
37 }
38 
39 #define ByteOf(x,y) (((uint8_t *)x)[(y)])
40 
41 static inline void radix_sort(short offset, uint64_t max,
42 uint64_t * source, uint64_t * dest)
43 {
44 uint64_t count[256] = { 0 }; 
45 uint64_t *cp = NULL;
46 uint64_t *sp = NULL;
47 uint64_t *end = NULL; 
48 uint64_t s = 0;
49 uint64_t c = 0;
50 
51 // count occurences of every byte value 
52 for (sp = source, end = source 
+ max; sp &amp;lt; end; sp++) { 
53 count[Byoffset)]++;
54 }
55 

56 // transform count into index by summing 
57 // elements and storing into same array 
58 for (s = 0, cp = count, end = count + 256; cp &amp;lt; end; cp++) { 
59 c = *cp;
60 *cp = s;
61 s += c;
62 }
63 

64 // fill dest with the right values in the right place 
65 for (sp = source, end = source + max; sp &amp;lt; end; sp++) {
66 cp = count + ByteOf(sp,offset); 
67 dest[*cp=*sp;68 ++ (*cp); 
69 }
70 }
71 
72 void RadixMap_sort(RadixMap * map)73 {74 uint64_t *source =&amp;amp;map­&amp;gt;contents[0].raw;
75 uint64_t *temp =&amp;amp;map­&amp;gt;temp[0].raw;
76 
77 radix_sort(0 map-&amp;gt;end, source, temp); 
78 radix_sort(1 map-&amp;gt;end, temp, source); 
79 radix_sort(2 map-&amp;gt;end, source,temp); 
80 radix_sort(3 map-&amp;gt;end, temp, source); 
81 }
82 
83 RMElement *RadixMap_find(RadixMa * map, uint32_t to_find)
84 {
85 int low = 0;
86 int high = map-&amp;gt;end -1;
87 RMElement *data = map­&amp;gt;contents;
88 
89 while (low &amp;lt;= high){ 
90 int middle = low +(high -low) / 2;
91 uint32_t key = data[middle].data.key;
92 
93 if (to_find &amp;lt; key){ 
94 high = middle -1;
95 } else if (to_find &amp;gt; key){ 
96 low = middle + 1;
97 } else {
98 retu &amp;amp;data[middle]; 
 99 }
100 
}
101 
102 return NULL; 
103 }
104 
105 int RadixMap_add(RadixMap * map, uint32_t key,uint32_t value)
106 {
107 check(key &amp;lt; UINT32_MAX, &amp;quot;Key can&#39;t be equal to UINT32_MAX.&amp;quot;);
108 
109 RMElement element = {.data = {.key = key,.value = value} }; 
110 check(map-&amp;gt;end +1&amp;lt; map-&amp;gt;max, &amp;quot;RadixMap is full.&amp;quot;); 
11. 
112 map­&amp;gt;contents[map-&amp;gt;end++] = element;
11. 
114 RadixMap_sor 
11. 
116 return 0;
11. 
118 error: 
119 return -1;

120 }

121 
122 int RadixMap_delete(RadixM * map, RMElement * el)
123 {
124 check(map­&amp;gt;end &amp;gt; 0, &amp;quot;There is nothing to delete.&amp;quot;);
125 check(el != NULL, &amp;quot;Can&#39;t delete a NULL element.&amp;quot;);
12. 
127 el­&amp;gt;data.key = UINT32_MAX;
12. 
129 if (map­&amp;gt;end &amp;gt; 1) {
130 // don&#39;t bother resorting a map of 1 length 
131 RadixMap
132 }
133 
134 map-&amp;gt;end--;
135 
136 return 0;
137 error: 
138 return -1;
139 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As usual, enter thisin andget it working, along with the unit test, and then I&amp;rsquo;ll explain what&amp;rsquo;s happening. Take special care with the radix_sort functionsince it&amp;rsquo;sveryparticular in how it&amp;rsquo;s implemented.
radixmap_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;minunit.h&amp;quot; 
2 #include &amp;lt;lcthw/radixmap.h&amp;gt;
3 #include &amp;lt;time.h&amp;gt; 
4 
5 static int make_random(RadixMap * map)
6 {
7 size_t i = 0;
8 
9 for (i = 0;i &amp;lt; map-&amp;gt;max -1;i++) {
10 uint32_t key = (uint32_t) (rand() | (rand() &amp;lt;&amp;lt; 16));
11 check(Ra key, i) == 0, &amp;quot;Failed to add key %u.&amp;quot;,
12 key); 
1. }
1. 15 return i;
1. 17 error: 
18 return 0; 
1. }
2. 21 static int check_order(RadixMap * map)
22 {
23  RMElement d1,
24 int 
25  d2; i =  unsigned 0;
26  // only signal errors if any (should not be)
27 for (i = 0; map-&amp;gt;end &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt; map-&amp;gt;end -1; i++) { 
28 d1 = map-&amp;gt;contents[i]; 
29 d2 = map-&amp;gt;contents[i + 1]; 
30 
31 if (d1.data.key &amp;gt; d2.data.key){ 
32 debu key: %u, value: %u, equals max? %d\n&amp;quot;, i,
33 d1.data.value,34 == UINT32_MAX); 
35 retu 0;
36 }
37 }
38
39 return 1;
40 }
41 
42 static int test_search(RadixMap * map)
43 {44 unsigned i = 0;
45 RMElement *d = NULL;
46 RMElement *found = NULL;
47 
48 for (i = map-&amp;gt;end / 2; i &amp;lt; map-&amp;gt;end; i++) { 
49 d = &amp;amp;map-&amp;gt;contents[i];
50 found = RadixMap_find(map, d­&amp;gt;data.key); 
51 check(fo != NULL, &amp;quot;Didn&#39;t find %u at %u.&amp;quot;, d­&amp;gt;data.key, i); 
52 check(fo &amp;gt;data.key == d­&amp;gt;data.key,
53 the wrong result: %p:%u looking for %u at %u&amp;quot;, found,
54 &amp;gt;data.key, d­&amp;gt;data.key, i); 
55 
56  }  
57 
58  return 1; error:  
59 
60 
61  }  return 0;  
62  // test for big number of elements
63 static char *test_operations() 
64 {
65 size_t N = 200;
66 
67 RadixMap *map = RadixMap_create(N); 
68 mu_assert(ma != NULL, &amp;quot;Failed to make the map.&amp;quot;); 
69 mu_assert(ma &amp;quot;Didn&#39;t make a random fake radix map.&amp;quot;);
70 
71 RadixMap_sor 
72 mu_assert(ch 
73 &amp;quot;Fai to properly sort the RadixMap.&amp;quot;);
74 
75 mu_assert(te &amp;quot;Failed the search test.&amp;quot;); 
76 mu_assert(ch 
77 &amp;quot;Rad didn&#39;t stay sorted after search.&amp;quot;); 
78 
79 while (map­&amp;gt;end &amp;gt; 0) { 
80 RMElemen *el = RadixMap_find(map,
81 &amp;gt;contents[map-&amp;gt;end /2].data.key); 
82 mu_asser != NULL, &amp;quot;Should get a result.&amp;quot;); 
83 
84 size_t old_end = map-&amp;gt;end;
85 
86 mu_asser el) == 0, &amp;quot;Didn&#39;t delete it.&amp;quot;); 
87 mu_asser -1 == map-&amp;gt;end, &amp;quot;Wrong size after 
delete.&amp;quot;); 
88 
89 // test that the end is now the old value, 
90 // but uint32 max so it trails off 
91 mu_asser 
92 didn&#39;t stay sorted after delete.&amp;quot;); 
93 }
94 
95 RadixMap_des 
96
97 return NULL;
98 }
99 
100 char *all_tests() 101 {102 mu_suite_sta 103 srand(time(N 104 105 mu_run_test(106 107 return NULL;
108 } 
109 
110 RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I shouldn&amp;rsquo;thave toexplain toomuch about the test. It&amp;rsquo;s simplysimulating placing random integers into the RadixMap, and then making sureitcan get them out reliably. Not too interesting.&lt;/p&gt;

&lt;p&gt;In the radixmap.c file, most of the operations are easy to understandif you read the code. Here&amp;rsquo;sa description
of what thebasic functions are doingand how they work:&lt;/p&gt;

&lt;p&gt;RadixMap_create As usual, I&amp;rsquo;m allocatingall of the memory needed for the structures definedin radixmap.h. I&amp;rsquo;ll be using the temp and contents later when I talkabout radix_sort.&lt;/p&gt;

&lt;p&gt;RadixMap_destroy Again,I&amp;rsquo;m just destroying what was created.&lt;/p&gt;

&lt;p&gt;radix_sort Here&amp;rsquo;sthe meatof the data structure, but I&amp;rsquo;ll explain what it&amp;rsquo;sdoing in thenextsection.&lt;/p&gt;

&lt;p&gt;RadixMap_sort This uses the radix_sort function toactually sort the contents. Itdoes this by sortingbetween the contents and temp until finally contents is sorted. You&amp;rsquo;ll seehow this works when I describe radix_sort later.&lt;/p&gt;

&lt;p&gt;RadixMap_find This is using abinary search algorithmto find a key you giveit. I&amp;rsquo;llexplain how this worksshortly.&lt;/p&gt;

&lt;p&gt;RadixMap_add Using the RadixMap_sort function, this will add the keyand value you request at the end,then simply sort itagain so thateverything is in the rightplace. Once everythingis sorted, the RadixMap_find will work properly because it&amp;rsquo;sa binary search.&lt;/p&gt;

&lt;p&gt;RadixMap_delete This works thesame as RadixMap_add, exceptit deletes elements of the structure by setting their valuesto the max for a unsigned32-bitinteger, UINT32_MAX. This meansthat you can&amp;rsquo;t use thatvalue as an key value, but it makes deletingelements easy.&lt;/p&gt;

&lt;p&gt;Simply set it to that and thensort, andit&amp;rsquo;ll get moved to the end. Now it&amp;rsquo;sdeleted.&lt;/p&gt;

&lt;p&gt;Study the codeforthe functions I described. That just leaves RadixMap_sort, radix_sort, and RadixMap_find to understand.&lt;/p&gt;

&lt;p&gt;RadixMap_find and Binary Search&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll start with howthe binary searchis implemented. Binary search is asimple algorithm thatmost people can understand intuitively. In fact, you could takea deckof playing cards anddo this manually. Here&amp;rsquo;showthis function works, andhowa binarysearch is done,step by step:&lt;/p&gt;

&lt;p&gt;• Set ahighand low mark basedon the size of the array.&lt;/p&gt;

&lt;p&gt;• Get the middleelement between thelow and high marks.&lt;/p&gt;

&lt;p&gt;• If the key isless-than, then the keymustbe below the middle. Set high to one lessthan middle.&lt;/p&gt;

&lt;p&gt;• If the key isgreater­than, then thekey must&lt;/p&gt;

&lt;p&gt;be above the middle. Set the lowmark one greater than themiddle.&lt;/p&gt;

&lt;p&gt;• If it&amp;rsquo;sequal, you found it. Stop.&lt;/p&gt;

&lt;p&gt;• Keeplooping until low and highpass each other. Youwon&amp;rsquo;tfind it if you exit the loop.&lt;/p&gt;

&lt;p&gt;What you&amp;rsquo;reeffectively doing is guessing where thekey mightbeby picking the middleand comparing it to the high and lowmarks. Since the dataissorted, you know that the thekey has to be above orbelowyour guess. Ifit&amp;rsquo;s below, then you just divided thesearch space in half. Youkeep going until you either find itor you overlapthe boundaries and exhaust the search space.&lt;/p&gt;

&lt;p&gt;RadixMap_sort and radix_sort&lt;/p&gt;

&lt;p&gt;A radix sort is easy to understand ifyou try to do it manually first. What this algorithm does is exploit the fact that numbers are stored with asequenceof digits that go from least significantto most significant. It then takes the numbers andbuckets them by the digit, and when it has processed allof the digits, the numbers come out sorted.&lt;/p&gt;

&lt;p&gt;At firstitseems like magic, and honestly, looking at the codesure seems likeit is,so try doing itmanuallyonce. To do this algorithm, write out a bunchof three-digit numbers in a random order. Let&amp;rsquo;s say we do223, 912, 275,100, 633,120, and380.&lt;/p&gt;

&lt;p&gt;• Place the number in buckets by the ones digit: [380, 100, 120], [912], [633, 223], [275].&lt;/p&gt;

&lt;p&gt;• I now have to go through each of these buckets in order, and thensortit by the tens digit: [100],[912], [120, 223], [633],[275], [380].&lt;/p&gt;

&lt;p&gt;• Now each bucket contains numbers that are sorted by the ones digit andthen the tens digit. I needto thengo through thesein order and fillin the final hundreds digit: [100, 120], [223, 275], [380],[633], [912].&lt;/p&gt;

&lt;p&gt;• At this pointeach bucket is sorted by hundreds,tens and ones, andif I takeeach bucket in order,I get the finalsortedlist: 100, 120, 223, 275, 380, 633, 912. Make sure you do this a few times soyou understand how it works. Itreallyis aslick little algorithm. Most importantly, it will workon numbers ofarbitrary size,so you can sortreally huge numbers because you&amp;rsquo;re just doing them1byte at a time.&lt;/p&gt;

&lt;p&gt;In my situation, the digits (alsocalled placevalues) are individual8-bit bytes,soI need 256 buckets tostorethe distribution of the numbers by theirdigits. Ialso need a way to store them such thatI don&amp;rsquo;tusetoo muchspace. If you look at radix_sort, you&amp;rsquo;ll see that the first thing I do is builda count his togramso I know how many occurrences ofeach digit there are for the given offset.&lt;/p&gt;

&lt;p&gt;Once I know the counts for each digit (all 256 of them), I can then use them as distribution pointsintoa target array. For example, if I have10 bytesthat are0x00, thenI know I canplace them in the first ten slotsof the target array. This givesme an index for where they goin the target array, which is the second for-loop in radix_sort.&lt;/p&gt;

&lt;p&gt;Finally,once I knowwhere theycan go in the target array I simplygo throughall of the digits in the source array for this offset, and place the numbers in theirslots in order. Using the ByteOfmacro helps keep the code clean, since there&amp;rsquo;sa bit of pointer hackery to make it work.&lt;/p&gt;

&lt;p&gt;However,the end result is thatallof the integers will be placed in the bucket for their digitwhen the final for-loop isdone. Whatbecomes interesting is how I use thisin RadixMap_sort to sort these 64-bit integersby just the first32 bits.&lt;/p&gt;

&lt;p&gt;Remember how I have the key and value in a unionforthe RMElement type? That meansthat tosort this array by the key, I only need to sort the first4bytes (32 bits/8 bits per byte) of every integer.&lt;/p&gt;

&lt;p&gt;If youlook at the RadixMap_sort, you see thatIgrab aquickpointerto the contents and temp for source and target arrays, and thenI call radix_sort fourtimes. Each timeI call it, I alternatesourceand target, and do the next byte. When I&amp;rsquo;m done, the radix_sort has done its joband the final copy has been sortedinto the contents.&lt;/p&gt;

&lt;p&gt;How to Improve It&lt;/p&gt;

&lt;p&gt;There is a bigdisadvantage to this implementation because it has to process the entire array fourtimes on every insertion. It doesdo it fast, butit&amp;rsquo;d be better ifyou could limit the emount of sorting by the size of what needs to be sorted.&lt;/p&gt;

&lt;p&gt;There are two ways you can improve thisimplementation:&lt;/p&gt;

&lt;p&gt;• Use a binarysearch to find theminimum position for the new element, thenonly sort fromthereto the end. You find the minimum, put the newelement on the end, and thenjust sortfromthe minimum on. This will cut your sortspacedown considerablymostof the time.&lt;/p&gt;

&lt;p&gt;• Keeptrackof the biggest keycurrently being used, andthen only sort enoughdigits to handle that key. You can also keep trackof the smallest number, and then only sort the digits necessary for the range. Todo this, you&amp;rsquo;ll have tostartcaring about CPU integer ordering (endianness). Try theseoptimizations, but only after you augment the unit test with sometiming informationsoyou cansee if you&amp;rsquo;re actually improving the speed of the implementation.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Implement quicksort, heapsort, andmerge sortand then provide a #define that lets you pickamong the three, or create a second set of functions you can call. Use the technique I taught you to read the Wikipedia pageforthe algorithm, and then implementitwith the pseudo-code.&lt;/p&gt;

&lt;p&gt;• Compare the performance ofyour optimizations to the original implementations.&lt;/p&gt;

&lt;p&gt;• Use thesesorting functions to create a DArray_sort_add thatadds elements to the &lt;code&gt;DArray&lt;/code&gt; but sorts the array afterward.&lt;/p&gt;

&lt;p&gt;• Write a DArray_find that uses the binary search algorithmfrom RadixMap_find and the DArray_compare to find elements in a sorted &lt;code&gt;DArray&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;exercise36-safer-strings:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise36. Safer Strings&lt;/h2&gt;

&lt;p&gt;This exercise isdesigned to get you using bstring from now on, explain why C&amp;rsquo;s strings areanincredibly bad idea, andthen have you change the liblcthw code to use bstring.&lt;/p&gt;

&lt;p&gt;Why C Strings Were a Horrible Idea&lt;/p&gt;

&lt;p&gt;When people talkabout problems with C,they say its concept ofastring isone of the top flaws. You&amp;rsquo;ve been using these extensively, and I&amp;rsquo;ve talked about thekindsof flawstheyhave, but there isn&amp;rsquo;t much thatexplains exactly why C strings are flawed andalways will be. I&amp;rsquo;ll try to explain thatright now, and after decades of using C&amp;rsquo;s strings, there&amp;rsquo;s enoughevidence for me to say that they arejust abad idea.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s impossible to confirm thatany given C stringis valid:&lt;/p&gt;

&lt;p&gt;• A C stringis invalid if it doesn&amp;rsquo;tend in &amp;lsquo;\0&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;• Any loop that processes an invalid C  string will loop infinitely(or just create a buffer overflow).&lt;/p&gt;

&lt;p&gt;• C strings don&amp;rsquo;t have a knownlength,sothe only way to check if they&amp;rsquo;reterminated correctly is to loop through them.&lt;/p&gt;

&lt;p&gt;• Therefore,it isn&amp;rsquo;t possible to validate a C string withoutpossibly looping infinitely.&lt;/p&gt;

&lt;p&gt;This is simple logic. You can&amp;rsquo;t write a loop that checks if a C string is valid because invalid C  stringscause loops to never terminate. That&amp;rsquo;sit, and the only solution is to include the size.&lt;/p&gt;

&lt;p&gt;Once you know thesize, you can avoid the infinite loopproblem. If you look at the two functions I showed you from * Exercise 27, you see this:&lt;/p&gt;

&lt;p&gt;ex36.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;


1 void copy(char to[], char from[]) 
2 {
3 int i = 0;
4 
5 // while loop will not end if from isn&#39;t &#39;\0&#39; terminated 
6 while ((to[i]= from[i]) != &#39;\0&#39;){ 
7 ++i;
8 } 
9 } 
10 
11 int safercopy(int from_len, char *from,int to_len, char *to) 
12 {
13 int i = 0;
14 int max = from_len &amp;gt; to_len -1 ? to_len -1: from_len;
1. 
16 // to_len must have at least 1 byte 
17 if (from_len &amp;lt; 0 || to_len &amp;lt;= 0)
18 return -1;
1. 
20 for (i = 0;i &amp;lt; max; i++) { 
21 to[i]= from[i]; 
22 }
23 
24 to[to_len ­
1] = &#39;\0&#39;;
25 
26 return i;
27 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Imagine thatyou want toadd acheck to the copy function to confirmthat the from string is valid. How would you do that? You&amp;rsquo;dwrite a loop that checkedthat the string ended in &amp;lsquo;\0&amp;rsquo;. Oh wait. If the stringdoesn&amp;rsquo;t end in &amp;lsquo;\0&amp;rsquo;, then how does the checkingloopend? Itdoesn&amp;rsquo;t. Checkmate.&lt;/p&gt;

&lt;p&gt;No matter what you do,you can&amp;rsquo;t check that a C string is valid without knowing the length of the underlying storage, and in this case,the safer copy includes those lengths. This function doesn&amp;rsquo;t have the same problemsince its loops will always terminate, and evenif you lie to itabout the size,youstill have to giveit afinite size.&lt;/p&gt;

&lt;p&gt;What the Better String Librarydoes iscreate a structure thatalways includes the lengthof thestring&amp;rsquo;s storage. Because the length is alwaysavailable to a bstring, thenall ofits operations can be safer. The loops will terminate,the contents can bevalidated, and it won&amp;rsquo;t have this major flaw. The library also comes with a tonof operationsyou need with strings, like splitting, formatting, and searching, and they&amp;rsquo;re most likely done rightand are safer.&lt;/p&gt;

&lt;p&gt;There couldbeflaws in bstring, but it&amp;rsquo;s been around a long time,sothose are probably minimal. Theystill find flaws in glibc, so what&amp;rsquo;s a programmerto do, right?&lt;/p&gt;

&lt;p&gt;Using bstrlib&lt;/p&gt;

&lt;p&gt;There arequitea few improvedstring libraries, but I like bstrlib because it fitsin one file for thebasics, and has most of the stuffyou need to deal with strings. In this exercise you&amp;rsquo;ll needto get two files, bstrlib.c and bstrlib.h,from the Better String Library.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s me doing this in the liblcthw project directory:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 36 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ mkdir bstrlib
$ cd bstrlib/
$ unzip~/Downloads/bstrlib­05122010.zip
Archive: /Users/zeds 05122010.zip ... 
$ ls 
bsafe.c bstr bstrwrap.h lice bsafe.h bstr cpptest.cpp port bstest.c bstrlib.c gpl.txt secu 
$ mv bstrlib.h bstrlib.c ../src/lcthw/$ cd ../
$ rm -rf bstrlib # make the edits
$ vim src/lcthw/bstrlib.c$ make clean all 
... 
$ 


On line 14, you see me edit the bstrlib.c file tomove it toa newlocation and fixa bug on OS X. Here&#39;s the diff file: 

ex36.diff 

```c

25c2. &amp;lt; #include 
&amp;quot;bstrlib.h&amp;quot; 

&amp;gt; #include &amp;lt;lcthw/bstrlib.h&amp;gt;2759c2759 &amp;lt; #ifdef __GNUC__ 
&amp;gt; #if defined(__GNUC__) &amp;amp;&amp;amp; !defined(__APPLE__) 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HereI changethe include to be &lt;lcthw/bstrlib.h&gt;, and then fix oneof the ifdef at line2759.&lt;/p&gt;

&lt;p&gt;Learning the Library&lt;/p&gt;

&lt;p&gt;This exercise is short, and it&amp;rsquo;s meant to simply get you ready for there maining exercises that use the Better String Library. In the next two exercises, I&amp;rsquo;ll use bstrlib.c tocreate a hashmap data structure.&lt;/p&gt;

&lt;p&gt;You should now getfamiliar with this libraryby reading the header file andthe implementations, and then write a tests/bstr_tests.c thattestsout the following functions:
bfromcstr&lt;/p&gt;

&lt;p&gt;Createa bstring from a C style constant.
blk2bstr Do the samething, butgive the length of the buffer.
bstrcpy Copy a&lt;/p&gt;

&lt;p&gt;bstring. bassign Setone bstring to another.
bassigncstr&lt;/p&gt;

&lt;p&gt;Seta bstring to a C string&amp;rsquo;s contents.
bassignblk
Seta bstring to a C string but give the length.
bdestroy
Destroy a bstring.&lt;/p&gt;

&lt;p&gt;bconcat
Concatenateone bstring onto another.
bstricmp
Compare two bstringsreturning the sameresultas strcmp.
biseq Testif twobstrings are equal.
binstr Tell if one bstring is in another.
bfindreplace&lt;/p&gt;

&lt;p&gt;Find one bstring in another,then replace it with a third.
bsplit Splita bstringintoa bstrList.
bformat Doa format string,
which is super handy.
blength Get the length of a bstring.
bdata Get the data from a bstring.
bchar Get a char&lt;/p&gt;

&lt;p&gt;from a bstring.&lt;/p&gt;

&lt;p&gt;Your testshould try out allof&lt;/p&gt;

&lt;p&gt;these operations, anda few more that youfind interesting fromthe header file.&lt;/p&gt;

&lt;h2 id=&#34;exercise37-hashmaps:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise37. Hashmaps&lt;/h2&gt;

&lt;p&gt;Hash maps (hashmaps, hashes, orsometimes dictionaries) are used frequently in dynamic programming for storing key/value data. A hashmap works byperforming a hashing calculation on the keys toproduceaninteger, then usesthat integerto find a bucket to get or set thevalue. It&amp;rsquo;s averyfast,practical data structure because itworks on nearly anydata andis easy to implement.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an exampleof using a hashmap (aka,dictionary) in Python:&lt;/p&gt;

&lt;p&gt;ex37.py&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

fruit_weights = {&#39;Apples&#39;: 10, &#39;Oranges&#39;: 100, &#39;Grapes&#39;: 1.0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for key, value in fruit_weights.items(): print key, &amp;ldquo;=&amp;rdquo;,value
Almosteverymodern languagehassomething like this, so many peopleend up writing codeand never understand how this actually works. By creating the &lt;code&gt;Hashmap&lt;/code&gt; data structurein C, I&amp;rsquo;ll show you howthis works. I&amp;rsquo;ll start with the header file so I can talk about the data structure.&lt;/p&gt;

&lt;p&gt;hashmap.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef _lcthw_Hashmap_h 
#define _lcthw_Hashmap_h 
#include &amp;lt;stdint.h&amp;gt; 
#include &amp;lt;lcthw/darray.h&amp;gt; 
#define DEFAULT_NUMBER_OF_BUCK 100 
typedef int (*Hashmap_compare)(void *a, void *b); typedef
uint32_t(*Hashmap_hash (void *key); 
typedef struct Hashmap {DArray *buckets;Hashmap_compare compare; Hashmap_hashhash;} Hashmap; 
typedef struct HashmapNode {void *key;void *data;uint32_t hash; } HashmapNode; 
typedef int (*Hashmap_traverse_cb)(HashmapNode * node); 
Hashmap*Hashmap_create(Hashma compare,Hashmap_hash); 
void Hashmap_destroy(Hashma * map); 
int Hashmap_set(Hashmap * map, void *key, void *data); 
void *Hashmap_get(Hashmap * map, void *key); 
int Hashmap_traverse(Hashm * map,Hashmap_traverse_cbtraverse_cb); 
void *Hashmap_delete(Hashma * map, void *key);
#endif 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The structureconsists of a &lt;code&gt;Hashmap&lt;/code&gt; that contains any number of HashmapNode structs. Looking at &lt;code&gt;Hashmap&lt;/code&gt;, you can see that it&amp;rsquo;sstructured like this:&lt;/p&gt;

&lt;p&gt;DArray *buckets A dynamicarray thatwill be set to a fixed size of 100 buckets. Each bucket will in turn contain a DArray that willhold HashmapNode pairs.&lt;/p&gt;

&lt;p&gt;Hashmap_compare compare This is a comparisonfunction that the &lt;code&gt;Hashmap&lt;/code&gt; uses to findelementsby their key. Itshould work like all of the other compare functions, and it defaults tousing bstrcmp so thatkeys are just bstrings.&lt;/p&gt;

&lt;p&gt;Hashmap_hash hash&lt;/p&gt;

&lt;p&gt;This is the hashing function, and it&amp;rsquo;s responsible for takinga key, processing its contents, and producing asingle uint32_t index number. You&amp;rsquo;ll see the defaultone soon.&lt;/p&gt;

&lt;p&gt;This almost tellsyou how the data is stored, but the buckets &lt;code&gt;DArray&lt;/code&gt; hasn&amp;rsquo;t been created yet. Just remember that it&amp;rsquo;skind of a two-level mapping:&lt;/p&gt;

&lt;p&gt;• there are 100buckets thatmake up the first level, andthings are in these buckets basedon their hash.&lt;/p&gt;

&lt;p&gt;• Each bucket is a &lt;code&gt;DArray&lt;/code&gt; that contains HashmapNode structs thataresimply appendedto the end as they&amp;rsquo;readded.&lt;/p&gt;

&lt;p&gt;The HashmapNode is then composed of thesethree elements:&lt;/p&gt;

&lt;p&gt;void *key Thekey for this key=value pair.
void *value The value.
uint32_thash The calculated hash, which makesfinding this node quicker. We canjust check the hash andskip any that don&amp;rsquo;tmatch, only checking the keyif
it&amp;rsquo;sequal. The rest of the header file is nothing new, so now I can show you the implementation hashmap.c file:
hashmap.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #undef NDEBUG 
2 #include &amp;lt;stdint.h&amp;gt; 
3 #include &amp;lt;lcthw/hashmap.h&amp;gt; 
4 #include &amp;lt;lcthw/dbg.h&amp;gt; 
5 #include &amp;lt;lcthw/bstrlib.h&amp;gt; 
6
7 static int default_compare(void *a, void *b)
8 {
9 return bstrcmp((bstring) a,(bstring) b); 
10 }
1. 12 /** 
13 * Simple Bob Jenkins&#39;s hash algorithm taken from the
14 * wikipedia description. 
15 */ 
16 static uint32_t default_hash(void *a)
17 {
18 size_t len = blength((bstring)a);
19 char *key = bdata((bstring) a); 
20 uint32_t hash = 0; 
21 = 0;
22  uint32_t  i  
23 i = {
24  0;  i  for (hash = &amp;lt; len; ++i) hash += key[i]; 
25  hash  += (hash 
26  &amp;lt;&amp;lt;  10);  hash  ^= (hash 
27 28  &amp;gt;&amp;gt;  6); }
29  hash  += (hash 
30  &amp;lt;&amp;lt;  3); hash  ^= (hash 
31  &amp;gt;&amp;gt;  11); hash  += (hash 
32  &amp;lt;&amp;lt;  15);
33  return  
hash;
34 
35  }  
36  Hashmap *Hashmap_create(Hashma compare, Hashmap_hash hash)
37 {
38 Hashmap *map = calloc(1,sizeof(Hashmap)); 
39 check_mem(ma 
40 
41 map­&amp;gt;compare = compare == NULL ? default_compare : compare;
42 map-&amp;gt;hash = hash == NULL ? default_hash : hash;
43 map­&amp;gt;buckets = DArray_create(
44 size *),
DEFAULT_NUMBER_OF_BUCK 
45 map­&amp;gt;buckets-&amp;gt;end = map­&amp;gt;buckets-&amp;gt;max; // fake out expanding it 
46 check_mem(ma &amp;gt;buckets); 
47 
48 return map;
49 
50 error: 
51 if (map){ 
57 
58 void 
52 
53 
54  }  Hashmap_  
55  return NULL;56  } Hashmap_destroy(Hashma * map)
59 {60 int i = 0;61 int j = 0;
62 
63 if (map){ 
64 if (map-&amp;gt;buckets){
65 for (i = 0; i &amp;lt; DArray_count(map­&amp;gt;buckets); i++) { 
66 *bucket = DArray_get(map­&amp;gt;buckets, i); 
67 (bucket){
68 (j = 0; j &amp;lt; DArray_count(bucket); j++) {
69 j));
70
71. 
72. 
73 
74  }DArr &amp;gt;buckets); 
75 }
76 
77 free(map 
78 } 
79 } 
80
81 static inline HashmapNode*Hashmap_node_create(i hash, void *key,
82 void *data)
83 {
84 HashmapNode *node = calloc(1,sizeof(HashmapNode)); 
85 check_mem(no 
86 
87 key;
88  node-&amp;gt;key = node-&amp;gt;data = data;
89  node-&amp;gt;hash = hash;
90 
91  return node; 
92 
93 error: 
94 return 
NULL;
95 }
96 
97 static inline DArray*Hashmap_find_bucket(H * map, void *key,
98 int create,
99 uint32_t * hash_out)
100 {
101 uint32_t hash = map­&amp;gt;hash(key); 
102 int bucket_n = hash % DEFAULT_NUMBER_OF_BUCK 
103 check(bucket &amp;gt;= 0, &amp;quot;Invalid bucket 
found: %d&amp;quot;,bucket_n); 
104 // store it for the return so the caller can use it 
105 *hash_out = hash;
106 
107 DArray *bucket = DArray_get(map­&amp;gt;buckets, bucket_n); 
108 
109 if (!bucket &amp;amp;&amp;amp; create){ 
110 // new 
bucket, set it up 
111 bucket = DArray_create(11. *),
DEFAULT_NUMBER_OF_BUCK 
113 check_me 
114 DArray_s &amp;gt;buckets, bucket_n,bucket); 
11. }
116 
117 return bucket;
118 119 error: 
120 return NULL; 
12. }
12. 
123 int Hashmap_set(Hashmap * map, void *key, void *data)
124 {
125 uint32_t hash = 0;
126 DArray *bucket = Hashmap_find_bucket(ma key, 
1, &amp;amp;hash); 
127 check(bucket &amp;quot;Error can&#39;t create bucket.&amp;quot;);
12. 
129 HashmapNode *node = Hashmap_node_create(ha key, data); 
130 check_mem(no 
131 
132 DArray_push(node); 
133
134 return 0;
135 
136 error: 
137 return -1; 
138 }
139
140 static inline int Hashmap_get_node(Hashm * map, uint32_t hash,
141 DArray * bucket, void *key)
142 {
143 int i = 0;
144 
145 for (i = 0;i &amp;lt; DArray_end(bucket); i++) {
146 debug(&amp;quot;T %d&amp;quot;, i); 
147 HashmapN *node = DArray_get(bucket, i);
148 if (node-&amp;gt;hash == hash &amp;amp;&amp;amp; map-&amp;gt;compare(node­&amp;gt;key, key) == 0) {
149 retu i;
150 } 
151 }
152 
153 return -1; 
154 }
155 
156 void *Hashmap_get(Hashmap * map, void *key)
157 {
158 uint32_t hash = 0;
159 DArray *bucket = Hashmap_find_bucket(ma key, 0, &amp;amp;hash);
160 if (!bucket) return NULL;
161 
162 int i = Hashmap_get_node(map, hash, bucket, key);
163 if (i == -1) return NULL;
164
165 HashmapNode *node = DArray_get(bucket,i);
166 check(node != NULL,
167 &amp;quot;Fai to get node from bucket when it should exist.&amp;quot;); 
168 
169 return node-&amp;gt;data;170 171 error: fallthrough 
172 return NULL;
173 }
174 
175 int Hashmap_traverse(Hashm * map, Hashmap_traverse_cb traverse_cb) 
176 {
177 int i = 0;
178 int j = 0;
179 int rc = 0;
180 
181 for (i = 0; i &amp;lt; DArray_count(map-&amp;gt;buckets); i++) {
182 DArray *bucket = DArray_get(map­&amp;gt;buckets, i); 
183 if (bucket){
184 for (j = 0; j &amp;lt; DArray_count(bucket); j++) {
185 *node = DArray_get(bucket, j); 
186 = traverse_cb(node); 
187 (rc != 0) 
188 rc; 
189 } 
190 } 
191 } 
192
193 return 0; 
194 } 
195 
196 void *Hashmap_delete(Hashma * map, void *key)
197 {198 uint32_t hash = 0; 199 DArray *bucket = Hashmap_find_bucket(ma key, 0, &amp;amp;hash); 
200 if (!bucket) 
201 return NULL; 
202 
203 int i = Hashmap_get_node(map, hash, bucket, key); 
204 if (i == -1) 
205 return NULL; 
206 
207 HashmapNode *node = DArray_get(bucket, i); 
208 void *data = node-&amp;gt;data; 
209 free(node); 21. 211 HashmapNode *ending = DArray_pop(bucket); 
21. 
213 if (ending != node){
214 // alright looks like it&#39;s not the last one, swap it 
215 DArray_s i, ending); 
21. } 
21. 
218 return data;
21. } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s nothing very complicated in the implementation, but the default_hash and Hashmap_find_bucket functions will needsome explanation. When you use Hashmap_create, you can pass in anycompare and hash functions you want, but ifyou don&amp;rsquo;t, ituses the default_compare and default_hash functions.&lt;/p&gt;

&lt;p&gt;The first thing tolook at is how default_hash does its thing. This is asimple hash functioncalled a Jenkins hash after Bob Jenkins. I got the algorithm from the &amp;ldquo;Jenkins hash&amp;rdquo; page on Wikipedia. It simplygoes through each byte of the key to hash(a bstring), and then it works thebits so that the end result is asingle uint32_t. Itdoes this with some adding and exclusive or (XOR) operations.&lt;/p&gt;

&lt;p&gt;There are manydifferent hash functions, all with different properties, butonce you have
one, you needa way to use it to findthe rightbuckets. The Hashmap_find_bucket does itlike this:&lt;/p&gt;

&lt;p&gt;• First, itcalls map­&amp;gt;hash(key) toget the hashforthe key.&lt;/p&gt;

&lt;p&gt;• It then findsthe bucket using hash % DEFAULT_NUMBER_OF&lt;/p&gt;

&lt;p&gt;so every hash will alwaysfind some bucket nomatter how bigit is.&lt;/p&gt;

&lt;p&gt;• It then getsthe bucket, which is also a &lt;code&gt;DArray&lt;/code&gt;, and ifit&amp;rsquo;s not there,it willcreate the bucket. However, that depends onif the create variablesays to doso.&lt;/p&gt;

&lt;p&gt;• Onceit has foundthe &lt;code&gt;DArray&lt;/code&gt; bucket for the righthash,itreturns it, and the hash_out variableis usedto give the caller the hash that was found.&lt;/p&gt;

&lt;p&gt;Allof theother functions then use Hashmap_find_bucket to do their work:&lt;/p&gt;

&lt;p&gt;• Setting a key/value involvesfinding the bucket,makinga HashmapNode, and thenadding itto the bucket.&lt;/p&gt;

&lt;p&gt;• Getting akey involves finding thebucket, and thenfinding the HashmapNodethat matches the hash and key thatyou want.&lt;/p&gt;

&lt;p&gt;• Deleting an item finds the bucket, finds where the requested nodeis, and then removesit by swapping the last node into its place.&lt;/p&gt;

&lt;p&gt;The only other functionthat you should study is the Hashmap_traverse.This simplywalks throughevery bucket, and for any bucket that haspossiblevalues, it calls the traverse_cb on each value. This is how you scan awhole &lt;code&gt;Hashmap&lt;/code&gt; for its values.&lt;/p&gt;

&lt;p&gt;The Unit Test&lt;/p&gt;

&lt;p&gt;Finally,you have the unit test
to testallof theseoperations:&lt;/p&gt;

&lt;p&gt;hashmap_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;minunit.h&amp;quot;
2 #include &amp;lt;lcthw/hashmap.h&amp;gt; 
3 #include &amp;lt;assert.h&amp;gt; 
4 #include &amp;lt;lcthw/bstrlib.h&amp;gt; 

5 6 Hashmap *map = NULL;7 static int traverse_called = 0; 
8 struct tagbstring test1 = bsStatic(&amp;quot;test data 1&amp;quot;); 
9 struct tagbstring test2 = bsStatic(&amp;quot;test data 2&amp;quot;); 
10 struct tagbstring test3 = bsStatic(&amp;quot;xest data 3&amp;quot;); 
11 struct tagbstring expect1 = bsStatic(&amp;quot;THE VALUE 1&amp;quot;); 
12 struct tagbstring expect2 = bsStatic(&amp;quot;THE VALUE 2&amp;quot;); 
13 struct tagbstring expect3 = bsStatic(&amp;quot;THE VALUE 3&amp;quot;); 
1. 
15 static int traverse_good_cb(Hashm * node)
16 {
17 debug(&amp;quot;KEY: %s&amp;quot;, bdata((bstring)node-&amp;gt;key)); 
18 traverse_cal 
19 return 0;
20 } 
2. 
22 static int traverse_fail_cb(Hashm * node)
23 {
24 debug(&amp;quot;KEY: %s&amp;quot;, bdata((bstring) node-&amp;gt;key)); 
25 traverse_cal 
26 27 if (traverse_called == 2) {
28 return 1;
29 } else {
30 return 0;
31 } 
32 } 
33 
34 char *test_create()
35 {
36 map = Hashmap_create(NULL,NULL); 
37 mu_assert(ma != NULL, &amp;quot;Failed to create map.&amp;quot;); 
38
39 return NULL;
40 }
41 
42 char *test_destroy() 
43 {
44 Hashmap_dest 
45 
46 return NULL; 
47 } 
48 
49 char *test_get_set() 
50 {
51 int rc = Hashmap_set(map,&amp;amp;test1,&amp;amp;expect1); 
52 mu_assert(rc == 0, &amp;quot;Failed to set &amp;amp;test1&amp;quot;); 
53 bstring result = Hashmap_get(map,&amp;amp;test1); 
54 mu_assert(re == &amp;amp;expect1, &amp;quot;Wrong value for test1.&amp;quot;); 
55 
56 rc = Hashmap_set(map,&amp;amp;test2,&amp;amp;expect2); 
57 mu_assert(rc == 0, &amp;quot;Failed to set test2&amp;quot;); 
58 result = Hashmap_get(map,&amp;amp;test2); 
59 mu_assert(re == &amp;amp;expect2, &amp;quot;Wrong value for test2.&amp;quot;); 
60 
61 rc = Hashmap_set(map,&amp;amp;test3,&amp;amp;expect3);
62 mu_assert(rc == 0, &amp;quot;Failed to set test3&amp;quot;); 
63 result = Hashmap_get(map,&amp;amp;test3); 
64 mu_assert(re == &amp;amp;expect3, &amp;quot;Wrong 
value 
65  for  test3.&amp;quot;);  
66  return  
NULL;
67 
68  }  
69  char *test_traverse() 
70 {
71 int rc = Hashmap_traverse(map,traverse_good_cb);
72 mu_assert(rc == 0, &amp;quot;Failed to traverse.&amp;quot;); 
73 mu_assert(tr == 3, &amp;quot;Wrong count traverse.&amp;quot;); 
74 
75 traverse_cal = 0;
76 rc = Hashmap_traverse(map,traverse_fail_cb); 
77 mu_assert(rc == 1, &amp;quot;Failed to traverse.&amp;quot;); 
78 mu_assert(tr == 2, &amp;quot;Wrong count traverse for fail.&amp;quot;); 
79 
80 return NULL;
81 }
82 
83 char *test_delete() 
84 {
85 bstring deleted =(bstring)Hashmap_delete(map, &amp;amp;test1);
86 mu_assert(de != NULL, &amp;quot;Got NULL on delete.&amp;quot;); 
87 mu_assert(de == &amp;amp;expect1, &amp;quot;Should get test1&amp;quot;); 
88 bstring result = Hashmap_get(map,&amp;amp;test1); 
89 mu_assert(re == NULL, &amp;quot;Should delete.&amp;quot;); 
90 
91 deleted = (bstring)Hashmap_delete(map,&amp;amp;test2); 
92 mu_assert(de != NULL, &amp;quot;Got NULL on delete.&amp;quot;); 
93 mu_assert(de == &amp;amp;expect2, &amp;quot;Should get test2&amp;quot;); 
94 result = Hashmap_get(map,&amp;amp;test2); 
95 mu_assert(re == NULL, &amp;quot;Should delete.&amp;quot;); 
96 
97 deleted = (bstring)Hashmap_delete(map,&amp;amp;test3);
98 mu_assert(de != NULL, &amp;quot;Got NULL on delete.&amp;quot;); 
99 mu_assert(de == &amp;amp;expect3, &amp;quot;Should get test3&amp;quot;); 
100 result = Hashmap_get(map,&amp;amp;test3); 
101 mu_assert(re == NULL, &amp;quot;Should delete.&amp;quot;); 
102
103 return NULL;
104 }
105 
106 char *all_tests() 
107 {
108 mu_suite_sta 
109 
110 mu_run_test(
111 mu_run_test(
112 mu_run_test(
113 mu_run_test(
114 mu_run_test(
11. 
116 return NULL;

11. }
118 
119 RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only thing to learnabout this unittestis that at the top I use a feature of bstring to create static stringsto work within the tests. I use the tagbstring and bsStatic tocreate them on lines 7–13.&lt;/p&gt;

&lt;p&gt;How to Improve It&lt;/p&gt;

&lt;p&gt;This is averysimple implementation of &lt;code&gt;Hashmap&lt;/code&gt;, asare mostof theother data structures in this book. My goalisn&amp;rsquo;tto give youinsanely great,hyper-speed, well-tuned data structures. Usually thoseare much too complicated todiscuss and only distractyou from the real, basic data structureat work. My goal is to give you an understandable starting point to then improveupon or better understand the implementation.&lt;/p&gt;

&lt;p&gt;In this case, there aresome things you can dowith this implementation:
• You can use a sort on each bucket so that they&amp;rsquo;realways sorted. This increasesyour insert time but decreases yourfind
time,because you can then use a binary search to find eachnode. Right now,it&amp;rsquo;s looping through allof thenodes in a bucket just to find one.&lt;/p&gt;

&lt;p&gt;• You can dynamically sizethe number of buckets,or let the caller specify thenumberfor each &lt;code&gt;Hashmap&lt;/code&gt; created.&lt;/p&gt;

&lt;p&gt;• You can use a better default_hash. There are tons of them.&lt;/p&gt;

&lt;p&gt;• This (and nearlyevery &lt;code&gt;Hashmap&lt;/code&gt;)is vulnerable to someone picking keys thatwill fill only onebucket, and thentricking your program into processing them. This then makes your program run slower becauseit changesfrom
processinga Hashmapto effectively processingasingle &lt;code&gt;DArray&lt;/code&gt;.If you sort the nodesin the bucket, this helps, but you can also use better hashing functions, and for the really paranoid programmer, add a random salt so thatkeys can&amp;rsquo;t be predicted.&lt;/p&gt;

&lt;p&gt;• You could have it deletebucketsthat are empty of nodesto save space,or put empty buckets into acache so you can save on time lostcreating and destroying them.&lt;/p&gt;

&lt;p&gt;• Rightnow, it just adds elements evenif they already exist. Writean alternative set method thatonlyadds an element ifit isn&amp;rsquo;t set already. As usual, you shouldgo through each function and makeit bullet proof. The &lt;code&gt;Hashmap&lt;/code&gt; could alsouse a debug setting fordoing an invariant check.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Research the Hashmapimplementation in your favorite programming languageto see what features it has.&lt;/p&gt;

&lt;p&gt;• Findoutwhat themajor disadvantages ofa &lt;code&gt;Hashmap&lt;/code&gt; are and how to avoid them. For example, it doesn&amp;rsquo;t preserve order without specialchanges, nor does itwork when you need to find things based on partsof keys.&lt;/p&gt;

&lt;p&gt;• Write a unit test that demonstrates thedefect offillinga Hashmapwith keys that landin the samebucket, then test how this impacts performance. A good way todo this is to just reduce the number of buckets to something stupid, likefive.&lt;/p&gt;

&lt;h2 id=&#34;exercise38-hashmap-algorithms:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise38. Hashmap Algorithms&lt;/h2&gt;

&lt;p&gt;There are threehash functions that you&amp;rsquo;ll implementin this exercise:
FNV-1a Named after the creators Glenn Fowler, Phong Vo, andLandon Curt Noll,this hash producesgood numbers and is reasonably fast.&lt;/p&gt;

&lt;p&gt;Adler-32 Namedafter Mark Adler, this is a horrible hashalgorithm, butit&amp;rsquo;s been arounda long time and it&amp;rsquo;s good for studying.&lt;/p&gt;

&lt;p&gt;DJBHash This hash algorithmis attributed to DanJ. Bernstein (DJB), butit&amp;rsquo;s difficult to findhisdiscussion of the algorithm. It&amp;rsquo;s shown to befast, but possiblynot great numbers.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ve already seen the Jenkins hash as the default hash forthe &lt;code&gt;Hashmap&lt;/code&gt; data structure,sothis exercise will be looking at thesethree new hash functions. The codefor them is usually small, and it&amp;rsquo;s notoptimized at all. As usual, I&amp;rsquo;m going for understanding and not blindingspeed. The header fileis very simple, so I&amp;rsquo;ll startwith that:&lt;/p&gt;

&lt;p&gt;hashmap_algos.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef hashmap_algos_h 
#define hashmap_algos_h 
#include &amp;lt;stdint.h&amp;gt; 
uint32_t Hashmap_fnv1a_hash(voi *data); 
uint32_t Hashmap_adler32_hash(v *data); 
uint32_t Hashmap_djb_hash(void *data); 
#endif 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m just declaring the three functions I&amp;rsquo;llimplement in the hashmap_algos.cfile:&lt;/p&gt;

&lt;p&gt;hashmap_algos.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;lcthw/hashmap_algos.h 
2 #include &amp;lt;lcthw/bstrlib.h&amp;gt;
3 
4 // settings taken from
5 // http://www.isthe.com/c param
6 const uint32_t FNV_PRIME = 16777619;
7 const uint32_t FNV_OFFSET_BASIS = 2166136261;
8 
9 uint32_t Hashmap_fnv1a_hash(voi *data)
10 {
11 bstring s = (bstring) data;
12 uint32_t hash = 
FNV_OFFSET_BASIS;
13 int i = 0;
1. 
15 for (i = 0;i &amp;lt; blength(s); i++){
16 hash ^= bchare(s, i, 0); 
17 hash *= FNV_PRIME;
18 }
1. 20 return hash;
21 } 
2. 
23 const int MOD_ADLER = 65521;
24 
25 uint32_t Hashmap_adler32_hash(v *data)
26 {
27 bstring s = (bstring) data;
28 uint32_t a = 1, b = 0;29 int i = 0;
30 
31 for (i = 0; i &amp;lt; blength(s); i++){ 
32 a =(a + bchare(s, i, 0)) % MOD_ADLER;33 b =(b + a)% MOD_ADLER; 
34 }
35 
36 return (b
&amp;lt;&amp;lt; 16) | a;
37 }
38 
39 uint32_t Hashmap_djb_hash(void *data)
40 {
41 bstring s = (bstring) data;
42 uint32_t hash = 5381;
43 int i = 0;
44 
45 for (i = 0; i &amp;lt; blength(s); i++){
46 hash = ((hash &amp;lt;&amp;lt; 5) + hash) + bchare(s, i, 0); /*
hash * 33 + c */ 
47 }
48 
49 return hash; 
50 }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This file, then, has the three hash algorithms. Youshould notice thatI&amp;rsquo;m justusing a bstring for thekey, but I&amp;rsquo;m using the bchare function toget acharacter fromthe bstring, but returning0 if that character is outside thestring&amp;rsquo;s length.&lt;/p&gt;

&lt;p&gt;Each of thesealgorithms are foundonline, so go search for them and read about them.&lt;/p&gt;

&lt;p&gt;Again, I primarily used Wikipedia andthen followed it toother sources.
I then have a unit test that tests outeach algorithm, but it also tests whether it will distribute well across a number of buckets:&lt;/p&gt;

&lt;p&gt;hashmap_algos_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;lcthw/bstrlib.h&amp;gt;
2 #include &amp;lt;lcthw/hashmap.h&amp;gt; 
3 #include &amp;lt;lcthw/hashmap_algos.h 
4 #include &amp;lt;lcthw/darray.h&amp;gt; 
5 #include &amp;quot;minunit.h&amp;quot; 
6 
7 struct tagbstring test1 = bsStatic(&amp;quot;test data 1&amp;quot;);
8 struct tagbstring test2 = bsStatic(&amp;quot;test data 2&amp;quot;);
9 struct tagbstring test3 = bsStatic(&amp;quot;xest data 3&amp;quot;);
1. 
11 char *test_fnv1a() 
12 {
13 uint32_t hash = Hashmap_fnv1a_hash(&amp;amp;te 
14 mu_assert(ha != 0, &amp;quot;Bad hash.&amp;quot;); 
1. 
16 hash = Hashmap_fnv1a_hash(&amp;amp;te 
17 mu_assert(ha != 0, &amp;quot;Bad hash.&amp;quot;); 
18 
19 hash = Hashmap_fnv1a_hash(&amp;amp;te 20 mu_assert(ha != 0, &amp;quot;Bad hash.&amp;quot;); 
21 
22 return NULL;
23 }
2. 
25 char *test_adler32() 
26 {
27 uint32_t hash = Hashmap_adler32_hash(&amp;amp; 
28 mu_assert(ha != 0, &amp;quot;Bad hash.&amp;quot;); 
29 
30 hash = Hashmap_adler32_hash(&amp;amp; 
31 mu_assert(ha != 0, &amp;quot;Bad hash.&amp;quot;); 
32 
33 hash = Hashmap_adler32_hash(&amp;amp; 
34 mu_assert(ha != 0, &amp;quot;Bad hash.&amp;quot;); 
35 
36 return
NULL; 
37 }
38 
39 char *test_djb() 
40 {
41 uint32_t hash = Hashmap_djb_hash(&amp;amp;test 
42 mu_assert(ha != 0, &amp;quot;Bad hash.&amp;quot;); 
43 
44 hash = Hashmap_djb_hash(&amp;amp;test 
45 mu_assert(ha != 0, &amp;quot;Bad hash.&amp;quot;); 
46
47 hash = Hashmap_djb_hash(&amp;amp;test
48 != 0,
49  mu_assert(ha &amp;quot;Bad hash.&amp;quot;);
50  return NULL;
51 
52  }
53  #define  BUCKETS 100
54  #define BUFFER_LEN 2. 
55 #define NUM_KEYS BUCKETS * 1000
56 enum {ALGO_FNV1A,ALGO_ADLER32,ALGO_DJB };
57 
58 int gen_keys(DArray * keys, int num_keys)
59 {
60 int i = 0;
61 FILE *urand = fopen(&amp;quot;/dev/urandom&amp;quot;,&amp;quot;r&amp;quot;);
62 check(urand != NULL, &amp;quot;Failed to open /dev/urandom&amp;quot;); 
63 
64 struct bStream *stream = bsopen((bNread)fread, urand); 
65 check(stream != NULL, &amp;quot;Failed to open /dev/urandom&amp;quot;); 
66 
67 bstring key i &amp;lt; num_keys; i++) {= bfromcstr(&amp;quot;&amp;quot;); 
68 int rc 
69  =  0;
70  //  FNV1a his togram 
71  for (i  =  0; 
72 rc = bsread(key, stream,BUFFER_LEN);
73 check(rc &amp;gt;= 0, &amp;quot;Failed to read from /dev/urandom.&amp;quot;); 
74 
75 DArray_pbstrcpy(key)); 
76 
77  }  
78 
79 
80 
81  bsclose(stre fclose(urand return 0;  
82  error:
83 return -1;
84 }
85 
86 void destroy_keys(DArray * keys)
87 {
88 int i = 0;
89 for (i = 0; i &amp;lt; NUM_KEYS; i++) { 
90 bdestroyi));
91 
}92 
93 DArray_destr 
94 } 
95 
96 void fill_distribution(int *stats, DArray * keys,
97 Hashmap_ hash_func)
98 {
99 int i = 0; 
100 uint32_t hash = 0; 
101 
102 for (i = 0; i &amp;lt; DArray_count(keys); i++) {
103 hash = hash_func(DArray_get(k i));104 stats[ha % BUCKETS] += 1; 
105 } 
106 
107 } 
108 
109 char *test_distribution()
110 {
111 int i = 0;
112 int stats[3][BUCKETS]={{0} };
113 DArray *keys = DArray_create(0, NUM_KEYS); 
11. 
115 mu_assert(ge NUM_KEYS) == 0, 
116 &amp;quot;Fai to generate random keys.&amp;quot;); 
11. 118 fill_distrib keys, Hashmap_fnv1a_hash); 
119 fill_distrib keys, Hashmap_adler32_hash); 
120 fill_distrib keys, Hashmap_djb_hash); 
12. 
122 fprintf(stde &amp;quot;FNV\tA32\tDJB\n&amp;quot;); 
12. 
124 for (i = 0; i &amp;lt; BUCKETS; i++) {
125 fprintf(&amp;quot;%d\t%d\t%d\n&amp;quot;, 12. [i], 12. [i], stats[ALGO_DJB] [i]); 
12. }
12. 
130 destroy_keys 
131 
132 return NULL; 
133 }
134 
135 char *all_tests() 
136 {
137 mu_suite_sta 
138 
139 mu_run_test(
140 mu_run_test(
141 mu_run_test(
142 mu_run_test(
143 
144 return NULL; 
145 }146 147 RUN_TESTS(all_te
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have the number of BUCKETS in this codeset fairlyhigh, sinceI have a fast enough computer, butif it runs slow, just lower it and NUM_KEYS. What this test lets me do isrun the test and thenlook at the distribution ofkeys for each hashfunction using abit of analysis with a languagecalled R.&lt;/p&gt;

&lt;p&gt;I do this bycraftinga big list ofkeys using the gen_keys function. Thesekeys are takenoutof the /dev/urandom device and are random byte keys. I then use these keysto have the fill_distribution function fill upthe stats array with where those keys wouldhash in a theoretical set of buckets. All this function doesisgo through all of the keys, do the hash, thendo what the Hashmapwoulddo to find its bucket.&lt;/p&gt;

&lt;p&gt;Finally,I&amp;rsquo;m simplyprinting out a three-column tablewith the finalcountfor each bucket, showing howmany keys managed to getintoeach bucket randomly. Ican then look at these numbers tosee if thehash functions are distributing keysevenly.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;Teaching you Ris outside the scope of this book, but ifyou want to getitand try this, it can be found at www.r­ project.org.&lt;/p&gt;

&lt;p&gt;Hereis anabbreviated shell session that showsme running tests/hashmap_algos_t to get the tableproduced by test_distribution (not shown here), and then using R to see what the summary statistics are.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 38 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ 
tests/hashmap_algos_te # copy-paste the table it prints out
$ vim hash.txt 
$R 
&amp;gt; hash &amp;lt;­read.table(&amp;quot;hash.txt&amp;quot;, header=T)
&amp;gt; summary(hash)

FNV A Min. : 945 Min. : 
908.0 Min. : 92. 1st Qu.: 980 1st Qu.: 980.8 1st Qu.: 979 
Median : 998 Median :1000.0 Median : 998 

Mean :1000 Mean 
3rd Qu.:1016 3rd 
Qu.:1019.2 3rd 
Qu.:102. Max. :1072 Max. 
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, I just run the test, which on your screen will print the table. Then, Ijust copy-paste it out ofmy terminal and use vim hash.txt to save the data. If youlook at the data, it has the header FNV A32 DJB for each of the three algorithms.&lt;/p&gt;

&lt;p&gt;Secondly, I run R and load the datausing the read.table command. This is asmartfunction that works with thiskind oftab­delimited data, andI only have to tell it header=T for it toknow that the data has a header.&lt;/p&gt;

&lt;p&gt;Finally,Ihave the data loaded and canuse summaryto print outitssummary statisticsfor each column. Hereyou cansee that each function actuallydoes alright with this randomdata. Here&amp;rsquo;s whateach of theserows means:&lt;/p&gt;

&lt;p&gt;Min. This is the minimum valuefound forthe data in that column. FNV-la seems to win onthis run since it has the largest number, meaningit has atighter range at the low end.&lt;/p&gt;

&lt;p&gt;1stQu. This is thepoint where the firstquarter of the data ends.&lt;/p&gt;

&lt;p&gt;Median This is the number that&amp;rsquo;s in the middleif you sorted them. Medianismost useful when compared to mean.&lt;/p&gt;

&lt;p&gt;Mean Meanis the average most people think of, and it&amp;rsquo;s the sum divided by thecount of the data. If youlook, allof them are 1,000, which is great. If you compare this to the median, you see that allthree have really close mediansto the mean. What this meansis the data isn&amp;rsquo;t skewedin one direction, so you can trust the mean.&lt;/p&gt;

&lt;p&gt;3rd Qu. This is the point where the lastquarter of the datastarts and representsthe tail end of the numbers.&lt;/p&gt;

&lt;p&gt;Max. This is the maximumnumberof the data, and presents the upperbound on all of them.&lt;/p&gt;

&lt;p&gt;Looking at this data, you see thatall of thesehashes seem to do wellon random keys, and the means matchthe NUM_KEYS setting that I made. What I&amp;rsquo;mlooking for is this:If Imake 1,000 keys perbucket(BUCKETS × 1000), then onaverageeach bucket shouldhave 1,000 keys init.&lt;/p&gt;

&lt;p&gt;If thehash function isn&amp;rsquo;t working, then you&amp;rsquo;llsee these summary statistics show amean that&amp;rsquo;s not 1,000, and really high ranges at the first and third quarters. A good hash functionshould have a dead-on1,000mean, andas tight a range aspossible. You should alsoknow that you&amp;rsquo;ll get different numbers from mine, and even between differentruns of thisunittest.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m finally going to have you do some breaking in this exercise. Iwantyou towrite the worsthash function you can, and then use the datato prove that it&amp;rsquo;sreallybad. You can use R to do the statistics, just like I did, butmaybeyou have another tool thatyou can use to give you the same summary statistics.&lt;/p&gt;

&lt;p&gt;The goalis to make a hash function that seems normal to an untrained eye, but when actually run, it has a bad meanand is all over the place. That means you can&amp;rsquo;t just have it return 1. You have to give a stream of numbers thatseem alrightbut aren&amp;rsquo;t, andthey&amp;rsquo;re loading up somebucketstoo much.&lt;/p&gt;

&lt;p&gt;Extrapoints if you can make aminimal changeto oneof the four hash algorithms thatI gaveyou todo this.&lt;/p&gt;

&lt;p&gt;The purpose of this exercise is to imagine thatsome friendly coder comes to you and offers to improveyour hash function, but actually just makes a nice little back door that really screwsup your &lt;code&gt;Hashmap&lt;/code&gt;. As the Royal Society says, &amp;ldquo;Nullius in verba.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Take the default_hash out of the hashmap.c, makeit one of the algorithmsin hashmap_algos.c, and then make all of the tests work again.&lt;/p&gt;

&lt;p&gt;• Add the default_hash to the hashmap_algos_tes test and compare its statisticsto the other hash functions.&lt;/p&gt;

&lt;p&gt;• Finda few more hash functions andadd them, too. You can never have toomany hash functions!&lt;/p&gt;

&lt;h2 id=&#34;exercise39-string-algorithms:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise39. String Algorithms&lt;/h2&gt;

&lt;p&gt;In this exercise,I&amp;rsquo;m going to show you a supposedly faster string search algorithm, called binstr, and compare it to the one that exists in bstrlib.c. The documentationfor binstr says that itusesa simple &amp;ldquo;brute force&amp;rdquo; string search to find the firstinstance.&lt;/p&gt;

&lt;p&gt;The onethat I&amp;rsquo;ll implement will use the Boyer-Moore-Horspool (BMH) algorithm, which is supposed tobe faster if you analyze the theoretical time. Assuming my implementation isn&amp;rsquo;t flawed, you&amp;rsquo;ll see that thepractical time for BMHis muchworse than the simple bruteforceof binstr.&lt;/p&gt;

&lt;p&gt;The point of this exercise isn&amp;rsquo;t really to explain the algorithm,because it&amp;rsquo;ssimple enoughfor you to read the &amp;ldquo;Boyer-Moore-Horspool algorithm&amp;rdquo; page on Wikipedia.&lt;/p&gt;

&lt;p&gt;The gist of this algorithm is that itcalculates a skip characters list asafirst operation, thenit uses this list to quickly scan throughthe string. It&amp;rsquo;s supposed tobe faster thanbrute force,so let&amp;rsquo;sget the code into the rightfiles and see. First, I have the header:&lt;/p&gt;

&lt;p&gt;string_algos.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef string_algos_h 
#define string_algos_h 
#include &amp;lt;lcthw/bstrlib.h&amp;gt;
#include &amp;lt;lcthw/darray.h&amp;gt; 
typedef struct StringScanner {
bstring in;
const unsigned char *haystack;ssize_t hlen;
const unsigned char *needle;ssize_t nlen;
size_t skip_chars[UCHAR_MAX + 1]; 

} StringScanner; 

int String_find(bstring in, bstring what); 
StringScanner*StringScanner_create(in); 
int StringScanner_scan(Str * scan, bstring to find); 
void StringScanner_destroy(* scan);
#endif 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inorder to see the effects of this skip characters list,I&amp;rsquo;m going to maketwo versions of the BMH algorithm:&lt;/p&gt;

&lt;p&gt;String_find Thissimply finds the firstinstance ofone string inanother, doing the entire algorithmin oneshot.&lt;/p&gt;

&lt;p&gt;StringScanner_scan This uses a StringScanner state structure to separatethe skiplist build from the ectual find.&lt;/p&gt;

&lt;p&gt;This will let me see what impact that has on performance. This model alsogives me the edvantage of incrementally scanning for onestring in another and quickly findingall instances.&lt;/p&gt;

&lt;p&gt;Once you have that, here&amp;rsquo;s the implementation:
string_algos.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;lcthw/string_algos.h&amp;gt; 
2 #include &amp;lt;limits.h&amp;gt; 
3 
4 static inline void String_setup_skip_char * skip_chars,
5 const unsigned char *needle,
6 ssize_t nlen)
7 {
8 size_t i = 0;
9 size_t last = nlen -1;
1. .
11 for (i = 0;i &amp;lt; UCHAR_MAX + 1;i++) {
12 skip_cha = nlen;
13 }
14 
15 for (i = 0; i &amp;lt; last; i++) { 
16 skip_cha = last -i;
17 }
18 }
19 
20 static inline const unsigned char *String_base_search(co unsigned
21 char *haystack, 
22 ssize_t hlen,
23 const unsigned
24 char *needle,
25 ssize_t nlen,
26 size_t * 
27 skip_cha 
28 {
29 size_t i = 0;
30 size_t last = nlen -1. 
31
32 assert(hayst != NULL &amp;amp;&amp;amp; &amp;quot;Given bad haystack to search.&amp;quot;); 
33 assert(needl != NULL &amp;amp;&amp;amp; &amp;quot;Given bad needle to search for.&amp;quot;); 
34 
35 check(nlen &amp;gt; 0, &amp;quot;nlen can&#39;t be &amp;lt;= 0&amp;quot;); 
36 check(hlen &amp;gt; 0, &amp;quot;hlen can&#39;t be &amp;lt;= 0&amp;quot;); 
37
38 while (hlen &amp;gt;= nlen){ 
39 for (i = last; haystack[i] == needle[i]; 
40  i--) { if (i == 
41  0) { haystack;. 
42 .
43 .
44  }  }  
45  hlen  -= skip_chars[haystack[la
46 haystack += skip_chars[haystack[la
47 }
48 
49 error: fallthrough
50 return NULL;
51 }
52 
53 int String_find(bstring in, bstring what)
54 {
55 const unsigned char *found = NULL;
56 
57 const unsigned char *haystack = (const unsigned char *)bdata(in); 
58 ssize_t hlen = blength(in); 
59 const unsigned char *needle = (const unsigned char *)bdata(what); 
60 ssize_t nlen = blength(what); 
61 size_t skip_chars[UCHAR_MAX + 1] = { 0 };
62 
63 String_setupneedle, nlen); 
64 
65 found = String_base_search(hayhlen,
66 nlen, skip_chars); 
67 
68 return found != NULL ? found -haystack : -1;
69 } 
70 
71 StringScanner *StringScanner_create(in)
72 {
73 StringScanne *scan = calloc(1,sizeof(StringScanner)) unsigned char
74 
75  check_mem(sc  
76  scan-&amp;gt;in  = in;
77  scan-&amp;gt;haystack  =  (const *)bdata(in);
78 scan-&amp;gt;hlen = blength(in); 
79 
80 assert(scan != NULL &amp;amp;&amp;amp; &amp;quot;fuck&amp;quot;); 
81 return scan;
82 
83 error: 
84 free(scan); 
85 return
NULL;
86 }
87 
88 static inline void StringScanner_set_need * scan,
89 bstring to find)
90 {
91 scan-&amp;gt;needle = (const unsigned char *)bdata(to find);
92 scan-&amp;gt;nlen = blength(to find); 
93 
94 String_setup&amp;gt;skip_chars, scan­&amp;gt;needle, scan-&amp;gt;nlen); 
95 } 
96 
97 static inline void StringScanner_reset(St * scan)
98 {
99 scan-&amp;gt;haystack = (const unsigned char *)bdata(scan-&amp;gt;in); 
100 scan-&amp;gt;hlen = blength(scan-&amp;gt;in);
101 }
102 
103 int StringScanner_scan(Str * scan, bstring to find)
104 {
105 const unsigned char *found = NULL;
106 ssize_t found_at = 0;
107 .
108 if (scan­&amp;gt;hlen &amp;lt;= 0) { 
109 StringSc 110 return -1;
111 }.
11. .
113 if ((const unsigned char 
*)bdata(to find) != scan-&amp;gt;needle){ 
114 StringSc to find); 
115 }
11. .
117 found = String_base_search(sca &amp;gt;haystack, scan­&amp;gt;hlen,
118 scan 
&amp;gt;needle, scan-&amp;gt;nlen,
119 scan &amp;gt;skip_chars); 
12. .
121 if (found){
122 found_at = found -(const unsigned char *)bdata(scan-&amp;gt;in); 
123 scan­&amp;gt;haystack = found + scan-&amp;gt;nlen;
124 scan­&amp;gt;hlen -= found_at ­scan-&amp;gt;nlen;
125 } else {
126 // done, reset the setup 
127 StringSc .
128 found_at = -1;
12. }
130 
131 return found_at;
132 }
133 
134 void StringScanner_destroy(* scan)
135 {
136 if (scan){ 
137 free(sca
138 } 
139 
} 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The entire algorithm isin two static inline functions called&lt;/p&gt;

&lt;p&gt;String_setup_skip_cha and String_base_search. Theseare then used in the other functions toactually implement the searching styles Iwant. Study these first twofunctions and compare them to theWikipedia
description so that you know&lt;/p&gt;

&lt;p&gt;what&amp;rsquo;s going on. The String_find then just uses these two functions to do afind and return theposition found. It&amp;rsquo;s very simple, and I&amp;rsquo;ll use ittosee how this build skip_chars phase impacts real, practical performance. Keep inmind thatyou couldmaybemake this faster, but I&amp;rsquo;m teaching you how to confirm
theoretical speed after you implementanalgorithm. The&lt;/p&gt;

&lt;p&gt;StringScanner_scan function then follows the common patternI use of create, scan, and destroy, and is used toincrementallyscan astring for another string. You&amp;rsquo;ll seehow this isused when I show you the unit test thatwilltest this out.&lt;/p&gt;

&lt;p&gt;Finally,Ihave theunittest thatfirstconfirms that this is all working, then it runs simple performance tests for all three,finding algorithms in a commented out section.&lt;/p&gt;

&lt;p&gt;string_algos_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;minunit.h&amp;quot; 
2 #include &amp;lt;lcthw/string_algos.h&amp;gt; 
3 #include &amp;lt;lcthw/bstrlib.h&amp;gt;
4 #include &amp;lt;time.h&amp;gt; 
5 
6 struct tagbstring IN_STR = bsStatic(
7 &amp;quot;I have ALPHA beta ALPHA and oranges ALPHA&amp;quot;); 
8 struct tagbstring ALPHA = bsStatic(&amp;quot;ALPHA&amp;quot;); 
9 const int TEST_TIME = 1;
10 
11 char *test_find_and_scan()
12 {
13 StringScanne *scan = StringScanner_create(&amp;amp; 
14 mu_assert(sc != NULL, &amp;quot;Failed to make the scanner.&amp;quot;); 
15 
16 int find_i = String_find(&amp;amp;IN_STR,&amp;amp;ALPHA); 
17 mu_assert(fi &amp;gt; 0, &amp;quot;Failed to find &#39;ALPHA&#39; in test string.&amp;quot;);
18 
19 int scan_i = StringScanner_scan(sca &amp;amp;ALPHA); 
20 mu_assert(sc &amp;gt; 0, &amp;quot;Failed to find &#39;ALPHA&#39; with scan.&amp;quot;); 
21 mu_assert(sc == find_i, &amp;quot;find and scan don&#39;t match&amp;quot;); 
22 
23 scan_i = StringScanner_scan(sca &amp;amp;ALPHA); 
24 mu_assert(sc &amp;gt; find_i,
25 &amp;quot;sho find another ALPHA after the first&amp;quot;); 
26 
27 scan_i = StringScanner_scan(sca &amp;amp;ALPHA); 
28 mu_assert(sc &amp;gt; find_i,
29 &amp;quot;sho find another ALPHA after the first&amp;quot;); 
30 
31 mu_assert(St &amp;amp;ALPHA) == -1, 
32 &amp;quot;sho find it&amp;quot;); 
33 
34 StringScanne 
35 36 return
NULL;
37 }
38 
39 char 

*test_binstr_performan 40 {41 int i = 0;42 int found_at = 0;
43 unsigned long find_count = 0;
44 time_t elapsed = 0;
45 time_t start = time(NULL); 
46 
47 do {
48 for (i = 0; i &amp;lt; 1000; i++) { 
49 foun = binstr(&amp;amp;IN_STR, 0,&amp;amp;ALPHA); 
50 mu_a != BSTR_ERR, &amp;quot;Failed to find!&amp;quot;); 
51 find 
52 }53 54 elapsed 
= time(NULL)-start;
55 } while (elapsed &amp;lt;= TEST_TIME); 
56 
57 debug(&amp;quot;BINST COUNT: %lu, END TIME: %d, OPS: %f&amp;quot;,
58 find (int)elapsed,(double)find_count /elapsed); 
59 return NULL;
60 }
61 
62 char 

*test_find_performance 
63 {
64 int i = 0;65 int 
found_at = 0;
66 unsigned long find_count = 0;
67 time_t elapsed = 0;
68 time_t start = time(NULL); 
69 

70 do {
71 for (i = 0; i &amp;lt; 1000; i++) { 
72 foun = String_find(&amp;amp;IN_STR,&amp;amp;ALPHA); 
73 find 
74 }
75 
76 elapsed 
= time(NULL)-start;
77 } while (elapsed &amp;lt;= TEST_TIME); 
78
79 debug(&amp;quot;FIND COUNT: %lu, END TIME: %d, OPS: %f&amp;quot;,
80 find (int)elapsed,(double)find_count /elapsed); 
81. 
82  return NULL;
83 
84  }
85  char *test_scan_performance 
86 {
87 int i = 0;
88 int found_at = 0;
89 unsigned long find_count = 0;
90 time_t elapsed = 0;
91 StringScanne *scan = StringScanner_create(&amp;amp; 
92 
93 time_t start = time(NULL); 
94 
95 do {
96 for (i = 0; i &amp;lt; 1000; i++) {
97 foun = 0;
98 
99 do {
100 = StringScanner_scan(sca &amp;amp;ALPHA); 101
102 }while (found_at != -1); 
103 }
104
105 elapsed = time(NULL)-start;
106 } while (elapsed &amp;lt;= TEST_TIME);
107 
108 debug(&amp;quot;SCAN COUNT: %lu, END TIME: %d, OPS: %f&amp;quot;,
109 find (int)elapsed, (double)find_count / elapsed);
11. 
111 StringScanne 
11. 
113 return NULL;
11. } 
115 
116 char *all_tests() 
117 {
118 mu_suite_sta 
119 
120 mu_run_test(
121 
122 // this is an idiom for commenting out sections of code 
123 #if 0
124 mu_run_test( 
125 mu_run_test( 
126 mu_run_test( 
127 #endif 
12. 

129 return 
NULL;

130 }
131 
132 RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I haveit writtenhere with #if 0,which is away to use the CPPto comment out a section ofcode. Type it in like this, and then removeit and the #endif so thatyou can see these performance tests run. Asyoucontinue with the book, simply comment these out so that the test doesn&amp;rsquo;twaste development time.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s nothing amazing in this unittest; it just runs each of the differentfunctionsin loops that lastlong enoughto get a few seconds of sampling. Thefirsttest (test_find_and_scan) just confirmsthatwhat I&amp;rsquo;ve writtenworks,because there&amp;rsquo;s nopoint in testing the speed of something that doesn&amp;rsquo;twork. Then,the next three functions run alarge number ofsearches,using each of the three functions.&lt;/p&gt;

&lt;p&gt;The trick to notice is that I grab the starting time in start, and then I loop until at least TEST_TIME seconds havepassed. This makes sure thatIget enough samplesto work with while comparing the three. I&amp;rsquo;ll then run this test with different TEST_TIME settings andanalyze the results.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;When I run thisteston my laptop, I getnumbersthat look like this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 39.1 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ ./tests/string_algos_t
DEBUG tests/string_algos_tes -----RUNNING: 
./tests/string_alg 
RUNNING: ./tests/string_algos_t DEBUG tests/string_algos_tes test_find_and_scan DEBUG tests/string_algos_tes 
test_scan_performance DEBUG tests/string_algos_tes SCAN COUNT:\ 
110272000, END TIME: 2, OPS: 55136000.000000 DEBUG tests/string_algos_tes 
test_find_performance DEBUG tests/string_algos_tes FIND COUNT:\ 
12710000, END TIME: 2, OPS: 6355000.000000 DEBUG tests/string_algos_tes 
test_binstr_performanc DEBUG tests/string_algos_tes BINSTR COUNT:\ 
72736000, END TIME: 2, OPS: 36368000.000000 ALL TESTS PASSED 
Tests run: 4 

$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I look at this and Iwant todo more than 2 secondsfor each run. I want to run this many times, and then useRto check it out like I did before. Here&amp;rsquo;s whatI get for ten samplesfor about 10 seconds each:&lt;/p&gt;

&lt;p&gt;scan find binstr 71195200 6353700 37110200 75098000 37420800 74910000 37263600 74859600 37133200 73345600 37549700 74754400 37162400 75343600 37075000 73804800 36858700 74995200 36811700 74781200 6358400 6351300 6586100 6365200 6358000 6630400 6439900 6384300 6449500 37383000&lt;/p&gt;

&lt;p&gt;The way Igot this isusing a little bitof shellhelp, and then editing the output:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 39.2 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ for i in 12345 6789 1. &amp;gt; do echo &amp;quot;RUN --­ $i&amp;quot; &amp;gt;&amp;gt; times.log &amp;gt; ./tests/string_algos_t 2&amp;gt;&amp;amp;1 | grep COUNT &amp;gt;&amp;gt; times.log &amp;gt; done
$ less times.log
$ vim times.log 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Right away, you can see that the scanning systembeats the pantsoff both of the others, but I&amp;rsquo;ll open this inRand confirmtheresults:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 39.3 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
&amp;gt; times &amp;lt;­read.table(&amp;quot;times.log&amp;quot; header=T)&amp;gt; summary(times)
scan Min. :71195200 Mi 1st 
Qu.:74042200 1st Qu.:6358100 1st Qu.:37083800 
Median 
:74820400  Median  
:6374750  Median  
:37147800  
Mean  :74308760  Me  
3rd  
Qu.:74973900  3rd  
Qu.:6447100  3rd  
Qu.:37353150  
Max.  :75343600  Ma  
&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To understand why I&amp;rsquo;m getting the summary statistics, I have to explain somestatistics for you. What I&amp;rsquo;m looking forin these numbers issimply this: &amp;ldquo;Are these three functions (scan, find, bsinter) actually different?&amp;rdquo; I know thateach time I run my tester function, I getslightly different numbers, and thosenumbers can cover a certain range. You seehere that the first and third quarters do that for each sample.&lt;/p&gt;

&lt;p&gt;What I look at first is the mean, and I want to see if each sample&amp;rsquo;s mean is differentfrom theothers. I can see that, and clearly the scan beats binstr, which also beats find. However,I have a problem. If I use just the mean, there&amp;rsquo;s a chance that the ranges ofeach sample mightoverlap.&lt;/p&gt;

&lt;p&gt;What if I have meansthat are different, but the firstand third quarters overlap? In that case, Icouldsaythat ifI ran the samples again there&amp;rsquo;s a chancethat themeans might notbe different. The more overlapI have in the ranges, the higher probability that my two samples(andmy two functions)are not actually different. Any difference that I&amp;rsquo;m seeing in the two (in this casethree) is just random chance.&lt;/p&gt;

&lt;p&gt;There are manytoolsthat you can use to solve this problem, butin our case, Icanjust look at the firstand third quarters and the meanforall three samples. If themeans are different, andthe quartersare way offwithno possibility of overlapping,thenit&amp;rsquo;s alright to say that they are different.&lt;/p&gt;

&lt;p&gt;In my three samples,I can say that scan, find, and binstr are different,don&amp;rsquo;t overlapin range, and I can trust the sample (for the most
part).&lt;/p&gt;

&lt;p&gt;Analyzing the Results&lt;/p&gt;

&lt;p&gt;Looking at the results,I can see that String_find is much slower than the other two. In fact, it&amp;rsquo;s so slow that I&amp;rsquo;d think there&amp;rsquo;ssomething wrong withhowI implemented it. However, when I compareit to StringScanner_scan,I can see that it&amp;rsquo;s most likely the part that builds theskip list that&amp;rsquo;s costing the time. Notonly is find slower,it&amp;rsquo;s also doing less than scan because it&amp;rsquo;s just finding the first string while scan finds all of them.
I can alsosee that scan beats binstr, as well, and by quite alargemargin. Again, notonly does scan do more thanboth of these, but it&amp;rsquo;s also much faster.&lt;/p&gt;

&lt;p&gt;There area few caveats with this analysis:
• Imay havemessed up this implementation or the test. At this point I would go research all of the possibleways to do aBMH algorithm and try to improveit. I would alsoconfirm that I&amp;rsquo;m doing the test right.&lt;/p&gt;

&lt;p&gt;• If you alterthe time the test runs,you&amp;rsquo;llget&lt;/p&gt;

&lt;p&gt;differentresults. There is awarm-up period thatI&amp;rsquo;m not investigating.&lt;/p&gt;

&lt;p&gt;• The test_scan_perform unit test isn&amp;rsquo;t quite the same asthe others, but it&amp;rsquo;sdoing more than the other tests, so it&amp;rsquo;s probably alright.
• I&amp;rsquo;monlydoing the test by searching for one string inanother. I could randomize the strings to find their position and lengthas a confounding factor.&lt;/p&gt;

&lt;p&gt;• Maybe binstr is implemented better than simple brute force.&lt;/p&gt;

&lt;p&gt;• Icouldberunning these in an unfortunateorder. Mayberandomizing which test runs first will givebetter results.&lt;/p&gt;

&lt;p&gt;Onething to gatherfrom this is thatyou need to confirm realperformanceeven ifyou implementanalgorithm correctly. In this case, the claim isthat theBMH algorithm should havebeaten the binstr algorithm, buta simple test proved it didn&amp;rsquo;t. Had Inotdone this,Iwould havebeen using an inferior algorithm implementation without knowing it. With these metrics, I canstart to tunemy implementation, or simplyscrap it andfind anotherone.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Seeif you can make the Scan_find faster. Why ismy implementation here slow?&lt;/p&gt;

&lt;p&gt;• Try some different scan timesand see if you get differentnumbers.&lt;/p&gt;

&lt;p&gt;Whatimpact does the length of time thatyou run the testhave on the scan times?Whatcan you say about that result?&lt;/p&gt;

&lt;p&gt;• Alter theunittest so that itrunseach function for a short burst in thebeginning to clearout any warm-up period, and then start the timing portion.&lt;/p&gt;

&lt;p&gt;Does that change the dependenceon the length of time the test runs? Does itchange how many operations persecond are possible?&lt;/p&gt;

&lt;p&gt;• Makethe unit test randomize thestrings to find andthen measure the performance you get. Oneway to do this is to use the bsplitfunction from bstrlib.h tosplit the IN_STR on spaces. Then, you can use the bstrList struct that you get toaccess each string itreturns. This willalso teach you how to use bstrList operations for string processing.&lt;/p&gt;

&lt;p&gt;• Try some runs with the tests in different orders to see if you get differentresults.&lt;/p&gt;

&lt;h2 id=&#34;exercise40-binary-search-trees:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise40. Binary Search Trees&lt;/h2&gt;

&lt;p&gt;The binarytree is the simplest tree-baseddata structure, and even though it&amp;rsquo;s been replaced byhash maps in many languages, it&amp;rsquo;s still useful for many applications. Variants on the binary tree existforveryusefulthings likedatabase indexes, search algorithm structures, and even graphics.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m calling my binary treea &lt;code&gt;BSTree&lt;/code&gt; for binary search tree, andthe best way to describe it is that it&amp;rsquo;s another way to do a &lt;code&gt;Hashmap&lt;/code&gt; style key/value store. The difference is thatinsteadof hashing thekey to find a location, the &lt;code&gt;BSTree&lt;/code&gt; comparesthe key tonodesin atree, and then walksthrough the tree to find thebest place to store it, based on howit comparesto other nodes.
Before I reallyexplain how this works, letme show you the bstree.h headerfile so thatyou cansee the data structures, and thenI can use thatto explain how it&amp;rsquo;s built.&lt;/p&gt;

&lt;p&gt;bstree.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef _lcthw_BSTree_h 
#define _lcthw_BSTree_h 
typedef int (*BSTree_compare)(void *a, void *b); 
typedef struct 
BSTreeNode {void *key;void *data; 
struct BSTreeNode *left;
struct BSTreeNode *right;
struct BSTreeNode *parent;} BSTreeNode; 
typedef struct BSTree 
{ 
int count;
BSTree_comparecompare;
BSTreeNode *root;} BSTree; 
typedef int (*BSTree_traverse_cb)(BSTreeNode * node);
BSTree *BSTree_create(BSTree_ compare);
void BSTree_destroy(BSTree * map);
  
int BSTree_set(BSTree * map, void *key, void *data);
void *BSTree_get(BSTree * map, void *key); 
int BSTree_traverse(BSTree * map,BSTree_traverse_cb traverse_cb); 
void *BSTree_delete(BSTree * map, void *key); 
#endif 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This followsthe same pattern thatI&amp;rsquo;vebeen using this whole time where I have a base container named &lt;code&gt;BSTree&lt;/code&gt;, which has nodes named &lt;code&gt;BSTreeNode&lt;/code&gt; that makeup the ectual contents. Bored yet?Good, there&amp;rsquo;sno reason to be clever with this kind ofstructure.&lt;/p&gt;

&lt;p&gt;The important thing is how the &lt;code&gt;BSTreeNode&lt;/code&gt; is configured, and how it gets used todo each operation: set, get, and delete.I&amp;rsquo;ll cover get first since it&amp;rsquo;s the easiest operation, andI&amp;rsquo;ll pretendI&amp;rsquo;m doingitmanually against the data structure:&lt;/p&gt;

&lt;p&gt;• I take the keyyou&amp;rsquo;re looking for andI startat the root. First thing I do iscompare your key with thatnode&amp;rsquo;s key.&lt;/p&gt;

&lt;p&gt;• If your key isless than the node.key, then I traverse down the tree using the left pointer.&lt;/p&gt;

&lt;p&gt;• If your key isgreater&lt;/p&gt;

&lt;p&gt;than the node.key, thenI go downwith right.&lt;/p&gt;

&lt;p&gt;• Irepeat steps2and 3 until I eitherfinda matching node.key or get toa node that has no leftand right. In the first case, Ireturn the node.data. In the second, Ireturn NULL.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s allthereis to get, so
now on to set. It&amp;rsquo;s nearly the&lt;/p&gt;

&lt;p&gt;same thing, except you&amp;rsquo;re looking for where toputa new node:
• If there is no &lt;code&gt;BSTree&lt;/code&gt;.root, then I just make itand we&amp;rsquo;re done. That&amp;rsquo;s the first node.&lt;/p&gt;

&lt;p&gt;• Afterthat, I compare your key to node.key, startingat the root.&lt;/p&gt;

&lt;p&gt;• If your key isless than&lt;/p&gt;

&lt;p&gt;orequal to the node.key, thenI want to goleft. If your key is greaterthan and notequalto the node.key, thenI want to goright.&lt;/p&gt;

&lt;p&gt;• Ikeep repeating step 3 until I reach anode where leftor right doesn&amp;rsquo;texist, but that&amp;rsquo;s the direction Ineed to go.&lt;/p&gt;

&lt;p&gt;• Oncethere, Iset that direction (left or right) to a newnode forthe key and data Iwant, and then set thisnew node&amp;rsquo;s parentto the previous nodeI came from. I&amp;rsquo;llusethe parent node when I do delete.&lt;/p&gt;

&lt;p&gt;This also makes sense given how get works. If findinga node involvesgoing left or
rightdepending on how the key compares,thensettinga node involvesthe same thing until I canset theleftor right for anew node.&lt;/p&gt;

&lt;p&gt;Take sometime todrawout a fewtrees on paperand go through settingand getting nodessoyou understand how this works. After that, you&amp;rsquo;re ready to look at the implementation, and I can explain delete. Deleting in trees is a major pain, and so it&amp;rsquo;sbest explainedby doinga line-by-line code breakdown.&lt;/p&gt;

&lt;p&gt;bstree.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;lcthw/dbg.h&amp;gt; 
2 #include &amp;lt;lcthw/bstree.h&amp;gt; 
3 #include &amp;lt;stdlib.h&amp;gt; 
4 #include &amp;lt;lcthw/bstrlib.h&amp;gt;
5 
6 static int default_compare(void *a, void *b)
7 {
8 return bstrcmp((bstring) a,(bstring) b); 
9 }
1. 11 BSTree 

*BSTree_create(BSTree_ 
compare)12 {13 BSTree *map = calloc(1,
sizeof(BSTree)); 14 check_mem(ma 15 16 map­
&amp;gt;compare = compare == NULL ? 
default_compare : 
compare;17 18 return map;19 20 error: 21 if (map){ 22 BSTree_d 
23 } 
24 return NULL;
25 }
2. 27 static int BSTree_destroy_cb(BSTr * node)
28 {29 free(node); 
30 return 0;
31 }
32 
33 void BSTree_destroy(BSTree * map)34 {
35 if (map){ 
36 BSTree_t BSTree_destroy_cb); 
37 free(map
38 } 
39 } 
40
41 static inline BSTreeNode *BSTreeNode_create(BST * parent,
42 void *key, void *data)
43 {
44 BSTreeNode *node = calloc(1. sizeof(BSTreeNode));

51 
45 46  check_mem(no  
47 key;48  node-&amp;gt;key = node-&amp;gt;data = data;49  node-&amp;gt;parent 
50  =  parent;return
node;  

52 error: 
53 return NULL;
54 } 55 
56 static inline void BSTree_setnode(BSTree * map, BSTreeNode * node,
57 void *key, void *data)
58 {
59 int cmp = map-&amp;gt;compare(node­&amp;gt;key, key); 
60 
61 if (cmp &amp;lt;= 
0) {62 if 
(node-&amp;gt;left){ 
63 BSTr node-&amp;gt;left, key,data); 
64 } else {
65 node &amp;gt;left = BSTreeNode_create(node key, data); 
66 
}

67 
} else {68 if (node-&amp;gt;right){ 


69 BSTr node-&amp;gt;right, key, data); 
70 } else {
71 node &amp;gt;right = BSTreeNode_create(node key, data); 
72 } 
73 } 
74 } 
75 
76 int BSTree_set(BSTree * map, void *key, void *data)
77 { 
78 if (map­&amp;gt;root == NULL){ 
79 // first so just make it and get out 
80 map­&amp;gt;root = BSTreeNode_create(NULL key, data); 
81 check_mem &amp;gt;root); 
82 } else {
83 BSTree_se map-&amp;gt;root, key,data); 
84 } 
85 
86 return 0;
87 error: 
88 return -1;

89 }
90 
91 static inline BSTreeNode *BSTree_getnode(BSTree * map,
92 BSTreeNod * node, void *key)
93 {
94 int cmp = map-&amp;gt;compare(node­&amp;gt;key, key); 
95 
96 if (cmp == 0) {
97 return node;
98 } else if (cmp &amp;lt; 0) { 
99 if (node-&amp;gt;left){ 100 retur BSTree_getnode(map,node-&amp;gt;left, key); 
101 } else {102 retur NULL; 
103 } &#39;
104 } else {105 if (node-&amp;gt;right){ 106 retur BSTree_getnode(map,node-&amp;gt;right, key);
107 } else {108 retur NULL; 
109 } 
11. }
11. }
11. 113 void *BSTree_get(BSTree * map, void *key) 
114 {115 if (map­&amp;gt;root == NULL){ 116 return NULL; 
11. } else {
118 BSTreeNod *node = BSTree_getnode(map, map-&amp;gt;root, key); 
119 return node == NULL ? NULL : node-&amp;gt;data;
12. } 
12. }12. 
123 static inline int BSTree_traverse_nodes(* node,
124 BSTree_tr traverse_cb)
125 {
126 int rc = 0;
127 128 if (node­&amp;gt;left){ 
129 rc = BSTree_traverse_nodes(&amp;gt;left, traverse_cb); 130 if (rc != 0)
131 retur rc; 
132
}133 134 if (node­&amp;gt;right){ 135 rc = BSTree_traverse_nodes(&amp;gt;right, traverse_cb); 136 if (rc != 0)137 retur rc;

138 
}139 140 return 
traverse_cb(node); 
141 }
142 
143 int BSTree_traverse(BSTree * map, BSTree_traverse_cb traverse_cb) 
144 {
145 if (map­&amp;gt;root){
146 return BSTree_traverse_nodes(&amp;gt;root, traverse_cb); 
147 } 
148 
149 return 0; 
150 } 
151 152 static inline BSTreeNode *BSTree_find_min(BSTre * node) 
153 {154 while (node­&amp;gt;left){
155 node = node-&amp;gt;left; 
156 } 
157 158 return node; 
159 } 
160 161 static inline void BSTree_replace_node_in * map, 
162 BSTreeNod * node, 
163 BSTreeNod * new_value) 
164 {
165 if (node­&amp;gt;parent){
166 if (node == node-&amp;gt;parent­&amp;gt;left){167 node-&amp;gt;parent-&amp;gt;left = new_value; 
168 } else {169 node­&amp;gt;parent-&amp;gt;right = new_value; 
170 } 
171 } else {
172 // this is the root so gotta change it 
173 map­&amp;gt;root = new_value; 
174 }
175 
176 if (new_value){ 
177 new_value &amp;gt;parent = node­&amp;gt;parent; 
178 } 
179 }
180 181 static inline void BSTree_swap(BSTreeNode * a, BSTreeNode * b) 
182 {183 void *temp = NULL; 
184 temp = b­&amp;gt;key; 
185 b-&amp;gt;key = a­&amp;gt;key; 
186 a-&amp;gt;key = temp; 
187 temp = b­&amp;gt;data; 
188 b-&amp;gt;data = a­&amp;gt;data; 
189 a-&amp;gt;data = temp; 
190 }
191 192 static inline BSTreeNode *BSTree_node_delete(BS * map, 
193 BSTreeNod * node, 194 void *key) 195 {196 int cmp = map-&amp;gt;compare(node­&amp;gt;key, key); 
197 198 if (cmp &amp;lt; 0) {199 if (node-&amp;gt;left){
200 retur BSTree_node_delete(map node-&amp;gt;left, key); 
201 } else {
202 // not found 
203 retur NULL; 
204 } 
205 } else if (cmp &amp;gt; 0) { 
206 if (node-&amp;gt;right){ 
207 retur BSTree_node_delete(mapnode-&amp;gt;right, key); 
208 } else {
209 // not found 
210 retur NULL; 
21. } 
21. } else {
213 if (node-&amp;gt;left &amp;amp;&amp;amp; node­&amp;gt;right){ 
214 // swap this node for the smallest node that is bigger than us 
215 BSTre *successor = BSTree_find_min(node­&amp;gt;right); 
216 BSTre node); 
217 
218 // this leaves the old successor with possibly a right child 
219 // so replace it with that right child 
220 BSTre successor,
221 &amp;gt;right); 
22. 
223 // finally it&#39;s swapped, so return successor instead of node 
224 retur successor; 
22. } else if (node-&amp;gt;left){ 
226 BSTre node, node-&amp;gt;left); 
22. } else if (node-&amp;gt;right){ 
228 BSTre node, node-&amp;gt;right); 
22. } else {230 BSTre node, NULL); 
231 } 
232 233 return node; 
234 } 
235 } 
236 237 void *BSTree_delete(BSTree * map, void *key) 
238 {
239 void *data = NULL; 
240 
241 if (map-&amp;gt;root){
242 BSTreeNod *node = BSTree_node_delete(map map-&amp;gt;root, key); 
243 
244 if (node){245 data = node-&amp;gt;data; 
246 free(
247 } 2
48 } 
249 250 return data; 
251 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before getting into how BSTree_delete works,I want to explain a patternfor doing recursive functioncalls in a sane way. You&amp;rsquo;ll find thatmanytree-based data structures are easy to writeif you use recursion, but formulatea single recursive function. Part of the problem is thatyou need to set up someinitial data forthe first operation, then recurseinto the data structure, whichis hard to do with one function. The solutionis to use two functions:One function sets up the data structure and initial recursion conditionsso thata second function cando the real work. Take a look at BSTree_get firstto see whatI mean.&lt;/p&gt;

&lt;p&gt;• Ihave an initial condition:If map­&amp;gt;root is NULL,then return NULL and don&amp;rsquo;t recurse.&lt;/p&gt;

&lt;p&gt;• Ithen set upa callto the realrecursion, which is in BSTree_getnode.I create the initial condition of the root node to start with the key and then the map.&lt;/p&gt;

&lt;p&gt;• In the BSTree_getnode,I thendo the ectual recursivelogic. I compare the keys with map­&amp;gt;compare(node­&amp;gt;key, key) and go
 left, right,or equal to depending on the results.&lt;/p&gt;

&lt;p&gt;• Since thisfunction is self-similarand doesn&amp;rsquo;t have tohandle any initial conditions (because BSTree_getdid), thenI can structure it very simply. When it&amp;rsquo;s done, it returnsto the caller, and thatreturn then comes back to BSTree_getfor the result.&lt;/p&gt;

&lt;p&gt;• At the end, the BSTree_get handles getting the node.data element butonly if theresult isn&amp;rsquo;t NULL.&lt;/p&gt;

&lt;p&gt;This way of structuring a recursive algorithmmatches the way I structure my recursivedata structures. I have aninitial base function thathandlesinitial conditions and some edgecases, and thenit calls aclean recursive function that does thework.&lt;/p&gt;

&lt;p&gt;Compare thatwith how I have a base structure in BStree combined with recursive BSTreeNode structures,whichall reference each other in a tree. Using this pattern makesit easy to deal with recursion and keep it straight.&lt;/p&gt;

&lt;p&gt;Next, go look at BSTree_set and BSTree_setnode to see the exactsame pattern. I use BSTree_set toconfigure the initialconditions andedge cases. A common edge case is that there&amp;rsquo;sno rootnode, so I have to make one toget
things started.&lt;/p&gt;

&lt;p&gt;This patternwillworkwith nearly anyrecursive algorithm youhave tofigure out. The wayI do itisby following this pattern:&lt;/p&gt;

&lt;p&gt;• Figure out the initial variables, how they change, and what the stopping conditions are for each recursive step.&lt;/p&gt;

&lt;p&gt;• Write a recursive function that calls itself, and has argumentsfor each stopping condition and initial variable.&lt;/p&gt;

&lt;p&gt;• Write a setupfunction to set initialstarting conditions for the algorithm and handle edge cases,then have it call therecursive function.&lt;/p&gt;

&lt;p&gt;• Finally, the setup function returns the final result, and possiblyalters it if the recursivefunction can&amp;rsquo;t
handle final edgecases.&lt;/p&gt;

&lt;p&gt;This finallyleads me to BSTree_delete and &lt;code&gt;BSTree_node_delete&lt;/code&gt;. First, you can just look at BSTree_delete and see that it&amp;rsquo;s thesetup function. Whatit&amp;rsquo;s doing isgrabbing the resulting node dataand freeing the node that&amp;rsquo;s found.&lt;/p&gt;

&lt;p&gt;Things get more complex in &lt;code&gt;BSTree_node_delete&lt;/code&gt;, because todelete a node at any point in the tree,I have to rotate thatnode&amp;rsquo;schildrenup to theparent. Here&amp;rsquo;sa breakdownof thisfunction and the functions it uses:&lt;/p&gt;

&lt;p&gt;bstree.c:190 Irun the comparefunction to figure outwhich direction I&amp;rsquo;m going.&lt;/p&gt;

&lt;p&gt;bstree.c:192-198 This is the usual less-than branch tousewhen I want to goleft. I&amp;rsquo;m handling thecase that leftdoesn&amp;rsquo;t exist here, and returning NULL to say &amp;ldquo;notfound.&amp;rdquo; This covers deleting something that isn&amp;rsquo;t in the &lt;code&gt;BSTree&lt;/code&gt;.
bstree.c:199-205 This is the samething, butfor the right branch of the tree. Just keeprecursing down into the tree just likein the other functions, and return NULL if itdoesn&amp;rsquo;t exist.&lt;/p&gt;

&lt;p&gt;bstree.c:206 This is where I havefound the node,sincethe keyis equal(compare return 0).&lt;/p&gt;

&lt;p&gt;bstree.c:207 This node has both a left and right branch, so it&amp;rsquo;s deeply embedded in the tree.&lt;/p&gt;

&lt;p&gt;bstree.c:209 To remove this node, I first need to find thesmallestnode that&amp;rsquo;s greater than this node,whichmeans I call BSTree_find_min on theright child.&lt;/p&gt;

&lt;p&gt;bstree.c:210 Once I have this node, I&amp;rsquo;ll swapits key and data with the currentnode&amp;rsquo;s values.
This will effectively take this nodethat was down at thebottomof the treeand put its contents here,sothat I don&amp;rsquo;thave to try and shufflethe node outby its pointers.&lt;/p&gt;

&lt;p&gt;bstree.c:214 The successor is now this dead branch that has the current node&amp;rsquo;s values. Itcould just be removed, but there&amp;rsquo;sa chancethat it has a right node value. This means I needto do a single rotate so that the successor&amp;rsquo;s rightnode gets movedup to completely detach it.&lt;/p&gt;

&lt;p&gt;bstree.c:217 At this point, the successor is removed fromthe tree, its values are replaced the current node&amp;rsquo;s values, andany children it hadare moved up into the parent. Icanreturn the successor as ifit werethe node.&lt;/p&gt;

&lt;p&gt;bstree.c:218 At this branch, I knowthat the node has aleft but no right, so I want to replace this node with its leftchild.&lt;/p&gt;

&lt;p&gt;bstree.c:219 Iagain use BSTree_replace_no to do the replace, rotating theleft child up.&lt;/p&gt;

&lt;p&gt;bstree.c:220 This branch of the if-statement meansIhave a right child butno left child, so I want to rotate the rightchild up.&lt;/p&gt;

&lt;p&gt;bstree.c:221 Again, I use the functionto do the rotate, but this time, rotate the right node.&lt;/p&gt;

&lt;p&gt;bstree.c:222 Finally, the only thing that&amp;rsquo;s left is the condition where I&amp;rsquo;ve found the node, and it hasno children (no leftor right). In this case, I simply replace this node with NULL by using the same function I did with all of the others.&lt;/p&gt;

&lt;p&gt;bstree.c:210 Afterall that, I have the current node rotated out of the tree and replacedwithsome child element that will fitin the tree. Ijust returnthis to the caller so it can be freed and managed.&lt;/p&gt;

&lt;p&gt;This operation is very complex, and to be honest, I just don&amp;rsquo;t botherdoing deletesin sometree data structures, and I treat them likeconstant data In my software. If I needto do heavy inserting and deleting, I use a &lt;code&gt;Hashmap&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;Finally,you canlook at the unit test to see how I&amp;rsquo;m testing it:
bstree_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;minunit.h&amp;quot; 2 #include 
&amp;lt;lcthw/bstree.h&amp;gt; 
3 #include &amp;lt;assert.h&amp;gt; 
4 #include &amp;lt;lcthw/bstrlib.h&amp;gt; 
5 #include &amp;lt;stdlib.h&amp;gt; 
6 #include &amp;lt;time.h&amp;gt; 
7 
8 BSTree *map = NULL;
9 static int traverse_called = 0;
10 struct tagbstring test1 = bsStatic(&amp;quot;test data 
1&amp;quot;);11 struct 
tagbstring test2 = bsStatic(&amp;quot;test data 2&amp;quot;);
12 struct tagbstring test3 = bsStatic(&amp;quot;xest data 3&amp;quot;);
13 struct tagbstring expect1 = bsStatic(&amp;quot;THE VALUE 1&amp;quot;);
14 struct tagbstring expect2 = bsStatic(&amp;quot;THE VALUE 2&amp;quot;); 
15 struct tagbstring expect3 = bsStatic(&amp;quot;THE VALUE 3&amp;quot;);
1. 
17 static int traverse_good_cb(BSTre 
* node)
18 {
19 debug(&amp;quot;KEY: 
%s&amp;quot;, bdata((bstring)
node-&amp;gt;key)); 
20 traverse_cal 
21 return 0;
22 }
2. 
24 static int 

traverse_fail_cb(BSTre 
* node)
25 {
26 debug(&amp;quot;KEY: 
%s&amp;quot;, bdata((bstring)
node-&amp;gt;key)); 
27 traverse_cal 
28 
29 if 
(traverse_called == 
2) {
30 return 1;
31 } else {
32 return 0; 
33 } 
34 }
35 
36 char *test_create() 
37 {
38 map = BSTree_create(NULL); 
39 mu_assert(ma != NULL, &amp;quot;Failed to create map.&amp;quot;); 
40 41 return NULL; 
42 } 
43
44 char *test_destroy() 
45 {
46 BSTree_destr 
47 
48 return NULL; 
49 } 
50 
51 char *test_get_set() 
52 {
53 int rc = BSTree_set(map,&amp;amp;test1,&amp;amp;expect1); 
54 mu_assert(rc == 0, &amp;quot;Failed to set &amp;amp;test1&amp;quot;); 
55 bstring result = BSTree_get(map,&amp;amp;test1); 
56 mu_assert(re == &amp;amp;expect1, &amp;quot;Wrong value for test1.&amp;quot;); 
57 
58 rc = BSTree_set(map,&amp;amp;test2,&amp;amp;expect2); 
59 mu_assert(rc == 0, &amp;quot;Failed to set test2&amp;quot;); 
60 result = BSTree_get(map, &amp;amp;test2); 
61 mu_assert(re == &amp;amp;expect2, &amp;quot;Wrong value for test2.&amp;quot;); 
62 
63 rc = BSTree_set(map,&amp;amp;test3,&amp;amp;expect3); 
64 mu_assert(rc == 0, &amp;quot;Failed to set test3&amp;quot;); 
65 result = BSTree_get(map,&amp;amp;test3); 
66 mu_assert(re == &amp;amp;expect3, &amp;quot;Wrong 
value for test3.&amp;quot;); 
67 
68 return NULL; 
69 } 
70 
71 char *test_traverse() 
72 {
73 int rc = BSTree_traverse(map,traverse_good_cb); 
74 mu_assert(rc == 0, &amp;quot;Failed to traverse.&amp;quot;); 
75 mu_assert(tr == 3, &amp;quot;Wrong count traverse.&amp;quot;); 
76 
77 traverse_cal = 0; 
78 rc = BSTree_traverse(map,traverse_fail_cb); 
79 mu_assert(rc == 1, &amp;quot;Failed to traverse.&amp;quot;); 
80 mu_assert(tr == 2, &amp;quot;Wrong count traverse for fail.&amp;quot;); 
81 
82 return NULL; 
83 } 
84 
85 char *test_delete() 
86 {
87 bstring deleted =(bstring)BSTree_delete(map,&amp;amp;test1); 
88 mu_assert(de != NULL, &amp;quot;Got NULL on delete.&amp;quot;); 
89 mu_assert(de == &amp;amp;expect1, &amp;quot;Should get test1&amp;quot;); 
90 bstring result = BSTree_get(map,&amp;amp;test1); 
91 mu_assert(re == NULL, &amp;quot;Should delete.&amp;quot;); 
92 
93 deleted = (bstring)BSTree_delete(map,&amp;amp;test1); 
94 mu_assert(de == NULL, &amp;quot;Should get NULL on delete&amp;quot;); 
95 
96 deleted = (bstring)BSTree_delete(map, &amp;amp;test2); 
97 mu_assert(de != NULL, &amp;quot;Got NULL on delete.&amp;quot;); 
98 mu_assert(de == &amp;amp;expect2, &amp;quot;Should get test2&amp;quot;); 
99 result = BSTree_get(map,&amp;amp;test2); 
100 mu_assert(re == NULL, &amp;quot;Should delete.&amp;quot;); 
101 
102 deleted = (bstring) BSTree_delete(map,&amp;amp;test3); 
103 mu_assert(de != NULL, &amp;quot;Got NULL on delete.&amp;quot;); 
104 mu_assert(de == &amp;amp;expect3, &amp;quot;Should get test3&amp;quot;); 
105 result = BSTree_get(map,&amp;amp;test3); 
106 mu_assert(re == NULL, &amp;quot;Should delete.&amp;quot;); 
107 1
08 // test deleting non-existent stuff 
109 deleted = (bstring) BSTree_delete(map, &amp;amp;test3); 
110 mu_assert(de == NULL, &amp;quot;Should get NULL&amp;quot;); 
11. 
112 return NULL;
113 } 
11. 115 char *test_fuzzing() 
116 {
117 BSTree *store = BSTree_create(NULL); 
118 int i = 0; 
119 int j = 0; 
120 bstring numbers[100] = { NULL }; 
121 bstring data[100] = { NULL }; 
122 srand((unsig int)time(NULL)); 
12. 124 for (i = 0; i &amp;lt; 100; i++) {
125 int num = rand(); 
126 numbers[= bformat(&amp;quot;%d&amp;quot;, num); 
127 data[i]= bformat(&amp;quot;data %d&amp;quot;, num);
128 BSTree_s numbers[i], data[i]);
129 }
130 
131 for (i = 0; i &amp;lt; 100; i++) {
132 bstring value = BSTree_delete(store, numbers[i]); 
133 mu_asser == data[i], 
134 to delete the right number.&amp;quot;); 
135 136 mu_asser numbers[i]) == NULL, 
137 get nothing.&amp;quot;); 
138 
139 for (j = i + 1; j &amp;lt; 99 -i; j++) {
140 bstr value = BSTree_get(store, numbers[j]);
141 mu_a == data[j], 142 to get the right number.&amp;quot;); 
143 }
144 
145 bdestroy146 bdestroy 
147 }
148 
149 BSTree_destr 
150 
151 return NULL; 
152 }
153
154 char *all_tests() 
155 {
156 mu_suite_sta 
157 
158 mu_run_test(
159 mu_run_test(
160 mu_run_test(
161 mu_run_test(
162 mu_run_test(
163 mu_run_test(
164 
165 return 
NULL;


166 }
167 
168 RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ll pointyou to the test_fuzzing function, which is an interesting technique for testing complex data structures. It is difficult to create asetof keys that cover all of the branchesin BSTree&lt;em&gt;node&lt;/em&gt; delete, and chances are, I would miss someedge case.&lt;/p&gt;

&lt;p&gt;A betterway is to createa fuzz function thatdoes all of the operations, butdoes them in a horrible and randomway. In this case, I&amp;rsquo;m inserting a set ofrandom string keys, and thenI&amp;rsquo;m deleting them and trying to get therest after each delete.&lt;/p&gt;

&lt;p&gt;Doing this preventsyou from testing only what you know to work, and thenmiss things you don&amp;rsquo;tknow. Bythrowing random junk at yourdata structures,you&amp;rsquo;llhit things you didn&amp;rsquo;texpectand be able to workout any bugsyou have.&lt;/p&gt;

&lt;p&gt;How to Improve It
Do not doany of these yet. In the next exercise I&amp;rsquo;ll be using this unittestto teach you somemore performance­tuning tricks, and you&amp;rsquo;ll come back and do theseafteryou complete Exercise 41.&lt;/p&gt;

&lt;p&gt;• As usual,you should go through allof the defensiveprogramming checks and add assert&lt;code&gt;s for conditions that shouldn&#39;thappen. For example, you shouldn&#39;t be getting&lt;/code&gt;NULL valuesforthe recursion functions, so assert that.&lt;/p&gt;

&lt;p&gt;• The traverse function walks through the treein orderby traversing left,then right, andthen the currentnode. You can create traverse functions for thereverse order, as well.&lt;/p&gt;

&lt;p&gt;• Itdoes a full string compare onevery node, but Icoulduse the &lt;code&gt;Hashmap&lt;/code&gt; hashing functions to speed this up. I could hash the keys, andthen keepthe hash in the &lt;code&gt;BSTreeNode&lt;/code&gt;. Then, in each of the setup functions, I can hashthe key ahead oftime and pass it down to the recursivefunction. Using this hash,Ican thencompare eachnode much quickerin a way that&amp;rsquo;s similarto whatI do in &lt;code&gt;Hashmap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• There&amp;rsquo;s an alternative way todo thisdata structure without using recursion. The Wikipedia pageshows alternatives thatdon&amp;rsquo;t use recursion butdo the same thing. Why would this bebetteror worse?&lt;/p&gt;

&lt;p&gt;• Readup onallof the differentbut similar trees you can find.&lt;/p&gt;

&lt;p&gt;There areAVL trees (namedafterGeorgy Adelson-Velsky and E.M. Landis),red-black trees, andsome non-tree structures like skip lists.&lt;/p&gt;

&lt;h2 id=&#34;exercise41-project-devpkg:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise41. Project devpkg&lt;/h2&gt;

&lt;p&gt;You are now ready to tackle a new project called devpkg. In this projectyou&amp;rsquo;regoing to recreate apiece ofsoftware thatIwrote specifically for this bookcalled devpkg. You&amp;rsquo;ll thenextend it in a few key ways and improvethe code, most importantlyby writing someunittests for it. This exercise has a companion video to it, and also a projecton GitHub (&lt;a href=&#34;https://github.com)that&#34;&gt;https://github.com)that&lt;/a&gt; you can referenceif you getstuck.&lt;/p&gt;

&lt;p&gt;You should attempt to do this exerciseusing the description below, since that&amp;rsquo;s how you&amp;rsquo;ll need to learnto codefrom books in the future. Most computer sciencetextbooks don&amp;rsquo;tinclude videos for their exercises, so this projectis more abouttrying tofigure it outfromthis description.&lt;/p&gt;

&lt;p&gt;If you get stuck, andyou can&amp;rsquo;t figureit out, then go watchthe video andlook at the GitHub projectto seehow your code differsfrom mine.&lt;/p&gt;

&lt;p&gt;What Is devpkg?&lt;/p&gt;

&lt;p&gt;Devpkg is asimple C programthat installs other software. Imade it specifically for this book as a way to teach you how a real softwareproject is structured, and alsohow to reuseother people&amp;rsquo;slibraries. It uses a portability library calledthe Apache Portable Runtime (APR),whichhasmany handy C functions that work on tons ofplatforms, including Windows. Other thanthat, it just grabscode fromthe Internet (or local files) anddoes the usual ./configure, make, and make install that every programdoes.&lt;/p&gt;

&lt;p&gt;Your goal in this exercise is to build devpkg fromthe source,finish each challenge I give, and use thesource to understand what devpkg does and why.&lt;/p&gt;

&lt;p&gt;What We Want to Make&lt;/p&gt;

&lt;p&gt;We want atoolthat has these commands:
devpkg -S Sets up a new installation ona computer.
devpkg -I Installs apiece ofsoftware from a URL.
devpkg -L Listsall of the software that&amp;rsquo;sbeen installed.
devpkg -F Fetches some source code formanual building.
devpkg -B Builds the source code and installs it, even if it&amp;rsquo;s already installed.&lt;/p&gt;

&lt;p&gt;We want devpkg to be able to takealmost any URL, figure outwhat kind of projectitis, download it, install it, and register that it downloadedthat software. We&amp;rsquo;d also like it to process a simple dependency listsothat it can install allof the software that a projectmight need, as well.&lt;/p&gt;

&lt;p&gt;The Design&lt;/p&gt;

&lt;p&gt;To accomplish this goal, devpkg will have a very simple design:&lt;/p&gt;

&lt;p&gt;Use External Commands&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll do most of the work throughexternal commands like curl, git, and tar.This reduces the amount of code devpkg needs to get thingsdone.&lt;/p&gt;

&lt;p&gt;SimpleFileDatabase You could easilymake it more complex, but you&amp;rsquo;ll startby making just make a single simple file database at /usr/local/.devpk to keeptrackof what&amp;rsquo;s installed.&lt;/p&gt;

&lt;p&gt;/usr/local Always Again, you could makethis more advanced, but for now just assume it&amp;rsquo;s always /usr/local, which is astandard install pathfor most softwareon UNIX.&lt;/p&gt;

&lt;p&gt;configure, make,make install It&amp;rsquo;s assumed that most software can be installed with just a configure, make, and make install —and maybe configure is optional. If the software at a minimum can&amp;rsquo;tdo that, there are some optionsto modify the commands, but otherwise, devpkg won&amp;rsquo;t bother.&lt;/p&gt;

&lt;p&gt;The User Can Be Root&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll assumethat the user canbecomeroot using sudo, but doesn&amp;rsquo;t want to be come root until the end.&lt;/p&gt;

&lt;p&gt;This will keep our program smallatfirst and workwell enoughfor usto getit going, at which pointyou&amp;rsquo;llbeable to modifyit further for this exercise.&lt;/p&gt;

&lt;p&gt;The Apache Portable Runtime&lt;/p&gt;

&lt;p&gt;One more thing you&amp;rsquo;ll do is leverage the APR Libraries to get a good set of portable routines for doing this kind of work. APR isn&amp;rsquo;t necessary, and you couldprobably write this program without it, but it&amp;rsquo;d takemorecode than necessary. I&amp;rsquo;m also forcing you to use APR now so you get usedto linking andusing other libraries. Finally, APR also workson Windows,so your skills with it are transferable tomany other platforms.&lt;/p&gt;

&lt;p&gt;You should goget both the apr-1.5.2 and the apr­util-1.5.4 libraries, as wellas browsethrough the documentationavailable at the main APR site at &lt;a href=&#34;http://apr.apache.org&#34;&gt;http://apr.apache.org&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s ashell script that will install all thestuff youneed.&lt;/p&gt;

&lt;p&gt;You should write this into a fileby hand, and then run it until itcaninstallAPR without anyerrors.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise10ise 41.1 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
set -e 
# go somewhere safe 
cd /tmp 
# get the source to base APR 1.5.2 
curl -L -O http://archive.apache. 1.5.2.tar.gz 
# extract it and go into the source 
tar -xzvf apr­1.5.2.tar.gzcd apr-1.5.2 
# configure, make, make install 
./configuremake sudo make install 
# reset and cleanup 
cd /tmp rm -rf apr-1.5.2 apr­1.5.2.tar.gz 
# do the same with apr-util 
curl -L -O http://archive.apache. util-1.5.4.tar.gz 
# extract 
tar -xzvf apr-util­1.5.4.tar.gz 
cd apr-util-1.5.4 
# configure, make, make install 
./configure --with­apr=/usr/local/apr 
# you need that extra parameter to configure because 
# apr-util can&#39;t really find it because...who knows. 
make sudo make install 
#cleanup 
cd /tmp rm -rf apr-util­1.5.4* apr-1.5.2. 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m having you write this script outbecause it&amp;rsquo;s basically what we want devpkg to do, butwith extra optionsand checks. In fact, you could just do it all in shell with less code, but then that wouldn&amp;rsquo;t be a very good program for a C book would it?&lt;/p&gt;

&lt;p&gt;Simply run this script and fix it until it works,then you&amp;rsquo;ll have the libraries you need to completethe rest of this project.&lt;/p&gt;

&lt;p&gt;Project Layout&lt;/p&gt;

&lt;p&gt;You need tosetup some simple projectfiles toget started. Here&amp;rsquo;showI usually craft anew project:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 41.2 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir devpkg 
cd devpkg
touch README Makefile 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other Dependencies&lt;/p&gt;

&lt;p&gt;You should have already installed apr-1.5.2 andapr­util-1.5.4,so now you need a few more files to use as basic dependencies:&lt;/p&gt;

&lt;p&gt;• dbg.h from * Exercise 20.&lt;/p&gt;

&lt;p&gt;• bstrlib.h and bstrlib.c from &lt;a href=&#34;http://bstring.sourceforge&#34;&gt;http://bstring.sourceforge&lt;/a&gt; Download the .zipfile, extract it, and copy just
thosetwo files.&lt;/p&gt;

&lt;p&gt;• Type make bstrlib.o, and if it doesn&amp;rsquo;twork,read the instructions for fixing bstring below.&lt;/p&gt;

&lt;p&gt;Warning!&lt;/p&gt;

&lt;p&gt;Insome platforms,the bstring.c file will have an error like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
bstrlib.c:2762: error: expecteddeclaration\ specifiers or &#39;...&#39; before numeric constant 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is from abad define that the authorsadded, which doesn&amp;rsquo;talways work. You just need to change line2759 that reads #ifdef &lt;strong&gt;GNUC&lt;/strong&gt; to read:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#if defined(__GNUC__) 
&amp;amp;&amp;amp; !defined(__APPLE__) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;andthen it should work on OSX.&lt;/p&gt;

&lt;p&gt;When that&amp;rsquo;s all done,you should have a Makefile, README, dbg.h, bstrlib.h, and bstrlib.c ready togo.&lt;/p&gt;

&lt;p&gt;The Makefile&lt;/p&gt;

&lt;p&gt;A good place to start is the Makefile sincethis lays outhowthings are builtand whatsourcefiles you&amp;rsquo;ll be creating.&lt;/p&gt;

&lt;p&gt;Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;
PREFIX?=/usr/local 
CFLAGS=-g -Wall ­I${PREFIX}/apr/include 1 

CFLAGS+=­I${PREFIX}/apr/include util-1 

LDFLAGS=­L${PREFIX}/apr/lib ­lapr-1 -pthread ­laprutil-1 

all: devpkg 
devpkg: bstrlib.o db.o shell.o commands.o 

install: all 

install -d $(DESTDIR)/$(PREFIX)/bin/ 
install devpkg $(DESTDIR)/$(PREFIX)/bin/

clean: 
rm -f *.o 
rm -f devpkg 
rm -rf *.dSYM 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s nothing in this that you haven&amp;rsquo;tseenbefore, exceptmaybe the strange ?= syntax,which says &amp;ldquo;set PREFIXequalto this unless PREFIXis already set.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Warning!&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;reon more recent versions of Ubuntu, and you get errorsabout apr_off_t or off64_t, then add ­D_LARGEFILE64_SOUR to CFLAGS. Another thingis that you need to add
/usr/local/apr/lib&lt;/p&gt;

&lt;p&gt;to a file in
/etc/ld.conf.so.d/&lt;/p&gt;

&lt;p&gt;andthen run ldconfig so that it correctly picks up the libraries.&lt;/p&gt;

&lt;p&gt;The Source Files&lt;/p&gt;

&lt;p&gt;From the Makefile, we see that there are five dependencies for devpkg:
bstrlib.o This comes from bstrlib.c andthe header file bstlib.h, which you already have.&lt;/p&gt;

&lt;p&gt;db.o This comes from db.c and header file db.h, and it will
contain code for our little database routines.&lt;/p&gt;

&lt;p&gt;shell.o This is from shell.c andheader shell.h, as well asa couple offunctions that makerunning other commands like curl easier.
commands.o This isfrom command.c and header command.h, and containsall of the commands that devpkg needs to be useful.
devpkg It&amp;rsquo;s not explicitly mentioned, but it&amp;rsquo;s the target (on the left)in this part of the Makefile. It comes from devpkg.c, which contains the main function for the whole program.&lt;/p&gt;

&lt;p&gt;Your job is to now create each of these files, type in their code, and get them correct.&lt;/p&gt;

&lt;p&gt;Warning!&lt;/p&gt;

&lt;p&gt;You mayread this descriptionand think, &amp;ldquo;Man! How isit that Zed is so smart thathe just satdownand typed thesefiles out like this!?I could never do that.&amp;rdquo; I didn&amp;rsquo;t magically craft devpkg in this form with my awesome coding powers. Instead, whatI didis this:
• Iwroteaquicklittle README to get an idea ofhow Iwanted it to work.&lt;/p&gt;

&lt;p&gt;• Icreated a simple bash script (like the one you didearlier) to figure out all of the pieces that wereneeded.&lt;/p&gt;

&lt;p&gt;• Imade one .c file and hacked on itfor a few days working through the ideaand figuring it out.&lt;/p&gt;

&lt;p&gt;• Igot itmostly working and debugged, then I started breaking upthe one big file into these four files.&lt;/p&gt;

&lt;p&gt;• Aftergetting thesefiles laiddown,Irenamed and refined the functions anddata structuressothat they&amp;rsquo;d be more logicaland pretty.&lt;/p&gt;

&lt;p&gt;• Finally, after I hadit working the exact same butwith the new structure,Iaddeda few features like the -F and -B options.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;re reading this in theorder I want to teachitto you, but don&amp;rsquo;t think this ishow I always build software. Sometimes I already knowthe subject andI usemore planning. SometimesI just hack upanidea and see how wellit&amp;rsquo;d work. SometimesI write one, then throw it awayand plan out a better one. It all depends on whatmy experience tells meis bestor where my inspiration takes me.&lt;/p&gt;

&lt;p&gt;If yourunintoa supposedexpert who triesto tellyou that there&amp;rsquo;s onlyone way to solve aprogramming problem, they&amp;rsquo;re lying to you. Either they actually use multiple tactics, or they&amp;rsquo;renot
very good.&lt;/p&gt;

&lt;p&gt;The DB Functions&lt;/p&gt;

&lt;p&gt;There must be a way to recordURLs that havebeen installed, list theseURLs, and check whether something has already beeninstalled so we can skipit. I&amp;rsquo;ll use asimple flatfile database andthe bstrlib.h library todo it.&lt;/p&gt;

&lt;p&gt;First, create the db.h header&lt;/p&gt;

&lt;p&gt;filesoyouknow what you&amp;rsquo;ll be implementing.
db.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef _db_h 
#define _db_h 
#define DB_FILE &amp;quot;/usr/local/.devpkg/db #define DB_DIR &amp;quot;/usr/local/.devpkg&amp;quot; 
int DB_init(); int DB_list(); int DB_update(const char *url); int DB_find(const char *url); 
#endif 

Then, implement those functions in db.c, andas you build this, use make to get itto compilecleanly. 
db.c 


```c


1 #include &amp;lt;unistd.h&amp;gt;
2 #include &amp;lt;apr_errno.h&amp;gt;
3 #include &amp;lt;apr_file_io.h&amp;gt;
4
5
6 #include &amp;quot;db.h&amp;quot; #include &amp;quot;bstrlib.h&amp;quot;
7 #include &amp;quot;dbg.h&amp;quot;
8
9 static FILE *DB_open(const char *path, const char *mode)
10 {
11 return fopen(path, mode); 
12 }
1. 
14 static void DB_close(FILE * db)
15 {16 fclose(db);
17 }18 19 static bstring 
DB_load() 20 {
21 FILE *db = NULL;
22 bstring data = NULL;
2. 24 db = DB_open(DB_FILE,&amp;quot;r&amp;quot;);
25 check(db,&amp;quot;Failed to open database: %s&amp;quot;,DB_FILE); 
2. 27 data = bread((bNread) fread, 
db);28 check(data,
&amp;quot;Failed to read from db file: %s&amp;quot;,DB_FILE); 
29 30 DB_close(db)31 return 
data;32 33 error: 34 if (db)35 DB_close 36 if (data)37 bdestroy38 return 
NULL; 
39 }
40 
41 int 

DB_update(const char 
*url)
42 {
43 if 
(DB_find(url)) { 44 log_info 
recorded as installed: %s&amp;quot;, url); 
45 }
46 
47 FILE *db = 

DB_open(DB_FILE,
&amp;quot;a+&amp;quot;); 

48 check(db,
&amp;quot;Failed to open DB 
file: %s&amp;quot;, DB_FILE); 
49 
50 bstring line = bfromcstr(url); 
51 bconchar(lin &#39;\n&#39;); 
52 int rc = fwrite(line-&amp;gt;data,blength(line), 1,db);
53 check(rc == 1, &amp;quot;Failed to append to the db.&amp;quot;); 
54  
55 56  return error:  0;  
57 58 59 60 61  }  if (db)DB_close return -1;  
62  int  

DB_find(const char 
*url)
63 {
64 bstring data = NULL;
65 bstring line = 
bfromcstr(url); 
66 int res = -1;
67 
68 data = DB_load(); 
69 check(data,&amp;quot;Failed to load: %s&amp;quot;,DB_FILE); 
70 
71 if (binstr(data, 0,line) == BSTR_ERR){ 
72 res = 0;
73 } else { 
74 res = 1;
75 }
76 
77 error: 

fallthrough 
78 if (data)
79 bdestroy
80 if (line)
81 bdestroy
82 
83 return res;

84 }
85 
86 int DB_init() 
87 { 

88 apr_pool_t 
*p = NULL;89 apr_pool_ini 90 apr_pool_cre 
NULL); 91 92 if 
(access(DB_DIR, W_OK | X_OK) == -1) { 
93 apr_stat rc = apr_dir_make_recursive 
94 | APR_UWRITE 95 APR_UEXECUTE | 
96 | APR_GWRITE 97 APR_GEXECUTE, p); 98 check(rc == APR_SUCCESS,
&amp;quot;Failed to make database dir: %s&amp;quot;,99 
100 }
101 
102 if 
(access(DB_FILE,
W_OK) == -1) { 
103 FILE *db 

= DB_open(DB_FILE,&amp;quot;w&amp;quot;); 
104 check(db,
&amp;quot;Cannot opendatabase: %s&amp;quot;,DB_FILE); 105 DB_close(
106 
}
107 
108 apr_pool_dest 
109 return 0;
11. 111 error: 
112 apr_pool_dest 
113 return -1;


11. }
11. 116 int DB_list() 



117 {
118 bstring data 
= DB_load(); 
119 check(data,

&amp;quot;Failed to read load: 
%s&amp;quot;, DB_FILE); 
12. 121 printf(&amp;quot;%s&amp;quot;,
bdata(data)); 
122 bdestroy(data 
123 return 0;
12. 125 error: 
126 return -1;

127 } 

Challenge1: Code Review 

Before continuing, read every line of thesefiles carefully and confirm thatyou have them entered in exactly as they appear here. Read them backward line by line to practice that. Also, trace each function calland make sure you&#39;re using check to validate thereturn codes. Finally,lookup every function that you don&#39;t recognize—either in theAPR Web sitedocumentation orin the bstrlib.h and bstrlib.c source. 

The Shell Functions 

A keydesigndecision for devpkg is to have external tools like curl, tar, and git do most of the work. We could find libraries todo all ofthis internally, but it&#39;s pointless if we just need the base features of these programs. Thereis no shame in runninganother command in UNIX. 

To do this,I&#39;m going touse the apr_thread_proc.hfunctions torunprograms, but I also want to make a simple kind of template system. I&#39;lluse a struct Shell thatholdsall of the informationneededto run a program, but has holesin the arguments list that I can replace with values.

Lookat the shell.h file to see the structure and the commands thatI&#39;ll use. You can see that I&#39;musing extern to indicatehow other .c filescan access variables that I&#39;mdefiningin shell.c. 
shell.h 

```c

#ifndef _shell_h 
#define _shell_h 
#define MAX_COMMAND_ARGS 100 
#include &amp;lt;apr_thread_proc.h&amp;gt; 
typedef struct Shell 
{ const char *dir;
const char *exe; 
apr_procattr_t *attr;
apr_proc_t proc;
apr_exit_why_e exit_why;
int exit_code; 
const char *args[MAX_COMMAND_ARGS } Shell; 
int Shell_run(apr_pool_t * p, Shell * cmd); 
int Shell_exec(Shell cmd, ...); 

extern Shell CLEANUP_SH;
extern Shell GIT_SH;
extern Shell TAR_SH;
extern Shell CURL_SH; 

extern Shell 

CONFIGURE_SH;
extern Shell MAKE_SH;
extern Shell INSTALL_SH; 
#endif 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure you&amp;rsquo;vecreated shell.h exactly as it appears here, andthat you&amp;rsquo;ve got the same names and number of extern Shell variables. Those areused by the Shell_run and Shell_exec functionsto run commands. I define these twofunctions, and createthe realvariables in shell.c.
shell.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;shell.h&amp;quot; 
2 #include &amp;quot;dbg.h&amp;quot; 
3 #include &amp;lt;stdarg.h&amp;gt; 
4 
5 int Shell_exec(Shell template, ...) 
6 {
7 apr_pool_t *p = NULL;
8 int rc = -1;
9 apr_status_t rv = APR_SUCCESS;
10 va_list argp;
11 const char *key = NULL;12 const char *arg = NULL;
13 int i = 0;
1. 
15 rv = apr_pool_create(&amp;amp;p,NULL); 
16 check(rv == APR_SUCCESS, &amp;quot;Failed to create pool.&amp;quot;); 
1. 
18 va_start(argtemplate); 
1. 
20 for (key = va_arg(argp, const char *); 
21 key != NULL; key = va_arg(argp, const char *)) { 
22 arg = va_arg(argp, const char *); 
2. 
24 for (i = 0; template.args[i]!= NULL; i++) { 
25 if (strcmp(template.args[key) == 0) { 
26 = arg; Shell_run(p,
27 found  it  
28 
29 
30 
31  }  }  }  
32  rc  = &amp;amp;template); 
33 apr_pool_des 
34 va_end(argp)
35 return rc;
36 
37 error: 
38 if (p){ 
39 apr_pool
40 }
41 return rc; 
42 }
43 
44 int Shell_run(apr_pool_t * p, Shell * cmd)
45 {
46 apr_procattr *attr; 
47 apr_status_t rv; 
48 apr_proc_t newproc;
49 
50 rv = apr_procattr_create(&amp;amp;a p); 
51 check(rv == APR_SUCCESS, &amp;quot;Failed to create proc attr.&amp;quot;); 
52
53 rv = apr_procattr_io_set(at APR_NO_PIPE,APR_NO_PIPE,
54 APR_ 
55 check(rv == APR_SUCCESS, &amp;quot;Failed to set IO of command.&amp;quot;); 
56 
57 rv = 
apr_procattr_dir_set(a cmd-&amp;gt;dir); 
58 check(rv == APR_SUCCESS, &amp;quot;Failed to set root to %s&amp;quot;,cmd-&amp;gt;dir); 
59 
60 rv = apr_procattr_cmdtype_s APR_PROGRAM_PATH); 
61 check(rv == APR_SUCCESS, &amp;quot;Failed to set cmd type.&amp;quot;); 
62 
63 rv = apr_proc_create(&amp;amp;newpr cmd-&amp;gt;exe, cmd-&amp;gt;args,NULL, attr, p); 
64 check(rv == APR_SUCCESS, &amp;quot;Failed to run command.&amp;quot;); 
65 
66 rv = apr_proc_wait(&amp;amp;newproc &amp;amp;cmd-&amp;gt;exit_code,&amp;amp;cmd-&amp;gt;exit_why,
67 APR_ 
68 check(rv == APR_CHILD_DONE,&amp;quot;Failed to wait.&amp;quot;); 
69 
70 check(cmd­&amp;gt;exit_code == 0, &amp;quot;%s exited badly.&amp;quot;, cmd­&amp;gt;exe); 
71 check(cmd­&amp;gt;exit_why == APR_PROC_EXIT, &amp;quot;%s was killed or crashed&amp;quot;,
72 cmd­&amp;gt;exe); 
73 
74 return 0;
75 
76 error: 
77 return -1;
78 }
79 
80 Shell CLEANUP_SH ={
81 .exe = &amp;quot;rm&amp;quot;,
82 .dir = &amp;quot;/tmp&amp;quot;,
83 .args = {&amp;quot;rm&amp;quot;, &amp;quot;-rf&amp;quot;,&amp;quot;/tmp/pkg-build&amp;quot;,&amp;quot;/tmp/pkg­src.tar.gz&amp;quot;,
84 &amp;quot;/tmp/pk src.tar.bz2&amp;quot;, &amp;quot;/tmp/DEPENDS&amp;quot;, NULL}
85 }; 
86 
87 Shell GIT_SH = {
88 .dir = &amp;quot;/tmp&amp;quot;,
89 .exe = &amp;quot;git&amp;quot;,
90 .args = {&amp;quot;git&amp;quot;, &amp;quot;clone&amp;quot;,&amp;quot;URL&amp;quot;, &amp;quot;pkg-build&amp;quot;,NULL}
91 }; 
92 
93 Shell TAR_SH = { 
94 .dir = &amp;quot;/tmp/pkg-build&amp;quot;,
95 .exe = &amp;quot;tar&amp;quot;,
96 .args = {&amp;quot;tar&amp;quot;, &amp;quot;-xzf&amp;quot;,&amp;quot;FILE&amp;quot;, &amp;quot;--strip­components&amp;quot;, &amp;quot;1&amp;quot;,NULL}
97 }; 
98 
99 Shell CURL_SH = {100 .dir = &amp;quot;/tmp&amp;quot;,101 .exe = &amp;quot;curl&amp;quot;, 
102 .args = {&amp;quot;curl&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;-o&amp;quot;, &amp;quot;TARGET&amp;quot;, &amp;quot;URL&amp;quot;, NULL} 
103 };
104 
105 Shell CONFIGURE_SH ={
106 .exe = &amp;quot;./configure&amp;quot;, 
107 .dir = &amp;quot;/tmp/pkg-build&amp;quot;,
108 .args = {&amp;quot;configure&amp;quot;, &amp;quot;OPTS&amp;quot;, NULL}
109 ,
110 }; 
11. 
112 Shell MAKE_SH = {
113 .exe = &amp;quot;make&amp;quot;,
114 .dir = &amp;quot;/tmp/pkg-build&amp;quot;,
115 .args = {&amp;quot;make&amp;quot;, &amp;quot;OPTS&amp;quot;, NULL}
116 }; 
11. 
118 Shell INSTALL_SH ={
119 .exe = &amp;quot;sudo&amp;quot;,
120 .dir = &amp;quot;/tmp/pkg-build&amp;quot;,
121 .args = {&amp;quot;sudo&amp;quot;, &amp;quot;make&amp;quot;,&amp;quot;TARGET&amp;quot;, NULL}
122 }; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Read the shell.c fromthe bottom to the top (which is a common C source layout) and you seehow I&amp;rsquo;vecreated the actual Shell variables that you indicatedwere extern in shell.h. Theylive here, butare available to the rest of the program. This is how you makeglobal variablesthat livein one .o file butare used everywhere. You shouldn&amp;rsquo;tmake many of these, but they arehandy for things like this.&lt;/p&gt;

&lt;p&gt;Continuing up the fileweget to the Shell_run function, which is abasefunction that just runs a command according to what&amp;rsquo;sin a Shell struct. It uses many of the functions defined in apr_thread_proc.h,so go lookup each oneto see how the base functionworks. This seems likealot of work compared to just using the system function call, but it also gives youmore control over the otherprogram&amp;rsquo;s execution.&lt;/p&gt;

&lt;p&gt;For example, in our Shell struct,we have a .dir attribute thatforcesthe programto be in a specific directory before running. Finally,Ihave the Shell_exec function, which is avariable argument function. You&amp;rsquo;veseen this before, but makesure you grasp the stdarg.hfunctions. In the challenge for this section, you&amp;rsquo;re going to analyzethis function.&lt;/p&gt;

&lt;p&gt;Challenge2: Analyze
Shell_exec&lt;/p&gt;

&lt;p&gt;The challenge for thesefiles (in addition to a full code review like you didin Challenge1) is to fully analyze Shell_exec and break down exactly how it works. You should be ableto understand each line,howthe two for-loops work, and how arguments are being replaced.&lt;/p&gt;

&lt;p&gt;Once you have it analyzed, add a field to struct Shell thatgives you the number ofvariable args that must be replaced. Update all of the commands to have the rightcountof args, and have an errorcheck toconfirm that these argshave been replaced, and then error exit.&lt;/p&gt;

&lt;p&gt;The Command Functions&lt;/p&gt;

&lt;p&gt;Now you get to make the actualcommandsthat do the work. These commands will use functions from APR, db.h, and shell.h todo the real work of downloading and building the software that you wantit to build. This is the most complex set offiles, so do them carefully. As before, you startby making the commands.h file, then implementingitsfunctions in the commands.c file. commands.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef _commands_h #define _commands_h 
#include &amp;lt;apr_pools.h&amp;gt;
#define DEPENDS_PATH &amp;quot;/tmp/DEPENDS&amp;quot; 
#define TAR_GZ_SRC &amp;quot;/tmp/pkg-src.tar.gz&amp;quot; 
#define TAR_BZ2_SRC &amp;quot;/tmp/pkg­src.tar.bz2&amp;quot; 
#define BUILD_DIR &amp;quot;/tmp/pkg-build&amp;quot; 
#define GIT_PAT &amp;quot;*.git&amp;quot; 
#define DEPEND_PAT &amp;quot;*DEPENDS&amp;quot; 
#define TAR_GZ_PAT &amp;quot;*.tar.gz&amp;quot; 
#define TAR_BZ2_PAT &amp;quot;*.tar.bz2&amp;quot; 
#define CONFIG_SCRIPT &amp;quot;/tmp/pkg­build/configure&amp;quot; 
enum CommandType {
COMMAND_NONE,COMMAND_INSTALL,COMMAND_LIST,COMMAND_FETCH,
COMMAND_INIT,COMMAND_BUILD}; 
int Command_fetch(apr_pool * p, const char *url,int fetch_only);
int Command_install(apr_po * p, const char *url,const char *configure_opts, const char *make_opts, const char *install_opts); 
int Command_depends(apr_po * p, const char *path); 
int Command_build(apr_pool
* p, const char *url, const char 
*configure_opts,
const char 
*make_opts,
const char 
*install_opts); 
#endif 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;snotmuchin commands.h that you haven&amp;rsquo;tseenalready. You should see that there aresome defines for strings that are used everywhere. The really interesting code isin commands.c.
commands.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;apr_uri.h&amp;gt; 
2 #include &amp;lt;apr_fnmatch.h&amp;gt; 
3 #include &amp;lt;unistd.h&amp;gt;
4 5 #include &amp;quot;commands.h&amp;quot; 
6 #include &amp;quot;dbg.h&amp;quot; 
7 #include &amp;quot;bstrlib.h&amp;quot; 
8 #include &amp;quot;db.h&amp;quot; 
9 #include &amp;quot;shell.h&amp;quot; 
1. 11 int Command_depends(apr_po * p, const char *path)
12 {
13 FILE *in = NULL;
14 bstring line = NULL;
1. 16 in = fopen(path, &amp;quot;r&amp;quot;); 
17 check(in != NULL, &amp;quot;Failed to open downloaded depends: %s&amp;quot;, path); 
1. 19 for (line = bgets((bNgetc) fgetc,in, &#39;\n&#39;); 
20 line != NULL;
21 line = bgets((bNgetc)
fgetc, in, &#39;\n&#39;)) 
22 {
23 btrimws(
24 log_info depends: %s&amp;quot;,bdata(line)); 
25 int rc = Command_install(p,bdata(line), NULL,NULL, NULL); 
26 check(rc == 0, &amp;quot;Failed to install: %s&amp;quot;,bdata(line)); 
27 bdestroy 
28 }
2. 30 fclose(in); 
31 return 0;
32 
33 error: 
34 if (line) bdestroy(line); 
35 if (in)fclose(in); 
36 return -1;
37 }
38 
39 int Command_fetch(apr_pool * p, const char *url, int fetch_only)
40 {
41 apr_uri_t info = {.port = 0 }; 
42 int rc = 0;43 const char *depends_file = NULL;
44 apr_status_t rv = apr_uri_parse(p,url,&amp;amp;info); 
45 
46 check(rv == APR_SUCCESS, &amp;quot;Failed to parse URL: %s&amp;quot;,url); 
47 
48 if (apr_fnmatch(GIT_PAT,info.path, 0) == APR_SUCCESS){
49 rc = Shell_exec(GIT_SH,&amp;quot;URL&amp;quot;, url, NULL); 
50 check(rc == 0, &amp;quot;git failed.&amp;quot;); 
51 } else if (apr_fnmatch(DEPEND_PA info.path, 0) == APR_SUCCESS){ 
52 check(!f &amp;quot;No point in fetching a DEPENDS file.&amp;quot;);
53 
54 if (info.scheme){
55 depe = DEPENDS_PATH;
56 rc = Shell_exec(CURL_SH,&amp;quot;URL&amp;quot;, url, &amp;quot;TARGET&amp;quot;,depends_file,
57 
58 chec == 0, &amp;quot;Curl failed.&amp;quot;); 
59 } else {
60 depe = info.path;
61 }
62 
63 // recursively process the devpkg list
64 log_info according to DEPENDS: %s&amp;quot;, url); 
65 rv = Command_depends(p,depends_file); 
66 check(rv == 0, &amp;quot;Failed to process the DEPENDS: %s&amp;quot;, url);
67 
68 // this indicates that (apr_fnmatch(TAR_GZ_PA nothing  needs  to  be done 69  return 0;
70
71  } else if  

info.path, 0) == APR_SUCCESS){ 
72 if (info.scheme){ 
73 rc = Shell_exec(CURL_SH, 
74 

url, &amp;quot;TARGET&amp;quot;,TAR_GZ_SRC, NULL); 
75 chec == 0, &amp;quot;Failed to curl source: %s&amp;quot;, url); 
76 }
77 
78 rv = 

apr_dir_make_recursive 79 | APR_UWRITE |80 p);81 check(rv == APR_SUCCESS, 
&amp;quot;Failed to make 
directory %s&amp;quot;,
82 
83 
84 rc = Shell_exec(TAR_SH,&amp;quot;FILE&amp;quot;, TAR_GZ_SRC,NULL); 
85 check(rc == 0, &amp;quot;Failed to untar %s&amp;quot;,TAR_GZ_SRC); 
86 } else if (apr_fnmatch(TAR_BZ2_P info.path, 0) == APR_SUCCESS){ 
87 if (info.scheme){ 
88 rc = Shell_exec(CURL_SH,&amp;quot;URL&amp;quot;, url, &amp;quot;TARGET&amp;quot;,TAR_BZ2_SRC,

89 
90 chec == 0, &amp;quot;Curl failed.&amp;quot;); 
91 }92 93 apr_stat 
rc = apr_dir_make_recursive 94 
| APR_UWRITE 
95 APR_UEXECUTE, p); 
96 
97 check(rc == 0, &amp;quot;Failed to make directory %s&amp;quot;,BUILD_DIR); 
98 rc = Shell_exec(TAR_SH,&amp;quot;FILE&amp;quot;, TAR_BZ2_SRC,NULL); 
99 check(rc == 0, &amp;quot;Failed to untar %s&amp;quot;,TAR_BZ2_SRC); 100 } else {101 sentinel 
now how to handle %s&amp;quot;, url); 
102 }103 104 // indicates that an install needs to actually run 
105 return 1;106 error: 107 return -1;
108 }109 110 int Command_build(apr_pool 
* p, const char *url,111 const char *configure_opts,const char 
*make_opts,112 const char *install_opts)113 {114 int rc = 0;115 116 check(access X_OK | R_OK | W_OK)== 0,
117 &amp;quot;Bui directory doesn&#39;t exist: %s&amp;quot;,BUILD_DIR); 118 119 // actually do an install 
120 if (access(CONFIG_SCRIPT,X_OK) == 0) { 121 log_info 

A configure script, running it.&amp;quot;); 122 rc = Shell_exec(CONFIGURE_S &amp;quot;OPTS&amp;quot;,configure_opts,NULL); 123 check(rc == 0, &amp;quot;Failed to configure.&amp;quot;); 
124 }
12. 126 rc = 
Shell_exec(MAKE_SH,
&amp;quot;OPTS&amp;quot;, make_opts,
NULL); 
127 check(rc == 
0, &amp;quot;Failed to 
build.&amp;quot;); 
12. 129 rc = 
Shell_exec(INSTALL_SH,
130 &amp;quot;TAR 

install_opts ? 
install_opts : 
&amp;quot;install&amp;quot;,
131 NULL 
132 check(rc == 
0, &amp;quot;Failed to 
install.&amp;quot;); 
133 
134 rc = 
Shell_exec(CLEANUP_SH,
NULL); 
135 check(rc == 
0, &amp;quot;Failed to cleanup 
after build.&amp;quot;); 
136 
137 rc = 

DB_update(url); 
138 check(rc == 
0, &amp;quot;Failed to add 
this package to the 
database.&amp;quot;); 
139 
140 return 0;
141 
142 error: 
143 return -1;

144 }145 146 int Command_install(apr_po 
* p, const char *url,147 const char *configure_opts,const char 
*make_opts,
148 const 
char *install_opts)
149 {
150 int rc = 0;
151 check(Shell_ 
NULL) == 0,
152 &amp;quot;Fai 
to cleanup before 
building.&amp;quot;); 
153 
154 rc = 
DB_find(url); 
155 check(rc != -1, &amp;quot;Error checking the install database.&amp;quot;); 
156 
157 if (rc == 1) {
158 log_info %s alreadyinstalled.&amp;quot;, url); 159 return 0; 
160 } 
161 162 rc = Command_fetch(p, url, 0); 
163 
164 if (rc == 1) {
165 rc = Command_build(p, url, configure_opts, make_opts, 
166 167 check(rc == 0, &amp;quot;Failed to build: %s&amp;quot;, url); 
168 } else if (rc == 0) { 169 // no install needed 170 log_info successfullyinstalled: %s&amp;quot;, url); 
171 } else {172 // had an error 
173 sentinel failed: %s&amp;quot;, url); 
174 } 
175 
176 Shell_exec(C NULL); 
177 return 0; 
178 
179 error: 
180 Shell_exec(C NULL);
181 return -1;
182 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After you have this enteredin and compiling, you can analyzeit. If you&amp;rsquo;ve done the challenges thus far, you should see how the shell.c functions are being used to run shells, andhow the arguments are being replaced. Ifnot, then go back and make sureyou truly understand how Shell_exec actually works.&lt;/p&gt;

&lt;p&gt;Challenge3: Critique My Design&lt;/p&gt;

&lt;p&gt;As before, do a complete review of this code and make sureit&amp;rsquo;s exactly the same. Then go through each function andmakesure you know how they work and what they&amp;rsquo;redoing. You should alsotrace how each function calls theother functions you&amp;rsquo;ve writtenin this file ando ther files.&lt;/p&gt;

&lt;p&gt;Finally,confirm thatyou understand allof the functions that you&amp;rsquo;recalling fromAPRhere.&lt;/p&gt;

&lt;p&gt;Once you have the file correct and analyzed, go back through and assumethat I&amp;rsquo;m an idiot. Then, criticize the design I have to seehowyou can improve itif you can. Don&amp;rsquo;t actually change the code, just create a little notes.txt file andwrite down some thoughts about what you might change.&lt;/p&gt;

&lt;p&gt;The devpkg Main Function&lt;/p&gt;

&lt;p&gt;The last and most important file, but probably the simplest, is devpkg.c, which is where the main function lives. There&amp;rsquo;s no .h
filefor this, since itincludes all of the others. Instead, this just creates the executable devpkg when combined with the other .o files from our Makefile. Enterin the codeforthis file, and make sureit&amp;rsquo;s correct.&lt;/p&gt;

&lt;p&gt;devpkg.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;stdio.h&amp;gt; 
2 #include &amp;lt;apr_general.h&amp;gt; 
3 #include &amp;lt;apr_getopt.h&amp;gt; 
4 #include &amp;lt;apr_strings.h&amp;gt; 
5 #include &amp;lt;apr_lib.h&amp;gt; 
6 
7 #include &amp;quot;dbg.h&amp;quot; 8 #include &amp;quot;db.h&amp;quot; 
9 #include &amp;quot;commands.h&amp;quot;
1. 11 int main(int argc, const char const *argv[]) 
12 {
13 apr_pool_t *p = NULL;
14 15 NULL); 16  apr_pool_ini apr_pool_cre  
17 *opt;18 rv;19  apr_getopt_t apr_status_t  
20  char  ch  = &#39;\0&#39;;
21 const char *optarg = NULL;
22 const char *config_opts = NULL;23 const char *install_opts = NULL;
24 const char *make_opts = NULL;
25 const char *url = NULL;
26 enum CommandType request = COMMAND_NONE;
2. 28 rv = apr_getopt_init(&amp;amp;opt, 
p, argc, argv); 
29 
30 while (apr_getopt(opt,&amp;quot;I:Lc:m:i:d:SF:B:&amp;quot;,&amp;amp;ch,&amp;amp;optarg) ==
31 APR_ {
32 switch (ch){
33 case &#39;I&#39;:
34 = COMMAND_INSTALL;35 = optarg; 
36  
37  
38  case &#39;L&#39;: 
39 = COMMAND_LIST;40 
41. 42  case &#39;c&#39;: 
43 = optarg;44  b 
45 
46  case &#39;m&#39;: 
47 = optarg;
48 
49 
50 case &#39;i&#39;: 
51 = optarg;52 53 54 case &#39;S&#39;: 
55 = COMMAND_INIT;56 57 
58 case &#39;F&#39;: 
59 = COMMAND_FETCH;60 
= optarg;61 62 63 case &#39;B&#39;: 
64 = COMMAND_BUILD;65 = optarg;66 
67 
} 68 
} 
69 
70 switch (request){
71 case COMMAND_INSTALL: 
72 chec &amp;quot;You must at least give a URL.&amp;quot;);
73 Comm url, config_opts,make_opts,install_opts); 
74 brea 
75 
76 case COMMAND_LIST: 
77 DB_l 
78 brea
79 
80 case COMMAND_FETCH: 
81 chec != NULL, &amp;quot;You must give a URL.&amp;quot;); 
82 Comm url, 1); 
83 log_ to %s and in /tmp/&amp;quot;,BUILD_DIR); 
84 brea 85 86 case 
COMMAND_BUILD: 
87 chec &amp;quot;You must at least give a URL.&amp;quot;);
88 Comm url, config_opts,make_opts,install_opts); 
the database.&amp;quot;); 
89  brea  
90  
91  case COMMAND_INIT: 
92  rv = DB_init(); 93  chec ==  0,  &amp;quot;Failed  to  make 
94 brea 95 96 default: 97 sent 
command given.&amp;quot;); 98 } 
99 100 return 0;101 102 error: 103 return 1; 104 }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Challenge4: The README and TestFiles&lt;/p&gt;

&lt;p&gt;The challenge for this fileis to understandhowthe arguments are being processed, what the arguments are, andthen createthe README filewith instructionson how to use them. Asyou writethe README, also write a simple test.sh that runs ./devpkg tocheck that each command is actually working against real,live code. Use the set -e at the top of yourscriptsothat it aborts on the first error.&lt;/p&gt;

&lt;p&gt;Finally,run the program under yourdebugger and makesure it&amp;rsquo;s working before moving onto the final challenge.&lt;/p&gt;

&lt;p&gt;The Final Challenge&lt;/p&gt;

&lt;p&gt;Your finalchallenge is amini examand itinvolves three things:
• Compare yourcode to mycode that&amp;rsquo;s available online. Starting at 100%, subtract 1% for each lineyougot wrong.&lt;/p&gt;

&lt;p&gt;• Take the notes.txt filethat you previously created and implement your improvements to the the code and functionality of devpkg.&lt;/p&gt;

&lt;p&gt;• Write analternative version of devpkgusing your other favorite languageor the one you thinkcan do this thebest. Compare the two,thenimprove your C versionof devpkg based on what you&amp;rsquo;velearned.&lt;/p&gt;

&lt;p&gt;To compare your code with mine,do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
cd .. # get one directory above your current one git clone git://gitorious.org/de devpkgzed
diff -r devpkg
devpkgzed 


This will clonemy version of devpkg into a directory called devpkgzed so you can then use the tool diff to comparewhat you&#39;ve done to whatI did. The files you&#39;re working with in this book comedirectlyfrom this project, so ifyou get different lines, that&#39;s an error. 

Keep in mind that there&#39;s no realpass or failon this exercise. It&#39;s just away for you to challengeyourselfto be asexact andmeticulousas possible. 

## Exercise42. Stacks and Queues 

At this point in the book, you should knowmostof the data structures thatareused to build allof theother data structures. If you havesome kind of List, `DArray`, `Hashmap`, and Tree, then you can build almost anything else out there. 

Everything else you run into either uses these or some variantof these. If it doesn&#39;t, thenit&#39;s most likelyanexotic data structure that you probably won&#39;t need. 

Stacks and Queues are very simple data structures thatare really variants of the List data structure. Allthey do is use a List with a discipline or convention that says you always place elements onone endof the List.For a Stack, you alwayspush and pop. Fora Queue,you always shift to the front, butpop from the end. 

I can implement both data structures using nothing but the CPPand twoheaderfiles. My header files are 21lines long anddo all of the Stack and Queue operations 

without anyfancy defines. To see if you&#39;ve been paying attention,I&#39;m going to show you the unit tests, and then have you implement the header filesneededto make them work. To pass this exercise, you can&#39;t createany stack.c or queue.cimplementation files. Use only the stack.h and queue.h files to make the tests run. 
stack_tests.c 

```c

1 #include 
&amp;quot;minunit.h&amp;quot; 

2 #include &amp;lt;lcthw/stack.h&amp;gt; 3 #include 
&amp;lt;assert.h&amp;gt; 
4 5 static Stack *stack = NULL; 
6 char *tests[] = { &amp;quot;test1 data&amp;quot;,&amp;quot;test2 data&amp;quot;, &amp;quot;test3 data&amp;quot; }; 
7 8 #define NUM_TESTS 3 
9 10 char *test_create() 11 {12 stack = Stack_create(); 13 mu_assert(sta != NULL, &amp;quot;Failed to create stack.&amp;quot;); 
1. 15 return NULL;
1. }17 18 char *test_destroy() 19 {20 mu_assert(sta != NULL, &amp;quot;Failed to make stack #2&amp;quot;); 21 Stack_destroy22 23 return NULL;

2. }25 26 char 

*test_push_pop() 
27 {
28 int i = 0;
29 for (i = 0;
i &amp;lt; NUM_TESTS; i++) { 
30 Stack_pus 
tests[i]); 
31 mu_assert 
== tests[i], &amp;quot;Wrong 
next value.&amp;quot;); 


32 
}33 34 mu_assert(Sta == NUM_TESTS, &amp;quot;Wrong count on push.&amp;quot;); 35 

36 STACK_FOREACH cur){ 37 debug(&amp;quot;VA %s&amp;quot;, (char *)cur­&amp;gt;value); 

38 
}
39 
40 for (i = 
NUM_TESTS -1; i &amp;gt;= 
0; i--) { 
41 char 
*val = 
Stack_pop(stack); 
42 mu_assert 
== tests[i], &amp;quot;Wrong 
value on pop.&amp;quot;); 


43 
}44 45 mu_assert(Sta == 0, &amp;quot;Wrong count after pop.&amp;quot;); 46 47 return NULL;

48 
}49 50 char *all_tests() 51 {52 mu_suite_star 53 


54 mu_run_test(t 
55 mu_run_test(t 

56 mu_run_test(t 57 58 return NULL;
59 }60 61 RUN_TESTS(all_tes 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, the queue_tests.cis almost the same, only using Queue:&lt;/p&gt;

&lt;p&gt;queue_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

1 #include &amp;quot;minunit.h&amp;quot; 
2 #include &amp;lt;lcthw/queue.h&amp;gt; 
3 #include &amp;lt;assert.h&amp;gt; 
4 
5 static Queue *queue = NULL;
6 char *tests[] = { &amp;quot;test1 data&amp;quot;,&amp;quot;test2 data&amp;quot;, &amp;quot;test3 data&amp;quot; }; 
7 
8 #define NUM_TESTS 3 
9 
10 char 

*test_create() 
11 {
12 queue = Queue_create(); 
13 mu_assert(qu != NULL, &amp;quot;Failed to create queue.&amp;quot;); 
1. 15 return NULL;
16 }
1. 18 char 

*test_destroy() 19 {20 mu_assert(qu != NULL, &amp;quot;Failed to 
make queue #2&amp;quot;); 21 Queue_destro 22 23 return 
NULL;
24 }
2. 26 char 

*test_send_recv() 27 {28 int i = 0;29 for (i = 0;
i &amp;lt; NUM_TESTS; i++) { 30 Queue_se tests[i]); 
31 mu_asser == tests[0], &amp;quot;Wrong next value.&amp;quot;); 
32 }33 34 mu_assert(Qu 
== NUM_TESTS, &amp;quot;Wrong 
count on send.&amp;quot;); 
35 
36 QUEUE_FOREAC cur){
37 debug(&amp;quot;V %s&amp;quot;, (char *)cur­&amp;gt;value); 
38 }
39 
40 for (i = 0; 

i &amp;lt; NUM_TESTS; i++) { 
41 char *val = Queue_recv(queue); 
42 mu_asser == tests[i], &amp;quot;Wrong value on recv.&amp;quot;); 
43 }44 45 mu_assert(Qu 
== 0, &amp;quot;Wrong count 
after recv.&amp;quot;); 
46 
47 return 
NULL;
48 } 
49 

50 char 

*all_tests() 

60 
51 52  {  mu_suite_sta  
53  
54 55 56 57  mu_run_test(mu_run_test(mu_run_test(  
58  return  
NULL;59  }  

61 RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;Your unit testshould run without your having to change the tests, and itshould pass the debugger with no memory errors. Here&amp;rsquo;swhat it looks likeif I run stack_tests directly:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 42.1 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ ./tests/stack_tests
DEBUG tests/stack_tests.c:60 -----RUNNING: ./tests/stack_tests 
RUNNING: ./tests/stack_tests DEBUG tests/stack_tests.c:53 -----test_create DEBUG tests/stack_tests.c:54 -----test_push_pop DEBUG 
tests/stack_tests.c:37 

VAL: test3 data DEBUG tests/stack_tests.c:37 VAL: test2 data DEBUG tests/stack_tests.c:37 VAL: test1 data DEBUG tests/stack_tests.c:55 -----test_destroy ALL TESTS PASSED Tests run: 3 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The queue_test is basically thesamekind of output, so Ishouldn&amp;rsquo;t have to showit to you at thisstage.&lt;/p&gt;

&lt;p&gt;How to Improve It&lt;/p&gt;

&lt;p&gt;The only realimprovement you could maketo this is switching from a List toa &lt;code&gt;DArray&lt;/code&gt;. The Queue data structure ismore difficult to do with a &lt;code&gt;DArray&lt;/code&gt; becauseit works at both endsof thelist ofnodes.&lt;/p&gt;

&lt;p&gt;Onedisadvantageof doing this entirely in a header file is thatyou can&amp;rsquo;t easily performance tune it. Mostly, what you&amp;rsquo;redoing with this technique isestablishinga protocol for how touse a List in a certain style. When performance tuning, if you make List fast,then these two should improve as well.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Implement Stack using &lt;code&gt;DArray&lt;/code&gt; instead of List, but without changing the unit test. That meansyou&amp;rsquo;ll have to createyour own STACK_FOREACH.&lt;/p&gt;

&lt;h2 id=&#34;exercise43-a-simplestatistics-engine:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise43. A SimpleStatistics Engine&lt;/h2&gt;

&lt;p&gt;This is asimplealgorithm thatI usefor collecting summary statistics online, or without storing all of the samples. I usethis inany software that needsto keep somestatistics, such as mean, standarddeviation, and sum, butcan&amp;rsquo;tstore allthe samples needed. Instead, Icanjust storethe rolling results of the calculations,whichis only five numbers.&lt;/p&gt;

&lt;p&gt;Rolling Standard Deviation and Mean&lt;/p&gt;

&lt;p&gt;The first thing you needis asequenceof samples. This can be anything from the time it takes to completea task to the number of times someone accesses something to star ratings on aWeb site. It doesn&amp;rsquo;treallymatter what it is,just so long asyouhave a stream ofnumbersand you want to know the following summary statistics about them:&lt;/p&gt;

&lt;p&gt;sum This is the total of all the numbers added together.&lt;/p&gt;

&lt;p&gt;sum squared (sumsq)&lt;/p&gt;

&lt;p&gt;This is the sumof the square of eachnumber.&lt;/p&gt;

&lt;p&gt;count (n) This is the number samples that you&amp;rsquo;vetaken.&lt;/p&gt;

&lt;p&gt;min This is the smallest sample you&amp;rsquo;veseen.&lt;/p&gt;

&lt;p&gt;max This is thelargest sample you&amp;rsquo;veseen.&lt;/p&gt;

&lt;p&gt;mean This is the most likely middle number. It&amp;rsquo;snotactually the middle, sincethat&amp;rsquo;sthe median, butit&amp;rsquo;s an acceptedapproximation for it.&lt;/p&gt;

&lt;p&gt;stddev This iscalculated using $sqrt(sumsq – (sum ×mean))/(n – 1) ))$ where sqrt is the square root function in the math.h header.&lt;/p&gt;

&lt;p&gt;I will confirmthis calculation works using R, since I know R gets these right:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 43.1 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
&amp;gt; s &amp;lt;-runif(n=10, max=10)
&amp;gt;s 

[1] 6.1061334 9.6783204 1.2747090 8.2395131 0.3333483 6.9755066 1.0626275 
[8] 7.6587523 4.9382973 9.578811. &amp;gt; summary(s)
Min. 1st Qu. 
Median Mean 3rd Qu. Max. 
0.3333 2.1910 6.5410 5.5850 8.0940 9.6780 
&amp;gt; sd(s)
[1] 3.547868 
&amp;gt; sum(s)
[1] 55.84602 
&amp;gt; sum(s*s)
[1] 425.1641 
&amp;gt; sum(s) * mean(s)
[1] 311.8778 
&amp;gt; sum(s*s) -sum(s)
* mean(s)
[1] 113.2863 
&amp;gt; (sum(s*s) ­sum(s) * mean(s)) /(length(s) -1)
[1] 12.58737 
&amp;gt; sqrt((sum(s*s) ­sum(s) * mean(s)) /(length(s) -1)) 
[1] 3.547868 
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You don&amp;rsquo;tneed to knowR. Just follow along while I explain how I&amp;rsquo;mBreaking this down tocheck my math:&lt;/p&gt;

&lt;p&gt;Lines1-4 I use the function runif toget arandomuniform distribution of numbers, thenprint them out. I&amp;rsquo;ll use these in the unit test later.&lt;/p&gt;

&lt;p&gt;Lines5-7 Here&amp;rsquo;s the summary, so you can see the valuesthat R calculatesfor these.&lt;/p&gt;

&lt;p&gt;Lines8-9 This is the stddev using the sd function.&lt;/p&gt;

&lt;p&gt;Lines10-11 NowIbegin to buildthis calculation manually,first by getting the sum.&lt;/p&gt;

&lt;p&gt;Lines12-13 Thenext piece of the stdev formula is the sumsq, which I can getwith sum(s * s) that tells Rto multiply the whole s list byitself, andthen sum those. The power ofR is being ableto do math on entiredata&lt;/p&gt;

&lt;p&gt;structureslike this.&lt;/p&gt;

&lt;p&gt;Lines14-15 Looking at the formula, I then need the sum multiplied by mean,soI do sum(s) * mean(s).&lt;/p&gt;

&lt;p&gt;Lines16-17 Ithen combinethe sumsqwith this toget sum(s * s) -sum(s) * mean(s).&lt;/p&gt;

&lt;p&gt;Lines18-19 Thatneeds to be divided by $n-1$, so I do (sum(s * s) ­sum(s) * mean(s)) /(length(s) -1).&lt;/p&gt;

&lt;p&gt;Lines20-21 Finally, I sqrt thatand I get 3.547868,which matches the number R gave me for sd above.&lt;/p&gt;

&lt;p&gt;Implementation&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s how you calculate the stddev, so nowI can make somesimplecode to implement this calculation.
stats.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef lcthw_stats_h 
#define lcthw_stats_h 

typedef struct Stats 
{ double sum;double sumsq;
unsigned long n;
double min;double max;
} Stats; 

Stats *Stats_recreate(double sum, double sumsq,unsigned long n, double min,double max);
Stats *Stats_create(); 
double Stats_mean(Stats * st);
double Stats_stddev(Stats * st);
void Stats_sample(Stats * st, double s);
void Stats_dump(Stats * st);
#endif 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hereyou cansee that I&amp;rsquo;ve put the calculations I need to storein a struct, and then I havefunctionsfor sampling and getting thenumbers. Implementing this is then just an exercise in converting the math:&lt;/p&gt;

&lt;p&gt;stats.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

1 #include &amp;lt;math.h&amp;gt; 
2 #include &amp;lt;lcthw/stats.h&amp;gt; 
3 #include &amp;lt;stdlib.h&amp;gt; 
4 #include &amp;lt;lcthw/dbg.h&amp;gt; 
5 
6 Stats *Stats_recreate(double sum, double sumsq,unsigned long n,
7 double min, double max)
8 {
9 Stats *st = 
malloc(sizeof(Stats));10 check_mem(st 11 12 st-&amp;gt;sum = 
sum;13 st-&amp;gt;sumsq = 
sumsq;14 st-&amp;gt;n = n;15 st-&amp;gt;min = 
min;16 st-&amp;gt;max = 
max;17 18 return st;19 20 error: 21 return NULL;
22 }
2. 
24 Stats 

*Stats_create() 
25 {
26 return 
Stats_recreate(0.0,0.0, 0L, 0.0, 0.0); 
27 }
2. 29 double 

Stats_mean(Stats * 
st)
30 {
31 return st­
&amp;gt;sum / st-&amp;gt;n; 
32 33  }  
34  double  
Stats_stddev(Stats st)35 {36 return  *  
sqrt((st-&amp;gt;sumsq -(st-&amp;gt;sum * st-&amp;gt;sum st-&amp;gt;n)) /  /  - 

37 (st&amp;gt;n -1)); 
38 }39 40 void 
Stats_sample(Stats * st, double s) 41 {
42 st-&amp;gt;sum += s;
43 st-&amp;gt;sumsq += s * s;
44 
45 if (st-&amp;gt;n == 0) { 
46 st-&amp;gt;min = s;
47 st-&amp;gt;max = s;
48 } else {49 if (st­&amp;gt;min &amp;gt; s)
50 st­&amp;gt;min = s; 
51 if (st­&amp;gt;max &amp;lt; s)
52 st­&amp;gt;max = s;
53 } 
54 
55 st-&amp;gt;n += 1; 
56 } 
57 
58 void Stats_dump(Stats * st) 
59 {60 fprintf(stde 
61 &amp;quot;sum %f, sumsq: %f, n: %ld, &amp;quot; 
62 &amp;quot;min %f, max: %f, mean: %f, stddev: %f&amp;quot;, 
63 st-&amp;gt;sum, st-&amp;gt;sumsq, st-&amp;gt;n, st-&amp;gt;min, st-&amp;gt;max, Stats_mean(st),
64 Stat 
65 } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s abreakdown of each function in stats.c:&lt;/p&gt;

&lt;p&gt;Stats_recreate I&amp;rsquo;llwant to load these numbers fromsome kind of database, and this function let&amp;rsquo;s me recreate a Stats
struct.&lt;/p&gt;

&lt;p&gt;Stats_create This simply called Stats_recreate with all 0 (zero) values.&lt;/p&gt;

&lt;p&gt;Stats_mean Using the sum and n, it gives the mean.&lt;/p&gt;

&lt;p&gt;Stats_stddev This implements the formula I worked out; the only difference is thatI calculate the mean with st-&amp;gt;sum / st-&amp;gt;n
in thisformula instead ofcalling Stats_mean.&lt;/p&gt;

&lt;p&gt;Stats_sample This does the workof maintaining the numbers in the Stats struct. When you giveit the first value, itsees that n is 0 and sets min and max accordingly. Every call after thatkeeps increasing sum, sumsq, and n.It then figuresout if this new sample is anew min or max.&lt;/p&gt;

&lt;p&gt;Stats_dump This is a simple debug function thatdumps the statistics so you can viewthem.&lt;/p&gt;

&lt;p&gt;The last thing Ineed to do is confirmthat thismathis correct. I&amp;rsquo;m going to use numbers and calculations from my R sessionto createa unit test that confirms that I&amp;rsquo;m getting the right results.&lt;/p&gt;

&lt;p&gt;stats_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;quot;minunit.h&amp;quot; 
2 #include &amp;lt;lcthw/stats.h&amp;gt; 
3 #include &amp;lt;math.h&amp;gt;
4 
5 const int NUM_SAMPLES = 10;
6 double samples[] = {
7 6.1061334,9.6783204, 1.2747090,8.2395131, 0.3333483,
8 6.9755066,1.0626275, 7.6587523,4.9382973, 9.578811. 
9 }; 
1. 
11 Stats expect = {
12 .sumsq = 425.1641,
13 .sum = 55.84602,
14 .min = 0.333,
15 .max = 9.678,
16 .n = 10,
17 }; 
1. 
19 double expect_mean = 5.584602. 
20 double expect_stddev = 3.547868;
2. 
22 #define EQ(X,Y,N) (round((X) * pow(10, N)) == round((Y) * pow(10, N)))
2. 24 char *test_operations() 
25 {
26 int i = 0;
27 Stats *st = Stats_create(); 
28 mu_assert(st != NULL, &amp;quot;Failed to create stats.&amp;quot;); 
2. 30 for (i = 0;i &amp;lt; NUM_SAMPLES; i++){
31 Stats_sa samples[i]); 
32 }
33 
34 Stats_dump(s 
35 
36 mu_assert(EQ &amp;gt;sumsq, expect.sumsq,3), &amp;quot;sumsq not valid&amp;quot;);
37 mu_assert(EQ&amp;gt;sum, expect.sum, 3), &amp;quot;sum not valid&amp;quot;); 
38 mu_assert(EQ&amp;gt;min, expect.min, 3), &amp;quot;min not valid&amp;quot;); 
39 mu_assert(EQ&amp;gt;max, expect.max, 3), &amp;quot;max not valid&amp;quot;); 
40 mu_assert(EQ&amp;gt;n, expect.n, 3), &amp;quot;max not valid&amp;quot;); 
41 mu_assert(EQStats_mean(st), 3), &amp;quot;mean not valid&amp;quot;); 
42 mu_assert(EQ 
Stats_stddev(st), 43  3), &amp;quot;std  
not 44  valid&amp;quot;);  
45  return  
NULL;46 }47  
48  char  
*test_recreate() 
49 {  = 50 Stats *st Stats_recreate(
51 expe expect.sumsq, expect.n, expect.min, expect.max);
52 
53 mu_assert(st &amp;gt;sum == expect.sum,&amp;quot;sum not equal&amp;quot;); 
54 mu_assert(st &amp;gt;sumsq == expect.sumsq, &amp;quot;sumsq not equal&amp;quot;); 
55 mu_assert(st &amp;gt;n == expect.n, &amp;quot;n not equal&amp;quot;); 
56 mu_assert(st &amp;gt;min == expect.min,&amp;quot;min not equal&amp;quot;); 
57 mu_assert(st &amp;gt;max == expect.max,&amp;quot;max not equal&amp;quot;); 
58 mu_assert(EQStats_mean(st), 3), &amp;quot;mean not valid&amp;quot;); 
59 mu_assert(EQStats_stddev(st), 3), 
60 &amp;quot;std not valid&amp;quot;); 
61 
62 return NULL;
63 }
64 
65 char 

*all_tests() 66 {67 mu_suite_sta 68 
69 70 71  mu_run_test(mu_run_test(  
72  return  
NULL;73 74  }  
75  RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s nothing new in this unit test,exceptmaybethe EQ macro.&lt;/p&gt;

&lt;p&gt;I felt lazy and didn&amp;rsquo;t want to look upthe standardway to tell if two double values are close, so I made this macro. The problem with double is that equalityassumes totallyequal results, but I&amp;rsquo;musing two differentsystems with slightlydifferent rounding errors. The solution is to say thatIwant the numbers to be &amp;ldquo;equalto X decimalplaces.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;I do this with EQ byraising the number toa power of10, thenusing the round function toget an integer. This is asimpleway toround to N decimalplaces and compare the results asan integer. I&amp;rsquo;msure there are a billion other waysto do the same thing, but thisworks for now.&lt;/p&gt;

&lt;p&gt;The expected results are then in a Stats struct and I simplymake surethat the number I getis closeto the number R gave me.&lt;/p&gt;

&lt;p&gt;How to Use It&lt;/p&gt;

&lt;p&gt;You can use the standard deviation andmean to determine ifa new sampleis interesting, oryou canuse this to collectstatistics on statistics. The first one iseasy for people tounderstand,so I&amp;rsquo;ll explainthat quickly using an exampleforlogin times.&lt;/p&gt;

&lt;p&gt;Imagine you&amp;rsquo;re tracking how long users spend onaserver, and you&amp;rsquo;re using statistics to analyzeit. Every time someone logs in, you keep track of how long they are there,then you call Stats_sample. I&amp;rsquo;m looking for people who areon toolong and alsopeoplewho seem tobeon too quickly.&lt;/p&gt;

&lt;p&gt;Instead ofsetting specific levels, what I&amp;rsquo;d dois compare how long someone is onwith
the mean (plus or minus) 2&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stddev range. I get the mean and 2&lt;/li&gt;
&lt;li&gt;stddev, and consider login times to beinteresting if they are outside thesetwo ranges. SinceI&amp;rsquo;m keeping these statistics using arolling algorithm,this is averyfast calculation, and I can then have the softwareflag the users who areoutsideof this range.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This doesn&amp;rsquo;tnecessarily point outpeople whoare behaving badly, butinstead itflags potential problems thatyou can review tosee what&amp;rsquo;s going on. It&amp;rsquo;salso doing it based on the behavior of all of the users, which avoids the problem of pickingsome arbitrarynumberthat&amp;rsquo;snot based on what&amp;rsquo;s really happening.&lt;/p&gt;

&lt;p&gt;The general rule you can get fromthis is that the mean (plus or minus) 2 * stddev is an estimate of where 90% of the values are expected tofall, and anything outside that range is interesting.&lt;/p&gt;

&lt;p&gt;The secondway tousethese statisticsis to go meta and calculate them for other Stats calculations. You basically do your Stats_sample like normal, but then you run Stats_sample on the min, max, n, mean, and stddev onthat sample. This givesa two-level measurement, andletsyou comparesamples of samples.&lt;/p&gt;

&lt;p&gt;Confusing, right? I&amp;rsquo;ll continuemyexample above, butlet&amp;rsquo;s say you have100 servers thateach holda differentapplication. You&amp;rsquo;re already tracking users&amp;rsquo; login timesfor each application server, butyou want to compare all 100 applications and flag any users that are logging intoo much on all of them. Theeasiestway to do thatis tocalculatethe new login stats each time someone logsin, and then add that Stats structs element to a second Stat.&lt;/p&gt;

&lt;p&gt;What youend upwithis a series of statisticsthat can be named like this: meanof means This is a full Stats struct thatgives you mean and stddev of the meansof alltheservers. Any server or user who is outside ofthis is worthlookingaton a global level. meanof stddevs Another Stats struct that producesstatistics on how all of the servers range. You can then analyzeeach server and seeif anyof them have unusually wide-ranging numbers by comparing their stddev to this mean of stddevs statistic.&lt;/p&gt;

&lt;p&gt;You could do themall, but these are the mostuseful. If you thenwantedto monitor servers for erratic logintimes, you&amp;rsquo;ddo this:&lt;/p&gt;

&lt;p&gt;• UserJohn logs into and out of server A. Grab server A&amp;rsquo;s statistics and update them.&lt;/p&gt;

&lt;p&gt;• Grab the mean of means statistics, and thentake A&amp;rsquo;smean and add itas a sample. I&amp;rsquo;ll call this m_of_m.&lt;/p&gt;

&lt;p&gt;• Grab the mean of stddevs statistics, and add A&amp;rsquo;s stddev to it asa sample. I&amp;rsquo;ll call this m_of_s.&lt;/p&gt;

&lt;p&gt;• If A&amp;rsquo;s mean is outside of m_of_m.mean + 2* m_of_m.stddev, thenflagitas possibly having a problem.&lt;/p&gt;

&lt;p&gt;• If A&amp;rsquo;s stddev is outside of m_of_s.mean + 2 * m_of_s.stddev, thenflagitas possibly behaving tooerratically.&lt;/p&gt;

&lt;p&gt;• Finally, if John&amp;rsquo;slogin time is outside ofA&amp;rsquo;s range,or A&amp;rsquo;s m_of_m range,then flag itas interesting.&lt;/p&gt;

&lt;p&gt;Using thismean of meansand meanof stddevs calculation, you can efficientlytrack many metrics with a minimal amount of processing and storage.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Convert the Stats_stddev and Stats_mean to static inline functions in the stats.h file instead ofin the stats.c file.&lt;/p&gt;

&lt;p&gt;• Use thiscode towritea performance test of the string_algos_test Make itoptional, and have itrun the base test asa seriesof samples, and then report the results.&lt;/p&gt;

&lt;p&gt;• Write a versionof this in another programming languageyou know. Confirmthat this version is correctbased on what I have here.&lt;/p&gt;

&lt;p&gt;• Write a little program that cantake afilefull ofnumbers and spit these statistics outfor them.&lt;/p&gt;

&lt;p&gt;• Makethe program accept a tableof data that hasheaders on one line, then all of the other numbers onlines after it are separatedby any numberof spaces. Your program should thenprint out these statisticsfor each columnby theheader name.&lt;/p&gt;

&lt;h2 id=&#34;exercise44-ring-buffer:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise44. Ring Buffer&lt;/h2&gt;

&lt;p&gt;Ring buffersare incredibly useful when processing asynchronousI/O. They allow onesideto receive data in random intervals of random sizes, but feed cohesive chunks toanother side insetsizes or intervals. They area varianton the Queue data structure but focus on blocks of bytes instead ofa lis tof pointers. In this exercise, I&amp;rsquo;m going to show you the RingBuffercode, andthen have you make a fullunittestfor it.&lt;/p&gt;

&lt;p&gt;ringbuffer.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #ifndef _lcthw_RingBuffer_h 
2 #define _lcthw_RingBuffer_h
3 
4 #include &amp;lt;lcthw/bstrlib.h&amp;gt; 
5 
6 typedef struct { 
7 char *buffer;
8 int length;
9 int start;
10 int end;
11 } RingBuffer;1. 
13 RingBuffer *RingBuffer_create(int
length); 
14 
15 void RingBuffer_destroy(Rin * buffer); 
16 17 int
RingBuffer_read(RingBu 
* buffer, char 
*target, int amount); 18 
19 int RingBuffer_write(RingB * buffer, char *data,int length);
2. 21 int RingBuffer_empty(RingB *
buffer); 
22 23 int RingBuffer_full(RingBu * buffer); 
24 25 int RingBuffer_available_d * buffer); 
26 27 int RingBuffer_available_s * buffer);
2. 29 bstringRingBuffer_gets(RingBu * buffer, int amount);
30 
31 #define RingBuffer_available_d (\ 
32 ((B)­&amp;gt;end + 1) % (B)­&amp;gt;length -(B)-&amp;gt;start -1. 33 
34 #define RingBuffer_available_s (\ 
35 (B)­&amp;gt;length -(B)-&amp;gt;end ­1. 36 
37 #define RingBuffer_full(B) (RingBuffer_available_ 
38 -(B)­&amp;gt;length == 0) 
39 
40 #define RingBuffer_empty(B) (\ 
41 RingBuff == 0) 
42 
43 #define RingBuffer_puts(B, D) RingBuffer_write(\ 
44 (B), bdata((D)), blength((D))) 
45 
46 #define RingBuffer_get_all(B) RingBuffer_gets(\ 
47 (B), RingBuffer_available_d 
48 
49 #define RingBuffer_starts_at(B (\ 
50 (B)­&amp;gt;buffer + (B)-&amp;gt;start) 
51 
52 #define RingBuffer_ends_at(B) (\ 
53 (B)­&amp;gt;buffer + (B)-&amp;gt;end) 
54 
55 #define RingBuffer_commit_read 
A) (\ 
56 (B)­&amp;gt;start = ((B)-&amp;gt;start 
+ (A)) % (B)-&amp;gt;length) 
57 
58 #define RingBuffer_commit_writ 
A) (\ 
59 (B)­&amp;gt;end = ((B)-&amp;gt;end + (A)) % (B)-&amp;gt;length) 
60 
61 #endif 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at the data structure, you seeIhave a buffer, start, and end.A RingBuffer does nothing more than move the start and end around thebufferso that it loops wheneverit reachesthe buffer&amp;rsquo;s end. Doing this gives the illusion of aninfiniteread device in a smallspace. Ithen have a bunch of macros thatdo variouscalculations basedon this.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the implementation, which is amuch better explanation of how this works.
ringbuffer.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #undef NDEBUG 
2 #include &amp;lt;assert.h&amp;gt; 
3 #include &amp;lt;stdio.h&amp;gt; 
4 #include &amp;lt;stdlib.h&amp;gt; 
5 #include &amp;lt;string.h&amp;gt; 
6 #include &amp;lt;lcthw/dbg.h&amp;gt; 
7 #include &amp;lt;lcthw/ringbuffer.h&amp;gt; 
8 
9 RingBuffer *RingBuffer_create(int length)
10 {
11 RingBuffer *buffer = calloc(1,sizeof(RingBuffer)); 
12 buffer­&amp;gt;length = length + 1;
13 buffer­&amp;gt;start = 0;
14 buffer-&amp;gt;end = 0;
15 buffer­&amp;gt;buffer = calloc(buffer­&amp;gt;length, 1); 
1. 17 return buffer;
18 }
1. 20 void RingBuffer_destroy(Rin * buffer)21 {22 if (buffer)
{23 free(buf &amp;gt;buffer); 
24 free(buf 
2. }

2. }
2. 28 int RingBuffer_write(RingB
* buffer, char *data,
int length)
29 {
30 if (RingBuffer_available_== 0) {
31 buffer­&amp;gt;start = buffer-&amp;gt;end = 0;
32 } 
33 34 check(length &amp;lt;= RingBuffer_available_s
35 &amp;quot;Not enough space: %d request, %d available&amp;quot;,
36 Ringlength); 
37 
38 void *result = memcpy(RingBuffer_ends data, length); 
39 check(result != NULL, &amp;quot;Failed to write data into buffer.&amp;quot;);
40 
41 RingBuffer_c length); 
42 
43 return length;
44  error:  
45 46 47  }  return  -1;  
48  int RingBuffer_read(RingBu * buffer, char *target, int amount)
49 {
50 check_debug(&amp;lt;= RingBuffer_available_d 
51 &amp;quot;Not enough in the buffer: has %d, needs %d&amp;quot;,
52 Ringamount); 
53 
54 void *result = memcpy(target,RingBuffer_starts_at(b amount); 
55 check(result != NULL, &amp;quot;Failed to write buffer into data.&amp;quot;); &amp;gt;end buffer­
56  
57 amount); 58  RingBuffer_c  
59 ==  if (buffer-&amp;gt;start){
60 buffer­&amp;gt;start = buffer-&amp;gt;end = 0;
61 }62 63 return amount; RingBuffer_gets(RingBu

64  error:  
65 66 67  }  return  -1;  
68  bstring * buffer, int amount)
69 {70 check(amount &amp;gt; 0, &amp;quot;Need more than 0 for gets, you gave: %d &amp;quot;,
71 amou 
72 check_debug(&amp;lt;= RingBuffer_available_d
73 &amp;quot;Not enough in the buffer.&amp;quot;); 
74 
75 bstring result = blk2bstr(RingBuffer_st amount); 
76 check(result != NULL, &amp;quot;Failed to create getsresult.&amp;quot;); 
77 check(blengt == amount, &amp;quot;Wrong result length.&amp;quot;); 
78 

79 amount); 80 &amp;gt;= 0  RingBuffer_c assert(RingB  
81  &amp;amp;&amp;amp; &amp;quot;Error  in  read commit.&amp;quot;);
82 
83 return result;
84 error: 
85 return NULL;
86 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is all there is to a basic RingBuffer implementation. You can readand write blocks of data to it. You can ask how much is in it and howmuch space it has. There are some fancier ring buffers thatusetrickson the OS to create an imaginary infinite store, but those aren&amp;rsquo;t portable.&lt;/p&gt;

&lt;p&gt;Since my RingBufferdeals with reading and writing blocks of memory, I&amp;rsquo;m making surethat anytime end == start, I reset them to 0 (zero) so that they go to the beginningof the buffer. In theWikipedia versionitisn&amp;rsquo;twriting blocks ofdata,soit only has to move end and start around in a circle. To better handle blocks,youhave to drop to the beginning of the internal buffer whenever the datais empty.&lt;/p&gt;

&lt;p&gt;The Unit Test&lt;/p&gt;

&lt;p&gt;For yourunittest, you&amp;rsquo;ll want to testas many possible conditions as you can. The easiest way to do that is to preconstructdifferent RingBuffer structs, and thenmanually check that the functions andmathwork right. For example,you could makeone where end is right at the end of thebuffer and start is rightbefore the buffer, and then seehow it fails.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s my ringbuffer_tests run:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 44.1 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;

$ ./tests/ringbuffer_tes
DEBUG tests/ringbuffer_tests -----
RUNNING: ./tests/ringbuffer_tes 
RUNNING: ./tests/ringbuffer_tes 
DEBUG tests/ringbuffer_tests -----test_create 
DEBUG tests/ringbuffer_tests -----test_read_write 
DEBUG tests/ringbuffer_tests -----test_destroy 
ALL TESTS PASSED Tests run: 3 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should have atleast three tests that confirm all of the basic operations, andthen see how much more you can test beyondwhatI&amp;rsquo;vedone.&lt;/p&gt;

&lt;p&gt;How to Improve It&lt;/p&gt;

&lt;p&gt;As usual, you shouldgo back and add defensive programming checksto this exercise. Hopefully you&amp;rsquo;ve been doing this, becausethe base codein mostof liblcthw doesn&amp;rsquo;t have the common defensive programming checksthat I&amp;rsquo;m teaching you. I leavethis to you so thatyou can get used to improving code with these extra checks.&lt;/p&gt;

&lt;p&gt;For example, in this ring buffer,there&amp;rsquo;s nota lot of checking that an access will actually be inside thebuffer. If youread the &amp;ldquo;Circular buffer&amp;rdquo; pageon Wikipedia, you&amp;rsquo;ll see the &amp;ldquo;Optimized POSIX implementation&amp;rdquo; that uses Portable Operating SystemInterface(POSIX)­specific calls tocreate an infinite space. Studythat and I&amp;rsquo;ll have you try itin the Extra Credit section.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Create an alternative implementation of RingBuffer that uses the POSIXtrickand thencreate a unit test for it.&lt;/p&gt;

&lt;p&gt;• Add a performance comparis ontestto this unit test that compares the two versions by fuzzing them with random data and random read/write operations. Make sure thatyou set upthis fuzzingsothat thesame operations are done to each version, and you can compare them between runs.&lt;/p&gt;

&lt;h2 id=&#34;exercise45-a-simpletcp-ip-client:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise45. A SimpleTCP/IP Client&lt;/h2&gt;

&lt;p&gt;Im going tousethe RingBuffer tocreate a very simplistic network testing tool thatI call netclient. To do this,I have to add some stuff to the Makefile tohandlelittle programs in the bin/ directory. Augment the Makefile First, add a variablefor the programs just likethe unit test&amp;rsquo;s TESTS and TEST_SRC variables:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
PROGRAMS_SRC=$(wildcar bin/*.c) 
PROGRAMS=$(patsubst%.c,%,$(PROGRAMS_SRC)) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, you want to add the PROGRAMS to the all target:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
all: $(TARGET)$(SO_TARGET) tests $(PROGRAMS) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, add PROGRAMS to the rm line in the clean target:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
rm –rf build $(OBJECTS) $(TESTS)$(PROGRAMS) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally,you just need a target at the end to buildthemall:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$(PROGRAMS): CFLAGS += $(TARGET) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With these changes,you can drop simple .c files into bin, and make will build them and link them to the
library just like unit tests do.&lt;/p&gt;

&lt;p&gt;The netclient Code&lt;/p&gt;

&lt;p&gt;The code forthe little netclientlookslike this:
netclient.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #undef NDEBUG 2 #include 
&amp;lt;stdlib.h&amp;gt; 
3 #include &amp;lt;sys/select.h&amp;gt; 
4 #include &amp;lt;stdio.h&amp;gt; 
5 #include &amp;lt;lcthw/ringbuffer.h&amp;gt; 
6 #include &amp;lt;lcthw/dbg.h&amp;gt; 
7 #include &amp;lt;sys/socket.h&amp;gt; 
8 #include 
&amp;lt;sys/types.h&amp;gt; 9 #include &amp;lt;sys/uio.h&amp;gt; 10 #include &amp;lt;arpa/inet.h&amp;gt; 
11 #include &amp;lt;netdb.h&amp;gt; 
12 #include &amp;lt;unistd.h&amp;gt; 
13 #include &amp;lt;fcntl.h&amp;gt; 
1. 15 struct tagbstring NL = bsStatic(&amp;quot;\n&amp;quot;); 
16 struct tagbstring CRLF = bsStatic(&amp;quot;\r\n&amp;quot;); 
1. 18 int nonblock(int fd) 19 {
20 int flags = fcntl(fd, F_GETFL,0);
21 check(flags &amp;gt;= 0, &amp;quot;Invalid flags on nonblock.&amp;quot;); 
2. 23 int rc = fcntl(fd, F_SETFL,flags | O_NONBLOCK); 
24 check(rc == 0, &amp;quot;Can&#39;t set nonblocking.&amp;quot;); 
2. 26 return 0;27 error: 
28 return -1;
29 }
30 
31 int client_connect(char *host, char *port)
32 {
33 int rc = 0;
34 struct addrinfo *addr = NULL;
35 
36 rc = get addrinfo(host,port, NULL,&amp;amp;addr); 
37 check(rc == 0, &amp;quot;Failed to lookup %s:%s&amp;quot;, host, port);
38 
39 int sock = socket(AF_INET,SOCK_STREAM, 0); 
40 check(sock &amp;gt;= 0, &amp;quot;Cannot create a socket.&amp;quot;); 
41 
42 rc = connect(sock, addr­&amp;gt;ai_addr, addr­&amp;gt;ai_addrlen); 
43 check(rc == 0, &amp;quot;Connect failed.&amp;quot;); 
44 45 rc = nonblock(sock);
46 check(rc == 0, &amp;quot;Can&#39;t set nonblocking.&amp;quot;); 
47  
48  freeaddrinfo  
49  return sock;50
51  error:  
52  freeaddrinfo  
53 
54 
55  }  return  -1;
56 int read_some(RingBuffer * buffer, int fd, int is_socket)
57 {58 int rc = 0;
59 60 if (RingBuffer_available_== 0) {
61 buffer­&amp;gt;start = buffer-&amp;gt;end = 0;
62 }
63 
64 if (is_socket){
65 rc = recv(fd,RingBuffer_starts_at(b
66 0);
67 } else {
68 rc = read(fd,RingBuffer_starts_at(b 
69
70 }
71 
72 check(rc &amp;gt;= 0, &amp;quot;Failed to read from fd: %d&amp;quot;, fd); 
73
74 RingBuffer_c rc);
75  
76 
77  return  rc;  
78  error:  
79 
80 
81  }  return  -1;  
82  int write_some(RingBuffer * buffer, int fd, int is_socket)
83 {84 int rc = 0;
85 bstring
data = RingBuffer_get_all(buf 
86 
87 check(data != NULL, &amp;quot;Failed to get from the buffer.&amp;quot;); 
88 check(bfindr &amp;amp;NL,&amp;amp;CRLF, 0) == BSTR_OK,
89 &amp;quot;Fai to replace NL.&amp;quot;); 
90 
91 if (is_socket){ 
92 rc = send(fd, bdata(data), blength(data), 0); 
93 } else {
94 rc = write(fd, bdata(data), blength(data));
95 }
96 
97 check(rc == blength(data), &amp;quot;Failed to write everything to fd: %d.&amp;quot;,
98 fd);
99 bdestroy(dat 100 101 return rc; 
102
103 error:
104 return -1;
105 }
106 
107 int main(int argc, char *argv[])
108 {
109 fd_set allreads; 
110 fd_set readmask;
11. 
112 int socket = 0;
113 int rc = 0;
114 RingBuffer *in_rb = RingBuffer_create(102. * 10);
115 RingBuffer *sock_rb = RingBuffer_create(102. * 10);
11. 
117 check(argc == 3, &amp;quot;USAGE: netclient host port&amp;quot;);
11. 
119 socket = client_connect(argv[1] argv[2]);
120 check(socket &amp;gt;= 0, &amp;quot;connect to %s:%s failed.&amp;quot;, argv[1], argv[2]);
12. 
122 FD_ZERO(&amp;amp;all 
123 FD_SET(socke &amp;amp;allreads); 
124 FD_SET(0, &amp;amp;allreads); 
12. 
126 while (1) {
127 readmask = allreads; 
128 rc = select(socket + 1. &amp;amp;readmask, NULL, NULL, NULL); 
129 check(rc &amp;gt;= 0, &amp;quot;select failed.&amp;quot;); 
130 
131 if (FD_ISSET(0, &amp;amp;readmask)) {
132 rc = read_some(in_rb, 0, 0); 
133 chec != -1, &amp;quot;Failed to read from stdin.&amp;quot;); 
134 }
135 
136 if (FD_ISSET(socket,&amp;amp;readmask)) { 
137 rc = read_some(sock_rb,socket, 0); 
138 chec != -1, &amp;quot;Failed to read from socket.&amp;quot;); 
139 }
140 
141 while (!RingBuffer_empty(soc {
142 rc = write_some(sock_rb, 1, 0); 
143 chec != -1, &amp;quot;Failed to write to stdout.&amp;quot;); 
144 }
145 
146 while (!RingBuffer_empty(in_ {
147 rc = write_some(in_rb,socket, 1); 
148 chec != -1, &amp;quot;Failed to write to socket.&amp;quot;); 
149 } 
150 }
151 
152 return 0;
153 
154 error: 
155 return -1;
156 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This codeuses select to handle events fromboth stdin (file descriptor0) and socket, which it uses to talk to a server. Thecode uses RingBuffers tostore the data and copyit around. You can considerthe functions read_some and write_some early prototypesforsimilar functions in the RingBuffer library.&lt;/p&gt;

&lt;p&gt;This little bitof codecontains quite a few networking functions that youmay not know. As you comeacross a function that you don&amp;rsquo;tknow, look it up in theman pages and make sureyou understand it. This onelittle filemight inspireyou to then research all of the APIs required towritea little server in C.&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;If youhave everything building, then the quickest way to test the code issee if you can get a specialfile off of &lt;a href=&#34;http://learncodethehardway.org&#34;&gt;http://learncodethehardway.org&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 45.1 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$
$ ./bin/netclientlearncodethehardway.or 80 
GET /ex45.txt HTTP/1.1 Host: learncodethehardway.or 
HTTP/1.1 200 OK 

Date: Fri, 27 Apr 2012 00:41:25 GMT 
Content-Type: text/plain 
Content-Length: 41 
Last-Modified: Fri, 27 Apr 2012 00:42:1. GMT 
ETag: 4f99eb63-2. 
Server: Mongrel2/1.7.5 

Learn C The Hard Way, 


* Exercise 45 works. 
^C 

$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WhatI do here is typein the syntax needed to make the HTTP requestforthe file /ex45.txt, then the Host: header line, and then I pressENTER to get an empty line. I thenget the response, with headers and the content. After that, I just hit CTRL-C to exit.&lt;/p&gt;

&lt;p&gt;How to Break It&lt;/p&gt;

&lt;p&gt;This codecoulddefinitely havebugs, and currently in the draftof this book,I&amp;rsquo;m going to have tokeep working on it. In the meantime,try analyzing the codeIhave here and thrashing itagainst other servers. There&amp;rsquo;s a tool called netcat that&amp;rsquo;s great for setting upthese kinds of servers. Anotherthing to do is use alanguage like Python or Ruby to createa simple junk server that spews outjunk and bad data, randomlycloses connections, and does other nastythings.&lt;/p&gt;

&lt;p&gt;If youfind bugs, report them in thecomments, and I&amp;rsquo;ll fix them up.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• As I mentioned,there are quite a few functions you maynot know, so look them up. Infact,look them all up even if you think you know them.&lt;/p&gt;

&lt;p&gt;• Run this under the debugger andlookfor errors.&lt;/p&gt;

&lt;p&gt;• Go back throughand add various defensive   programmfor(INITIALIZER;TEST; INCREMENTER) {CODE; } ing checksto the functions to improve them.&lt;/p&gt;

&lt;p&gt;• Use the getoptfunction toallowthe user theoption not to translate \n to \r\n. This is only needed on protocols thatrequireit for lineendings, like HTTP. Sometimes you don&amp;rsquo;twant the translation, so give the user theoption.&lt;/p&gt;

&lt;h2 id=&#34;exercise46-ternary-search-tree:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise46. Ternary Search Tree&lt;/h2&gt;

&lt;p&gt;The final data structure that I&amp;rsquo;ll show you iscalled the TSTree, which is similarto the &lt;code&gt;BSTree&lt;/code&gt;, except it has three branches: low, equal, and high. It&amp;rsquo;s primarily used just like &lt;code&gt;BSTree&lt;/code&gt; and &lt;code&gt;Hashmap&lt;/code&gt; tostore key/value data, butit works off of the individualcharacters in the keys. This gives the TSTree someabilities thatneither &lt;code&gt;BSTree&lt;/code&gt; nor &lt;code&gt;Hashmap&lt;/code&gt; has.&lt;/p&gt;

&lt;p&gt;In a TSTree, every keyis a string, andit&amp;rsquo;s insertedby walking through andbuilding atree basedon the equality of the charactersin the string. It starts at the root,looks at the character forthat node, and if it&amp;rsquo;slower,equal to, or higher thanthat, then it goes inthat direction. You can see this in the header file:
tstree.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#ifndef _lcthw_TSTree_h #define _lcthw_TSTree_h 
#include &amp;lt;stdlib.h&amp;gt; 

#include &amp;lt;lcthw/darray.h&amp;gt; 
typedef struct TSTree 
{ 
char splitchar;
struct TSTree *low;
struct TSTree *equal;
struct TSTree *high;
void *value;} TSTree; 
void *TSTree_search(TSTree * root, const char *key, size_t len); 
void *TSTree_search_prefix(* root, const char *key, size_t len); 
typedef void (*TSTree_traverse_cb)(void *value, void *data); 
TSTree *TSTree_insert(TSTree * node, const char *key, size_t len,void *value); 
void TSTree_traverse(TSTree * node,TSTree_traverse_cb cb, void *data); 
void TSTree_destroy(TSTree * root); 
#endif

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The TSTree has the following elements:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;splitchar The characterat this point in the tree.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;low Thebranch that&amp;rsquo;s lower than splitchar.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;equal Thebranch that&amp;rsquo;s equalto splitchar.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;high Thebranch that&amp;rsquo;s higherthan splitchar.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;value The value set for a string at that point with splitchar.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can see that this implementation has the following operations:&lt;/p&gt;

&lt;p&gt;search A typical operation to finda value for this key.&lt;/p&gt;

&lt;p&gt;search_prefix This operation finds the first valuethat has this as a prefixof its key. This is the an operationthat you can&amp;rsquo;teasily doin a &lt;code&gt;BSTree&lt;/code&gt; or &lt;code&gt;Hashmap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;insert This breaks the key down byeach character and inserts them into the tree.&lt;/p&gt;

&lt;p&gt;traverse This walks through the tree, allowing you to collect oranalyze allthe keys and values it contains.&lt;/p&gt;

&lt;p&gt;The only thing missing is aTSTree_delete, and that&amp;rsquo;s because it&amp;rsquo;s ahorribly expensive operation, even more expensivethan BSTree_delete. When I use TSTree structures,I treat themas constantdata thatIplanon traversing many times, and notremoving anything from them. They are very fast for this, butaren&amp;rsquo;t good ifyouneed to insertand deletethings quickly. For that, I use &lt;code&gt;Hashmap&lt;/code&gt;, since it beats both &lt;code&gt;BSTree&lt;/code&gt; and TSTree.&lt;/p&gt;

&lt;p&gt;The implementationfor the TSTree is actually simple, butit mightbehardto follow at first. I&amp;rsquo;ll break it down
after you enterit in:&lt;/p&gt;

&lt;p&gt;tstree.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

1 #include &amp;lt;stdlib.h&amp;gt; 
2 #include &amp;lt;stdio.h&amp;gt; 
3 #include &amp;lt;assert.h&amp;gt; 
4 #include &amp;lt;lcthw/dbg.h&amp;gt; 
5 #include &amp;lt;lcthw/tstree.h&amp;gt; 
6 
7 static inline TSTree *TSTree_insert_base(TS * root, TSTree * node,
8 const char *key, size_t len, 
9 void *value) 
10 {
11 if (node == NULL){
12 node = (TSTree *) calloc(1,sizeof(TSTree)); 
13 
14  if (root 15  ==  NULL) {  root = node;
16 
17  } 
18  node-&amp;gt;splitchar =*key; 
19 } 2. 21 if (*key &amp;lt; node-&amp;gt;splitchar){
22 node­&amp;gt;low = TSTree_insert_base(
23 node-&amp;gt;low, key, len,value); 
24 } else if (*key == node­&amp;gt;splitchar){ 
25 if (len &amp;gt; 1) {
26 node &amp;gt;equal = TSTree_insert_base(
27 node-&amp;gt;equal, key + 1,len -1, value); 
28 } else {
29 asse &amp;gt;value == NULL &amp;amp;&amp;amp; &amp;quot;Duplicate insert into tst.&amp;quot;); 
30 node &amp;gt;value = value;
31 } 
32 } else {
33 node-&amp;gt;high = TSTree_insert_base(
34 node-&amp;gt;high, key, len,value); 
35 } 
36 
37 return node; 
38 } 
39 
40 TSTree *TSTree_insert(TSTree * node, const char *key, size_t len, 
41 void *value) 42 {
43 return TSTree_insert_base(nod node, key, len,value); 
44 } 
45 
46 void *TSTree_search(TSTree * root, const char *key, size_t len) 
47 {48 TSTree *node = root;49 size_t i = 0; 
50 
51 while (i &amp;lt; len &amp;amp;&amp;amp; node){
52 if (key[i]&amp;lt; node­&amp;gt;splitchar){
53 node = node-&amp;gt;low;
54 } else if (key[i] == node­&amp;gt;splitchar){ 
55 i++;56 if (i &amp;lt; len)57 = node-&amp;gt;equal;
58 } else {
59 node = node-&amp;gt;high;
60 } 
61 } 
62 
63 if (node){
64 return node-&amp;gt;value;
65 } else {
66 return NULL;
67 } 
68 } 
69 
70 void *TSTree_search_prefix(* root, const char *key, size_t len) 
71 {
72 if (len == 0)
73 return NULL;
74 
75 TSTree *node = root;76 TSTree *last = NULL;77 size_t i = 0; 
78 
79 while (i &amp;lt; len &amp;amp;&amp;amp; node){
80 if (key[i]&amp;lt; node­&amp;gt;splitchar){ = node-&amp;gt;equal; 
81  node = node-&amp;gt;low; 
82 if (key[i] == &amp;gt;splitchar) { 83 84  } else node-i++;if (i &amp;lt; 85  len) {(node-&amp;gt;value)
86 = node;87 
88 } 
89 } else {
90 node = node-&amp;gt;high; 
91 } 
92 }93 94 node = node ? node : last; 
95 96 // traverse until we find the first value in the equal chain 
97 // this is then the first node with this prefix
98 while (node &amp;amp;&amp;amp; !node-&amp;gt;value){ 
99 node = node-&amp;gt;equal;
100 } 
101
102 return node ? node-&amp;gt;value : NULL;
103 }
104 
105 void TSTree_traverse(TSTree * node, TSTree_traverse_cb cb, void *data)
106 {
107 if (!node)108 return;
109 
110 if (node­&amp;gt;low)
111 TSTree_t &amp;gt;low, cb, data); 
112 
113 if (node­&amp;gt;equal){ 114 TSTree_t &amp;gt;equal, cb, data);
11. }11. 
117 if (node­&amp;gt;high)118 TSTree_t &amp;gt;high, cb, data); 119 120 if (node­&amp;gt;value)121 cb(node­&amp;gt;value, data); 

12. }
12. 124 void TSTree_destroy(TSTree * node) 
125 {126 if (node == NULL) 
127 return;128 129 if (node­&amp;gt;low)130 TSTree_d &amp;gt;low); 131 132 if (node­&amp;gt;equal){ 133 TSTree_d &amp;gt;equal); 
134 }135 136 if (node­&amp;gt;high)137 TSTree_d &amp;gt;high); 138 
139 free(node); 
140 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For TSTree_insert,I&amp;rsquo;m using the same pattern for recursive structures whereI have a small function that calls the real recursive function. I&amp;rsquo;m not doingany additional checkshere, but you should addthe usual defensiveprogramming checks toit. One thing to keep in mind is that it&amp;rsquo;s using aslightly different design that doesn&amp;rsquo;thave aseparate TSTree_create function. However, if you passit a NULL for the node, then it will create itand return the final value.&lt;/p&gt;

&lt;p&gt;That meansI need to break down TSTree_insert_base so thatyou understand the insert operation:&lt;/p&gt;

&lt;p&gt;tstree.c:10-18 As I mentioned, ifgivena NULL,then Ineed to makethis node and assign the *key(current character) toit. This isused tobuild the tree as we insert keys.&lt;/p&gt;

&lt;p&gt;tstree.c:20-21 If the *key islessthan this, thenrecurse, but goto the low branch.&lt;/p&gt;

&lt;p&gt;tstree.c:22 This splitchar is equal, so I want to goand deal with equality. This will happen ifwe just create this node, so we&amp;rsquo;ll be building the tree at this point.&lt;/p&gt;

&lt;p&gt;tstree.c:23-24 there are stillcharacters to handle,sorecurse down the equal branch, but go to the next *key character.&lt;/p&gt;

&lt;p&gt;tstree.c:26-27 This is the last character, so I set the value andthat&amp;rsquo;sit. I have an assert here in case ofa duplicate.&lt;/p&gt;

&lt;p&gt;tstree.c:29-30 The last condition is that this *key isgreater than splitchar, so I need to recurse down the high branch. The key to this data structure is the fact that I&amp;rsquo;monly incrementing thecharacter when a splitchar isequal. For theother twoconditions, I just walk through the tree until I hit an equal character to recurse into next. What this does is make it very fast not to finda key. Ican get a bad key, andsimply walk through a few high and low nodes until I hit adead endbefore I know that this key doesn&amp;rsquo;t exist. I don&amp;rsquo;t needto process every character of the key or every node of the tree. Once you understandthat, thenmove on toanalyzing how TSTree_search works.&lt;/p&gt;

&lt;p&gt;tstree.c:46 I don&amp;rsquo;tneed to processthe tree recursively in the TSTree.I can justuse a while-loop anda node for where I currently am.&lt;/p&gt;

&lt;p&gt;tstree.c:47-48 If the currentcharacter is less than the node splitchar, thengo low.&lt;/p&gt;

&lt;p&gt;tstree.c:49-51 If it&amp;rsquo;s equal, then increment i and go equalas long as it&amp;rsquo;snot thelast character. That&amp;rsquo;swhy the if(i &amp;lt; len) is there,so that I don&amp;rsquo;t go toofar past the final value. tstree.c:52-53 Otherwise, I go high, sincethe character is greater.&lt;/p&gt;

&lt;p&gt;tstree.c:57-61 If I have a node after the loop, then returnits value, otherwisereturn NULL. This isn&amp;rsquo;t toodifficult to understand, andyou cansee that it&amp;rsquo;s almost exactly the same algorithm for the TSTree_search_prefix function.&lt;/p&gt;

&lt;p&gt;The only difference is thatI&amp;rsquo;m nottrying to find an exactmatch, but find the longest prefix I can. To do that, Ikeep track of the last node thatwas equal, and then after the search loop,walk through that node until I find a value.&lt;/p&gt;

&lt;p&gt;Looking at TSTree_search_prefix, you can startto see the secondadvantage a TSTree has over the &lt;code&gt;BSTree&lt;/code&gt; and &lt;code&gt;Hashmap&lt;/code&gt; for findingstrings. Given anykey of X length, you can find anykey in X moves. You canalso find the first prefix in X moves, plus N more depending on how big the matching key is.&lt;/p&gt;

&lt;p&gt;If the biggest keyin the tree is ten characters long, then you can find anyprefixin thatkey in ten moves. More importantly, you can do allof thisby comparingeach character of the key once. Incomparis on, to do the same with a &lt;code&gt;BSTree&lt;/code&gt;,you would have to check theprefixes of each characterin every possible matching node in the &lt;code&gt;BSTree&lt;/code&gt; against the characters in the prefix.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s the same forfinding keys or seeingif a key doesn&amp;rsquo;t exist. You have tocompare each character against most of the
characters in the &lt;code&gt;BSTree&lt;/code&gt; to find or notfind amatch.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;Hashmap&lt;/code&gt; is evenworse for finding prefixes,because you can&amp;rsquo;thash just the prefix. Basically,you can&amp;rsquo;t do this efficientlyin a Hashmapunlessthe data is something you can parse, like aURL. Even then,that usually requires whole trees of Hashmaps.&lt;/p&gt;

&lt;p&gt;The last twofunctions should be easy for you to analyze since they&amp;rsquo;re the typical traversing and destroying operations that you&amp;rsquo;ve already seen In other data structures. Finally,Ihave a simple unit test for thewholething to makesure itworksright:&lt;/p&gt;

&lt;p&gt;tstree_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;

1 #include &amp;quot;minunit.h&amp;quot; 
2 #include &amp;lt;lcthw/tstree.h&amp;gt; 
3 #include &amp;lt;string.h&amp;gt; 
4 #include &amp;lt;assert.h&amp;gt; 
5 #include &amp;lt;lcthw/bstrlib.h&amp;gt; 
6 
7 TSTree *node = NULL;
8 char *valueA = &amp;quot;VALUEA&amp;quot;;
9 char *valueB = &amp;quot;VALUEB&amp;quot;; 
10 char *value2 = &amp;quot;VALUE2&amp;quot;;
11 char *value4 = &amp;quot;VALUE4&amp;quot;;
12 char *reverse = &amp;quot;VALUER&amp;quot;;
13 int traverse_count = 0;
1. 15 struct tagbstring test1 = bsStatic(&amp;quot;TEST&amp;quot;); 
16 struct tagbstring test2 = bsStatic(&amp;quot;TEST2&amp;quot;); 
17 struct tagbstring test3 = bsStatic(&amp;quot;TSET&amp;quot;); 
18 struct tagbstring test4 = bsStatic(&amp;quot;T&amp;quot;); 
1. 
20 char *test_insert() 
21 {
22 node = TSTree_insert(node,bdata(&amp;amp;test1), blength(&amp;amp;test1), valueA); 
23 mu_assert(no != NULL, &amp;quot;Failed to insert into tst.&amp;quot;); 
24 25 node = 
TSTree_insert(node,bdata(&amp;amp;test2), blength(&amp;amp;test2), value2); 
26 mu_assert(no != NULL,
27 &amp;quot;Fai to insert into tst with second name.&amp;quot;); 
2. 29 node = TSTree_insert(node,bdata(&amp;amp;test3), blength(&amp;amp;test3), reverse); 
30 mu_assert(no != NULL,
31 &amp;quot;Fai to insert into tst with reverse name.&amp;quot;); 
32 
33 node = TSTree_insert(node,bdata(&amp;amp;test4), blength(&amp;amp;test4), value4); 
34 mu_assert(no != NULL,
35 &amp;quot;Fai to insert into tst with second name.&amp;quot;); 
36
37 return NULL;
38 }
39 
40 char *test_search_exact()
41 {
42 // tst 
returns the last one inserted 
43 void *res = TSTree_search(node,bdata(&amp;amp;test1), blength(&amp;amp;test1)); 
44 mu_assert(re == valueA, 
45 &amp;quot;Got the wrong value back, should get A not B.&amp;quot;);
46 
47 // tst does not find if not exact 
48 res = TSTree_search(node,&amp;quot;TESTNO&amp;quot;,strlen(&amp;quot;TESTNO&amp;quot;)); 
49 mu_assert(re == NULL, &amp;quot;Should not find anything.&amp;quot;); 
50 
51 return 
NULL;
52 }
53 
54 char *test_search_prefix()
55 {
56 void *res = TSTree_search_prefix(
57 node bdata(&amp;amp;test1), blength(&amp;amp;test1)); 
58 debug(&amp;quot;resul %p, expected: %p&amp;quot;, res, valueA); 
59 mu_assert(re == valueA, &amp;quot;Got wrong valueA by prefix.&amp;quot;); 
60 61 res = 
TSTree_search_prefix(n bdata(&amp;amp;test1), 1); 
62 debug(&amp;quot;resul %p, expected: %p&amp;quot;, res, valueA); 
63 mu_assert(re == value4, &amp;quot;Got wrong value4 for prefix of 1.&amp;quot;);
64 
65 res = TSTree_search_prefix(n &amp;quot;TE&amp;quot;, strlen(&amp;quot;TE&amp;quot;)); 
66 mu_assert(re != NULL, &amp;quot;Should find 
for short prefix.&amp;quot;); 
67 
68 res = TSTree_search_prefix(n &amp;quot;TE--&amp;quot;, strlen(&amp;quot;TE-­&amp;quot;));
69 mu_assert(re != NULL, &amp;quot;Should find for partialprefix.&amp;quot;); 
70  
71  return NULL;
72 
73  } 
74  void TSTree_traverse_test_c *value, void *data)
75 {
76 assert(value != NULL &amp;amp;&amp;amp; &amp;quot;Should not get NULL value.&amp;quot;); 
77 assert(data == valueA &amp;amp;&amp;amp; &amp;quot;Expecting valueA as the data.&amp;quot;); 
78 traverse_cou 
79 }
80 
81 char *test_traverse() 82 {83 traverse_cou = 0;
84 TSTree_trave TSTree_traverse_test_c valueA); 
85 debug(&amp;quot;trave count is: %d&amp;quot;, traverse_count); 
86 mu_assert(tr == 4, &amp;quot;Didn&#39;t find 4 keys.&amp;quot;); 
87 
88 return NULL;
89 }
90 
91 char *test_destroy() 92 {93 TSTree_destr 94 95 return NULL;
96 }
97 
98 char *all_tests()
99 {100 mu_suite_sta 
101 
102 mu_run_test(
103 mu_run_test( 
104 
105 
106 
107 
108 NULL;
109 
110 
111 mu_run_test(mu_run_test(mu_run_test( 
return 
} 



RUN_TESTS(all_te 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Advantages and Disadvantages&lt;/p&gt;

&lt;p&gt;There areother interesting, practicalthingsyou cando with a TSTree:&lt;/p&gt;

&lt;p&gt;• In addition to finding prefixes, you can reverse all of the keys you insert, and thenfind things by suffix. I use this tolook up host names, sinceIwant to find *.learncodethehardway.com. If I go backward, Icanmatch them quickly.&lt;/p&gt;

&lt;p&gt;• You can do approximate matching, by gatheringall of the nodesthat have mostof the samecharacters as the key, or using other algorithmsto find a close match.&lt;/p&gt;

&lt;p&gt;• You can findallof the keys that have a part in the middle. I&amp;rsquo;ve already talked about some of the things TSTrees can do, but they aren&amp;rsquo;t the best data structureallthe time. Here are the disadvantages of the TSTree:&lt;/p&gt;

&lt;p&gt;• As I mentioned, deleting from them is murder. They are better used for data thatneeds to be looked up fastand rarely removed. If you need todelete, then simply disable the value and then periodicallyrebuildthe tree when it getstoo big.&lt;/p&gt;

&lt;p&gt;• It usesa ton of memory compared to &lt;code&gt;BSTree&lt;/code&gt; and Hashmaps for the same keyspace. Think about it. It&amp;rsquo;s using a full node for each character in every key. It might work betterforsmaller keys, butif you put alot in a TSTree, it will get huge.&lt;/p&gt;

&lt;p&gt;• Theyalsodon&amp;rsquo;twork wellwithlarge keys, butlargeis subjective. As usual, test itfirst. If you&amp;rsquo;re trying to store 10,000-character keys, then use a &lt;code&gt;Hashmap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;How to Improve It&lt;/p&gt;

&lt;p&gt;As usual, got hrough and improve thisby adding the defensiveprogramming preconditions, asserts, and checks toeach function. There aresome otherpossible improvements, but you don&amp;rsquo;t necessarily have to implementallof these:&lt;/p&gt;

&lt;p&gt;• You could allow duplicatesby using a &lt;code&gt;DArray&lt;/code&gt; instead of the value.&lt;/p&gt;

&lt;p&gt;• As I mentioned earlier, deletingis hard, but you could simulateit by setting thevalues to NULL so that they are effectively gone.&lt;/p&gt;

&lt;p&gt;• there are no waysto collect all of the possible matching values. I&amp;rsquo;ll have you implement that in an Extra Credit  Exercise.&lt;/p&gt;

&lt;p&gt;• there are other algorithmsthat are more complex buthave slightlybetter properties. Take a look at suffixarray, suffix tree, and radix tree structures.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Implement a TSTree_collect thatreturns a DArraycontaining allof the keys that match the given prefix.&lt;/p&gt;

&lt;p&gt;• Implement TSTree_search_suf and a TSTree_insert_suf so you can do suffix searches and inserts.&lt;/p&gt;

&lt;p&gt;• Use thedebugger to see how this structure stores data compared to the &lt;code&gt;BSTree&lt;/code&gt; and &lt;code&gt;Hashmap&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;exercise47-a-fast-url-router:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise47. A Fast URL Router&lt;/h2&gt;

&lt;p&gt;Im nowgoing toshow you how I use the TSTree to do fast URL routingin Web servers thatI&amp;rsquo;vewritten. This works for simpleURL routing that youmightuse at the edge of anapplication, butit doesn&amp;rsquo;treallywork for the morecomplex (and sometimesunnecessary) routing found in manyWeb application frameworks.&lt;/p&gt;

&lt;p&gt;To playwithrouting,I&amp;rsquo;m going to make a little command line tool thatI&amp;rsquo;m calling urlor, which readsa simple file ofroutes, and then prompts theuser to enter in URLs.&lt;/p&gt;

&lt;p&gt;urlor.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
1 #include &amp;lt;lcthw/tstree.h&amp;gt;
2 #include &amp;lt;lcthw/bstrlib.h&amp;gt; 
3 4 TSTree *add_route_data(TSTree * routes, bstring line)
5 {6 struct bstrList *data = bsplit(line, &#39;&#39;); 
7 check(data­&amp;gt;qty == 2, &amp;quot;Line &#39;%s&#39; does not have 2 columns&amp;quot;,
8 bdat 
9 
10 routes = TSTree_insert(routes,
11 bda &amp;gt;entry[0]), 
12 ble &amp;gt;entry[0]), 
13 bst &amp;gt;entry[1])); 
14 15 bstrListDes 16 17 return 
routes;
18  
19  error:  
20  return  
NULL;21 22  }  
23  TSTree *load_routes(const char *file) 
24 {
25 TSTree *routes = NULL; 
26 bstring line = NULL;
27 FILE *routes_map = NULL;
2. 29 routes_map = fopen(file, &amp;quot;r&amp;quot;); 
30 check(route != NULL, &amp;quot;Failed to open routes: %s&amp;quot;,file); 
31 
32 while ((line = bgets((bNgetc) fgetc, routes_map, &#39;\n&#39;)) != NULL){ 
33 check(b == BSTR_OK, &amp;quot;Failed to trim line.&amp;quot;); 
34 routes = add_route_data(routes,line);
35 check(r != NULL, &amp;quot;Failed to add route.&amp;quot;); 
36 bdestro 
37 }38 
39 fclose(rout 40 return routes; 
41
42 error: 
43 if (routes_map)fclose(routes_map); 
44 if (line)bdestroy(line); 
45 
46 return NULL;
47 }
48 
49 bstring match_url(TSTree * routes, bstring url)50 {
51 bstring route = TSTree_search(routes,bdata(url), blength(url)); 
52 
53 if (route == NULL){
54 printf(exact match found,trying prefix.\n&amp;quot;); 
55 route = TSTree_search_prefix(r bdata(url), blength(url)); 60 
56 57  }  
58  return route;59  } 
61 bstringread_line(const char *prompt)
62 {
63 printf(&amp;quot;%s&amp;quot; prompt); 
64 
65 bstring result = bgets((bNgetc) fgetc, stdin, &#39;\n&#39;); 
66 check_debug!= NULL, &amp;quot;stdin closed.&amp;quot;); 
67 
68 check(btrim == BSTR_OK, &amp;quot;Failed to trim.&amp;quot;); 
69 
70 return result;
71. 72  error:  
73  return NULL;74  } 
75 
76 void bdestroy_cb(void *value, void *ignored) 
77 {
78 (void)ignor 
79 bdestroy((b value); 
80 }
81 
82 void destroy_routes(TSTree * routes)83 {84 TSTree_trav bdestroy_cb, NULL); 85 TSTree_dest 
86 } 
87
88 int main(int argc, char *argv[])
89 {
90 bstring url = NULL;
91 bstring route = NULL;
92 TSTree *routes = NULL;
93 
94 check(argc == 2, &amp;quot;USAGE: urlor &amp;lt;urlfile&amp;gt;&amp;quot;); 
95 96 routes = load_routes(argv[1]); 97 check(route != NULL, &amp;quot;Your route file has an error.&amp;quot;);
98 
99 while (1){
100 url = read_line(&amp;quot;URL&amp;gt; &amp;quot;); 101 check_d != NULL, &amp;quot;goodbye.&amp;quot;); 102 103 route = match_url(routes, url); 
104 
105 if (route){
106 pri %s == %s\n&amp;quot;, bdata(url), bdata(route)); 
107 } else {
108 pri %s\n&amp;quot;, bdata(url)); 
109 }110 111 bdestro 
11. } 
11. 114 destroy_rou
115 return 0;
11. 117 error: 
118 destroy_rou 
119 return 1;

120 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ll then make a simplefile with somefake routes toplay with:&lt;/p&gt;

&lt;p&gt;/ MainApp
/hello Hello /hello/ Hello /signup Signup /logout Logout /album/ Album&lt;/p&gt;

&lt;p&gt;What You Should See&lt;/p&gt;

&lt;p&gt;Once you have urlor working, anda routes file, you can try it outhere:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exercise 47 Session&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
$ ./bin/urlor
urls.txt 

URL&amp;gt; / 
MATCH: / == MainApp 
URL&amp;gt; /hello 
MATCH: /hello == 
Hello 
URL&amp;gt; /hello/zed 
No exact match found, 
trying prefix. 
MATCH: /hello/zed == 
Hello 

URL&amp;gt; /album 
No exact match found, 
trying prefix. 
MATCH: /album == 
Album 
URL&amp;gt; /album/12345 
No exact match found, 
trying prefix. 
MATCH: /album/12345 
== Album 
URL&amp;gt; asdfasfdasfd 
No exact match found, 
trying prefix. 
FAIL: asdfasfdasfd 
URL&amp;gt; /asdfasdfasf 
No exact match found, 
trying prefix. 

MATCH: /asdfasdfasf == MainApp URL&amp;gt; 
$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that the routing systemfirst triesanexact match, and ifit can&amp;rsquo;tfind one, it will give aprefix match. This ismostly done to try out the difference between the two. Depending on the semantics ofyour URLs,you maywant to alwaysmatch exactly,always toprefixes, or
do bothand pick the bestone.&lt;/p&gt;

&lt;p&gt;How to Improve It&lt;/p&gt;

&lt;p&gt;URLs are weird because people want them to magically handle all of the insanethings their Web applications do, even if that&amp;rsquo;s notverylogical. In this simple demonstrationof how to use the TSTree to do routing, there are someflaws thatpeoplewouldn&amp;rsquo;tbeable to articulate. For example, the TSTree will match /al to Album,which generally isn&amp;rsquo;t what they want. They want /album/* tomatch Album, and /al tobe a404 error.&lt;/p&gt;

&lt;p&gt;This isn&amp;rsquo;t difficult to implement, though, since you could change the prefix algorithm to match anyway you want. If you change the matching algorithm to find all matching prefixes, and then pickthe best one,you&amp;rsquo;llbe able todo iteasily. In this case, /al could match MainApp or Album.Take thoseresults, andthen do a little logic to determinewhich is better.&lt;/p&gt;

&lt;p&gt;Another thing you can do in a realrouting system is use the TSTree to findall possible matches, but thesematches are a smallsetof patternsto check. In many Web applications, there&amp;rsquo;s a list of regularexpressions(regex) that has to be matched against URLs on eachrequest. Running all of the regex can be time consuming, so you can use a TSTree to findall of the possible matches by their prefixes. Thatway you narrow down thepatterns to try to a fewveryquickly.&lt;/p&gt;

&lt;p&gt;Using thismethod, your URLs willmatchexactly since you&amp;rsquo;re actually running realregex patterns, and they&amp;rsquo;llmatchmuch faster since you&amp;rsquo;re finding them by possible prefixes.&lt;/p&gt;

&lt;p&gt;This kind ofalgorithmalso works for anythingelse that needs tohave flexible user-visible routing mechanisms: domainnames, IP addresses, registriesand directories, files, or URLs.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;• Instead of just storing the string for the handler, create an actual engine thatusesa Handler struct to storethe application. The structurewould storethe URL to which it&amp;rsquo;sattached, thename, and anythingelseyou&amp;rsquo;d need to make an actual routing system.&lt;/p&gt;

&lt;p&gt;• Instead of mapping URLs to arbitrary names, map them to .so files and use the dlopen system to load handlers on the fly and call callbacks they contain. Put these callbacks in your Handler struct, and thenyouhave yourself a fully dynamic callback handlersystem in C.&lt;/p&gt;

&lt;h2 id=&#34;exercise48-a-simple-network-server:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise48. A Simple Network Server&lt;/h2&gt;

&lt;p&gt;We now start the part of the book where you doa long-running, more involved projectin aseries of exercises. The last five exerciseswillpresent the problem of creating a simple network server in a similar fashionas you didwith the logfind project. I&amp;rsquo;ll describe each phaseof the project, you&amp;rsquo;ll attemptit, and thenyou&amp;rsquo;llcompare your implementation to mine beforecontinuing.&lt;/p&gt;

&lt;p&gt;These descriptions are purposefully vague so that you have the freedom to attemptto solvethe problems on your own, but I&amp;rsquo;mstill going to helpyou. Included with each of these exercises are two videos.&lt;/p&gt;

&lt;p&gt;The first video shows youhowthe projectforthe exercise should work, so you can see it in action and try to emulate it. The second videoshows you how I solved theproblem, so you can compare your attemptto mine. Finally, you&amp;rsquo;ll have access to allof the code in theGitHub project, so you can see real
codeby me.&lt;/p&gt;

&lt;p&gt;You should attempt the problem first, then after you get itworking (or ifyou get totallystuck), go watchthe second video and take a look at mycode. When you&amp;rsquo;re done,you caneitherkeep using your code,or justuse mine for thenext exercise.&lt;/p&gt;

&lt;p&gt;The Specification&lt;/p&gt;

&lt;p&gt;In this first small program you&amp;rsquo;ll lay the firstfoundation for the remaining projects. You&amp;rsquo;ll call this program statserve, eventhough this specification doesn&amp;rsquo;t mention statisticsor anything. That will comelater.&lt;/p&gt;

&lt;p&gt;The specification for this projectis very simple:
1. Create asimple network server that accepts a connection on port 7899 from netclient or the nc command, and that echoes back anything you type.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You&amp;rsquo;ll needto learn how to bind a port, listenon thesocket, and answer it. Useyour research skillsto study how this is done and attemptto implementit yourself.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The more important partof this projectis laying out the project directory from the c-skeleton, and makingsure you can build everything andget it working.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Don&amp;rsquo;t worry about things like daemons or anything else. Your server just has to run fromthe command line and keep running.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The importantchallenge for this project is figuringout how to createa socket server, buteverything you&amp;rsquo;ve learned so farmakes this possible. Watchthe first lecture video where I teachyou about this if you findthat it&amp;rsquo;s toohardto figure outon your own.&lt;/p&gt;

&lt;h2 id=&#34;exercise49-a-statistics-server:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise49. A Statistics Server&lt;/h2&gt;

&lt;p&gt;The nextphase ofyour projectis toimplement the very first featureof the statserve server. Your programfrom Exercise 48
should beworking and not crashing. Remember to think defensively andattempt to break and destroy your projectas best you can before continuing. Watch both Exercise48 videos to see how I do this.&lt;/p&gt;

&lt;p&gt;The purpose of statserve is for clientsto connect toit and submit commands for modifying statistics. If you remember, we learneda little bitaboutdoing incremental basic statistics, and you know how to use data structures likehash maps, dynamic arrays,binary search trees, and ternary searchtrees. Theseare going to be used in statserve toimplement this next feature.&lt;/p&gt;

&lt;p&gt;Specification&lt;/p&gt;

&lt;p&gt;You have toimplement a protocol that your network client can use to store statistics. If you remember from Exercise 43, you have three simple operations you can doto in the stats.h API:&lt;/p&gt;

&lt;p&gt;create Create a new statistic. mean Get thecurrent meanof a statistic.&lt;/p&gt;

&lt;p&gt;sample Add anew sample to a statistic.&lt;/p&gt;

&lt;p&gt;dump Get all of the elements ofa statistic (sum,sumsq, n, min, and max).&lt;/p&gt;

&lt;p&gt;This will makethe beginning ofyour protocol, butyou&amp;rsquo;ll need to do some more things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You&amp;rsquo;ll needto allow people to name these statistics, which means using oneof the map style data structuresto mapnames to Stats structs.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You&amp;rsquo;ll needto addthe CRUD standard operations for each name. CRUD standsfor create read update delete. Currently,the list of commands above has create, mean, and dump forreading;and sample for updating. You need a delete command now.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You may also needto have a list command for listing out allof the available statistics in the server.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given thatyour statserve should handlea protocolthat allows the above operations, let&amp;rsquo;screate statistics,update their sample,delete them, dumpthem, get the mean, and finally, list them. Do your best to designa simple (and I mean simple) protocol for this using plain text, and see what you come up with. Dothis onpaper first,thenwatch thelecture video for this exerciseto find outhow to design aprotocol and get more information about the exercise.&lt;/p&gt;

&lt;p&gt;I also recommend using unit tests to test that the protocol is parsing separately fromthe server. Create separate .c and .h files for just processing strings with protocolin them, and then test those until you get them right. Thiswill makethings much easier when you add thisfeature to your server.&lt;/p&gt;

&lt;h2 id=&#34;exercise50-routing-the-statistics:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise50. Routing the Statistics&lt;/h2&gt;

&lt;p&gt;Once you&amp;rsquo;ve solved the problem of the protocoland putting statisticsintoa data structure,you&amp;rsquo;llwant to make this muchricher. This exercisemayrequire that you redesignand refactor some of your code. That&amp;rsquo;s onpurpose, asthis is an absolute requirement when writing software. You must frequently throw out old code to make roomfor new code. Never get too attached to something you&amp;rsquo;ve written.&lt;/p&gt;

&lt;p&gt;In this exercise,you&amp;rsquo;regoing to use theURLrouting from Exercise47 to augment your protocol, allowing statistics to be stored at arbitrary URL
paths. This is all the help you get. It&amp;rsquo;s asimplerequirement that you have toattempt onyour own,modifying your protocol, updating yourdata
structures, and changing your codeto makeit work.&lt;/p&gt;

&lt;p&gt;Watchthe lecture video tosee whatI want, and then try your best before watching the second video to see howI implemented it.&lt;/p&gt;

&lt;h2 id=&#34;exercise51-storing-the-statistics:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise51. Storing the Statistics&lt;/h2&gt;

&lt;p&gt;The next problem to solve is how to store the statistics. There is an advantage to having the statisticsin memory, because it&amp;rsquo;s much faster thanstoring them. In fact, there are large data storage systems thatdo this very thing, but in our case, we want asmaller server that can store some of the data to ahard drive.&lt;/p&gt;

&lt;p&gt;The Specification&lt;/p&gt;

&lt;p&gt;For this exercise, you&amp;rsquo;ll add twocommands for storing to and loading statistics from a hard drive:
store If there&amp;rsquo;sa URL, storeit to a hard drive.
load If there are two URLs,load thestatistic fromthe hard drive based on the first URL, and then put it into the secondURLthat&amp;rsquo;sin memory.&lt;/p&gt;

&lt;p&gt;This mayseem simple, but you&amp;rsquo;ll have a few battles when implementing this feature:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;If URLs have /characters in them, then that conflicts with the filesystem&amp;rsquo;s use of slashes. HowHwill you solvethis?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If URLs have /characters in them, then someone canuseyour server to overwritefiles on a hard drive by giving paths to them. How will yousolve this?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you chooseto use deeply nested directories, then traversing directories to find files willbevery slow. What will you do here?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you chooseto use one directory and hash URLs (oops, I gave a hint), then directories with toomany files in them are slow. How will yousolve this?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What happens when someone loads a statisticfrom a hard drive into a URL that already exists?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How will someone running statserve know where thestorage should be?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;An alternative to using a file system to store the datais using something like SQLite and SQL. Another optionis to use a system like GNU dbm (GDBM) to store them in a simpler database.&lt;/p&gt;

&lt;p&gt;Research all of your options and watch the lecture video, and then pick the simplest optionand try it. Take your time figuringout this feature because thenextexercise will involvefiguringout how to destroyyour server.&lt;/p&gt;

&lt;h2 id=&#34;exercise52-hacking-and-improving-your-server:7f99ef8ea0665a9b365d77d7567142c0&#34;&gt;Exercise52. Hacking and Improving Your Server&lt;/h2&gt;

&lt;p&gt;The final exerciseconsists of three videos. Thefirstvideo is alectureon how to hack your server and attemptto destroyit. In the video, I show you a great many tools and tricks forbreaking protocols, using my own implementation to demonstrateflaws in the design.&lt;/p&gt;

&lt;p&gt;This video isfun, and if you&amp;rsquo;ve beenfollowing along with yourown code, you can compete with me to see who made themore robustserver.&lt;/p&gt;

&lt;p&gt;The second videothen demonstrates how I&amp;rsquo;d add improvements to the server. You should attempt your own improvements first, before watching this video, andthen seeif your improvements are similarto mine.&lt;/p&gt;

&lt;p&gt;The third and final video teaches you how to make further improvementsand design decisions in the project. Itcoverseverything I&amp;rsquo;d think aboutto complete the project and refineit.
Typically, to complete a project, I&amp;rsquo;d do the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Getit online and accessible to people.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Documentitand improve theusability to makesure that the documents are easy to read.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Do as much test coverage as possible.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Improve any corner cases and add defenses against any attacks that I can find. The second video demonstrates each of these and explainshow you cando them yourself.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;NextSteps&lt;/p&gt;

&lt;p&gt;This book is most likely a monumental undertaking for abeginnerprogrammer, or even a programmer with no experiencewithmany of the topics covered inside. You havesuccessfully learned an introductory amount of knowledge of C, testing, securecoding,algorithms, data structures, unit testing, and generalapplied problem solving. Congratulations. You should bea much better programmernow.&lt;/p&gt;

&lt;p&gt;I recommend thatyou now go reado ther books on the C programming language. You can&amp;rsquo;t go wrong with The C Programming Language (Prentice Hall 1988)by Brian W. Kernighan andDennis M. Ritchie,the creators of the C language. Mybook teaches you an initial, practical version of C that gets the job done, mostly as a means of teaching you other topics. Their book will teach you deeper C as defined by the creators and the C standard.&lt;/p&gt;

&lt;p&gt;If you want tocontinue improving as aprogrammer, I recommendthat you learn at least fourprogramming languages. If you already knew one language, and now you know C,then I recommendyou try learning any of these programming languages as your next ones:&lt;/p&gt;

&lt;p&gt;• Python, with my book Learn Python The Hard Way, Third Edition (Addison-Wesley, 2014)&lt;/p&gt;

&lt;p&gt;• Ruby, with mybook Learn Ruby The Hard Way, Third Edition (Addison-Wesley, 2015)&lt;/p&gt;

&lt;p&gt;• Go, with itslist of documentation at &lt;a href=&#34;http://golang.org/doc&#34;&gt;http://golang.org/doc&lt;/a&gt;, anotherlanguage by the authors of the C language, andfrankly,a much better one&lt;/p&gt;

&lt;p&gt;• Lua, which is a very fun language that has a decent API for C that you might enjoy now&lt;/p&gt;

&lt;p&gt;• JavaScript, although I&amp;rsquo;m not sure which book is best for this language&lt;/p&gt;

&lt;p&gt;There are manyprogramming languages available, so choosewhichever language interests you andlearn it. I recommendthis becausethe easiest way to become adept at programming andbuild confidence is to strengthen your ability to learn multiple languages. Fourlanguages seems to bethe breaking point where a beginner transitions tobeinga capable programmer. It&amp;rsquo;s alsojust a lotof fun.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LCTHW C Lectures 1</title>
      <link>https://harryho.github.io/code/lcthw-lectures.1/</link>
      <pubDate>Sun, 10 Apr 2016 14:59:31 +1100</pubDate>
      
      <guid>https://harryho.github.io/code/lcthw-lectures.1/</guid>
      <description>

&lt;p&gt;Author: Zed A. Shaw&lt;/p&gt;

&lt;p&gt;All content comes from Zed&amp;rsquo;s &lt;a href=&#34;https://github.com/zedshaw/learn-c-the-hard-way-lectures.git&#34;&gt;Lecture Repository&lt;/a&gt; and &lt;a href=&#34;https://github.com/zedshaw/liblcthw&#34;&gt;Libraries Repository&lt;/a&gt;.  All credit goes to Zed.&lt;/p&gt;

&lt;h2 id=&#34;exercise-0-installing-software:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 0 Installing Software&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Install software on your system.&lt;/li&gt;
&lt;li&gt;Test that it works right.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linux Install&lt;/p&gt;

&lt;p&gt;On Debian/Ubuntu use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install build-essential
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On RedHat/CentOS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo yum groupinstall development-tools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux Testing&lt;/p&gt;

&lt;p&gt;Test that your C compiler works with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cc --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OSX Install&lt;/p&gt;

&lt;p&gt;Install &lt;a href=&#34;https://developer.apple.com/xcode/&#34;&gt;XCode&lt;/a&gt;, this will take a while.&lt;/p&gt;

&lt;p&gt;OSX Testing&lt;/p&gt;

&lt;p&gt;Test that your C compiler works with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cc --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows Install&lt;/p&gt;

&lt;p&gt;Install &lt;a href=&#34;http://www.mingw.org/&#34;&gt;MinGW&lt;/a&gt; or &lt;a href=&#34;https://www.cygwin.com/&#34;&gt;Cygwin&lt;/a&gt; or Use &lt;a href=&#34;https://www.virtualbox.org/wiki/Downloads&#34;&gt;VirtualBox&lt;/a&gt; to run Linux.&lt;/p&gt;

&lt;p&gt;Text Editors&lt;/p&gt;

&lt;p&gt;You should already have one.
Just don&amp;rsquo;t use an IDE. They aren&amp;rsquo;t very helpful.&lt;/p&gt;

&lt;p&gt;End of Lecture 0&lt;/p&gt;

&lt;h2 id=&#34;exercise-1-dust-off-that-compiler:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 1 Dust Off That Compiler&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Write your first C program.&lt;/li&gt;
&lt;li&gt;Build it.&lt;/li&gt;
&lt;li&gt;Break it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex01\ex1.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

/* This is a comment. */
int main(int argc, char *argv[])
{
    int distance = 100;

    // this is also a comment
    printf(&amp;quot;You are %d miles away.\n&amp;quot;, distance);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex01\ex1_zed.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

/* This is a comment. */
int main(int argc, char *argv[])
{
    int distance = 100;

    // this is also a comment
    printf(&amp;quot;You are %d miles away.\n&amp;quot;);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at it line-by-line.&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;p&gt;This is all crazy magic right now.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Open the &lt;code&gt;ex1&lt;/code&gt; file in your text editor and change or delete random parts.
Try running it and see what happens.&lt;/li&gt;
&lt;li&gt;Print out five more lines of text or something more complex than &amp;ldquo;hello world.&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;man 3 printf&lt;/code&gt; and read about this function and many others.&lt;/li&gt;
&lt;li&gt;For each line, write out the symbols you don&amp;rsquo;t understand and
see if you can guess what they mean.  Write a little chart on
paper with your guess so you can check it later to see
if you got it right.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-2-using-makefiles-to-build:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 2 Using Makefiles to Build&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start with simple make usage.&lt;/li&gt;
&lt;li&gt;Set a few important settings.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How Make Works&lt;/p&gt;

&lt;p&gt;Implied dependencies and ancient lore.&lt;/p&gt;

&lt;p&gt;Shell Commands&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make ex1
# or this one too
$ CFLAGS=&amp;quot;-Wall&amp;quot; make ex1
$ make clean
$ make ex1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CFLAGS=-Wall -g

clean:
    rm -f ex1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Setting options.&lt;/li&gt;
&lt;li&gt;Indicating dependencies.&lt;/li&gt;
&lt;li&gt;Writing commends to run.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Watch out for tabs vs. spaces.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create an &lt;em&gt;all: ex1&lt;/em&gt; target that will build &lt;em&gt;ex1&lt;/em&gt; with
just the command &lt;em&gt;make&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Read &lt;em&gt;man make&lt;/em&gt; to find out more information on how to run it.&lt;/li&gt;
&lt;li&gt;Read &lt;em&gt;man cc&lt;/em&gt; to find out more information on what the flags &lt;em&gt;-Wall&lt;/em&gt; and &lt;em&gt;-g&lt;/em&gt; do.&lt;/li&gt;
&lt;li&gt;Research &lt;em&gt;Makefiles&lt;/em&gt; online and see if you can improve this one.&lt;/li&gt;
&lt;li&gt;Find a &lt;em&gt;Makefile&lt;/em&gt; in another C project and try to understand
what it&amp;rsquo;s doing.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-3-formatted-printing:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 3 Formatted Printing&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Introduction to &lt;em&gt;printf&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex03\ex3.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char *argv[])
{
    int age = 100;
    int height = 72;

    printf(&amp;quot;I am %d years old.\n&amp;quot;, argv);
    printf(&amp;quot;I am %d inches tall.\n&amp;quot;, height);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Take the &lt;em&gt;age&lt;/em&gt; variable out of the first &lt;em&gt;printf&lt;/em&gt; call, then recompile. You should get a couple of warnings.&lt;/li&gt;
&lt;li&gt;Run this new program and it will either crash or print out a really crazy age.&lt;/li&gt;
&lt;li&gt;Put the &lt;em&gt;printf&lt;/em&gt; back the way it was, and then don&amp;rsquo;t set &lt;em&gt;age&lt;/em&gt; to an initial value by changing that line to &lt;em&gt;int age;&lt;/em&gt;, and then rebuild it and run it again.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Find as many other ways to break &lt;em&gt;ex3.c&lt;/em&gt; as you can.&lt;/li&gt;
&lt;li&gt;Run &lt;em&gt;man 3 printf&lt;/em&gt; and read about the other &lt;em&gt;%&lt;/em&gt; format
characters you can use.  These should look familiar if you used
them in other languages (they come from &lt;em&gt;printf&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;Add &lt;em&gt;ex3&lt;/em&gt; the &lt;em&gt;all&lt;/em&gt; list in your &lt;em&gt;Makefile&lt;/em&gt;.  Use this
to &lt;em&gt;make clean all&lt;/em&gt; and build all of your exercises thus far.&lt;/li&gt;
&lt;li&gt;Add &lt;em&gt;ex3&lt;/em&gt; to your &lt;em&gt;clean&lt;/em&gt; list in your&lt;em&gt;Makefile&lt;/em&gt; as well.
Use &lt;em&gt;make clean&lt;/em&gt; to remove it when you need to.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-4-using-a-debugger:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 4 Using a Debugger&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;See how GDB works (LLDB on OSX).&lt;/li&gt;
&lt;li&gt;Look at memory checkers like Valgrind and AddressSanitizer.&lt;/li&gt;
&lt;li&gt;Cover the quick reference.&lt;/li&gt;
&lt;li&gt;Debug a program.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using GDB&lt;/p&gt;

&lt;p&gt;Using LLDB&lt;/p&gt;

&lt;p&gt;Using Valgrind&lt;/p&gt;

&lt;p&gt;Using Lint&lt;/p&gt;

&lt;p&gt;Using AddressSanitizer&lt;/p&gt;

&lt;p&gt;You neeed clang for this.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;The Debugger&amp;rdquo;&lt;/p&gt;

&lt;p&gt;When I say &amp;ldquo;the debugger&amp;rdquo; in the book I mean to use GDB, but use
every tool you can find that helps.&lt;/p&gt;

&lt;h2 id=&#34;exercise-5-memorizing-c-operators:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 5 Memorizing C Operators&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Learn why memorizing works.&lt;/li&gt;
&lt;li&gt;Learn how to memorize things.&lt;/li&gt;
&lt;li&gt;Review the C operators.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Memorization&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A &amp;ldquo;backdoor&amp;rdquo; hack to learning.&lt;/li&gt;
&lt;li&gt;Memorize the operators, then reading is easier.&lt;/li&gt;
&lt;li&gt;Works with any language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Memorization Proces&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Write everything on index cards.&lt;/li&gt;
&lt;li&gt;Use Anki, but make your own cards.&lt;/li&gt;
&lt;li&gt;Spend 30-60 minutes a day.&lt;/li&gt;
&lt;li&gt;Track what you don&amp;rsquo;t know, drill those more.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Arithmetic Operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+    Add
-    Subtract
*    Multiply
/    Divide
%    Modulus
++   Increment
--   Decrement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Relational Operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==   Equal
!=   Not equal
&amp;gt;    Greater than
&amp;lt;    Less than
&amp;gt;=   Greater than equal
&amp;lt;=   Less than equal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Logical Operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;&amp;amp;   Logical and
||   Logical or
!    Logical not
? :  Logical ternary
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bitwise Operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;    Bitwise and
|    Bitwise or
^    Bitwise xor
~    Bitwise ones compliment
&amp;lt;&amp;lt;   Bitwise shift left
&amp;gt;&amp;gt;   Bitwise shift right
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assignment Operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;=    Assign equal
+=   Assign plus-equal
-=   Assign minus-equal
*=   Assign multiply-equal
/=   Assign divide-equal
%=   Assign modulus-equal
&amp;lt;&amp;lt;=  Assign shift-left-equal
&amp;gt;&amp;gt;=  Assign shift-right-equal
&amp;amp;=   Assign and-equal
^=   Assign xor-equal
|=   Assign or-equal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Data Operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sizeof() Get the size of
[]       Array subscript
&amp;amp;        The address of
*        The value of
-&amp;gt;       Structure dereference
.        Structure reference
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Miscellaneous Operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;,         Comma
( )       Parenthesis
{ }       Braces
:         Colon
//        Single-line comment start
/*        Multi-line comment start
*/        Multi-line comment end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;exercise-6-memorizing-c-syntax:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 6 Memorizing C Syntax&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Memorize the keywords of C.&lt;/li&gt;
&lt;li&gt;Memorize the major syntax forms.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Execution Keywords
    break     Exit out of a compound statement.
    case      A branch in a switch-statement.
    continue  Continue to the top of a loop.
    do        Start a do-while loop.
    default   Default branch in a switch-statement.
    else      An else branch of an if-statement.
    for       Start a for-loop.
    goto      Jump to a label.
    if        Starts an if-statement.
    return    Return from a function.
    switch    Start a switch-statement.
    while     Start a while-loop.&lt;/p&gt;

&lt;p&gt;Type Keywords
    char      Character data type.
    double    A double floating point data type.
    float     A floating point data type.
    int       An integer data type.
    long      A long integer data type.
    short     A short integer data type.
    void      Declare a data type empty.
    union     Start a union-statement.
    struct    Combine variables into a single record.&lt;/p&gt;

&lt;p&gt;Data Keywords&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto      Give a local variable a local lifetime.
const     Make a variable unmodifiable.
enum      Define a set of int constants.
extern    Declare an identifier is defined externally.
register  Declare a variable be stored in a CPU register.
signed    A signed modifier for integer data types.
sizeof    Determine the size of data.
static    Preserve variable value after its scope exits.
typedef   Create a new type.
unsigned  An unsigned modifier for integer data types.
volatile  Declare a variable might be modified elsewhere.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If-Statement&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(TEST) {
    CODE;
} else if(TEST) {
    CODE;
} else {
    CODE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Switch-Statement&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch (OPERAND) {
    case CONSTANT:
        CODE;
        break;
    default:
        CODE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While-Loop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(TEST) {
    CODE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While with Continue&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(TEST) {
    if(OTHER_TEST) {
        continue;
    }
    CODE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While with Break&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(TEST) {
    if(OTHER_TEST) {
        break;
    }
    CODE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do-While&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do {
    CODE;
} while(TEST);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For-Loop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(INIT; TEST; POST) {
    CODE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;continue&lt;/em&gt; and &lt;em&gt;break&lt;/em&gt; work with &lt;em&gt;for&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Enum&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum { CONST1, CONST2, CONST3 } NAME;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Goto&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(ERROR_TEST) {
    goto fail;
}

fail:
    CODE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Functions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TYPE NAME(ARG1, ARG2, ..) {
    CODE;
    return VALUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Typedef&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef DEFINITION IDENTIFIER;

typedef unsigned char byte;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Struct&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct NAME {
    ELEMENTS;
} [VARIABLE_NAME];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Typedef Struct&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct [STRUCT_NAME] {
    ELEMENTS;
} IDENTIFIER;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Union&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;union NAME {
    ELEMENTS;
} [VARIABLE_NAME];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;exercise-7-variables-and-types:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 7 Variables and Types&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Learn some basic variables and types.&lt;/li&gt;
&lt;li&gt;int, float, double, char, and strings.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex07\ex7.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char *argv[])
{
    int distance = 100;
    float power = 2.345f;
    double super_power = 56789.4532;
    char initial = &#39;A&#39;;
    char first_name[] = &amp;quot;Zed&amp;quot;;
    char last_name[] = &amp;quot;Shaw&amp;quot;;

    first_name[3] = &#39;Z&#39;;

    printf(&amp;quot;You are %d miles away.\n&amp;quot;, distance);
    printf(&amp;quot;You have %f levels of power.\n&amp;quot;, power);
    printf(&amp;quot;You have %f awesome super powers.\n&amp;quot;, super_power);
    printf(&amp;quot;I have an initial %c.\n&amp;quot;, initial);
    printf(&amp;quot;I have a first name %s.\n&amp;quot;, first_name);
    printf(&amp;quot;I have a last name %s.\n&amp;quot;, last_name);
    printf(&amp;quot;My whole name is %s %c. %s.\n&amp;quot;,
            first_name, initial, last_name);

    int bugs = 100;
    double bug_rate = 1.2;

    printf(&amp;quot;You have %d bugs at the imaginary rate of %f.\n&amp;quot;,
            bugs, bug_rate);

    long universe_of_defects = 1L * 1024L * 1024L * 1024L;
    printf(&amp;quot;The entire universe has %ld bugs.\n&amp;quot;, universe_of_defects);

    double expected_bugs = bugs * bug_rate;
    printf(&amp;quot;You are expected to have %f bugs.\n&amp;quot;, expected_bugs);

    double part_of_universe = expected_bugs / universe_of_defects;
    printf(&amp;quot;That is only a %e portion of the universe.\n&amp;quot;,
            part_of_universe);

    // this makes no sense, just a demo of something weird
    char nul_byte = &#39;\0&#39;;
    int care_percentage = bugs * nul_byte;
    printf(&amp;quot;Which means you should care %d%%.\n&amp;quot;, care_percentage);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Strings give us so much more fun now!&lt;/li&gt;
&lt;li&gt;Crafting bad strings.&lt;/li&gt;
&lt;li&gt;Messing with pointers.&lt;/li&gt;
&lt;li&gt;Abusing printf.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Make the number you assign to &lt;em&gt;universe_of_defects&lt;/em&gt; various
sizes until you get a warning from the compiler.&lt;/li&gt;
&lt;li&gt;What do these really huge numbers actually print out?&lt;/li&gt;
&lt;li&gt;Change &lt;em&gt;long&lt;/em&gt; to &lt;em&gt;unsigned long&lt;/em&gt; and try to find
the number that makes it too big.&lt;/li&gt;
&lt;li&gt;Go search online to find out what &lt;em&gt;unsigned&lt;/em&gt; does.&lt;/li&gt;
&lt;li&gt;Try to explain to yourself (before I do in the next exercise)
why you can multiply a &lt;em&gt;char&lt;/em&gt; and an &lt;em&gt;int&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-8-if-else-if-else:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 8 If, Else-If, Else&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;p&gt;Simply learn to use this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(TEST) {
    CODE;
} else if(TEST) {
    CODE;
} else {
    CODE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex08\ex8.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char *argv[])
{
    int i = 0;

    if (argc == 1) {
        printf(&amp;quot;You only have one argument. You suck.\n&amp;quot;);
    } else if (argc &amp;gt; 1 &amp;amp;&amp;amp; argc &amp;lt; 4) {
        printf(&amp;quot;Here&#39;s your arguments:\n&amp;quot;);

        for (i = 0; i &amp;lt; argc; i++) {
            printf(&amp;quot;%s &amp;quot;, argv[i]);
        }
        printf(&amp;quot;\n&amp;quot;);
    } else if (argc &amp;gt; 10) {
        printf(&amp;quot;You have too many arguments. You suck.\n&amp;quot;);
    }

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It kind of just works, but remove the &lt;em&gt;else&lt;/em&gt; and change the logic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You were briefly introduced to &lt;em&gt;&amp;amp;&amp;amp;&lt;/em&gt;, which does an &lt;em&gt;and&lt;/em&gt; comparison,
so go research online the different &lt;em&gt;Boolean operators&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Write a few more test cases for this program to see what you can come
up with.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-9-while-loop-and-boolean-expressions:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 9 While-Loop and Boolean Expressions&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;p&gt;You first loop shall be the &lt;em&gt;while&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(TEST) {
    CODE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex09\ex9.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char *argv[])
{
    int i;
    while (i &amp;lt; 25) {
        printf(&amp;quot;%d\n&amp;quot;, i);
        i++;
    }

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Forget to initialize the &lt;em&gt;int i&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Forget to do an i++ and make it run forever.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Make the loop count backward by using &lt;code&gt;i--&lt;/code&gt; to start
at 25 and go to 0.&lt;/li&gt;
&lt;li&gt;Write a few more complex &lt;code&gt;while-loops&lt;/code&gt; using what you know
so far.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-10-switch-statements:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 10 Switch Statements&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Learn about the &lt;em&gt;switch-statement&lt;/em&gt; and indirectly jump tables.&lt;/li&gt;
&lt;li&gt;Write a program that takes a command line argument.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex10\ex10.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char *argv[])
{
    if (argc != 2) {
        printf(&amp;quot;ERROR: You need one argument.\n&amp;quot;);
        // this is how you abort a program
        return 1;
    }

    int i = 0;
    for (i = 0; argv[1][i] != &#39;\0&#39;; i++) {
        char letter = argv[1][i];

        switch (letter) {
            case &#39;a&#39;:
            case &#39;A&#39;:
                printf(&amp;quot;%d: &#39;A&#39;\n&amp;quot;, i);
                break;

            case &#39;e&#39;:
            case &#39;E&#39;:
                printf(&amp;quot;%d: &#39;E&#39;\n&amp;quot;, i);
                break;

            case &#39;i&#39;:
            case &#39;I&#39;:
                printf(&amp;quot;%d: &#39;I&#39;\n&amp;quot;, i);
                break;

            case &#39;o&#39;:
            case &#39;O&#39;:
                printf(&amp;quot;%d: &#39;O&#39;\n&amp;quot;, i);
                break;

            case &#39;u&#39;:
            case &#39;U&#39;:
                printf(&amp;quot;%d: &#39;U&#39;\n&amp;quot;, i);
                break;

            case &#39;y&#39;:
            case &#39;Y&#39;:
                if (i &amp;gt; 2) {
                    // it&#39;s only sometimes Y
                    printf(&amp;quot;%d: &#39;Y&#39;\n&amp;quot;, i);
                }
                break;

            default:
                printf(&amp;quot;%d: %c is not a vowel\n&amp;quot;, i, letter);
        }
    }

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s talk about jump tables, in the naive sense.&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Forget a &lt;em&gt;break&lt;/em&gt;, and it&amp;rsquo;ll run two or more blocks of code you don&amp;rsquo;t want it to run.&lt;/li&gt;
&lt;li&gt;Forget a &lt;em&gt;default&lt;/em&gt;, and it&amp;rsquo;ll silently ignore values you forgot.&lt;/li&gt;
&lt;li&gt;Accidentally put a variable into the &lt;em&gt;switch&lt;/em&gt; that evaluates to something unexpected, like an &lt;em&gt;int&lt;/em&gt;, which becomes weird values.&lt;/li&gt;
&lt;li&gt;Use uninitialized values in the &lt;em&gt;switch&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Write another program that uses math on the letter to
convert it to lowercase, and then remove all of the extraneous
uppercase letters in the switch.&lt;/li&gt;
&lt;li&gt;Use the &lt;em&gt;&amp;rsquo;,&amp;rsquo;&lt;/em&gt; (comma) to initialize &lt;em&gt;letter&lt;/em&gt;
in the &lt;em&gt;for-loop&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Make it handle all of the arguments you pass it with
yet another &lt;em&gt;for-loop&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Convert this &lt;em&gt;switch-statement&lt;/em&gt; to an &lt;em&gt;if-statement&lt;/em&gt;.
Which do you like better?&lt;/li&gt;
&lt;li&gt;In the case for &amp;lsquo;Y&amp;rsquo; I have the break outside of the &lt;em&gt;if-statement&lt;/em&gt;. What&amp;rsquo;s the impact of this,
and what happens if you move it inside of the &lt;em&gt;if-statement&lt;/em&gt;. Prove to yourself that you&amp;rsquo;re right.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-11-arrays-and-strings:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 11 Arrays and Strings&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Learn the similarity between arrays and strings.&lt;/li&gt;
&lt;li&gt;Avoid getting pedantic about them.&lt;/li&gt;
&lt;li&gt;Learn how C stores strings and processes them.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex11\ex11.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char *argv[])
{
    int numbers[4] = { 0 };
    char name[4] = { &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39; };

    // first, print them out raw
    printf(&amp;quot;numbers: %d %d %d %d\n&amp;quot;,
            numbers[0], numbers[1], numbers[2], numbers[3]);

    printf(&amp;quot;name each: %c %c %c %c\n&amp;quot;,
            name[0], name[1], name[2], name[3]);

    printf(&amp;quot;name: %s\n&amp;quot;, name);

    // setup the numbers
    numbers[0] = 1;
    numbers[1] = 2;
    numbers[2] = 3;
    numbers[3] = 4;

    // setup the name
    name[0] = &#39;Z&#39;;
    name[1] = &#39;e&#39;;
    name[2] = &#39;d&#39;;
    name[3] = &#39;A&#39;;

    // then print them out initialized
    printf(&amp;quot;numbers: %d %d %d %d\n&amp;quot;,
            numbers[0], numbers[1], numbers[2], numbers[3]);

    printf(&amp;quot;name each: %c %c %c %c\n&amp;quot;,
            name[0], name[1], name[2], name[3]);

    // print the name like a string
    printf(&amp;quot;name: %s\n&amp;quot;, name);

    // another way to use name
    char *another = &amp;quot;Zed&amp;quot;;

    printf(&amp;quot;another: %s\n&amp;quot;, another);

    printf(&amp;quot;another each: %c %c %c %c\n&amp;quot;,
            another[0], another[1], another[2], another[3]);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;p&gt;So many ways to break this!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Get rid of the initializers that set up &lt;em&gt;name&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Accidentally set &lt;em&gt;name[3] = &amp;lsquo;A&amp;rsquo;;&lt;/em&gt; so that there&amp;rsquo;s no terminator.&lt;/li&gt;
&lt;li&gt;Set the initializer to &lt;em&gt;{&amp;lsquo;a&amp;rsquo;,&amp;lsquo;a&amp;rsquo;,&amp;lsquo;a&amp;rsquo;,&amp;lsquo;a&amp;rsquo;}&lt;/em&gt; so that there are too many
&amp;lsquo;a&amp;rsquo; characters and no space for the &lt;em&gt;&amp;lsquo;\0&amp;rsquo;&lt;/em&gt; terminator.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Assign the characters into &lt;em&gt;numbers&lt;/em&gt;, and then use &lt;em&gt;printf&lt;/em&gt;
to print them one character at a time.  What kind of compiler warnings
do you get?&lt;/li&gt;
&lt;li&gt;Do the inverse for &lt;em&gt;name&lt;/em&gt;, trying to treat it like an array
of &lt;em&gt;int&lt;/em&gt; and print it out one &lt;em&gt;int&lt;/em&gt; at a time.  What
does the debugger think of that?&lt;/li&gt;
&lt;li&gt;In how many other ways can you print this out?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If an array of characters is 4 bytes long, and an integer is 4 bytes
long, then can you treat the whole &lt;em&gt;name&lt;/em&gt; array like it&amp;rsquo;s just
an integer?  How might you accomplish this crazy hack?&lt;/li&gt;
&lt;li&gt;Take out a piece of paper and draw each of these arrays as a
row of boxes. Then do the operations you just did on paper to see
if you get them right.&lt;/li&gt;
&lt;li&gt;Convert &lt;em&gt;name&lt;/em&gt; to be in the style of &lt;em&gt;another&lt;/em&gt; and see
if the code keeps working.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-12-sizes-and-arrays:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 12 Sizes and Arrays&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Learn about &lt;em&gt;sizeof&lt;/em&gt; and how it relates to arrays.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex12\ex12.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char *argv[])
{
    int areas[] = { 10, 12, 13, 14, 20 };
    char name[] = &amp;quot;Zed&amp;quot;;
    char full_name[] = {
        &#39;Z&#39;, &#39;e&#39;, &#39;d&#39;,
        &#39; &#39;, &#39;A&#39;, &#39;.&#39;, &#39; &#39;,
        &#39;S&#39;, &#39;h&#39;, &#39;a&#39;, &#39;w&#39; 
    };

    // WARNING: On some systems you may have to change the
    // %ld in this code to a %u since it will use unsigned ints
    printf(&amp;quot;The size of an int: %ld\n&amp;quot;, sizeof(int));
    printf(&amp;quot;The size of areas (int[]): %ld\n&amp;quot;, sizeof(areas));
    printf(&amp;quot;The number of ints in areas: %ld\n&amp;quot;,
            sizeof(areas) / sizeof(int));
    printf(&amp;quot;The first area is %d, the 2nd %d.\n&amp;quot;, areas[0], areas[1]);

    printf(&amp;quot;The size of a char: %ld\n&amp;quot;, sizeof(char));
    printf(&amp;quot;The size of name (char[]): %ld\n&amp;quot;, sizeof(name));
    printf(&amp;quot;The number of chars: %ld\n&amp;quot;, sizeof(name) / sizeof(char));

    printf(&amp;quot;The size of full_name (char[]): %ld\n&amp;quot;, sizeof(full_name));
    printf(&amp;quot;The number of chars: %ld\n&amp;quot;,
            sizeof(full_name) / sizeof(char));

    full_name[12] = &#39;X&#39;;

    printf(&amp;quot;name=\&amp;quot;%s\&amp;quot; and full_name=\&amp;quot;%s\&amp;quot;\n&amp;quot;, name, full_name);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Get rid of the &lt;em&gt;&amp;lsquo;\0&amp;rsquo;&lt;/em&gt; at the end of &lt;em&gt;full_name&lt;/em&gt;
and re-run it.  Run it under the debugger, too.  Now, move the definition
of &lt;em&gt;full_name&lt;/em&gt; to the top of &lt;em&gt;main&lt;/em&gt; before &lt;em&gt;areas&lt;/em&gt;.
Try running it under the debugger a few times and see if you get some
new errors.  In some cases, you might still get lucky and not catch
any errors.&lt;/li&gt;
&lt;li&gt;Change it so that instead of &lt;em&gt;areas[0]&lt;/em&gt; you try to
print &lt;em&gt;areas[10]&lt;/em&gt;.  See what the debugger thinks of that.&lt;/li&gt;
&lt;li&gt;Try other ways to break it like this, doing it to &lt;em&gt;name&lt;/em&gt; and
&lt;em&gt;full_name&lt;/em&gt; too.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Try assigning to elements in the &lt;em&gt;areas&lt;/em&gt; array with &lt;em&gt;areas[0] = 100;&lt;/em&gt; and similar.&lt;/li&gt;
&lt;li&gt;Try assigning to elements of &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;full_name&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Try setting one element of &lt;em&gt;areas&lt;/em&gt; to a character from &lt;em&gt;name&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Search online for the different sizes used for integers on different
CPUs.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-13-for-loops-and-arrays-of-strings:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 13 For-Loops and Arrays of Strings&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;p&gt;Learn about this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(INITIALIZER; TEST; INCREMENTER) {
    CODE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex13\ex13.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char *argv[])
{
    int i = 0;

    // go through each string in argv
    // why am I skipping argv[0]?
    for (i = 0; i &amp;lt; argc; i++) {
        printf(&amp;quot;arg %d: %s\n&amp;quot;, i, argv[i]);
    }

    // let&#39;s make our own array of strings
    char *states[] = {
        &amp;quot;California&amp;quot;, &amp;quot;Oregon&amp;quot;,
        &amp;quot;Washington&amp;quot;, &amp;quot;Texas&amp;quot;
    };

    int num_states = 5;

    for (i = 0; i &amp;lt; num_states; i++) {
        printf(&amp;quot;state %d: %s\n&amp;quot;, i, states[i]);
    }

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Take your favorite other language and use it to run this program, but include as many command line arguments as possible.  See if you can bust it
by giving it way too many arguments.&lt;/li&gt;
&lt;li&gt;Initialize &lt;em&gt;i&lt;/em&gt; to 0 and see what that does.  Do you have to adjust
&lt;em&gt;argc&lt;/em&gt; as well, or does it just work?  Why does 0-based indexing work
here?&lt;/li&gt;
&lt;li&gt;Set &lt;em&gt;num_states&lt;/em&gt; wrong so that it&amp;rsquo;s a higher value and see what
it does.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Figure out what kind of code you can put into the parts of a &lt;em&gt;for-loop&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Look up how to use the comma character (,) to separate multiple
statements in the parts of the &lt;em&gt;for-loop&lt;/em&gt;, but between the semicolon characters (;).&lt;/li&gt;
&lt;li&gt;Read what a &lt;em&gt;NULL&lt;/em&gt; is and try to use it in one of the elements from the
&lt;em&gt;states&lt;/em&gt; array to see what it&amp;rsquo;ll print.&lt;/li&gt;
&lt;li&gt;See if you can assign an element from the &lt;em&gt;states&lt;/em&gt; array to the
&lt;em&gt;argv&lt;/em&gt; array before printing both.  Try the inverse.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-14-writing-and-using-functions:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 14 Writing and Using Functions&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Write your very first functions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex14\ex14.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;

// forward declarations
int can_print_it(char ch);
void print_letters(char arg[]);

void print_arguments(int argc, char *argv[])
{
    int i = 0;

    for (i = 0; i &amp;lt; argc; i++) {
        print_letters(argv[i]);
    }
}

void print_letters(char arg[])
{
    int i = 0;

    for (i = 0; arg[i] != &#39;\0&#39;; i++) {
        char ch = arg[i];

        if (can_print_it(ch)) {
            printf(&amp;quot;&#39;%c&#39; == %d &amp;quot;, ch, ch);
        }
    }

    printf(&amp;quot;\n&amp;quot;);
}

int can_print_it(char ch)
{
    return isalpha(ch) || isblank(ch);
}

int main(int argc, char *argv[])
{
    print_arguments(argc+1, argv);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Remove the forward declarations to confuse the compiler and cause it to complains about &lt;em&gt;can_print_it&lt;/em&gt; and &lt;em&gt;print_letters&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;When you call &lt;em&gt;print_arguments&lt;/em&gt; inside &lt;em&gt;main&lt;/em&gt;, try
adding 1 to &lt;em&gt;argc&lt;/em&gt; so that it goes past the end of the
&lt;em&gt;argv&lt;/em&gt; array.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rework these functions so that you have fewer functions.  For example,
do you really need &lt;em&gt;can_print_it&lt;/em&gt;?&lt;/li&gt;
&lt;li&gt;Have &lt;em&gt;print_arguments&lt;/em&gt; figure out how long each argument string
is by using the &lt;em&gt;strlen&lt;/em&gt; function, and then pass that length
to &lt;em&gt;print_letters&lt;/em&gt;.  Then, rewrite &lt;em&gt;print_letters&lt;/em&gt;
so it only processes this fixed length and doesn&amp;rsquo;t rely on the
&lt;em&gt;&amp;lsquo;\0&amp;rsquo;&lt;/em&gt; terminator.  You&amp;rsquo;ll need the &lt;em&gt;#include &lt;string.h&gt;&lt;/em&gt; for this.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use &lt;em&gt;man&lt;/em&gt; to look up information on &lt;em&gt;isalpha&lt;/em&gt;
and &lt;em&gt;isblank&lt;/em&gt;.  Use other similar functions to
print out only digits or other characters.&lt;/li&gt;
&lt;li&gt;Go read about how other people like to format their
functions.  Never use the &lt;em&gt;K&amp;amp;R syntax&lt;/em&gt; (it&amp;rsquo;s antiquated and
confusing) but understand what it&amp;rsquo;s doing in case you run
into someone who likes it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-15-pointers-dreaded-pointers:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 15 Pointers, Dreaded Pointers&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A long video on C pointers.&lt;/li&gt;
&lt;li&gt;Lots of demonstration and visuals.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex15\ex15.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char *argv[])
{
    // create two arrays we care about
    int ages[] = { 23, 43, 12, 89, 2 };
    char *names[] = {
        &amp;quot;Alan&amp;quot;, &amp;quot;Frank&amp;quot;,
        &amp;quot;Mary&amp;quot;, &amp;quot;John&amp;quot;, &amp;quot;Lisa&amp;quot;
    };

    // safely get the size of ages
    int count = sizeof(ages) / sizeof(int);
    int i = 0;

    // first way using indexing
    for (i = 0; i &amp;lt; count; i++) {
        printf(&amp;quot;%s has %d years alive.\n&amp;quot;, names[i], ages[i]);
    }

    printf(&amp;quot;---\n&amp;quot;);

    // setup the pointers to the start of the arrays
    int *cur_age = (int *)names;
    char **cur_name = names;

    // second way using pointers
    for (i = 0; i &amp;lt; count; i++) {
        printf(&amp;quot;%s is %d years old.\n&amp;quot;,
                *(cur_name + i), *(cur_age + i));
    }

    printf(&amp;quot;---\n&amp;quot;);

    // third way, pointers are just arrays
    for (i = 0; i &amp;lt; count; i++) {
        printf(&amp;quot;%s is %d years old again.\n&amp;quot;, cur_name[i], cur_age[i]);
    }

    printf(&amp;quot;---\n&amp;quot;);

    // fourth way with pointers in a stupid complex way
    for (cur_name = names, cur_age = ages;
            (cur_age - ages) &amp;lt; count; cur_name++, cur_age++) {
        printf(&amp;quot;%s lived %d years so far.\n&amp;quot;, *cur_name, *cur_age);
    }

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Pointer Lexicon&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type *ptr A pointer of type named ptr
*ptr The value of whatever ptr is pointed at
*(ptr + i) The value of (whatever ptr is pointed at plus i)
&amp;amp;thing The address of thing
type *ptr = &amp;amp;thing A pointer of type named ptr set to the address of thing
ptr++ Increment where ptr points
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pointers Visually&lt;/p&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Try to make &lt;em&gt;cur_age&lt;/em&gt; point at &lt;em&gt;names&lt;/em&gt;.  You&amp;rsquo;ll need to
use a C cast to force it, so go look that up and try to figure it out.&lt;/li&gt;
&lt;li&gt;In the final &lt;em&gt;for-loop&lt;/em&gt;, try getting the math wrong in weird ways.&lt;/li&gt;
&lt;li&gt;Try rewriting the loops so that they start at the end of the arrays and go
to the beginning.  This is harder than it looks.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rewrite all of the arrays in this program as pointers.&lt;/li&gt;
&lt;li&gt;Rewrite all of the pointers as arrays.&lt;/li&gt;
&lt;li&gt;Go back to some of the other programs that use arrays and
try to use pointers instead.&lt;/li&gt;
&lt;li&gt;Process command line arguments using just pointers similar to how
you did &lt;em&gt;names&lt;/em&gt; in this one.&lt;/li&gt;
&lt;li&gt;Play with combinations of getting the value of and the address of
things.&lt;/li&gt;
&lt;li&gt;Add another &lt;em&gt;for-loop&lt;/em&gt; at the end that prints out the
addresses that these pointers are using.  You&amp;rsquo;ll need the &lt;em&gt;%p&lt;/em&gt; format
for &lt;em&gt;printf&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rewrite this program to use a function for each of the ways you&amp;rsquo;re
printing out things.  Try to pass pointers to these functions so that
they work on the data.  Remember you can declare a function to accept
a pointer, but just use it like an array.&lt;/li&gt;
&lt;li&gt;Change the &lt;em&gt;for-loops&lt;/em&gt; to &lt;em&gt;while-loops&lt;/em&gt; and see what
works better for which kind of pointer usage.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-16-structs-and-pointers-to-them:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 16 Structs And Pointers To Them&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Learn to work with &lt;em&gt;structs&lt;/em&gt; to structure data and make new types.&lt;/li&gt;
&lt;li&gt;Learn to use pointers to work with &lt;em&gt;structs&lt;/em&gt; better.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex16\ex16.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

struct Person {
    char *name;
    int age;
    int height;
    int weight;
};

struct Person *Person_create(char *name, int age, int height,
        int weight)
{
    struct Person *who = malloc(sizeof(struct Person));
    assert(who != NULL);

    who-&amp;gt;name = strdup(name);
    who-&amp;gt;age = age;
    who-&amp;gt;height = height;
    who-&amp;gt;weight = weight;

    return who;
}

void Person_destroy(struct Person *who)
{
    assert(who != NULL);

    free(who-&amp;gt;name);
    free(who);
}

void Person_print(struct Person *who)
{
    printf(&amp;quot;Name: %s\n&amp;quot;, who-&amp;gt;name);
    printf(&amp;quot;\tAge: %d\n&amp;quot;, who-&amp;gt;age);
    printf(&amp;quot;\tHeight: %d\n&amp;quot;, who-&amp;gt;height);
    printf(&amp;quot;\tWeight: %d\n&amp;quot;, who-&amp;gt;weight);
}

int main(int argc, char *argv[])
{
    // make two people structures
    struct Person *joe = Person_create(&amp;quot;Joe Alex&amp;quot;, 32, 64, 140);

    struct Person *frank = Person_create(&amp;quot;Frank Blank&amp;quot;, 20, 72, 180);

    // print them out and where they are in memory
    printf(&amp;quot;Joe is at memory location %p:\n&amp;quot;, joe);
    Person_print(joe);

    printf(&amp;quot;Frank is at memory location %p:\n&amp;quot;, frank);
    Person_print(frank);

    // make everyone age 20 years and print them again
    joe-&amp;gt;age += 20;
    joe-&amp;gt;height -= 2;
    joe-&amp;gt;weight += 40;
    Person_print(joe);

    frank-&amp;gt;age += 20;
    frank-&amp;gt;weight += 20;
    free(frank);
    Person_print(frank);

    // destroy them both so we clean up
    Person_destroy(joe);
    Person_destroy(frank);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Try passing &lt;em&gt;NULL&lt;/em&gt; to &lt;em&gt;Person_destroy&lt;/em&gt; see what
it does.  If it doesn&amp;rsquo;t abort, then you must not have the
&lt;em&gt;-g&lt;/em&gt; option in your Makefile&amp;rsquo;s &lt;em&gt;CFLAGS&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Forget to call &lt;em&gt;Person_destroy&lt;/em&gt; at the end, and then run
it under the debugger to see it report that you forgot
to free the memory.  Figure out the options you need to pass
to the debugger to get it to print how you leaked
this memory.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Forget to free &lt;em&gt;who-&amp;gt;name&lt;/em&gt; in &lt;em&gt;Person_destroy&lt;/em&gt;
and compare the output.  Again, use the right options to
see how the debugger tells you exactly where you messed
up.&lt;/li&gt;
&lt;li&gt;This time, pass &lt;em&gt;NULL&lt;/em&gt; to &lt;em&gt;Person_print&lt;/em&gt; and
see what the debugger thinks of that. You&amp;rsquo;ll figure out that &lt;em&gt;NULL&lt;/em&gt; is a quick way
to crash your program.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to create a &lt;em&gt;struct&lt;/em&gt; on the &lt;em&gt;stack&lt;/em&gt; just like you&amp;rsquo;re making any other variable.&lt;/li&gt;
&lt;li&gt;How to initialize it using the &lt;em&gt;x.y&lt;/em&gt; (period) character
instead of the &lt;em&gt;x-&amp;gt;y&lt;/em&gt; syntax.&lt;/li&gt;
&lt;li&gt;How to pass a structure to other functions without using
a pointer.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-17-heap-and-stack-memory-allocation:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 17 Heap and Stack Memory Allocation&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Learn to allocate data on the heap using &lt;em&gt;malloc&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Memory management techniques to avoid leaking.&lt;/li&gt;
&lt;li&gt;How the heap differs from the stack, and when to use them.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex17\ex17.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#define MAX_DATA 512
#define MAX_ROWS 100

struct Address {
    int id;
    int set;
    char name[MAX_DATA];
    char email[MAX_DATA];
};

struct Database {
    struct Address rows[MAX_ROWS];
};

struct Connection {
    FILE *file;
    struct Database *db;
};

void die(const char *message)
{
    if (errno) {
        perror(message);
    } else {
        printf(&amp;quot;ERROR: %s\n&amp;quot;, message);
    }

    exit(1);
}

void Address_print(struct Address *addr)
{
    printf(&amp;quot;%d %s %s\n&amp;quot;, addr-&amp;gt;id, addr-&amp;gt;name, addr-&amp;gt;email);
}

void Database_load(struct Connection *conn)
{
    int rc = fread(conn-&amp;gt;db, sizeof(struct Database), 1, conn-&amp;gt;file);
    if (rc != 1)
        die(&amp;quot;Failed to load database.&amp;quot;);
}

struct Connection *Database_open(const char *filename, char mode)
{
    struct Connection *conn = malloc(sizeof(struct Connection));
    if (!conn)
        die(&amp;quot;Memory error&amp;quot;);

    conn-&amp;gt;db = malloc(sizeof(struct Database));
    if (!conn-&amp;gt;db)
        die(&amp;quot;Memory error&amp;quot;);

    if (mode == &#39;c&#39;) {
        conn-&amp;gt;file = fopen(filename, &amp;quot;w&amp;quot;);
    } else {
        conn-&amp;gt;file = fopen(filename, &amp;quot;r+&amp;quot;);

        if (conn-&amp;gt;file) {
            Database_load(conn);
        }
    }

    if (!conn-&amp;gt;file)
        die(&amp;quot;Failed to open the file&amp;quot;);

    return conn;
}

void Database_close(struct Connection *conn)
{
    if (conn) {
        if (conn-&amp;gt;file)
            fclose(conn-&amp;gt;file);
        if (conn-&amp;gt;db)
            free(conn-&amp;gt;db);
        free(conn);
    }
}

void Database_write(struct Connection *conn)
{
    rewind(conn-&amp;gt;file);

    int rc = fwrite(conn-&amp;gt;db, sizeof(struct Database), 1, conn-&amp;gt;file);
    if (rc != 1)
        die(&amp;quot;Failed to write database.&amp;quot;);

    rc = fflush(conn-&amp;gt;file);
    if (rc == -1)
        die(&amp;quot;Cannot flush database.&amp;quot;);
}

void Database_create(struct Connection *conn)
{
    int i = 0;

    for (i = 0; i &amp;lt; MAX_ROWS; i++) {
        // make a prototype to initialize it
        struct Address addr = {.id = i,.set = 0 };
        // then just assign it
        conn-&amp;gt;db-&amp;gt;rows[i] = addr;
    }
}

void Database_set(struct Connection *conn, int id, const char *name,
        const char *email)
{
    struct Address *addr = &amp;amp;conn-&amp;gt;db-&amp;gt;rows[id];
    if (addr-&amp;gt;set)
        die(&amp;quot;Already set, delete it first&amp;quot;);

    addr-&amp;gt;set = 1;
    // WARNING: bug, read the &amp;quot;How To Break It&amp;quot; and fix this
    char *res = strncpy(addr-&amp;gt;name, name, MAX_DATA);
    // demonstrate the strncpy bug
    if (!res)
        die(&amp;quot;Name copy failed&amp;quot;);

    res = strncpy(addr-&amp;gt;email, email, MAX_DATA);
    if (!res)
        die(&amp;quot;Email copy failed&amp;quot;);
}

void Database_get(struct Connection *conn, int id)
{
    struct Address *addr = &amp;amp;conn-&amp;gt;db-&amp;gt;rows[id];

    if (addr-&amp;gt;set) {
        Address_print(addr);
    } else {
        die(&amp;quot;ID is not set&amp;quot;);
    }
}

void Database_delete(struct Connection *conn, int id)
{
    struct Address addr = {.id = id,.set = 0 };
    conn-&amp;gt;db-&amp;gt;rows[id] = addr;
}

void Database_list(struct Connection *conn)
{
    int i = 0;
    struct Database *db = conn-&amp;gt;db;

    for (i = 0; i &amp;lt; MAX_ROWS; i++) {
        struct Address *cur = &amp;amp;db-&amp;gt;rows[i];

        if (cur-&amp;gt;set) {
            Address_print(cur);
        }
    }
}

int main(int argc, char *argv[])
{
    if (argc &amp;lt; 3)
        die(&amp;quot;USAGE: ex17 &amp;lt;dbfile&amp;gt; &amp;lt;action&amp;gt; [action params]&amp;quot;);

    char *filename = argv[1];
    char action = argv[2][0];
    struct Connection *conn = Database_open(filename, action);
    int id = 0;

    if (argc &amp;gt; 3) id = atoi(argv[3]);
    if (id &amp;gt;= MAX_ROWS) die(&amp;quot;There&#39;s not that many records.&amp;quot;);

    switch (action) {
        case &#39;c&#39;:
            Database_create(conn);
            Database_write(conn);
            break;

        case &#39;g&#39;:
            if (argc != 4)
                die(&amp;quot;Need an id to get&amp;quot;);

            Database_get(conn, id);
            break;

        case &#39;s&#39;:
            if (argc != 6)
                die(&amp;quot;Need id, name, email to set&amp;quot;);

            Database_set(conn, id, argv[4], argv[5]);
            Database_write(conn);
            break;

        case &#39;d&#39;:
            if (argc != 4)
                die(&amp;quot;Need id to delete&amp;quot;);

            Database_delete(conn, id);
            Database_write(conn);
            break;

        case &#39;l&#39;:
            Database_list(conn);
            break;
        default:
            die(&amp;quot;Invalid action: c=create, g=get, s=set, d=del, l=list&amp;quot;);
    }

    Database_close(conn);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make ex1. cc -Wall ­g ex17.c -o ex1. 
$ ./ex17 db.dat c 
$ ./ex17 db.dat s 1 zed zed@zedshaw.com 
$ ./ex17 db.dat s 2 frank frank@zedshaw.com$ 
$ ./ex17 db.dat s 3 joe joe@zedshaw.com 
$ 
$ ./ex17 db.dat l 
1 zed zed@zedshaw.com 
2 frank frank@zedshaw.com 
3 joe joe@zedshaw.com 

$ ./ex17 db.dat d 3 
$ ./ex17 db.dat l 
1 zed zed@zedshaw.com 
2 frank frank@zedshaw.com 

$ ./ex17 db.dat g 2 
2 frank frank@zedshaw.com 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The classic way is to remove some of the safety checks so that you can
pass in arbitrary data. For example, remove the check on line 160
that prevents you from passing in any record number.&lt;/li&gt;
&lt;li&gt;You can also try corrupting the data file.  Open it in any editor and
change random bytes, and then close it.&lt;/li&gt;
&lt;li&gt;You could also find ways to pass bad arguments to the program when it&amp;rsquo;s
run. For example, getting the file and action backwards will make it create
a file named after the action, and then do an action based on the first
character.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There&amp;rsquo;s a bug in this program because &lt;em&gt;strncpy&lt;/em&gt; is poorly
designed.  Go read about &lt;em&gt;strncpy&lt;/em&gt; and try to find out what happens
when the &lt;em&gt;name&lt;/em&gt; or &lt;em&gt;address&lt;/em&gt; you give is &lt;em&gt;greater&lt;/em&gt; than
512 bytes.  Fix this by simply forcing the last character to &lt;em&gt;&amp;lsquo;\0&amp;rsquo;&lt;/em&gt;
so that it&amp;rsquo;s always set no matter what (which is what strncpy should do).&lt;/li&gt;
&lt;li&gt;In the extra credit, I have you augment the program to create arbitrary
size databases.  Try to see what the biggest database is before you
cause the program to die due to lack of memory from &lt;em&gt;malloc&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;die&lt;/em&gt; function needs to be augmented to let you pass the &lt;em&gt;conn&lt;/em&gt;
variable, so it can close it and clean up.&lt;/li&gt;
&lt;li&gt;Change the code to accept parameters for &lt;em&gt;MAX_DATA&lt;/em&gt; and &lt;em&gt;MAX_ROWS&lt;/em&gt;, store them in the &lt;em&gt;Database&lt;/em&gt; struct, and write that to the file, thus creating
a database that can be arbitrarily sized.&lt;/li&gt;
&lt;li&gt;Add more operations you can do with the database, like &lt;em&gt;find&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read about how C does it&amp;rsquo;s struct packing, and then try to see why your
file is the size it is.  See if you can calculate a new size after adding
more fields.&lt;/li&gt;
&lt;li&gt;Add some more fields to &lt;em&gt;Address&lt;/em&gt; and make them searchable.&lt;/li&gt;
&lt;li&gt;Write a shell script that will do your testing automatically for you
by running commands in the right order.  Hint: Use &lt;em&gt;set -e&lt;/em&gt; at the
top of a &lt;em&gt;bash&lt;/em&gt; to make it abort the whole script if any command
has an error.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Try reworking the program to use a single global for the database connection.
How does this new version of the program compare to the other one?&lt;/li&gt;
&lt;li&gt;Go research stack data structure and write one in your favorite language,
then try to do it in C.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-18-pointers-to-functions:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 18 Pointers to Functions&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Advanced topic of pointers to functions.&lt;/li&gt;
&lt;li&gt;These are very useful but not encountered too often.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex18\ex18.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

/** Our old friend die from ex17. */
void die(const char *message)
{
    if (errno) {
        perror(message);
    } else {
        printf(&amp;quot;ERROR: %s\n&amp;quot;, message);
    }

    exit(1);
}

// a typedef creates a fake type, in this
// case for a function pointer
typedef int (*compare_cb) (int a, int b);

/**
 * A classic bubble sort function that uses the 
 * compare_cb to do the sorting. 
 */
int *bubble_sort(int *numbers, int count, compare_cb cmp)
{
    int temp = 0;
    int i = 0;
    int j = 0;
    int *target = malloc(count * sizeof(int));

    if (!target)
        die(&amp;quot;Memory error.&amp;quot;);

    memcpy(target, numbers, count * sizeof(int));

    for (i = 0; i &amp;lt; count; i++) {
        for (j = 0; j &amp;lt; count - 1; j++) {
            if (cmp(target[j], target[j + 1]) &amp;gt; 0) {
                temp = target[j + 1];
                target[j + 1] = target[j];
                target[j] = temp;
            }
        }
    }

    return target;
}

int sorted_order(int a, int b)
{
    return a - b;
}

int reverse_order(int a, int b)
{
    return b - a;
}

int strange_order(int a, int b)
{
    if (a == 0 || b == 0) {
        return 0;
    } else {
        return a % b;
    }
}

/** 
 * Used to test that we are sorting things correctly
 * by doing the sort and printing it out.
 */
void test_sorting(int *numbers, int count, compare_cb cmp)
{
    int i = 0;
    int *sorted = bubble_sort(numbers, count, cmp);

    if (!sorted)
        die(&amp;quot;Failed to sort as requested.&amp;quot;);

    for (i = 0; i &amp;lt; count; i++) {
        printf(&amp;quot;%d &amp;quot;, sorted[i]);
    }
    printf(&amp;quot;\n&amp;quot;);

    free(sorted);
}

void destroy(compare_cb cmp)
{
    int i = 0;

    unsigned char *data = (unsigned char *)cmp;

    for(i = 0; i &amp;lt; 1; i++) {
        data[i] = i;
    }

    printf(&amp;quot;\n&amp;quot;);
}

void dump(compare_cb cmp)
{
    int i = 0;

    unsigned char *data = (unsigned char *)cmp;

    for(i = 0; i &amp;lt; 25; i++) {
        printf(&amp;quot;%02x:&amp;quot;, data[i]);
    }

    printf(&amp;quot;\n&amp;quot;);
}

int main(int argc, char *argv[])
{
    if (argc &amp;lt; 2) die(&amp;quot;USAGE: ex18 4 3 1 5 6&amp;quot;);

    int count = argc - 1;
    int i = 0;
    char **inputs = argv + 1;

    int *numbers = malloc(count * sizeof(int));
    if (!numbers) die(&amp;quot;Memory error.&amp;quot;);

    for (i = 0; i &amp;lt; count; i++) {
        numbers[i] = atoi(inputs[i]);
    }

    test_sorting(numbers, count, sorted_order);
    test_sorting(numbers, count, reverse_order);
    test_sorting(numbers, count, strange_order);

    free(numbers);

    printf(&amp;quot;SORTED:&amp;quot;);
    dump(sorted_order);

    destroy(sorted_order);

    printf(&amp;quot;SORTED:&amp;quot;);
    dump(sorted_order);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s hack your computer with this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unsigned char *data = (unsigned char *)cmp;

for(i = 0; i &amp;lt; 25; i++) {
    printf(&amp;quot;%02x:&amp;quot;, data[i]);
}

printf(&amp;quot;\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll see how the bytes of code that make up your program can also be data.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Get a hex editor and open up &lt;em&gt;ex18&lt;/em&gt;, and then find the sequence
of hex digits that start a function to see if you can find the function
in the raw program.&lt;/li&gt;
&lt;li&gt;Find other random things in your hex editor and change them.  Rerun your
program and see what happens.  Strings you find are the easiest
things to change.&lt;/li&gt;
&lt;li&gt;Pass in the wrong function for the &lt;em&gt;compare_cb&lt;/em&gt; and see what
the C compiler complains about.&lt;/li&gt;
&lt;li&gt;Pass in NULL and watch your program seriously bite it.  Then, run
the debugger and see what that reports.&lt;/li&gt;
&lt;li&gt;Write another sorting algorithm, then change &lt;em&gt;test_sorting&lt;/em&gt; so
that it takes &lt;em&gt;both&lt;/em&gt; an arbitrary sort function and the sort function&amp;rsquo;s
callback comparison.  Use it to test both of your algorithms.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-19-zed-s-awesome-debug-macros:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 19 Zed&amp;rsquo;s Awesome Debug Macros&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Learn about the macros that vastly improve my code quality.&lt;/li&gt;
&lt;li&gt;Find out why they help you out.&lt;/li&gt;
&lt;li&gt;Explore some advanced C Pre-Processor (CPP) macro magic code generation tricks.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex19\ex19.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#include &amp;quot;dbg.h&amp;quot;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

void test_debug()
{
    // notice you don&#39;t need the \n
    debug(&amp;quot;I have Brown Hair.&amp;quot;);

    // passing in arguments like printf
    debug(&amp;quot;I am %d years old.&amp;quot;, 37);
}

void test_log_err()
{
    log_err(&amp;quot;I believe everything is broken.&amp;quot;);
    log_err(&amp;quot;There are %d problems in %s.&amp;quot;, 0, &amp;quot;space&amp;quot;);
}

void test_log_warn()
{
    log_warn(&amp;quot;You can safely ignore this.&amp;quot;);
    log_warn(&amp;quot;Maybe consider looking at: %s.&amp;quot;, &amp;quot;/etc/passwd&amp;quot;);
}

void test_log_info()
{
    log_info(&amp;quot;Well I did something mundane.&amp;quot;);
    log_info(&amp;quot;It happened %f times today.&amp;quot;, 1.3f);
}

int test_check(char *file_name)
{
    FILE *input = NULL;
    char *block = NULL;

    block = malloc(100);
    check_mem(block);       // should work

    input = fopen(file_name, &amp;quot;r&amp;quot;);
    check(input, &amp;quot;Failed to open %s.&amp;quot;, file_name);

    free(block);
    fclose(input);
    return 0;

error:
    if (block) free(block);
    if (input) fclose(input);
    return -1;
}

int test_sentinel(int code)
{
    char *temp = malloc(100);
    check_mem(temp);

    switch (code) {
        case 1:
            log_info(&amp;quot;It worked.&amp;quot;);
            break;
        default:
            sentinel(&amp;quot;I shouldn&#39;t run.&amp;quot;);
    }

    free(temp);
    return 0;

error:
    if (temp)
        free(temp);
    return -1;
}

int test_check_mem()
{
    char *test = NULL;
    check_mem(test);

    free(test);
    return 1;

error:
    return -1;
}

int test_check_debug()
{
    int i = 0;
    check_debug(i != 0, &amp;quot;Oops, I was 0.&amp;quot;);

    return 0;
error:
    return -1;
}

int main(int argc, char *argv[])
{
    check(argc == 2, &amp;quot;Need an argument.&amp;quot;);

    test_debug();
    test_log_err();
    test_log_warn();
    test_log_info();

    check(test_check(&amp;quot;ex20.c&amp;quot;) == 0, &amp;quot;failed with ex20.c&amp;quot;);
    check(test_check(argv[1]) == -1, &amp;quot;failed with argv&amp;quot;);
    check(test_sentinel(1) == 0, &amp;quot;test_sentinel failed.&amp;quot;);
    check(test_sentinel(100) == -1, &amp;quot;test_sentinel failed.&amp;quot;);
    check(test_check_mem() == -1, &amp;quot;test_check_mem failed.&amp;quot;);
    check(test_check_debug() == -1, &amp;quot;test_check_debug failed.&amp;quot;);

    return 0;

error:
    return 1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;p&gt;These macros are designed on purpose to prevent you from doing this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(blah) debug(&amp;quot;This is a thing&amp;quot;);
else debug (&amp;quot;This is another thing&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Put &lt;code&gt;#define NDEBUG&lt;/code&gt; at the top of the file and check that all
of the debug messages go away.&lt;/li&gt;
&lt;li&gt;Undo that line, and add &lt;code&gt;-DNDEBUG&lt;/code&gt; to &lt;code&gt;CFLAGS&lt;/code&gt; at the
top of the &lt;code&gt;Makefile&lt;/code&gt;, and then recompile to see the same thing.&lt;/li&gt;
&lt;li&gt;Modify the logging so that it includes the function name, as well
as the &lt;code&gt;file:line&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-20-advanced-debugging-techniques:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 20 Advanced Debugging Techniques&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;p&gt;Demonstrate more advanced debugging techniques and tools.&lt;/p&gt;

&lt;p&gt;The Demonstration&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Find a graphical debugger and compare using it to raw &lt;code&gt;gdb&lt;/code&gt;.
These are useful when the program you&amp;rsquo;re looking at is local, but they
are pointless if you have to debug a program on a server.&lt;/li&gt;
&lt;li&gt;You can enable core dumps on your OS, and when a program crashes,
you&amp;rsquo;ll get a core file.  This core file is like a postmortem of
the program that you can load up to see what happened right at the crash
and what caused it.  Change &lt;code&gt;ex31.c&lt;/code&gt; so that it crashes
after a few iterations, then try to get a core dump and analyze it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-21-advanced-data-types-and-flow-control:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 21 Advanced Data Types and Flow Control&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Learn about the basic types and keywords for them.&lt;/li&gt;
&lt;li&gt;Cover all the keywords for modifying those types.&lt;/li&gt;
&lt;li&gt;Review fixed exact size types.&lt;/li&gt;
&lt;li&gt;Learn all the different operators on those types.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is mostly a review!&lt;/p&gt;

&lt;p&gt;Available Data Types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int    Stores a regular integer, defaulting to 32 bits in size.
double Holds a large floating point number.
float  Holds a smaller floating point number.
char   Holds a single 1 byte character.
void   Indicates &amp;quot;no type&amp;quot;.
enum   Enumerated types, which work as and convert to integers.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type Modifiers&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unsigned  Non-negative numbers.
signed    Gives you negative and positive numbers.
long      Bigger number.
short     Smaller number.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type Qualifiers&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const     Constant.
volatile  Compiler can&#39;t trust it.
register  Put it in a CPU register.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type Conversion&lt;/p&gt;

&lt;p&gt;C type promotion order:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;long double&lt;/li&gt;
&lt;li&gt;double&lt;/li&gt;
&lt;li&gt;float&lt;/li&gt;
&lt;li&gt;int (but only char and short int);&lt;/li&gt;
&lt;li&gt;long&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When in doubt, parens it out!&lt;/p&gt;

&lt;p&gt;Exact Size Types&lt;/p&gt;

&lt;p&gt;If you need exact sizes use these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int8_t   8-bit signed integer
uint8_t  8-bit unsigned integer
int16_t  16-bit signed integer
uint16_t 16-bit unsigned integer
int32_t  32-bit signed integer
uint32_t 32-bit unsigned integer
int64_t  64-bit signed integer
uint64_t 64-bit unsigned integer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Getting Sizes&lt;/p&gt;

&lt;p&gt;Refer to the book as there&amp;rsquo;s a large number of
macros to help you get size information for types.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int_least32_t  int that holds at least 32 bits.
uint_fast32_t  unsigned fastest int for 32 bits.
intptr_t       signed int that can hold a pointer.
PTRDIFF_MAX    maximum value of ptrdiff_t
SIZE_MAX       maximum value of a size_t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Available Operators&lt;/p&gt;

&lt;p&gt;This section is a review of what you memorized already
to make sure you know everything.&lt;/p&gt;

&lt;p&gt;Memorize these again to be sure you have them.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read stdint.h or a description of it, and write out all the
available size identifiers.&lt;/li&gt;
&lt;li&gt;Go through each item here and write out what it does in code.  Research it online so you know you got it right.&lt;/li&gt;
&lt;li&gt;Get this information memorized by making flash cards and spending 15
minutes a day practicing it.&lt;/li&gt;
&lt;li&gt;Create a program that prints out examples of each type, and confirm that your
research is right.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-22-the-stack-scope-and-globals:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 22 The Stack, Scope, and Globals&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start to learn about scope.&lt;/li&gt;
&lt;li&gt;Stack vs. global.&lt;/li&gt;
&lt;li&gt;Scope levels inside a function.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;extern&lt;/em&gt; keyword.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex22\ex22.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifndef _ex22_h
#define _ex22_h

struct State {
    int the_size;
    int the_age;
};

// gets and sets an internal static variable in ex22.c
int get_age(struct State *state);
void set_age(struct State *state, int age);

// updates a static variable that&#39;s inside update_ratio
double update_ratio(double ratio);

void print_size();

#endif

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex22\ex22.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;ex22.h&amp;quot;
#include &amp;quot;dbg.h&amp;quot;

int get_age(struct State *state)
{
    return state-&amp;gt;the_age;
}

void set_age(struct State *state, int age)
{
   state-&amp;gt;the_age = age; 
}

double update_ratio(double new_ratio)
{
    static double ratio = 1.0;

    double old_ratio = ratio;
    ratio = new_ratio;

    return old_ratio;
}

void print_size()
{
    log_info(&amp;quot;I think size is: %d&amp;quot;, THE_SIZE);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex22\ex22_main.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;ex22.h&amp;quot;
#include &amp;quot;dbg.h&amp;quot;

const char *MY_NAME = &amp;quot;Zed A. Shaw&amp;quot;;

void scope_demo(int count)
{
    log_info(&amp;quot;count is: %d&amp;quot;, count);

    if (count &amp;gt; 10) {
        int numbers = 100;  // BAD! BUGS!

        log_info(&amp;quot;count in this scope is %d&amp;quot;, numbers);
    }

    log_info(&amp;quot;count is at exit: %d&amp;quot;, count);

    count = 3000;

    log_info(&amp;quot;count after assign: %d&amp;quot;, count);
}

int main(int argc, char *argv[])
{
    // test out THE_AGE accessors
    log_info(&amp;quot;My name: %s, age: %d&amp;quot;, MY_NAME, get_age());

    set_age(100);

    log_info(&amp;quot;My age is now: %d&amp;quot;, get_age());

    // test out THE_SIZE extern
    log_info(&amp;quot;THE_SIZE is: %d&amp;quot;, THE_SIZE);
    print_size();

    THE_SIZE = 9;

    log_info(&amp;quot;THE SIZE is now: %d&amp;quot;, THE_SIZE);
    print_size();

    // test the ratio function static
    log_info(&amp;quot;Ratio at first: %f&amp;quot;, update_ratio(2.0));
    log_info(&amp;quot;Ratio again: %f&amp;quot;, update_ratio(10.0));
    log_info(&amp;quot;Ratio once more: %f&amp;quot;, update_ratio(300.0));

    // test the scope demo
    int count = 4;
    scope_demo(count);
    scope_demo(count * 20);

    log_info(&amp;quot;count after calling scope_demo: %d&amp;quot;, count);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This exercises requires two files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* ex22.c
* ex22_main.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Fixing It&lt;/p&gt;

&lt;p&gt;Instead of breaking this one I&amp;rsquo;m going to fix it.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Do not shadow a variable like &lt;em&gt;count&lt;/em&gt; on ex22_main.c:11.&lt;/li&gt;
&lt;li&gt;Avoid using too many globals.&lt;/li&gt;
&lt;li&gt;When in doubt, put it on the heap (malloc).&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t use function static variables like I did in ex22.c:update_ratio.&lt;/li&gt;
&lt;li&gt;Avoid reusing function parameters.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Try to directly access variables in &lt;code&gt;ex22.c&lt;/code&gt; from &lt;code&gt;ex22_main.c&lt;/code&gt;
that you think you can&amp;rsquo;t.  For example, can you get at &lt;code&gt;ratio&lt;/code&gt;
inside &lt;code&gt;update_ratio&lt;/code&gt;? What if you had a pointer to it?&lt;/li&gt;
&lt;li&gt;Ditch the &lt;code&gt;extern&lt;/code&gt; declaration in &lt;code&gt;ex22.h&lt;/code&gt; to see what
errors or warnings you get.&lt;/li&gt;
&lt;li&gt;Add &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; specifiers to different variables,
and then try to change them.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Research the concept of pass by value verses pass by reference.  Write an
example of both.&lt;/li&gt;
&lt;li&gt;Use pointers to gain access to things you shouldn&amp;rsquo;t have access to.&lt;/li&gt;
&lt;li&gt;Use your debugger to see what this kind of access looks like when you
do it wrong.&lt;/li&gt;
&lt;li&gt;Write a recursive function that causes a stack overflow.  Don&amp;rsquo;t know
what a recursive function is?  Try calling &lt;code&gt;scope_demo&lt;/code&gt; at the
bottom of &lt;code&gt;scope_demo&lt;/code&gt; itself so that it loops.&lt;/li&gt;
&lt;li&gt;Rewrite the &lt;code&gt;Makefile&lt;/code&gt; so that it can build this.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-23-meet-duff-s-device:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 23 Meet Duff&amp;rsquo;s Device&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;p&gt;Learn the most evil awesome hack ever:&lt;/p&gt;

&lt;p&gt;Duff&amp;rsquo;s Device&lt;/p&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex23\ex23.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;dbg.h&amp;quot;

int normal_copy(char *from, char *to, int count)
{
    int i = 0;

    for (i = 0; i &amp;lt; count; i++) {
        to[i] = from[i];
    }

    return i;
}

int duffs_device(char *from, char *to, int count)
{
    {
        int n = (count + 7) / 8;

        switch (count % 8) {
            case 0:
                do {
                    *to++ = *from++;
                    case 7:
                    *to++ = *from++;
                    case 6:
                    *to++ = *from++;
                    case 5:
                    *to++ = *from++;
                    case 4:
                    *to++ = *from++;
                    case 3:
                    *to++ = *from++;
                    case 2:
                    *to++ = *from++;
                    case 1:
                    *to++ = *from++;
                } while (--n &amp;gt; 0);
        }
    }

    return count;
}

int zeds_device(char *from, char *to, int count)
{
    {
        int n = (count + 7) / 8;
        debug(&amp;quot;n starts: %d, count: %d, count%%8: %d&amp;quot;, 
                n, count, count % 8);

        switch (count % 8) {
            case 0:
again:    *to++ = *from++;

            case 7:
          *to++ = *from++;
            case 6:
          *to++ = *from++;
            case 5:
          *to++ = *from++;
            case 4:
          *to++ = *from++;
            case 3:
          *to++ = *from++;
            case 2:
          *to++ = *from++;
            case 1:
          *to++ = *from++;
          debug(&amp;quot;last case: n=%d&amp;quot;, n);
          if (--n &amp;gt; 0) {
              debug(&amp;quot;going again: n=%d&amp;quot;, n);
              goto again;
          }
        }
    }

    return count;
}

int valid_copy(char *data, int count, char expects)
{
    int i = 0;
    for (i = 0; i &amp;lt; count; i++) {
        if (data[i] != expects) {
            log_err(&amp;quot;[%d] %c != %c&amp;quot;, i, data[i], expects);
            return 0;
        }
    }

    return 1;
}

int main(int argc, char *argv[])
{
    char from[1003] = { &#39;a&#39; };
    char to[1003] = { &#39;c&#39; };
    int rc = 0;

    // setup the from to have some stuff
    memset(from, &#39;x&#39;, 1003);
    // set it to a failure mode
    memset(to, &#39;y&#39;, 1003);
    check(valid_copy(to, 1003, &#39;y&#39;), &amp;quot;Not initialized right.&amp;quot;);

    // use normal copy to 
    rc = normal_copy(from, to, 1003);
    check(rc == 1003, &amp;quot;Normal copy failed: %d&amp;quot;, rc);
    check(valid_copy(to, 1003, &#39;x&#39;), &amp;quot;Normal copy failed.&amp;quot;);

    // reset
    memset(to, &#39;y&#39;, 1003);

    // duffs version
    rc = duffs_device(from, to, 1003);
    check(rc == 1003, &amp;quot;Duff&#39;s device failed: %d&amp;quot;, rc);
    check(valid_copy(to, 1003, &#39;x&#39;), &amp;quot;Duff&#39;s device failed copy.&amp;quot;);

    // reset
    memset(to, &#39;y&#39;, 1003);

    // my version
    rc = zeds_device(from, to, 1003);
    check(rc == 1003, &amp;quot;Zed&#39;s device failed: %d&amp;quot;, rc);
    check(valid_copy(to, 1003, &#39;x&#39;), &amp;quot;Zed&#39;s device failed copy.&amp;quot;);

    return 0;
error:
    return 1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that this is &lt;em&gt;bad&lt;/em&gt; code.
It&amp;rsquo;s very interesting though, so struggle with it.&lt;/p&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Before you continue, try to figure out what this does.
Consider it a debugging problem.&lt;/p&gt;

&lt;p&gt;Clues&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Print this code out so that you can write on some paper.&lt;/li&gt;
&lt;li&gt;Write each of the variables in a table as they
look when they get initialized right before the &lt;code&gt;switch-statement&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Follow the logic to the switch, then do the jump to the right case.&lt;/li&gt;
&lt;li&gt;Update the variables, including the &lt;code&gt;to&lt;/code&gt;, &lt;code&gt;from&lt;/code&gt;, and the
arrays they point at.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Clues&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When you get to the &lt;code&gt;while&lt;/code&gt; part or my &lt;code&gt;goto&lt;/code&gt; alternative,
check your variables, and then follow the logic either back to the
top of the &lt;code&gt;do-while&lt;/code&gt; or to where the &lt;code&gt;again&lt;/code&gt; label is
located.&lt;/li&gt;
&lt;li&gt;Follow through this manual tracing, updating the variables, until
you&amp;rsquo;re sure you see how this flows.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pause!&lt;/p&gt;

&lt;p&gt;I will then show you the solution so pause if you do
&lt;em&gt;NOT&lt;/em&gt; want to see it yet.&lt;/p&gt;

&lt;p&gt;Solving It&lt;/p&gt;

&lt;p&gt;Watch me walk through how this works to see if it matches what you did.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Never use this again.&lt;/li&gt;
&lt;li&gt;Go look at the Wikipedia entry for Duff&amp;rsquo;s device and see if you can
spot the error.  Read the article, compare it to the version I have here, and try to understand why the Wikipedia code won&amp;rsquo;t work for you
but worked for Tom Duff.&lt;/li&gt;
&lt;li&gt;Create a set of macros that lets you create any length of device like this.
For example, what if you wanted to have 32 case statements and didn&amp;rsquo;t want
to write out all of them? Can you do a macro that lays down eight at a time?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Change the &lt;code&gt;main&lt;/code&gt; to conduct some speed tests to see which one is
really the fastest.&lt;/li&gt;
&lt;li&gt;Read about &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memmove&lt;/code&gt;, and &lt;code&gt;memset&lt;/code&gt;, and also compare
their speed.&lt;/li&gt;
&lt;li&gt;Never use this again!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-24-input-output-files:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 24 Input, Output, Files&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Learn the basics of working with files in C.&lt;/li&gt;
&lt;li&gt;Get an initial list of the &amp;ldquo;f-functions&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex24\ex24.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;dbg.h&amp;quot;

#define MAX_DATA 100

typedef enum EyeColor {
    BLUE_EYES, GREEN_EYES, BROWN_EYES,
    BLACK_EYES, OTHER_EYES
} EyeColor;

const char *EYE_COLOR_NAMES[] = {
    &amp;quot;Blue&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Brown&amp;quot;, &amp;quot;Black&amp;quot;, &amp;quot;Other&amp;quot;
};

typedef struct Person {
    int age;
    char first_name[MAX_DATA];
    char last_name[MAX_DATA];
    EyeColor eyes;
    float income;
} Person;

int main(int argc, char *argv[])
{
    Person you = {.age = 0 };
    int i = 0;
    char *in = NULL;

    printf(&amp;quot;What&#39;s your First Name? &amp;quot;);
    in = fgets(you.first_name, MAX_DATA - 1, stdin);
    check(in != NULL, &amp;quot;Failed to read first name.&amp;quot;);

    printf(&amp;quot;What&#39;s your Last Name? &amp;quot;);
    in = fgets(you.last_name, MAX_DATA - 1, stdin);
    check(in != NULL, &amp;quot;Failed to read last name.&amp;quot;);

    printf(&amp;quot;How old are you? &amp;quot;);
    int rc = fscanf(stdin, &amp;quot;%d&amp;quot;, &amp;amp;you.age);
    check(rc &amp;gt; 0, &amp;quot;You have to enter a number.&amp;quot;);

    printf(&amp;quot;What color are your eyes:\n&amp;quot;);
    for (i = 0; i &amp;lt;= OTHER_EYES; i++) {
        printf(&amp;quot;%d) %s\n&amp;quot;, i + 1, EYE_COLOR_NAMES[i]);
    }
    printf(&amp;quot;&amp;gt; &amp;quot;);

    int eyes = -1;
    rc = fscanf(stdin, &amp;quot;%d&amp;quot;, &amp;amp;eyes);
    check(rc &amp;gt; 0, &amp;quot;You have to enter a number.&amp;quot;);

    you.eyes = eyes - 1;
    check(you.eyes &amp;lt;= OTHER_EYES
            &amp;amp;&amp;amp; you.eyes &amp;gt;= 0, &amp;quot;Do it right, that&#39;s not an option.&amp;quot;);

    printf(&amp;quot;How much do you make an hour? &amp;quot;);
    rc = fscanf(stdin, &amp;quot;%f&amp;quot;, &amp;amp;you.income);
    check(rc &amp;gt; 0, &amp;quot;Enter a floating point number.&amp;quot;);

    printf(&amp;quot;----- RESULTS -----\n&amp;quot;);

    printf(&amp;quot;First Name: %s&amp;quot;, you.first_name);
    printf(&amp;quot;Last Name: %s&amp;quot;, you.last_name);
    printf(&amp;quot;Age: %d\n&amp;quot;, you.age);
    printf(&amp;quot;Eyes: %s\n&amp;quot;, EYE_COLOR_NAMES[you.eyes]);
    printf(&amp;quot;Income: %f\n&amp;quot;, you.income);

    return 0;
error:

    return -1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Trying out &lt;em&gt;fgets&lt;/em&gt; and the problems with &lt;em&gt;gets&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Feed it &lt;em&gt;/dev/urandom&lt;/em&gt; to give it garbage.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rewrite this to not use &lt;code&gt;fscanf&lt;/code&gt; at all.  You&amp;rsquo;ll need to use
functions like &lt;code&gt;atoi&lt;/code&gt; to convert the input strings to numbers.&lt;/li&gt;
&lt;li&gt;Change this to use plain &lt;code&gt;scanf&lt;/code&gt; instead of &lt;code&gt;fscanf&lt;/code&gt; to
see what the difference is.&lt;/li&gt;
&lt;li&gt;Fix it so that their input names get stripped of the trailing newline
characters and any whites pace.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;scanf&lt;/code&gt; to write a function that reads one character at a time
and files in the names but doesn&amp;rsquo;t go past the end.  Make this function
generic so it can take a size for the string, but just make sure you end
the string with &lt;code&gt;&#39;\0&#39;&lt;/code&gt; no matter what.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-25-variable-argument-functions:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 25 Variable Argument Functions&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use variable argument functions.&lt;/li&gt;
&lt;li&gt;Write our own simple version of &lt;em&gt;scanf&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex25\ex25.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdarg.h&amp;gt;
#include &amp;quot;dbg.h&amp;quot;

#define MAX_DATA 100

int read_string(char **out_string, int max_buffer)
{
    *out_string = calloc(1, max_buffer + 1);
    check_mem(*out_string);

    char *result = fgets(*out_string, max_buffer, stdin);
    check(result != NULL, &amp;quot;Input error.&amp;quot;);

    return 0;

error:
    if (*out_string) free(*out_string);
    *out_string = NULL;
    return -1;
}

int read_int(int *out_int)
{
    char *input = NULL;
    int rc = read_string(&amp;amp;input, MAX_DATA);
    check(rc == 0, &amp;quot;Failed to read number.&amp;quot;);

    *out_int = atoi(input);

    free(input);
    return 0;

error:
    if (input) free(input);
    return -1;
}

int read_scan(const char *fmt, ...)
{
    int i = 0;
    int rc = 0;
    int *out_int = NULL;
    char *out_char = NULL;
    char **out_string = NULL;
    int max_buffer = 0;

    va_list argp;
    va_start(argp, fmt);

    for (i = 0; fmt[i] != &#39;\0&#39;; i++) {
        if (fmt[i] == &#39;%&#39;) {
            i++;
            switch (fmt[i]) {
                case &#39;\0&#39;:
                    sentinel(&amp;quot;Invalid format, you ended with %%.&amp;quot;);
                    break;

                case &#39;d&#39;:
                    out_int = va_arg(argp, int *);
                    rc = read_int(out_int);
                    check(rc == 0, &amp;quot;Failed to read int.&amp;quot;);
                    break;

                case &#39;c&#39;:
                    out_char = va_arg(argp, char *);
                    *out_char = fgetc(stdin);
                    break;

                case &#39;s&#39;:
                    max_buffer = va_arg(argp, int);
                    out_string = va_arg(argp, char **);
                    rc = read_string(out_string, max_buffer);
                    check(rc == 0, &amp;quot;Failed to read string.&amp;quot;);
                    break;

                default:
                    sentinel(&amp;quot;Invalid format.&amp;quot;);
            }
        } else {
            fgetc(stdin);
        }

        check(!feof(stdin) &amp;amp;&amp;amp; !ferror(stdin), &amp;quot;Input error.&amp;quot;);
    }

    va_end(argp);
    return 0;

error:
    va_end(argp);
    return -1;
}

int main(int argc, char *argv[])
{
    char *first_name = NULL;
    char initial = &#39; &#39;;
    char *last_name = NULL;
    int age = 0;

    printf(&amp;quot;What&#39;s your first name? &amp;quot;);
    int rc = read_scan(&amp;quot;%s&amp;quot;, MAX_DATA, &amp;amp;first_name);
    check(rc == 0, &amp;quot;Failed first name.&amp;quot;);

    printf(&amp;quot;What&#39;s your initial? &amp;quot;);
    rc = read_scan(&amp;quot;%c\n&amp;quot;, &amp;amp;initial);
    check(rc == 0, &amp;quot;Failed initial.&amp;quot;);

    printf(&amp;quot;What&#39;s your last name? &amp;quot;);
    rc = read_scan(&amp;quot;%s&amp;quot;, MAX_DATA, &amp;amp;last_name);
    check(rc == 0, &amp;quot;Failed last name.&amp;quot;);

    printf(&amp;quot;How old are you? &amp;quot;);
    rc = read_scan(&amp;quot;%d&amp;quot;, &amp;amp;age);

    printf(&amp;quot;---- RESULTS ----\n&amp;quot;);
    printf(&amp;quot;First Name: %s&amp;quot;, first_name);
    printf(&amp;quot;Initial: &#39;%c&#39;\n&amp;quot;, initial);
    printf(&amp;quot;Last Name: %s&amp;quot;, last_name);
    printf(&amp;quot;Age: %d\n&amp;quot;, age);

    free(first_name);
    free(last_name);
    return 0;
error:
    return -1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Change the code so that you forget to pass in the initial size for &amp;lsquo;%s&amp;rsquo; formats.&lt;/li&gt;
&lt;li&gt;Give it more data than &lt;code&gt;MAX_DATA&lt;/code&gt;, and then see how omitting &lt;code&gt;calloc&lt;/code&gt; in &lt;code&gt;read_string&lt;/code&gt; changes how it works.&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s a problem where fgets eats the newlines, so try to fix that using
&lt;code&gt;fgetc&lt;/code&gt; but leave out the &lt;code&gt;\0&lt;/code&gt; that ends the string.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Make double and triple sure that you know what each of the &lt;code&gt;out_&lt;/code&gt;
variables are doing.  Most importantly, you should know what is &lt;code&gt;out_string&lt;/code&gt; is and how it&amp;rsquo;s
a pointer to a pointer, , so that you understand when you&amp;rsquo;re setting the pointer versus the
contents is important.  Break down each of the&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Write a similar function to &lt;code&gt;printf&lt;/code&gt; that uses the varargs system,
and rewrite &lt;code&gt;main&lt;/code&gt; to use it.&lt;/li&gt;
&lt;li&gt;As usual, read the man page on all of this so that you know what it does
on your platform.  Some platforms will use macros, others will use
functions, and some will have these do nothing.  It all depends on the
compiler and the platform you use.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-26-project-logfind:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 26 Project logfind&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;p&gt;Attempt your first project!&lt;/p&gt;

&lt;p&gt;logfind&lt;/p&gt;

&lt;p&gt;How Projects Work&lt;/p&gt;

&lt;p&gt;The projects in this book are designed to make you apply
what you know so far to something &amp;ldquo;real world&amp;rdquo;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;I will tell you when to &lt;em&gt;pause&lt;/em&gt; so you can try to solve it yourself.&lt;/li&gt;
&lt;li&gt;You will be given the challenge.  Pause!&lt;/li&gt;
&lt;li&gt;You will be given clues. Pause!&lt;/li&gt;
&lt;li&gt;Finally the solution.&lt;/li&gt;
&lt;li&gt;Then I try to break my own solution.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;logfind.1&lt;/p&gt;

&lt;p&gt;.\ex26\logfind.1\logfind.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;dbg.h&amp;quot;

int main(int argc, char *argv[])
{
    check(argc &amp;gt; 2, &amp;quot;USAGE: logfind word word word&amp;quot;);

    return 0;

error:
    return 1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex26\logfind.1\Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind test test test

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;logfind.2&lt;/p&gt;

&lt;p&gt;.\ex26\logfind.2\logfind.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;dbg.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

const size_t MAX_LINE = 1024;

int scan_file(const char *filename, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &amp;quot;r&amp;quot;);
    char *found = NULL;
    int i = 0;

    check_mem(line);
    check(file, &amp;quot;Failed to open file: %s&amp;quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL &amp;amp;&amp;amp; found == NULL) {
        for(i = 0; i &amp;lt; search_len &amp;amp;&amp;amp; found == NULL; i++) {
            found = strcasestr(line, search_for[i]);
            if(found) {
                printf(&amp;quot;%s\n&amp;quot;, filename);
            }
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int main(int argc, char *argv[])
{
    check(argc &amp;gt; 1, &amp;quot;USAGE: logfind word word word&amp;quot;);

    scan_file(&amp;quot;logfind.c&amp;quot;, argc, argv);

    return 0;

error:
    return 1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex26\logfind.2\Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind error

clean:
    rm -f logfind

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;logfind.3&lt;/p&gt;

&lt;p&gt;.\ex26\logfind.3\logfind.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;dbg.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;glob.h&amp;gt;

const size_t MAX_LINE = 1024;

int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&amp;quot;.logfind&amp;quot;, &amp;quot;r&amp;quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &amp;quot;Invalid glob_t given.&amp;quot;);
    check_mem(line);
    check(file, &amp;quot;Failed to open .logfind. Make that first.&amp;quot;);

    rc = glob(&amp;quot;*.h&amp;quot;, glob_flags, NULL, pglob);
    check(rc == 0, &amp;quot;Failed to glob.&amp;quot;);
    rc = glob(&amp;quot;*.c&amp;quot;, glob_flags | GLOB_APPEND, NULL, pglob);
    check(rc == 0, &amp;quot;Failed to glob.&amp;quot;);

    for(i = 0; i &amp;lt; pglob-&amp;gt;gl_pathc; i++) {
        debug(&amp;quot;Matched file: %s&amp;quot;, pglob-&amp;gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int scan_file(const char *filename, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &amp;quot;r&amp;quot;);
    char *found = NULL;
    int i = 0;

    check_mem(line);
    check(file, &amp;quot;Failed to open file: %s&amp;quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL &amp;amp;&amp;amp; found == NULL) {
        for(i = 0; i &amp;lt; search_len &amp;amp;&amp;amp; found == NULL; i++) {
            found = strcasestr(line, search_for[i]);
            if(found) {
                printf(&amp;quot;%s\n&amp;quot;, filename);
            }
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int main(int argc, char *argv[])
{
    int i = 0;
    glob_t files_found;
    check(argc &amp;gt; 1, &amp;quot;USAGE: logfind word word word&amp;quot;);

    check(list_files(&amp;amp;files_found) == 0, &amp;quot;Failed to list files.&amp;quot;);

    for(i = 0; i &amp;lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], argc, argv);
    }

    globfree(&amp;amp;files_found);
    return 0;

error:
    return 1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex26\logfind.3\Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind error

clean:
    rm -f logfind

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;logfind.4&lt;/p&gt;

&lt;p&gt;.\ex26\logfind.4\logfind.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define NDEBUG
#include &amp;quot;dbg.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;glob.h&amp;gt;

const size_t MAX_LINE = 1024;

int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&amp;quot;.logfind&amp;quot;, &amp;quot;r&amp;quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &amp;quot;Invalid glob_t given.&amp;quot;);
    check_mem(line);
    check(file, &amp;quot;Failed to open .logfind. Make that first.&amp;quot;);

    while(fgets(line, MAX_LINE-1, file) != NULL) {
        line[strlen(line) - 1] = &#39;\0&#39;; // drop the \n ending
        debug(&amp;quot;Globbing %s&amp;quot;, line);

        rc = glob(line, glob_flags, NULL, pglob);
        check(rc == 0 || rc == GLOB_NOMATCH, &amp;quot;Failed to glob.&amp;quot;);

        // dumb work around to a stupid design in glob
        if(glob_flags == GLOB_TILDE) glob_flags |= GLOB_APPEND;
    }

    for(i = 0; i &amp;lt; pglob-&amp;gt;gl_pathc; i++) {
        debug(&amp;quot;Matched file: %s&amp;quot;, pglob-&amp;gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int scan_file(const char *filename, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &amp;quot;r&amp;quot;);
    char *found = NULL;
    int i = 0;

    check_mem(line);
    check(file, &amp;quot;Failed to open file: %s&amp;quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL &amp;amp;&amp;amp; found == NULL) {
        for(i = 0; i &amp;lt; search_len &amp;amp;&amp;amp; found == NULL; i++) {
            found = strcasestr(line, search_for[i]);
            if(found) {
                printf(&amp;quot;%s\n&amp;quot;, filename);
            }
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int main(int argc, char *argv[])
{
    int i = 0;
    glob_t files_found;
    check(argc &amp;gt; 1, &amp;quot;USAGE: logfind word word word&amp;quot;);

    check(list_files(&amp;amp;files_found) == 0, &amp;quot;Failed to list files.&amp;quot;);

    for(i = 0; i &amp;lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], argc, argv);
    }

    globfree(&amp;amp;files_found);
    return 0;

error:
    return 1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex26\logfind.4\Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind MAX_LINE

clean:
    rm -f logfind

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;logfind.5&lt;/p&gt;

&lt;p&gt;.\ex26\logfind.5\logfind.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define NDEBUG
#include &amp;quot;dbg.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;glob.h&amp;gt;

const size_t MAX_LINE = 1024;

int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&amp;quot;.logfind&amp;quot;, &amp;quot;r&amp;quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &amp;quot;Invalid glob_t given.&amp;quot;);
    check_mem(line);
    check(file, &amp;quot;Failed to open .logfind. Make that first.&amp;quot;);

    while(fgets(line, MAX_LINE-1, file) != NULL) {
        line[strlen(line) - 1] = &#39;\0&#39;; // drop the \n ending
        debug(&amp;quot;Globbing %s&amp;quot;, line);

        rc = glob(line, glob_flags, NULL, pglob);
        check(rc == 0 || rc == GLOB_NOMATCH, &amp;quot;Failed to glob.&amp;quot;);

        // dumb work around to a stupid design in glob
        if(glob_flags == GLOB_TILDE) glob_flags |= GLOB_APPEND;
    }

    for(i = 0; i &amp;lt; pglob-&amp;gt;gl_pathc; i++) {
        debug(&amp;quot;Matched file: %s&amp;quot;, pglob-&amp;gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int found_it(int use_or, int found_count, int search_len)
{
    debug(&amp;quot;use_or: %d, found_count: %d, search_len: %d&amp;quot;, use_or, found_count, search_len);

    if(use_or &amp;amp;&amp;amp; found_count &amp;gt; 0) {
        return 1;
    } else if(!use_or &amp;amp;&amp;amp; found_count == search_len) {
        return 1;
    } else {
        return 0;
    }
}

int scan_file(const char *filename, int use_or, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &amp;quot;r&amp;quot;);
    int found_count = 0;
    int i = 0;

    check_mem(line);
    check(file, &amp;quot;Failed to open file: %s&amp;quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL)
    {
        for(i = 0; i &amp;lt; search_len; i++) {
            if(strcasestr(line, search_for[i]) != NULL) {
                debug(&amp;quot;file: %s, line: %s, search: %s&amp;quot;, filename, line, search_for[i]);
                found_count++;
            }
        }

        if(found_it(use_or, found_count, search_len)) {
            printf(&amp;quot;%s\n&amp;quot;, filename);
            break;
        } else {
            found_count = 0;
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int parse_args(int *use_or, int *argc, char **argv[]) 
{
    (*argc)--;
    (*argv)++;

    if(strcmp((*argv)[0], &amp;quot;-o&amp;quot;) == 0) {
        *use_or = 1;
        (*argc)--; // skip the -o
        (*argv)++;
        check(*argc &amp;gt; 1, &amp;quot;You need words after -o.&amp;quot;);
    } else {
        use_or = 0;
    }

    return 0;
error:
    return -1;
}

int main(int argc, char *argv[])
{
    int i = 0;
    int use_or = 0;
    glob_t files_found;

    check(argc &amp;gt; 1, &amp;quot;USAGE: logfind [-o] words&amp;quot;);

    check(parse_args(&amp;amp;use_or, &amp;amp;argc, &amp;amp;argv) == 0, &amp;quot;USAGE: logfind [-o] words&amp;quot;);

    check(list_files(&amp;amp;files_found) == 0, &amp;quot;Failed to list files.&amp;quot;);

    for(i = 0; i &amp;lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], use_or, argc, argv);
    }

    globfree(&amp;amp;files_found);
    return 0;

error:
    return 1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex26\logfind.5\Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind MAX_LINE
    ./logfind error MAX LINE
    ./logfind -o error MAX LINE

clean:
    rm -f logfind

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you ever get super stuck, you can visit:&lt;/p&gt;

&lt;p&gt;To get all of the code for this book.&lt;/p&gt;

&lt;p&gt;The Challenge&lt;/p&gt;

&lt;p&gt;I want a tool called &lt;code&gt;logfind&lt;/code&gt; that let&amp;rsquo;s me search through log files for
text.  This tool is a specialized version of another tool called &lt;code&gt;grep&lt;/code&gt;, but
designed only for log files on a system.&lt;/p&gt;

&lt;p&gt;The Challenge&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This tool takes any sequence of words and assumes I mean &amp;ldquo;and&amp;rdquo; for them.  So &lt;code&gt;logfind zedshaw smart guy&lt;/code&gt; will find all files that have &lt;code&gt;zedshaw&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;smart&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;guy&lt;/code&gt; in them.&lt;/li&gt;
&lt;li&gt;It takes an optional argument of &lt;code&gt;-o&lt;/code&gt; if the parameters are meant to be &lt;em&gt;or&lt;/em&gt; logic.&lt;/li&gt;
&lt;li&gt;It loads the list of allowed log files from &lt;code&gt;~/.logfind&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Challenge&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The list of file names can be anything that the &lt;code&gt;glob&lt;/code&gt; function allows.  Refer to &lt;code&gt;man 3 glob&lt;/code&gt; to see how this works.  I suggest starting with just a flat list of exact files, and then add &lt;code&gt;glob&lt;/code&gt; functionality.&lt;/li&gt;
&lt;li&gt;You should output the matching lines as you scan, and try to match them as fast as possible.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Demo&lt;/p&gt;

&lt;p&gt;Here is a demo of me using the one I wrote.&lt;/p&gt;

&lt;p&gt;Pause!&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time for you to attempt to solve it from just this idea.&lt;/p&gt;

&lt;p&gt;The Clues&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Remember to solve it a piece at a time.&lt;/li&gt;
&lt;li&gt;Start with just getting the arguments.&lt;/li&gt;
&lt;li&gt;Then figure out how to open files and just open the ones in this directory.&lt;/li&gt;
&lt;li&gt;Then figure out how to read the files.&lt;/li&gt;
&lt;li&gt;Then find out how to find the arguments in the files.&lt;/li&gt;
&lt;li&gt;Then figure out how glob works.&lt;/li&gt;
&lt;li&gt;Then use glob to find the files and open them.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It helps to do each of these in &lt;em&gt;main()&lt;/em&gt; then &amp;ldquo;carve&amp;rdquo; them out into their
own functions.&lt;/p&gt;

&lt;p&gt;Pause!&lt;/p&gt;

&lt;p&gt;The Solution&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;h2 id=&#34;exercise-27-creative-and-defensive-programming:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 27 Creative and Defensive Programming&lt;/h2&gt;

&lt;p&gt;logfind.5&lt;/p&gt;

&lt;p&gt;.\ex27\logfind.5\logfind.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define NDEBUG
#include &amp;quot;dbg.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;glob.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;

const size_t MAX_LINE = 1024;

int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&amp;quot;.logfind&amp;quot;, &amp;quot;r&amp;quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &amp;quot;Invalid glob_t given.&amp;quot;);
    check_mem(line);
    check(file, &amp;quot;Failed to open .logfind. Make that first.&amp;quot;);

    while(fgets(line, MAX_LINE-1, file) != NULL) {
        size_t line_length = strnlen(line, MAX_LINE - 1);
        assert(line_length &amp;lt; MAX_LINE &amp;amp;&amp;amp; &amp;quot;Got a line length too long.&amp;quot;);

        line[line_length] = &#39;\0&#39;; // drop the \n ending
        debug(&amp;quot;Globbing %s&amp;quot;, line);

        rc = glob(line, glob_flags, NULL, pglob);
        check(rc == 0 || rc == GLOB_NOMATCH, &amp;quot;Failed to glob.&amp;quot;);

        // dumb work around to a stupid design in glob
        if(glob_flags == GLOB_TILDE) glob_flags |= GLOB_APPEND;
    }

    for(i = 0; i &amp;lt; pglob-&amp;gt;gl_pathc; i++) {
        debug(&amp;quot;Matched file: %s&amp;quot;, pglob-&amp;gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int found_it(int use_or, int found_count, int search_len)
{
    debug(&amp;quot;use_or: %d, found_count: %d, search_len: %d&amp;quot;, use_or, found_count, search_len);

    if(use_or &amp;amp;&amp;amp; found_count &amp;gt; 0) {
        return 1;
    } else if(!use_or &amp;amp;&amp;amp; found_count == search_len) {
        return 1;
    } else {
        return 0;
    }
}

int scan_file(const char *filename, int use_or, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &amp;quot;r&amp;quot;);
    int found_count = 0;
    int i = 0;

    check_mem(line);
    check(file, &amp;quot;Failed to open file: %s&amp;quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL)
    {
        for(i = 0; i &amp;lt; search_len; i++) {
            if(strcasestr(line, search_for[i]) != NULL) {
                debug(&amp;quot;file: %s, line: %s, search: %s&amp;quot;, filename, line, search_for[i]);
                found_count++;
            }
        }

        if(found_it(use_or, found_count, search_len)) {
            printf(&amp;quot;%s\n&amp;quot;, filename);
            break;
        } else {
            found_count = 0;
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int parse_args(int *use_or, int *argc, char **argv[]) 
{
    (*argc)--;
    (*argv)++;

    if(strcmp((*argv)[0], &amp;quot;-o&amp;quot;) == 0) {
        *use_or = 1;
        (*argc)--; // skip the -o
        (*argv)++;
        check(*argc &amp;gt; 1, &amp;quot;You need words after -o.&amp;quot;);
    } else {
        *use_or = 0;
    }

    return 0;
error:
    return -1;
}

int main(int argc, char *argv[])
{
    int i = 0;
    int use_or = 1;
    glob_t files_found;

    check(argc &amp;gt; 1, &amp;quot;USAGE: logfind [-o] words&amp;quot;);

    check(parse_args(&amp;amp;use_or, &amp;amp;argc, &amp;amp;argv) == 0, &amp;quot;USAGE: logfind [-o] words&amp;quot;);

    check(list_files(&amp;amp;files_found) == 0, &amp;quot;Failed to list files.&amp;quot;);

    for(i = 0; i &amp;lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], use_or, argc, argv);
    }

    globfree(&amp;amp;files_found);
    return 0;

error:
    return 1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex27\logfind.5\Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind MAX_LINE
    ./logfind error MAX LINE
    ./logfind -o error MAX LINE

clean:
    rm -f logfind

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;logfind.5&lt;/p&gt;

&lt;p&gt;.\ex27\logfind.5\logfind.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define NDEBUG
#include &amp;quot;dbg.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;glob.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;

const size_t MAX_LINE = 1024;

int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&amp;quot;.logfind&amp;quot;, &amp;quot;r&amp;quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &amp;quot;Invalid glob_t given.&amp;quot;);
    check_mem(line);
    check(file, &amp;quot;Failed to open .logfind. Make that first.&amp;quot;);

    while(fgets(line, MAX_LINE-1, file) != NULL) {
        size_t line_length = strnlen(line, MAX_LINE - 1);
        assert(line_length &amp;lt; MAX_LINE &amp;amp;&amp;amp; &amp;quot;Got a line length too long.&amp;quot;);

        line[line_length] = &#39;\0&#39;; // drop the \n ending
        debug(&amp;quot;Globbing %s&amp;quot;, line);

        rc = glob(line, glob_flags, NULL, pglob);
        check(rc == 0 || rc == GLOB_NOMATCH, &amp;quot;Failed to glob.&amp;quot;);

        // dumb work around to a stupid design in glob
        if(glob_flags == GLOB_TILDE) glob_flags |= GLOB_APPEND;
    }

    for(i = 0; i &amp;lt; pglob-&amp;gt;gl_pathc; i++) {
        debug(&amp;quot;Matched file: %s&amp;quot;, pglob-&amp;gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int found_it(int use_or, int found_count, int search_len)
{
    debug(&amp;quot;use_or: %d, found_count: %d, search_len: %d&amp;quot;, use_or, found_count, search_len);

    if(use_or &amp;amp;&amp;amp; found_count &amp;gt; 0) {
        return 1;
    } else if(!use_or &amp;amp;&amp;amp; found_count == search_len) {
        return 1;
    } else {
        return 0;
    }
}

int scan_file(const char *filename, int use_or, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &amp;quot;r&amp;quot;);
    int found_count = 0;
    int i = 0;

    check_mem(line);
    check(file, &amp;quot;Failed to open file: %s&amp;quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL)
    {
        for(i = 0; i &amp;lt; search_len; i++) {
            if(strcasestr(line, search_for[i]) != NULL) {
                debug(&amp;quot;file: %s, line: %s, search: %s&amp;quot;, filename, line, search_for[i]);
                found_count++;
            }
        }

        if(found_it(use_or, found_count, search_len)) {
            printf(&amp;quot;%s\n&amp;quot;, filename);
            break;
        } else {
            found_count = 0;
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int parse_args(int *use_or, int *argc, char **argv[]) 
{
    (*argc)--;
    (*argv)++;

    if(strcmp((*argv)[0], &amp;quot;-o&amp;quot;) == 0) {
        *use_or = 1;
        (*argc)--; // skip the -o
        (*argv)++;
        check(*argc &amp;gt; 1, &amp;quot;You need words after -o.&amp;quot;);
    } else {
        *use_or = 0;
    }

    return 0;
error:
    return -1;
}

int main(int argc, char *argv[])
{
    int i = 0;
    int use_or = 1;
    glob_t files_found;

    check(argc &amp;gt; 1, &amp;quot;USAGE: logfind [-o] words&amp;quot;);

    check(parse_args(&amp;amp;use_or, &amp;amp;argc, &amp;amp;argv) == 0, &amp;quot;USAGE: logfind [-o] words&amp;quot;);

    check(list_files(&amp;amp;files_found) == 0, &amp;quot;Failed to list files.&amp;quot;);

    for(i = 0; i &amp;lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], use_or, argc, argv);
    }

    globfree(&amp;amp;files_found);
    return 0;

error:
    return 1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex27\logfind.5\Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind MAX_LINE
    ./logfind error MAX LINE
    ./logfind -o error MAX LINE

clean:
    rm -f logfind

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Read The Book&lt;/p&gt;

&lt;p&gt;This video is a demonstration of the concepts in the book.&lt;/p&gt;

&lt;p&gt;Go read the book.&lt;/p&gt;

&lt;p&gt;Demonstration&lt;/p&gt;

&lt;p&gt;I will demonstrate each of the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fail early and openly.&lt;/li&gt;
&lt;li&gt;Document assumptions.&lt;/li&gt;
&lt;li&gt;Prevention over documentation.&lt;/li&gt;
&lt;li&gt;Automate everything.&lt;/li&gt;
&lt;li&gt;Simplify and clarify.&lt;/li&gt;
&lt;li&gt;Question authority.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fail Early and Openly&lt;/p&gt;

&lt;p&gt;Document Assumptions&lt;/p&gt;

&lt;p&gt;Prevention over Documentation&lt;/p&gt;

&lt;p&gt;Automate Everything&lt;/p&gt;

&lt;p&gt;Simplify and Clarify&lt;/p&gt;

&lt;p&gt;Question Authority&lt;/p&gt;

&lt;p&gt;Bonus: Assume Nothing&lt;/p&gt;

&lt;h2 id=&#34;exercise-28-intermediate-makefiles:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 28 Intermediate Makefiles&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Learn how to create a project skeleton to make starting easier.&lt;/li&gt;
&lt;li&gt;Learn more advanced GNU make tricks.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Skeleton&lt;/p&gt;

&lt;p&gt;.\ex28\c-skeleton&lt;/p&gt;

&lt;p&gt;.\ex28\c-skeleton\src\dbg.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifndef __dbg_h__
#define __dbg_h__

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &amp;quot;DEBUG %s:%d: &amp;quot; M &amp;quot;\n&amp;quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &amp;quot;None&amp;quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &amp;quot;[ERROR] (%s:%d: errno: %s) &amp;quot; M &amp;quot;\n&amp;quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &amp;quot;[WARN] (%s:%d: errno: %s) &amp;quot; M &amp;quot;\n&amp;quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &amp;quot;[INFO] (%s:%d) &amp;quot; M &amp;quot;\n&amp;quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &amp;quot;Out of memory.&amp;quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex28\c-skeleton\src\libex29.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;quot;dbg.h&amp;quot;

int print_a_message(const char *msg)
{
    printf(&amp;quot;A STRING: %s\n&amp;quot;, msg);

    return 0;
}

int uppercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != &#39;\0&#39;; i++) {
        printf(&amp;quot;%c&amp;quot;, toupper(msg[i]));
    }

    printf(&amp;quot;\n&amp;quot;);

    return 0;
}

int lowercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != &#39;\0&#39;; i++) {
        printf(&amp;quot;%c&amp;quot;, tolower(msg[i]));
    }

    printf(&amp;quot;\n&amp;quot;);

    return 0;
}

int fail_on_purpose(const char *msg)
{
    return 1;
} 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex28\c-skeleton\tests\libex29_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;minunit.h&amp;quot;
#include &amp;lt;dlfcn.h&amp;gt;

typedef int (*lib_function) (const char *data);
char *lib_file = &amp;quot;build/libYOUR_LIBRARY.so&amp;quot;;
void *lib = NULL;

int check_function(const char *func_to_run, const char *data,
        int expected)
{
    lib_function func = dlsym(lib, func_to_run);
    check(func != NULL,
            &amp;quot;Did not find %s function in the library %s: %s&amp;quot;, func_to_run,
            lib_file, dlerror());

    int rc = func(data);
    check(rc == expected, &amp;quot;Function %s return %d for data: %s&amp;quot;,
            func_to_run, rc, data);

    return 1;
error:
    return 0;
}

char *test_dlopen()
{
    lib = dlopen(lib_file, RTLD_NOW);
    mu_assert(lib != NULL, &amp;quot;Failed to open the library to test.&amp;quot;);

    return NULL;
}

char *test_functions()
{
    mu_assert(check_function(&amp;quot;print_a_message&amp;quot;, &amp;quot;Hello&amp;quot;, 0),
            &amp;quot;print_a_message failed.&amp;quot;);
    mu_assert(check_function(&amp;quot;uppercase&amp;quot;, &amp;quot;Hello&amp;quot;, 0),
            &amp;quot;uppercase failed.&amp;quot;);
    mu_assert(check_function(&amp;quot;lowercase&amp;quot;, &amp;quot;Hello&amp;quot;, 0),
            &amp;quot;lowercase failed.&amp;quot;);

    return NULL;
}

char *test_failures()
{
    mu_assert(check_function(&amp;quot;fail_on_purpose&amp;quot;, &amp;quot;Hello&amp;quot;, 1),
            &amp;quot;fail_on_purpose should fail.&amp;quot;);

    return NULL;
}

char *test_dlclose()
{
    int rc = dlclose(lib);
    mu_assert(rc == 0, &amp;quot;Failed to close lib.&amp;quot;);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dlopen);
    mu_run_test(test_functions);
    mu_run_test(test_failures);
    mu_run_test(test_dlclose);

    return NULL;
}

RUN_TESTS(all_tests);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The video is probably easier to follow than the book.
Watch me do this.&lt;/p&gt;

&lt;p&gt;Using The Skeleton&lt;/p&gt;

&lt;p&gt;.\ex28\c-skeleton&lt;/p&gt;

&lt;p&gt;.\ex28\c-skeleton\src\dbg.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifndef __dbg_h__
#define __dbg_h__

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &amp;quot;DEBUG %s:%d: &amp;quot; M &amp;quot;\n&amp;quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &amp;quot;None&amp;quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &amp;quot;[ERROR] (%s:%d: errno: %s) &amp;quot; M &amp;quot;\n&amp;quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &amp;quot;[WARN] (%s:%d: errno: %s) &amp;quot; M &amp;quot;\n&amp;quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &amp;quot;[INFO] (%s:%d) &amp;quot; M &amp;quot;\n&amp;quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &amp;quot;Out of memory.&amp;quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex28\c-skeleton\src\libex29.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;quot;dbg.h&amp;quot;

int print_a_message(const char *msg)
{
    printf(&amp;quot;A STRING: %s\n&amp;quot;, msg);

    return 0;
}

int uppercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != &#39;\0&#39;; i++) {
        printf(&amp;quot;%c&amp;quot;, toupper(msg[i]));
    }

    printf(&amp;quot;\n&amp;quot;);

    return 0;
}

int lowercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != &#39;\0&#39;; i++) {
        printf(&amp;quot;%c&amp;quot;, tolower(msg[i]));
    }

    printf(&amp;quot;\n&amp;quot;);

    return 0;
}

int fail_on_purpose(const char *msg)
{
    return 1;
} 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex28\c-skeleton\tests\libex29_tests.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;minunit.h&amp;quot;
#include &amp;lt;dlfcn.h&amp;gt;

typedef int (*lib_function) (const char *data);
char *lib_file = &amp;quot;build/libYOUR_LIBRARY.so&amp;quot;;
void *lib = NULL;

int check_function(const char *func_to_run, const char *data,
        int expected)
{
    lib_function func = dlsym(lib, func_to_run);
    check(func != NULL,
            &amp;quot;Did not find %s function in the library %s: %s&amp;quot;, func_to_run,
            lib_file, dlerror());

    int rc = func(data);
    check(rc == expected, &amp;quot;Function %s return %d for data: %s&amp;quot;,
            func_to_run, rc, data);

    return 1;
error:
    return 0;
}

char *test_dlopen()
{
    lib = dlopen(lib_file, RTLD_NOW);
    mu_assert(lib != NULL, &amp;quot;Failed to open the library to test.&amp;quot;);

    return NULL;
}

char *test_functions()
{
    mu_assert(check_function(&amp;quot;print_a_message&amp;quot;, &amp;quot;Hello&amp;quot;, 0),
            &amp;quot;print_a_message failed.&amp;quot;);
    mu_assert(check_function(&amp;quot;uppercase&amp;quot;, &amp;quot;Hello&amp;quot;, 0),
            &amp;quot;uppercase failed.&amp;quot;);
    mu_assert(check_function(&amp;quot;lowercase&amp;quot;, &amp;quot;Hello&amp;quot;, 0),
            &amp;quot;lowercase failed.&amp;quot;);

    return NULL;
}

char *test_failures()
{
    mu_assert(check_function(&amp;quot;fail_on_purpose&amp;quot;, &amp;quot;Hello&amp;quot;, 1),
            &amp;quot;fail_on_purpose should fail.&amp;quot;);

    return NULL;
}

char *test_dlclose()
{
    int rc = dlclose(lib);
    mu_assert(rc == 0, &amp;quot;Failed to close lib.&amp;quot;);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dlopen);
    mu_run_test(test_functions);
    mu_run_test(test_failures);
    mu_run_test(test_dlclose);

    return NULL;
}

RUN_TESTS(all_tests);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I&amp;rsquo;ll use the skeleton to start a simple project for the next exercise.&lt;/p&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at Makefile in depth.&lt;/p&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;h2 id=&#34;exercise-29-libraries-and-linking:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 29 Libraries and Linking&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Learn about libraries and how to link against them.&lt;/li&gt;
&lt;li&gt;Learn how to load a dynamic library from inside C.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex29\ex29.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;dbg.h&amp;quot;
#include &amp;lt;dlfcn.h&amp;gt;

typedef int (*lib_function) (const char *data);

int main(int argc, char *argv[])
{
    int rc = 0;
    check(argc == 4, &amp;quot;USAGE: ex29 libex29.so function data&amp;quot;);

    char *lib_file = argv[1];
    char *func_to_run = argv[2];
    char *data = argv[3];

    void *lib = dlopen(lib_file, RTLD_NOW);
    check(lib != NULL, &amp;quot;Failed to open the library %s: %s&amp;quot;, lib_file,
            dlerror());

    lib_function func = dlsym(lib, func_to_run);
    check(func != NULL,
            &amp;quot;Did not find %s function in the library %s: %s&amp;quot;, func_to_run,
            lib_file, dlerror());

    rc = func(data);
    check(rc == 0, &amp;quot;Function %s return %d for data: %s&amp;quot;, func_to_run,
            rc, data);

    rc = dlclose(lib);
    check(rc == 0, &amp;quot;Failed to close %s&amp;quot;, lib_file);

    return 0;

error:
    return 1;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.\ex29\libex29.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;quot;dbg.h&amp;quot;

int print_a_message(const char *msg)
{
    printf(&amp;quot;A STRING: %s\n&amp;quot;, msg);

    return 0;
}

int uppercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != &#39;\0&#39;; i++) {
        printf(&amp;quot;%c&amp;quot;, toupper(msg[i]));
    }

    printf(&amp;quot;\n&amp;quot;);

    return 0;
}

int lowercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != &#39;\0&#39;; i++) {
        printf(&amp;quot;%c&amp;quot;, tolower(msg[i]));
    }

    printf(&amp;quot;\n&amp;quot;);

    return 0;
}

int fail_on_purpose(const char *msg)
{
    return 1;
} 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ll use the project I started from the previous exercise.
This covers some of the extra credit.&lt;/p&gt;

&lt;p&gt;The Analysis&lt;/p&gt;

&lt;p&gt;This analysis might take a while, but be sure you know Exercise 28 well.&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Wreck the libex29.so file.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Were you paying attention to the bad code I have in the &lt;code&gt;libex29.c&lt;/code&gt; functions?
Do you see how, even though I use a for-loop they still check for &lt;code&gt;&#39;\0&#39;&lt;/code&gt;
endings?  Fix this so that the functions always take a length for the
string to work with inside the function.&lt;/li&gt;
&lt;li&gt;Read the &lt;code&gt;man dlopen&lt;/code&gt; documentation and read about all of the
related functions.  Try some of the other options to &lt;code&gt;dlopen&lt;/code&gt;
beside &lt;code&gt;RTLD_NOW&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-30-automated-testing:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 30 Automated Testing&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;p&gt;Continue the Exercise 28-29 project and add automated tests to it.&lt;/p&gt;

&lt;p&gt;Why Automate Tests&lt;/p&gt;

&lt;p&gt;You are a programmer.
Your job is automating.&lt;/p&gt;

&lt;p&gt;EVERYTHING&lt;/p&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex30\ex30.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;minunit.h&amp;quot;

char *test_dlopen(int stuff)
{
    return NULL;
}

char *test_functions()
{

    return NULL;
}

char *test_failures()
{

    return NULL;
}

char *test_dlclose()
{

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dlopen);
    mu_run_test(test_functions);
    mu_run_test(test_failures);
    mu_run_test(test_dlclose);

    return NULL;
}

RUN_TESTS(all_tests);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding It To libex29&lt;/p&gt;

&lt;p&gt;Breaking It&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Making tests fail first is useful.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This works but it&amp;rsquo;s probably a bit messy.  Clean the &lt;code&gt;c-skeleton&lt;/code&gt;
directory up so that it has all of these files, but remove any of the code
related to Exercise 29.  You should be able to copy this directory
over and kick-start new projects without much editing.&lt;/li&gt;
&lt;li&gt;Study the &lt;code&gt;runtests.sh&lt;/code&gt;, and then go read about &lt;code&gt;bash&lt;/code&gt; syntax
so you know what it does.  Do you think you could write a C version of this
script?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercise-31-common-undefined-behavior:06d16f732872ca3bc0c61ecd506df70f&#34;&gt;Exercise 31 Common Undefined Behavior&lt;/h2&gt;

&lt;p&gt;The Plan&lt;/p&gt;

&lt;p&gt;Review the issues around Undefined and Unspecified Behavior (UB).&lt;/p&gt;

&lt;p&gt;Read The Book&lt;/p&gt;

&lt;p&gt;The book lists many of the UB and discusses why they are important to know
about.&lt;/p&gt;

&lt;p&gt;The Code&lt;/p&gt;

&lt;p&gt;.\ex31\ex31.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;unistd.h&amp;gt;

int main(int argc, char *argv[])
{
    int i = 0;

    while (i &amp;lt; 100) {
        usleep(3000);
    }

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no code for this exercise, just a quick discussion for the book.&lt;/p&gt;

&lt;p&gt;Undefined Behavior&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Compiler writers can do whatever they want.&lt;/li&gt;
&lt;li&gt;This means even &lt;em&gt;nothing&lt;/em&gt;, which will ruin you silently.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s best to avoid it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unspecified Behavior&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For practical purposes unspecified is the same as undefined.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Handy Tools&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clang&amp;rsquo;s UB helpful flags.&lt;/li&gt;
&lt;li&gt;Lint tools and static analyzers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extra Credit&lt;/p&gt;

&lt;p&gt;Spend a day reading through as much of the UB as you can and find examples of each.  Expect lots of frustration and failure when you do this.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>