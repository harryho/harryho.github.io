<!DOCTYPE html> 
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="google-site-verification" content="fB00vw3NhrcDODZ6PcjUHM1Pz1j4T-eZ0Ja7ffDx-aU" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="alternate" href="/index.xml" type="application/rss+xml" title="Hello World">
    <link rel="icon" href="https://harryho.github.io/favicon.ico">
    <title>LCTHW Lectures - Hello World</title>
    
    <link rel="stylesheet" href="https://harryho.github.io/css/highlight/github.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/theme.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/bootie-docs.css">
</head>

<body role="document">
    
    <nav class="navbar navbar-inverse navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://harryho.github.io/">Hello World</a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li ><a href="https://harryho.github.io/">Home</a></li>
                       
                    <li ><a href="https://harryho.github.io/info/">Info</a></li>
                     
                    <li ><a href="https://harryho.github.io/code/">Code</a></li>
                     
                    <li ><a href="https://harryho.github.io/dev/">Dev</a></li>
                     
                    <li ><a href="https://harryho.github.io/os/">OS</a></li>
                     
                    <li ><a href="https://harryho.github.io/project/">Project</a></li>
                      
                </ul>
                
                <form class="navbar-form navbar-left" role="search" action="https://www.google.co.jp/search" method="get">
                    <div class="input-group doc-search-form">
                        <input type="hidden" name="as_sitesearch" value="harryho.github.io">
                        <input type="text" name="as_q" class="search-query doc-search-input-text" placeholder="Search Site">
                        <span class="input-group-addon input-group-btn doc-search-input-btn " >
							<button class="btn" type="submit"><span class="glyphicon glyphicon-search"></span></button>
                        </span>
                    </div>
                </form>
                
            </div>
            
        </div>
    </nav>
    <div class="container">


<div class="row">
	<div class="col-sm-8 doc-main">
		<main role="main">
			<article>
				<a id="title"></a>
				<h1 class="doc-entry-title">LCTHW Lectures</h1>
				<div class="doc-entry-meta">
					
				</div>
				<section>
					

<p>Author: Zed A. Shaw</p>

<p>All content comes from Zed&rsquo;s <a href="https://github.com/zedshaw/learn-c-the-hard-way-lectures.git">Repository</a>. All credit goes to Zed.</p>

<h2 id="exercise-0-installing-software">Exercise 0 Installing Software</h2>

<p>The Plan</p>

<ul>
<li>Install software on your system.</li>
<li>Test that it works right.</li>
</ul>

<p>Linux Install</p>

<p>On Debian/Ubuntu use:</p>

<pre><code>$ sudo apt-get install build-essential
</code></pre>

<p>On RedHat/CentOS:</p>

<pre><code>$ sudo yum groupinstall development-tools
</code></pre>

<p>Linux Testing</p>

<p>Test that your C compiler works with:</p>

<pre><code>$ cc --version
</code></pre>

<p>OSX Install</p>

<p>Install <a href="https://developer.apple.com/xcode/">XCode</a>, this will take a while.</p>

<p>OSX Testing</p>

<p>Test that your C compiler works with:</p>

<pre><code>$ cc --version
</code></pre>

<p>Windows Install</p>

<p>Install <a href="http://www.mingw.org/">MinGW</a> or <a href="https://www.cygwin.com/">Cygwin</a> or Use <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a> to run Linux.</p>

<p>Text Editors</p>

<p>You should already have one.
Just don&rsquo;t use an IDE. They aren&rsquo;t very helpful.</p>

<p>End of Lecture 0</p>

<h2 id="exercise-1-dust-off-that-compiler">Exercise 1 Dust Off That Compiler</h2>

<p>The Plan</p>

<ul>
<li>Write your first C program.</li>
<li>Build it.</li>
<li>Break it.</li>
</ul>

<p>The Code</p>

<p>.\ex01\ex1.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

/* This is a comment. */
int main(int argc, char *argv[])
{
    int distance = 100;

    // this is also a comment
    printf(&quot;You are %d miles away.\n&quot;, distance);

    return 0;
}

</code></pre>

<p>.\ex01\ex1_zed.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

/* This is a comment. */
int main(int argc, char *argv[])
{
    int distance = 100;

    // this is also a comment
    printf(&quot;You are %d miles away.\n&quot;);

    return 0;
}
</code></pre>

<p>The Analysis</p>

<p>Let&rsquo;s look at it line-by-line.</p>

<p>Breaking It</p>

<p>This is all crazy magic right now.</p>

<p>Extra Credit</p>

<ul>
<li>Open the <code>ex1</code> file in your text editor and change or delete random parts. Try running it and see what happens.</li>
<li>Print out five more lines of text or something more complex than &ldquo;hello world.&rdquo;</li>
<li>Run <code>man 3 printf</code> and read about this function and many others.</li>
<li>For each line, write out the symbols you don&rsquo;t understand and see if you can guess what they mean.  Write a little chart on paper with your guess so you can check it later to see if you got it right.</li>
</ul>

<h2 id="exercise-2-using-makefiles-to-build">Exercise 2 Using Makefiles to Build</h2>

<p>The Plan</p>

<ul>
<li>Start with simple make usage.</li>
<li>Set a few important settings.</li>
</ul>

<p>How Make Works</p>

<p>Implied dependencies and ancient lore.</p>

<p>Shell Commands</p>

<pre><code>$ make ex1
# or this one too
$ CFLAGS=&quot;-Wall&quot; make ex1
$ make clean
$ make ex1
</code></pre>

<p>Makefile</p>

<pre><code>CFLAGS=-Wall -g

clean:
    rm -f ex1
</code></pre>

<p>The Analysis</p>

<ul>
<li>Setting options.</li>
<li>Indicating dependencies.</li>
<li>Writing commends to run.</li>
</ul>

<p>Breaking It</p>

<ul>
<li>Watch out for tabs vs. spaces.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Create an <em>all: ex1</em> target that will build <em>ex1</em> with
just the command <em>make</em>.</li>
<li>Read <em>man make</em> to find out more information on how to run it.</li>
<li>Read <em>man cc</em> to find out more information on what the flags <em>-Wall</em> and <em>-g</em> do.</li>
<li>Research <em>Makefiles</em> online and see if you can improve this one.</li>
<li>Find a <em>Makefile</em> in another C project and try to understand
what it&rsquo;s doing.</li>
</ul>

<h2 id="exercise-3-formatted-printing">Exercise 3 Formatted Printing</h2>

<p>The Plan</p>

<ul>
<li>Introduction to <em>printf</em>.</li>
</ul>

<p>The Code</p>

<p>.\ex03\ex3.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int age = 100;
    int height = 72;

    printf(&quot;I am %d years old.\n&quot;, argv);
    printf(&quot;I am %d inches tall.\n&quot;, height);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Take the <em>age</em> variable out of the first <em>printf</em> call, then recompile. You should get a couple of warnings.</li>
<li>Run this new program and it will either crash or print out a really crazy age.</li>
<li>Put the <em>printf</em> back the way it was, and then don&rsquo;t set <em>age</em> to an initial value by changing that line to <em>int age;</em>, and then rebuild it and run it again.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Find as many other ways to break <em>ex3.c</em> as you can.</li>
<li>Run <em>man 3 printf</em> and read about the other <em>%</em> format
characters you can use.  These should look familiar if you used
them in other languages (they come from <em>printf</em>).</li>
<li>Add <em>ex3</em> the <em>all</em> list in your <em>Makefile</em>.  Use this
to <em>make clean all</em> and build all of your exercises thus far.</li>
<li>Add <em>ex3</em> to your <em>clean</em> list in your<em>Makefile</em> as well.
Use <em>make clean</em> to remove it when you need to.</li>
</ul>

<h2 id="exercise-4-using-a-debugger">Exercise 4 Using a Debugger</h2>

<p>The Plan</p>

<ul>
<li>See how GDB works (LLDB on OSX).</li>
<li>Look at memory checkers like Valgrind and AddressSanitizer.</li>
<li>Cover the quick reference.</li>
<li>Debug a program.</li>
</ul>

<p>Using GDB</p>

<p>Using LLDB</p>

<p>Using Valgrind</p>

<p>Using Lint</p>

<p>Using AddressSanitizer</p>

<p>You neeed clang for this.</p>

<p>&ldquo;The Debugger&rdquo;</p>

<p>When I say &ldquo;the debugger&rdquo; in the book I mean to use GDB, but use
every tool you can find that helps.</p>

<h2 id="exercise-5-memorizing-c-operators">Exercise 5 Memorizing C Operators</h2>

<p>The Plan</p>

<ul>
<li>Learn why memorizing works.</li>
<li>Learn how to memorize things.</li>
<li>Review the C operators.</li>
</ul>

<p>Memorization</p>

<ul>
<li>A &ldquo;backdoor&rdquo; hack to learning.</li>
<li>Memorize the operators, then reading is easier.</li>
<li>Works with any language.</li>
</ul>

<p>Memorization Proces</p>

<ul>
<li>Write everything on index cards.</li>
<li>Use Anki, but make your own cards.</li>
<li>Spend 30-60 minutes a day.</li>
<li>Track what you don&rsquo;t know, drill those more.</li>
</ul>

<p>Arithmetic Operators</p>

<pre><code>+    Add
-    Subtract
*    Multiply
/    Divide
%    Modulus
++   Increment
--   Decrement
</code></pre>

<p>Relational Operators</p>

<pre><code>==   Equal
!=   Not equal
&gt;    Greater than
&lt;    Less than
&gt;=   Greater than equal
&lt;=   Less than equal
</code></pre>

<p>Logical Operators</p>

<pre><code>&amp;&amp;   Logical and
||   Logical or
!    Logical not
? :  Logical ternary
</code></pre>

<p>Bitwise Operators</p>

<pre><code>&amp;    Bitwise and
|    Bitwise or
^    Bitwise xor
~    Bitwise ones compliment
&lt;&lt;   Bitwise shift left
&gt;&gt;   Bitwise shift right
</code></pre>

<p>Assignment Operators</p>

<pre><code>=    Assign equal
+=   Assign plus-equal
-=   Assign minus-equal
*=   Assign multiply-equal
/=   Assign divide-equal
%=   Assign modulus-equal
&lt;&lt;=  Assign shift-left-equal
&gt;&gt;=  Assign shift-right-equal
&amp;=   Assign and-equal
^=   Assign xor-equal
|=   Assign or-equal
</code></pre>

<p>Data Operators</p>

<pre><code>sizeof() Get the size of
[]       Array subscript
&amp;        The address of
*        The value of
-&gt;       Structure dereference
.        Structure reference
</code></pre>

<p>Miscellaneous Operators</p>

<pre><code>,         Comma
( )       Parenthesis
{ }       Braces
:         Colon
//        Single-line comment start
/*        Multi-line comment start
*/        Multi-line comment end
</code></pre>

<h2 id="exercise-6-memorizing-c-syntax">Exercise 6 Memorizing C Syntax</h2>

<p>The Plan</p>

<ul>
<li>Memorize the keywords of C.</li>
<li>Memorize the major syntax forms.</li>
</ul>

<p>Execution Keywords
    break     Exit out of a compound statement.
    case      A branch in a switch-statement.
    continue  Continue to the top of a loop.
    do        Start a do-while loop.
    default   Default branch in a switch-statement.
    else      An else branch of an if-statement.
    for       Start a for-loop.
    goto      Jump to a label.
    if        Starts an if-statement.
    return    Return from a function.
    switch    Start a switch-statement.
    while     Start a while-loop.</p>

<p>Type Keywords
    char      Character data type.
    double    A double floating point data type.
    float     A floating point data type.
    int       An integer data type.
    long      A long integer data type.
    short     A short integer data type.
    void      Declare a data type empty.
    union     Start a union-statement.
    struct    Combine variables into a single record.</p>

<p>Data Keywords</p>

<pre><code>auto      Give a local variable a local lifetime.
const     Make a variable unmodifiable.
enum      Define a set of int constants.
extern    Declare an identifier is defined externally.
register  Declare a variable be stored in a CPU register.
signed    A signed modifier for integer data types.
sizeof    Determine the size of data.
static    Preserve variable value after its scope exits.
typedef   Create a new type.
unsigned  An unsigned modifier for integer data types.
volatile  Declare a variable might be modified elsewhere.
</code></pre>

<p>If-Statement</p>

<pre><code>if(TEST) {
    CODE;
} else if(TEST) {
    CODE;
} else {
    CODE;
}
</code></pre>

<p>Switch-Statement</p>

<pre><code>switch (OPERAND) {
    case CONSTANT:
        CODE;
        break;
    default:
        CODE;
}
</code></pre>

<p>While-Loop</p>

<pre><code>while(TEST) {
    CODE;
}
</code></pre>

<p>While with Continue</p>

<pre><code>while(TEST) {
    if(OTHER_TEST) {
        continue;
    }
    CODE;
}
</code></pre>

<p>While with Break</p>

<pre><code>while(TEST) {
    if(OTHER_TEST) {
        break;
    }
    CODE;
}
</code></pre>

<p>Do-While</p>

<pre><code>do {
    CODE;
} while(TEST);
</code></pre>

<p>For-Loop</p>

<pre><code>for(INIT; TEST; POST) {
    CODE;
}
</code></pre>

<ul>
<li><em>continue</em> and <em>break</em> work with <em>for</em></li>
</ul>

<p>Enum</p>

<pre><code>enum { CONST1, CONST2, CONST3 } NAME;
</code></pre>

<p>Goto</p>

<pre><code>if(ERROR_TEST) {
    goto fail;
}

fail:
    CODE;
</code></pre>

<p>Functions</p>

<pre><code>TYPE NAME(ARG1, ARG2, ..) {
    CODE;
    return VALUE;
}
</code></pre>

<p>Typedef</p>

<pre><code>typedef DEFINITION IDENTIFIER;


typedef unsigned char byte;
</code></pre>

<p>Struct</p>

<pre><code>struct NAME {
    ELEMENTS;
} [VARIABLE_NAME];
</code></pre>

<p>Typedef Struct</p>

<pre><code>typedef struct [STRUCT_NAME] {
    ELEMENTS;
} IDENTIFIER;
</code></pre>

<p>Union</p>

<pre><code>union NAME {
    ELEMENTS;
} [VARIABLE_NAME];
</code></pre>

<h2 id="exercise-7-variables-and-types">Exercise 7 Variables and Types</h2>

<p>The Plan</p>

<ul>
<li>Learn some basic variables and types.</li>
<li>int, float, double, char, and strings.</li>
</ul>

<p>The Code</p>

<p>.\ex07\ex7.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int distance = 100;
    float power = 2.345f;
    double super_power = 56789.4532;
    char initial = 'A';
    char first_name[] = &quot;Zed&quot;;
    char last_name[] = &quot;Shaw&quot;;

    first_name[3] = 'Z';

    printf(&quot;You are %d miles away.\n&quot;, distance);
    printf(&quot;You have %f levels of power.\n&quot;, power);
    printf(&quot;You have %f awesome super powers.\n&quot;, super_power);
    printf(&quot;I have an initial %c.\n&quot;, initial);
    printf(&quot;I have a first name %s.\n&quot;, first_name);
    printf(&quot;I have a last name %s.\n&quot;, last_name);
    printf(&quot;My whole name is %s %c. %s.\n&quot;,
            first_name, initial, last_name);

    int bugs = 100;
    double bug_rate = 1.2;

    printf(&quot;You have %d bugs at the imaginary rate of %f.\n&quot;,
            bugs, bug_rate);

    long universe_of_defects = 1L * 1024L * 1024L * 1024L;
    printf(&quot;The entire universe has %ld bugs.\n&quot;, universe_of_defects);

    double expected_bugs = bugs * bug_rate;
    printf(&quot;You are expected to have %f bugs.\n&quot;, expected_bugs);

    double part_of_universe = expected_bugs / universe_of_defects;
    printf(&quot;That is only a %e portion of the universe.\n&quot;,
            part_of_universe);

    // this makes no sense, just a demo of something weird
    char nul_byte = '\0';
    int care_percentage = bugs * nul_byte;
    printf(&quot;Which means you should care %d%%.\n&quot;, care_percentage);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Strings give us so much more fun now!</li>
<li>Crafting bad strings.</li>
<li>Messing with pointers.</li>
<li>Abusing printf.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Make the number you assign to <em>universe_of_defects</em> various
sizes until you get a warning from the compiler.</li>
<li>What do these really huge numbers actually print out?</li>
<li>Change <em>long</em> to <em>unsigned long</em> and try to find
the number that makes it too big.</li>
<li>Go search online to find out what <em>unsigned</em> does.</li>
<li>Try to explain to yourself (before I do in the next exercise)
why you can multiply a <em>char</em> and an <em>int</em>.</li>
</ul>

<h2 id="exercise-8-if-else-if-else">Exercise 8 If, Else-If, Else</h2>

<p>The Plan</p>

<p>Simply learn to use this:</p>

<pre><code>if(TEST) {
    CODE;
} else if(TEST) {
    CODE;
} else {
    CODE;
}
</code></pre>

<p>The Code</p>

<p>.\ex08\ex8.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int i = 0;

    if (argc == 1) {
        printf(&quot;You only have one argument. You suck.\n&quot;);
    } else if (argc &gt; 1 &amp;&amp; argc &lt; 4) {
        printf(&quot;Here's your arguments:\n&quot;);

        for (i = 0; i &lt; argc; i++) {
            printf(&quot;%s &quot;, argv[i]);
        }
        printf(&quot;\n&quot;);
    } else if (argc &gt; 10) {
        printf(&quot;You have too many arguments. You suck.\n&quot;);
    }

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>It kind of just works, but remove the <em>else</em> and change the logic.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>You were briefly introduced to <em>&amp;&amp;</em>, which does an <em>and</em> comparison,
so go research online the different <em>Boolean operators</em>.</li>
<li>Write a few more test cases for this program to see what you can come
up with.</li>
</ul>

<h2 id="exercise-9-while-loop-and-boolean-expressions">Exercise 9 While-Loop and Boolean Expressions</h2>

<p>The Plan</p>

<p>You first loop shall be the <em>while</em>:</p>

<pre><code>while(TEST) {
    CODE;
}
</code></pre>

<p>The Code</p>

<p>.\ex09\ex9.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int i;
    while (i &lt; 25) {
        printf(&quot;%d\n&quot;, i);
        i++;
    }

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Forget to initialize the <em>int i</em>.</li>
<li>Forget to do an i++ and make it run forever.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Make the loop count backward by using <code>i--</code> to start
at 25 and go to 0.</li>
<li>Write a few more complex <code>while-loops</code> using what you know
so far.</li>
</ul>

<h2 id="exercise-10-switch-statements">Exercise 10 Switch Statements</h2>

<p>The Plan</p>

<ul>
<li>Learn about the <em>switch-statement</em> and indirectly jump tables.</li>
<li>Write a program that takes a command line argument.</li>
</ul>

<p>The Code</p>

<p>.\ex10\ex10.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    if (argc != 2) {
        printf(&quot;ERROR: You need one argument.\n&quot;);
        // this is how you abort a program
        return 1;
    }

    int i = 0;
    for (i = 0; argv[1][i] != '\0'; i++) {
        char letter = argv[1][i];

        switch (letter) {
            case 'a':
            case 'A':
                printf(&quot;%d: 'A'\n&quot;, i);
                break;

            case 'e':
            case 'E':
                printf(&quot;%d: 'E'\n&quot;, i);
                break;

            case 'i':
            case 'I':
                printf(&quot;%d: 'I'\n&quot;, i);
                break;

            case 'o':
            case 'O':
                printf(&quot;%d: 'O'\n&quot;, i);
                break;

            case 'u':
            case 'U':
                printf(&quot;%d: 'U'\n&quot;, i);
                break;

            case 'y':
            case 'Y':
                if (i &gt; 2) {
                    // it's only sometimes Y
                    printf(&quot;%d: 'Y'\n&quot;, i);
                }
                break;

            default:
                printf(&quot;%d: %c is not a vowel\n&quot;, i, letter);
        }
    }

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Let&rsquo;s talk about jump tables, in the naive sense.</p>

<p>Breaking It</p>

<ul>
<li>Forget a <em>break</em>, and it&rsquo;ll run two or more blocks of code you don&rsquo;t want it to run.</li>
<li>Forget a <em>default</em>, and it&rsquo;ll silently ignore values you forgot.</li>
<li>Accidentally put a variable into the <em>switch</em> that evaluates to something unexpected, like an <em>int</em>, which becomes weird values.</li>
<li>Use uninitialized values in the <em>switch</em>.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Write another program that uses math on the letter to
convert it to lowercase, and then remove all of the extraneous
uppercase letters in the switch.</li>
<li>Use the <em>&rsquo;,&rsquo;</em> (comma) to initialize <em>letter</em>
in the <em>for-loop</em>.</li>
<li>Make it handle all of the arguments you pass it with
yet another <em>for-loop</em>.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Convert this <em>switch-statement</em> to an <em>if-statement</em>.
Which do you like better?</li>
<li>In the case for &lsquo;Y&rsquo; I have the break outside of the <em>if-statement</em>. What&rsquo;s the impact of this,
and what happens if you move it inside of the <em>if-statement</em>. Prove to yourself that you&rsquo;re right.</li>
</ul>

<h2 id="exercise-11-arrays-and-strings">Exercise 11 Arrays and Strings</h2>

<p>The Plan</p>

<ul>
<li>Learn the similarity between arrays and strings.</li>
<li>Avoid getting pedantic about them.</li>
<li>Learn how C stores strings and processes them.</li>
</ul>

<p>The Code</p>

<p>.\ex11\ex11.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int numbers[4] = { 0 };
    char name[4] = { 'a', 'a', 'a', 'a' };

    // first, print them out raw
    printf(&quot;numbers: %d %d %d %d\n&quot;,
            numbers[0], numbers[1], numbers[2], numbers[3]);

    printf(&quot;name each: %c %c %c %c\n&quot;,
            name[0], name[1], name[2], name[3]);

    printf(&quot;name: %s\n&quot;, name);

    // setup the numbers
    numbers[0] = 1;
    numbers[1] = 2;
    numbers[2] = 3;
    numbers[3] = 4;

    // setup the name
    name[0] = 'Z';
    name[1] = 'e';
    name[2] = 'd';
    name[3] = 'A';

    // then print them out initialized
    printf(&quot;numbers: %d %d %d %d\n&quot;,
            numbers[0], numbers[1], numbers[2], numbers[3]);

    printf(&quot;name each: %c %c %c %c\n&quot;,
            name[0], name[1], name[2], name[3]);

    // print the name like a string
    printf(&quot;name: %s\n&quot;, name);

    // another way to use name
    char *another = &quot;Zed&quot;;

    printf(&quot;another: %s\n&quot;, another);

    printf(&quot;another each: %c %c %c %c\n&quot;,
            another[0], another[1], another[2], another[3]);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<p>So many ways to break this!</p>

<ul>
<li>Get rid of the initializers that set up <em>name</em>.</li>
<li>Accidentally set <em>name[3] = &lsquo;A&rsquo;;</em> so that there&rsquo;s no terminator.</li>
<li>Set the initializer to <em>{&lsquo;a&rsquo;,&lsquo;a&rsquo;,&lsquo;a&rsquo;,&lsquo;a&rsquo;}</em> so that there are too many
&lsquo;a&rsquo; characters and no space for the <em>&lsquo;\0&rsquo;</em> terminator.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Assign the characters into <em>numbers</em>, and then use <em>printf</em>
to print them one character at a time.  What kind of compiler warnings
do you get?</li>
<li>Do the inverse for <em>name</em>, trying to treat it like an array
of <em>int</em> and print it out one <em>int</em> at a time.  What
does the debugger think of that?</li>
<li>In how many other ways can you print this out?</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>If an array of characters is 4 bytes long, and an integer is 4 bytes
long, then can you treat the whole <em>name</em> array like it&rsquo;s just
an integer?  How might you accomplish this crazy hack?</li>
<li>Take out a piece of paper and draw each of these arrays as a
row of boxes. Then do the operations you just did on paper to see
if you get them right.</li>
<li>Convert <em>name</em> to be in the style of <em>another</em> and see
if the code keeps working.</li>
</ul>

<h2 id="exercise-12-sizes-and-arrays">Exercise 12 Sizes and Arrays</h2>

<p>The Plan</p>

<ul>
<li>Learn about <em>sizeof</em> and how it relates to arrays.</li>
</ul>

<p>The Code</p>

<p>.\ex12\ex12.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int areas[] = { 10, 12, 13, 14, 20 };
    char name[] = &quot;Zed&quot;;
    char full_name[] = {
        'Z', 'e', 'd',
        ' ', 'A', '.', ' ',
        'S', 'h', 'a', 'w' 
    };

    // WARNING: On some systems you may have to change the
    // %ld in this code to a %u since it will use unsigned ints
    printf(&quot;The size of an int: %ld\n&quot;, sizeof(int));
    printf(&quot;The size of areas (int[]): %ld\n&quot;, sizeof(areas));
    printf(&quot;The number of ints in areas: %ld\n&quot;,
            sizeof(areas) / sizeof(int));
    printf(&quot;The first area is %d, the 2nd %d.\n&quot;, areas[0], areas[1]);

    printf(&quot;The size of a char: %ld\n&quot;, sizeof(char));
    printf(&quot;The size of name (char[]): %ld\n&quot;, sizeof(name));
    printf(&quot;The number of chars: %ld\n&quot;, sizeof(name) / sizeof(char));

    printf(&quot;The size of full_name (char[]): %ld\n&quot;, sizeof(full_name));
    printf(&quot;The number of chars: %ld\n&quot;,
            sizeof(full_name) / sizeof(char));

    full_name[12] = 'X';

    printf(&quot;name=\&quot;%s\&quot; and full_name=\&quot;%s\&quot;\n&quot;, name, full_name);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Get rid of the <em>&lsquo;\0&rsquo;</em> at the end of <em>full_name</em>
and re-run it.  Run it under the debugger, too.  Now, move the definition
of <em>full_name</em> to the top of <em>main</em> before <em>areas</em>.
Try running it under the debugger a few times and see if you get some
new errors.  In some cases, you might still get lucky and not catch
any errors.</li>
<li>Change it so that instead of <em>areas[0]</em> you try to
print <em>areas[10]</em>.  See what the debugger thinks of that.</li>
<li>Try other ways to break it like this, doing it to <em>name</em> and
<em>full_name</em> too.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Try assigning to elements in the <em>areas</em> array with <em>areas[0] = 100;</em> and similar.</li>
<li>Try assigning to elements of <em>name</em> and <em>full_name</em>.</li>
<li>Try setting one element of <em>areas</em> to a character from <em>name</em>.</li>
<li>Search online for the different sizes used for integers on different
CPUs.</li>
</ul>

<h2 id="exercise-13-for-loops-and-arrays-of-strings">Exercise 13 For-Loops and Arrays of Strings</h2>

<p>The Plan</p>

<p>Learn about this code:</p>

<pre><code>for(INITIALIZER; TEST; INCREMENTER) {
    CODE;
}
</code></pre>

<p>The Code</p>

<p>.\ex13\ex13.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int i = 0;

    // go through each string in argv
    // why am I skipping argv[0]?
    for (i = 0; i &lt; argc; i++) {
        printf(&quot;arg %d: %s\n&quot;, i, argv[i]);
    }

    // let's make our own array of strings
    char *states[] = {
        &quot;California&quot;, &quot;Oregon&quot;,
        &quot;Washington&quot;, &quot;Texas&quot;
    };

    int num_states = 5;

    for (i = 0; i &lt; num_states; i++) {
        printf(&quot;state %d: %s\n&quot;, i, states[i]);
    }

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Take your favorite other language and use it to run this program, but include as many command line arguments as possible.  See if you can bust it
by giving it way too many arguments.</li>
<li>Initialize <em>i</em> to 0 and see what that does.  Do you have to adjust
<em>argc</em> as well, or does it just work?  Why does 0-based indexing work
here?</li>
<li>Set <em>num_states</em> wrong so that it&rsquo;s a higher value and see what
it does.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Figure out what kind of code you can put into the parts of a <em>for-loop</em>.</li>
<li>Look up how to use the comma character (,) to separate multiple
statements in the parts of the <em>for-loop</em>, but between the semicolon characters (;).</li>
<li>Read what a <em>NULL</em> is and try to use it in one of the elements from the
<em>states</em> array to see what it&rsquo;ll print.</li>
<li>See if you can assign an element from the <em>states</em> array to the
<em>argv</em> array before printing both.  Try the inverse.</li>
</ul>

<h2 id="exercise-14-writing-and-using-functions">Exercise 14 Writing and Using Functions</h2>

<p>The Plan</p>

<ul>
<li>Write your very first functions.</li>
</ul>

<p>The Code</p>

<p>.\ex14\ex14.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

// forward declarations
int can_print_it(char ch);
void print_letters(char arg[]);

void print_arguments(int argc, char *argv[])
{
    int i = 0;

    for (i = 0; i &lt; argc; i++) {
        print_letters(argv[i]);
    }
}

void print_letters(char arg[])
{
    int i = 0;

    for (i = 0; arg[i] != '\0'; i++) {
        char ch = arg[i];

        if (can_print_it(ch)) {
            printf(&quot;'%c' == %d &quot;, ch, ch);
        }
    }

    printf(&quot;\n&quot;);
}

int can_print_it(char ch)
{
    return isalpha(ch) || isblank(ch);
}

int main(int argc, char *argv[])
{
    print_arguments(argc+1, argv);
    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Remove the forward declarations to confuse the compiler and cause it to complains about <em>can_print_it</em> and <em>print_letters</em>.</li>
<li>When you call <em>print_arguments</em> inside <em>main</em>, try
adding 1 to <em>argc</em> so that it goes past the end of the
<em>argv</em> array.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Rework these functions so that you have fewer functions.  For example,
do you really need <em>can_print_it</em>?</li>
<li>Have <em>print_arguments</em> figure out how long each argument string
is by using the <em>strlen</em> function, and then pass that length
to <em>print_letters</em>.  Then, rewrite <em>print_letters</em>
so it only processes this fixed length and doesn&rsquo;t rely on the
<em>&lsquo;\0&rsquo;</em> terminator.  You&rsquo;ll need the <em>#include <string.h></em> for this.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Use <em>man</em> to look up information on <em>isalpha</em>
and <em>isblank</em>.  Use other similar functions to
print out only digits or other characters.</li>
<li>Go read about how other people like to format their
functions.  Never use the <em>K&amp;R syntax</em> (it&rsquo;s antiquated and
confusing) but understand what it&rsquo;s doing in case you run
into someone who likes it.</li>
</ul>

<h2 id="exercise-15-pointers-dreaded-pointers">Exercise 15 Pointers, Dreaded Pointers</h2>

<p>The Plan</p>

<ul>
<li>A long video on C pointers.</li>
<li>Lots of demonstration and visuals.</li>
</ul>

<p>The Code</p>

<p>.\ex15\ex15.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    // create two arrays we care about
    int ages[] = { 23, 43, 12, 89, 2 };
    char *names[] = {
        &quot;Alan&quot;, &quot;Frank&quot;,
        &quot;Mary&quot;, &quot;John&quot;, &quot;Lisa&quot;
    };

    // safely get the size of ages
    int count = sizeof(ages) / sizeof(int);
    int i = 0;

    // first way using indexing
    for (i = 0; i &lt; count; i++) {
        printf(&quot;%s has %d years alive.\n&quot;, names[i], ages[i]);
    }

    printf(&quot;---\n&quot;);

    // setup the pointers to the start of the arrays
    int *cur_age = (int *)names;
    char **cur_name = names;

    // second way using pointers
    for (i = 0; i &lt; count; i++) {
        printf(&quot;%s is %d years old.\n&quot;,
                *(cur_name + i), *(cur_age + i));
    }

    printf(&quot;---\n&quot;);

    // third way, pointers are just arrays
    for (i = 0; i &lt; count; i++) {
        printf(&quot;%s is %d years old again.\n&quot;, cur_name[i], cur_age[i]);
    }

    printf(&quot;---\n&quot;);

    // fourth way with pointers in a stupid complex way
    for (cur_name = names, cur_age = ages;
            (cur_age - ages) &lt; count; cur_name++, cur_age++) {
        printf(&quot;%s lived %d years so far.\n&quot;, *cur_name, *cur_age);
    }

    return 0;
}

</code></pre>

<p>The Pointer Lexicon</p>

<pre><code>type *ptr A pointer of type named ptr
*ptr The value of whatever ptr is pointed at
*(ptr + i) The value of (whatever ptr is pointed at plus i)
&amp;thing The address of thing
type *ptr = &amp;thing A pointer of type named ptr set to the address of thing
ptr++ Increment where ptr points
</code></pre>

<p>Pointers Visually</p>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Try to make <em>cur_age</em> point at <em>names</em>.  You&rsquo;ll need to
use a C cast to force it, so go look that up and try to figure it out.</li>
<li>In the final <em>for-loop</em>, try getting the math wrong in weird ways.</li>
<li>Try rewriting the loops so that they start at the end of the arrays and go
to the beginning.  This is harder than it looks.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Rewrite all of the arrays in this program as pointers.</li>
<li>Rewrite all of the pointers as arrays.</li>
<li>Go back to some of the other programs that use arrays and
try to use pointers instead.</li>
<li>Process command line arguments using just pointers similar to how
you did <em>names</em> in this one.</li>
<li>Play with combinations of getting the value of and the address of
things.</li>
<li>Add another <em>for-loop</em> at the end that prints out the
addresses that these pointers are using.  You&rsquo;ll need the <em>%p</em> format
for <em>printf</em>.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Rewrite this program to use a function for each of the ways you&rsquo;re
printing out things.  Try to pass pointers to these functions so that
they work on the data.  Remember you can declare a function to accept
a pointer, but just use it like an array.</li>
<li>Change the <em>for-loops</em> to <em>while-loops</em> and see what
works better for which kind of pointer usage.</li>
</ul>

<h2 id="exercise-16-structs-and-pointers-to-them">Exercise 16 Structs And Pointers To Them</h2>

<p>The Plan</p>

<ul>
<li>Learn to work with <em>structs</em> to structure data and make new types.</li>
<li>Learn to use pointers to work with <em>structs</em> better.</li>
</ul>

<p>The Code</p>

<p>.\ex16\ex16.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct Person {
    char *name;
    int age;
    int height;
    int weight;
};

struct Person *Person_create(char *name, int age, int height,
        int weight)
{
    struct Person *who = malloc(sizeof(struct Person));
    assert(who != NULL);

    who-&gt;name = strdup(name);
    who-&gt;age = age;
    who-&gt;height = height;
    who-&gt;weight = weight;

    return who;
}

void Person_destroy(struct Person *who)
{
    assert(who != NULL);

    free(who-&gt;name);
    free(who);
}

void Person_print(struct Person *who)
{
    printf(&quot;Name: %s\n&quot;, who-&gt;name);
    printf(&quot;\tAge: %d\n&quot;, who-&gt;age);
    printf(&quot;\tHeight: %d\n&quot;, who-&gt;height);
    printf(&quot;\tWeight: %d\n&quot;, who-&gt;weight);
}

int main(int argc, char *argv[])
{
    // make two people structures
    struct Person *joe = Person_create(&quot;Joe Alex&quot;, 32, 64, 140);

    struct Person *frank = Person_create(&quot;Frank Blank&quot;, 20, 72, 180);

    // print them out and where they are in memory
    printf(&quot;Joe is at memory location %p:\n&quot;, joe);
    Person_print(joe);

    printf(&quot;Frank is at memory location %p:\n&quot;, frank);
    Person_print(frank);

    // make everyone age 20 years and print them again
    joe-&gt;age += 20;
    joe-&gt;height -= 2;
    joe-&gt;weight += 40;
    Person_print(joe);

    frank-&gt;age += 20;
    frank-&gt;weight += 20;
    free(frank);
    Person_print(frank);

    // destroy them both so we clean up
    Person_destroy(joe);
    Person_destroy(frank);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Try passing <em>NULL</em> to <em>Person_destroy</em> see what
it does.  If it doesn&rsquo;t abort, then you must not have the
<em>-g</em> option in your Makefile&rsquo;s <em>CFLAGS</em>.</li>
<li>Forget to call <em>Person_destroy</em> at the end, and then run
it under the debugger to see it report that you forgot
to free the memory.  Figure out the options you need to pass
to the debugger to get it to print how you leaked
this memory.</li>
</ul>

<p>Breaking It</p>

<ul>
<li>Forget to free <em>who-&gt;name</em> in <em>Person_destroy</em>
and compare the output.  Again, use the right options to
see how the debugger tells you exactly where you messed
up.</li>
<li>This time, pass <em>NULL</em> to <em>Person_print</em> and
see what the debugger thinks of that. You&rsquo;ll figure out that <em>NULL</em> is a quick way
to crash your program.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>How to create a <em>struct</em> on the <em>stack</em> just like you&rsquo;re making any other variable.</li>
<li>How to initialize it using the <em>x.y</em> (period) character
instead of the <em>x-&gt;y</em> syntax.</li>
<li>How to pass a structure to other functions without using
a pointer.</li>
</ul>

<h2 id="exercise-17-heap-and-stack-memory-allocation">Exercise 17 Heap and Stack Memory Allocation</h2>

<p>The Plan</p>

<ul>
<li>Learn to allocate data on the heap using <em>malloc</em>.</li>
<li>Memory management techniques to avoid leaking.</li>
<li>How the heap differs from the stack, and when to use them.</li>
</ul>

<p>The Code</p>

<p>.\ex17\ex17.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#define MAX_DATA 512
#define MAX_ROWS 100

struct Address {
    int id;
    int set;
    char name[MAX_DATA];
    char email[MAX_DATA];
};

struct Database {
    struct Address rows[MAX_ROWS];
};

struct Connection {
    FILE *file;
    struct Database *db;
};

void die(const char *message)
{
    if (errno) {
        perror(message);
    } else {
        printf(&quot;ERROR: %s\n&quot;, message);
    }

    exit(1);
}

void Address_print(struct Address *addr)
{
    printf(&quot;%d %s %s\n&quot;, addr-&gt;id, addr-&gt;name, addr-&gt;email);
}

void Database_load(struct Connection *conn)
{
    int rc = fread(conn-&gt;db, sizeof(struct Database), 1, conn-&gt;file);
    if (rc != 1)
        die(&quot;Failed to load database.&quot;);
}

struct Connection *Database_open(const char *filename, char mode)
{
    struct Connection *conn = malloc(sizeof(struct Connection));
    if (!conn)
        die(&quot;Memory error&quot;);

    conn-&gt;db = malloc(sizeof(struct Database));
    if (!conn-&gt;db)
        die(&quot;Memory error&quot;);

    if (mode == 'c') {
        conn-&gt;file = fopen(filename, &quot;w&quot;);
    } else {
        conn-&gt;file = fopen(filename, &quot;r+&quot;);

        if (conn-&gt;file) {
            Database_load(conn);
        }
    }

    if (!conn-&gt;file)
        die(&quot;Failed to open the file&quot;);

    return conn;
}

void Database_close(struct Connection *conn)
{
    if (conn) {
        if (conn-&gt;file)
            fclose(conn-&gt;file);
        if (conn-&gt;db)
            free(conn-&gt;db);
        free(conn);
    }
}

void Database_write(struct Connection *conn)
{
    rewind(conn-&gt;file);

    int rc = fwrite(conn-&gt;db, sizeof(struct Database), 1, conn-&gt;file);
    if (rc != 1)
        die(&quot;Failed to write database.&quot;);

    rc = fflush(conn-&gt;file);
    if (rc == -1)
        die(&quot;Cannot flush database.&quot;);
}

void Database_create(struct Connection *conn)
{
    int i = 0;

    for (i = 0; i &lt; MAX_ROWS; i++) {
        // make a prototype to initialize it
        struct Address addr = {.id = i,.set = 0 };
        // then just assign it
        conn-&gt;db-&gt;rows[i] = addr;
    }
}

void Database_set(struct Connection *conn, int id, const char *name,
        const char *email)
{
    struct Address *addr = &amp;conn-&gt;db-&gt;rows[id];
    if (addr-&gt;set)
        die(&quot;Already set, delete it first&quot;);

    addr-&gt;set = 1;
    // WARNING: bug, read the &quot;How To Break It&quot; and fix this
    char *res = strncpy(addr-&gt;name, name, MAX_DATA);
    // demonstrate the strncpy bug
    if (!res)
        die(&quot;Name copy failed&quot;);

    res = strncpy(addr-&gt;email, email, MAX_DATA);
    if (!res)
        die(&quot;Email copy failed&quot;);
}

void Database_get(struct Connection *conn, int id)
{
    struct Address *addr = &amp;conn-&gt;db-&gt;rows[id];

    if (addr-&gt;set) {
        Address_print(addr);
    } else {
        die(&quot;ID is not set&quot;);
    }
}

void Database_delete(struct Connection *conn, int id)
{
    struct Address addr = {.id = id,.set = 0 };
    conn-&gt;db-&gt;rows[id] = addr;
}

void Database_list(struct Connection *conn)
{
    int i = 0;
    struct Database *db = conn-&gt;db;

    for (i = 0; i &lt; MAX_ROWS; i++) {
        struct Address *cur = &amp;db-&gt;rows[i];

        if (cur-&gt;set) {
            Address_print(cur);
        }
    }
}

int main(int argc, char *argv[])
{
    if (argc &lt; 3)
        die(&quot;USAGE: ex17 &lt;dbfile&gt; &lt;action&gt; [action params]&quot;);

    char *filename = argv[1];
    char action = argv[2][0];
    struct Connection *conn = Database_open(filename, action);
    int id = 0;

    if (argc &gt; 3) id = atoi(argv[3]);
    if (id &gt;= MAX_ROWS) die(&quot;There's not that many records.&quot;);

    switch (action) {
        case 'c':
            Database_create(conn);
            Database_write(conn);
            break;

        case 'g':
            if (argc != 4)
                die(&quot;Need an id to get&quot;);

            Database_get(conn, id);
            break;

        case 's':
            if (argc != 6)
                die(&quot;Need id, name, email to set&quot;);

            Database_set(conn, id, argv[4], argv[5]);
            Database_write(conn);
            break;

        case 'd':
            if (argc != 4)
                die(&quot;Need id to delete&quot;);

            Database_delete(conn, id);
            Database_write(conn);
            break;

        case 'l':
            Database_list(conn);
            break;
        default:
            die(&quot;Invalid action: c=create, g=get, s=set, d=del, l=list&quot;);
    }

    Database_close(conn);

    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>The classic way is to remove some of the safety checks so that you can
pass in arbitrary data. For example, remove the check on line 160
that prevents you from passing in any record number.</li>
<li>You can also try corrupting the data file.  Open it in any editor and
change random bytes, and then close it.</li>
<li>You could also find ways to pass bad arguments to the program when it&rsquo;s
run. For example, getting the file and action backwards will make it create
a file named after the action, and then do an action based on the first
character.</li>
</ul>

<p>Breaking It</p>

<ul>
<li>There&rsquo;s a bug in this program because <em>strncpy</em> is poorly
designed.  Go read about <em>strncpy</em> and try to find out what happens
when the <em>name</em> or <em>address</em> you give is <em>greater</em> than
512 bytes.  Fix this by simply forcing the last character to <em>&lsquo;\0&rsquo;</em>
so that it&rsquo;s always set no matter what (which is what strncpy should do).</li>
<li>In the extra credit, I have you augment the program to create arbitrary
size databases.  Try to see what the biggest database is before you
cause the program to die due to lack of memory from <em>malloc</em>.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>The <em>die</em> function needs to be augmented to let you pass the <em>conn</em>
variable, so it can close it and clean up.</li>
<li>Change the code to accept parameters for <em>MAX_DATA</em> and <em>MAX_ROWS</em>, store them in the <em>Database</em> struct, and write that to the file, thus creating
a database that can be arbitrarily sized.</li>
<li>Add more operations you can do with the database, like <em>find</em>.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Read about how C does it&rsquo;s struct packing, and then try to see why your
file is the size it is.  See if you can calculate a new size after adding
more fields.</li>
<li>Add some more fields to <em>Address</em> and make them searchable.</li>
<li>Write a shell script that will do your testing automatically for you
by running commands in the right order.  Hint: Use <em>set -e</em> at the
top of a <em>bash</em> to make it abort the whole script if any command
has an error.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Try reworking the program to use a single global for the database connection.
How does this new version of the program compare to the other one?</li>
<li>Go research stack data structure and write one in your favorite language,
then try to do it in C.</li>
</ul>

<h2 id="exercise-18-pointers-to-functions">Exercise 18 Pointers to Functions</h2>

<p>The Plan</p>

<ul>
<li>Advanced topic of pointers to functions.</li>
<li>These are very useful but not encountered too often.</li>
</ul>

<p>The Code</p>

<p>.\ex18\ex18.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

/** Our old friend die from ex17. */
void die(const char *message)
{
    if (errno) {
        perror(message);
    } else {
        printf(&quot;ERROR: %s\n&quot;, message);
    }

    exit(1);
}

// a typedef creates a fake type, in this
// case for a function pointer
typedef int (*compare_cb) (int a, int b);

/**
 * A classic bubble sort function that uses the 
 * compare_cb to do the sorting. 
 */
int *bubble_sort(int *numbers, int count, compare_cb cmp)
{
    int temp = 0;
    int i = 0;
    int j = 0;
    int *target = malloc(count * sizeof(int));

    if (!target)
        die(&quot;Memory error.&quot;);

    memcpy(target, numbers, count * sizeof(int));

    for (i = 0; i &lt; count; i++) {
        for (j = 0; j &lt; count - 1; j++) {
            if (cmp(target[j], target[j + 1]) &gt; 0) {
                temp = target[j + 1];
                target[j + 1] = target[j];
                target[j] = temp;
            }
        }
    }

    return target;
}

int sorted_order(int a, int b)
{
    return a - b;
}

int reverse_order(int a, int b)
{
    return b - a;
}

int strange_order(int a, int b)
{
    if (a == 0 || b == 0) {
        return 0;
    } else {
        return a % b;
    }
}

/** 
 * Used to test that we are sorting things correctly
 * by doing the sort and printing it out.
 */
void test_sorting(int *numbers, int count, compare_cb cmp)
{
    int i = 0;
    int *sorted = bubble_sort(numbers, count, cmp);

    if (!sorted)
        die(&quot;Failed to sort as requested.&quot;);

    for (i = 0; i &lt; count; i++) {
        printf(&quot;%d &quot;, sorted[i]);
    }
    printf(&quot;\n&quot;);

    free(sorted);
}

void destroy(compare_cb cmp)
{
    int i = 0;

    unsigned char *data = (unsigned char *)cmp;

    for(i = 0; i &lt; 1; i++) {
        data[i] = i;
    }

    printf(&quot;\n&quot;);
}

void dump(compare_cb cmp)
{
    int i = 0;

    unsigned char *data = (unsigned char *)cmp;

    for(i = 0; i &lt; 25; i++) {
        printf(&quot;%02x:&quot;, data[i]);
    }

    printf(&quot;\n&quot;);
}



int main(int argc, char *argv[])
{
    if (argc &lt; 2) die(&quot;USAGE: ex18 4 3 1 5 6&quot;);

    int count = argc - 1;
    int i = 0;
    char **inputs = argv + 1;

    int *numbers = malloc(count * sizeof(int));
    if (!numbers) die(&quot;Memory error.&quot;);

    for (i = 0; i &lt; count; i++) {
        numbers[i] = atoi(inputs[i]);
    }

    test_sorting(numbers, count, sorted_order);
    test_sorting(numbers, count, reverse_order);
    test_sorting(numbers, count, strange_order);

    free(numbers);

    printf(&quot;SORTED:&quot;);
    dump(sorted_order);

    destroy(sorted_order);

    printf(&quot;SORTED:&quot;);
    dump(sorted_order);


    return 0;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<p>Let&rsquo;s hack your computer with this code:</p>

<pre><code>unsigned char *data = (unsigned char *)cmp;

for(i = 0; i &lt; 25; i++) {
    printf(&quot;%02x:&quot;, data[i]);
}

printf(&quot;\n&quot;);
</code></pre>

<p>You&rsquo;ll see how the bytes of code that make up your program can also be data.</p>

<p>Extra Credit</p>

<ul>
<li>Get a hex editor and open up <em>ex18</em>, and then find the sequence
of hex digits that start a function to see if you can find the function
in the raw program.</li>
<li>Find other random things in your hex editor and change them.  Rerun your
program and see what happens.  Strings you find are the easiest
things to change.</li>
<li>Pass in the wrong function for the <em>compare_cb</em> and see what
the C compiler complains about.</li>
<li>Pass in NULL and watch your program seriously bite it.  Then, run
the debugger and see what that reports.</li>
<li>Write another sorting algorithm, then change <em>test_sorting</em> so
that it takes <em>both</em> an arbitrary sort function and the sort function&rsquo;s
callback comparison.  Use it to test both of your algorithms.</li>
</ul>

<h2 id="exercise-19-zed-s-awesome-debug-macros">Exercise 19 Zed&rsquo;s Awesome Debug Macros</h2>

<p>The Plan</p>

<ul>
<li>Learn about the macros that vastly improve my code quality.</li>
<li>Find out why they help you out.</li>
<li>Explore some advanced C Pre-Processor (CPP) macro magic code generation tricks.</li>
</ul>

<p>The Code</p>

<p>.\ex19\ex19.c</p>

<pre><code class="language-c">
#include &quot;dbg.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void test_debug()
{
    // notice you don't need the \n
    debug(&quot;I have Brown Hair.&quot;);

    // passing in arguments like printf
    debug(&quot;I am %d years old.&quot;, 37);
}

void test_log_err()
{
    log_err(&quot;I believe everything is broken.&quot;);
    log_err(&quot;There are %d problems in %s.&quot;, 0, &quot;space&quot;);
}

void test_log_warn()
{
    log_warn(&quot;You can safely ignore this.&quot;);
    log_warn(&quot;Maybe consider looking at: %s.&quot;, &quot;/etc/passwd&quot;);
}

void test_log_info()
{
    log_info(&quot;Well I did something mundane.&quot;);
    log_info(&quot;It happened %f times today.&quot;, 1.3f);
}

int test_check(char *file_name)
{
    FILE *input = NULL;
    char *block = NULL;

    block = malloc(100);
    check_mem(block);       // should work

    input = fopen(file_name, &quot;r&quot;);
    check(input, &quot;Failed to open %s.&quot;, file_name);

    free(block);
    fclose(input);
    return 0;

error:
    if (block) free(block);
    if (input) fclose(input);
    return -1;
}

int test_sentinel(int code)
{
    char *temp = malloc(100);
    check_mem(temp);

    switch (code) {
        case 1:
            log_info(&quot;It worked.&quot;);
            break;
        default:
            sentinel(&quot;I shouldn't run.&quot;);
    }

    free(temp);
    return 0;

error:
    if (temp)
        free(temp);
    return -1;
}

int test_check_mem()
{
    char *test = NULL;
    check_mem(test);

    free(test);
    return 1;

error:
    return -1;
}

int test_check_debug()
{
    int i = 0;
    check_debug(i != 0, &quot;Oops, I was 0.&quot;);

    return 0;
error:
    return -1;
}

int main(int argc, char *argv[])
{
    check(argc == 2, &quot;Need an argument.&quot;);

    test_debug();
    test_log_err();
    test_log_warn();
    test_log_info();

    check(test_check(&quot;ex20.c&quot;) == 0, &quot;failed with ex20.c&quot;);
    check(test_check(argv[1]) == -1, &quot;failed with argv&quot;);
    check(test_sentinel(1) == 0, &quot;test_sentinel failed.&quot;);
    check(test_sentinel(100) == -1, &quot;test_sentinel failed.&quot;);
    check(test_check_mem() == -1, &quot;test_check_mem failed.&quot;);
    check(test_check_debug() == -1, &quot;test_check_debug failed.&quot;);

    return 0;

error:
    return 1;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<p>These macros are designed on purpose to prevent you from doing this:</p>

<pre><code>if(blah) debug(&quot;This is a thing&quot;);
else debug (&quot;This is another thing&quot;);
</code></pre>

<p>Extra Credit</p>

<ul>
<li>Put <code>#define NDEBUG</code> at the top of the file and check that all
of the debug messages go away.</li>
<li>Undo that line, and add <code>-DNDEBUG</code> to <code>CFLAGS</code> at the
top of the <code>Makefile</code>, and then recompile to see the same thing.</li>
<li>Modify the logging so that it includes the function name, as well
as the <code>file:line</code>.</li>
</ul>

<h2 id="exercise-20-advanced-debugging-techniques">Exercise 20 Advanced Debugging Techniques</h2>

<p>The Plan</p>

<p>Demonstrate more advanced debugging techniques and tools.</p>

<p>The Demonstration</p>

<p>Extra Credit</p>

<ul>
<li>Find a graphical debugger and compare using it to raw <code>gdb</code>.
These are useful when the program you&rsquo;re looking at is local, but they
are pointless if you have to debug a program on a server.</li>
<li>You can enable core dumps on your OS, and when a program crashes,
you&rsquo;ll get a core file.  This core file is like a postmortem of
the program that you can load up to see what happened right at the crash
and what caused it.  Change <code>ex31.c</code> so that it crashes
after a few iterations, then try to get a core dump and analyze it.</li>
</ul>

<h2 id="exercise-21-advanced-data-types-and-flow-control">Exercise 21 Advanced Data Types and Flow Control</h2>

<p>The Plan</p>

<ul>
<li>Learn about the basic types and keywords for them.</li>
<li>Cover all the keywords for modifying those types.</li>
<li>Review fixed exact size types.</li>
<li>Learn all the different operators on those types.</li>
</ul>

<p>This is mostly a review!</p>

<p>Available Data Types</p>

<pre><code>int    Stores a regular integer, defaulting to 32 bits in size.
double Holds a large floating point number.
float  Holds a smaller floating point number.
char   Holds a single 1 byte character.
void   Indicates &quot;no type&quot;.
enum   Enumerated types, which work as and convert to integers.
</code></pre>

<p>Type Modifiers</p>

<pre><code>unsigned  Non-negative numbers.
signed    Gives you negative and positive numbers.
long      Bigger number.
short     Smaller number.
</code></pre>

<p>Type Qualifiers</p>

<pre><code>const     Constant.
volatile  Compiler can't trust it.
register  Put it in a CPU register.
</code></pre>

<p>Type Conversion</p>

<p>C type promotion order:</p>

<ul>
<li>long double</li>
<li>double</li>
<li>float</li>
<li>int (but only char and short int);</li>
<li>long</li>
</ul>

<p>When in doubt, parens it out!</p>

<p>Exact Size Types</p>

<p>If you need exact sizes use these:</p>

<pre><code>int8_t   8-bit signed integer
uint8_t  8-bit unsigned integer
int16_t  16-bit signed integer
uint16_t 16-bit unsigned integer
int32_t  32-bit signed integer
uint32_t 32-bit unsigned integer
int64_t  64-bit signed integer
uint64_t 64-bit unsigned integer
</code></pre>

<p>Getting Sizes</p>

<p>Refer to the book as there&rsquo;s a large number of
macros to help you get size information for types.</p>

<p>Examples:</p>

<pre><code>int_least32_t  int that holds at least 32 bits.
uint_fast32_t  unsigned fastest int for 32 bits.
intptr_t       signed int that can hold a pointer.
PTRDIFF_MAX    maximum value of ptrdiff_t
SIZE_MAX       maximum value of a size_t
</code></pre>

<p>Available Operators</p>

<p>This section is a review of what you memorized already
to make sure you know everything.</p>

<p>Memorize these again to be sure you have them.</p>

<p>Extra Credit</p>

<ul>
<li>Read stdint.h or a description of it, and write out all the
available size identifiers.</li>
<li>Go through each item here and write out what it does in code.  Research it online so you know you got it right.</li>
<li>Get this information memorized by making flash cards and spending 15
minutes a day practicing it.</li>
<li>Create a program that prints out examples of each type, and confirm that your
research is right.</li>
</ul>

<h2 id="exercise-22-the-stack-scope-and-globals">Exercise 22 The Stack, Scope, and Globals</h2>

<p>The Plan</p>

<ul>
<li>Start to learn about scope.</li>
<li>Stack vs. global.</li>
<li>Scope levels inside a function.</li>
<li>The <em>extern</em> keyword.</li>
</ul>

<p>The Code</p>

<p>.\ex22\ex22.h</p>

<pre><code class="language-c">#ifndef _ex22_h
#define _ex22_h

struct State {
    int the_size;
    int the_age;
};


// gets and sets an internal static variable in ex22.c
int get_age(struct State *state);
void set_age(struct State *state, int age);

// updates a static variable that's inside update_ratio
double update_ratio(double ratio);

void print_size();

#endif

</code></pre>

<p>.\ex22\ex22.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;ex22.h&quot;
#include &quot;dbg.h&quot;

int get_age(struct State *state)
{
    return state-&gt;the_age;
}

void set_age(struct State *state, int age)
{
   state-&gt;the_age = age; 
}

double update_ratio(double new_ratio)
{
    static double ratio = 1.0;

    double old_ratio = ratio;
    ratio = new_ratio;

    return old_ratio;
}

void print_size()
{
    log_info(&quot;I think size is: %d&quot;, THE_SIZE);
}

</code></pre>

<p>.\ex22\ex22_main.c</p>

<pre><code class="language-c">#include &quot;ex22.h&quot;
#include &quot;dbg.h&quot;

const char *MY_NAME = &quot;Zed A. Shaw&quot;;

void scope_demo(int count)
{
    log_info(&quot;count is: %d&quot;, count);

    if (count &gt; 10) {
        int numbers = 100;  // BAD! BUGS!

        log_info(&quot;count in this scope is %d&quot;, numbers);
    }

    log_info(&quot;count is at exit: %d&quot;, count);

    count = 3000;

    log_info(&quot;count after assign: %d&quot;, count);
}

int main(int argc, char *argv[])
{
    // test out THE_AGE accessors
    log_info(&quot;My name: %s, age: %d&quot;, MY_NAME, get_age());

    set_age(100);

    log_info(&quot;My age is now: %d&quot;, get_age());

    // test out THE_SIZE extern
    log_info(&quot;THE_SIZE is: %d&quot;, THE_SIZE);
    print_size();

    THE_SIZE = 9;

    log_info(&quot;THE SIZE is now: %d&quot;, THE_SIZE);
    print_size();

    // test the ratio function static
    log_info(&quot;Ratio at first: %f&quot;, update_ratio(2.0));
    log_info(&quot;Ratio again: %f&quot;, update_ratio(10.0));
    log_info(&quot;Ratio once more: %f&quot;, update_ratio(300.0));

    // test the scope demo
    int count = 4;
    scope_demo(count);
    scope_demo(count * 20);

    log_info(&quot;count after calling scope_demo: %d&quot;, count);

    return 0;
}

</code></pre>

<p>This exercises requires two files:</p>

<pre><code>* ex22.c
* ex22_main.c
</code></pre>

<p>The Analysis</p>

<p>Fixing It</p>

<p>Instead of breaking this one I&rsquo;m going to fix it.</p>

<ul>
<li>Do not shadow a variable like <em>count</em> on ex22_main.c:11.</li>
<li>Avoid using too many globals.</li>
<li>When in doubt, put it on the heap (malloc).</li>
<li>Don&rsquo;t use function static variables like I did in ex22.c:update_ratio.</li>
<li>Avoid reusing function parameters.</li>
</ul>

<p>Breaking It</p>

<ul>
<li>Try to directly access variables in <code>ex22.c</code> from <code>ex22_main.c</code>
that you think you can&rsquo;t.  For example, can you get at <code>ratio</code>
inside <code>update_ratio</code>? What if you had a pointer to it?</li>
<li>Ditch the <code>extern</code> declaration in <code>ex22.h</code> to see what
errors or warnings you get.</li>
<li>Add <code>static</code> or <code>const</code> specifiers to different variables,
and then try to change them.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Research the concept of pass by value verses pass by reference.  Write an
example of both.</li>
<li>Use pointers to gain access to things you shouldn&rsquo;t have access to.</li>
<li>Use your debugger to see what this kind of access looks like when you
do it wrong.</li>
<li>Write a recursive function that causes a stack overflow.  Don&rsquo;t know
what a recursive function is?  Try calling <code>scope_demo</code> at the
bottom of <code>scope_demo</code> itself so that it loops.</li>
<li>Rewrite the <code>Makefile</code> so that it can build this.</li>
</ul>

<h2 id="exercise-23-meet-duff-s-device">Exercise 23 Meet Duff&rsquo;s Device</h2>

<p>The Plan</p>

<p>Learn the most evil awesome hack ever:</p>

<p>Duff&rsquo;s Device</p>

<p>The Code</p>

<p>.\ex23\ex23.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;dbg.h&quot;

int normal_copy(char *from, char *to, int count)
{
    int i = 0;

    for (i = 0; i &lt; count; i++) {
        to[i] = from[i];
    }

    return i;
}

int duffs_device(char *from, char *to, int count)
{
    {
        int n = (count + 7) / 8;

        switch (count % 8) {
            case 0:
                do {
                    *to++ = *from++;
                    case 7:
                    *to++ = *from++;
                    case 6:
                    *to++ = *from++;
                    case 5:
                    *to++ = *from++;
                    case 4:
                    *to++ = *from++;
                    case 3:
                    *to++ = *from++;
                    case 2:
                    *to++ = *from++;
                    case 1:
                    *to++ = *from++;
                } while (--n &gt; 0);
        }
    }

    return count;
}

int zeds_device(char *from, char *to, int count)
{
    {
        int n = (count + 7) / 8;
        debug(&quot;n starts: %d, count: %d, count%%8: %d&quot;, 
                n, count, count % 8);

        switch (count % 8) {
            case 0:
again:    *to++ = *from++;

            case 7:
          *to++ = *from++;
            case 6:
          *to++ = *from++;
            case 5:
          *to++ = *from++;
            case 4:
          *to++ = *from++;
            case 3:
          *to++ = *from++;
            case 2:
          *to++ = *from++;
            case 1:
          *to++ = *from++;
          debug(&quot;last case: n=%d&quot;, n);
          if (--n &gt; 0) {
              debug(&quot;going again: n=%d&quot;, n);
              goto again;
          }
        }
    }

    return count;
}

int valid_copy(char *data, int count, char expects)
{
    int i = 0;
    for (i = 0; i &lt; count; i++) {
        if (data[i] != expects) {
            log_err(&quot;[%d] %c != %c&quot;, i, data[i], expects);
            return 0;
        }
    }

    return 1;
}

int main(int argc, char *argv[])
{
    char from[1003] = { 'a' };
    char to[1003] = { 'c' };
    int rc = 0;

    // setup the from to have some stuff
    memset(from, 'x', 1003);
    // set it to a failure mode
    memset(to, 'y', 1003);
    check(valid_copy(to, 1003, 'y'), &quot;Not initialized right.&quot;);

    // use normal copy to 
    rc = normal_copy(from, to, 1003);
    check(rc == 1003, &quot;Normal copy failed: %d&quot;, rc);
    check(valid_copy(to, 1003, 'x'), &quot;Normal copy failed.&quot;);

    // reset
    memset(to, 'y', 1003);

    // duffs version
    rc = duffs_device(from, to, 1003);
    check(rc == 1003, &quot;Duff's device failed: %d&quot;, rc);
    check(valid_copy(to, 1003, 'x'), &quot;Duff's device failed copy.&quot;);

    // reset
    memset(to, 'y', 1003);

    // my version
    rc = zeds_device(from, to, 1003);
    check(rc == 1003, &quot;Zed's device failed: %d&quot;, rc);
    check(valid_copy(to, 1003, 'x'), &quot;Zed's device failed copy.&quot;);

    return 0;
error:
    return 1;
}

</code></pre>

<p>Remember that this is <em>bad</em> code.
It&rsquo;s very interesting though, so struggle with it.</p>

<p>The Analysis</p>

<p>Before you continue, try to figure out what this does.
Consider it a debugging problem.</p>

<p>Clues</p>

<ul>
<li>Print this code out so that you can write on some paper.</li>
<li>Write each of the variables in a table as they
look when they get initialized right before the <code>switch-statement</code>.</li>
<li>Follow the logic to the switch, then do the jump to the right case.</li>
<li>Update the variables, including the <code>to</code>, <code>from</code>, and the
arrays they point at.</li>
</ul>

<p>Clues</p>

<ul>
<li>When you get to the <code>while</code> part or my <code>goto</code> alternative,
check your variables, and then follow the logic either back to the
top of the <code>do-while</code> or to where the <code>again</code> label is
located.</li>
<li>Follow through this manual tracing, updating the variables, until
you&rsquo;re sure you see how this flows.</li>
</ul>

<p>Pause!</p>

<p>I will then show you the solution so pause if you do
<em>NOT</em> want to see it yet.</p>

<p>Solving It</p>

<p>Watch me walk through how this works to see if it matches what you did.</p>

<p>Extra Credit</p>

<ul>
<li>Never use this again.</li>
<li>Go look at the Wikipedia entry for Duff&rsquo;s device and see if you can
spot the error.  Read the article, compare it to the version I have here, and try to understand why the Wikipedia code won&rsquo;t work for you
but worked for Tom Duff.</li>
<li>Create a set of macros that lets you create any length of device like this.
For example, what if you wanted to have 32 case statements and didn&rsquo;t want
to write out all of them? Can you do a macro that lays down eight at a time?</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Change the <code>main</code> to conduct some speed tests to see which one is
really the fastest.</li>
<li>Read about <code>memcpy</code>, <code>memmove</code>, and <code>memset</code>, and also compare
their speed.</li>
<li>Never use this again!</li>
</ul>

<h2 id="exercise-24-input-output-files">Exercise 24 Input, Output, Files</h2>

<p>The Plan</p>

<ul>
<li>Learn the basics of working with files in C.</li>
<li>Get an initial list of the &ldquo;f-functions&rdquo;.</li>
</ul>

<p>The Code</p>

<p>.\ex24\ex24.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;dbg.h&quot;

#define MAX_DATA 100

typedef enum EyeColor {
    BLUE_EYES, GREEN_EYES, BROWN_EYES,
    BLACK_EYES, OTHER_EYES
} EyeColor;

const char *EYE_COLOR_NAMES[] = {
    &quot;Blue&quot;, &quot;Green&quot;, &quot;Brown&quot;, &quot;Black&quot;, &quot;Other&quot;
};

typedef struct Person {
    int age;
    char first_name[MAX_DATA];
    char last_name[MAX_DATA];
    EyeColor eyes;
    float income;
} Person;

int main(int argc, char *argv[])
{
    Person you = {.age = 0 };
    int i = 0;
    char *in = NULL;

    printf(&quot;What's your First Name? &quot;);
    in = fgets(you.first_name, MAX_DATA - 1, stdin);
    check(in != NULL, &quot;Failed to read first name.&quot;);

    printf(&quot;What's your Last Name? &quot;);
    in = fgets(you.last_name, MAX_DATA - 1, stdin);
    check(in != NULL, &quot;Failed to read last name.&quot;);

    printf(&quot;How old are you? &quot;);
    int rc = fscanf(stdin, &quot;%d&quot;, &amp;you.age);
    check(rc &gt; 0, &quot;You have to enter a number.&quot;);

    printf(&quot;What color are your eyes:\n&quot;);
    for (i = 0; i &lt;= OTHER_EYES; i++) {
        printf(&quot;%d) %s\n&quot;, i + 1, EYE_COLOR_NAMES[i]);
    }
    printf(&quot;&gt; &quot;);

    int eyes = -1;
    rc = fscanf(stdin, &quot;%d&quot;, &amp;eyes);
    check(rc &gt; 0, &quot;You have to enter a number.&quot;);

    you.eyes = eyes - 1;
    check(you.eyes &lt;= OTHER_EYES
            &amp;&amp; you.eyes &gt;= 0, &quot;Do it right, that's not an option.&quot;);

    printf(&quot;How much do you make an hour? &quot;);
    rc = fscanf(stdin, &quot;%f&quot;, &amp;you.income);
    check(rc &gt; 0, &quot;Enter a floating point number.&quot;);

    printf(&quot;----- RESULTS -----\n&quot;);

    printf(&quot;First Name: %s&quot;, you.first_name);
    printf(&quot;Last Name: %s&quot;, you.last_name);
    printf(&quot;Age: %d\n&quot;, you.age);
    printf(&quot;Eyes: %s\n&quot;, EYE_COLOR_NAMES[you.eyes]);
    printf(&quot;Income: %f\n&quot;, you.income);

    return 0;
error:

    return -1;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Trying out <em>fgets</em> and the problems with <em>gets</em>.</li>
<li>Feed it <em>/dev/urandom</em> to give it garbage.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Rewrite this to not use <code>fscanf</code> at all.  You&rsquo;ll need to use
functions like <code>atoi</code> to convert the input strings to numbers.</li>
<li>Change this to use plain <code>scanf</code> instead of <code>fscanf</code> to
see what the difference is.</li>
<li>Fix it so that their input names get stripped of the trailing newline
characters and any whites pace.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Use <code>scanf</code> to write a function that reads one character at a time
and files in the names but doesn&rsquo;t go past the end.  Make this function
generic so it can take a size for the string, but just make sure you end
the string with <code>'\0'</code> no matter what.</li>
</ul>

<h2 id="exercise-25-variable-argument-functions">Exercise 25 Variable Argument Functions</h2>

<p>The Plan</p>

<ul>
<li>Use variable argument functions.</li>
<li>Write our own simple version of <em>scanf</em>.</li>
</ul>

<p>The Code</p>

<p>.\ex25\ex25.c</p>

<pre><code class="language-c">
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &quot;dbg.h&quot;

#define MAX_DATA 100

int read_string(char **out_string, int max_buffer)
{
    *out_string = calloc(1, max_buffer + 1);
    check_mem(*out_string);

    char *result = fgets(*out_string, max_buffer, stdin);
    check(result != NULL, &quot;Input error.&quot;);

    return 0;

error:
    if (*out_string) free(*out_string);
    *out_string = NULL;
    return -1;
}

int read_int(int *out_int)
{
    char *input = NULL;
    int rc = read_string(&amp;input, MAX_DATA);
    check(rc == 0, &quot;Failed to read number.&quot;);

    *out_int = atoi(input);

    free(input);
    return 0;

error:
    if (input) free(input);
    return -1;
}

int read_scan(const char *fmt, ...)
{
    int i = 0;
    int rc = 0;
    int *out_int = NULL;
    char *out_char = NULL;
    char **out_string = NULL;
    int max_buffer = 0;

    va_list argp;
    va_start(argp, fmt);

    for (i = 0; fmt[i] != '\0'; i++) {
        if (fmt[i] == '%') {
            i++;
            switch (fmt[i]) {
                case '\0':
                    sentinel(&quot;Invalid format, you ended with %%.&quot;);
                    break;

                case 'd':
                    out_int = va_arg(argp, int *);
                    rc = read_int(out_int);
                    check(rc == 0, &quot;Failed to read int.&quot;);
                    break;

                case 'c':
                    out_char = va_arg(argp, char *);
                    *out_char = fgetc(stdin);
                    break;

                case 's':
                    max_buffer = va_arg(argp, int);
                    out_string = va_arg(argp, char **);
                    rc = read_string(out_string, max_buffer);
                    check(rc == 0, &quot;Failed to read string.&quot;);
                    break;

                default:
                    sentinel(&quot;Invalid format.&quot;);
            }
        } else {
            fgetc(stdin);
        }

        check(!feof(stdin) &amp;&amp; !ferror(stdin), &quot;Input error.&quot;);
    }

    va_end(argp);
    return 0;

error:
    va_end(argp);
    return -1;
}

int main(int argc, char *argv[])
{
    char *first_name = NULL;
    char initial = ' ';
    char *last_name = NULL;
    int age = 0;

    printf(&quot;What's your first name? &quot;);
    int rc = read_scan(&quot;%s&quot;, MAX_DATA, &amp;first_name);
    check(rc == 0, &quot;Failed first name.&quot;);

    printf(&quot;What's your initial? &quot;);
    rc = read_scan(&quot;%c\n&quot;, &amp;initial);
    check(rc == 0, &quot;Failed initial.&quot;);

    printf(&quot;What's your last name? &quot;);
    rc = read_scan(&quot;%s&quot;, MAX_DATA, &amp;last_name);
    check(rc == 0, &quot;Failed last name.&quot;);

    printf(&quot;How old are you? &quot;);
    rc = read_scan(&quot;%d&quot;, &amp;age);

    printf(&quot;---- RESULTS ----\n&quot;);
    printf(&quot;First Name: %s&quot;, first_name);
    printf(&quot;Initial: '%c'\n&quot;, initial);
    printf(&quot;Last Name: %s&quot;, last_name);
    printf(&quot;Age: %d\n&quot;, age);

    free(first_name);
    free(last_name);
    return 0;
error:
    return -1;
}

</code></pre>

<p>The Analysis</p>

<p>Breaking It</p>

<ul>
<li>Change the code so that you forget to pass in the initial size for &lsquo;%s&rsquo; formats.</li>
<li>Give it more data than <code>MAX_DATA</code>, and then see how omitting <code>calloc</code> in <code>read_string</code> changes how it works.</li>
<li>There&rsquo;s a problem where fgets eats the newlines, so try to fix that using
<code>fgetc</code> but leave out the <code>\0</code> that ends the string.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Make double and triple sure that you know what each of the <code>out_</code>
variables are doing.  Most importantly, you should know what is <code>out_string</code> is and how it&rsquo;s
a pointer to a pointer, , so that you understand when you&rsquo;re setting the pointer versus the
contents is important.  Break down each of the</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Write a similar function to <code>printf</code> that uses the varargs system,
and rewrite <code>main</code> to use it.</li>
<li>As usual, read the man page on all of this so that you know what it does
on your platform.  Some platforms will use macros, others will use
functions, and some will have these do nothing.  It all depends on the
compiler and the platform you use.</li>
</ul>

<h2 id="exercise-26-project-logfind">Exercise 26 Project logfind</h2>

<p>The Plan</p>

<p>Attempt your first project!</p>

<p>logfind</p>

<p>How Projects Work</p>

<p>The projects in this book are designed to make you apply
what you know so far to something &ldquo;real world&rdquo;.</p>

<ol>
<li>I will tell you when to <em>pause</em> so you can try to solve it yourself.</li>
<li>You will be given the challenge.  Pause!</li>
<li>You will be given clues. Pause!</li>
<li>Finally the solution.</li>
<li>Then I try to break my own solution.</li>
</ol>

<p>The Code</p>

<p>logfind.1</p>

<p>.\ex26\logfind.1\logfind.c</p>

<pre><code class="language-c">#include &quot;dbg.h&quot;


int main(int argc, char *argv[])
{
    check(argc &gt; 2, &quot;USAGE: logfind word word word&quot;);

    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex26\logfind.1\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind test test test


</code></pre>

<p>logfind.2</p>

<p>.\ex26\logfind.2\logfind.c</p>

<pre><code class="language-c">#include &quot;dbg.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

const size_t MAX_LINE = 1024;

int scan_file(const char *filename, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &quot;r&quot;);
    char *found = NULL;
    int i = 0;

    check_mem(line);
    check(file, &quot;Failed to open file: %s&quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL &amp;&amp; found == NULL) {
        for(i = 0; i &lt; search_len &amp;&amp; found == NULL; i++) {
            found = strcasestr(line, search_for[i]);
            if(found) {
                printf(&quot;%s\n&quot;, filename);
            }
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}


int main(int argc, char *argv[])
{
    check(argc &gt; 1, &quot;USAGE: logfind word word word&quot;);

    scan_file(&quot;logfind.c&quot;, argc, argv);

    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex26\logfind.2\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind error

clean:
    rm -f logfind

</code></pre>

<p>logfind.3</p>

<p>.\ex26\logfind.3\logfind.c</p>

<pre><code class="language-c">#include &quot;dbg.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;glob.h&gt;

const size_t MAX_LINE = 1024;


int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&quot;.logfind&quot;, &quot;r&quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &quot;Invalid glob_t given.&quot;);
    check_mem(line);
    check(file, &quot;Failed to open .logfind. Make that first.&quot;);

    rc = glob(&quot;*.h&quot;, glob_flags, NULL, pglob);
    check(rc == 0, &quot;Failed to glob.&quot;);
    rc = glob(&quot;*.c&quot;, glob_flags | GLOB_APPEND, NULL, pglob);
    check(rc == 0, &quot;Failed to glob.&quot;);

    for(i = 0; i &lt; pglob-&gt;gl_pathc; i++) {
        debug(&quot;Matched file: %s&quot;, pglob-&gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int scan_file(const char *filename, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &quot;r&quot;);
    char *found = NULL;
    int i = 0;

    check_mem(line);
    check(file, &quot;Failed to open file: %s&quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL &amp;&amp; found == NULL) {
        for(i = 0; i &lt; search_len &amp;&amp; found == NULL; i++) {
            found = strcasestr(line, search_for[i]);
            if(found) {
                printf(&quot;%s\n&quot;, filename);
            }
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}


int main(int argc, char *argv[])
{
    int i = 0;
    glob_t files_found;
    check(argc &gt; 1, &quot;USAGE: logfind word word word&quot;);

    check(list_files(&amp;files_found) == 0, &quot;Failed to list files.&quot;);

    for(i = 0; i &lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], argc, argv);
    }

    globfree(&amp;files_found);
    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex26\logfind.3\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind error

clean:
    rm -f logfind

</code></pre>

<p>logfind.4</p>

<p>.\ex26\logfind.4\logfind.c</p>

<pre><code class="language-c">#define NDEBUG
#include &quot;dbg.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;glob.h&gt;

const size_t MAX_LINE = 1024;


int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&quot;.logfind&quot;, &quot;r&quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &quot;Invalid glob_t given.&quot;);
    check_mem(line);
    check(file, &quot;Failed to open .logfind. Make that first.&quot;);

    while(fgets(line, MAX_LINE-1, file) != NULL) {
        line[strlen(line) - 1] = '\0'; // drop the \n ending
        debug(&quot;Globbing %s&quot;, line);

        rc = glob(line, glob_flags, NULL, pglob);
        check(rc == 0 || rc == GLOB_NOMATCH, &quot;Failed to glob.&quot;);

        // dumb work around to a stupid design in glob
        if(glob_flags == GLOB_TILDE) glob_flags |= GLOB_APPEND;
    }

    for(i = 0; i &lt; pglob-&gt;gl_pathc; i++) {
        debug(&quot;Matched file: %s&quot;, pglob-&gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int scan_file(const char *filename, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &quot;r&quot;);
    char *found = NULL;
    int i = 0;

    check_mem(line);
    check(file, &quot;Failed to open file: %s&quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL &amp;&amp; found == NULL) {
        for(i = 0; i &lt; search_len &amp;&amp; found == NULL; i++) {
            found = strcasestr(line, search_for[i]);
            if(found) {
                printf(&quot;%s\n&quot;, filename);
            }
        }
    }

    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}


int main(int argc, char *argv[])
{
    int i = 0;
    glob_t files_found;
    check(argc &gt; 1, &quot;USAGE: logfind word word word&quot;);

    check(list_files(&amp;files_found) == 0, &quot;Failed to list files.&quot;);

    for(i = 0; i &lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], argc, argv);
    }

    globfree(&amp;files_found);
    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex26\logfind.4\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind MAX_LINE

clean:
    rm -f logfind

</code></pre>

<p>logfind.5</p>

<p>.\ex26\logfind.5\logfind.c</p>

<pre><code class="language-c">#define NDEBUG
#include &quot;dbg.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;glob.h&gt;

const size_t MAX_LINE = 1024;


int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&quot;.logfind&quot;, &quot;r&quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &quot;Invalid glob_t given.&quot;);
    check_mem(line);
    check(file, &quot;Failed to open .logfind. Make that first.&quot;);

    while(fgets(line, MAX_LINE-1, file) != NULL) {
        line[strlen(line) - 1] = '\0'; // drop the \n ending
        debug(&quot;Globbing %s&quot;, line);

        rc = glob(line, glob_flags, NULL, pglob);
        check(rc == 0 || rc == GLOB_NOMATCH, &quot;Failed to glob.&quot;);

        // dumb work around to a stupid design in glob
        if(glob_flags == GLOB_TILDE) glob_flags |= GLOB_APPEND;
    }

    for(i = 0; i &lt; pglob-&gt;gl_pathc; i++) {
        debug(&quot;Matched file: %s&quot;, pglob-&gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int found_it(int use_or, int found_count, int search_len)
{
    debug(&quot;use_or: %d, found_count: %d, search_len: %d&quot;, use_or, found_count, search_len);

    if(use_or &amp;&amp; found_count &gt; 0) {
        return 1;
    } else if(!use_or &amp;&amp; found_count == search_len) {
        return 1;
    } else {
        return 0;
    }
}

int scan_file(const char *filename, int use_or, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &quot;r&quot;);
    int found_count = 0;
    int i = 0;

    check_mem(line);
    check(file, &quot;Failed to open file: %s&quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL)
    {
        for(i = 0; i &lt; search_len; i++) {
            if(strcasestr(line, search_for[i]) != NULL) {
                debug(&quot;file: %s, line: %s, search: %s&quot;, filename, line, search_for[i]);
                found_count++;
            }
        }

        if(found_it(use_or, found_count, search_len)) {
            printf(&quot;%s\n&quot;, filename);
            break;
        } else {
            found_count = 0;
        }
    }


    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int parse_args(int *use_or, int *argc, char **argv[]) 
{
    (*argc)--;
    (*argv)++;

    if(strcmp((*argv)[0], &quot;-o&quot;) == 0) {
        *use_or = 1;
        (*argc)--; // skip the -o
        (*argv)++;
        check(*argc &gt; 1, &quot;You need words after -o.&quot;);
    } else {
        use_or = 0;
    }

    return 0;
error:
    return -1;
}


int main(int argc, char *argv[])
{
    int i = 0;
    int use_or = 0;
    glob_t files_found;

    check(argc &gt; 1, &quot;USAGE: logfind [-o] words&quot;);

    check(parse_args(&amp;use_or, &amp;argc, &amp;argv) == 0, &quot;USAGE: logfind [-o] words&quot;);

    check(list_files(&amp;files_found) == 0, &quot;Failed to list files.&quot;);

    for(i = 0; i &lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], use_or, argc, argv);
    }

    globfree(&amp;files_found);
    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex26\logfind.5\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind MAX_LINE
    ./logfind error MAX LINE
    ./logfind -o error MAX LINE

clean:
    rm -f logfind

</code></pre>

<p>If you ever get super stuck, you can visit:</p>

<p>To get all of the code for this book.</p>

<p>The Challenge</p>

<p>I want a tool called <code>logfind</code> that let&rsquo;s me search through log files for
text.  This tool is a specialized version of another tool called <code>grep</code>, but
designed only for log files on a system.</p>

<p>The Challenge</p>

<ul>
<li>This tool takes any sequence of words and assumes I mean &ldquo;and&rdquo; for them.  So <code>logfind zedshaw smart guy</code> will find all files that have <code>zedshaw</code> <em>and</em> <code>smart</code> <em>and</em> <code>guy</code> in them.</li>
<li>It takes an optional argument of <code>-o</code> if the parameters are meant to be <em>or</em> logic.</li>
<li>It loads the list of allowed log files from <code>~/.logfind</code>.</li>
</ul>

<p>The Challenge</p>

<ul>
<li>The list of file names can be anything that the <code>glob</code> function allows.  Refer to <code>man 3 glob</code> to see how this works.  I suggest starting with just a flat list of exact files, and then add <code>glob</code> functionality.</li>
<li>You should output the matching lines as you scan, and try to match them as fast as possible.</li>
</ul>

<p>Demo</p>

<p>Here is a demo of me using the one I wrote.</p>

<p>Pause!</p>

<p>Now it&rsquo;s time for you to attempt to solve it from just this idea.</p>

<p>The Clues</p>

<ul>
<li>Remember to solve it a piece at a time.</li>
<li>Start with just getting the arguments.</li>
<li>Then figure out how to open files and just open the ones in this directory.</li>
<li>Then figure out how to read the files.</li>
<li>Then find out how to find the arguments in the files.</li>
<li>Then figure out how glob works.</li>
<li>Then use glob to find the files and open them.</li>
</ul>

<p>It helps to do each of these in <em>main()</em> then &ldquo;carve&rdquo; them out into their
own functions.</p>

<p>Pause!</p>

<p>The Solution</p>

<p>Breaking It</p>

<h2 id="exercise-27-creative-and-defensive-programming">Exercise 27 Creative and Defensive Programming</h2>

<p>logfind.5</p>

<p>.\ex27\logfind.5\logfind.c</p>

<pre><code class="language-c">#define NDEBUG
#include &quot;dbg.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;glob.h&gt;
#include &lt;assert.h&gt;

const size_t MAX_LINE = 1024;


int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&quot;.logfind&quot;, &quot;r&quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &quot;Invalid glob_t given.&quot;);
    check_mem(line);
    check(file, &quot;Failed to open .logfind. Make that first.&quot;);

    while(fgets(line, MAX_LINE-1, file) != NULL) {
        size_t line_length = strnlen(line, MAX_LINE - 1);
        assert(line_length &lt; MAX_LINE &amp;&amp; &quot;Got a line length too long.&quot;);

        line[line_length] = '\0'; // drop the \n ending
        debug(&quot;Globbing %s&quot;, line);

        rc = glob(line, glob_flags, NULL, pglob);
        check(rc == 0 || rc == GLOB_NOMATCH, &quot;Failed to glob.&quot;);

        // dumb work around to a stupid design in glob
        if(glob_flags == GLOB_TILDE) glob_flags |= GLOB_APPEND;
    }

    for(i = 0; i &lt; pglob-&gt;gl_pathc; i++) {
        debug(&quot;Matched file: %s&quot;, pglob-&gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int found_it(int use_or, int found_count, int search_len)
{
    debug(&quot;use_or: %d, found_count: %d, search_len: %d&quot;, use_or, found_count, search_len);

    if(use_or &amp;&amp; found_count &gt; 0) {
        return 1;
    } else if(!use_or &amp;&amp; found_count == search_len) {
        return 1;
    } else {
        return 0;
    }
}

int scan_file(const char *filename, int use_or, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &quot;r&quot;);
    int found_count = 0;
    int i = 0;

    check_mem(line);
    check(file, &quot;Failed to open file: %s&quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL)
    {
        for(i = 0; i &lt; search_len; i++) {
            if(strcasestr(line, search_for[i]) != NULL) {
                debug(&quot;file: %s, line: %s, search: %s&quot;, filename, line, search_for[i]);
                found_count++;
            }
        }

        if(found_it(use_or, found_count, search_len)) {
            printf(&quot;%s\n&quot;, filename);
            break;
        } else {
            found_count = 0;
        }
    }


    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int parse_args(int *use_or, int *argc, char **argv[]) 
{
    (*argc)--;
    (*argv)++;

    if(strcmp((*argv)[0], &quot;-o&quot;) == 0) {
        *use_or = 1;
        (*argc)--; // skip the -o
        (*argv)++;
        check(*argc &gt; 1, &quot;You need words after -o.&quot;);
    } else {
        *use_or = 0;
    }

    return 0;
error:
    return -1;
}


int main(int argc, char *argv[])
{
    int i = 0;
    int use_or = 1;
    glob_t files_found;

    check(argc &gt; 1, &quot;USAGE: logfind [-o] words&quot;);

    check(parse_args(&amp;use_or, &amp;argc, &amp;argv) == 0, &quot;USAGE: logfind [-o] words&quot;);

    check(list_files(&amp;files_found) == 0, &quot;Failed to list files.&quot;);

    for(i = 0; i &lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], use_or, argc, argv);
    }

    globfree(&amp;files_found);
    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex27\logfind.5\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind MAX_LINE
    ./logfind error MAX LINE
    ./logfind -o error MAX LINE

clean:
    rm -f logfind

</code></pre>

<p>logfind.5</p>

<p>.\ex27\logfind.5\logfind.c</p>

<pre><code class="language-c">#define NDEBUG
#include &quot;dbg.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;glob.h&gt;
#include &lt;assert.h&gt;

const size_t MAX_LINE = 1024;


int list_files(glob_t *pglob) 
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(&quot;.logfind&quot;, &quot;r&quot;);
    int glob_flags = GLOB_TILDE;
    int i = 0;
    int rc = -1;

    check(pglob != NULL, &quot;Invalid glob_t given.&quot;);
    check_mem(line);
    check(file, &quot;Failed to open .logfind. Make that first.&quot;);

    while(fgets(line, MAX_LINE-1, file) != NULL) {
        size_t line_length = strnlen(line, MAX_LINE - 1);
        assert(line_length &lt; MAX_LINE &amp;&amp; &quot;Got a line length too long.&quot;);

        line[line_length] = '\0'; // drop the \n ending
        debug(&quot;Globbing %s&quot;, line);

        rc = glob(line, glob_flags, NULL, pglob);
        check(rc == 0 || rc == GLOB_NOMATCH, &quot;Failed to glob.&quot;);

        // dumb work around to a stupid design in glob
        if(glob_flags == GLOB_TILDE) glob_flags |= GLOB_APPEND;
    }

    for(i = 0; i &lt; pglob-&gt;gl_pathc; i++) {
        debug(&quot;Matched file: %s&quot;, pglob-&gt;gl_pathv[i]);
    }

    rc = 0; // all good

error: // fallthrough
    if(line) free(line);
    return rc;
}

int found_it(int use_or, int found_count, int search_len)
{
    debug(&quot;use_or: %d, found_count: %d, search_len: %d&quot;, use_or, found_count, search_len);

    if(use_or &amp;&amp; found_count &gt; 0) {
        return 1;
    } else if(!use_or &amp;&amp; found_count == search_len) {
        return 1;
    } else {
        return 0;
    }
}

int scan_file(const char *filename, int use_or, int search_len, char *search_for[])
{
    char *line = calloc(MAX_LINE, 1);
    FILE *file = fopen(filename, &quot;r&quot;);
    int found_count = 0;
    int i = 0;

    check_mem(line);
    check(file, &quot;Failed to open file: %s&quot;, filename);

    // read each line of the file and search that line for the contents
    while(fgets(line, MAX_LINE-1, file) != NULL)
    {
        for(i = 0; i &lt; search_len; i++) {
            if(strcasestr(line, search_for[i]) != NULL) {
                debug(&quot;file: %s, line: %s, search: %s&quot;, filename, line, search_for[i]);
                found_count++;
            }
        }

        if(found_it(use_or, found_count, search_len)) {
            printf(&quot;%s\n&quot;, filename);
            break;
        } else {
            found_count = 0;
        }
    }


    free(line);
    fclose(file);
    return 0;

error:
    if(line) free(line);
    if(file) fclose(file);

    return -1;
}

int parse_args(int *use_or, int *argc, char **argv[]) 
{
    (*argc)--;
    (*argv)++;

    if(strcmp((*argv)[0], &quot;-o&quot;) == 0) {
        *use_or = 1;
        (*argc)--; // skip the -o
        (*argv)++;
        check(*argc &gt; 1, &quot;You need words after -o.&quot;);
    } else {
        *use_or = 0;
    }

    return 0;
error:
    return -1;
}


int main(int argc, char *argv[])
{
    int i = 0;
    int use_or = 1;
    glob_t files_found;

    check(argc &gt; 1, &quot;USAGE: logfind [-o] words&quot;);

    check(parse_args(&amp;use_or, &amp;argc, &amp;argv) == 0, &quot;USAGE: logfind [-o] words&quot;);

    check(list_files(&amp;files_found) == 0, &quot;Failed to list files.&quot;);

    for(i = 0; i &lt; files_found.gl_pathc; i++) {
        scan_file(files_found.gl_pathv[i], use_or, argc, argv);
    }

    globfree(&amp;files_found);
    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex27\logfind.5\Makefile</p>

<pre><code class="language-makefile">CFLAGS=-Wall -g

all: logfind
    ./logfind || true
    ./logfind MAX_LINE
    ./logfind error MAX LINE
    ./logfind -o error MAX LINE

clean:
    rm -f logfind

</code></pre>

<p>Read The Book</p>

<p>This video is a demonstration of the concepts in the book.</p>

<p>Go read the book.</p>

<p>Demonstration</p>

<p>I will demonstrate each of the following:</p>

<ul>
<li>Fail early and openly.</li>
<li>Document assumptions.</li>
<li>Prevention over documentation.</li>
<li>Automate everything.</li>
<li>Simplify and clarify.</li>
<li>Question authority.</li>
</ul>

<p>Fail Early and Openly</p>

<p>Document Assumptions</p>

<p>Prevention over Documentation</p>

<p>Automate Everything</p>

<p>Simplify and Clarify</p>

<p>Question Authority</p>

<p>Bonus: Assume Nothing</p>

<h2 id="exercise-28-intermediate-makefiles">Exercise 28 Intermediate Makefiles</h2>

<p>The Plan</p>

<ul>
<li>Learn how to create a project skeleton to make starting easier.</li>
<li>Learn more advanced GNU make tricks.</li>
</ul>

<p>The Skeleton</p>

<p>.\ex28\c-skeleton</p>

<p>.\ex28\c-skeleton\src\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex28\c-skeleton\src\libex29.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &quot;dbg.h&quot;


int print_a_message(const char *msg)
{
    printf(&quot;A STRING: %s\n&quot;, msg);

    return 0;
}


int uppercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, toupper(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int lowercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, tolower(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int fail_on_purpose(const char *msg)
{
    return 1;
} 

</code></pre>

<p>.\ex28\c-skeleton\tests\libex29_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;dlfcn.h&gt;

typedef int (*lib_function) (const char *data);
char *lib_file = &quot;build/libYOUR_LIBRARY.so&quot;;
void *lib = NULL;

int check_function(const char *func_to_run, const char *data,
        int expected)
{
    lib_function func = dlsym(lib, func_to_run);
    check(func != NULL,
            &quot;Did not find %s function in the library %s: %s&quot;, func_to_run,
            lib_file, dlerror());

    int rc = func(data);
    check(rc == expected, &quot;Function %s return %d for data: %s&quot;,
            func_to_run, rc, data);

    return 1;
error:
    return 0;
}

char *test_dlopen()
{
    lib = dlopen(lib_file, RTLD_NOW);
    mu_assert(lib != NULL, &quot;Failed to open the library to test.&quot;);

    return NULL;
}

char *test_functions()
{
    mu_assert(check_function(&quot;print_a_message&quot;, &quot;Hello&quot;, 0),
            &quot;print_a_message failed.&quot;);
    mu_assert(check_function(&quot;uppercase&quot;, &quot;Hello&quot;, 0),
            &quot;uppercase failed.&quot;);
    mu_assert(check_function(&quot;lowercase&quot;, &quot;Hello&quot;, 0),
            &quot;lowercase failed.&quot;);

    return NULL;
}

char *test_failures()
{
    mu_assert(check_function(&quot;fail_on_purpose&quot;, &quot;Hello&quot;, 1),
            &quot;fail_on_purpose should fail.&quot;);

    return NULL;
}

char *test_dlclose()
{
    int rc = dlclose(lib);
    mu_assert(rc == 0, &quot;Failed to close lib.&quot;);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dlopen);
    mu_run_test(test_functions);
    mu_run_test(test_failures);
    mu_run_test(test_dlclose);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>The video is probably easier to follow than the book.
Watch me do this.</p>

<p>Using The Skeleton</p>

<p>.\ex28\c-skeleton</p>

<p>.\ex28\c-skeleton\src\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex28\c-skeleton\src\libex29.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &quot;dbg.h&quot;


int print_a_message(const char *msg)
{
    printf(&quot;A STRING: %s\n&quot;, msg);

    return 0;
}


int uppercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, toupper(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int lowercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, tolower(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int fail_on_purpose(const char *msg)
{
    return 1;
} 

</code></pre>

<p>.\ex28\c-skeleton\tests\libex29_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;dlfcn.h&gt;

typedef int (*lib_function) (const char *data);
char *lib_file = &quot;build/libYOUR_LIBRARY.so&quot;;
void *lib = NULL;

int check_function(const char *func_to_run, const char *data,
        int expected)
{
    lib_function func = dlsym(lib, func_to_run);
    check(func != NULL,
            &quot;Did not find %s function in the library %s: %s&quot;, func_to_run,
            lib_file, dlerror());

    int rc = func(data);
    check(rc == expected, &quot;Function %s return %d for data: %s&quot;,
            func_to_run, rc, data);

    return 1;
error:
    return 0;
}

char *test_dlopen()
{
    lib = dlopen(lib_file, RTLD_NOW);
    mu_assert(lib != NULL, &quot;Failed to open the library to test.&quot;);

    return NULL;
}

char *test_functions()
{
    mu_assert(check_function(&quot;print_a_message&quot;, &quot;Hello&quot;, 0),
            &quot;print_a_message failed.&quot;);
    mu_assert(check_function(&quot;uppercase&quot;, &quot;Hello&quot;, 0),
            &quot;uppercase failed.&quot;);
    mu_assert(check_function(&quot;lowercase&quot;, &quot;Hello&quot;, 0),
            &quot;lowercase failed.&quot;);

    return NULL;
}

char *test_failures()
{
    mu_assert(check_function(&quot;fail_on_purpose&quot;, &quot;Hello&quot;, 1),
            &quot;fail_on_purpose should fail.&quot;);

    return NULL;
}

char *test_dlclose()
{
    int rc = dlclose(lib);
    mu_assert(rc == 0, &quot;Failed to close lib.&quot;);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dlopen);
    mu_run_test(test_functions);
    mu_run_test(test_failures);
    mu_run_test(test_dlclose);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>Now I&rsquo;ll use the skeleton to start a simple project for the next exercise.</p>

<p>The Analysis</p>

<p>Let&rsquo;s look at Makefile in depth.</p>

<p>Extra Credit</p>

<h2 id="exercise-29-libraries-and-linking">Exercise 29 Libraries and Linking</h2>

<p>The Plan</p>

<ul>
<li>Learn about libraries and how to link against them.</li>
<li>Learn how to load a dynamic library from inside C.</li>
</ul>

<p>The Code</p>

<p>.\ex29\ex29.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;dbg.h&quot;
#include &lt;dlfcn.h&gt;

typedef int (*lib_function) (const char *data);

int main(int argc, char *argv[])
{
    int rc = 0;
    check(argc == 4, &quot;USAGE: ex29 libex29.so function data&quot;);

    char *lib_file = argv[1];
    char *func_to_run = argv[2];
    char *data = argv[3];

    void *lib = dlopen(lib_file, RTLD_NOW);
    check(lib != NULL, &quot;Failed to open the library %s: %s&quot;, lib_file,
            dlerror());

    lib_function func = dlsym(lib, func_to_run);
    check(func != NULL,
            &quot;Did not find %s function in the library %s: %s&quot;, func_to_run,
            lib_file, dlerror());

    rc = func(data);
    check(rc == 0, &quot;Function %s return %d for data: %s&quot;, func_to_run,
            rc, data);

    rc = dlclose(lib);
    check(rc == 0, &quot;Failed to close %s&quot;, lib_file);

    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex29\libex29.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &quot;dbg.h&quot;


int print_a_message(const char *msg)
{
    printf(&quot;A STRING: %s\n&quot;, msg);

    return 0;
}


int uppercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, toupper(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int lowercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, tolower(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int fail_on_purpose(const char *msg)
{
    return 1;
} 

</code></pre>

<p>I&rsquo;ll use the project I started from the previous exercise.
This covers some of the extra credit.</p>

<p>The Analysis</p>

<p>This analysis might take a while, but be sure you know Exercise 28 well.</p>

<p>Breaking It</p>

<ul>
<li>Wreck the libex29.so file.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Were you paying attention to the bad code I have in the <code>libex29.c</code> functions?
Do you see how, even though I use a for-loop they still check for <code>'\0'</code>
endings?  Fix this so that the functions always take a length for the
string to work with inside the function.</li>
<li>Read the <code>man dlopen</code> documentation and read about all of the
related functions.  Try some of the other options to <code>dlopen</code>
beside <code>RTLD_NOW</code>.</li>
</ul>

<h2 id="exercise-30-automated-testing">Exercise 30 Automated Testing</h2>

<p>The Plan</p>

<p>Continue the Exercise 28-29 project and add automated tests to it.</p>

<p>Why Automate Tests</p>

<p>You are a programmer.
Your job is automating.</p>

<p>EVERYTHING</p>

<p>The Code</p>

<p>.\ex30\ex30.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;

char *test_dlopen(int stuff)
{
    return NULL;
}

char *test_functions()
{

    return NULL;
}

char *test_failures()
{

    return NULL;
}

char *test_dlclose()
{

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dlopen);
    mu_run_test(test_functions);
    mu_run_test(test_failures);
    mu_run_test(test_dlclose);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>Adding It To libex29</p>

<p>Breaking It</p>

<ul>
<li>Making tests fail first is useful.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>This works but it&rsquo;s probably a bit messy.  Clean the <code>c-skeleton</code>
directory up so that it has all of these files, but remove any of the code
related to Exercise 29.  You should be able to copy this directory
over and kick-start new projects without much editing.</li>
<li>Study the <code>runtests.sh</code>, and then go read about <code>bash</code> syntax
so you know what it does.  Do you think you could write a C version of this
script?</li>
</ul>

<h2 id="exercise-31-common-undefined-behavior">Exercise 31 Common Undefined Behavior</h2>

<p>The Plan</p>

<p>Review the issues around Undefined and Unspecified Behavior (UB).</p>

<p>Read The Book</p>

<p>The book lists many of the UB and discusses why they are important to know
about.</p>

<p>The Code</p>

<p>.\ex31\ex31.c</p>

<pre><code class="language-c">#include &lt;unistd.h&gt;

int main(int argc, char *argv[])
{
    int i = 0;

    while (i &lt; 100) {
        usleep(3000);
    }

    return 0;
}

</code></pre>

<p>There is no code for this exercise, just a quick discussion for the book.</p>

<p>Undefined Behavior</p>

<ul>
<li>Compiler writers can do whatever they want.</li>
<li>This means even <em>nothing</em>, which will ruin you silently.</li>
<li>It&rsquo;s best to avoid it.</li>
</ul>

<p>Unspecified Behavior</p>

<ul>
<li>For practical purposes unspecified is the same as undefined.</li>
</ul>

<p>Handy Tools</p>

<ul>
<li>Clang&rsquo;s UB helpful flags.</li>
<li>Lint tools and static analyzers.</li>
</ul>

<p>Extra Credit</p>

<p>Spend a day reading through as much of the UB as you can and find examples of each.  Expect lots of frustration and failure when you do this.</p>

<h2 id="exercise-32-double-linked-lists">Exercise 32 Double Linked Lists</h2>

<p>The Plan</p>

<p>Learn about your very first data structure:</p>

<p>Double Linked Lists</p>

<p>Creating A liblcthw Project</p>

<p>We&rsquo;ll need a project for the rest of the book called <em>liblcthw</em>.</p>

<p>Algorithms and Data Structures</p>

<p>A big step in going from amateur to professional is learning
about data structures and algorithms.</p>

<p>A double linked list is the easiest one.</p>

<p>Double Linked Lists Visually</p>

<p>I&rsquo;ll quickly draw some diagrams to show you how they work.</p>

<p>Automated Testing Demo</p>

<p>You can enter the code just fine, but watch me write
the test.</p>

<p>Code Reviews</p>

<p>Later videos will demonstrate how to code review to make code solid.</p>

<p>Improving It</p>

<ul>
<li>You can make <code>List_clear_destroy</code> more efficient by using
<code>LIST_FOREACH</code> and doing both <code>free</code> calls inside one
loop.</li>
<li>You can add asserts for preconditions so that the program isn&rsquo;t given a <code>NULL</code>
value for the <code>List *list</code> parameters.</li>
</ul>

<p>Improving It</p>

<ul>
<li>You can add invariants that check that the list&rsquo;s contents are always correct,
such as <code>count</code> is never <code>&lt; 0</code>, and if <code>count &gt; 0</code>, then <code>first</code> isn&rsquo;t NULL.</li>
<li>You can add documentation to the header file in the form of comments before
each struct, function, and macro that describes what it does.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Research doubly vs. singly linked lists and when one is preferred over
the other.</li>
<li>Research the limitations of a doubly linked list.  For example, while they
are efficient for inserting and deleting elements, they are very slow for
iterating over them all.</li>
<li>What operations are missing that you can imagine needing?  Some examples
are copying, joining, and splitting.  Implement these operations and write the
unit tests for them.</li>
</ul>

<h2 id="exercise-33-linked-list-algorithms">Exercise 33 Linked List Algorithms</h2>

<p>The Plan</p>

<p>Learn two sorting algorithms for double linked lists.</p>

<p>Watch how to conduct a simple code review.</p>

<p>The Code</p>

<p>You should be able to create this and figure out how it works.</p>

<p>I will assume you&rsquo;ve done that, and now to code review.</p>

<p>Bubble Sort</p>

<p>Code review of bubble sort.</p>

<p>Start with the unit test and move from there.</p>

<p>Merge Sort</p>

<p>Code review of merge sort.</p>

<p>Improving It</p>

<ul>
<li>The merge sort does a crazy amount of copying and creating lists, so find ways to reduce this.</li>
<li>The bubble sort description in Wikipedia mentions a few optimizations. Try to implement them.</li>
<li>Can you use the <code>List_split</code> and <code>List_join</code> (if you implemented them) to improve merge sort?</li>
<li>Go through of all the defensive programming checks and improve the robustness of
this implementation, protecting against bad <code>NULL</code> pointers, and then create
an optional debug level invariant that works like <code>is_sorted</code> does
after a sort.</li>
</ul>

<p>Breaking It</p>

<ul>
<li>Overload the data structure to hit the worst case time complexity.</li>
<li>Give it a bad data structure.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Create a unit test that compares the performance of the two algorithms.  You&rsquo;ll want to look at <code>man 3 time</code> for a basic timer function,
and run enough iterations to at least have a few seconds of samples.</li>
<li>Play with the amount of data in the lists that need to be sorted and see if that changes your timing.</li>
<li>Find a way to simulate filling different sized random lists, measuring how long they take. Then, graph the result to see how it compares to the
description of the algorithm.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Try to explain why sorting linked lists is a really bad idea.</li>
<li>Implement a <code>List_insert_sorted</code> that will take a given value, and using the <code>List_compare</code>, insert the element at the
right position so that the list is always sorted.  How does using this method compare to sorting a list after you&rsquo;ve built it?</li>
<li>Try implementing the bottom-up merge sort described on the Wikipedia page.  The code there is already C, so it should be easy to
recreate, but try to understand how it&rsquo;s working compared to the slower one I have here.</li>
</ul>

<h2 id="exercise-34-dynamic-array">Exercise 34 Dynamic Array</h2>

<p>The Plan</p>

<p>Learn about dynamic arrays, a very useful datastructure.</p>

<p>Code Review</p>

<p>Starting with the header file to implement, then the test, then the implementation.</p>

<p>The Analysis</p>

<p>DArray Advantages</p>

<ul>
<li>Iteration:  You can just use a basic for-loop and <code>DArray_count</code>
with <code>DArray_get</code>, and you&rsquo;re done.  No special macros needed, and
it&rsquo;s faster because you aren&rsquo;t walking through pointers.</li>
<li>Indexing:  You can use <code>DArray_get</code> and <code>DArray_set</code> to
access any element at random, but with a <code>List</code> you have to go
through N elements to get to N+1.</li>
<li>Destroying:  You can just free the struct and the <code>contents</code> in
two operations.  A <code>List</code> requires a series of <code>free</code> calls
and walking every element.</li>
</ul>

<p>DArray Advantages</p>

<ul>
<li>Cloning: You can also clone it in just two operations (plus whatever
it&rsquo;s storing) by copying the struct and <code>contents</code>.  A list
again requires walking through the whole thing and copying every <code>ListNode</code>
plus its value.</li>
<li>Sorting: As you saw, <code>List</code> is horrible if you need to keep the
data sorted.  A <code>DArray</code> opens up a whole class of great sorting
algorithms, because now you can access elements randomly.</li>
<li>Large Data: If you need to keep around a lot of data, then a <code>DArray</code>
wins since its base, <code>contents</code>, takes up less memory than the same
number of <code>ListNode</code> structs.</li>
</ul>

<p>DArray Disadvantages</p>

<ul>
<li>Insert and remove on the front (what I called shift).  A <code>DArray</code>
needs special treatment to be able to do this efficiently, and usually it
has to do some copying.</li>
<li>Splitting or joining:  A <code>List</code> can just copy some pointers and
it&rsquo;s done, but with a <code>DArray</code>, you have copy all of the
arrays involved.</li>
</ul>

<p>DArray Disadvantages</p>

<ul>
<li>Small Data. If you only need to store a few elements, then typically the
storage will be less in a <code>List</code> than a generic <code>DArray</code>. This is because
the <code>DArray</code> needs to expand the backing store to accommodate future
inserts, while a <code>List</code> only makes what it needs.</li>
</ul>

<p>Breaking It</p>

<ul>
<li>Forget to check the return value from malloc and then use the buffer.</li>
<li>Getting the end and start count of the buffer wrong.  Easy to do an off-by-one here.</li>
<li>Exploit the insert and delete costs to cause a denial of service.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Improve the unit tests to cover more of the operations, and test them
using a for-loop to ensure that they work.</li>
<li>Research what it would take to implement bubble sort and merge sort
for DArray, but don&rsquo;t do it yet.  I&rsquo;ll be implementing DArray algorithms
next, so you&rsquo;ll do this then.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Write some performance tests for common operations and compare them
to the same operations in <code>List</code>.  You did some of this already, but this
time, write a unit test that repeatedly does the operation in question, and
then in the main runner, do the timing.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Look at how the <code>DArray_expand</code> is implemented using a constant increase (size + 300).
Typically, dynamic arrays are implemented with a multiplicative increase (size * 2), but I&rsquo;ve
found this to cost needless memory for no real performance gain.  Test my assertion
and see when you&rsquo;d want a multiplicative increase instead of a constant increase.</li>
</ul>

<h2 id="exercise-35-sorting-and-searching">Exercise 35 Sorting and Searching</h2>

<p>The Plan</p>

<ul>
<li>Make a simple DArray sorting library using existing functions.</li>
<li>Implement a new structure and algorithm called a &ldquo;Radix Map&rdquo;.</li>
<li>Create a binary search algorithm for the RadixMap.</li>
</ul>

<p>The DArray Code</p>

<p>Continuing the code review method with a part of DArray.</p>

<p>The RadixMap Code</p>

<p>Code review this code next.</p>

<p>The Binary Search Code</p>

<p>Finally, code review of the BSTree code.</p>

<p>Improving It</p>

<ul>
<li>Use a binary search to find the minimum position for the
new element, then only sort from there to the end.  You find the
minimum, put the new element on the end, and then just sort from
the minimum on.   This will cut your sort space down
considerably most of the time.</li>
<li>Keep track of the biggest key currently being used, and then only
sort enough digits to handle that key.  You can also keep track
of the smallest number, and then only sort the digits necessary
for the range.  To do this, you&rsquo;ll have to start caring about
CPU integer ordering (endianness).</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Implement quicksort, heapsort, and merge sort and then provide a <em>#define</em>
that lets you pick between the two, or create a second set of functions
you can call.  Use the technique I taught you to read the Wikipedia page
for the algorithm, and then implement it with the psuedo-code.</li>
<li>Compare the performance of your optimizations to the original implementations.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Use these sorting functions to create a <em>DArray_sort_add</em> that
adds elements to the <em>DArray</em> but sorts the array after.</li>
<li>Write a <em>DArray_find</em> that uses the binary search algorithm from
<em>RadixMap_find</em> and the <em>DArray_compare</em> to find elements
in a sorted <em>DArray</em>.</li>
</ul>

<h2 id="exercise-36-safer-strings">Exercise 36 Safer Strings</h2>

<p>The Plan</p>

<p>Learn about an alternative string implementation to avoid most C string problems.</p>

<p>C Strings Suck</p>

<p>It is impossible to safely process strings in C.</p>

<p>The bstrling Library</p>

<p>An alternative is a library that provides alternative APIs for working with
C strings.</p>

<p>The Common Functions</p>

<pre><code>bfromcstr    Create a bstring from a C style constant.
blk2bstr     Do the same thing, but give the length of the buffer.
bstrcpy      Copy a bstring.
bassign      Set one bstring to another.
bassigncstr  Set a bstring to a C string's contents.
bassignblk   Set a bstring to a C string but give the length.
bdestroy     Destroy a bstring.
bconcat      Concatenate one bstring onto another.
bstricmp     Compare two bstrings returning the same result as strcmp.
biseq        Tests if two bstrings are equal.
</code></pre>

<p>The Common Functions</p>

<pre><code>binstr       Tells if one bstring is in another.
bfindreplace Find one bstring in another, then replace it with a third.
bsplit       Split a bstring into a bstrList.
bformat      Do a format string, which is super handy.
blength      Get the length of a bstring.
bdata        Get the data from a bstring.
bchar        Get a char from a bstring.
</code></pre>

<p>Extra Credit</p>

<p>There is only one extra credit and that&rsquo;s to write a <em>tests/bstr_tests.c</em> file that
tests all of these functions.  The bstrlib comes with a test that you can reference it if needed.</p>

<h2 id="exercise-37-hashmaps">Exercise 37 Hashmaps</h2>

<p>The Plan</p>

<p>Implement a Hashmap in C.
In Python these are called Dictionaries.</p>

<p>Hashmaps Visually</p>

<p>Hashmaps are very intuitive once you know how a DArray works.
It&rsquo;s all about the hashing function used.</p>

<p>Code Review</p>

<p>Conducting a review of Hashmap by following the test.</p>

<p>Improving It</p>

<ul>
<li>You can use a sort on each bucket so that they&rsquo;re always sorted.
This increases your insert time but decreases your find time, because
you can then use a binary search to find each node.  Right now,
it&rsquo;s looping through all of the nodes in a bucket just to find one.</li>
<li>You can dynamically size the number of buckets, or let the caller
specify the number for each <em>Hashmap</em> created.</li>
<li>You can use a better <em>default_hash</em>.  There are tons of them.</li>
</ul>

<p>Improving It</p>

<ul>
<li>This (and nearly every <em>Hashmap</em>) is vulnerable to someone picking
keys that will fill only one bucket, and then tricking your program
into processing them.  This then makes your program run slower because
it changes from processing a <em>Hashmap</em> to effectively processing
a single <em>DArray</em>.  If you sort the nodes in the bucket, this
helps, but you can also use better hashing functions, and for
the really paranoid programmer, add a random salt so that keys can&rsquo;t be predicted.</li>
</ul>

<p>Improving It</p>

<ul>
<li>You could have it delete buckets that are empty of nodes to save space,
or put empty buckets into a cache so you can save on time lost creating and destroying
them.</li>
<li>Right now, it just adds elements even if they already exist.  Write an
alternative set method that only adds an element if it isn&rsquo;t set already.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Research the <em>Hashmap</em> implementation in your favorite programming language to see what features it has.</li>
<li>Find out what the major disadvantages of a <em>Hashmap</em> are and how to avoid them.  For example, it doesn&rsquo;t preserve order without special changes, nor does it work when you need to find things based on parts
of keys.</li>
<li>Write a unit test that demonstrates the defect of filling a <em>Hashmap</em> with keys that land
in the same bucket, then test how this impacts performance.  A good way to do this is to just reduce
the number of buckets to something stupid, like five.</li>
</ul>

<h2 id="exercise-38-hashmap-algorithms">Exercise 38 Hashmap Algorithms</h2>

<p>The Plan</p>

<p>Learn three different string hashing algorithms and make them dynamically available
to the Hashmap.</p>

<p>Code Review</p>

<p>The default is the Jenkin&rsquo;s hash.</p>

<p>You added the FNV1a, Adler32, and DJB hashing algorithms.</p>

<p>Review the code for FNV1a vs. DJB.</p>

<p>Breaking It</p>

<p>In this exercise you will attempt to write the worst hashing function that can
pass for a real one.  Try to make one that either looks complicated but
statistically is way off, or is a discrete change to an existing one that is a
bad change.</p>

<p>Extra Credit</p>

<ul>
<li>Take the <code>default_hash</code> out of the <code>hashmap.c</code>, make it
one of the algorithms in <code>hashmap_algos.c</code>, and then make all
of the tests work again.</li>
<li>Add the <code>default_hash</code> to the <code>hashmap_algos_tests.c</code>
test and compare its statistics to the other hash functions.</li>
<li>Find a few more hash functions and add them, too. You can never have too
many hash functions!</li>
</ul>

<h2 id="exercise-39-string-algorithms">Exercise 39 String Algorithms</h2>

<p>The Plan</p>

<p>Develop a formal code review procedure.</p>

<p>The Code</p>

<p>The code is easy to implement so should be no problem for you
at this point.  Focus on getting the unit test right.</p>

<p>Code Review Process</p>

<ol>
<li>Start at the entry point for a piece of code that has changed.</li>
<li>For each function, confirm that its calling parameters are correct.</li>
<li>Enter that function, and confirm each line&rsquo;s correctness.</li>
<li>When you encounter a function, repeat up to #2 until you go no further.</li>
<li>As you exit functions, confirm the return values and their usage.</li>
<li>Continue until you are back where you started at the entry point.</li>
<li>Do a diff on your changes, and confirm any missed calls to changed functions.</li>
</ol>

<p>Code Review Key Points</p>

<ol>
<li>Check your pointer dereferences and defend against NULL.</li>
<li>Check if-statements and while loops for exiting.</li>
<li>Check return values are going to be valid.</li>
<li>Check that memory allocated is freed and other resources freed.</li>
<li>Confirm all system call parameters are correct with man pages.</li>
</ol>

<p>Record Your Code Review</p>

<p>I want <em>you</em> to try to record yourself coding and reviewing your
code.  What do you learn from this experience?</p>

<p>What if you kept track of the number of mistakes you found in
your code reviews and analyzed the data?</p>

<p>Extra Credit</p>

<ul>
<li>See if you can make the <code>Scan_find</code> faster.  Why is my implementation
here slow?</li>
<li>Try some different scan times and see if you get different numbers.
What impact does the length of time that you run the test have on
the <code>scan</code> times?  What can you say about that result?</li>
<li>Alter the unit test so that it runs each function for a short burst
in the beginning to clear out any warm up period, and then start the
timing portion.  Does that change the dependence on the length of time
the test runs?  Does it change how many operations per second are possible?</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Make the unit test randomize the strings to find and then measure
the performance you get.  One way to do this is to use the <code>bsplit</code>
function from <code>bstrlib.h</code> to split the <code>IN_STR</code> on
spaces.  Then, you can use the <code>bstrList</code> struct that you get to access each
string it returns.  This will also teach you how to use <code>bstrList</code>
operations for string processing.</li>
<li>Try some runs with the tests in different orders to see if you get different
results.</li>
</ul>

<h2 id="exercise-40-binary-search-trees">Exercise 40 Binary Search Trees</h2>

<p>The Plan</p>

<p>Implement a Binary Search Tree, a competitor to the Hashmap.</p>

<p>Binary Search Trees Visually</p>

<p>The Code</p>

<p>There&rsquo;s nothing new in the code, but make sure you read the book carefully.</p>

<p>Code Review</p>

<p>I&rsquo;ll walk through the implementation and compare it to Hashmaps for features.</p>

<p>Improving It</p>

<ul>
<li>As usual, you should go through all of the defensive programming checks and add
*assert*s for conditions that shouldn&rsquo;t happen.  For example, you shouldn&rsquo;t be getting <em>NULL</em> values for the recursion functions, so assert that.</li>
<li>The traverse function walks through the tree in order by traversing left, then right,
and then the current node.  You can create traverse functions for the reverse order, as well.</li>
</ul>

<p>Improving It</p>

<ul>
<li>It does a full string compare on every node, but I could use the <em>Hashmap</em>
hashing functions to speed this up.  I could hash the keys, and then keep the hash in
the <em>BSTreeNode</em>.  Then, in each of the set up functions, I can hash the
key ahead of time, and pass it down to the recursive function.  Using this hash, I can
then compare each node much quicker in a way that&rsquo;s similar to what I do in <em>Hashmap</em>.</li>
</ul>

<p>Breaking It</p>

<p>A big flaw in this is the use of recursion.  An attacker could choose data to cause a stack overflow.</p>

<p>Extra Credit</p>

<ul>
<li>There&rsquo;s an alternative way to do this data structure without using recursion.  The Wikipedia
page shows alternatives that don&rsquo;t use recursion but do the same thing.  Why would this
be better or worse?</li>
<li>Read up on all of the different but similar trees you can find. There are AVL trees (named after Georgy Adelson-Velsky and E.M. Landis), red-black trees,
and some non-tree structures like skip lists.</li>
</ul>

<h2 id="exercise-41-project-devpkg">Exercise 41 Project devpkg</h2>

<p>.\ex41\devpkg</p>

<p>.\ex41\devpkg\commands.c</p>

<pre><code class="language-c">#include &lt;apr_uri.h&gt;
#include &lt;apr_fnmatch.h&gt;
#include &lt;unistd.h&gt;

#include &quot;commands.h&quot;
#include &quot;dbg.h&quot;
#include &quot;bstrlib.h&quot;
#include &quot;db.h&quot;
#include &quot;shell.h&quot;

int Command_depends(apr_pool_t * p, const char *path)
{
    FILE *in = NULL;
    bstring line = NULL;

    in = fopen(path, &quot;r&quot;);
    check(in != NULL, &quot;Failed to open downloaded depends: %s&quot;, path);

    for (line = bgets((bNgetc) fgetc, in, '\n');
            line != NULL; 
            line = bgets((bNgetc) fgetc, in, '\n')) 
    {
        btrimws(line);
        log_info(&quot;Processing depends: %s&quot;, bdata(line));
        int rc = Command_install(p, bdata(line), NULL, NULL, NULL);
        check(rc == 0, &quot;Failed to install: %s&quot;, bdata(line));
        bdestroy(line);
    }

    fclose(in);
    return 0;

error:
    if (line) bdestroy(line);
    if (in) fclose(in);
    return -1;
}

int Command_fetch(apr_pool_t * p, const char *url, int fetch_only)
{
    apr_uri_t info = {.port = 0 };
    int rc = 0;
    const char *depends_file = NULL;
    apr_status_t rv = apr_uri_parse(p, url, &amp;info);

    check(rv == APR_SUCCESS, &quot;Failed to parse URL: %s&quot;, url);

    if (apr_fnmatch(GIT_PAT, info.path, 0) == APR_SUCCESS) {
        rc = Shell_exec(GIT_SH, &quot;URL&quot;, url, NULL);
        check(rc == 0, &quot;git failed.&quot;);
    } else if (apr_fnmatch(DEPEND_PAT, info.path, 0) == APR_SUCCESS) {
        check(!fetch_only, &quot;No point in fetching a DEPENDS file.&quot;);

        if (info.scheme) {
            depends_file = DEPENDS_PATH;
            rc = Shell_exec(CURL_SH, &quot;URL&quot;, url, &quot;TARGET&quot;, depends_file,
                    NULL);
            check(rc == 0, &quot;Curl failed.&quot;);
        } else {
            depends_file = info.path;
        }

        // recursively process the devpkg list
        log_info(&quot;Building according to DEPENDS: %s&quot;, url);
        rv = Command_depends(p, depends_file);
        check(rv == 0, &quot;Failed to process the DEPENDS: %s&quot;, url);

        // this indicates that nothing needs to be done
        return 0;

    } else if (apr_fnmatch(TAR_GZ_PAT, info.path, 0) == APR_SUCCESS) {
        if (info.scheme) {
            rc = Shell_exec(CURL_SH,
                    &quot;URL&quot;, url, &quot;TARGET&quot;, TAR_GZ_SRC, NULL);
            check(rc == 0, &quot;Failed to curl source: %s&quot;, url);
        }

        rv = apr_dir_make_recursive(BUILD_DIR,
                APR_UREAD | APR_UWRITE |
                APR_UEXECUTE, p);
        check(rv == APR_SUCCESS, &quot;Failed to make directory %s&quot;,
                BUILD_DIR);

        rc = Shell_exec(TAR_SH, &quot;FILE&quot;, TAR_GZ_SRC, NULL);
        check(rc == 0, &quot;Failed to untar %s&quot;, TAR_GZ_SRC);
    } else if (apr_fnmatch(TAR_BZ2_PAT, info.path, 0) == APR_SUCCESS) {
        if (info.scheme) {
            rc = Shell_exec(CURL_SH, &quot;URL&quot;, url, &quot;TARGET&quot;, TAR_BZ2_SRC,
                    NULL);
            check(rc == 0, &quot;Curl failed.&quot;);
        }

        apr_status_t rc = apr_dir_make_recursive(BUILD_DIR,
                APR_UREAD | APR_UWRITE
                | APR_UEXECUTE, p);

        check(rc == 0, &quot;Failed to make directory %s&quot;, BUILD_DIR);
        rc = Shell_exec(TAR_SH, &quot;FILE&quot;, TAR_BZ2_SRC, NULL);
        check(rc == 0, &quot;Failed to untar %s&quot;, TAR_BZ2_SRC);
    } else {
        sentinel(&quot;Don't now how to handle %s&quot;, url);
    }

    // indicates that an install needs to actually run
    return 1;
error:
    return -1;
}

int Command_build(apr_pool_t * p, const char *url,
        const char *configure_opts, const char *make_opts,
        const char *install_opts)
{
    int rc = 0;

    check(access(BUILD_DIR, X_OK | R_OK | W_OK) == 0,
            &quot;Build directory doesn't exist: %s&quot;, BUILD_DIR);

    // actually do an install
    if (access(CONFIG_SCRIPT, X_OK) == 0) {
        log_info(&quot;Has a configure script, running it.&quot;);
        rc = Shell_exec(CONFIGURE_SH, &quot;OPTS&quot;, configure_opts, NULL);
        check(rc == 0, &quot;Failed to configure.&quot;);
    }

    rc = Shell_exec(MAKE_SH, &quot;OPTS&quot;, make_opts, NULL);
    check(rc == 0, &quot;Failed to build.&quot;);

    rc = Shell_exec(INSTALL_SH,
            &quot;TARGET&quot;, install_opts ? install_opts : &quot;install&quot;,
            NULL);
    check(rc == 0, &quot;Failed to install.&quot;);

    rc = Shell_exec(CLEANUP_SH, NULL);
    check(rc == 0, &quot;Failed to cleanup after build.&quot;);

    rc = DB_update(url);
    check(rc == 0, &quot;Failed to add this package to the database.&quot;);

    return 0;

error:
    return -1;
}

int Command_install(apr_pool_t * p, const char *url,
        const char *configure_opts, const char *make_opts,
        const char *install_opts)
{
    int rc = 0;
    check(Shell_exec(CLEANUP_SH, NULL) == 0,
            &quot;Failed to cleanup before building.&quot;);

    rc = DB_find(url);
    check(rc != -1, &quot;Error checking the install database.&quot;);

    if (rc == 1) {
        log_info(&quot;Package %s already installed.&quot;, url);
        return 0;
    }

    rc = Command_fetch(p, url, 0);

    if (rc == 1) {
        rc = Command_build(p, url, configure_opts, make_opts,
                install_opts);
        check(rc == 0, &quot;Failed to build: %s&quot;, url);
    } else if (rc == 0) {
        // no install needed
        log_info(&quot;Depends successfully installed: %s&quot;, url);
    } else {
        // had an error
        sentinel(&quot;Install failed: %s&quot;, url);
    }

    Shell_exec(CLEANUP_SH, NULL);
    return 0;

error:
    Shell_exec(CLEANUP_SH, NULL);
    return -1;
}

</code></pre>

<p>.\ex41\devpkg\commands.h</p>

<pre><code class="language-c">#ifndef _commands_h
#define _commands_h

#include &lt;apr_pools.h&gt;

#define DEPENDS_PATH &quot;/tmp/DEPENDS&quot;
#define TAR_GZ_SRC &quot;/tmp/pkg-src.tar.gz&quot;
#define TAR_BZ2_SRC &quot;/tmp/pkg-src.tar.bz2&quot;
#define BUILD_DIR &quot;/tmp/pkg-build&quot;
#define GIT_PAT &quot;*.git&quot;
#define DEPEND_PAT &quot;*DEPENDS&quot;
#define TAR_GZ_PAT &quot;*.tar.gz&quot;
#define TAR_BZ2_PAT &quot;*.tar.bz2&quot;
#define CONFIG_SCRIPT &quot;/tmp/pkg-build/configure&quot;

enum CommandType {
    COMMAND_NONE, COMMAND_INSTALL, COMMAND_LIST, COMMAND_FETCH,
    COMMAND_INIT, COMMAND_BUILD
};

int Command_fetch(apr_pool_t * p, const char *url, int fetch_only);

int Command_install(apr_pool_t * p, const char *url,
        const char *configure_opts, const char *make_opts,
        const char *install_opts);

int Command_depends(apr_pool_t * p, const char *path);

int Command_build(apr_pool_t * p, const char *url,
        const char *configure_opts, const char *make_opts,
        const char *install_opts);

#endif

</code></pre>

<p>.\ex41\devpkg\db.c</p>

<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;apr_errno.h&gt;
#include &lt;apr_file_io.h&gt;

#include &quot;db.h&quot;
#include &quot;bstrlib.h&quot;
#include &quot;dbg.h&quot;

static FILE *DB_open(const char *path, const char *mode)
{
    return fopen(path, mode);
}

static void DB_close(FILE * db)
{
    fclose(db);
}

static bstring DB_load()
{
    FILE *db = NULL;
    bstring data = NULL;

    db = DB_open(DB_FILE, &quot;r&quot;);
    check(db, &quot;Failed to open database: %s&quot;, DB_FILE);

    data = bread((bNread) fread, db);
    check(data, &quot;Failed to read from db file: %s&quot;, DB_FILE);

    DB_close(db);
    return data;

error:
    if (db)
        DB_close(db);
    if (data)
        bdestroy(data);
    return NULL;
}

int DB_update(const char *url)
{
    if (DB_find(url)) {
        log_info(&quot;Already recorded as installed: %s&quot;, url);
    }

    FILE *db = DB_open(DB_FILE, &quot;a+&quot;);
    check(db, &quot;Failed to open DB file: %s&quot;, DB_FILE);

    bstring line = bfromcstr(url);
    bconchar(line, '\n');
    int rc = fwrite(line-&gt;data, blength(line), 1, db);
    check(rc == 1, &quot;Failed to append to the db.&quot;);

    return 0;
error:
    if (db)
        DB_close(db);
    return -1;
}

int DB_find(const char *url)
{
    bstring data = NULL;
    bstring line = bfromcstr(url);
    int res = -1;

    data = DB_load();
    check(data, &quot;Failed to load: %s&quot;, DB_FILE);

    if (binstr(data, 0, line) == BSTR_ERR) {
        res = 0;
    } else {
        res = 1;
    }

error:          // fallthrough
    if (data)
        bdestroy(data);
    if (line)
        bdestroy(line);

    return res;
}

int DB_init()
{
    apr_pool_t *p = NULL;
    apr_pool_initialize();
    apr_pool_create(&amp;p, NULL);

    if (access(DB_DIR, W_OK | X_OK) == -1) {
        apr_status_t rc = apr_dir_make_recursive(DB_DIR,
                APR_UREAD | APR_UWRITE
                | APR_UEXECUTE |
                APR_GREAD | APR_GWRITE
                | APR_GEXECUTE, p);
        check(rc == APR_SUCCESS, &quot;Failed to make database dir: %s&quot;,
                DB_DIR);
    }

    if (access(DB_FILE, W_OK) == -1) {
        FILE *db = DB_open(DB_FILE, &quot;w&quot;);
        check(db, &quot;Cannot open database: %s&quot;, DB_FILE);
        DB_close(db);
    }

    apr_pool_destroy(p);
    return 0;

error:
    apr_pool_destroy(p);
    return -1;
}

int DB_list()
{
    bstring data = DB_load();
    check(data, &quot;Failed to read load: %s&quot;, DB_FILE);

    printf(&quot;%s&quot;, bdata(data));
    bdestroy(data);
    return 0;

error:
    return -1;
}

</code></pre>

<p>.\ex41\devpkg\db.h</p>

<pre><code class="language-c">#ifndef _db_h
#define _db_h

#define DB_FILE &quot;/usr/local/.devpkg/db&quot;
#define DB_DIR &quot;/usr/local/.devpkg&quot;

int DB_init();
int DB_list();
int DB_update(const char *url);
int DB_find(const char *url);

#endif

</code></pre>

<p>.\ex41\devpkg\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex41\devpkg\devpkg.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;apr_general.h&gt;
#include &lt;apr_getopt.h&gt;
#include &lt;apr_strings.h&gt;
#include &lt;apr_lib.h&gt;

#include &quot;dbg.h&quot;
#include &quot;db.h&quot;
#include &quot;commands.h&quot;

int main(int argc, const char *argv[])
{
    apr_pool_t *p = NULL;
    apr_pool_initialize();
    apr_pool_create(&amp;p, NULL);

    apr_getopt_t *opt;
    apr_status_t rv;

    char ch = '\0';
    const char *optarg = NULL;
    const char *config_opts = NULL;
    const char *install_opts = NULL;
    const char *make_opts = NULL;
    const char *url = NULL;
    enum CommandType request = COMMAND_NONE;

    rv = apr_getopt_init(&amp;opt, p, argc, argv);

    while (apr_getopt(opt, &quot;I:Lc:m:i:d:SF:B:&quot;, &amp;ch, &amp;optarg) ==
            APR_SUCCESS) {
        switch (ch) {
            case 'I':
                request = COMMAND_INSTALL;
                url = optarg;
                break;

            case 'L':
                request = COMMAND_LIST;
                break;

            case 'c':
                config_opts = optarg;
                break;

            case 'm':
                make_opts = optarg;
                break;

            case 'i':
                install_opts = optarg;
                break;

            case 'S':
                request = COMMAND_INIT;
                break;

            case 'F':
                request = COMMAND_FETCH;
                url = optarg;
                break;

            case 'B':
                request = COMMAND_BUILD;
                url = optarg;
                break;
        }
    }

    switch (request) {
        case COMMAND_INSTALL:
            check(url, &quot;You must at least give a URL.&quot;);
            Command_install(p, url, config_opts, make_opts, install_opts);
            break;

        case COMMAND_LIST:
            DB_list();
            break;

        case COMMAND_FETCH:
            check(url != NULL, &quot;You must give a URL.&quot;);
            Command_fetch(p, url, 1);
            log_info(&quot;Downloaded to %s and in /tmp/&quot;, BUILD_DIR);
            break;

        case COMMAND_BUILD:
            check(url, &quot;You must at least give a URL.&quot;);
            Command_build(p, url, config_opts, make_opts, install_opts);
            break;

        case COMMAND_INIT:
            rv = DB_init();
            check(rv == 0, &quot;Failed to make the database.&quot;);
            break;

        default:
            sentinel(&quot;Invalid command given.&quot;);
    }

    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex41\devpkg\shell.c</p>

<pre><code class="language-c">#include &quot;shell.h&quot;
#include &quot;dbg.h&quot;
#include &lt;stdarg.h&gt;

int Shell_exec(Shell template, ...)
{
    apr_pool_t *p = NULL;
    int rc = -1;
    apr_status_t rv = APR_SUCCESS;
    va_list argp;
    const char *key = NULL;
    const char *arg = NULL;
    int i = 0;

    rv = apr_pool_create(&amp;p, NULL);
    check(rv == APR_SUCCESS, &quot;Failed to create pool.&quot;);

    va_start(argp, template);

    for (key = va_arg(argp, const char *);
            key != NULL; key = va_arg(argp, const char *)) {
        arg = va_arg(argp, const char *);

        for (i = 0; template.args[i] != NULL; i++) {
            if (strcmp(template.args[i], key) == 0) {
                template.args[i] = arg;
                break;      // found it
            }
        }
    }

    rc = Shell_run(p, &amp;template);
    apr_pool_destroy(p);
    va_end(argp);
    return rc;

error:
    if (p) {
        apr_pool_destroy(p);
    }
    return rc;
}

int Shell_run(apr_pool_t * p, Shell * cmd)
{
    apr_procattr_t *attr;
    apr_status_t rv;
    apr_proc_t newproc;

    rv = apr_procattr_create(&amp;attr, p);
    check(rv == APR_SUCCESS, &quot;Failed to create proc attr.&quot;);

    rv = apr_procattr_io_set(attr, APR_NO_PIPE, APR_NO_PIPE,
            APR_NO_PIPE);
    check(rv == APR_SUCCESS, &quot;Failed to set IO of command.&quot;);

    rv = apr_procattr_dir_set(attr, cmd-&gt;dir);
    check(rv == APR_SUCCESS, &quot;Failed to set root to %s&quot;, cmd-&gt;dir);

    rv = apr_procattr_cmdtype_set(attr, APR_PROGRAM_PATH);
    check(rv == APR_SUCCESS, &quot;Failed to set cmd type.&quot;);

    rv = apr_proc_create(&amp;newproc, cmd-&gt;exe, cmd-&gt;args, NULL, attr, p);
    check(rv == APR_SUCCESS, &quot;Failed to run command.&quot;);

    rv = apr_proc_wait(&amp;newproc, &amp;cmd-&gt;exit_code, &amp;cmd-&gt;exit_why,
            APR_WAIT);
    check(rv == APR_CHILD_DONE, &quot;Failed to wait.&quot;);

    check(cmd-&gt;exit_code == 0, &quot;%s exited badly.&quot;, cmd-&gt;exe);
    check(cmd-&gt;exit_why == APR_PROC_EXIT, &quot;%s was killed or crashed&quot;,
            cmd-&gt;exe);

    return 0;

error:
    return -1;
}

Shell CLEANUP_SH = {
    .exe = &quot;rm&quot;,
    .dir = &quot;/tmp&quot;,
    .args = {&quot;rm&quot;, &quot;-rf&quot;, &quot;/tmp/pkg-build&quot;, &quot;/tmp/pkg-src.tar.gz&quot;,
        &quot;/tmp/pkg-src.tar.bz2&quot;, &quot;/tmp/DEPENDS&quot;, NULL}
};

Shell GIT_SH = {
    .dir = &quot;/tmp&quot;,
    .exe = &quot;git&quot;,
    .args = {&quot;git&quot;, &quot;clone&quot;, &quot;URL&quot;, &quot;pkg-build&quot;, NULL}
};

Shell TAR_SH = {
    .dir = &quot;/tmp/pkg-build&quot;,
    .exe = &quot;tar&quot;,
    .args = {&quot;tar&quot;, &quot;-xzf&quot;, &quot;FILE&quot;, &quot;--strip-components&quot;, &quot;1&quot;, NULL}
};

Shell CURL_SH = {
    .dir = &quot;/tmp&quot;,
    .exe = &quot;curl&quot;,
    .args = {&quot;curl&quot;, &quot;-L&quot;, &quot;-o&quot;, &quot;TARGET&quot;, &quot;URL&quot;, NULL}
};

Shell CONFIGURE_SH = {
    .exe = &quot;./configure&quot;,
    .dir = &quot;/tmp/pkg-build&quot;,
    .args = {&quot;configure&quot;, &quot;OPTS&quot;, NULL}
    ,
};

Shell MAKE_SH = {
    .exe = &quot;make&quot;,
    .dir = &quot;/tmp/pkg-build&quot;,
    .args = {&quot;make&quot;, &quot;OPTS&quot;, NULL}
};

Shell INSTALL_SH = {
    .exe = &quot;sudo&quot;,
    .dir = &quot;/tmp/pkg-build&quot;,
    .args = {&quot;sudo&quot;, &quot;make&quot;, &quot;TARGET&quot;, NULL}
};

</code></pre>

<p>.\ex41\devpkg\shell.h</p>

<pre><code class="language-c">#ifndef _shell_h
#define _shell_h

#define MAX_COMMAND_ARGS 100

#include &lt;apr_thread_proc.h&gt;

typedef struct Shell {
    const char *dir;
    const char *exe;

    apr_procattr_t *attr;
    apr_proc_t proc;
    apr_exit_why_e exit_why;
    int exit_code;

    const char *args[MAX_COMMAND_ARGS];
} Shell;

int Shell_run(apr_pool_t * p, Shell * cmd);
int Shell_exec(Shell cmd, ...);

extern Shell CLEANUP_SH;
extern Shell GIT_SH;
extern Shell TAR_SH;
extern Shell CURL_SH;
extern Shell CONFIGURE_SH;
extern Shell MAKE_SH;
extern Shell INSTALL_SH;

#endif

</code></pre>

<p>.\ex41\ex41.1.sh</p>

<pre><code class="language-bash">set -e

# go somewhere safe
cd /tmp

# get the source to base APR 1.5.2
curl -L -O http://archive.apache.org/dist/apr/apr-1.5.2.tar.gz

# extract it and go into the source
tar -xzvf apr-1.5.2.tar.gz
cd apr-1.5.2

# you need this on OSX Yosemite
touch libtoolT

# configure, make, make install
./configure
make
sudo make install

# reset and cleanup
cd /tmp
rm -rf apr-1.5.2 apr-1.5.2.tar.gz

# do the same with apr-util
curl -L -O http://archive.apache.org/dist/apr/apr-util-1.5.4.tar.gz

# extract
tar -xzvf apr-util-1.5.4.tar.gz
cd apr-util-1.5.4

# you need this on OSX Yosemite
touch libtoolT

# configure, make, make install
./configure --with-apr=/usr/local/apr
# you need that extra parameter to configure because
# apr-util can't really find it because...who knows.

make
sudo make install

#cleanup
cd /tmp
rm -rf apr-util-1.5.4* apr-1.5.2*


</code></pre>

<p>.\ex41\ex41.2.sh</p>

<pre><code class="language-bash">mkdir devpkg
cd devpkg
touch README Makefile

</code></pre>

<p>.\ex41\devpkg</p>

<p>.\ex41\devpkg\commands.c</p>

<pre><code class="language-c">#include &lt;apr_uri.h&gt;
#include &lt;apr_fnmatch.h&gt;
#include &lt;unistd.h&gt;

#include &quot;commands.h&quot;
#include &quot;dbg.h&quot;
#include &quot;bstrlib.h&quot;
#include &quot;db.h&quot;
#include &quot;shell.h&quot;

int Command_depends(apr_pool_t * p, const char *path)
{
    FILE *in = NULL;
    bstring line = NULL;

    in = fopen(path, &quot;r&quot;);
    check(in != NULL, &quot;Failed to open downloaded depends: %s&quot;, path);

    for (line = bgets((bNgetc) fgetc, in, '\n');
            line != NULL; 
            line = bgets((bNgetc) fgetc, in, '\n')) 
    {
        btrimws(line);
        log_info(&quot;Processing depends: %s&quot;, bdata(line));
        int rc = Command_install(p, bdata(line), NULL, NULL, NULL);
        check(rc == 0, &quot;Failed to install: %s&quot;, bdata(line));
        bdestroy(line);
    }

    fclose(in);
    return 0;

error:
    if (line) bdestroy(line);
    if (in) fclose(in);
    return -1;
}

int Command_fetch(apr_pool_t * p, const char *url, int fetch_only)
{
    apr_uri_t info = {.port = 0 };
    int rc = 0;
    const char *depends_file = NULL;
    apr_status_t rv = apr_uri_parse(p, url, &amp;info);

    check(rv == APR_SUCCESS, &quot;Failed to parse URL: %s&quot;, url);

    if (apr_fnmatch(GIT_PAT, info.path, 0) == APR_SUCCESS) {
        rc = Shell_exec(GIT_SH, &quot;URL&quot;, url, NULL);
        check(rc == 0, &quot;git failed.&quot;);
    } else if (apr_fnmatch(DEPEND_PAT, info.path, 0) == APR_SUCCESS) {
        check(!fetch_only, &quot;No point in fetching a DEPENDS file.&quot;);

        if (info.scheme) {
            depends_file = DEPENDS_PATH;
            rc = Shell_exec(CURL_SH, &quot;URL&quot;, url, &quot;TARGET&quot;, depends_file,
                    NULL);
            check(rc == 0, &quot;Curl failed.&quot;);
        } else {
            depends_file = info.path;
        }

        // recursively process the devpkg list
        log_info(&quot;Building according to DEPENDS: %s&quot;, url);
        rv = Command_depends(p, depends_file);
        check(rv == 0, &quot;Failed to process the DEPENDS: %s&quot;, url);

        // this indicates that nothing needs to be done
        return 0;

    } else if (apr_fnmatch(TAR_GZ_PAT, info.path, 0) == APR_SUCCESS) {
        if (info.scheme) {
            rc = Shell_exec(CURL_SH,
                    &quot;URL&quot;, url, &quot;TARGET&quot;, TAR_GZ_SRC, NULL);
            check(rc == 0, &quot;Failed to curl source: %s&quot;, url);
        }

        rv = apr_dir_make_recursive(BUILD_DIR,
                APR_UREAD | APR_UWRITE |
                APR_UEXECUTE, p);
        check(rv == APR_SUCCESS, &quot;Failed to make directory %s&quot;,
                BUILD_DIR);

        rc = Shell_exec(TAR_SH, &quot;FILE&quot;, TAR_GZ_SRC, NULL);
        check(rc == 0, &quot;Failed to untar %s&quot;, TAR_GZ_SRC);
    } else if (apr_fnmatch(TAR_BZ2_PAT, info.path, 0) == APR_SUCCESS) {
        if (info.scheme) {
            rc = Shell_exec(CURL_SH, &quot;URL&quot;, url, &quot;TARGET&quot;, TAR_BZ2_SRC,
                    NULL);
            check(rc == 0, &quot;Curl failed.&quot;);
        }

        apr_status_t rc = apr_dir_make_recursive(BUILD_DIR,
                APR_UREAD | APR_UWRITE
                | APR_UEXECUTE, p);

        check(rc == 0, &quot;Failed to make directory %s&quot;, BUILD_DIR);
        rc = Shell_exec(TAR_SH, &quot;FILE&quot;, TAR_BZ2_SRC, NULL);
        check(rc == 0, &quot;Failed to untar %s&quot;, TAR_BZ2_SRC);
    } else {
        sentinel(&quot;Don't now how to handle %s&quot;, url);
    }

    // indicates that an install needs to actually run
    return 1;
error:
    return -1;
}

int Command_build(apr_pool_t * p, const char *url,
        const char *configure_opts, const char *make_opts,
        const char *install_opts)
{
    int rc = 0;

    check(access(BUILD_DIR, X_OK | R_OK | W_OK) == 0,
            &quot;Build directory doesn't exist: %s&quot;, BUILD_DIR);

    // actually do an install
    if (access(CONFIG_SCRIPT, X_OK) == 0) {
        log_info(&quot;Has a configure script, running it.&quot;);
        rc = Shell_exec(CONFIGURE_SH, &quot;OPTS&quot;, configure_opts, NULL);
        check(rc == 0, &quot;Failed to configure.&quot;);
    }

    rc = Shell_exec(MAKE_SH, &quot;OPTS&quot;, make_opts, NULL);
    check(rc == 0, &quot;Failed to build.&quot;);

    rc = Shell_exec(INSTALL_SH,
            &quot;TARGET&quot;, install_opts ? install_opts : &quot;install&quot;,
            NULL);
    check(rc == 0, &quot;Failed to install.&quot;);

    rc = Shell_exec(CLEANUP_SH, NULL);
    check(rc == 0, &quot;Failed to cleanup after build.&quot;);

    rc = DB_update(url);
    check(rc == 0, &quot;Failed to add this package to the database.&quot;);

    return 0;

error:
    return -1;
}

int Command_install(apr_pool_t * p, const char *url,
        const char *configure_opts, const char *make_opts,
        const char *install_opts)
{
    int rc = 0;
    check(Shell_exec(CLEANUP_SH, NULL) == 0,
            &quot;Failed to cleanup before building.&quot;);

    rc = DB_find(url);
    check(rc != -1, &quot;Error checking the install database.&quot;);

    if (rc == 1) {
        log_info(&quot;Package %s already installed.&quot;, url);
        return 0;
    }

    rc = Command_fetch(p, url, 0);

    if (rc == 1) {
        rc = Command_build(p, url, configure_opts, make_opts,
                install_opts);
        check(rc == 0, &quot;Failed to build: %s&quot;, url);
    } else if (rc == 0) {
        // no install needed
        log_info(&quot;Depends successfully installed: %s&quot;, url);
    } else {
        // had an error
        sentinel(&quot;Install failed: %s&quot;, url);
    }

    Shell_exec(CLEANUP_SH, NULL);
    return 0;

error:
    Shell_exec(CLEANUP_SH, NULL);
    return -1;
}

</code></pre>

<p>.\ex41\devpkg\commands.h</p>

<pre><code class="language-c">#ifndef _commands_h
#define _commands_h

#include &lt;apr_pools.h&gt;

#define DEPENDS_PATH &quot;/tmp/DEPENDS&quot;
#define TAR_GZ_SRC &quot;/tmp/pkg-src.tar.gz&quot;
#define TAR_BZ2_SRC &quot;/tmp/pkg-src.tar.bz2&quot;
#define BUILD_DIR &quot;/tmp/pkg-build&quot;
#define GIT_PAT &quot;*.git&quot;
#define DEPEND_PAT &quot;*DEPENDS&quot;
#define TAR_GZ_PAT &quot;*.tar.gz&quot;
#define TAR_BZ2_PAT &quot;*.tar.bz2&quot;
#define CONFIG_SCRIPT &quot;/tmp/pkg-build/configure&quot;

enum CommandType {
    COMMAND_NONE, COMMAND_INSTALL, COMMAND_LIST, COMMAND_FETCH,
    COMMAND_INIT, COMMAND_BUILD
};

int Command_fetch(apr_pool_t * p, const char *url, int fetch_only);

int Command_install(apr_pool_t * p, const char *url,
        const char *configure_opts, const char *make_opts,
        const char *install_opts);

int Command_depends(apr_pool_t * p, const char *path);

int Command_build(apr_pool_t * p, const char *url,
        const char *configure_opts, const char *make_opts,
        const char *install_opts);

#endif

</code></pre>

<p>.\ex41\devpkg\db.c</p>

<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;apr_errno.h&gt;
#include &lt;apr_file_io.h&gt;

#include &quot;db.h&quot;
#include &quot;bstrlib.h&quot;
#include &quot;dbg.h&quot;

static FILE *DB_open(const char *path, const char *mode)
{
    return fopen(path, mode);
}

static void DB_close(FILE * db)
{
    fclose(db);
}

static bstring DB_load()
{
    FILE *db = NULL;
    bstring data = NULL;

    db = DB_open(DB_FILE, &quot;r&quot;);
    check(db, &quot;Failed to open database: %s&quot;, DB_FILE);

    data = bread((bNread) fread, db);
    check(data, &quot;Failed to read from db file: %s&quot;, DB_FILE);

    DB_close(db);
    return data;

error:
    if (db)
        DB_close(db);
    if (data)
        bdestroy(data);
    return NULL;
}

int DB_update(const char *url)
{
    if (DB_find(url)) {
        log_info(&quot;Already recorded as installed: %s&quot;, url);
    }

    FILE *db = DB_open(DB_FILE, &quot;a+&quot;);
    check(db, &quot;Failed to open DB file: %s&quot;, DB_FILE);

    bstring line = bfromcstr(url);
    bconchar(line, '\n');
    int rc = fwrite(line-&gt;data, blength(line), 1, db);
    check(rc == 1, &quot;Failed to append to the db.&quot;);

    return 0;
error:
    if (db)
        DB_close(db);
    return -1;
}

int DB_find(const char *url)
{
    bstring data = NULL;
    bstring line = bfromcstr(url);
    int res = -1;

    data = DB_load();
    check(data, &quot;Failed to load: %s&quot;, DB_FILE);

    if (binstr(data, 0, line) == BSTR_ERR) {
        res = 0;
    } else {
        res = 1;
    }

error:          // fallthrough
    if (data)
        bdestroy(data);
    if (line)
        bdestroy(line);

    return res;
}

int DB_init()
{
    apr_pool_t *p = NULL;
    apr_pool_initialize();
    apr_pool_create(&amp;p, NULL);

    if (access(DB_DIR, W_OK | X_OK) == -1) {
        apr_status_t rc = apr_dir_make_recursive(DB_DIR,
                APR_UREAD | APR_UWRITE
                | APR_UEXECUTE |
                APR_GREAD | APR_GWRITE
                | APR_GEXECUTE, p);
        check(rc == APR_SUCCESS, &quot;Failed to make database dir: %s&quot;,
                DB_DIR);
    }

    if (access(DB_FILE, W_OK) == -1) {
        FILE *db = DB_open(DB_FILE, &quot;w&quot;);
        check(db, &quot;Cannot open database: %s&quot;, DB_FILE);
        DB_close(db);
    }

    apr_pool_destroy(p);
    return 0;

error:
    apr_pool_destroy(p);
    return -1;
}

int DB_list()
{
    bstring data = DB_load();
    check(data, &quot;Failed to read load: %s&quot;, DB_FILE);

    printf(&quot;%s&quot;, bdata(data));
    bdestroy(data);
    return 0;

error:
    return -1;
}

</code></pre>

<p>.\ex41\devpkg\db.h</p>

<pre><code class="language-c">#ifndef _db_h
#define _db_h

#define DB_FILE &quot;/usr/local/.devpkg/db&quot;
#define DB_DIR &quot;/usr/local/.devpkg&quot;

int DB_init();
int DB_list();
int DB_update(const char *url);
int DB_find(const char *url);

#endif

</code></pre>

<p>.\ex41\devpkg\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex41\devpkg\devpkg.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;apr_general.h&gt;
#include &lt;apr_getopt.h&gt;
#include &lt;apr_strings.h&gt;
#include &lt;apr_lib.h&gt;

#include &quot;dbg.h&quot;
#include &quot;db.h&quot;
#include &quot;commands.h&quot;

int main(int argc, const char *argv[])
{
    apr_pool_t *p = NULL;
    apr_pool_initialize();
    apr_pool_create(&amp;p, NULL);

    apr_getopt_t *opt;
    apr_status_t rv;

    char ch = '\0';
    const char *optarg = NULL;
    const char *config_opts = NULL;
    const char *install_opts = NULL;
    const char *make_opts = NULL;
    const char *url = NULL;
    enum CommandType request = COMMAND_NONE;

    rv = apr_getopt_init(&amp;opt, p, argc, argv);

    while (apr_getopt(opt, &quot;I:Lc:m:i:d:SF:B:&quot;, &amp;ch, &amp;optarg) ==
            APR_SUCCESS) {
        switch (ch) {
            case 'I':
                request = COMMAND_INSTALL;
                url = optarg;
                break;

            case 'L':
                request = COMMAND_LIST;
                break;

            case 'c':
                config_opts = optarg;
                break;

            case 'm':
                make_opts = optarg;
                break;

            case 'i':
                install_opts = optarg;
                break;

            case 'S':
                request = COMMAND_INIT;
                break;

            case 'F':
                request = COMMAND_FETCH;
                url = optarg;
                break;

            case 'B':
                request = COMMAND_BUILD;
                url = optarg;
                break;
        }
    }

    switch (request) {
        case COMMAND_INSTALL:
            check(url, &quot;You must at least give a URL.&quot;);
            Command_install(p, url, config_opts, make_opts, install_opts);
            break;

        case COMMAND_LIST:
            DB_list();
            break;

        case COMMAND_FETCH:
            check(url != NULL, &quot;You must give a URL.&quot;);
            Command_fetch(p, url, 1);
            log_info(&quot;Downloaded to %s and in /tmp/&quot;, BUILD_DIR);
            break;

        case COMMAND_BUILD:
            check(url, &quot;You must at least give a URL.&quot;);
            Command_build(p, url, config_opts, make_opts, install_opts);
            break;

        case COMMAND_INIT:
            rv = DB_init();
            check(rv == 0, &quot;Failed to make the database.&quot;);
            break;

        default:
            sentinel(&quot;Invalid command given.&quot;);
    }

    return 0;

error:
    return 1;
}

</code></pre>

<p>.\ex41\devpkg\shell.c</p>

<pre><code class="language-c">#include &quot;shell.h&quot;
#include &quot;dbg.h&quot;
#include &lt;stdarg.h&gt;

int Shell_exec(Shell template, ...)
{
    apr_pool_t *p = NULL;
    int rc = -1;
    apr_status_t rv = APR_SUCCESS;
    va_list argp;
    const char *key = NULL;
    const char *arg = NULL;
    int i = 0;

    rv = apr_pool_create(&amp;p, NULL);
    check(rv == APR_SUCCESS, &quot;Failed to create pool.&quot;);

    va_start(argp, template);

    for (key = va_arg(argp, const char *);
            key != NULL; key = va_arg(argp, const char *)) {
        arg = va_arg(argp, const char *);

        for (i = 0; template.args[i] != NULL; i++) {
            if (strcmp(template.args[i], key) == 0) {
                template.args[i] = arg;
                break;      // found it
            }
        }
    }

    rc = Shell_run(p, &amp;template);
    apr_pool_destroy(p);
    va_end(argp);
    return rc;

error:
    if (p) {
        apr_pool_destroy(p);
    }
    return rc;
}

int Shell_run(apr_pool_t * p, Shell * cmd)
{
    apr_procattr_t *attr;
    apr_status_t rv;
    apr_proc_t newproc;

    rv = apr_procattr_create(&amp;attr, p);
    check(rv == APR_SUCCESS, &quot;Failed to create proc attr.&quot;);

    rv = apr_procattr_io_set(attr, APR_NO_PIPE, APR_NO_PIPE,
            APR_NO_PIPE);
    check(rv == APR_SUCCESS, &quot;Failed to set IO of command.&quot;);

    rv = apr_procattr_dir_set(attr, cmd-&gt;dir);
    check(rv == APR_SUCCESS, &quot;Failed to set root to %s&quot;, cmd-&gt;dir);

    rv = apr_procattr_cmdtype_set(attr, APR_PROGRAM_PATH);
    check(rv == APR_SUCCESS, &quot;Failed to set cmd type.&quot;);

    rv = apr_proc_create(&amp;newproc, cmd-&gt;exe, cmd-&gt;args, NULL, attr, p);
    check(rv == APR_SUCCESS, &quot;Failed to run command.&quot;);

    rv = apr_proc_wait(&amp;newproc, &amp;cmd-&gt;exit_code, &amp;cmd-&gt;exit_why,
            APR_WAIT);
    check(rv == APR_CHILD_DONE, &quot;Failed to wait.&quot;);

    check(cmd-&gt;exit_code == 0, &quot;%s exited badly.&quot;, cmd-&gt;exe);
    check(cmd-&gt;exit_why == APR_PROC_EXIT, &quot;%s was killed or crashed&quot;,
            cmd-&gt;exe);

    return 0;

error:
    return -1;
}

Shell CLEANUP_SH = {
    .exe = &quot;rm&quot;,
    .dir = &quot;/tmp&quot;,
    .args = {&quot;rm&quot;, &quot;-rf&quot;, &quot;/tmp/pkg-build&quot;, &quot;/tmp/pkg-src.tar.gz&quot;,
        &quot;/tmp/pkg-src.tar.bz2&quot;, &quot;/tmp/DEPENDS&quot;, NULL}
};

Shell GIT_SH = {
    .dir = &quot;/tmp&quot;,
    .exe = &quot;git&quot;,
    .args = {&quot;git&quot;, &quot;clone&quot;, &quot;URL&quot;, &quot;pkg-build&quot;, NULL}
};

Shell TAR_SH = {
    .dir = &quot;/tmp/pkg-build&quot;,
    .exe = &quot;tar&quot;,
    .args = {&quot;tar&quot;, &quot;-xzf&quot;, &quot;FILE&quot;, &quot;--strip-components&quot;, &quot;1&quot;, NULL}
};

Shell CURL_SH = {
    .dir = &quot;/tmp&quot;,
    .exe = &quot;curl&quot;,
    .args = {&quot;curl&quot;, &quot;-L&quot;, &quot;-o&quot;, &quot;TARGET&quot;, &quot;URL&quot;, NULL}
};

Shell CONFIGURE_SH = {
    .exe = &quot;./configure&quot;,
    .dir = &quot;/tmp/pkg-build&quot;,
    .args = {&quot;configure&quot;, &quot;OPTS&quot;, NULL}
    ,
};

Shell MAKE_SH = {
    .exe = &quot;make&quot;,
    .dir = &quot;/tmp/pkg-build&quot;,
    .args = {&quot;make&quot;, &quot;OPTS&quot;, NULL}
};

Shell INSTALL_SH = {
    .exe = &quot;sudo&quot;,
    .dir = &quot;/tmp/pkg-build&quot;,
    .args = {&quot;sudo&quot;, &quot;make&quot;, &quot;TARGET&quot;, NULL}
};

</code></pre>

<p>.\ex41\devpkg\shell.h</p>

<pre><code class="language-c">#ifndef _shell_h
#define _shell_h

#define MAX_COMMAND_ARGS 100

#include &lt;apr_thread_proc.h&gt;

typedef struct Shell {
    const char *dir;
    const char *exe;

    apr_procattr_t *attr;
    apr_proc_t proc;
    apr_exit_why_e exit_why;
    int exit_code;

    const char *args[MAX_COMMAND_ARGS];
} Shell;

int Shell_run(apr_pool_t * p, Shell * cmd);
int Shell_exec(Shell cmd, ...);

extern Shell CLEANUP_SH;
extern Shell GIT_SH;
extern Shell TAR_SH;
extern Shell CURL_SH;
extern Shell CONFIGURE_SH;
extern Shell MAKE_SH;
extern Shell INSTALL_SH;

#endif

</code></pre>

<p>.\ex41\ex41.1.sh</p>

<pre><code class="language-bash">set -e

# go somewhere safe
cd /tmp

# get the source to base APR 1.5.2
curl -L -O http://archive.apache.org/dist/apr/apr-1.5.2.tar.gz

# extract it and go into the source
tar -xzvf apr-1.5.2.tar.gz
cd apr-1.5.2

# you need this on OSX Yosemite
touch libtoolT

# configure, make, make install
./configure
make
sudo make install

# reset and cleanup
cd /tmp
rm -rf apr-1.5.2 apr-1.5.2.tar.gz

# do the same with apr-util
curl -L -O http://archive.apache.org/dist/apr/apr-util-1.5.4.tar.gz

# extract
tar -xzvf apr-util-1.5.4.tar.gz
cd apr-util-1.5.4

# you need this on OSX Yosemite
touch libtoolT

# configure, make, make install
./configure --with-apr=/usr/local/apr
# you need that extra parameter to configure because
# apr-util can't really find it because...who knows.

make
sudo make install

#cleanup
cd /tmp
rm -rf apr-util-1.5.4* apr-1.5.2*


</code></pre>

<p>.\ex41\ex41.2.sh</p>

<pre><code class="language-bash">mkdir devpkg
cd devpkg
touch README Makefile

</code></pre>

<p>The Plan</p>

<p>Create a handy little tool called devpkg.</p>

<p>This will be a <em>lot</em> of work, so this video is more complete.</p>

<p>Demonstration</p>

<p>I&rsquo;ll demonstrate how devpkg works so you get a better idea.</p>

<p>Read the book&rsquo;s description as well for more details.</p>

<p>The Apache Portable Runtime</p>

<p>Review of the APR and installing it.</p>

<p>The Analysis</p>

<p>Walk through the code, where everything is, and what to watch out for.</p>

<p>Getting My Code</p>

<p>If you get stuck you can check out the learn-c-the-hard-way-lectures project:</p>

<p>And look in ex41/devpkg for the code.</p>

<p>Extra Credit</p>

<ul>
<li>Compare your code to my code available online.  Starting with 100%,
remove 1% for each line you got wrong.</li>
<li>Take the notes.txt file that you previously created and implement your improvements to the the code and functionality
of <code>devpkg</code>.</li>
<li>Write an alternative version of <code>devpkg</code> using your other
favorite language or the one you think can do this the best.  Compare
the two, then improve your <em>C</em> version of <code>devpkg</code> based on what
you&rsquo;ve learned.</li>
</ul>

<h2 id="exercise-42-stacks-and-queues">Exercise 42 Stacks and Queues</h2>

<p>The Plan</p>

<p>Create a Stack and Queue data structure from just the unit tests.</p>

<p>PAUSE!</p>

<p>WARNING!  Stop the video now and try to solve this yourself!</p>

<p>I&rsquo;ll show you how I did it after you try it (or you can cheat).</p>

<p>Code Review</p>

<p>Extra Credit</p>

<ul>
<li>Implement <code>Stack</code> using <code>DArray</code> instead of <code>List</code>, but without changing the unit test.  That means you&rsquo;ll have to create your own <code>STACK_FOREACH</code>.</li>
</ul>

<h2 id="exercise-43-a-simple-statistics-engine">Exercise 43 A Simple Statistics Engine</h2>

<p>The Plan</p>

<ul>
<li>A fun and handy little statistics engine for simple analysis.</li>
<li>Comparing it to the same in R.</li>
</ul>

<p>Comparing Test vs. R</p>

<p>I&rsquo;ll use R to show you how this works vs. normal calculations using all data.</p>

<p>Breaking It</p>

<p>Easiest way to break this is to just feed it bad data once then the whole
stream is broken.</p>

<p>Extra Credit</p>

<ul>
<li>Convert the <code>Stats_stddev</code> and <code>Stats_mean</code> to <code>static inline</code> functions in the <code>stats.h</code> file instead of in the <code>stats.c</code> file.</li>
<li>Use this code to write a performance test of the <code>string_algos_test.c</code>.
Make it optional, and have it run the base test as a series of samples, and then report
the results.</li>
<li>Write a version of this in another programming language you know.  Confirm that this
version is correct based on what I have here.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Write a little program that can take a file full of numbers and spit these statistics
out for them.</li>
<li>Make the program accept a table of data that has headers on one line, then all
of the other numbers on lines after it are separated by any number of spaces.  Your program
should then print out these statistics for each column by the header name.</li>
</ul>

<h2 id="exercise-44-ring-buffer">Exercise 44 Ring Buffer</h2>

<p>The Plan</p>

<p>Learn about a handy data structure for I/O processing:</p>

<p>Ring Buffers</p>

<p>The Code</p>

<p>.\ex44\netclient.c</p>

<pre><code class="language-c">#undef NDEBUG
#include &lt;stdlib.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;stdio.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

struct tagbstring NL = bsStatic(&quot;\n&quot;);
struct tagbstring CRLF = bsStatic(&quot;\r\n&quot;);

int nonblock(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    check(flags &gt;= 0, &quot;Invalid flags on nonblock.&quot;);

    int rc = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    return 0;
error:
    return -1;
}

int client_connect(char *host, char *port)
{
    int rc = 0;
    struct addrinfo *addr = NULL;

    rc = getaddrinfo(host, port, NULL, &amp;addr);
    check(rc == 0, &quot;Failed to lookup %s:%s&quot;, host, port);

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    check(sock &gt;= 0, &quot;Cannot create a socket.&quot;);

    rc = connect(sock, addr-&gt;ai_addr, addr-&gt;ai_addrlen);
    check(rc == 0, &quot;Connect failed.&quot;);

    rc = nonblock(sock);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    freeaddrinfo(addr);
    return sock;

error:
    freeaddrinfo(addr);
    return -1;
}

int read_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;

    if (RingBuffer_available_data(buffer) == 0) {
        buffer-&gt;start = buffer-&gt;end = 0;
    }

    if (is_socket) {
        rc = recv(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer), 0);
    } else {
        rc = read(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer));
    }

    check(rc &gt;= 0, &quot;Failed to read from fd: %d&quot;, fd);

    RingBuffer_commit_write(buffer, rc);

    return rc;

error:
    return -1;
}

int write_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;
    bstring data = RingBuffer_get_all(buffer);

    check(data != NULL, &quot;Failed to get from the buffer.&quot;);
    check(bfindreplace(data, &amp;NL, &amp;CRLF, 0) == BSTR_OK,
            &quot;Failed to replace NL.&quot;);

    if (is_socket) {
        rc = send(fd, bdata(data), blength(data), 0);
    } else {
        rc = write(fd, bdata(data), blength(data));
    }

    check(rc == blength(data), &quot;Failed to write everything to fd: %d.&quot;,
            fd);
    bdestroy(data);

    return rc;

error:
    return -1;
}

int main(int argc, char *argv[])
{
    fd_set allreads;
    fd_set readmask;

    int socket = 0;
    int rc = 0;
    RingBuffer *in_rb = RingBuffer_create(1024 * 10);
    RingBuffer *sock_rb = RingBuffer_create(1024 * 10);

    check(argc == 3, &quot;USAGE: netclient host port&quot;);

    socket = client_connect(argv[1], argv[2]);
    check(socket &gt;= 0, &quot;connect to %s:%s failed.&quot;, argv[1], argv[2]);

    FD_ZERO(&amp;allreads);
    FD_SET(socket, &amp;allreads);
    FD_SET(0, &amp;allreads);

    while (1) {
        readmask = allreads;
        rc = select(socket + 1, &amp;readmask, NULL, NULL, NULL);
        check(rc &gt;= 0, &quot;select failed.&quot;);

        if (FD_ISSET(0, &amp;readmask)) {
            rc = read_some(in_rb, 0, 0);
            check_debug(rc != -1, &quot;Failed to read from stdin.&quot;);
        }

        if (FD_ISSET(socket, &amp;readmask)) {
            rc = read_some(sock_rb, socket, 0);
            check_debug(rc != -1, &quot;Failed to read from socket.&quot;);
        }

        while (!RingBuffer_empty(sock_rb)) {
            rc = write_some(sock_rb, 1, 0);
            check_debug(rc != -1, &quot;Failed to write to stdout.&quot;);
        }

        while (!RingBuffer_empty(in_rb)) {
            rc = write_some(in_rb, socket, 1);
            check_debug(rc != -1, &quot;Failed to write to socket.&quot;);
        }
    }

    return 0;

error:
    return -1;
}

</code></pre>

<p>It&rsquo;s basically a DArray with dynamic start and end settings.
You can <em>also</em> use a Queue of bstrings to do almost the same thing.</p>

<p>Code Review</p>

<p>.\ex44\netclient.c</p>

<pre><code class="language-c">#undef NDEBUG
#include &lt;stdlib.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;stdio.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

struct tagbstring NL = bsStatic(&quot;\n&quot;);
struct tagbstring CRLF = bsStatic(&quot;\r\n&quot;);

int nonblock(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    check(flags &gt;= 0, &quot;Invalid flags on nonblock.&quot;);

    int rc = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    return 0;
error:
    return -1;
}

int client_connect(char *host, char *port)
{
    int rc = 0;
    struct addrinfo *addr = NULL;

    rc = getaddrinfo(host, port, NULL, &amp;addr);
    check(rc == 0, &quot;Failed to lookup %s:%s&quot;, host, port);

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    check(sock &gt;= 0, &quot;Cannot create a socket.&quot;);

    rc = connect(sock, addr-&gt;ai_addr, addr-&gt;ai_addrlen);
    check(rc == 0, &quot;Connect failed.&quot;);

    rc = nonblock(sock);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    freeaddrinfo(addr);
    return sock;

error:
    freeaddrinfo(addr);
    return -1;
}

int read_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;

    if (RingBuffer_available_data(buffer) == 0) {
        buffer-&gt;start = buffer-&gt;end = 0;
    }

    if (is_socket) {
        rc = recv(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer), 0);
    } else {
        rc = read(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer));
    }

    check(rc &gt;= 0, &quot;Failed to read from fd: %d&quot;, fd);

    RingBuffer_commit_write(buffer, rc);

    return rc;

error:
    return -1;
}

int write_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;
    bstring data = RingBuffer_get_all(buffer);

    check(data != NULL, &quot;Failed to get from the buffer.&quot;);
    check(bfindreplace(data, &amp;NL, &amp;CRLF, 0) == BSTR_OK,
            &quot;Failed to replace NL.&quot;);

    if (is_socket) {
        rc = send(fd, bdata(data), blength(data), 0);
    } else {
        rc = write(fd, bdata(data), blength(data));
    }

    check(rc == blength(data), &quot;Failed to write everything to fd: %d.&quot;,
            fd);
    bdestroy(data);

    return rc;

error:
    return -1;
}

int main(int argc, char *argv[])
{
    fd_set allreads;
    fd_set readmask;

    int socket = 0;
    int rc = 0;
    RingBuffer *in_rb = RingBuffer_create(1024 * 10);
    RingBuffer *sock_rb = RingBuffer_create(1024 * 10);

    check(argc == 3, &quot;USAGE: netclient host port&quot;);

    socket = client_connect(argv[1], argv[2]);
    check(socket &gt;= 0, &quot;connect to %s:%s failed.&quot;, argv[1], argv[2]);

    FD_ZERO(&amp;allreads);
    FD_SET(socket, &amp;allreads);
    FD_SET(0, &amp;allreads);

    while (1) {
        readmask = allreads;
        rc = select(socket + 1, &amp;readmask, NULL, NULL, NULL);
        check(rc &gt;= 0, &quot;select failed.&quot;);

        if (FD_ISSET(0, &amp;readmask)) {
            rc = read_some(in_rb, 0, 0);
            check_debug(rc != -1, &quot;Failed to read from stdin.&quot;);
        }

        if (FD_ISSET(socket, &amp;readmask)) {
            rc = read_some(sock_rb, socket, 0);
            check_debug(rc != -1, &quot;Failed to read from socket.&quot;);
        }

        while (!RingBuffer_empty(sock_rb)) {
            rc = write_some(sock_rb, 1, 0);
            check_debug(rc != -1, &quot;Failed to write to stdout.&quot;);
        }

        while (!RingBuffer_empty(in_rb)) {
            rc = write_some(in_rb, socket, 1);
            check_debug(rc != -1, &quot;Failed to write to socket.&quot;);
        }
    }

    return 0;

error:
    return -1;
}

</code></pre>

<p>The Analysis</p>

<ul>
<li>Watch a ring buffer work in the debugger.</li>
<li>Draw it visually to explore it.</li>
<li>The purpose is to efficiently add and remove data when the amount added and removed is random.</li>
</ul>

<p>Pause!</p>

<p>I will next review the unit test I wrote so if you want to attempt
solving it yourself then pause now.</p>

<p>The Unit Test</p>

<p>Here&rsquo;s my version of the unit test.</p>

<p>Breaking It</p>

<ul>
<li>The biggest mistake you&rsquo;ll make with a ring buffer is off-by-one errors.</li>
<li>This is why the RingBuffer_commit_ and other macros exist.</li>
<li>Another common mistake is to use it between threads, but that&rsquo;s a whole other book.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Create an alternative implementation of <code>RingBuffer</code> that uses
the POSIX trick and a unit test for it.</li>
<li>Add a performance comparison test to this unit test that compares the
two versions by fuzzing them with random data and random read/write operations.
Make sure that you set up this fuzzing so that the same operations are done
to each version, and you can compare them between runs.</li>
</ul>

<h2 id="exercise-45-a-simple-tcp-ip-client">Exercise 45 A Simple TCP/IP Client</h2>

<p>The Plan</p>

<ul>
<li>Learn to use the <em>select</em> method and a RingBuffer to write a simple command line network client.</li>
</ul>

<p>How select Works</p>

<p>Code Review</p>

<p>Improving It</p>

<p>These read functions are useful so I can put them in RingBuffer.</p>

<p>Extra Credit</p>

<ul>
<li>As I mentioned, there are quite a few functions you may not know, so
look them up.  In fact, look them all up even if you think you know
them.</li>
<li>Go back through and add various defensive programming checks to
the functions to improve them.</li>
<li>Use the <em>getopt</em> function to allow the user
the option <em>not</em> to translate <em>\n</em> to <em>\r\n</em>. This
is only needed on protocols that require it for line endings, like HTTP.
Sometimes you don&rsquo;t want the translation, so give the user the option.</li>
</ul>

<h2 id="exercise-46-ternary-search-tree">Exercise 46 Ternary Search Tree</h2>

<p>The Plan</p>

<p>Learn about my favorite data structure ever:</p>

<p>Ternary Search Tree</p>

<p>The Code</p>

<p>Similar to a Binary Search Tree, but it has 3 branches per node based on
the characters in strings.</p>

<p>Advantages</p>

<ul>
<li>Find any string comparing at most N characters.</li>
<li>Detect <em>missing</em> strings as fast, usually faster.</li>
<li>Find all strings that start with, or contain, any substring as fast.</li>
<li>Find all similar known strings quickly.</li>
</ul>

<p>Disadvantages</p>

<ul>
<li>Delete is a pain, as in most trees.</li>
<li>Uses lots of memory to store keys, so bad for sets of large keys.</li>
<li>Kind of weird for most programmers.</li>
</ul>

<p>Improving It</p>

<ul>
<li>You could allow duplicates by using a <em>DArray</em> instead of the
<em>value</em>.</li>
<li>As I mentioned earlier, deleting is hard, but you could simulate it by setting
the values to <em>NULL</em> so that they are effectively gone.</li>
<li>There are no ways to collect all of the possible matching values.  I&rsquo;ll have
you implement that in an extra credit.</li>
<li>There are other algorithms that are more complex but have slightly
better properties.  Take a look at suffix array, suffix tree, and
radix tree structures.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Implement a <em>TSTree_collect</em> that returns a <em>DArray</em> containing
all of the keys that match the given prefix.</li>
<li>Implement <em>TSTree_search_suffix</em> and a <em>TSTree_insert_suffix</em>
so you can do suffix searches and inserts.</li>
<li>Use the debugger to see how this structure is used in memory
compared to the <em>BSTree</em> and <em>Hashmap</em>.</li>
</ul>

<h2 id="exercise-47-a-fast-url-router">Exercise 47 A Fast URL Router</h2>

<p>The Plan</p>

<p>Use the <em>TSTree</em> to do something useful:</p>

<p>Route URLs</p>

<p>.\ex47\ex47_urls.txt</p>

<pre><code>/test.tst TestHandler
/ IndexHandler
/test/this/out/index.html PageHandler
/index.html PageHandler
/and/then/i/have/things/to/test.html PageHandler

</code></pre>

<p>Code Review</p>

<p>.\ex47\urlor.c</p>

<pre><code class="language-c">#include &lt;lcthw/tstree.h&gt;
#include &lt;lcthw/bstrlib.h&gt;

TSTree *add_route_data(TSTree * routes, bstring line)
{
    struct bstrList *data = bsplit(line, ' ');
    check(data-&gt;qty == 2, &quot;Line '%s' does not have 2 columns&quot;,
            bdata(line));

    routes = TSTree_insert(routes,
            bdata(data-&gt;entry[0]),
            blength(data-&gt;entry[0]),
            bstrcpy(data-&gt;entry[1]));

    bstrListDestroy(data);

    return routes;

error:
    return NULL;
}

TSTree *load_routes(const char *file)
{
    TSTree *routes = NULL;
    bstring line = NULL;
    FILE *routes_map = NULL;

    routes_map = fopen(file, &quot;r&quot;);
    check(routes_map != NULL, &quot;Failed to open routes: %s&quot;, file);

    while ((line = bgets((bNgetc) fgetc, routes_map, '\n')) != NULL) {
        check(btrimws(line) == BSTR_OK, &quot;Failed to trim line.&quot;);
        routes = add_route_data(routes, line);
        check(routes != NULL, &quot;Failed to add route.&quot;);
        bdestroy(line);
    }

    fclose(routes_map);
    return routes;

error:
    if (routes_map) fclose(routes_map);
    if (line) bdestroy(line);

    return NULL;
}

bstring match_url(TSTree * routes, bstring url)
{
    bstring route = TSTree_search(routes, bdata(url), blength(url));

    if (route == NULL) {
        printf(&quot;No exact match found, trying prefix.\n&quot;);
        route = TSTree_search_prefix(routes, bdata(url), blength(url));
    }

    return route;
}

bstring read_line(const char *prompt)
{
    printf(&quot;%s&quot;, prompt);

    bstring result = bgets((bNgetc) fgetc, stdin, '\n');
    check_debug(result != NULL, &quot;stdin closed.&quot;);

    check(btrimws(result) == BSTR_OK, &quot;Failed to trim.&quot;);

    return result;

error:
    return NULL;
}

void bdestroy_cb(void *value, void *ignored)
{
    (void)ignored;
    bdestroy((bstring) value);
}

void destroy_routes(TSTree * routes)
{
    TSTree_traverse(routes, bdestroy_cb, NULL);
    TSTree_destroy(routes);
}

int main(int argc, char *argv[])
{
    bstring url = NULL;
    bstring route = NULL;
    TSTree *routes = NULL;

    check(argc == 2, &quot;USAGE: urlor &lt;urlfile&gt;&quot;);

    routes = load_routes(argv[1]);
    check(routes != NULL, &quot;Your route file has an error.&quot;);

    while (1) {
        url = read_line(&quot;URL&gt; &quot;);
        check_debug(url != NULL, &quot;goodbye.&quot;);

        route = match_url(routes, url);

        if (route) {
            printf(&quot;MATCH: %s == %s\n&quot;, bdata(url), bdata(route));
        } else {
            printf(&quot;FAIL: %s\n&quot;, bdata(url));
        }

        bdestroy(url);
    }

    destroy_routes(routes);
    return 0;

error:
    destroy_routes(routes);
    return 1;
}

</code></pre>

<p>The Analysis</p>

<p>Watch me play with it and then tell you how it&rsquo;s working.</p>

<p>Improving It</p>

<ul>
<li>Collect all possible matches then choose the longest as winner.</li>
<li>Use TSTree to find prefixes, then regex to choose winner.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Instead of just storing the string for the handler, create an actual engine that uses a
<em>Handler</em> struct to store the application.  The structure would store the URL to which it&rsquo;s attached, the name, and anything else you&rsquo;d need to make an actual routing system.</li>
</ul>

<p>Extra Credit</p>

<ul>
<li>Instead of mapping URLs to arbitrary names, map them to .so files and use the <em>dlopen</em>
system to load handlers on the fly and call callbacks they contain.  Put these callbacks that
in your <em>Handler</em> struct, and then you have yourself a fully dynamic callback
handler system in C.</li>
</ul>

<h2 id="exercise-48a-a-simple-network-server">Exercise 48a A Simple Network Server:</h2>

<p>Project Description</p>

<p>The Plan</p>

<p>Start your first long running project:</p>

<p>statserve</p>

<p>The Purpose</p>

<p>You&rsquo;ll get the project started and get a minimum first hack going.</p>

<p>The Requirements</p>

<ol>
<li>Create a simple network server that accepts a connection on port 7899 from
<em>netclient</em> or the <em>nc</em> command, and echoes back anything you type.</li>
<li>You&rsquo;ll need to learn how to bind a port, listen on the socket, and answer it.
Use your research skills to study how this is done and attempt to implement it
yourself.</li>
</ol>

<p>The Requirements</p>

<ol>
<li>The more important part of this project is laying out the project directory
from the <em>c-skeleton</em>, and making sure you can build everything and get it
working.</li>
<li>Don&rsquo;t worry about things like daemons or anything else.  Your server just has
to run from the command line and keep running.</li>
</ol>

<p>The Clues</p>

<p>I will now give you some clues:</p>

<ul>
<li>USE liblcthw!</li>
<li>Remember you did a client already, you just need to make a server.</li>
<li>Do NOT use select! Use fork() for the server.</li>
<li>Keep it <em>simple</em>.  Don&rsquo;t worry about anything other than accepting a connection and closing.</li>
<li>Stay small, build slowly.</li>
</ul>

<p>Important References</p>

<ul>
<li>Research online for &ldquo;echo server in C&rdquo;.</li>
<li>Read man (2) pages for <em>accept</em>, <em>bind</em>, <em>listen</em>, <em>connect</em>, <em>select</em>, <em>socket</em>, and <em>shutdown</em>.</li>
</ul>

<p>Encouragement</p>

<p>This will be <em>HARD</em>!  Try it your best, and take it piece by piece.  You can do it, but remember if you give up the next video (48b) will show you the code to my solution and how to solve it.  You can peek there then come back when you&rsquo;re stuck.</p>

<h2 id="exercise-48b-a-simple-network-server">Exercise 48b A Simple Network Server:</h2>

<p>.\ex48b\c-skeleton</p>

<p>.\ex48b\c-skeleton\src\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex48b\c-skeleton\src\libex29.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &quot;dbg.h&quot;


int print_a_message(const char *msg)
{
    printf(&quot;A STRING: %s\n&quot;, msg);

    return 0;
}


int uppercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, toupper(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int lowercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, tolower(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int fail_on_purpose(const char *msg)
{
    return 1;
} 

</code></pre>

<p>.\ex48b\c-skeleton\tests\libex29_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;dlfcn.h&gt;

typedef int (*lib_function) (const char *data);
char *lib_file = &quot;build/libYOUR_LIBRARY.so&quot;;
void *lib = NULL;

int check_function(const char *func_to_run, const char *data,
        int expected)
{
    lib_function func = dlsym(lib, func_to_run);
    check(func != NULL,
            &quot;Did not find %s function in the library %s: %s&quot;, func_to_run,
            lib_file, dlerror());

    int rc = func(data);
    check(rc == expected, &quot;Function %s return %d for data: %s&quot;,
            func_to_run, rc, data);

    return 1;
error:
    return 0;
}

char *test_dlopen()
{
    lib = dlopen(lib_file, RTLD_NOW);
    mu_assert(lib != NULL, &quot;Failed to open the library to test.&quot;);

    return NULL;
}

char *test_functions()
{
    mu_assert(check_function(&quot;print_a_message&quot;, &quot;Hello&quot;, 0),
            &quot;print_a_message failed.&quot;);
    mu_assert(check_function(&quot;uppercase&quot;, &quot;Hello&quot;, 0),
            &quot;uppercase failed.&quot;);
    mu_assert(check_function(&quot;lowercase&quot;, &quot;Hello&quot;, 0),
            &quot;lowercase failed.&quot;);

    return NULL;
}

char *test_failures()
{
    mu_assert(check_function(&quot;fail_on_purpose&quot;, &quot;Hello&quot;, 1),
            &quot;fail_on_purpose should fail.&quot;);

    return NULL;
}

char *test_dlclose()
{
    int rc = dlclose(lib);
    mu_assert(rc == 0, &quot;Failed to close lib.&quot;);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dlopen);
    mu_run_test(test_functions);
    mu_run_test(test_failures);
    mu_run_test(test_dlclose);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>.\ex48b\statserve</p>

<p>.\ex48b\statserve\bin\statserve.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &quot;statserve.h&quot;
#include &quot;net.h&quot;


int main(int argc, char *argv[])
{
    check(argc == 3, &quot;USAGE: statserve host port&quot;);

    const char *host = argv[1];
    const char *port = argv[2];

    check(echo_server(host, port), &quot;Failed to run the echo server.&quot;);

    return 0;

error:
    
    return 1;
}

</code></pre>

<p>.\ex48b\statserve\src\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex48b\statserve\src\net.c</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;stdio.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &quot;net.h&quot;

struct tagbstring NL = bsStatic(&quot;\n&quot;);
struct tagbstring CRLF = bsStatic(&quot;\r\n&quot;);

int nonblock(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    check(flags &gt;= 0, &quot;Invalid flags on nonblock.&quot;);

    int rc = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    return 0;
error:
    return -1;
}

int client_connect(char *host, char *port)
{
    int rc = 0;
    struct addrinfo *addr = NULL;

    rc = getaddrinfo(host, port, NULL, &amp;addr);
    check(rc == 0, &quot;Failed to lookup %s:%s&quot;, host, port);

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    check(sock &gt;= 0, &quot;Cannot create a socket.&quot;);

    rc = connect(sock, addr-&gt;ai_addr, addr-&gt;ai_addrlen);
    check(rc == 0, &quot;Connect failed.&quot;);

    rc = nonblock(sock);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    freeaddrinfo(addr);
    return sock;

error:
    freeaddrinfo(addr);
    return -1;
}

int read_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;

    if (RingBuffer_available_data(buffer) == 0) {
        buffer-&gt;start = buffer-&gt;end = 0;
    }

    if (is_socket) {
        rc = recv(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer), 0);
    } else {
        rc = read(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer));
    }

    check(rc &gt;= 0, &quot;Failed to read from fd: %d&quot;, fd);

    RingBuffer_commit_write(buffer, rc);

    return rc;

error:
    return -1;
}

int write_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;
    bstring data = RingBuffer_get_all(buffer);

    check(data != NULL, &quot;Failed to get from the buffer.&quot;);
    check(bfindreplace(data, &amp;NL, &amp;CRLF, 0) == BSTR_OK,
            &quot;Failed to replace NL.&quot;);

    if (is_socket) {
        rc = send(fd, bdata(data), blength(data), 0);
    } else {
        rc = write(fd, bdata(data), blength(data));
    }

    check(rc == blength(data), &quot;Failed to write everything to fd: %d.&quot;,
            fd);
    bdestroy(data);

    return rc;

error:
    return -1;
}

int attempt_listen(struct addrinfo *info)
{
    int sockfd = -1; // default fail
    int rc = -1;
    int yes = 1;

    check(info != NULL, &quot;Invalid addrinfo.&quot;);

    // create a socket with the addrinfo
    sockfd = socket(info-&gt;ai_family, info-&gt;ai_socktype,
            info-&gt;ai_protocol);
    check_debug(sockfd != -1, &quot;Failed to bind to address. Trying more.&quot;);

    // set the SO_REUSEADDR option on the socket
    rc = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));
    check_debug(rc == 0, &quot;Failed to set SO_REUSADDR.&quot;);

    // attempt to bind to it
    rc = bind(sockfd, info-&gt;ai_addr, info-&gt;ai_addrlen);
    check_debug(rc == 0, &quot;Failed to find socket.&quot;);

    // finally listen with a backlog
    rc = listen(sockfd, BACKLOG);
    check_debug(rc == 0, &quot;Failed to listen to socket.&quot;);

    return sockfd;

error:
    return -1;
}


int server_listen(const char *host, const char *port)
{
    int rc = 0;
    int sockfd = -1; // default fail value
    struct addrinfo *info = NULL;
    struct addrinfo *next_p = NULL;
    struct addrinfo addr = {
        .ai_family = AF_UNSPEC,
        .ai_socktype = SOCK_STREAM,
        .ai_flags = AI_PASSIVE
    };

    check(host != NULL, &quot;Invalid host.&quot;);
    check(port != NULL, &quot;Invalid port.&quot;);

    // get the address info for host and port
    rc = getaddrinfo(NULL, port, &amp;addr, &amp;info);
    check(rc == 0, &quot;Failed to get address info for connect.&quot;);

    // cycle through the available list to find one
    for(next_p = info; next_p != NULL; next_p = next_p-&gt;ai_next)
    {
        // attempt to listen to each one
        sockfd = attempt_listen(next_p);
        if(sockfd != -1) break;
    }

    // either we found one and were able to listen or nothing.
    check(sockfd != -1, &quot;All possible addresses failed.&quot;);

error: //fallthrough
    if(info) freeaddrinfo(info);
    // this gets set by the above to either -1 or valid
    return sockfd;
}

</code></pre>

<p>.\ex48b\statserve\src\net.h</p>

<pre><code class="language-c">#ifndef _net_h
#define _net_h

#include &lt;lcthw/ringbuffer.h&gt;

#define BACKLOG 10

int nonblock(int fd);
int client_connect(char *host, char *port);
int read_some(RingBuffer * buffer, int fd, int is_socket);
int write_some(RingBuffer * buffer, int fd, int is_socket);
int server_listen(const char *host, const char *port);

#endif

</code></pre>

<p>.\ex48b\statserve\src\statserve.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &quot;net.h&quot;
#include &lt;netdb.h&gt;

const int RB_SIZE = 1024 * 10;

void handle_sigchild(int sig) {
    sig = 0; // ignore it
    while(waitpid(-1, NULL, WNOHANG) &gt; 0) {
    }
}

void client_handler(int client_fd)
{
    int rc = 0;
    // need a ringbuffer for the input
    RingBuffer *sock_rb = RingBuffer_create(RB_SIZE);

    // read_some in a loop
    while(read_some(sock_rb, client_fd, 1) != -1) {
        // write_it back off the ringbuffer
        if(write_some(sock_rb, client_fd, 1) == -1) {
            debug(&quot;Client closed.&quot;);
            break;
        }
    }

    // close the socket
    rc = close(client_fd);
    check(rc != -1, &quot;Failed to close the socket.&quot;);

error: // fallthrough
    if(sock_rb) RingBuffer_destroy(sock_rb);
    exit(0); // just exit the child process
}

int echo_server(const char *host, const char *port)
{
    int rc = 0;
    struct sockaddr_in client_addr;
    socklen_t sin_size = sizeof(client_addr);
    int server_socket = 0;
    int client_fd = 0;

    struct sigaction sa = {
        .sa_handler = handle_sigchild,
        .sa_flags = SA_RESTART | SA_NOCLDSTOP
    };

    check(host != NULL, &quot;Invalid host.&quot;);
    check(port != NULL, &quot;Invalid port.&quot;);

    // create a sigaction that handles SIGCHLD
    sigemptyset(&amp;sa.sa_mask);
    rc = sigaction(SIGCHLD, &amp;sa, 0);
    check(rc != -1, &quot;Failed to setup signal handler for child processes.&quot;);

    // listen on the given port and host
    server_socket = server_listen(host, port);
    check(server_socket &gt;= 0, &quot;bind to %s:%s failed.&quot;, host, port);

    while(1) {
        // accept the connection
        client_fd = accept(server_socket, (struct sockaddr *)&amp;client_addr, &amp;sin_size); 
        check(client_fd &gt;= 0, &quot;Failed to accept connection.&quot;);

        debug(&quot;Client connected.&quot;);

        rc = fork();
        if(rc == 0) {
            // child process
            close(server_socket); // don't need this
            // handle the client
            client_handler(client_fd);
        } else {
            // server process
            close(client_fd); // don't need this
        }
    }

error:  // fallthrough
    return -1;
}

</code></pre>

<p>.\ex48b\statserve\src\statserve.h</p>

<pre><code class="language-c">#ifndef _statserve_h
#define _statserve_h

int echo_server(const char *host, const char *port);

#endif

</code></pre>

<p>.\ex48b\statserve\tests\statserve_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;dlfcn.h&gt;
#include &quot;statserve.h&quot;

char *test_dummy()
{
    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dummy);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>.\ex48b\c-skeleton</p>

<p>.\ex48b\c-skeleton\src\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex48b\c-skeleton\src\libex29.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &quot;dbg.h&quot;


int print_a_message(const char *msg)
{
    printf(&quot;A STRING: %s\n&quot;, msg);

    return 0;
}


int uppercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, toupper(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int lowercase(const char *msg)
{
    int i = 0;

    // BUG: \0 termination problems
    for(i = 0; msg[i] != '\0'; i++) {
        printf(&quot;%c&quot;, tolower(msg[i]));
    }

    printf(&quot;\n&quot;);

    return 0;
}

int fail_on_purpose(const char *msg)
{
    return 1;
} 

</code></pre>

<p>.\ex48b\c-skeleton\tests\libex29_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;dlfcn.h&gt;

typedef int (*lib_function) (const char *data);
char *lib_file = &quot;build/libYOUR_LIBRARY.so&quot;;
void *lib = NULL;

int check_function(const char *func_to_run, const char *data,
        int expected)
{
    lib_function func = dlsym(lib, func_to_run);
    check(func != NULL,
            &quot;Did not find %s function in the library %s: %s&quot;, func_to_run,
            lib_file, dlerror());

    int rc = func(data);
    check(rc == expected, &quot;Function %s return %d for data: %s&quot;,
            func_to_run, rc, data);

    return 1;
error:
    return 0;
}

char *test_dlopen()
{
    lib = dlopen(lib_file, RTLD_NOW);
    mu_assert(lib != NULL, &quot;Failed to open the library to test.&quot;);

    return NULL;
}

char *test_functions()
{
    mu_assert(check_function(&quot;print_a_message&quot;, &quot;Hello&quot;, 0),
            &quot;print_a_message failed.&quot;);
    mu_assert(check_function(&quot;uppercase&quot;, &quot;Hello&quot;, 0),
            &quot;uppercase failed.&quot;);
    mu_assert(check_function(&quot;lowercase&quot;, &quot;Hello&quot;, 0),
            &quot;lowercase failed.&quot;);

    return NULL;
}

char *test_failures()
{
    mu_assert(check_function(&quot;fail_on_purpose&quot;, &quot;Hello&quot;, 1),
            &quot;fail_on_purpose should fail.&quot;);

    return NULL;
}

char *test_dlclose()
{
    int rc = dlclose(lib);
    mu_assert(rc == 0, &quot;Failed to close lib.&quot;);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dlopen);
    mu_run_test(test_functions);
    mu_run_test(test_failures);
    mu_run_test(test_dlclose);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>.\ex48b\statserve</p>

<p>.\ex48b\statserve\bin\statserve.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &quot;statserve.h&quot;
#include &quot;net.h&quot;


int main(int argc, char *argv[])
{
    check(argc == 3, &quot;USAGE: statserve host port&quot;);

    const char *host = argv[1];
    const char *port = argv[2];

    check(echo_server(host, port), &quot;Failed to run the echo server.&quot;);

    return 0;

error:
    
    return 1;
}

</code></pre>

<p>.\ex48b\statserve\src\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex48b\statserve\src\net.c</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;stdio.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &quot;net.h&quot;

struct tagbstring NL = bsStatic(&quot;\n&quot;);
struct tagbstring CRLF = bsStatic(&quot;\r\n&quot;);

int nonblock(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    check(flags &gt;= 0, &quot;Invalid flags on nonblock.&quot;);

    int rc = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    return 0;
error:
    return -1;
}

int client_connect(char *host, char *port)
{
    int rc = 0;
    struct addrinfo *addr = NULL;

    rc = getaddrinfo(host, port, NULL, &amp;addr);
    check(rc == 0, &quot;Failed to lookup %s:%s&quot;, host, port);

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    check(sock &gt;= 0, &quot;Cannot create a socket.&quot;);

    rc = connect(sock, addr-&gt;ai_addr, addr-&gt;ai_addrlen);
    check(rc == 0, &quot;Connect failed.&quot;);

    rc = nonblock(sock);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    freeaddrinfo(addr);
    return sock;

error:
    freeaddrinfo(addr);
    return -1;
}

int read_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;

    if (RingBuffer_available_data(buffer) == 0) {
        buffer-&gt;start = buffer-&gt;end = 0;
    }

    if (is_socket) {
        rc = recv(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer), 0);
    } else {
        rc = read(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer));
    }

    check(rc &gt;= 0, &quot;Failed to read from fd: %d&quot;, fd);

    RingBuffer_commit_write(buffer, rc);

    return rc;

error:
    return -1;
}

int write_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;
    bstring data = RingBuffer_get_all(buffer);

    check(data != NULL, &quot;Failed to get from the buffer.&quot;);
    check(bfindreplace(data, &amp;NL, &amp;CRLF, 0) == BSTR_OK,
            &quot;Failed to replace NL.&quot;);

    if (is_socket) {
        rc = send(fd, bdata(data), blength(data), 0);
    } else {
        rc = write(fd, bdata(data), blength(data));
    }

    check(rc == blength(data), &quot;Failed to write everything to fd: %d.&quot;,
            fd);
    bdestroy(data);

    return rc;

error:
    return -1;
}

int attempt_listen(struct addrinfo *info)
{
    int sockfd = -1; // default fail
    int rc = -1;
    int yes = 1;

    check(info != NULL, &quot;Invalid addrinfo.&quot;);

    // create a socket with the addrinfo
    sockfd = socket(info-&gt;ai_family, info-&gt;ai_socktype,
            info-&gt;ai_protocol);
    check_debug(sockfd != -1, &quot;Failed to bind to address. Trying more.&quot;);

    // set the SO_REUSEADDR option on the socket
    rc = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));
    check_debug(rc == 0, &quot;Failed to set SO_REUSADDR.&quot;);

    // attempt to bind to it
    rc = bind(sockfd, info-&gt;ai_addr, info-&gt;ai_addrlen);
    check_debug(rc == 0, &quot;Failed to find socket.&quot;);

    // finally listen with a backlog
    rc = listen(sockfd, BACKLOG);
    check_debug(rc == 0, &quot;Failed to listen to socket.&quot;);

    return sockfd;

error:
    return -1;
}


int server_listen(const char *host, const char *port)
{
    int rc = 0;
    int sockfd = -1; // default fail value
    struct addrinfo *info = NULL;
    struct addrinfo *next_p = NULL;
    struct addrinfo addr = {
        .ai_family = AF_UNSPEC,
        .ai_socktype = SOCK_STREAM,
        .ai_flags = AI_PASSIVE
    };

    check(host != NULL, &quot;Invalid host.&quot;);
    check(port != NULL, &quot;Invalid port.&quot;);

    // get the address info for host and port
    rc = getaddrinfo(NULL, port, &amp;addr, &amp;info);
    check(rc == 0, &quot;Failed to get address info for connect.&quot;);

    // cycle through the available list to find one
    for(next_p = info; next_p != NULL; next_p = next_p-&gt;ai_next)
    {
        // attempt to listen to each one
        sockfd = attempt_listen(next_p);
        if(sockfd != -1) break;
    }

    // either we found one and were able to listen or nothing.
    check(sockfd != -1, &quot;All possible addresses failed.&quot;);

error: //fallthrough
    if(info) freeaddrinfo(info);
    // this gets set by the above to either -1 or valid
    return sockfd;
}

</code></pre>

<p>.\ex48b\statserve\src\net.h</p>

<pre><code class="language-c">#ifndef _net_h
#define _net_h

#include &lt;lcthw/ringbuffer.h&gt;

#define BACKLOG 10

int nonblock(int fd);
int client_connect(char *host, char *port);
int read_some(RingBuffer * buffer, int fd, int is_socket);
int write_some(RingBuffer * buffer, int fd, int is_socket);
int server_listen(const char *host, const char *port);

#endif

</code></pre>

<p>.\ex48b\statserve\src\statserve.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &quot;net.h&quot;
#include &lt;netdb.h&gt;

const int RB_SIZE = 1024 * 10;

void handle_sigchild(int sig) {
    sig = 0; // ignore it
    while(waitpid(-1, NULL, WNOHANG) &gt; 0) {
    }
}

void client_handler(int client_fd)
{
    int rc = 0;
    // need a ringbuffer for the input
    RingBuffer *sock_rb = RingBuffer_create(RB_SIZE);

    // read_some in a loop
    while(read_some(sock_rb, client_fd, 1) != -1) {
        // write_it back off the ringbuffer
        if(write_some(sock_rb, client_fd, 1) == -1) {
            debug(&quot;Client closed.&quot;);
            break;
        }
    }

    // close the socket
    rc = close(client_fd);
    check(rc != -1, &quot;Failed to close the socket.&quot;);

error: // fallthrough
    if(sock_rb) RingBuffer_destroy(sock_rb);
    exit(0); // just exit the child process
}

int echo_server(const char *host, const char *port)
{
    int rc = 0;
    struct sockaddr_in client_addr;
    socklen_t sin_size = sizeof(client_addr);
    int server_socket = 0;
    int client_fd = 0;

    struct sigaction sa = {
        .sa_handler = handle_sigchild,
        .sa_flags = SA_RESTART | SA_NOCLDSTOP
    };

    check(host != NULL, &quot;Invalid host.&quot;);
    check(port != NULL, &quot;Invalid port.&quot;);

    // create a sigaction that handles SIGCHLD
    sigemptyset(&amp;sa.sa_mask);
    rc = sigaction(SIGCHLD, &amp;sa, 0);
    check(rc != -1, &quot;Failed to setup signal handler for child processes.&quot;);

    // listen on the given port and host
    server_socket = server_listen(host, port);
    check(server_socket &gt;= 0, &quot;bind to %s:%s failed.&quot;, host, port);

    while(1) {
        // accept the connection
        client_fd = accept(server_socket, (struct sockaddr *)&amp;client_addr, &amp;sin_size); 
        check(client_fd &gt;= 0, &quot;Failed to accept connection.&quot;);

        debug(&quot;Client connected.&quot;);

        rc = fork();
        if(rc == 0) {
            // child process
            close(server_socket); // don't need this
            // handle the client
            client_handler(client_fd);
        } else {
            // server process
            close(client_fd); // don't need this
        }
    }

error:  // fallthrough
    return -1;
}

</code></pre>

<p>.\ex48b\statserve\src\statserve.h</p>

<pre><code class="language-c">#ifndef _statserve_h
#define _statserve_h

int echo_server(const char *host, const char *port);

#endif

</code></pre>

<p>.\ex48b\statserve\tests\statserve_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;dlfcn.h&gt;
#include &quot;statserve.h&quot;

char *test_dummy()
{
    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    mu_run_test(test_dummy);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>Solution</p>

<p>The Plan</p>

<p>Show you how I solved the <em>statserve</em> project.</p>

<p>The Purpose</p>

<p>Watch me solve the first project quickly, then review the code.</p>

<p>The Setup</p>

<p>First I need to install liblcthw since I&rsquo;ll be using that.</p>

<p>Then I make the project skeleton and get something, anything going.</p>

<p>The Server</p>

<p>Then I just get it accepting a connection.</p>

<p>The Echo</p>

<p>Then I decided to just make it echo back what I type.</p>

<p>The Final Code</p>

<h2 id="exercise-49b-a-statistics-server">Exercise 49b A Statistics Server</h2>

<p>Project Description</p>

<p>The Plan</p>

<p>Make the <em>statsserver</em> do something using a simple protocol.</p>

<p>The Purpose</p>

<p>Learn the first steps in creating a server that answers a protocol.</p>

<p>The Requirements</p>

<p>Create this protocol:</p>

<pre><code>create Create a new statistic.
mean   Get the current mean of a statistic.
sample Add a new sample to a statistics.
dump   Get all of the elements of a statistic (sum, sumsq, n, min, and max).
</code></pre>

<p>The Requirements</p>

<ol>
<li>You&rsquo;ll need to allow people to name these statistics, which means using one of the map style data structures to map names to <code>Stats</code> structs.</li>
<li>You&rsquo;ll need to add the <code>CRUD</code> standard operations for each name.  CRUD stands for create read update delete.  Currently, the list of commands above has create, mean, and dump for reading; and sample for updating.  You need a delete command now.</li>
<li>Make the protocol <em>strict</em>! Abort any client that makes any mistakes in protocols.</li>
</ol>

<p>Strict Protocol</p>

<p>Once again, in case you missed it, be ruthless!</p>

<p>Abort all deviant clients.</p>

<p>Pause!</p>

<p>I&rsquo;m going to give you clues to solve this, so if you want to try on your own pause now!</p>

<p>The Clues</p>

<ul>
<li>Create the data structures first for holding the information for each of these commands.</li>
<li>Then write a protocol parser to handle it and fill in the data.</li>
<li>Then pass that data to a function that knows how to do that command.</li>
<li>You can just store the stats in a Hashmap, BSTree, or TSTree for now.</li>
<li>KEEP IT SIMPLE!</li>
</ul>

<p>Important References</p>

<ul>
<li>You&rsquo;ll want to refer to the bstring documentation as much as possible to know what functions to use.</li>
</ul>

<p>Encouragement</p>

<ul>
<li>Remember that this is <em>supposed</em> to be hard.</li>
<li>You are <em>supposed</em> to struggle with this.</li>
<li>This could take you a while, but keep up the struggle, do it bit by bit, and test little pieces as you go.</li>
<li>Automate your tests!</li>
</ul>

<h2 id="exercise-49a-a-statistics-server">Exercise 49a A Statistics Server:</h2>

<p>.\ex49b\statserve</p>

<p>.\ex49b\statserve\bin\statserve.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &quot;statserve.h&quot;
#include &quot;net.h&quot;


int main(int argc, char *argv[])
{
    check(argc == 3, &quot;USAGE: statserve host port&quot;);

    const char *host = argv[1];
    const char *port = argv[2];

    check(echo_server(host, port), &quot;Failed to run the echo server.&quot;);

    return 0;

error:
    
    return 1;
}

</code></pre>

<p>.\ex49b\statserve\src\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex49b\statserve\src\net.c</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;stdio.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &quot;net.h&quot;

struct tagbstring NL = bsStatic(&quot;\n&quot;);
struct tagbstring CRLF = bsStatic(&quot;\r\n&quot;);

int nonblock(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    check(flags &gt;= 0, &quot;Invalid flags on nonblock.&quot;);

    int rc = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    return 0;
error:
    return -1;
}

int client_connect(char *host, char *port)
{
    int rc = 0;
    struct addrinfo *addr = NULL;

    rc = getaddrinfo(host, port, NULL, &amp;addr);
    check(rc == 0, &quot;Failed to lookup %s:%s&quot;, host, port);

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    check(sock &gt;= 0, &quot;Cannot create a socket.&quot;);

    rc = connect(sock, addr-&gt;ai_addr, addr-&gt;ai_addrlen);
    check(rc == 0, &quot;Connect failed.&quot;);

    rc = nonblock(sock);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    freeaddrinfo(addr);
    return sock;

error:
    freeaddrinfo(addr);
    return -1;
}

int read_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;

    if (RingBuffer_available_data(buffer) == 0) {
        buffer-&gt;start = buffer-&gt;end = 0;
    }

    if (is_socket) {
        rc = recv(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer), 0);
    } else {
        rc = read(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer));
    }

    check(rc &gt;= 0, &quot;Failed to read from fd: %d&quot;, fd);

    RingBuffer_commit_write(buffer, rc);

    return rc;

error:
    return -1;
}

int write_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;
    bstring data = RingBuffer_get_all(buffer);

    check(data != NULL, &quot;Failed to get from the buffer.&quot;);
    check(bfindreplace(data, &amp;NL, &amp;CRLF, 0) == BSTR_OK,
            &quot;Failed to replace NL.&quot;);

    if (is_socket) {
        rc = send(fd, bdata(data), blength(data), 0);
    } else {
        rc = write(fd, bdata(data), blength(data));
    }

    check(rc == blength(data), &quot;Failed to write everything to fd: %d.&quot;,
            fd);
    bdestroy(data);

    return rc;

error:
    return -1;
}

int attempt_listen(struct addrinfo *info)
{
    int sockfd = -1; // default fail
    int rc = -1;
    int yes = 1;

    check(info != NULL, &quot;Invalid addrinfo.&quot;);

    // create a socket with the addrinfo
    sockfd = socket(info-&gt;ai_family, info-&gt;ai_socktype,
            info-&gt;ai_protocol);
    check_debug(sockfd != -1, &quot;Failed to bind to address. Trying more.&quot;);

    // set the SO_REUSEADDR option on the socket
    rc = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));
    check_debug(rc == 0, &quot;Failed to set SO_REUSADDR.&quot;);

    // attempt to bind to it
    rc = bind(sockfd, info-&gt;ai_addr, info-&gt;ai_addrlen);
    check_debug(rc == 0, &quot;Failed to find socket.&quot;);

    // finally listen with a backlog
    rc = listen(sockfd, BACKLOG);
    check_debug(rc == 0, &quot;Failed to listen to socket.&quot;);

    return sockfd;

error:
    return -1;
}


int server_listen(const char *host, const char *port)
{
    int rc = 0;
    int sockfd = -1; // default fail value
    struct addrinfo *info = NULL;
    struct addrinfo *next_p = NULL;
    struct addrinfo addr = {
        .ai_family = AF_UNSPEC,
        .ai_socktype = SOCK_STREAM,
        .ai_flags = AI_PASSIVE
    };

    check(host != NULL, &quot;Invalid host.&quot;);
    check(port != NULL, &quot;Invalid port.&quot;);

    // get the address info for host and port
    rc = getaddrinfo(NULL, port, &amp;addr, &amp;info);
    check(rc == 0, &quot;Failed to get address info for connect.&quot;);

    // cycle through the available list to find one
    for(next_p = info; next_p != NULL; next_p = next_p-&gt;ai_next)
    {
        // attempt to listen to each one
        sockfd = attempt_listen(next_p);
        if(sockfd != -1) break;
    }

    // either we found one and were able to listen or nothing.
    check(sockfd != -1, &quot;All possible addresses failed.&quot;);

error: //fallthrough
    if(info) freeaddrinfo(info);
    // this gets set by the above to either -1 or valid
    return sockfd;
}

bstring read_line(RingBuffer *input, const char line_ending)
{
    int i = 0;
    bstring result = NULL;

    // not super efficient
    // read a character at a time from the ring buffer
    for(i = 0; i &lt; RingBuffer_available_data(input); i++) {
        // if the buffer has line ending
        if(input-&gt;buffer[i] == line_ending) {
            // get that much fromt he ring buffer
            result = RingBuffer_gets(input, i);
            check(result, &quot;Failed to get line from RingBuffer&quot;);
            // make sure that we got the right amount
            check(RingBuffer_available_data(input) &gt;= 1, 
                    &quot;Not enough data in the RingBuffer after reading line.&quot;);
            // and commit it
            RingBuffer_commit_read(input, 1);
            break;
        }
    }

    // notice this will fail in the cases where we get a set of data
    // on the wire that does not have a line ending yet
    return result;
error:
    return NULL;
}

</code></pre>

<p>.\ex49b\statserve\src\net.h</p>

<pre><code class="language-c">#ifndef _net_h
#define _net_h

#include &lt;lcthw/ringbuffer.h&gt;

#define BACKLOG 10

int nonblock(int fd);
int client_connect(char *host, char *port);
int read_some(RingBuffer * buffer, int fd, int is_socket);
int write_some(RingBuffer * buffer, int fd, int is_socket);
int server_listen(const char *host, const char *port);
bstring read_line(RingBuffer *input, const char line_ending);

#endif

</code></pre>

<p>.\ex49b\statserve\src\statserve.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;lcthw/hashmap.h&gt;
#include &lt;lcthw/stats.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &quot;net.h&quot;
#include &lt;netdb.h&gt;

struct tagbstring LINE_SPLIT = bsStatic(&quot; &quot;);
struct tagbstring CREATE = bsStatic(&quot;create&quot;);
struct tagbstring STDDEV = bsStatic(&quot;stddev&quot;);
struct tagbstring MEAN = bsStatic(&quot;mean&quot;);
struct tagbstring SAMPLE = bsStatic(&quot;sample&quot;);
struct tagbstring DUMP = bsStatic(&quot;dump&quot;);
struct tagbstring DELETE = bsStatic(&quot;delete&quot;);
struct tagbstring OK = bsStatic(&quot;OK\n&quot;);
struct tagbstring ERR = bsStatic(&quot;ERR\n&quot;);
struct tagbstring DNE = bsStatic(&quot;DNE\n&quot;);
struct tagbstring EXISTS = bsStatic(&quot;EXISTS\n&quot;);
const char LINE_ENDING = '\n';

const int RB_SIZE = 1024 * 10;

Hashmap *DATA = NULL;

struct Command;

typedef int (*handler_cb)(struct Command *cmd, RingBuffer *send_rb);

typedef struct Command {
    bstring command;
    bstring name;
    bstring number;
    handler_cb handler;
} Command;


typedef struct Record {
    bstring name;
    Stats *stat;
} Record;

void handle_sigchild(int sig) {
    sig = 0; // ignore it
    while(waitpid(-1, NULL, WNOHANG) &gt; 0) {
    }
}

void send_reply(RingBuffer *send_rb, bstring reply)
{
    RingBuffer_puts(send_rb, reply);
}

int handle_create(Command *cmd, RingBuffer *send_rb)
{
    int rc = 0;

    // if the name is in the DATA map then return exists
    if(Hashmap_get(DATA, cmd-&gt;name)) {
        send_reply(send_rb, &amp;EXISTS);
    } else {
        // allocate a recrod
        debug(&quot;create: %s %s&quot;, bdata(cmd-&gt;name), bdata(cmd-&gt;number));

        Record *info = calloc(sizeof(Record), 1);
        check_mem(info);

        // set its stat element
        info-&gt;stat = Stats_create();
        check_mem(info-&gt;stat);

        // set its name element
        info-&gt;name = bstrcpy(cmd-&gt;name);
        check_mem(info-&gt;name);

        // do a first sample
        Stats_sample(info-&gt;stat, atof(bdata(cmd-&gt;number)));

        // add it to the hashmap
        rc = Hashmap_set(DATA, info-&gt;name, info);
        check(rc == 0, &quot;Failed to add data to map.&quot;);

        // send an OK
        send_reply(send_rb, &amp;OK);
    }

    return 0;
error:
    return -1;
}


int handle_sample(Command *cmd, RingBuffer *send_rb)
{
    // get the info from the hashmap
    Record *info = Hashmap_get(DATA, cmd-&gt;name);

    if(info == NULL) {
        // if it doesn't exist then DNE
        send_reply(send_rb, &amp;DNE);
    } else {
        // else run sample on it, return the mean
        Stats_sample(info-&gt;stat, atof(bdata(cmd-&gt;number)));
        bstring reply = bformat(&quot;%f\n&quot;, Stats_mean(info-&gt;stat));
        send_reply(send_rb, reply);
        bdestroy(reply);
    }


    return 0;
}

int handle_delete(Command *cmd, RingBuffer *send_rb)
{
    log_info(&quot;delete: %s&quot;, bdata(cmd-&gt;name));
    Record *info = Hashmap_get(DATA, cmd-&gt;name);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        Hashmap_delete(DATA, cmd-&gt;name);

        free(info-&gt;stat);
        bdestroy(info-&gt;name);
        free(info);

        send_reply(send_rb, &amp;OK);
    }

    return 0;
}

int handle_mean(Command *cmd, RingBuffer *send_rb)
{
    log_info(&quot;mean: %s&quot;, bdata(cmd-&gt;name));
    Record *info = Hashmap_get(DATA, cmd-&gt;name);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        bstring reply = bformat(&quot;%f\n&quot;, Stats_mean(info-&gt;stat));
        send_reply(send_rb, reply);
        bdestroy(reply);
    }

    return 0;
}

int handle_stddev(Command *cmd, RingBuffer *send_rb)
{
    log_info(&quot;stddev: %s&quot;, bdata(cmd-&gt;name));
    Record *info = Hashmap_get(DATA, cmd-&gt;name);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        bstring reply = bformat(&quot;%f\n&quot;, Stats_stddev(info-&gt;stat));
        send_reply(send_rb, reply);
        bdestroy(reply);
    }

    return 0;
}

int handle_dump(Command *cmd, RingBuffer *send_rb)
{
    log_info(&quot;dump: %s&quot;, bdata(cmd-&gt;name));
    Record *info = Hashmap_get(DATA, cmd-&gt;name);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        bstring reply = bformat(&quot;%f %f %f %f %ld %f %f\n&quot;,
                Stats_mean(info-&gt;stat),
                Stats_stddev(info-&gt;stat),
                info-&gt;stat-&gt;sum,
                info-&gt;stat-&gt;sumsq,
                info-&gt;stat-&gt;n,
                info-&gt;stat-&gt;min,
                info-&gt;stat-&gt;max);

        send_reply(send_rb, reply);
        bdestroy(reply);
    }

    return 0;
}

int parse_command(struct bstrList *splits, Command *cmd)
{
    // get the command
    cmd-&gt;command = splits-&gt;entry[0];

    if(biseq(cmd-&gt;command, &amp;CREATE)) {
        check(splits-&gt;qty == 3, &quot;Failed to parse create: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;number = splits-&gt;entry[2];
        cmd-&gt;handler = handle_create;
    } else if(biseq(cmd-&gt;command, &amp;MEAN)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse mean: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_mean;
    } else if(biseq(cmd-&gt;command, &amp;SAMPLE)) {
        check(splits-&gt;qty == 3, &quot;Failed to parse sample: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;number = splits-&gt;entry[2];
        cmd-&gt;handler = handle_sample;
    } else if(biseq(cmd-&gt;command, &amp;DUMP)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse dump: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_dump;
    } else if(biseq(cmd-&gt;command, &amp;DELETE)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse delete: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_delete;
    } else if(biseq(cmd-&gt;command, &amp;STDDEV)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse stddev: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_stddev;
    } else {
        sentinel(&quot;Failed to parse the command.&quot;);
    }

    return 0;
error:
    return -1;
}

int parse_line(bstring data, RingBuffer *send_rb)
{
    int rc = -1;
    Command cmd = {.command = NULL};

    // split data on line boundaries
    struct bstrList *splits = bsplits(data, &amp;LINE_SPLIT);
    check(splits != NULL, &quot;Bad data.&quot;);

    // parse it into a command
    rc = parse_command(splits, &amp;cmd);
    check(rc == 0, &quot;Failed to parse command.&quot;);

    // call the command handler for that command
    rc = cmd.handler(&amp;cmd, send_rb);

error: // fallthrough
    if(splits) bstrListDestroy(splits);
    return rc;

}

void client_handler(int client_fd)
{
    int rc = 0;
    RingBuffer *recv_rb = RingBuffer_create(RB_SIZE);
    RingBuffer *send_rb = RingBuffer_create(RB_SIZE);

    check_mem(recv_rb);
    check_mem(send_rb);

    // keep reading into the recv buffer and sending on send
    while(read_some(recv_rb, client_fd, 1) != -1) {
        // read a line from the recv_rb
        bstring data = read_line(recv_rb, LINE_ENDING);
        check(data != NULL, &quot;Client closed.&quot;);

        // parse it, close on any protocol errors
        rc = parse_line(data, send_rb);
        bdestroy(data); // cleanup here
        check(rc == 0, &quot;Failed to parse user. Closing.&quot;);

        // and as long as there's something to send, send it
        if(RingBuffer_available_data(send_rb)) {
            write_some(send_rb, client_fd, 1);
        }
    }

    // close the socket
    rc = close(client_fd);
    check(rc != -1, &quot;Failed to close the socket.&quot;);

error: // fallthrough
    if(recv_rb) RingBuffer_destroy(recv_rb);
    if(send_rb) RingBuffer_destroy(send_rb);
    exit(0); // just exit the child process
}

int setup_data_store()
{
    // a more advanced design simply wouldn't use this
    DATA = Hashmap_create(NULL, NULL);
    check_mem(DATA);

    return 0;
error:
    return -1;
}

int echo_server(const char *host, const char *port)
{
    int rc = 0;
    struct sockaddr_in client_addr;
    socklen_t sin_size = sizeof(client_addr);
    int server_socket = 0;
    int client_fd = 0;

    rc = setup_data_store();
    check(rc == 0, &quot;Failed to setup the data store.&quot;);

    struct sigaction sa = {
        .sa_handler = handle_sigchild,
        .sa_flags = SA_RESTART | SA_NOCLDSTOP
    };

    check(host != NULL, &quot;Invalid host.&quot;);
    check(port != NULL, &quot;Invalid port.&quot;);

    // create a sigaction that handles SIGCHLD
    sigemptyset(&amp;sa.sa_mask);
    rc = sigaction(SIGCHLD, &amp;sa, 0);
    check(rc != -1, &quot;Failed to setup signal handler for child processes.&quot;);

    // listen on the given port and host
    server_socket = server_listen(host, port);
    check(server_socket &gt;= 0, &quot;bind to %s:%s failed.&quot;, host, port);

    while(1) {
        // accept the connection
        client_fd = accept(server_socket, (struct sockaddr *)&amp;client_addr, &amp;sin_size); 
        check(client_fd &gt;= 0, &quot;Failed to accept connection.&quot;);

        debug(&quot;Client connected.&quot;);

        rc = fork();
        if(rc == 0) {
            // child process
            close(server_socket); // don't need this
            // handle the client
            client_handler(client_fd);
        } else {
            // server process
            close(client_fd); // don't need this
        }
    }

error:  // fallthrough
    return -1;
}

</code></pre>

<p>.\ex49b\statserve\src\statserve.h</p>

<pre><code class="language-c">#ifndef _statserve_h
#define _statserve_h

#include &lt;lcthw/bstrlib.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;

struct tagbstring OK;

int setup_data_store();

int parse_line(bstring data, RingBuffer *send_rb);

int echo_server(const char *host, const char *port);

#endif

</code></pre>

<p>.\ex49b\statserve\tests\statserve_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;dlfcn.h&gt;
#include &quot;statserve.h&quot;
#include &lt;lcthw/bstrlib.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;assert.h&gt;

typedef struct LineTest {
    char *line;
    bstring result;
    char *description;
} LineTest;

int attempt_line(LineTest test)
{
    int rc = -1;
    bstring result = NULL;

    bstring line = bfromcstr(test.line);
    RingBuffer *send_rb = RingBuffer_create(1024);

    rc = parse_line(line, send_rb);
    check(rc == 0, &quot;Failed to parse line.&quot;);

    result = RingBuffer_get_all(send_rb);
    check(result != NULL, &quot;Ring buffer empty.&quot;);
    check(biseq(result, test.result), &quot;Got the wrong output: %s expected %s&quot;,
            bdata(result), bdata(test.result));

    bdestroy(line);
    RingBuffer_destroy(send_rb);
    return 1; // using 1 for tests
error:
  
    log_err(&quot;Failed to process test %s: got %s&quot;, test.line, bdata(result));
    if(line) bdestroy(line);
    if(send_rb) RingBuffer_destroy(send_rb);
    return 0;
}


int run_test_lines(LineTest *tests, int count)
{
    int i = 0;

    for(i = 0; i &lt; count; i++) {
        check(attempt_line(tests[i]), &quot;Failed to run %s&quot;, tests[i].description);
    }

    return 1;
error:
    return 0;
}

char *test_create()
{
    LineTest tests[] = {
        {.line = &quot;create /zed 100&quot;, .result = &amp;OK, .description = &quot;create zed failed&quot;},
        {.line = &quot;create /joe 100&quot;, .result = &amp;OK, .description = &quot;create joe failed&quot;},

    };

    mu_assert(run_test_lines(tests, 2), &quot;Failed to run create tests.&quot;);

    return NULL;
}

char *test_sample()
{
    struct tagbstring sample1 = bsStatic(&quot;100.000000\n&quot;);

    LineTest tests[] = {
        {.line = &quot;sample /zed 100&quot;, .result = &amp;sample1, .description = &quot;sample zed failed.&quot;}
    };

    mu_assert(run_test_lines(tests, 1), &quot;Failed to run sample tests.&quot;);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    int rc = setup_data_store();
    mu_assert(rc == 0, &quot;Failed to setup the data store.&quot;);

    mu_run_test(test_create);
    mu_run_test(test_sample);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>.\ex49b\statserve</p>

<p>.\ex49b\statserve\bin\statserve.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &quot;statserve.h&quot;
#include &quot;net.h&quot;


int main(int argc, char *argv[])
{
    check(argc == 3, &quot;USAGE: statserve host port&quot;);

    const char *host = argv[1];
    const char *port = argv[2];

    check(echo_server(host, port), &quot;Failed to run the echo server.&quot;);

    return 0;

error:
    
    return 1;
}

</code></pre>

<p>.\ex49b\statserve\src\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex49b\statserve\src\net.c</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;stdio.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &quot;net.h&quot;

struct tagbstring NL = bsStatic(&quot;\n&quot;);
struct tagbstring CRLF = bsStatic(&quot;\r\n&quot;);

int nonblock(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    check(flags &gt;= 0, &quot;Invalid flags on nonblock.&quot;);

    int rc = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    return 0;
error:
    return -1;
}

int client_connect(char *host, char *port)
{
    int rc = 0;
    struct addrinfo *addr = NULL;

    rc = getaddrinfo(host, port, NULL, &amp;addr);
    check(rc == 0, &quot;Failed to lookup %s:%s&quot;, host, port);

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    check(sock &gt;= 0, &quot;Cannot create a socket.&quot;);

    rc = connect(sock, addr-&gt;ai_addr, addr-&gt;ai_addrlen);
    check(rc == 0, &quot;Connect failed.&quot;);

    rc = nonblock(sock);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    freeaddrinfo(addr);
    return sock;

error:
    freeaddrinfo(addr);
    return -1;
}

int read_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;

    if (RingBuffer_available_data(buffer) == 0) {
        buffer-&gt;start = buffer-&gt;end = 0;
    }

    if (is_socket) {
        rc = recv(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer), 0);
    } else {
        rc = read(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer));
    }

    check(rc &gt;= 0, &quot;Failed to read from fd: %d&quot;, fd);

    RingBuffer_commit_write(buffer, rc);

    return rc;

error:
    return -1;
}

int write_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;
    bstring data = RingBuffer_get_all(buffer);

    check(data != NULL, &quot;Failed to get from the buffer.&quot;);
    check(bfindreplace(data, &amp;NL, &amp;CRLF, 0) == BSTR_OK,
            &quot;Failed to replace NL.&quot;);

    if (is_socket) {
        rc = send(fd, bdata(data), blength(data), 0);
    } else {
        rc = write(fd, bdata(data), blength(data));
    }

    check(rc == blength(data), &quot;Failed to write everything to fd: %d.&quot;,
            fd);
    bdestroy(data);

    return rc;

error:
    return -1;
}

int attempt_listen(struct addrinfo *info)
{
    int sockfd = -1; // default fail
    int rc = -1;
    int yes = 1;

    check(info != NULL, &quot;Invalid addrinfo.&quot;);

    // create a socket with the addrinfo
    sockfd = socket(info-&gt;ai_family, info-&gt;ai_socktype,
            info-&gt;ai_protocol);
    check_debug(sockfd != -1, &quot;Failed to bind to address. Trying more.&quot;);

    // set the SO_REUSEADDR option on the socket
    rc = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));
    check_debug(rc == 0, &quot;Failed to set SO_REUSADDR.&quot;);

    // attempt to bind to it
    rc = bind(sockfd, info-&gt;ai_addr, info-&gt;ai_addrlen);
    check_debug(rc == 0, &quot;Failed to find socket.&quot;);

    // finally listen with a backlog
    rc = listen(sockfd, BACKLOG);
    check_debug(rc == 0, &quot;Failed to listen to socket.&quot;);

    return sockfd;

error:
    return -1;
}


int server_listen(const char *host, const char *port)
{
    int rc = 0;
    int sockfd = -1; // default fail value
    struct addrinfo *info = NULL;
    struct addrinfo *next_p = NULL;
    struct addrinfo addr = {
        .ai_family = AF_UNSPEC,
        .ai_socktype = SOCK_STREAM,
        .ai_flags = AI_PASSIVE
    };

    check(host != NULL, &quot;Invalid host.&quot;);
    check(port != NULL, &quot;Invalid port.&quot;);

    // get the address info for host and port
    rc = getaddrinfo(NULL, port, &amp;addr, &amp;info);
    check(rc == 0, &quot;Failed to get address info for connect.&quot;);

    // cycle through the available list to find one
    for(next_p = info; next_p != NULL; next_p = next_p-&gt;ai_next)
    {
        // attempt to listen to each one
        sockfd = attempt_listen(next_p);
        if(sockfd != -1) break;
    }

    // either we found one and were able to listen or nothing.
    check(sockfd != -1, &quot;All possible addresses failed.&quot;);

error: //fallthrough
    if(info) freeaddrinfo(info);
    // this gets set by the above to either -1 or valid
    return sockfd;
}

bstring read_line(RingBuffer *input, const char line_ending)
{
    int i = 0;
    bstring result = NULL;

    // not super efficient
    // read a character at a time from the ring buffer
    for(i = 0; i &lt; RingBuffer_available_data(input); i++) {
        // if the buffer has line ending
        if(input-&gt;buffer[i] == line_ending) {
            // get that much fromt he ring buffer
            result = RingBuffer_gets(input, i);
            check(result, &quot;Failed to get line from RingBuffer&quot;);
            // make sure that we got the right amount
            check(RingBuffer_available_data(input) &gt;= 1, 
                    &quot;Not enough data in the RingBuffer after reading line.&quot;);
            // and commit it
            RingBuffer_commit_read(input, 1);
            break;
        }
    }

    // notice this will fail in the cases where we get a set of data
    // on the wire that does not have a line ending yet
    return result;
error:
    return NULL;
}

</code></pre>

<p>.\ex49b\statserve\src\net.h</p>

<pre><code class="language-c">#ifndef _net_h
#define _net_h

#include &lt;lcthw/ringbuffer.h&gt;

#define BACKLOG 10

int nonblock(int fd);
int client_connect(char *host, char *port);
int read_some(RingBuffer * buffer, int fd, int is_socket);
int write_some(RingBuffer * buffer, int fd, int is_socket);
int server_listen(const char *host, const char *port);
bstring read_line(RingBuffer *input, const char line_ending);

#endif

</code></pre>

<p>.\ex49b\statserve\src\statserve.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;lcthw/hashmap.h&gt;
#include &lt;lcthw/stats.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &quot;net.h&quot;
#include &lt;netdb.h&gt;

struct tagbstring LINE_SPLIT = bsStatic(&quot; &quot;);
struct tagbstring CREATE = bsStatic(&quot;create&quot;);
struct tagbstring STDDEV = bsStatic(&quot;stddev&quot;);
struct tagbstring MEAN = bsStatic(&quot;mean&quot;);
struct tagbstring SAMPLE = bsStatic(&quot;sample&quot;);
struct tagbstring DUMP = bsStatic(&quot;dump&quot;);
struct tagbstring DELETE = bsStatic(&quot;delete&quot;);
struct tagbstring OK = bsStatic(&quot;OK\n&quot;);
struct tagbstring ERR = bsStatic(&quot;ERR\n&quot;);
struct tagbstring DNE = bsStatic(&quot;DNE\n&quot;);
struct tagbstring EXISTS = bsStatic(&quot;EXISTS\n&quot;);
const char LINE_ENDING = '\n';

const int RB_SIZE = 1024 * 10;

Hashmap *DATA = NULL;

struct Command;

typedef int (*handler_cb)(struct Command *cmd, RingBuffer *send_rb);

typedef struct Command {
    bstring command;
    bstring name;
    bstring number;
    handler_cb handler;
} Command;


typedef struct Record {
    bstring name;
    Stats *stat;
} Record;

void handle_sigchild(int sig) {
    sig = 0; // ignore it
    while(waitpid(-1, NULL, WNOHANG) &gt; 0) {
    }
}

void send_reply(RingBuffer *send_rb, bstring reply)
{
    RingBuffer_puts(send_rb, reply);
}

int handle_create(Command *cmd, RingBuffer *send_rb)
{
    int rc = 0;

    // if the name is in the DATA map then return exists
    if(Hashmap_get(DATA, cmd-&gt;name)) {
        send_reply(send_rb, &amp;EXISTS);
    } else {
        // allocate a recrod
        debug(&quot;create: %s %s&quot;, bdata(cmd-&gt;name), bdata(cmd-&gt;number));

        Record *info = calloc(sizeof(Record), 1);
        check_mem(info);

        // set its stat element
        info-&gt;stat = Stats_create();
        check_mem(info-&gt;stat);

        // set its name element
        info-&gt;name = bstrcpy(cmd-&gt;name);
        check_mem(info-&gt;name);

        // do a first sample
        Stats_sample(info-&gt;stat, atof(bdata(cmd-&gt;number)));

        // add it to the hashmap
        rc = Hashmap_set(DATA, info-&gt;name, info);
        check(rc == 0, &quot;Failed to add data to map.&quot;);

        // send an OK
        send_reply(send_rb, &amp;OK);
    }

    return 0;
error:
    return -1;
}


int handle_sample(Command *cmd, RingBuffer *send_rb)
{
    // get the info from the hashmap
    Record *info = Hashmap_get(DATA, cmd-&gt;name);

    if(info == NULL) {
        // if it doesn't exist then DNE
        send_reply(send_rb, &amp;DNE);
    } else {
        // else run sample on it, return the mean
        Stats_sample(info-&gt;stat, atof(bdata(cmd-&gt;number)));
        bstring reply = bformat(&quot;%f\n&quot;, Stats_mean(info-&gt;stat));
        send_reply(send_rb, reply);
        bdestroy(reply);
    }


    return 0;
}

int handle_delete(Command *cmd, RingBuffer *send_rb)
{
    log_info(&quot;delete: %s&quot;, bdata(cmd-&gt;name));
    Record *info = Hashmap_get(DATA, cmd-&gt;name);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        Hashmap_delete(DATA, cmd-&gt;name);

        free(info-&gt;stat);
        bdestroy(info-&gt;name);
        free(info);

        send_reply(send_rb, &amp;OK);
    }

    return 0;
}

int handle_mean(Command *cmd, RingBuffer *send_rb)
{
    log_info(&quot;mean: %s&quot;, bdata(cmd-&gt;name));
    Record *info = Hashmap_get(DATA, cmd-&gt;name);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        bstring reply = bformat(&quot;%f\n&quot;, Stats_mean(info-&gt;stat));
        send_reply(send_rb, reply);
        bdestroy(reply);
    }

    return 0;
}

int handle_stddev(Command *cmd, RingBuffer *send_rb)
{
    log_info(&quot;stddev: %s&quot;, bdata(cmd-&gt;name));
    Record *info = Hashmap_get(DATA, cmd-&gt;name);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        bstring reply = bformat(&quot;%f\n&quot;, Stats_stddev(info-&gt;stat));
        send_reply(send_rb, reply);
        bdestroy(reply);
    }

    return 0;
}

int handle_dump(Command *cmd, RingBuffer *send_rb)
{
    log_info(&quot;dump: %s&quot;, bdata(cmd-&gt;name));
    Record *info = Hashmap_get(DATA, cmd-&gt;name);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        bstring reply = bformat(&quot;%f %f %f %f %ld %f %f\n&quot;,
                Stats_mean(info-&gt;stat),
                Stats_stddev(info-&gt;stat),
                info-&gt;stat-&gt;sum,
                info-&gt;stat-&gt;sumsq,
                info-&gt;stat-&gt;n,
                info-&gt;stat-&gt;min,
                info-&gt;stat-&gt;max);

        send_reply(send_rb, reply);
        bdestroy(reply);
    }

    return 0;
}

int parse_command(struct bstrList *splits, Command *cmd)
{
    // get the command
    cmd-&gt;command = splits-&gt;entry[0];

    if(biseq(cmd-&gt;command, &amp;CREATE)) {
        check(splits-&gt;qty == 3, &quot;Failed to parse create: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;number = splits-&gt;entry[2];
        cmd-&gt;handler = handle_create;
    } else if(biseq(cmd-&gt;command, &amp;MEAN)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse mean: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_mean;
    } else if(biseq(cmd-&gt;command, &amp;SAMPLE)) {
        check(splits-&gt;qty == 3, &quot;Failed to parse sample: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;number = splits-&gt;entry[2];
        cmd-&gt;handler = handle_sample;
    } else if(biseq(cmd-&gt;command, &amp;DUMP)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse dump: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_dump;
    } else if(biseq(cmd-&gt;command, &amp;DELETE)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse delete: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_delete;
    } else if(biseq(cmd-&gt;command, &amp;STDDEV)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse stddev: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_stddev;
    } else {
        sentinel(&quot;Failed to parse the command.&quot;);
    }

    return 0;
error:
    return -1;
}

int parse_line(bstring data, RingBuffer *send_rb)
{
    int rc = -1;
    Command cmd = {.command = NULL};

    // split data on line boundaries
    struct bstrList *splits = bsplits(data, &amp;LINE_SPLIT);
    check(splits != NULL, &quot;Bad data.&quot;);

    // parse it into a command
    rc = parse_command(splits, &amp;cmd);
    check(rc == 0, &quot;Failed to parse command.&quot;);

    // call the command handler for that command
    rc = cmd.handler(&amp;cmd, send_rb);

error: // fallthrough
    if(splits) bstrListDestroy(splits);
    return rc;

}

void client_handler(int client_fd)
{
    int rc = 0;
    RingBuffer *recv_rb = RingBuffer_create(RB_SIZE);
    RingBuffer *send_rb = RingBuffer_create(RB_SIZE);

    check_mem(recv_rb);
    check_mem(send_rb);

    // keep reading into the recv buffer and sending on send
    while(read_some(recv_rb, client_fd, 1) != -1) {
        // read a line from the recv_rb
        bstring data = read_line(recv_rb, LINE_ENDING);
        check(data != NULL, &quot;Client closed.&quot;);

        // parse it, close on any protocol errors
        rc = parse_line(data, send_rb);
        bdestroy(data); // cleanup here
        check(rc == 0, &quot;Failed to parse user. Closing.&quot;);

        // and as long as there's something to send, send it
        if(RingBuffer_available_data(send_rb)) {
            write_some(send_rb, client_fd, 1);
        }
    }

    // close the socket
    rc = close(client_fd);
    check(rc != -1, &quot;Failed to close the socket.&quot;);

error: // fallthrough
    if(recv_rb) RingBuffer_destroy(recv_rb);
    if(send_rb) RingBuffer_destroy(send_rb);
    exit(0); // just exit the child process
}

int setup_data_store()
{
    // a more advanced design simply wouldn't use this
    DATA = Hashmap_create(NULL, NULL);
    check_mem(DATA);

    return 0;
error:
    return -1;
}

int echo_server(const char *host, const char *port)
{
    int rc = 0;
    struct sockaddr_in client_addr;
    socklen_t sin_size = sizeof(client_addr);
    int server_socket = 0;
    int client_fd = 0;

    rc = setup_data_store();
    check(rc == 0, &quot;Failed to setup the data store.&quot;);

    struct sigaction sa = {
        .sa_handler = handle_sigchild,
        .sa_flags = SA_RESTART | SA_NOCLDSTOP
    };

    check(host != NULL, &quot;Invalid host.&quot;);
    check(port != NULL, &quot;Invalid port.&quot;);

    // create a sigaction that handles SIGCHLD
    sigemptyset(&amp;sa.sa_mask);
    rc = sigaction(SIGCHLD, &amp;sa, 0);
    check(rc != -1, &quot;Failed to setup signal handler for child processes.&quot;);

    // listen on the given port and host
    server_socket = server_listen(host, port);
    check(server_socket &gt;= 0, &quot;bind to %s:%s failed.&quot;, host, port);

    while(1) {
        // accept the connection
        client_fd = accept(server_socket, (struct sockaddr *)&amp;client_addr, &amp;sin_size); 
        check(client_fd &gt;= 0, &quot;Failed to accept connection.&quot;);

        debug(&quot;Client connected.&quot;);

        rc = fork();
        if(rc == 0) {
            // child process
            close(server_socket); // don't need this
            // handle the client
            client_handler(client_fd);
        } else {
            // server process
            close(client_fd); // don't need this
        }
    }

error:  // fallthrough
    return -1;
}

</code></pre>

<p>.\ex49b\statserve\src\statserve.h</p>

<pre><code class="language-c">#ifndef _statserve_h
#define _statserve_h

#include &lt;lcthw/bstrlib.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;

struct tagbstring OK;

int setup_data_store();

int parse_line(bstring data, RingBuffer *send_rb);

int echo_server(const char *host, const char *port);

#endif

</code></pre>

<p>.\ex49b\statserve\tests\statserve_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;dlfcn.h&gt;
#include &quot;statserve.h&quot;
#include &lt;lcthw/bstrlib.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;assert.h&gt;

typedef struct LineTest {
    char *line;
    bstring result;
    char *description;
} LineTest;

int attempt_line(LineTest test)
{
    int rc = -1;
    bstring result = NULL;

    bstring line = bfromcstr(test.line);
    RingBuffer *send_rb = RingBuffer_create(1024);

    rc = parse_line(line, send_rb);
    check(rc == 0, &quot;Failed to parse line.&quot;);

    result = RingBuffer_get_all(send_rb);
    check(result != NULL, &quot;Ring buffer empty.&quot;);
    check(biseq(result, test.result), &quot;Got the wrong output: %s expected %s&quot;,
            bdata(result), bdata(test.result));

    bdestroy(line);
    RingBuffer_destroy(send_rb);
    return 1; // using 1 for tests
error:
  
    log_err(&quot;Failed to process test %s: got %s&quot;, test.line, bdata(result));
    if(line) bdestroy(line);
    if(send_rb) RingBuffer_destroy(send_rb);
    return 0;
}


int run_test_lines(LineTest *tests, int count)
{
    int i = 0;

    for(i = 0; i &lt; count; i++) {
        check(attempt_line(tests[i]), &quot;Failed to run %s&quot;, tests[i].description);
    }

    return 1;
error:
    return 0;
}

char *test_create()
{
    LineTest tests[] = {
        {.line = &quot;create /zed 100&quot;, .result = &amp;OK, .description = &quot;create zed failed&quot;},
        {.line = &quot;create /joe 100&quot;, .result = &amp;OK, .description = &quot;create joe failed&quot;},

    };

    mu_assert(run_test_lines(tests, 2), &quot;Failed to run create tests.&quot;);

    return NULL;
}

char *test_sample()
{
    struct tagbstring sample1 = bsStatic(&quot;100.000000\n&quot;);

    LineTest tests[] = {
        {.line = &quot;sample /zed 100&quot;, .result = &amp;sample1, .description = &quot;sample zed failed.&quot;}
    };

    mu_assert(run_test_lines(tests, 1), &quot;Failed to run sample tests.&quot;);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    int rc = setup_data_store();
    mu_assert(rc == 0, &quot;Failed to setup the data store.&quot;);

    mu_run_test(test_create);
    mu_run_test(test_sample);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>Solution</p>

<p>The Plan</p>

<p>I&rsquo;ll show you how I implemented the protocol in the smallest code possible.</p>

<p>I won&rsquo;t implement all of the CRUD operations, so you can go look at the
git repo for this project to see a full implementation.</p>

<p>The Setup</p>

<p>First I setup the data, then the protocol parser, then the handlers.</p>

<p>The Protocol</p>

<pre><code>create Create a new statistic.
mean   Get the current mean of a statistic.
sample Add a new sample to a statistics.
dump   Get all of the elements of a statistic (sum, sumsq, n, min, and max).Final Code
</code></pre>

<p>The Command Structure</p>

<pre><code>typedef struct Command {
    bstring command;
    bstring name;
    bstring number;
    handler_cb handler;
} Command;
</code></pre>

<p>The Storage Record</p>

<pre><code>typedef struct Record {
    bstring name;
    Stats *stat;
} Record;
</code></pre>

<p>The Design</p>

<ul>
<li>Accept a connection</li>
<li>Parse the line into the Command</li>
<li>Run a handler function to process it</li>
<li>Temporarily store into a Hashmap</li>
</ul>

<p>Final Thoughts</p>

<p>The last thing I would do is add better tests and round out the protocol with CRUD operations.</p>

<h2 id="exercise-50a-routing-the-statistics">Exercise 50a Routing The Statistics</h2>

<p>Project Description</p>

<p>The Plan</p>

<p>You are now given vague instructions and have to &ldquo;solve&rdquo; as best you can.</p>

<p>The Purpose</p>

<p>To give you freedom to be creative, and also taste a real project with vague
specifications.</p>

<p>Many times all you get is a single sentence in a bug tracker. Oh well.</p>

<p>The Requirements</p>

<p>Allow people to work with statistics at arbitrary URLs in the server.
You get to define what that means, but think &ldquo;web application&rdquo;.</p>

<p>Pause!</p>

<p>Try to solve it on your own then continue.</p>

<p>The Clues</p>

<p>Answer these questions:</p>

<ol>
<li>What happens when I have a statistics &ldquo;under&rdquo; another, as in /age/northamerica/ is under /age/.</li>
<li>Could you do the summary statistics we talked about?  A mean of means and mean of standard deviations that are rolled up the tree?</li>
<li>What data structures do you need?  Starting with data is key here too. Data data data.</li>
<li>Are your tests good enough?  Before you start you might want to get good tests that use the protocol.</li>
</ol>

<p>Important References</p>

<ul>
<li>Definitely look at the statistics code you built in liblcthw if you do the summary statistics.</li>
</ul>

<p>Encouragement</p>

<p>This is hard, as I&rsquo;ve said all along, however it is all doable. It&rsquo;s simply a matter of breaking the problems down and tackling each little piece.</p>

<h2 id="exercise-50b-routing-the-statistics">Exercise 50b Routing the Statistics</h2>

<p>Solution</p>

<p>The Plan</p>

<p>Show you how I solved the problem of routing the names of statistics as URLs.</p>

<p>The Setup</p>

<ol>
<li>First thing I did was make sure my tests were really good.</li>
<li>Then I designed the data structures I&rsquo;d need.</li>
<li>Then I did the work to make them functions.</li>
<li>The protocol shouldn&rsquo;t need to change.</li>
</ol>

<p>&ldquo;URLs&rdquo;</p>

<p>I&rsquo;ll define paths as simply names separated by /.</p>

<p>Real URLs are way more complex than that.</p>

<p>Data Structure</p>

<p>I just added:</p>

<pre><code>struct bstrList *path;
</code></pre>

<p>To the Command struct to hold paths.</p>

<p>URL Meaning</p>

<p>Kind of weird, but:</p>

<pre><code>Deepest part of URL is &quot;parent&quot;, this is the main stat.
Children are next segments up, and are mean-of-mean stats.
</code></pre>

<p>New Processing</p>

<ol>
<li>Change to a loop over all paths with a &ldquo;scan path&rdquo; function.</li>
<li>Add optional path parameter to handlers.</li>
<li>Parse the path in <em>parse_command</em> to set path in Commands.</li>
<li>In sample and create, change root processing vs. child processing.</li>
<li>Move <em>send_reply</em> over to <em>net.c</em> instead.</li>
</ol>

<p>Test First Path Parsing</p>

<p>I&rsquo;ll write a small test for just the <em>scan_paths</em> part first.</p>

<p>Then wire that in and use the existing tests to confirm the old code
works.</p>

<p>The Code</p>

<p>.\ex50b\statserve</p>

<p>.\ex50b\statserve\bin\statserve.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &quot;statserve.h&quot;
#include &quot;net.h&quot;


int main(int argc, char *argv[])
{
    check(argc == 3, &quot;USAGE: statserve host port&quot;);

    const char *host = argv[1];
    const char *port = argv[2];

    check(echo_server(host, port), &quot;Failed to run the echo server.&quot;);

    return 0;

error:
    
    return 1;
}

</code></pre>

<p>.\ex50b\statserve\src\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex50b\statserve\src\net.c</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;stdio.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &quot;net.h&quot;

struct tagbstring NL = bsStatic(&quot;\n&quot;);
struct tagbstring CRLF = bsStatic(&quot;\r\n&quot;);

int nonblock(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    check(flags &gt;= 0, &quot;Invalid flags on nonblock.&quot;);

    int rc = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    return 0;
error:
    return -1;
}

int client_connect(char *host, char *port)
{
    int rc = 0;
    struct addrinfo *addr = NULL;

    rc = getaddrinfo(host, port, NULL, &amp;addr);
    check(rc == 0, &quot;Failed to lookup %s:%s&quot;, host, port);

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    check(sock &gt;= 0, &quot;Cannot create a socket.&quot;);

    rc = connect(sock, addr-&gt;ai_addr, addr-&gt;ai_addrlen);
    check(rc == 0, &quot;Connect failed.&quot;);

    rc = nonblock(sock);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    freeaddrinfo(addr);
    return sock;

error:
    freeaddrinfo(addr);
    return -1;
}

int read_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;

    if (RingBuffer_available_data(buffer) == 0) {
        buffer-&gt;start = buffer-&gt;end = 0;
    }

    if (is_socket) {
        rc = recv(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer), 0);
    } else {
        rc = read(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer));
    }

    check(rc &gt;= 0, &quot;Failed to read from fd: %d&quot;, fd);

    RingBuffer_commit_write(buffer, rc);

    return rc;

error:
    return -1;
}

int write_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;
    bstring data = RingBuffer_get_all(buffer);

    check(data != NULL, &quot;Failed to get from the buffer.&quot;);
    check(bfindreplace(data, &amp;NL, &amp;CRLF, 0) == BSTR_OK,
            &quot;Failed to replace NL.&quot;);

    if (is_socket) {
        rc = send(fd, bdata(data), blength(data), 0);
    } else {
        rc = write(fd, bdata(data), blength(data));
    }

    check(rc == blength(data), &quot;Failed to write everything to fd: %d.&quot;,
            fd);
    bdestroy(data);

    return rc;

error:
    return -1;
}

int attempt_listen(struct addrinfo *info)
{
    int sockfd = -1; // default fail
    int rc = -1;
    int yes = 1;

    check(info != NULL, &quot;Invalid addrinfo.&quot;);

    // create a socket with the addrinfo
    sockfd = socket(info-&gt;ai_family, info-&gt;ai_socktype,
            info-&gt;ai_protocol);
    check_debug(sockfd != -1, &quot;Failed to bind to address. Trying more.&quot;);

    // set the SO_REUSEADDR option on the socket
    rc = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));
    check_debug(rc == 0, &quot;Failed to set SO_REUSADDR.&quot;);

    // attempt to bind to it
    rc = bind(sockfd, info-&gt;ai_addr, info-&gt;ai_addrlen);
    check_debug(rc == 0, &quot;Failed to find socket.&quot;);

    // finally listen with a backlog
    rc = listen(sockfd, BACKLOG);
    check_debug(rc == 0, &quot;Failed to listen to socket.&quot;);

    return sockfd;

error:
    return -1;
}


int server_listen(const char *host, const char *port)
{
    int rc = 0;
    int sockfd = -1; // default fail value
    struct addrinfo *info = NULL;
    struct addrinfo *next_p = NULL;
    struct addrinfo addr = {
        .ai_family = AF_UNSPEC,
        .ai_socktype = SOCK_STREAM,
        .ai_flags = AI_PASSIVE
    };

    check(host != NULL, &quot;Invalid host.&quot;);
    check(port != NULL, &quot;Invalid port.&quot;);

    // get the address info for host and port
    rc = getaddrinfo(NULL, port, &amp;addr, &amp;info);
    check(rc == 0, &quot;Failed to get address info for connect.&quot;);

    // cycle through the available list to find one
    for(next_p = info; next_p != NULL; next_p = next_p-&gt;ai_next)
    {
        // attempt to listen to each one
        sockfd = attempt_listen(next_p);
        if(sockfd != -1) break;
    }

    // either we found one and were able to listen or nothing.
    check(sockfd != -1, &quot;All possible addresses failed.&quot;);

error: //fallthrough
    if(info) freeaddrinfo(info);
    // this gets set by the above to either -1 or valid
    return sockfd;
}

bstring read_line(RingBuffer *input, const char line_ending)
{
    int i = 0;
    bstring result = NULL;

    // not super efficient
    // read a character at a time from the ring buffer
    for(i = 0; i &lt; RingBuffer_available_data(input); i++) {
        // if the buffer has line ending
        if(input-&gt;buffer[i] == line_ending) {
            // get that much fromt he ring buffer
            result = RingBuffer_gets(input, i);
            check(result, &quot;Failed to get line from RingBuffer&quot;);
            // make sure that we got the right amount
            check(RingBuffer_available_data(input) &gt;= 1, 
                    &quot;Not enough data in the RingBuffer after reading line.&quot;);
            // and commit it
            RingBuffer_commit_read(input, 1);
            break;
        }
    }

    // notice this will fail in the cases where we get a set of data
    // on the wire that does not have a line ending yet
    return result;
error:
    return NULL;
}


void send_reply(RingBuffer *send_rb, bstring reply)
{
    RingBuffer_puts(send_rb, reply);
}

</code></pre>

<p>.\ex50b\statserve\src\net.h</p>

<pre><code class="language-c">#ifndef _net_h
#define _net_h

#include &lt;lcthw/ringbuffer.h&gt;

#define BACKLOG 10

int nonblock(int fd);
int client_connect(char *host, char *port);
int read_some(RingBuffer * buffer, int fd, int is_socket);
int write_some(RingBuffer * buffer, int fd, int is_socket);
int server_listen(const char *host, const char *port);
bstring read_line(RingBuffer *input, const char line_ending);
void send_reply(RingBuffer *send_rb, bstring reply);


#endif

</code></pre>

<p>.\ex50b\statserve\src\statserve.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;lcthw/hashmap.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &quot;net.h&quot;
#include &lt;netdb.h&gt;
#include &quot;statserve.h&quot;

struct tagbstring LINE_SPLIT = bsStatic(&quot; &quot;);
struct tagbstring CREATE = bsStatic(&quot;create&quot;);
struct tagbstring STDDEV = bsStatic(&quot;stddev&quot;);
struct tagbstring MEAN = bsStatic(&quot;mean&quot;);
struct tagbstring SAMPLE = bsStatic(&quot;sample&quot;);
struct tagbstring DUMP = bsStatic(&quot;dump&quot;);
struct tagbstring DELETE = bsStatic(&quot;delete&quot;);
struct tagbstring OK = bsStatic(&quot;OK\n&quot;);
struct tagbstring ERR = bsStatic(&quot;ERR\n&quot;);
struct tagbstring DNE = bsStatic(&quot;DNE\n&quot;);
struct tagbstring EXISTS = bsStatic(&quot;EXISTS\n&quot;);
struct tagbstring SLASH = bsStatic(&quot;/&quot;);
const char LINE_ENDING = '\n';

const int RB_SIZE = 1024 * 10;

Hashmap *DATA = NULL;

void handle_sigchild(int sig) {
    sig = 0; // ignore it
    while(waitpid(-1, NULL, WNOHANG) &gt; 0) {
    }
}


int handle_create(Command *cmd, RingBuffer *send_rb, bstring path)
{
    int rc = 0;
    int is_root = biseq(path, cmd-&gt;name);
    log_info(&quot;create: %s %s %s&quot;, bdata(cmd-&gt;name), bdata(path), bdata(cmd-&gt;number));

    Record *info = Hashmap_get(DATA, path);

    if(info != NULL &amp;&amp; is_root) {
        // report if root exists, just skip children
        send_reply(send_rb, &amp;EXISTS);
    } else if(info != NULL) {
        debug(&quot;Child %s exists, skipping it.&quot;, bdata(path));
        return 0;
    } else {
        // new child so make it
        debug(&quot;create: %s %s&quot;, bdata(path), bdata(cmd-&gt;number));

        Record *info = calloc(sizeof(Record), 1);
        check_mem(info);

        // set its stat element
        info-&gt;stat = Stats_create();
        check_mem(info-&gt;stat);

        // set its name element
        info-&gt;name = bstrcpy(path);
        check_mem(info-&gt;name);

        // do a first sample
        Stats_sample(info-&gt;stat, atof(bdata(cmd-&gt;number)));

        // add it to the hashmap
        rc = Hashmap_set(DATA, info-&gt;name, info);
        check(rc == 0, &quot;Failed to add data to map.&quot;);

        // only send the for the root part
        if(is_root) {
            send_reply(send_rb, &amp;OK);
        }
    }

    return 0;
error:
    return -1;
}


int handle_sample(Command *cmd, RingBuffer *send_rb, bstring path)
{
    // get the info from the hashmap
    Record *info = Hashmap_get(DATA, path);
    int is_root = biseq(path, cmd-&gt;name);
    log_info(&quot;sample %s %s %s&quot;, bdata(cmd-&gt;name), bdata(path), bdata(cmd-&gt;number));
    bstring child_path = NULL;

    if(info == NULL) {
        // if it doesn't exist then DNE
        send_reply(send_rb, &amp;DNE);
        return 0;
    } else {
        if(is_root) {
            // just sample the root like normal
            Stats_sample(info-&gt;stat, atof(bdata(cmd-&gt;number)));
        } else {
            // need to do some hackery to get the child path
            // for rolling up mean-of-means on it

            // increase the qty on path up one
            cmd-&gt;path-&gt;qty++;
            // get the &quot;child path&quot; (previous path?)
            child_path = bjoin(cmd-&gt;path, &amp;SLASH);
            // get that info from the DATA
            Record *child_info = Hashmap_get(DATA, child_path);
            bdestroy(child_path);

            // if it exists then sample on it
            if(child_info) {
                // info is /logins, child_info is /logins/zed 
                // we want /logins/zed's mean to be a new sample on /logins
                Stats_sample(info-&gt;stat, Stats_mean(child_info-&gt;stat));
            }
            // drop the path back to where it was
            cmd-&gt;path-&gt;qty--;
        }

    }

    // do the reply for the mean last
    bstring reply = bformat(&quot;%f\n&quot;, Stats_mean(info-&gt;stat));
    send_reply(send_rb, reply);
    bdestroy(reply);

    return 0;
}

int handle_delete(Command *cmd, RingBuffer *send_rb, bstring path)
{
    log_info(&quot;delete: %s %s&quot;, bdata(cmd-&gt;name), bdata(path));
    Record *info = Hashmap_get(DATA, path);
    int is_root = biseq(path, cmd-&gt;name);

    // BUG: should just decide that this isn't scanned 
    // but run once, for now just only run on root
    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else if(is_root) {
        Hashmap_delete(DATA, path);

        free(info-&gt;stat);
        bdestroy(info-&gt;name);
        free(info);

        send_reply(send_rb, &amp;OK);
    }

    return 0;
}

int handle_mean(Command *cmd, RingBuffer *send_rb, bstring path)
{
    log_info(&quot;mean: %s %s %s&quot;, bdata(cmd-&gt;name), bdata(path), bdata(path));
    Record *info = Hashmap_get(DATA, path);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        bstring reply = bformat(&quot;%f\n&quot;, Stats_mean(info-&gt;stat));
        send_reply(send_rb, reply);
        bdestroy(reply);
    }

    return 0;
}

int handle_stddev(Command *cmd, RingBuffer *send_rb, bstring path)
{
    log_info(&quot;stddev: %s %s %s&quot;, bdata(cmd-&gt;name), bdata(path), bdata(path));
    Record *info = Hashmap_get(DATA, path);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        bstring reply = bformat(&quot;%f\n&quot;, Stats_stddev(info-&gt;stat));
        send_reply(send_rb, reply);
        bdestroy(reply);
    }

    return 0;
}

int handle_dump(Command *cmd, RingBuffer *send_rb, bstring path)
{
    log_info(&quot;dump: %s, %s, %s&quot;, bdata(cmd-&gt;name), bdata(path), bdata(path));
    Record *info = Hashmap_get(DATA, path);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        bstring reply = bformat(&quot;%f %f %f %f %ld %f %f\n&quot;,
                Stats_mean(info-&gt;stat),
                Stats_stddev(info-&gt;stat),
                info-&gt;stat-&gt;sum,
                info-&gt;stat-&gt;sumsq,
                info-&gt;stat-&gt;n,
                info-&gt;stat-&gt;min,
                info-&gt;stat-&gt;max);

        send_reply(send_rb, reply);
        bdestroy(reply);
    }

    return 0;
}

int parse_command(struct bstrList *splits, Command *cmd)
{
    // get the command
    cmd-&gt;command = splits-&gt;entry[0];

    if(biseq(cmd-&gt;command, &amp;CREATE)) {
        check(splits-&gt;qty == 3, &quot;Failed to parse create: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;number = splits-&gt;entry[2];
        cmd-&gt;handler = handle_create;
    } else if(biseq(cmd-&gt;command, &amp;MEAN)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse mean: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_mean;
    } else if(biseq(cmd-&gt;command, &amp;SAMPLE)) {
        check(splits-&gt;qty == 3, &quot;Failed to parse sample: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;number = splits-&gt;entry[2];
        cmd-&gt;handler = handle_sample;
    } else if(biseq(cmd-&gt;command, &amp;DUMP)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse dump: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_dump;
    } else if(biseq(cmd-&gt;command, &amp;DELETE)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse delete: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_delete;
    } else if(biseq(cmd-&gt;command, &amp;STDDEV)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse stddev: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_stddev;
    } else {
        sentinel(&quot;Failed to parse the command.&quot;);
    }

    return 0;
error:
    return -1;
}

int scan_paths(Command *cmd, RingBuffer *send_rb)
{
    check(cmd-&gt;path != NULL, &quot;Path was not set in command.&quot;);

    int rc = 0;
    // save the original path length
    size_t qty = cmd-&gt;path-&gt;qty;

    // starting at the longest path, shorten it and call
    // for each one:
    for(; cmd-&gt;path-&gt;qty &gt; 1; cmd-&gt;path-&gt;qty--) {
        // remake the path with / again
        bstring path = bjoin(cmd-&gt;path, &amp;SLASH);
        // call the handler with the path
        rc = cmd-&gt;handler(cmd, send_rb, path);
        // if the handler returns != 0 then abort and return that
        bdestroy(path);

        if(rc != 0) break;
    }

    // restore path length
    cmd-&gt;path-&gt;qty = qty;
    return rc;
error:
    return -1;
}

struct bstrList *parse_name(bstring name)
{
    return bsplits(name, &amp;SLASH);
}

int parse_line(bstring data, RingBuffer *send_rb)
{
    int rc = -1;
    Command cmd = {.command = NULL};

    // split data on line boundaries
    struct bstrList *splits = bsplits(data, &amp;LINE_SPLIT);
    check(splits != NULL, &quot;Bad data.&quot;);

    // parse it into a command
    rc = parse_command(splits, &amp;cmd);
    check(rc == 0, &quot;Failed to parse command.&quot;);

    // parse the name into the path we need for scan_paths
    cmd.path = parse_name(cmd.name);
    check(cmd.path != NULL, &quot;Invalid path.&quot;);

    // scan the path and call the handlers
    rc = scan_paths(&amp;cmd, send_rb);
    check(rc == 0, &quot;Failure running command against path: %s&quot;, bdata(cmd.name));

    bstrListDestroy(cmd.path);
    bstrListDestroy(splits);

    return 0;

error: // fallthrough
    if(cmd.path) bstrListDestroy(cmd.path);
    if(splits) bstrListDestroy(splits);
    return -1;
}

void client_handler(int client_fd)
{
    int rc = 0;
    RingBuffer *recv_rb = RingBuffer_create(RB_SIZE);
    RingBuffer *send_rb = RingBuffer_create(RB_SIZE);

    check_mem(recv_rb);
    check_mem(send_rb);

    // keep reading into the recv buffer and sending on send
    while(read_some(recv_rb, client_fd, 1) != -1) {
        // read a line from the recv_rb
        bstring data = read_line(recv_rb, LINE_ENDING);
        check(data != NULL, &quot;Client closed.&quot;);

        // parse it, close on any protocol errors
        rc = parse_line(data, send_rb);
        bdestroy(data); // cleanup here
        check(rc == 0, &quot;Failed to parse user. Closing.&quot;);

        // and as long as there's something to send, send it
        if(RingBuffer_available_data(send_rb)) {
            write_some(send_rb, client_fd, 1);
        }
    }

    // close the socket
    rc = close(client_fd);
    check(rc != -1, &quot;Failed to close the socket.&quot;);

error: // fallthrough
    if(recv_rb) RingBuffer_destroy(recv_rb);
    if(send_rb) RingBuffer_destroy(send_rb);
    exit(0); // just exit the child process
}

int setup_data_store()
{
    // a more advanced design simply wouldn't use this
    DATA = Hashmap_create(NULL, NULL);
    check_mem(DATA);

    return 0;
error:
    return -1;
}

int echo_server(const char *host, const char *port)
{
    int rc = 0;
    struct sockaddr_in client_addr;
    socklen_t sin_size = sizeof(client_addr);
    int server_socket = 0;
    int client_fd = 0;

    rc = setup_data_store();
    check(rc == 0, &quot;Failed to setup the data store.&quot;);

    struct sigaction sa = {
        .sa_handler = handle_sigchild,
        .sa_flags = SA_RESTART | SA_NOCLDSTOP
    };

    check(host != NULL, &quot;Invalid host.&quot;);
    check(port != NULL, &quot;Invalid port.&quot;);

    // create a sigaction that handles SIGCHLD
    sigemptyset(&amp;sa.sa_mask);
    rc = sigaction(SIGCHLD, &amp;sa, 0);
    check(rc != -1, &quot;Failed to setup signal handler for child processes.&quot;);

    // listen on the given port and host
    server_socket = server_listen(host, port);
    check(server_socket &gt;= 0, &quot;bind to %s:%s failed.&quot;, host, port);

    while(1) {
        // accept the connection
        client_fd = accept(server_socket, (struct sockaddr *)&amp;client_addr, &amp;sin_size); 
        check(client_fd &gt;= 0, &quot;Failed to accept connection.&quot;);

        debug(&quot;Client connected.&quot;);

        rc = fork();
        if(rc == 0) {
            // child process
            close(server_socket); // don't need this
            // handle the client
            client_handler(client_fd);
        } else {
            // server process
            close(client_fd); // don't need this
        }
    }

error:  // fallthrough
    return -1;
}

</code></pre>

<p>.\ex50b\statserve\src\statserve.h</p>

<pre><code class="language-c">#ifndef _statserve_h
#define _statserve_h

#include &lt;lcthw/bstrlib.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;lcthw/stats.h&gt;

struct Command;

typedef int (*handler_cb)(struct Command *cmd, RingBuffer *send_rb, bstring path);

typedef struct Command {
    bstring command;
    bstring name;
    struct bstrList *path;
    bstring number;
    handler_cb handler;
} Command;


typedef struct Record {
    bstring name;
    Stats *stat;
} Record;

struct tagbstring OK;

int setup_data_store();

struct bstrList *parse_name(bstring name);

int scan_paths(Command *cmd, RingBuffer *send_rb);

int parse_line(bstring data, RingBuffer *send_rb);

int echo_server(const char *host, const char *port);

#endif

</code></pre>

<p>.\ex50b\statserve\tests\statserve_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;dlfcn.h&gt;
#include &quot;statserve.h&quot;
#include &lt;lcthw/bstrlib.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;assert.h&gt;

typedef struct LineTest {
    char *line;
    bstring result;
    char *description;
} LineTest;

int attempt_line(LineTest test)
{
    int rc = -1;
    bstring result = NULL;

    bstring line = bfromcstr(test.line);
    RingBuffer *send_rb = RingBuffer_create(1024);

    rc = parse_line(line, send_rb);
    check(rc == 0, &quot;Failed to parse line.&quot;);

    result = RingBuffer_get_all(send_rb);
    check(result != NULL, &quot;Ring buffer empty.&quot;);
    check(biseq(result, test.result), &quot;Got the wrong output: %s expected %s&quot;,
            bdata(result), bdata(test.result));

    bdestroy(line);
    RingBuffer_destroy(send_rb);
    return 1; // using 1 for tests
error:
  
    log_err(&quot;Failed to process test %s: got %s&quot;, test.line, bdata(result));
    if(line) bdestroy(line);
    if(send_rb) RingBuffer_destroy(send_rb);
    return 0;
}


int run_test_lines(LineTest *tests, int count)
{
    int i = 0;

    for(i = 0; i &lt; count; i++) {
        check(attempt_line(tests[i]), &quot;Failed to run %s&quot;, tests[i].description);
    }

    return 1;
error:
    return 0;
}

int fake_command(Command *cmd, RingBuffer *send_rb, bstring path)
{
    check(cmd != NULL, &quot;Bad cmd.&quot;);
    check(cmd-&gt;path != NULL, &quot;Bad path.&quot;);
    check(send_rb != NULL, &quot;Bad send_rb.&quot;);
    check(path != NULL, &quot;Bad path given.&quot;);

    return 0;
error:
    return -1;
}

char *test_path_parsing()
{
    struct bstrList *result = NULL;
    struct tagbstring slash = bsStatic(&quot;/&quot;);
    struct tagbstring logins_zed = bsStatic(&quot;/logins/zed&quot;);
    struct tagbstring command_name = bsStatic(&quot;dump&quot;);
    RingBuffer *send_rb = RingBuffer_create(1024);
    struct bstrList *path = bsplits(&amp;logins_zed, &amp;slash);
    int rc = 0;

    Command fake = {
        .command = &amp;command_name,
        .name = &amp;logins_zed,
        .number = NULL,
        .handler = fake_command,
        .path = path
    };

    result = parse_name(&amp;logins_zed);
    mu_assert(result != NULL, &quot;Failed to parse /logins/zed&quot;);

    rc = scan_paths(&amp;fake, send_rb); 
    mu_assert(rc != -1, &quot;scan_paths failed.&quot;);

    return NULL;
}

char *test_create()
{
    LineTest tests[] = {
        {.line = &quot;create /zed 100&quot;, .result = &amp;OK, .description = &quot;create zed failed&quot;},
        {.line = &quot;create /joe 100&quot;, .result = &amp;OK, .description = &quot;create joe failed&quot;},

    };

    mu_assert(run_test_lines(tests, 2), &quot;Failed to run create tests.&quot;);

    return NULL;
}

char *test_sample()
{
    struct tagbstring sample1 = bsStatic(&quot;100.000000\n&quot;);

    LineTest tests[] = {
        {.line = &quot;sample /zed 100&quot;, .result = &amp;sample1, .description = &quot;sample zed failed.&quot;}
    };

    mu_assert(run_test_lines(tests, 1), &quot;Failed to run sample tests.&quot;);

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    int rc = setup_data_store();
    mu_assert(rc == 0, &quot;Failed to setup the data store.&quot;);

    mu_run_test(test_create);
    mu_run_test(test_sample);
    mu_run_test(test_path_parsing);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>Final Review</p>

<h2 id="exercise-51a-storing-the-statistics">Exercise 51a Storing the Statistics</h2>

<p>Project Description</p>

<p>The Plan</p>

<p>Learn to store the statistics to the hard disk.</p>

<p>There are meany issues with this.</p>

<p>The Purpose</p>

<p>To teach you about various problems related to securely storing files.</p>

<p>The Requirements</p>

<p>For this exercise, you&rsquo;ll add two commands for storing to and loading statistics
from a hard drive:</p>

<p>store
    If there&rsquo;s a URL, store it to a hard drive.</p>

<p>load
    If there are two URLs, load the statistic from the hard drive based on the first URL, and then put it into the second URL that&rsquo;s in memory.</p>

<p>The Requirements</p>

<ol>
<li>If URLs have <code>/</code> characters in them, then that conflicts with the filesystem&rsquo;s use of slashes.  How will you solve this?</li>
<li>If URLs have <code>/</code> characters in them, then someone can use your server to overwrite files on a hard drive by giving paths to them.  How will you solve this?</li>
<li>If you choose to use deeply nested directories, then traversing directories to find files will be very slow.  What will you do here?</li>
</ol>

<p>The Requirements</p>

<ol>
<li>If you choose to use one directory and hash URLs (oops, I gave a hint), then directories with too many files in them are slow.  How will you solve this?</li>
<li>What happens when someone loads a statistic from a hard drive into a URL that already exists?</li>
<li>How will someone running <code>statserve</code> know where the storage should be?</li>
</ol>

<p>The Clues</p>

<p>There are no clues.  You can do this.</p>

<h2 id="exercise-51b-storing-the-statistics">Exercise 51b Storing the Statistics</h2>

<p>Solution</p>

<p>The Plan</p>

<p>Show you how I solved the problem of storing the statistics to disk.</p>

<p>Security Requirements</p>

<ul>
<li>Use <em>realpath</em> to make sure that paths are in one place.</li>
<li>Use <em>BAD</em> encryption to mangle the stored names.</li>
<li>No other security beyond that. Just a demo of the path issue.</li>
</ul>

<p>XTEA Encryption</p>

<ul>
<li>For an extra challenge I decided to &ldquo;hash&rdquo; names with XTEA.</li>
<li><a href="https://en.wikipedia.org/wiki/XTEA">https://en.wikipedia.org/wiki/XTEA</a> for the code.</li>
<li>Normally I wouldn&rsquo;t do this, but wanted to show you XTEA.</li>
<li>Because XTEA if cool and fun, although broken.</li>
<li>DON&rsquo;T USE XTEA FOR ENCRYPTION.</li>
</ul>

<p>Improvements</p>

<ul>
<li>Let commands set cmd-&gt;path = NULL to indicate non-recursive.</li>
<li>Change <em>echo_server</em> to <em>run_server</em> finally.</li>
<li>Allow a 3rd storage path argument on the command line.</li>
<li>Allow an additional argument to Command.</li>
</ul>

<p>Weirdness</p>

<ul>
<li>Forking means I can&rsquo;t share data between clients without storage.</li>
<li>Storing doesn&rsquo;t happen automatically, only explicitly.</li>
<li>Loading acts as a copy command.</li>
<li>XTEA isn&rsquo;t the best algorithm at all.  Just for fun.</li>
</ul>

<p>How I Did It</p>

<ol>
<li>Create the LOAD and STORE handlers.</li>
<li>Add Command.arg and set those in <em>parse_command</em>.</li>
<li>Move path parsing up to allow non-recursive handling with path = NULL.</li>
<li>Write a <em>sanitize_location</em> and <em>encrypt_armor_name</em> function, test them.</li>
<li>Write <em>handle_store</em> first to allow testing <em>handle_load</em>.</li>
<li>Use <em>open</em> (man 2 open) with O_EXLOCK to get exclusive locks on files.</li>
<li>Using <em>close</em> (man 2 close) should release EXLOCK, but not clear on this.</li>
</ol>

<p>The Code</p>

<p>.\ex51b\statserve</p>

<p>.\ex51b\statserve\bin\statserve.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &quot;statserve.h&quot;
#include &quot;net.h&quot;


int main(int argc, char *argv[])
{
    check(argc == 4, &quot;USAGE: statserve host port store_path&quot;);

    const char *host = argv[1];
    const char *port = argv[2];
    const char *store_path = argv[3];

    check(run_server(host, port, store_path), &quot;Failed to run the echo server.&quot;);

    return 0;

error:
    
    return 1;
}

</code></pre>

<p>.\ex51b\statserve\src\dbg.h</p>

<pre><code class="language-c">#ifndef __dbg_h__
#define __dbg_h__

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))

#define log_err(M, ...) fprintf(stderr,\
        &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\n&quot;, __FILE__, __LINE__,\
        clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr,\
        &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\n&quot;,\
        __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) {\
    log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#define check_mem(A) check((A), &quot;Out of memory.&quot;)

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__);\
    errno=0; goto error; }

#endif

</code></pre>

<p>.\ex51b\statserve\src\net.c</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;stdio.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &quot;net.h&quot;

struct tagbstring NL = bsStatic(&quot;\n&quot;);
struct tagbstring CRLF = bsStatic(&quot;\r\n&quot;);

int nonblock(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    check(flags &gt;= 0, &quot;Invalid flags on nonblock.&quot;);

    int rc = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    return 0;
error:
    return -1;
}

int client_connect(char *host, char *port)
{
    int rc = 0;
    struct addrinfo *addr = NULL;

    rc = getaddrinfo(host, port, NULL, &amp;addr);
    check(rc == 0, &quot;Failed to lookup %s:%s&quot;, host, port);

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    check(sock &gt;= 0, &quot;Cannot create a socket.&quot;);

    rc = connect(sock, addr-&gt;ai_addr, addr-&gt;ai_addrlen);
    check(rc == 0, &quot;Connect failed.&quot;);

    rc = nonblock(sock);
    check(rc == 0, &quot;Can't set nonblocking.&quot;);

    freeaddrinfo(addr);
    return sock;

error:
    freeaddrinfo(addr);
    return -1;
}

int read_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;

    if (RingBuffer_available_data(buffer) == 0) {
        buffer-&gt;start = buffer-&gt;end = 0;
    }

    if (is_socket) {
        rc = recv(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer), 0);
    } else {
        rc = read(fd, RingBuffer_starts_at(buffer),
                RingBuffer_available_space(buffer));
    }

    check(rc &gt;= 0, &quot;Failed to read from fd: %d&quot;, fd);

    RingBuffer_commit_write(buffer, rc);

    return rc;

error:
    return -1;
}

int write_some(RingBuffer * buffer, int fd, int is_socket)
{
    int rc = 0;
    bstring data = RingBuffer_get_all(buffer);

    check(data != NULL, &quot;Failed to get from the buffer.&quot;);
    check(bfindreplace(data, &amp;NL, &amp;CRLF, 0) == BSTR_OK,
            &quot;Failed to replace NL.&quot;);

    if (is_socket) {
        rc = send(fd, bdata(data), blength(data), 0);
    } else {
        rc = write(fd, bdata(data), blength(data));
    }

    check(rc == blength(data), &quot;Failed to write everything to fd: %d.&quot;,
            fd);
    bdestroy(data);

    return rc;

error:
    return -1;
}

int attempt_listen(struct addrinfo *info)
{
    int sockfd = -1; // default fail
    int rc = -1;
    int yes = 1;

    check(info != NULL, &quot;Invalid addrinfo.&quot;);

    // create a socket with the addrinfo
    sockfd = socket(info-&gt;ai_family, info-&gt;ai_socktype,
            info-&gt;ai_protocol);
    check_debug(sockfd != -1, &quot;Failed to bind to address. Trying more.&quot;);

    // set the SO_REUSEADDR option on the socket
    rc = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));
    check_debug(rc == 0, &quot;Failed to set SO_REUSADDR.&quot;);

    // attempt to bind to it
    rc = bind(sockfd, info-&gt;ai_addr, info-&gt;ai_addrlen);
    check_debug(rc == 0, &quot;Failed to find socket.&quot;);

    // finally listen with a backlog
    rc = listen(sockfd, BACKLOG);
    check_debug(rc == 0, &quot;Failed to listen to socket.&quot;);

    return sockfd;

error:
    return -1;
}


int server_listen(const char *host, const char *port)
{
    int rc = 0;
    int sockfd = -1; // default fail value
    struct addrinfo *info = NULL;
    struct addrinfo *next_p = NULL;
    struct addrinfo addr = {
        .ai_family = AF_UNSPEC,
        .ai_socktype = SOCK_STREAM,
        .ai_flags = AI_PASSIVE
    };

    check(host != NULL, &quot;Invalid host.&quot;);
    check(port != NULL, &quot;Invalid port.&quot;);

    // get the address info for host and port
    rc = getaddrinfo(NULL, port, &amp;addr, &amp;info);
    check(rc == 0, &quot;Failed to get address info for connect.&quot;);

    // cycle through the available list to find one
    for(next_p = info; next_p != NULL; next_p = next_p-&gt;ai_next)
    {
        // attempt to listen to each one
        sockfd = attempt_listen(next_p);
        if(sockfd != -1) break;
    }

    // either we found one and were able to listen or nothing.
    check(sockfd != -1, &quot;All possible addresses failed.&quot;);

error: //fallthrough
    if(info) freeaddrinfo(info);
    // this gets set by the above to either -1 or valid
    return sockfd;
}

bstring read_line(RingBuffer *input, const char line_ending)
{
    int i = 0;
    bstring result = NULL;

    // not super efficient
    // read a character at a time from the ring buffer
    for(i = 0; i &lt; RingBuffer_available_data(input); i++) {
        // if the buffer has line ending
        if(input-&gt;buffer[i] == line_ending) {
            // get that much fromt he ring buffer
            result = RingBuffer_gets(input, i);
            check(result, &quot;Failed to get line from RingBuffer&quot;);
            // make sure that we got the right amount
            check(RingBuffer_available_data(input) &gt;= 1, 
                    &quot;Not enough data in the RingBuffer after reading line.&quot;);
            // and commit it
            RingBuffer_commit_read(input, 1);
            break;
        }
    }

    // notice this will fail in the cases where we get a set of data
    // on the wire that does not have a line ending yet
    return result;
error:
    return NULL;
}


void send_reply(RingBuffer *send_rb, bstring reply)
{
    RingBuffer_puts(send_rb, reply);
}


</code></pre>

<p>.\ex51b\statserve\src\net.h</p>

<pre><code class="language-c">#ifndef _net_h
#define _net_h

#include &lt;lcthw/ringbuffer.h&gt;

#define BACKLOG 10

int nonblock(int fd);
int client_connect(char *host, char *port);
int read_some(RingBuffer * buffer, int fd, int is_socket);
int write_some(RingBuffer * buffer, int fd, int is_socket);
int server_listen(const char *host, const char *port);
bstring read_line(RingBuffer *input, const char line_ending);
void send_reply(RingBuffer *send_rb, bstring reply);


#endif

</code></pre>

<p>.\ex51b\statserve\src\statserve.c</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;lcthw/dbg.h&gt;
#include &lt;lcthw/hashmap.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &quot;net.h&quot;
#include &lt;netdb.h&gt;
#include &lt;fcntl.h&gt;
#include &quot;statserve.h&quot;

struct tagbstring LINE_SPLIT = bsStatic(&quot; &quot;);
struct tagbstring CREATE = bsStatic(&quot;create&quot;);
struct tagbstring STDDEV = bsStatic(&quot;stddev&quot;);
struct tagbstring MEAN = bsStatic(&quot;mean&quot;);
struct tagbstring SAMPLE = bsStatic(&quot;sample&quot;);
struct tagbstring DUMP = bsStatic(&quot;dump&quot;);
struct tagbstring DELETE = bsStatic(&quot;delete&quot;);
struct tagbstring STORE = bsStatic(&quot;store&quot;);
struct tagbstring LOAD = bsStatic(&quot;load&quot;);
struct tagbstring OK = bsStatic(&quot;OK\n&quot;);
struct tagbstring ERR = bsStatic(&quot;ERR\n&quot;);
struct tagbstring DNE = bsStatic(&quot;DNE\n&quot;);
struct tagbstring EXISTS = bsStatic(&quot;EXISTS\n&quot;);
struct tagbstring SLASH = bsStatic(&quot;/&quot;);
const char LINE_ENDING = '\n';

const int RB_SIZE = 1024 * 10;

Hashmap *DATA = NULL;
bstring STORE_PATH = NULL;

void handle_sigchild(int sig) {
    sig = 0; // ignore it
    while(waitpid(-1, NULL, WNOHANG) &gt; 0) {
    }
}

// BUG: this is stupid, use md5
void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) {
    unsigned int i;
    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;
    for (i=0; i &lt; num_rounds; i++) {
        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);
        sum += delta;
        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);
    }
    v[0]=v0; v[1]=v1;
}

/// TOTALLY RANDOM! LOL  BUG: not secure
const uint32_t STORE_KEY[4] = {18748274, 228374, 193034845, 85726348};
struct tagbstring FAUX64 = bsStatic(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890&quot;);

// BUG: this all dies
bstring encrypt_armor_name(bstring name)
{
    // copy the name to encrypt
    bstring encname = bstrcpy(name);
    size_t i = 0;
    // point the encrypt pointer at it
    // BUG: this cast is weird, why?
    uint32_t *v = (uint32_t *)bdata(encname);

    // extend the encname so that it can hold everything
    // BUG: use a correct padding algorithm
    while(blength(encname) % (sizeof(uint32_t) * 2) &gt; 0) {
        bconchar(encname, ' ');
    }

    // run encipher on this
    // BUG: get rid of encipher
    for(i = 0; i &lt; (size_t)blength(encname) / (sizeof(uint32_t) * 2); i+=2) {
        encipher(1, v+i, STORE_KEY);
    }

    // do a lame &quot;base 64&quot; kind of thing on it
    // BUG: this is NOT the best way, it's a quick hack to get it working
    // replace with real BASE64 later
    for(i = 0; i &lt; (size_t)blength(encname); i++) {
        int at = encname-&gt;data[i] % blength(&amp;FAUX64);
        encname-&gt;data[i] = FAUX64.data[at];
    }

    // that's our final hack encrypted name
    return encname;
}


bstring sanitize_location(bstring base, bstring path)
{
    bstring attempt = NULL;
    bstring encpath = NULL;
    
    // encrypt armore the name
    // BUG: ditch encryption, it was dumb
    encpath = encrypt_armor_name(path);
    check(encpath != NULL, &quot;Failed to encrypt path name: %s&quot;, bdata(path));

    // combine it with the base, this means that we've armored the 
    // path so we can just append it
    attempt = bformat(&quot;%s/%s&quot;, bdata(base), bdata(encpath));
    bdestroy(encpath);
    return attempt;

error:
    if(encpath) bdestroy(encpath);
    if(attempt) bdestroy(attempt);
    return NULL;
}

int handle_create(Command *cmd, RingBuffer *send_rb, bstring path)
{
    int rc = 0;
    int is_root = biseq(path, cmd-&gt;name);
    log_info(&quot;create: %s %s %s&quot;, bdata(cmd-&gt;name), bdata(path), bdata(cmd-&gt;number));

    Record *info = Hashmap_get(DATA, path);

    if(info != NULL &amp;&amp; is_root) {
        // report if root exists, just skip children
        send_reply(send_rb, &amp;EXISTS);
    } else if(info != NULL) {
        debug(&quot;Child %s exists, skipping it.&quot;, bdata(path));
        return 0;
    } else {
        // new child so make it
        debug(&quot;create: %s %s&quot;, bdata(path), bdata(cmd-&gt;number));

        Record *info = calloc(1, sizeof(Record));
        check_mem(info);

        // set its stat element
        info-&gt;stat = Stats_create();
        check_mem(info-&gt;stat);

        // set its name element
        info-&gt;name = bstrcpy(path);
        check_mem(info-&gt;name);

        // do a first sample
        Stats_sample(info-&gt;stat, atof(bdata(cmd-&gt;number)));

        // add it to the hashmap
        rc = Hashmap_set(DATA, info-&gt;name, info);
        check(rc == 0, &quot;Failed to add data to map.&quot;);

        // only send the for the root part
        if(is_root) {
            send_reply(send_rb, &amp;OK);
        }
    }

    return 0;
error:
    return -1;
}


int handle_sample(Command *cmd, RingBuffer *send_rb, bstring path)
{
    // get the info from the hashmap
    Record *info = Hashmap_get(DATA, path);
    int is_root = biseq(path, cmd-&gt;name);
    log_info(&quot;sample %s %s %s&quot;, bdata(cmd-&gt;name), bdata(path), bdata(cmd-&gt;number));
    bstring child_path = NULL;

    if(info == NULL) {
        // if it doesn't exist then DNE
        send_reply(send_rb, &amp;DNE);
        return 0;
    } else {
        if(is_root) {
            // just sample the root like normal
            Stats_sample(info-&gt;stat, atof(bdata(cmd-&gt;number)));
        } else {
            // need to do some hackery to get the child path
            // for rolling up mean-of-means on it

            // increase the qty on path up one
            cmd-&gt;path-&gt;qty++;
            // get the &quot;child path&quot; (previous path?)
            child_path = bjoin(cmd-&gt;path, &amp;SLASH);
            // get that info from the DATA
            Record *child_info = Hashmap_get(DATA, child_path);
            bdestroy(child_path);

            // if it exists then sample on it
            if(child_info) {
                // info is /logins, child_info is /logins/zed 
                // we want /logins/zed's mean to be a new sample on /logins
                Stats_sample(info-&gt;stat, Stats_mean(child_info-&gt;stat));
            }
            // drop the path back to where it was
            cmd-&gt;path-&gt;qty--;
        }

    }

    // do the reply for the mean last
    bstring reply = bformat(&quot;%f\n&quot;, Stats_mean(info-&gt;stat));
    send_reply(send_rb, reply);
    bdestroy(reply);

    return 0;
}

int handle_delete(Command *cmd, RingBuffer *send_rb, bstring path)
{
    log_info(&quot;delete: %s&quot;, bdata(cmd-&gt;name));
    Record *info = Hashmap_get(DATA, cmd-&gt;name);
    check(path == NULL &amp;&amp; cmd-&gt;path == NULL, &quot;Should be a recursive command.&quot;);

    // BUG: should just decide that this isn't scanned 
    // but run once, for now just only run on root
    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        Hashmap_delete(DATA, cmd-&gt;name);

        free(info-&gt;stat);
        bdestroy(info-&gt;name);
        free(info);

        send_reply(send_rb, &amp;OK);
    }

    return 0;
error:
    return -1;
}

int handle_mean(Command *cmd, RingBuffer *send_rb, bstring path)
{
    log_info(&quot;mean: %s %s %s&quot;, bdata(cmd-&gt;name), bdata(path), bdata(path));
    Record *info = Hashmap_get(DATA, path);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        bstring reply = bformat(&quot;%f\n&quot;, Stats_mean(info-&gt;stat));
        send_reply(send_rb, reply);
        bdestroy(reply);
    }

    return 0;
}

int handle_stddev(Command *cmd, RingBuffer *send_rb, bstring path)
{
    log_info(&quot;stddev: %s %s %s&quot;, bdata(cmd-&gt;name), bdata(path), bdata(path));
    Record *info = Hashmap_get(DATA, path);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        bstring reply = bformat(&quot;%f\n&quot;, Stats_stddev(info-&gt;stat));
        send_reply(send_rb, reply);
        bdestroy(reply);
    }

    return 0;
}

int handle_dump(Command *cmd, RingBuffer *send_rb, bstring path)
{
    log_info(&quot;dump: %s, %s, %s&quot;, bdata(cmd-&gt;name), bdata(path), bdata(path));
    Record *info = Hashmap_get(DATA, path);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        bstring reply = bformat(&quot;%f %f %f %f %ld %f %f\n&quot;,
                Stats_mean(info-&gt;stat),
                Stats_stddev(info-&gt;stat),
                info-&gt;stat-&gt;sum,
                info-&gt;stat-&gt;sumsq,
                info-&gt;stat-&gt;n,
                info-&gt;stat-&gt;min,
                info-&gt;stat-&gt;max);

        send_reply(send_rb, reply);
        bdestroy(reply);
    }

    return 0;
}


int handle_store(Command *cmd, RingBuffer *send_rb, bstring path)
{
    Record *info = Hashmap_get(DATA, cmd-&gt;name);
    bstring location = NULL;
    bstring from = cmd-&gt;name;
    int rc = 0;
    int fd = -1;

    check(cmd != NULL, &quot;Invalid command.&quot;);
    debug(&quot;store %s&quot;, bdata(cmd-&gt;name));
    check(path == NULL &amp;&amp; cmd-&gt;path == NULL, &quot;Store is non-recursive.&quot;);

    if(info == NULL) {
        send_reply(send_rb, &amp;DNE);
    } else {
        // it exists so we sanitize the name
        location = sanitize_location(STORE_PATH, from);
        check(location, &quot;Failed to sanitize the location.&quot;);

        // open the file we need with EXLOCK
        fd = open(bdata(location), O_WRONLY | O_CREAT | O_EXLOCK, S_IRWXU);
        check(fd &gt;= 0, &quot;Cannot open file for writing: %s&quot;, bdata(location));

        // write the Stats part of info to it
        rc = write(fd, info-&gt;stat, sizeof(Stats));
        check(rc == sizeof(Stats), &quot;Failed to write to %s&quot;, bdata(location));

        // close, which should release the lock
        close(fd);

        // then send OK
        send_reply(send_rb, &amp;OK);
    }

    return 0;
error: 
    if(fd &lt; 0) close(fd);
    return -1;
}

int handle_load(Command *cmd, RingBuffer *send_rb, bstring path)
{
    bstring to = cmd-&gt;arg;
    bstring from = cmd-&gt;name;
    bstring location = NULL;
    Record *info = Hashmap_get(DATA, to);
    int fd = -1;

    check(path == NULL &amp;&amp; cmd-&gt;path == NULL, &quot;Load is non-recursive.&quot;);

    if(info != NULL) {
        // don't do it if the target to exists
        send_reply(send_rb, &amp;EXISTS);
    } else {
        location = sanitize_location(STORE_PATH, from);
        check(location, &quot;Failed to sanitize location.&quot;);

        // make a new record for the to target
        // TODO: make regular CRUD methods for Record
        info = calloc(1, sizeof(Record));
        check_mem(info);

        info-&gt;stat = calloc(1, sizeof(Stats));
        check_mem(info-&gt;stat);

        // open the file to read from readonly and locked
        fd = open(bdata(location), O_RDONLY | O_EXLOCK);
        check(fd &gt;= 0, &quot;Error opening file: %s&quot;, bdata(location));

        // read into the stats record 
        int rc = read(fd, info-&gt;stat, sizeof(Stats));
        check(rc == sizeof(Stats), &quot;Failed to read record at %s&quot;, bdata(location));

        // close so we release the lock quick
        close(fd);

        // make a copy of to as the name for the info
        info-&gt;name = bstrcpy(to);
        check_mem(info-&gt;name);

        // put it in the hashmap
        rc = Hashmap_set(DATA, info-&gt;name, info);
        check(rc == 0, &quot;Failed to ass to data map: %s&quot;, bdata(info-&gt;name));

        // and send the reply
        send_reply(send_rb, &amp;OK);
    }

    return 0;
error:
    if(fd &lt; 0) close(fd);
    return -1;
}

int parse_command(struct bstrList *splits, Command *cmd)
{
    check(splits != NULL, &quot;Invalid split line.&quot;);

    // get the command
    cmd-&gt;command = splits-&gt;entry[0];

    if(biseq(cmd-&gt;command, &amp;CREATE)) {
        check(splits-&gt;qty == 3, &quot;Failed to parse create: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;number = splits-&gt;entry[2];
        cmd-&gt;handler = handle_create;
        cmd-&gt;path = parse_name(cmd-&gt;name);
    } else if(biseq(cmd-&gt;command, &amp;MEAN)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse mean: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_mean;
        cmd-&gt;path = parse_name(cmd-&gt;name);
    } else if(biseq(cmd-&gt;command, &amp;SAMPLE)) {
        check(splits-&gt;qty == 3, &quot;Failed to parse sample: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;number = splits-&gt;entry[2];
        cmd-&gt;handler = handle_sample;
        cmd-&gt;path = parse_name(cmd-&gt;name);
    } else if(biseq(cmd-&gt;command, &amp;DUMP)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse dump: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_dump;
        cmd-&gt;path = parse_name(cmd-&gt;name);
    } else if(biseq(cmd-&gt;command, &amp;DELETE)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse delete: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_delete;
        cmd-&gt;path = NULL;
    } else if(biseq(cmd-&gt;command, &amp;STDDEV)) {
        check(splits-&gt;qty == 2, &quot;Failed to parse stddev: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_stddev;
        cmd-&gt;path = parse_name(cmd-&gt;name);
    } else if(biseq(cmd-&gt;command, &amp;STORE)) {
        // store URL
        check(splits-&gt;qty == 2, &quot;Failed to parse store: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;handler = handle_store;
        cmd-&gt;path = NULL;
    } else if(biseq(cmd-&gt;command, &amp;LOAD)) {
        // load FROM TO
        check(splits-&gt;qty == 3, &quot;Failed to parse load: %d&quot;, splits-&gt;qty);
        cmd-&gt;name = splits-&gt;entry[1];
        cmd-&gt;arg = splits-&gt;entry[2];
        cmd-&gt;handler = handle_load;
        cmd-&gt;path = NULL;
    } else {
        sentinel(&quot;Failed to parse the command.&quot;);
    }

    return 0;
error:
    return -1;
}

int scan_paths(Command *cmd, RingBuffer *send_rb)
{
    check(cmd-&gt;path != NULL, &quot;Path was not set in command.&quot;);

    int rc = 0;
    // save the original path length
    size_t qty = cmd-&gt;path-&gt;qty;

    // starting at the longest path, shorten it and call
    // for each one:
    for(; cmd-&gt;path-&gt;qty &gt; 1; cmd-&gt;path-&gt;qty--) {
        // remake the path with / again
        bstring path = bjoin(cmd-&gt;path, &amp;SLASH);
        // call the handler with the path
        rc = cmd-&gt;handler(cmd, send_rb, path);
        // if the handler returns != 0 then abort and return that
        bdestroy(path);

        if(rc != 0) break;
    }

    // restore path length
    cmd-&gt;path-&gt;qty = qty;
    return rc;
error:
    return -1;
}

struct bstrList *parse_name(bstring name)
{
    return bsplits(name, &amp;SLASH);
}

int parse_line(bstring data, RingBuffer *send_rb)
{
    int rc = -1;
    Command cmd = {.command = NULL};

    // split data on line boundaries
    struct bstrList *splits = bsplits(data, &amp;LINE_SPLIT);
    check(splits != NULL, &quot;Bad data.&quot;);

    // parse it into a command
    rc = parse_command(splits, &amp;cmd);
    check(rc == 0, &quot;Failed to parse command.&quot;);

    // scan the path and call the handlers
    if(cmd.path) { 
        check(cmd.path-&gt;qty &gt; 1, &quot;Didn't give a valid URL.&quot;);
        rc = scan_paths(&amp;cmd, send_rb);
        check(rc == 0, &quot;Failure running recursive command against path: %s&quot;, bdata(cmd.name));
        bstrListDestroy(cmd.path);
    } else {
        rc = cmd.handler(&amp;cmd, send_rb, NULL);
        check(rc == 0, &quot;Failed running command against path: %s&quot;, bdata(cmd.name));
    }

    bstrListDestroy(splits);

    return 0;

error: // fallthrough
    if(cmd.path) bstrListDestroy(cmd.path);
    if(splits) bstrListDestroy(splits);
    return -1;
}

void client_handler(int client_fd)
{
    int rc = 0;
    RingBuffer *recv_rb = RingBuffer_create(RB_SIZE);
    RingBuffer *send_rb = RingBuffer_create(RB_SIZE);

    check_mem(recv_rb);
    check_mem(send_rb);

    // keep reading into the recv buffer and sending on send
    while(read_some(recv_rb, client_fd, 1) != -1) {
        // read a line from the recv_rb
        bstring data = read_line(recv_rb, LINE_ENDING);
        check(data != NULL, &quot;Client closed.&quot;);

        // parse it, close on any protocol errors
        rc = parse_line(data, send_rb);
        bdestroy(data); // cleanup here
        check(rc == 0, &quot;Failed to parse user. Closing.&quot;);

        // and as long as there's something to send, send it
        if(RingBuffer_available_data(send_rb)) {
            write_some(send_rb, client_fd, 1);
        }
    }

    // close the socket
    rc = close(client_fd);
    check(rc != -1, &quot;Failed to close the socket.&quot;);

error: // fallthrough
    if(recv_rb) RingBuffer_destroy(recv_rb);
    if(send_rb) RingBuffer_destroy(send_rb);
    exit(0); // just exit the child process
}

int setup_data_store(const char *store_path)
{
    // a more advanced design simply wouldn't use this
    DATA = Hashmap_create(NULL, NULL);
    check_mem(DATA);

    char *path = realpath(store_path, NULL);
    check(path != NULL, &quot;Failed to get the real path for storage: %s&quot;, store_path);
    
    STORE_PATH = bfromcstr(path);
    free(path);

    return 0;
error:
    return -1;
}

int run_server(const char *host, const char *port, const char *store_path)
{
    int rc = 0;
    struct sockaddr_in client_addr;
    socklen_t sin_size = sizeof(client_addr);
    int server_socket = 0;
    int client_fd = 0;

    rc = setup_data_store(store_path);
    check(rc == 0, &quot;Failed to setup the data store.&quot;);

    struct sigaction sa = {
        .sa_handler = handle_sigchild,
        .sa_flags = SA_RESTART | SA_NOCLDSTOP
    };

    check(host != NULL, &quot;Invalid host.&quot;);
    check(port != NULL, &quot;Invalid port.&quot;);

    // create a sigaction that handles SIGCHLD
    sigemptyset(&amp;sa.sa_mask);
    rc = sigaction(SIGCHLD, &amp;sa, 0);
    check(rc != -1, &quot;Failed to setup signal handler for child processes.&quot;);

    // listen on the given port and host
    server_socket = server_listen(host, port);
    check(server_socket &gt;= 0, &quot;bind to %s:%s failed.&quot;, host, port);

    while(1) {
        // accept the connection
        client_fd = accept(server_socket, (struct sockaddr *)&amp;client_addr, &amp;sin_size); 
        check(client_fd &gt;= 0, &quot;Failed to accept connection.&quot;);

        debug(&quot;Client connected.&quot;);

        rc = fork();
        if(rc == 0) {
            // child process
            close(server_socket); // don't need this
            // handle the client
            client_handler(client_fd);
        } else {
            // server process
            close(client_fd); // don't need this
        }
    }

error:  // fallthrough
    return -1;
}

</code></pre>

<p>.\ex51b\statserve\src\statserve.h</p>

<pre><code class="language-c">#ifndef _statserve_h
#define _statserve_h

#include &lt;lcthw/bstrlib.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;lcthw/stats.h&gt;

struct Command;

typedef int (*handler_cb)(struct Command *cmd, RingBuffer *send_rb, bstring path);

typedef struct Command {
    bstring command;
    bstring name;
    struct bstrList *path;
    bstring number;
    bstring arg;
    handler_cb handler;
} Command;


typedef struct Record {
    bstring name;
    Stats *stat;
} Record;

struct tagbstring OK;

int setup_data_store(const char *store_path);

struct bstrList *parse_name(bstring name);

int scan_paths(Command *cmd, RingBuffer *send_rb);

int parse_line(bstring data, RingBuffer *send_rb);

int run_server(const char *host, const char *port, const char *store_path);

bstring sanitize_location(bstring base, bstring path);

bstring encrypt_armor_name(bstring name);

#endif

</code></pre>

<p>.\ex51b\statserve\tests\statserve_tests.c</p>

<pre><code class="language-c">#include &quot;minunit.h&quot;
#include &lt;dlfcn.h&gt;
#include &quot;statserve.h&quot;
#include &lt;lcthw/bstrlib.h&gt;
#include &lt;lcthw/ringbuffer.h&gt;
#include &lt;assert.h&gt;

typedef struct LineTest {
    char *line;
    bstring result;
    char *description;
} LineTest;

int attempt_line(LineTest test)
{
    int rc = -1;
    bstring result = NULL;

    bstring line = bfromcstr(test.line);
    RingBuffer *send_rb = RingBuffer_create(1024);

    rc = parse_line(line, send_rb);
    check(rc == 0, &quot;Failed to parse line.&quot;);
    result = RingBuffer_get_all(send_rb);
    check(result != NULL, &quot;Ring buffer empty.&quot;);
    check(biseq(result, test.result), &quot;Got the wrong output: %s expected %s&quot;,
            bdata(result), bdata(test.result));

    bdestroy(line);
    RingBuffer_destroy(send_rb);
    return 1; // using 1 for tests
error:
  
    log_err(&quot;Failed to process test %s: got %s&quot;, test.line, bdata(result));
    if(line) bdestroy(line);
    if(send_rb) RingBuffer_destroy(send_rb);
    return 0;
}


int run_test_lines(LineTest *tests, int count)
{
    int i = 0;

    for(i = 0; i &lt; count; i++) {
        check(attempt_line(tests[i]), &quot;Failed to run %s&quot;, tests[i].description);
    }

    return 1;
error:
    return 0;
}

int fake_command(Command *cmd, RingBuffer *send_rb, bstring path)
{
    check(cmd != NULL, &quot;Bad cmd.&quot;);
    check(cmd-&gt;path != NULL, &quot;Bad path.&quot;);
    check(send_rb != NULL, &quot;Bad send_rb.&quot;);
    check(path != NULL, &quot;Bad path given.&quot;);

    return 0;
error:
    return -1;
}

char *test_path_parsing()
{
    struct bstrList *result = NULL;
    struct tagbstring slash = bsStatic(&quot;/&quot;);
    struct tagbstring logins_zed = bsStatic(&quot;/logins/zed&quot;);
    struct tagbstring command_name = bsStatic(&quot;dump&quot;);
    RingBuffer *send_rb = RingBuffer_create(1024);
    struct bstrList *path = bsplits(&amp;logins_zed, &amp;slash);
    int rc = 0;

    Command fake = {
        .command = &amp;command_name,
        .name = &amp;logins_zed,
        .number = NULL,
        .handler = fake_command,
        .path = path
    };

    result = parse_name(&amp;logins_zed);
    mu_assert(result != NULL, &quot;Failed to parse /logins/zed&quot;);

    rc = scan_paths(&amp;fake, send_rb); 
    mu_assert(rc != -1, &quot;scan_paths failed.&quot;);

    return NULL;
}

char *test_create()
{
    LineTest tests[] = {
        {.line = &quot;create /zed 100&quot;, .result = &amp;OK, .description = &quot;create zed failed&quot;},
        {.line = &quot;create /joe 100&quot;, .result = &amp;OK, .description = &quot;create joe failed&quot;},

    };

    mu_assert(run_test_lines(tests, 2), &quot;Failed to run create tests.&quot;);

    return NULL;
}

char *test_sample()
{
    struct tagbstring sample1 = bsStatic(&quot;100.000000\n&quot;);

    LineTest tests[] = {
        {.line = &quot;sample /zed 100&quot;, .result = &amp;sample1, .description = &quot;sample zed failed.&quot;}
    };

    mu_assert(run_test_lines(tests, 1), &quot;Failed to run sample tests.&quot;);

    return NULL;
}

char *test_store_load()
{
    LineTest tests[] = {
        {.line = &quot;delete /zed&quot;, .result = &amp;OK, .description = &quot;delete zed failed&quot;},
        {.line = &quot;create /zed 100&quot;, .result = &amp;OK, .description = &quot;create zed failed&quot;},
        {.line = &quot;store /zed&quot;, .result = &amp;OK, .description = &quot;store zed failed&quot;},
        {.line = &quot;load /zed /sam&quot;, .result = &amp;OK, .description = &quot;load zed failed&quot;},
        {.line = &quot;delete /sam&quot;, .result = &amp;OK, .description = &quot;load zed failed&quot;},
    };

    mu_assert(run_test_lines(tests, 3), &quot;Failed to run sample tests.&quot;);

    return NULL;
}

char *test_encrypt_armor_name()
{
    struct tagbstring test1 = bsStatic(&quot;/logins&quot;);
    struct tagbstring expect1 = bsStatic(&quot;vtmTmzNI&quot;);
    struct tagbstring test2 = bsStatic(&quot;../../../../../../../../etc/passwd&quot;);
    struct tagbstring expect2 = bsStatic(&quot;pVOBpFjHEIhB7cuT3BGUvyZGn3lvyj226mgggggg&quot;);
   
    bstring result = encrypt_armor_name(&amp;test1);
    debug(&quot;Got encrypted name %s&quot;, bdata(result));
    mu_assert(biseq(result, &amp;expect1), &quot;Failed to encrypt test2.&quot;);
    bdestroy(result);

    result = encrypt_armor_name(&amp;test2);
    debug(&quot;Got encrypted name %s&quot;, bdata(result));
    mu_assert(biseq(result, &amp;expect2), &quot;Failed to encrypt test2.&quot;);
    bdestroy(result);

    return NULL;
}

char *test_path_sanitize_armor()
{
    struct tagbstring base = bsStatic(&quot;/tmp&quot;);
    struct tagbstring test1 = bsStatic(&quot;/somepath/here/there&quot;);
    bstring encname = encrypt_armor_name(&amp;test1);
    bstring expect = bformat(&quot;%s/%s&quot;, bdata(&amp;base), bdata(encname));
    struct tagbstring test2 = bsStatic(&quot;../../../../../../../../etc/passwd&quot;);


    bstring result = sanitize_location(&amp;base, &amp;test1);
    mu_assert(result != NULL, &quot;Failed to sanitize path.&quot;);
    mu_assert(biseq(result, expect), &quot;failed to sanitize test1&quot;);

    // this should be pulled up into a tester function
    // BUG: just get rid of this and use md5
    encname = encrypt_armor_name(&amp;test2);
    expect = bformat(&quot;%s/%s&quot;, bdata(&amp;base), bdata(encname));
    result = sanitize_location(&amp;base, &amp;test2);
    mu_assert(result != NULL, &quot;Failed to sanitize path.&quot;);
    mu_assert(biseq(result, expect), &quot;failed to sanitize test1&quot;);
    

    return NULL;
}

char *all_tests()
{
    mu_suite_start();

    int rc = setup_data_store(&quot;/tmp&quot;);
    mu_assert(rc == 0, &quot;Failed to setup the data store.&quot;);

    mu_run_test(test_path_parsing);
    mu_run_test(test_encrypt_armor_name);
    mu_run_test(test_path_sanitize_armor);
    mu_run_test(test_create);
    mu_run_test(test_sample);
    mu_run_test(test_store_load);

    return NULL;
}

RUN_TESTS(all_tests);

</code></pre>

<p>Final Review</p>

				</section>
			</article>
		</main>
	</div> 

	

<div class="col-sm-3 col-sm-offset-1 doc-sidebar">
	<div id="sidebar">
	<div class="sidebar-module">
		<div class="sidebar-toc">
			<h4 class="sidebar-heading">Table of Contents</h4>
			<ul>
				<li><strong><a href="#title">LCTHW Lectures</a></strong></li>
			</ul>
			<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#exercise-0-installing-software">Exercise 0 Installing Software</a></li>
<li><a href="#exercise-1-dust-off-that-compiler">Exercise 1 Dust Off That Compiler</a></li>
<li><a href="#exercise-2-using-makefiles-to-build">Exercise 2 Using Makefiles to Build</a></li>
<li><a href="#exercise-3-formatted-printing">Exercise 3 Formatted Printing</a></li>
<li><a href="#exercise-4-using-a-debugger">Exercise 4 Using a Debugger</a></li>
<li><a href="#exercise-5-memorizing-c-operators">Exercise 5 Memorizing C Operators</a></li>
<li><a href="#exercise-6-memorizing-c-syntax">Exercise 6 Memorizing C Syntax</a></li>
<li><a href="#exercise-7-variables-and-types">Exercise 7 Variables and Types</a></li>
<li><a href="#exercise-8-if-else-if-else">Exercise 8 If, Else-If, Else</a></li>
<li><a href="#exercise-9-while-loop-and-boolean-expressions">Exercise 9 While-Loop and Boolean Expressions</a></li>
<li><a href="#exercise-10-switch-statements">Exercise 10 Switch Statements</a></li>
<li><a href="#exercise-11-arrays-and-strings">Exercise 11 Arrays and Strings</a></li>
<li><a href="#exercise-12-sizes-and-arrays">Exercise 12 Sizes and Arrays</a></li>
<li><a href="#exercise-13-for-loops-and-arrays-of-strings">Exercise 13 For-Loops and Arrays of Strings</a></li>
<li><a href="#exercise-14-writing-and-using-functions">Exercise 14 Writing and Using Functions</a></li>
<li><a href="#exercise-15-pointers-dreaded-pointers">Exercise 15 Pointers, Dreaded Pointers</a></li>
<li><a href="#exercise-16-structs-and-pointers-to-them">Exercise 16 Structs And Pointers To Them</a></li>
<li><a href="#exercise-17-heap-and-stack-memory-allocation">Exercise 17 Heap and Stack Memory Allocation</a></li>
<li><a href="#exercise-18-pointers-to-functions">Exercise 18 Pointers to Functions</a></li>
<li><a href="#exercise-19-zed-s-awesome-debug-macros">Exercise 19 Zed&rsquo;s Awesome Debug Macros</a></li>
<li><a href="#exercise-20-advanced-debugging-techniques">Exercise 20 Advanced Debugging Techniques</a></li>
<li><a href="#exercise-21-advanced-data-types-and-flow-control">Exercise 21 Advanced Data Types and Flow Control</a></li>
<li><a href="#exercise-22-the-stack-scope-and-globals">Exercise 22 The Stack, Scope, and Globals</a></li>
<li><a href="#exercise-23-meet-duff-s-device">Exercise 23 Meet Duff&rsquo;s Device</a></li>
<li><a href="#exercise-24-input-output-files">Exercise 24 Input, Output, Files</a></li>
<li><a href="#exercise-25-variable-argument-functions">Exercise 25 Variable Argument Functions</a></li>
<li><a href="#exercise-26-project-logfind">Exercise 26 Project logfind</a></li>
<li><a href="#exercise-27-creative-and-defensive-programming">Exercise 27 Creative and Defensive Programming</a></li>
<li><a href="#exercise-28-intermediate-makefiles">Exercise 28 Intermediate Makefiles</a></li>
<li><a href="#exercise-29-libraries-and-linking">Exercise 29 Libraries and Linking</a></li>
<li><a href="#exercise-30-automated-testing">Exercise 30 Automated Testing</a></li>
<li><a href="#exercise-31-common-undefined-behavior">Exercise 31 Common Undefined Behavior</a></li>
<li><a href="#exercise-32-double-linked-lists">Exercise 32 Double Linked Lists</a></li>
<li><a href="#exercise-33-linked-list-algorithms">Exercise 33 Linked List Algorithms</a></li>
<li><a href="#exercise-34-dynamic-array">Exercise 34 Dynamic Array</a></li>
<li><a href="#exercise-35-sorting-and-searching">Exercise 35 Sorting and Searching</a></li>
<li><a href="#exercise-36-safer-strings">Exercise 36 Safer Strings</a></li>
<li><a href="#exercise-37-hashmaps">Exercise 37 Hashmaps</a></li>
<li><a href="#exercise-38-hashmap-algorithms">Exercise 38 Hashmap Algorithms</a></li>
<li><a href="#exercise-39-string-algorithms">Exercise 39 String Algorithms</a></li>
<li><a href="#exercise-40-binary-search-trees">Exercise 40 Binary Search Trees</a></li>
<li><a href="#exercise-41-project-devpkg">Exercise 41 Project devpkg</a></li>
<li><a href="#exercise-42-stacks-and-queues">Exercise 42 Stacks and Queues</a></li>
<li><a href="#exercise-43-a-simple-statistics-engine">Exercise 43 A Simple Statistics Engine</a></li>
<li><a href="#exercise-44-ring-buffer">Exercise 44 Ring Buffer</a></li>
<li><a href="#exercise-45-a-simple-tcp-ip-client">Exercise 45 A Simple TCP/IP Client</a></li>
<li><a href="#exercise-46-ternary-search-tree">Exercise 46 Ternary Search Tree</a></li>
<li><a href="#exercise-47-a-fast-url-router">Exercise 47 A Fast URL Router</a></li>
<li><a href="#exercise-48a-a-simple-network-server">Exercise 48a A Simple Network Server:</a></li>
<li><a href="#exercise-48b-a-simple-network-server">Exercise 48b A Simple Network Server:</a></li>
<li><a href="#exercise-49b-a-statistics-server">Exercise 49b A Statistics Server</a></li>
<li><a href="#exercise-49a-a-statistics-server">Exercise 49a A Statistics Server:</a></li>
<li><a href="#exercise-50a-routing-the-statistics">Exercise 50a Routing The Statistics</a></li>
<li><a href="#exercise-50b-routing-the-statistics">Exercise 50b Routing the Statistics</a></li>
<li><a href="#exercise-51a-storing-the-statistics">Exercise 51a Storing the Statistics</a></li>
<li><a href="#exercise-51b-storing-the-statistics">Exercise 51b Storing the Statistics</a></li>
</ul></li>
</ul>
</nav>
		</div>
	</div>
	<div class="sidebar-module">
		<h4 class="sidebar-heading">Pages in Categories</h4>
		<ul class="sidebar-category-list">
		
			<li>
				<a href="https://harryho.github.io/categories/code">
					<span class="doc-list-category">Code</span>
				</a>
				<ul>
					<li>
						<span class="active">LCTHW Lectures</span>
						</li>
				
					<li><a href="/code/csharp-notes-1/">C# Notes -- Part 1</a>
					</li>
				
					<li><a href="/code/csharp-notes-2/">C# Notes -- Part 2</a>
					</li>
				
					<li><a href="/code/javascript-oop/">JavaScript and Object Oriented Programming</a>
					</li>
				
					<li><a href="/code/java-notes-1/">Java Notes, Part-1</a>
					</li>
				
					<li><a href="/code/java-notes-2/">Java Notes, Part-2</a>
					</li>
				
					<li><a href="/code/java-notes-3/">Java Notes, Part-3</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/dev">
					<span class="doc-list-category">Dev</span>
				</a>
				<ul>
					<li><a href="/dev/php-web/">PHP web framework</a>
					</li>
				
					<li><a href="/dev/build-mobile-app/">Build mobile app with web dev skills</a>
					</li>
				
					<li><a href="/dev/python-django/">Python Web framework</a>
					</li>
				
					<li><a href="/dev/php-debug/">Debug PHP with Eclipse PDT and Netbeans</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/info">
					<span class="doc-list-category">Info</span>
				</a>
				<ul>
					<li><a href="/info/create-a-blog-on-github-pages/">Create a blog site on GitHub Pages</a>
					</li>
				
					<li><a href="/info/jira-notes/">JIRA Notes</a>
					</li>
				
					<li><a href="/info/linux-history/">Brief history of Linux</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/os">
					<span class="doc-list-category">Os</span>
				</a>
				<ul>
					<li><a href="/os/linux-notes/">Linux notes</a>
					</li>
				
					<li><a href="/os/ubuntu-server-14/">Ubuntu 14 -- server setup</a>
					</li>
				
					<li><a href="/os/ubuntu-desktop-14/">Ubuntu 14 -- desktop setup &amp; dual boot </a>
					</li>
				
					<li><a href="/os/use-windows-command-hotkey-as-hacker-2/">Use Windows command &amp; hotkey as a hacker - Part 2</a>
					</li>
				
					<li><a href="/os/use-windows-command-hotkey-as-hacker-1/">Use Windows command &amp; hotkey as a hacker - Part 1</a>
					</li>
				
					<li><a href="/os/centos-fedora-desktop/">CentOS 6/7 -- desktop Setup</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/project">
					<span class="doc-list-category">Project</span>
				</a>
				<ul>
					<li><a href="/project/laravel-mvc-starter/">Laravel MVC Starter</a>
					</li>
				
					<li><a href="/project/reetek-vue2-admin/">Reetek Vue 2 Admin Project</a>
					</li>
				
					<li><a href="/project/angularjs-webpack-es6-starter/">Angularjs Webpack ES6 Starter</a>
					</li>
				
					<li><a href="/project/zf2-mvc-starter/">Zendframework 2 MVC Starter</a>
					</li>
				
				</ul>
			</li>
		
		</ul>
	</div>
	<div class="sidebar-module">
		<h4 class="sidebar-heading">Tags</h4>
		<div class="tag-box">
		
			<a class="tag-item" href="https://harryho.github.io/tags/agile">agile</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/angularjs">angularjs</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/c">c</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/centos">centos</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/cmd">cmd</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/git">git</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/hugo">hugo</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/java">java</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/javascript">javascript</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/linux">linux</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/mobile">mobile</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/oo">oo</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/php">php</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/python">python</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/ubuntu">ubuntu</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/webpack">webpack</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/windows">windows</a>
		
		</div>
	</div>
	</div>
</div>

</div> 
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'harryho';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<hr />

<div class="row">
	<div class="col-sm-8">
		<p class="doc-footer-em"><a href="#" onclick="resetSidebarPos()">Back to TOP</a></p>
	</div>
</div>

</div> 

<footer class="doc-footer">
	<p class="doc-footer-em">Browse <strong><a href="https://github.com/harryho/harryho.github.io.git">Repository</a></strong></p>
	<p>Copyright (c) 2015, harryho; All rights reserved.</p>
	<p>Powered by <strong><a href="https://github.com/key-amb/hugo-theme-bootie-docs">Bootie Docs</a></strong> - theme for <a href="http://gohugo.io/">Hugo</a> by <a href="https://github.com/key-amb/">key-amb</a>.</p>
</footer>



<script src="https://harryho.github.io/js/jquery.min.js"></script>
<script src="https://harryho.github.io/js/bootstrap.min.js"></script>

<script src="https://harryho.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://harryho.github.io/js/ie10-viewport-bug-workaround.js"></script>
<script src="https://harryho.github.io/js/bootie-docs.js"></script>
<script>
	console.log( hljs.listLanguages());
</script>
<script id="dsq-count-scr" src="//harryho.disqus.com/count.js" async></script>


</body>
</html>
