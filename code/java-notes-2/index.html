<!DOCTYPE html> 
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="google-site-verification" content="fB00vw3NhrcDODZ6PcjUHM1Pz1j4T-eZ0Ja7ffDx-aU" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="alternate" href="/index.xml" type="application/rss+xml" title="Hello World">
    <link rel="icon" href="https://harryho.github.io/favicon.ico">
    <title>Java Notes, Part-2 - Hello World</title>
    
    <link rel="stylesheet" href="https://harryho.github.io/css/highlight/railscasts.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/theme.css">
    <link rel="stylesheet" href="https://harryho.github.io/css/bootie-docs.css">
</head>

<body role="document">
    
    <nav class="navbar navbar-inverse navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
                    <a class="navbar-brand" href="https://harryho.github.io/">Hello World</a>
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
      
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    
                     
                    
                         
                            <li >
                                <a href="https://harryho.github.io/article/">Article</a>
                            </li>
                         
                            <li >
                                <a href="https://harryho.github.io/code/">Code</a>
                            </li>
                         
                            <li >
                                <a href="https://harryho.github.io/dev/">Dev</a>
                            </li>
                         
                            <li >
                                <a href="https://harryho.github.io/os/">OS</a>
                            </li>
                         
                            <li >
                                <a href="https://harryho.github.io/project/">Project</a>
                            </li>
                        
                    
                    
                    
                </ul>
                
                    <form class="navbar-form navbar-left" role="search" action="https://www.google.com/search" method="get">
                        <div class="input-group doc-search-form">
                            <input type="hidden" name="as_sitesearch" value="harryho.github.io">
                            <input type="text" name="as_q" class="search-query doc-search-input-text" placeholder="Search Site">
                            <span class="input-group-addon input-group-btn doc-search-input-btn " >
                                <button class="btn" type="submit"><span class="glyphicon glyphicon-search"></span></button>
                            </span>
                        </div>
                    </form>
                
            </div>
            
        </div>
    </nav>
    <div class="container">


<div class="row">
	<div class="col-sm-8 doc-main">
		<main role="main">
			<article>
				<a id="title"></a>
				<h1 class="doc-entry-title">Java Notes, Part-2</h1>
				<div class="doc-entry-meta">
					<span>updated at <time datetime="2013-07-08">08 Jul 2013</time></span>
				</div>
				<section>
					

<h1 id="thread">Thread</h1>

<h2 id="join">Join</h2>

<ul>
<li><p>The join method allows one thread to wait for the completion of another. join responds to an interrupt by exiting with an InterruptedException.</p></li>

<li><p>Demo code of thread join</p></li>
</ul>

<pre><code class="language-java">public class JoinDemo implements Runnable {
    private Random rand = new Random(System.currentTimeMillis());

    public void run() {
        //simulate some CPU expensive task
        for (int i = 0; i &lt; 100000000; i++) {
            rand.nextInt();
        }
        System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;] finished  .&quot;);
    }

    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[5];
        for (int i = 0; i &lt; threads.length; i++) {
            threads[i] = new Thread(new JoinDemo(), &quot;joinThread &quot; + i);
            threads[i].start();
        }
        for (int i = 0; i &lt; threads.length; i++) {
            threads[i].join();
        }
        System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;] All  -threads have finished.&quot;);
    }
}
</code></pre>

<h2 id="common-problem-of-multithred-program">Common problem of multithred program</h2>

<ul>
<li><p>When there are many threads running, the exact sequence in which all running threads are executed depends next to the thread
configuration like priority also on the available CPU resources and the way the scheduler chooses the next thread to execute.
Although the behavior of the scheduler is completely deterministic, it is hard to predict which threads execute in which moment
at a given point in time. This makes access to shared resources critical as it is hard to predict which thread will be the first thread
that tries to access it.</p></li>

<li><p>Sample code without sync can show you what the problem is. If you run the following sample code, you may get different output from mine here. It is also common Thread safe issue for multiple threads program.</p></li>
</ul>

<pre><code class="language-java">public class NotSyncCounter implements Runnable {
    private static int counter = 0;

    public void run() {
        while (counter &lt; 10) {
            System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;]  -    before: &quot; + counter);
            counter++;
            System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;]  -    after: &quot; + counter);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[5];
        for (int i = 0; i &lt; threads.length; i++) {
            threads[i] = new Thread(new NotSyncCounter(), &quot;  -    thread-&quot; + i);
            threads[i].start();
        }
        for (int i = 0; i &lt; threads.length; i++) {
            threads[i].join();
        }
    }
}


//Possible output:
// [  -    thread-2]  -    before: 0
// [  -    thread-1]  -    before: 0
// [  -    thread-4]  -    before: 0
// [  -    thread-3]  -    before: 0
// [  -    thread-0]  -    before: 0
// [  -    thread-3]  -    after: 4
// [  -    thread-3]  -    before: 5
// [  -    thread-4]  -    after: 3
// [  -    thread-1]  -    after: 2
// [  -    thread-1]  -    before: 6
// [  -    thread-1]  -    after: 7
// [  -    thread-2]  -    after: 1
// [  -    thread-1]  -    before: 7
// [  -    thread-4]  -    before: 6
// [  -    thread-4]  -    after: 9
// [  -    thread-4]  -    before: 9
// [  -    thread-3]  -    after: 6
// [  -    thread-0]  -    after: 5
// [  -    thread-4]  -    after: 10
// [  -    thread-1]  -    after: 8
// [  -    thread-2]  -    before: 7
// [  -    thread-2]  -    after: 11
</code></pre>

<ul>
<li><p>To solve the problme, there is <code>synchronized</code> keyword in Java available for us to handle the multiple threads program.</p></li>

<li><p>Demo code of <code>synchronized</code> to solve the problem on above sample.</p></li>
</ul>

<pre><code class="language-java">
public class SyncCounter implements Runnable {
    private static int counter = 0;

    public void run() {
        while (counter &lt; 10) {
            synchronized (SyncCounter.class) {
                System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;] - before: &quot; + counter);
                counter++;
                System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;] - after: &quot; + counter);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[5];
        for (int i = 0; i &lt; threads.length; i++) {
            threads[i] = new Thread(new SyncCounter(), &quot;  -    thread-&quot; + i);
            threads[i].start();
        }
        for (int i = 0; i &lt; threads.length; i++) {
            threads[i].join();
        }
    }
}

</code></pre>

<h3 id="deadlock">Deadlock</h3>

<p>In general the following requirements for a deadlock can be identified:
* Mutual exclusion: There is a resource which can be accessed only by one thread at any point in time.
* Resource holding: While having locked one resource, the thread tries to acquire another lock on some other exclusive resource.
* No preemption: There is no mechanism, which frees the resource if one threads holds the lock for a specific period of time.
* Circular wait: During runtime a constellation occurs in which two (or more) threads are each waiting on the other thread to free a resource that it has locked.</p>

<ul>
<li>Monitor with wait and notify</li>
</ul>

<pre><code class="language-java">
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
public class SyncWaitNotfiyDemo {
    private static final Queue &lt;Integer&gt;queue = new ConcurrentLinkedQueue&lt;Integer&gt;();

    public Integer getNextInt() {
        Integer retVal = null;
        synchronized (queue) {
            try {
                while (queue.isEmpty()) {
                    queue.wait();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            retVal = queue.poll();
        }
        return retVal;
    }

    public synchronized void putInt(Integer value) {
        synchronized (queue) {
            queue.add(value);
            queue.notify();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        final SyncWaitNotfiyDemo queue = new SyncWaitNotfiyDemo();

        Thread thread1 = new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i &lt; 10; i++) {
                    queue.putInt(i);
                }
            }
        });

        Thread thread2 = new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i &lt; 10; i++) {
                    Integer nextInt = queue.getNextInt();
                    System.out.println(&quot;Next int: &quot; + nextInt);
                }
            }
        });

        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
    }
}
</code></pre>

<h3 id="useful-concurrent-collections">Useful concurrent collections</h3>

<h4 id="concurrenthashmap">ConcurrentHashMap</h4>

<blockquote>
<p><code>ConcurrentHashMap</code> is undoubtedly most popular collection class introduced in Java 5 and most of us are already using it. It provides a concurrent alternative of Hashtable or Synchronized Map classes with aim to support higher level of concurrency by implementing fined grained locking. Multiple reader can access the Map concurrently  while a portion of Map gets locked for write operation depends upon concurrency level of Map. Also it provides better scalability than there synchronized counter part. Iterator of <code>ConcurrentHashMap</code> are fail-safe iterators which doesn&rsquo;t throw ConcurrencModificationException thus eliminates another requirement of locking during iteration which result in further scalability and performance.</p>
</blockquote>

<h4 id="copyonwritearraylist-and-copyonwritearrayset">CopyOnWriteArrayList and CopyOnWriteArraySet</h4>

<blockquote>
<p><code>CopyOnWriteArrayList</code> is a concurrent alternative of synchronized List. It provides better concurrency than synchronized List by allowing multiple concurrent reader and replacing the whole list on write operation. Yes, write operation is costly on <code>CopyOnWriteArrayList</code> but it performs better when there are multiple reader and requirement of iteration is more than writing. Since <code>CopyOnWriteArrayList</code> Iterator also don&rsquo;t throw ConcurrencModificationException it eliminates need to lock the collection during iteration. Remember both <code>ConcurrentHashMap</code> and <code>CopyOnWriteArrayList</code> doesn&rsquo;t provides same level of locking as Synchronized Collection and achieves thread-safety by there locking and mutability strategy. So they perform better if requirements suits there nature. Similarly, <code>CopyOnWriteArraySet</code> is a concurrent replacement to Synchronized Set.</p>
</blockquote>

<h4 id="blockingqueue-and-deque">BlockingQueue and <code>Deque</code></h4>

<blockquote>
<p><code>BlockingQueue</code> makes it easy to implement producer-consumer design pattern by providing inbuilt blocking support for put() and take() method. put() method will block if Queue is full while take() method will block if Queue is empty. Java 5 API provides two concrete implementation of <code>BlockingQueue</code> in form of <code>ArrayBlockingQueue</code> and <code>LinkedBlockingQueue</code>, both of them implement FIFO ordering of element. ArrayBlockingQueue is backed by Array and its bounded in nature while <code>LinkedBlockingQueue</code> is optionally bounded. Consider using <code>BlockingQueue</code> to solve producer Consumer problem in Java instead of writing your won wait-notify code. Java 5 also provides <code>PriorityBlockingQueue</code>, another implementation of <code>BlockingQueue</code> which is ordered on priority and useful if you want to process elements on order other than FIFO.</p>

<p><code>Deque</code> interface is added in Java 6 and it extends Queue interface to support insertion and removal from both end of Queue referred as head and tail. Java6 also provides concurrent implementation of <code>Deque</code> like ArrayDeque and LinkedBlockingDeque. <code>Deque</code> Can be used efficiently to increase parallelism in program by allowing set of worker thread to help each other by taking some of work load from other thread by utilizing <code>Deque</code> double end consumption property. So if all Thread has there own set of task Queue and they are consuming from head; helper thread can also share some work load via consumption from tail.</p>
</blockquote>

<h4 id="concurrentskiplistmap-and-concurrentskiplistset">ConcurrentSkipListMap and ConcurrentSkipListSet</h4>

<blockquote>
<p>Just like <code>ConcurrentHashMap</code> provides a concurrent alternative of synchronized HashMap. ConcurrentSkipListMap and ConcurrentSkipListSet provide concurrent alternative for synchronized version of SortedMap and SortedSet. For example instead of using TreeMap or TreeSet wrapped inside synchronized Collection, You can consider using ConcurrentSkipListMap or ConcurrentSkipListSet from java.util.concurrent package. They also implement NavigableMap and NavigableSet to add additional navigation method.</p>
</blockquote>

<h2 id="synchronizer">Synchronizer</h2>

<h3 id="counter-semaphore">Counter Semaphore</h3>

<ul>
<li>Counting Semaphore in Java maintains specified number of pass or permits, In order to access a shared resource, Current Thread must acquire a permit. If permit is already exhausted by other thread than it can wait until a permit is available due to release of permit from different thread. This concurrency utility can be very useful to implement producer consumer design pattern or implement bounded pool or resources like Thread Pool, DB Connection pool etc.</li>
</ul>

<pre><code class="language-java">
import java.util.concurrent.Semaphore;

public class SemaphoreDemo {

    Semaphore binary = new Semaphore(1);
  
    public static void main(String args[]) {
        final SemaphoreDemo test = new SemaphoreDemo();
        new Thread(){
            @Override
            public void run(){
              test.mutualExclusion(); 
            }
        }.start();
      
        new Thread(){
            @Override
            public void run(){
              test.mutualExclusion(); 
            }
        }.start();
      
    }
  
    private void mutualExclusion() {
        try {
            binary.acquire();

            //mutual exclusive region
            System.out.println(Thread.currentThread().getName() + &quot; inside mutual exclusive region&quot;);
            Thread.sleep(1000);

        } catch (InterruptedException i.e.) {
            ie.printStackTrace();
        } finally {
            binary.release();
            System.out.println(Thread.currentThread().getName() + &quot; outside of mutual exclusive region&quot;);
        }
    } 
  
}

// Output:
// Thread-0 inside mutual exclusive region
// Thread-0 outside of mutual exclusive region
// Thread-1 inside mutual exclusive region
// Thread-1 outside of mutual exclusive region

</code></pre>

<h3 id="countdownlatch">CountDownLatch</h3>

<ul>
<li><p><code>CountDownLatch</code> in Java is a kind of synchronizer which allows one Thread  to wait for one or more Threads before starts processing. You can also implement same functionality using  wait and notify mechanism in Java but it requires lot of code and getting it write in first attempt is tricky,  With <code>CountDownLatch</code> it can  be done in just few lines. <code>CountDownLatch</code> also allows flexibility on number of thread for which main thread should wait, It can wait for one thread or n number of thread, there is not much change on code.</p></li>

<li><p>The difficulty to use it properly is where to use <code>CountDownLatch</code>. First, let us figour out how <code>CountDownLatch</code> works. usaullly main thread of application,  which calls CountDownLatch.await() will wait until count reaches zero or its interrupted by another Thread. All other thread are required to do count down by calling CountDownLatch.countDown() once they are completed. One disadvantage of <code>CountDownLatch</code> is not reusable, once its count reaches zero.</p></li>

<li><p>Sample program requires 3 services namely CacheService, AlertService  and ValidationService  to be started and ready before application can handle any request.</p></li>
</ul>

<pre><code class="language-java">import java.util.Date;
import java.util.concurrent.CountDownLatch;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CountDownLatchDemo {

    public static void main(String args[]) {
       final CountDownLatch latch = new CountDownLatch(3);
       Thread cacheService = new Thread(new Service(&quot;CacheService&quot;, 1000, latch));
       Thread alertService = new Thread(new Service(&quot;AlertService&quot;, 1000, latch));
       Thread validationService = new Thread(new Service(&quot;ValidationService&quot;, 1000, latch));
      
       cacheService.start(); //separate thread will initialize CacheService
       alertService.start(); //another thread for AlertService initialization
       validationService.start();
      
      
       //count is 3 since we have 3 Threads (Services)
      
       try{
            latch.await();  //main thread is waiting on CountDownLatch to finish
            System.out.println(&quot;All services are up, Application is starting now&quot;);
       }catch(InterruptedException ie){
           ie.printStackTrace();
       }
      
    }
  
}

/**
 * Service class which will be executed by Thread using CountDownLatch synchronizer.
 */
class Service implements Runnable{
    private final String name;
    private final int timeToStart;
    private final CountDownLatch latch;
  
    public Service(String name, int timeToStart, CountDownLatch latch){
        this.name = name;
        this.timeToStart = timeToStart;
        this.latch = latch;
    }
  
    @Override
    public void run() {
        try {
            Thread.sleep(timeToStart);
        } catch (InterruptedException ex) {
            Logger.getLogger(Service.class.getName()).log(Level.SEVERE, null, ex);
        }
        System.out.println( name + &quot; is Up&quot;);
        latch.countDown(); //reduce count of CountDownLatch by 1
    }  
}



</code></pre>

<h3 id="cylicbarrier">CylicBarrier</h3>

<ul>
<li><p><code>CyclicBarrier</code> is similar to <code>CountDownLatch</code> which we have seen in the last article  What is <code>CountDownLatch</code> in Java and allows multiple threads to wait for each other (barrier) before proceeding. The difference between <code>CountDownLatch</code> and <code>CyclicBarrier</code> is an also very popular multi-threading interview question in Java. <code>CyclicBarrier</code> is a natural requirement for a concurrent program because it can be used to perform final part of the task once individual tasks  are completed.</p></li>

<li><p>The demo of <code>CyclicBarrier</code> on which we initialize <code>CyclicBarrier</code> with 3 parties, means in order to cross barrier, 3 thread needs to call await() method. each thread calls await method in short duration but they don&rsquo;t proceed until all 3 threads reached the barrier, once all thread reach the barrier, barrier gets broker and each thread started their execution from that point.</p></li>
</ul>

<pre><code class="language-java">import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.`CyclicBarrier`;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CyclicBarrierDemo {

    //Runnable task for each thread
    private static class Task implements Runnable {

        private CyclicBarrier barrier;

        public Task(CyclicBarrier barrier) {
            this.barrier = barrier;
        }

        @Override
        public void run() {
            try {
                System.out.println(Thread.currentThread().getName() + &quot; is waiting on barrier&quot;);
                barrier.await();
                System.out.println(Thread.currentThread().getName() + &quot; has crossed the barrier&quot;);
            } catch (InterruptedException ex) {
                Logger.getLogger(CyclicBarrierDemo.class.getName()).log(Level.SEVERE, null, ex);
            } catch (BrokenBarrierException ex) {
                Logger.getLogger(CyclicBarrierDemo.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    public static void main(String args[]) {

        //creating CyclicBarrier with 3 parties i.e. 3 Threads needs to call await()
        final CyclicBarrier cb = new CyclicBarrier(3, new Runnable(){
            @Override
            public void run(){
                //This task will be executed once all thread reaches barrier
                System.out.println(&quot;All parties are arrived at barrier, lets play&quot;);
            }
        });

        //starting each of thread
        Thread t1 = new Thread(new Task(cb), &quot;Thread 1&quot;);
        Thread t2 = new Thread(new Task(cb), &quot;Thread 2&quot;);
        Thread t3 = new Thread(new Task(cb), &quot;Thread 3&quot;);

        t1.start();
        t2.start();
        t3.start();
      
    }
}

// Output:
// Thread 1 is waiting on barrier
// Thread 3 is waiting on barrier
// Thread 2 is waiting on barrier
// All parties have arrived at barrier, lets play
// Thread 3 has crossed the barrier
// Thread 1 has crossed the barrier
// Thread 2 has crossed the barrier

</code></pre>

<h3 id="producer-consumer-pattern">Producer / Consumer pattern</h3>

<ul>
<li><p>Producer Consumer Design pattern is a classic concurrency or threading pattern which reduces coupling between
Producer and Consumer by separating Identification of work with Execution of Work. In producer consumer design pattern a shared queue is used to control the flow and this separation allows you to code producer and consumer separately.</p></li>

<li><p>It is everywhere in real life and depict coordination and collaboration. Like one person is preparing food (Producer) while other one is serving food (Consumer), both will use shared table for putting food plates and taking food plates. Producer which is the person preparing food will wait if table is full and Consumer (Person who is serving food) will wait if table is empty. table is a shared object here. On Java library Executor framework itself implement Producer Consumer design pattern be separating responsibility of addition and execution of task.</p></li>
</ul>

<pre><code class="language-java">import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.logging.Level;
import java.util.logging.Logger;

public class ProducerConsumerPattern {

    public static void main(String args[]){
  
     //Creating shared object
     BlockingQueue sharedQueue = new LinkedBlockingQueue();
 
     //Creating Producer and Consumer Thread
     Thread prodThread = new Thread(new Producer(sharedQueue));
     Thread consThread = new Thread(new Consumer(sharedQueue));

     //Starting producer and Consumer thread
     prodThread.start();
     consThread.start();
    }
 
}

//Producer Class in java
class Producer implements Runnable {

    private final BlockingQueue sharedQueue;

    public Producer(BlockingQueue sharedQueue) {
        this.sharedQueue = sharedQueue;
    }

    @Override
    public void run() {
        for(int i=0; i&lt;10; i++){
            try {
                System.out.println(&quot;Produced: &quot; + i);
                sharedQueue.put(i);
            } catch (InterruptedException ex) {
                Logger.getLogger(Producer.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

}

//Consumer Class in Java
class Consumer implements Runnable{

    private final BlockingQueue sharedQueue;

    public Consumer (BlockingQueue sharedQueue) {
        this.sharedQueue = sharedQueue;
    }
  
    @Override
    public void run() {
        while(true){
            try {
                System.out.println(&quot;Consumed: &quot;+ sharedQueue.take());
            } catch (InterruptedException ex) {
                Logger.getLogger(Consumer.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
  
  
}

// Output:
// Produced: 0
// Produced: 1
// Consumed: 0
// Produced: 2
// Consumed: 1
// Produced: 3
// Consumed: 2
// Produced: 4
// Consumed: 3
// Produced: 5
// Consumed: 4
// Produced: 6
// Consumed: 5
// Produced: 7
// Consumed: 6
// Produced: 8
// Consumed: 7
// Produced: 9
// Consumed: 8
// Consumed: 9

</code></pre>

<h3 id="executor-thread-pool">Executor &ndash; Thread Pool</h3>

<ul>
<li><p>Java 1.5 introduced Thread pool in Java in the form of Executor framework, which allows Java programmer to decouple submission of a task to execution of the task. It also introduced a full feature built-in Thread Pool framework commonly known as Executor framework. Executor framework also provides different kind of Thread Pool e.g. <code>SingleThreadExecutor</code> which creates just one worker thread or <code>CachedThreadPool</code> which creates worker threads as and when necessary.</p></li>

<li><p>Demo of thread pool</p></li>
</ul>

<pre><code class="language-java">import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolDemo {

    public static void main(String args[]) {
       ExecutorService service = Executors.newFixedThreadPool(10);
       for (int i =0; i&lt;100; i++){
           service.submit(new Task(i));
       }
    }
  
}

final class Task implements Runnable{
    private int taskId;
  
    public Task(int id){
        this.taskId = id;
    }
  
    @Override
    public void run() {
        System.out.println(&quot;Task ID : &quot; + this.taskId +&quot; performed by &quot; + Thread.currentThread().getName());
    }  
}

// Output:
// Task ID : 0 performed by pool-1-thread-1
// Task ID : 7 performed by pool-1-thread-8
// Task ID : 8 performed by pool-1-thread-9
// Task ID : 6 performed by pool-1-thread-7
// Task ID : 4 performed by pool-1-thread-5
// Task ID : 5 performed by pool-1-thread-6
// Task ID : 3 performed by pool-1-thread-4
// Task ID : 1 performed by pool-1-thread-2
// ...
</code></pre>

<h3 id="submit-runnable">Submit(Runnable)</h3>

<blockquote>
<p>The submit(Runnable) method also takes a Runnable implementation, but returns a Future object. This Future object can be used to check if the Runnable as finished executing.</p>
</blockquote>

<h3 id="submit-callable">Submit(Callable)</h3>

<blockquote>
<p>The submit(Callable) method is similar to the submit(Runnable) method except for the type of parameter it takes. The Callable instance is very similar to a Runnable except that its call() method can return a result.</p>
</blockquote>

<h3 id="invokeany">InvokeAny()</h3>

<blockquote>
<p>The invokeAny() method takes a collection of Callable objects, or subinterfaces of Callable. If one of the tasks complete (or throws an exception), the rest of the Callable&rsquo;s are cancelled.</p>
</blockquote>

<h3 id="invokeall">InvokeAll()</h3>

<blockquote>
<p>The invokeAll() method invokes all of the Callable objects and returns a list of Future objects. Keep in mind that a task might finish due to an exception, so it may not have &ldquo;succeeded&rdquo;. There is no way on a Future to tell the difference.</p>
</blockquote>

<h3 id="demo-of-submit-invokeany">Demo of submit, InvokeAny</h3>

<pre><code class="language-java">import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.concurrent.ExecutionException;
import java.util.HashSet;
import java.util.Set;

public class SubmitInvokeDemo {

    public static void main(String args[]) throws InterruptedException, ExecutionException {


        ExecutorService executorService = Executors.newSingleThreadExecutor();

        Future future = executorService.submit(new Runnable() {
            public void run() {
                System.out.println(&quot;Asynchronous task&quot;);
            }
        });

        future.get();  //returns null if the task has finished correctly.

        Set&lt;Callable&lt;String&gt;&gt; callables = new HashSet&lt;Callable&lt;String&gt;&gt;();

        callables.add(new Callable&lt;String&gt;() {
            public String call() throws Exception {
                return &quot;Task 1&quot;;
            }
        });
        callables.add(new Callable&lt;String&gt;() {
            public String call() throws Exception {
                return &quot;Task 2&quot;;
            }
        });
        callables.add(new Callable&lt;String&gt;() {
            public String call() throws Exception {
                return &quot;Task 3&quot;;
            }
        });

        String result = executorService.invokeAny(callables);

        System.out.println(&quot;result = &quot; + result);

        executorService.shutdown();

    }
}

</code></pre>

<h2 id="join-and-fork">Join and Fork</h2>

<ul>
<li>Here is an introduction into the Fork/Join Framework that is part of the JDK since version 1.7.</li>
</ul>

<h3 id="join-and-fork-with-executor-service">Join and Fork with Executor Service</h3>

<ul>
<li>The demo code submit() our tasks to the ExecutorService and then use the returned instance of <code>Future</code> to wait() for the result. The normal
<code>ExecutorService</code> where you would have to block the current thread while waiting for a result. If we would only provide as many threads to the pool as we have CPUs available, the program would run out of resources and hang indefinitely.</li>
</ul>

<pre><code class="language-java">import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.concurrent.ExecutionException;
import java.util.Random;

public class FindMinTask implements Callable&lt;Integer&gt; {
    private int[] numbers;
    private int startIndex;
    private int endIndex;
    private ExecutorService executorService;

    public FindMinTask(ExecutorService executorService, int[] numbers, int startIndex, int endIndex) {
        this.executorService = executorService;
        this.numbers = numbers;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
    }

    public Integer call() throws Exception {

        int sliceLength = (endIndex - startIndex) + 1;
        if (sliceLength &gt; 2) {
            FindMinTask lowerFindMin = new FindMinTask(executorService, numbers, startIndex,
                    startIndex + (sliceLength / 2) - 1);
            Future&lt;Integer&gt; futureLowerFindMin = executorService.submit(lowerFindMin);
            FindMinTask upperFindMin = new FindMinTask(executorService, numbers, startIndex + (sliceLength / 2),
                    endIndex);
            Future&lt;Integer&gt; futureUpperFindMin = executorService.submit(upperFindMin);
            return Math.min(futureLowerFindMin.get(), futureUpperFindMin.get());
        } else {
            return Math.min(numbers[startIndex], numbers[endIndex]);
        }
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        int[] numbers = new int[100];
        Random random = new Random(System.currentTimeMillis());
        for (int i = 0; i &lt; numbers.length; i++) {
            numbers[i] = random.nextInt(100);
        }
        ExecutorService executorService = Executors.newFixedThreadPool(64);
        Future&lt;Integer&gt; futureResult = executorService
                .submit(new FindMinTask(executorService, numbers, 0, numbers.length - 1));
        System.out.println(futureResult.get());
        executorService.shutdown();
    }
}
</code></pre>

<h3 id="join-and-fork-with-joinforkpool">Join and Fork with JoinForkPool</h3>

<ul>
<li><p>The <code>ForkJoinPool</code> implements the already mentioned work-stealing strategy, i.e. every time a running thread has to wait for some result; the thread removes the current task from the work queue and executes some other task ready to run. This way the current thread is not blocked and can be used to execute other tasks. Once the result for the originally suspended task has been computed the task gets executed again and the join() method returns the result. This is an important difference between <code>JoinForkPool</code> and <code>ExecutorService</code>.</p></li>

<li><p>Demo of JoinForkPool</p></li>
</ul>

<pre><code class="language-java">import java.awt.*;
import java.awt.image.*;
import java.io.*;
import java.util.concurrent.ForkJoinPool;
import javax.imageio.*;
import java.util.concurrent.RecursiveAction;

public class GrayscaleImageAction extends RecursiveAction {
    private static final long serialVersionUID = 1L;
    private int row;
    private BufferedImage bufferedImage;

    public GrayscaleImageAction(int row, BufferedImage bufferedImage) {
        this.row = row;
        this.bufferedImage = bufferedImage;
    }

    @Override
    protected void compute() {
        for (int column = 0; column &lt; bufferedImage.getWidth(); column++) {
            int rgb = bufferedImage.getRGB(column, row);
            int r = (rgb &gt;&gt; 16) &amp; 0xFF;
            int g = (rgb &gt;&gt; 8) &amp; 0xFF;
            int b = (rgb &amp; 0xFF);
            int gray = (int) (0.2126 * (float) r + 0.7152 * (float) g + 0.0722 * (float) b);
            gray = (gray &lt;&lt; 16) + (gray &lt;&lt; 8) + gray;
            bufferedImage.setRGB(column, row, gray);
        }
    }

    public static void main(String[] args) throws IOException {
        ForkJoinPool pool = new ForkJoinPool(Runtime.getRuntime().availableProcessors());
        BufferedImage bufferedImage = ImageIO.read(new File(args[0]));
        for (int row = 0; row &lt; bufferedImage.getHeight(); row++) {
            GrayscaleImageAction action = new GrayscaleImageAction(row, bufferedImage);
            pool.execute(action);
        }
        pool.shutdown();
        ImageIO.write(bufferedImage, &quot;jpg&quot;, new File(args[1]));
    }
}

</code></pre>

				</section>
			</article>
		</main>
	</div> 

	

<div class="col-sm-3 col-sm-offset-1 doc-sidebar">
	<div id="sidebar">
	<div class="sidebar-module">
		<div class="sidebar-toc">
			<h4 class="sidebar-heading">Table of Contents</h4>
			<ul>
				<li><strong><a href="#title">Java Notes, Part-2</a></strong></li>
			</ul>
			<nav id="TableOfContents">
<ul>
<li><a href="#thread">Thread</a>
<ul>
<li><a href="#join">Join</a></li>
<li><a href="#common-problem-of-multithred-program">Common problem of multithred program</a>
<ul>
<li><a href="#deadlock">Deadlock</a></li>
<li><a href="#useful-concurrent-collections">Useful concurrent collections</a>
<ul>
<li><a href="#concurrenthashmap">ConcurrentHashMap</a></li>
<li><a href="#copyonwritearraylist-and-copyonwritearrayset">CopyOnWriteArrayList and CopyOnWriteArraySet</a></li>
<li><a href="#blockingqueue-and-deque">BlockingQueue and <code>Deque</code></a></li>
<li><a href="#concurrentskiplistmap-and-concurrentskiplistset">ConcurrentSkipListMap and ConcurrentSkipListSet</a></li>
</ul></li>
</ul></li>
<li><a href="#synchronizer">Synchronizer</a>
<ul>
<li><a href="#counter-semaphore">Counter Semaphore</a></li>
<li><a href="#countdownlatch">CountDownLatch</a></li>
<li><a href="#cylicbarrier">CylicBarrier</a></li>
<li><a href="#producer-consumer-pattern">Producer / Consumer pattern</a></li>
<li><a href="#executor-thread-pool">Executor &ndash; Thread Pool</a></li>
<li><a href="#submit-runnable">Submit(Runnable)</a></li>
<li><a href="#submit-callable">Submit(Callable)</a></li>
<li><a href="#invokeany">InvokeAny()</a></li>
<li><a href="#invokeall">InvokeAll()</a></li>
<li><a href="#demo-of-submit-invokeany">Demo of submit, InvokeAny</a></li>
</ul></li>
<li><a href="#join-and-fork">Join and Fork</a>
<ul>
<li><a href="#join-and-fork-with-executor-service">Join and Fork with Executor Service</a></li>
<li><a href="#join-and-fork-with-joinforkpool">Join and Fork with JoinForkPool</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
		</div>
	</div>
	<div class="sidebar-module">
		<h4 class="sidebar-heading">Pages in Categories</h4>
		<ul class="sidebar-category-list">
		
			<li>
				<a href="https://harryho.github.io/categories/article">
					<span class="doc-list-category">Article</span>
				</a>
				<ul>
					<li><a href="/article/vue-ng-react/">Angular vs React vs Vue</a>
					</li>
				
					<li><a href="/article/create-a-blog-on-github-pages/">Create a blog site on GitHub Pages</a>
					</li>
				
					<li><a href="/article/jira-notes/">JIRA Notes</a>
					</li>
				
					<li><a href="/article/build-mobile-app/">Build mobile app with web dev skills</a>
					</li>
				
					<li><a href="/article/azure-notes/">Azure notes</a>
					</li>
				
					<li><a href="/article/hello-world/">Do you have potential to be a programmer?</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/code">
					<span class="doc-list-category">Code</span>
				</a>
				<ul>
					<li><a href="/code/lcthw-lectures.2/">LCTHW C Lectures 2</a>
					</li>
				
					<li><a href="/code/lcthw-lectures.4/">LCTHW C Lectures 4</a>
					</li>
				
					<li><a href="/code/lcthw-lectures.3/">LCTHW C Lectures 3</a>
					</li>
				
					<li><a href="/code/lcthw-lectures.1/">LCTHW C Lectures 1</a>
					</li>
				
					<li><a href="/code/csharp-notes-1/">C# Notes -- Part 1</a>
					</li>
				
					<li><a href="/code/csharp-notes-2/">C# Notes -- Part 2</a>
					</li>
				
					<li><a href="/code/java-notes-3/">Java Notes, Part 3: Date Time API </a>
					</li>
				
					<li><a href="/code/javascript-oop/">JavaScript and Object Oriented Programming</a>
					</li>
				
					<li>
						<span class="active">Java Notes, Part-2</span>
						</li>
				
					<li><a href="/code/java-notes-1/">Java Notes, Part-1</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/dev">
					<span class="doc-list-category">Dev</span>
				</a>
				<ul>
					<li><a href="/dev/cntk-notes-1/">CNTK Notes, Part 1</a>
					</li>
				
					<li><a href="/dev/tensorflow-notes-1/">Tensorflow Notes, Part 1</a>
					</li>
				
					<li><a href="/dev/tensorflow-notes-2/">Tensorflow Notes, Part 2</a>
					</li>
				
					<li><a href="/dev/git-notes/">Git Notes</a>
					</li>
				
					<li><a href="/dev/php-web/">PHP web framework</a>
					</li>
				
					<li><a href="/dev/python-django/">Python Web framework</a>
					</li>
				
					<li><a href="/dev/php-debug/">Debug PHP with Eclipse PDT and Netbeans</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/info">
					<span class="doc-list-category">Info</span>
				</a>
				<ul>
					<li><a href="/os/ubuntu-desktop-14-extra-tools/">Ubuntu 14 -- desktop, extra tools</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/os">
					<span class="doc-list-category">Os</span>
				</a>
				<ul>
					<li><a href="/os/raspberrypi-notes/">Raspberry Pi setup</a>
					</li>
				
					<li><a href="/os/lubuntu16-desktop/">Lubuntu 16 desktop</a>
					</li>
				
					<li><a href="/os/grub-trouble-shooting/">Ubuntu 14 -- desktop setup &amp; dual boot </a>
					</li>
				
					<li><a href="/os/ubuntu-server-16/">Ubuntu 16 server note</a>
					</li>
				
					<li><a href="/os/centos-server-7/">CentOS 7 Server note</a>
					</li>
				
					<li><a href="/os/ubuntu-server-14/">Ubuntu 14 -- server setup</a>
					</li>
				
					<li><a href="/os/ubuntu-desktop-14/">Ubuntu 14 -- desktop setup &amp; dual boot </a>
					</li>
				
					<li><a href="/os/use-windows-command-hotkey-as-hacker-3/">Use Windows command &amp; hotkey as a hacker - Part 3</a>
					</li>
				
					<li><a href="/os/use-windows-command-hotkey-as-hacker-2/">Use Windows command &amp; hotkey as a hacker - Part 2</a>
					</li>
				
					<li><a href="/os/use-windows-command-hotkey-as-hacker-1/">Use Windows command &amp; hotkey as a hacker - Part 1</a>
					</li>
				
					<li><a href="/os/centos-fedora-desktop/">CentOS 6/7 Multi-Boot Setup</a>
					</li>
				
				</ul>
			</li>
		
			<li>
				<a href="https://harryho.github.io/categories/project">
					<span class="doc-list-category">Project</span>
				</a>
				<ul>
					<li><a href="/project/python-flat-api/">FlatApi -- A handy Restful API for python developer</a>
					</li>
				
					<li><a href="/project/reetek-angular4-crm/">Angular 4 Crm Project</a>
					</li>
				
					<li><a href="/project/laravel-mvc-starter/">Laravel MVC Starter</a>
					</li>
				
					<li><a href="/project/reetek-react-crm/">React Redux Crm Project</a>
					</li>
				
					<li><a href="/project/reetek-vue2-admin/">Vue 2 Admin Project</a>
					</li>
				
					<li><a href="/project/reetek-vue2-crm/">Vue 2 Crm Project</a>
					</li>
				
					<li><a href="/project/angularjs-webpack-es6-starter/">Angularjs Webpack ES6 Starter</a>
					</li>
				
					<li><a href="/project/zf2-mvc-starter/">Zendframework 2 MVC Starter</a>
					</li>
				
				</ul>
			</li>
		
		</ul>
	</div>
	<div class="sidebar-module">
		<h4 class="sidebar-heading">Tags</h4>
		<div class="tag-box">
		
			<a class="tag-item" href="https://harryho.github.io/tags/agile">agile</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/ai">ai</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/angularjs">angularjs</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/azure">azure</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/c">c</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/centos">centos</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/cmd">cmd</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/git">git</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/hugo">hugo</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/itext">itext</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/java">java</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/javascript">javascript</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/linux">linux</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/mobile">mobile</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/oo">oo</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/php">php</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/python">python</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/pythoon">pythoon</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/raspberry-pi">raspberry-pi</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/ubuntu">ubuntu</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/webpack">webpack</a>
		
			<a class="tag-item" href="https://harryho.github.io/tags/windows">windows</a>
		
		</div>
	</div>
	</div>
</div>

</div> 
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'harryho';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<hr />

<div class="row">
	<div class="col-sm-8">
		<p class="doc-footer-em"><a href="#" onclick="resetSidebarPos()">Back to TOP</a></p>
	</div>
</div>

</div> 

<footer class="doc-footer">
	<p class="doc-footer-em">Browse <strong><a href="https://github.com/harryho/harryho.github.io.git">Repository</a></strong></p>
	<p>Copyright (c) 2015, harryho; All rights reserved.</p>
	<p>Powered by <strong><a href="https://github.com/key-amb/hugo-theme-bootie-docs">Bootie Docs</a></strong> - theme for <a href="http://gohugo.io/">Hugo</a> by <a href="https://github.com/key-amb/">key-amb</a>.</p>
</footer>



<script src="https://harryho.github.io/js/jquery.min.js"></script>
<script src="https://harryho.github.io/js/bootstrap.min.js"></script>

<script src="https://harryho.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://harryho.github.io/js/ie10-viewport-bug-workaround.js"></script>
<script src="https://harryho.github.io/js/bootie-docs.js"></script>
<script>
	console.log( hljs.listLanguages());
</script>
<script id="dsq-count-scr" src="//harryho.disqus.com/count.js" async></script>


</body>
</html>
